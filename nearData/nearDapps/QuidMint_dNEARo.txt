*GitHub Repository "QuidMint/dNEARo"*

'''--- .env ---
NEAR_NETWORK=testnet
'''
'''--- Cargo.toml ---
[package]
name = "quid"
version = "1.0.0"
authors = ["Johnny Quid <john@quid.io>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[dependencies]
libm = "0.2.1"
uint = { version = "0.9.2", default-features = false }
near-sdk = "3.1.0"
near-contract-standards = "3.1.0"
# =4.0.0-pre.7
'''
'''--- README.md ---
ðŸ‘â€ðŸ—¨U!D
===================

Uses [near-contract-standards] and [simulation] tests. 

  [Fungible Token]: https://nomicon.io/Standards/Tokens/FungibleTokenCore.html
  [near-contract-standards]: https://github.com/near/near-sdk-rs/tree/master/near-contract-standards
  [simulation]: https://github.com/near/near-sdk-rs/tree/master/near-sdk-sim

## Compiling

Follow instructions for installing Rust here https://docs.near.org/docs/tutorials/contracts/intro-to-rust#3-step-rust-installation (if you're using Gitpod, you can skip this step).

To build run:
```bash
./build.sh
```

## Testing
Discontinued support for NEAR in solidarity with Wintermute
https://twitter.com/EvgenyGaevoy/status/1722019542220607602

'''
'''--- build.sh ---
#!/bin/bash

set -e
cd "`dirname $0`"

RUSTFLAGS='-C link-arg=-s' cargo build --all --target wasm32-unknown-unknown --release

mkdir res

cp -R ./target/wasm32-unknown-unknown/release/*.wasm ./res/

'''
'''--- package.json ---
{
    "name": "quid-near",
    "version": "1.0.0",
    "description": "",
    "main": "index.js",
    "scripts": {
        "hoist-credentials": "mkdir ./neardev/testnet && mkdir ./neardev/mainnet && node ./scripts/hoist-credentials.js",
        "deploy": "(near dev-deploy --wasmFile=./res/quid.wasm || exit 0) && node ./scripts/patch-config.js",
        "dev": "rm -rf res && ./build.sh && rm -rf neardev && npm run deploy && npm run hoist-credentials && npm run test",
        "test": "mocha ./scripts/app.test.js --timeout 42000"
    },
    "keywords": [],
    "author": "",
    "license": "ISC",
    "dependencies": {
        "bn": "^1.0.5",
        "bn.js": "^5.2.0",
        "chai": "^4.3.4",
        "dotenv": "^9.0.0",
        "js-sha256": "^0.9.0",
        "mocha": "^9.0.3",
        "near-api-js": "^0.42.0",
        "near-units": "^0.1.9"
    }
}

'''
'''--- scripts/app.test.js ---

var chai = require('chai')   
var assert = chai.assert 
const BN = require('bn.js') 

// const { NEAR, Gas, parse } = require('near-units') 

const nearAPI = require('near-api-js') 
const testUtils = require('./test-utils') 
const { contractAccount } = require('./near-utils')
const getConfig = require('./config') 

const { Account, functionCall, utils: { format: { parseNearAmount }} } = nearAPI 
const { connection, initContract, getAccount, getContract } = testUtils 
const { GAS, contractName } = getConfig() 

describe('Tests for ' + contractName, () => {
	let alice
	let bob
	let carl
	let david
	before(async () => {
		await initContract() 

		let state = (await new Account(connection, contractName)).state() 
		assert(state.code_hash !== '11111111111111111111111111111111', "bad") 

		alice = await getAccount()
		bob = await getAccount()
		carl = await getAccount()
		david = await getAccount()
	}) 
    it('borrow QD against NEAR', async () => {
		const contract = await getContract(alice)
		
		// var deposited = parseNearAmount('1.00')
		var borrowed = parseNearAmount('12')	
		var deposited = parseNearAmount('1.0')
		// // var borrowed = parseNearAmount('6.755')	

		try { // should fail
			var result = await alice.functionCall(contractName, 'borrow', {
				amount: borrowed, 
				short: false
			}, GAS, deposited) 
			
			// var result = await bob.functionCall(contractName, 'deposit', {
			// 	qd_amt: parseNearAmount('0.5'), // not staking QD...
			// 	//  NEAR with attached_deposit...not staking collat
			// 	live: false // it's a solvency deposit
			// }, GAS, 1) 
			// console.log('deposited')
			
			// console.log(deposited)
			// var result = await alice.functionCall(contractName, 'swap', {
			// 	amount: "0", 				
			// 	repay: false,
			// 	short: true
			// }, GAS, parseNearAmount('0.4')) 

		} catch (err) {
			assert.include(err.message, "Cannot do operation that would result in CR below min")
		}
		// try { // should fail
		// 	var result = await alice.functionCall(contractName, 'borrow', {
		// 		amount: borrowed, 
		// 		short: false
		// 	}, GAS, deposited) 
		// } catch (err) {
		// 	assert.include(err.message, "Cannot do operation that would result in CR below min")
		// }
		// let tmp = borrowed
		// borrowed = deposited
		// deposited = tmp

		// result = await alice.functionCall(contractName, 'borrow', {
		// 	amount: borrowed, 
		// 	short: false
		// }, GAS, deposited) 
		
		let balance = await contract.get_qd_balance({ account: alice.accountId}) 
		let pledge = await contract.get_pledge({ account: alice.accountId}) 
		let stats = await contract.get_pool_stats({}) 
		
		console.log('pledge', pledge)
		console.log('stats', stats)
		console.log('balance', balance)
		
		// assert.equal(stats.live_long_debit, borrowed)
		// assert.equal(stats.live_long_credit, deposited)
	})

	// it('deposit NEAR into SP so it can be loaned out', async () => {
	// 	const contract = await getContract(bob) 
	// 	let final = parseNearAmount('2.42')
	// 	var deposit = parseNearAmount('2.69')

	// 	var result = await bob.functionCall(contractName, 'deposit', {
	// 		amount: parseNearAmount('0'), // not staking QD, but NEAR with attached_deposit
	// 		live: false // not staking collateral, but solvency deposit
	// 	}, GAS, deposit) 

	// 	result = await bob.functionCall(contractName, 'renege', {
	// 		amount: parseNearAmount('0.27'), // 2.69 - 2.42
	// 		sp: true, // we are withdrawing from the SolvencyPool
	// 		qd: false, // we are withdrawing NEAR
	// 	}, GAS) 

	// 	const pledge = await contract.get_pledge({ account: bob.accountId}) 
	// 	assert.equal(pledge.near_sp, final)

	// 	const stats = await contract.get_pool_stats({}) 
	// 	assert.equal(stats.spool_debit, final)
	// })

	// it('borrow NEAR against QD', async () => {
	// 	const contract = await getContract(alice) 
	// 	let borrowed = parseNearAmount('3.0')
	// 	let available = parseNearAmount('2.42') // staked amount from last unit
	// 	let minimum = parseNearAmount('2.662')

	// 	let balanceBefore = await alice.getAccountBalance() 
	// 	console.log('balanceBefore', balanceBefore)
		
	// 	let result = await alice.functionCall(contractName, 'borrow', {
	// 		amount: borrowed, 
	// 		short: true
	// 	}, GAS, 1)
	// 	let pledge = await contract.get_pledge({ account: alice.accountId}) 
	// 	let stats = await contract.get_pool_stats({}) 

	// 	assert.equal(pledge.s_debit, available) 
	// 	assert.equal(pledge.s_credit, minimum)	
		
	// 	assert.equal(stats.live_short_debit, available)
	// 	assert.equal(stats.live_short_credit, minimum)

	// 	let balanceAfter = await alice.getAccountBalance()
	// 	let bb = new BN(balanceBefore.available)
	// 	let ba = new BN(balanceAfter.available)

	// 	let delta = ba.sub(bb).toString(10).substring(3)
	// 	assert.isAbove(parseFloat(delta), 2.416)
	// }) 
	// it('describe your test', async () => {
	// 	const contract = await getContract(alice) 
		

	// }) 

	// it('borrow short', async () => {
	// 	alice = await getAccount()

	// 	console.log('alice')
	// 	console.log(alice)
	// 	console.log('bob') 
	// 	console.log(bob) // TODO bob has the same accountId as Alice :/
		
	// 	const contract = await getContract(alice) 
	// 	// let result = await contract.borrow({ amount: parseNearAmount('0.123'), short: false }, GAS, parseNearAmount('1.0')) 
	// 	let amt = parseNearAmount('0.123')
		
	// 	let result = await alice.functionCall(contractName, 'borrow', {
	// 		amount: amt, 
	// 		short: false
	// 	}, GAS, parseNearAmount('1.0')) 
		
	// 	const pledge = await contract.get_pledge({ account: alice.accountId}) 
	// 	console.log(pledge)

	// 	const stats = await contract.get_pool_stats({}) 
	// 	console.log(stats)
	// 	let live_long_debit = stats.live_long_debit
	// 	console.log('live_long_debit', live_long_debit)
	// 	expect(live_long_debit).toEqual(amt) 

	// 	const pstats = await contract.get_stats({account: alice.accountId, short: false}) 
	// 	console.log(pstats)

	// 	let balanceBefore = await alice.getAccountBalance() 
	// 	console.log('balanceBefore', balanceBefore)

	// 	// expect(balance).toEqual(parseNearAmount('1')) 
	// }) 
}) 

'''
'''--- scripts/config.js ---

// Load environment variables
require("dotenv").config();

const near = require("near-api-js");

const contractName = 'dev-1650458016217-97126526854058';

// Configure the directory where NEAR credentials are going to be stored
// const credentialsPath = "./credentials";

// Configure the keyStore to be used with the NEAR Javascript API
// const UnencryptedFileSystemKeyStore = near.keyStores.UnencryptedFileSystemKeyStore;
// const keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);

module.exports = function getConfig() {
	let config = {
		networkId:   process.env.NEAR_NETWORK,
        nodeUrl:     'https://rpc.testnet.near.org', //process.env.NEAR_NODE_URL,
        walletUrl:   `https://wallet.${process.env.NEAR_NETWORK}.near.org`,
        helperUrl:   `https://helper.${process.env.NEAR_NETWORK}.near.org`,
        explorerUrl: `https://explorer.${process.env.NEAR_NETWORK}.near.org`,
		contractName,
		contractMethods: {
			viewMethods: [
				"get_pledge",
				"get_qd_balance",
				"get_pledges",
				"get_pool_stats",
				"get_pledge_stats"
			  ], // our read function
			  changeMethods: [
				"deposit", // add param vote
				"borrow",
				"renege",
				"fold",
				"swap",
				"split",
				// not called by users
				"update",
				"clip",	
				"new"
			  ],
		},
	};
	if (!process.env.PROD) {
		config = {
			...config,
			GAS: '300000000000000',
			DEFAULT_NEW_ACCOUNT_AMOUNT: '5',
		};
	}
	else { // AKA prod
		config = {
			...config,
			networkId: 'mainnet',
			nodeUrl: 'https://rpc.mainnet.near.org',
			walletUrl: 'https://wallet.near.org',
			helperUrl: 'https://helper.mainnet.near.org',
			contractName: 'quid.near',
			// keyStore:    keyStore
		};
	}
	return config;
};

'''
'''--- scripts/hoist-credentials.js ---
const fs = require('fs');
const getConfig = require('./config');
const { networkId, contractName } = getConfig();

console.log(
	"Copying Credentials to Repo:\n",
	`${process.env.HOME}/.near-credentials/${networkId}/${contractName}.json`
);

fs.copyFile(`${process.env.HOME}/.near-credentials/${networkId}/${contractName}.json`, `./neardev/${networkId}/${contractName}.json`, (err) => {
    if (err) throw err;
    console.log('source.txt was copied to destination.txt');
});
'''
'''--- scripts/legacy-test.js ---
// Load environment variables
require("dotenv").config();

// Load Near Javascript API components
const near = require("near-api-js");
const { sha256 } = require("js-sha256");
const fs = require("fs");

// Configure the directory where NEAR credentials are going to be stored
const credentialsPath = "./credentials";

// Configure the keyStore to be used with the NEAR Javascript API
const UnencryptedFileSystemKeyStore = near.keyStores.UnencryptedFileSystemKeyStore;
const keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);

// Setup default client options
const options = {
  networkId:   process.env.NEAR_NETWORK,
  nodeUrl:     process.env.NEAR_NODE_URL,
  walletUrl:   `https://wallet.${process.env.NEAR_NETWORK}.near.org`,
  helperUrl:   `https://helper.${process.env.NEAR_NETWORK}.near.org`,
  explorerUrl: `https://explorer.${process.env.NEAR_NETWORK}.near.org`,
  accountId:   process.env.NEAR_ACCOUNT, 
  keyStore:    keyStore
}

// Formatter helper for Near amounts
function formatAmount(amount) {
  return BigInt(near.utils.format.parseNearAmount(amount.toString()));
};

async function createAccount() {
  let keyPair;

  // Configure the client with options and our local key store
  const client = await near.connect(options);

  // Configure the key pair file location
  const keyRootPath = client.connection.signer.keyStore.keyDir;
  const keyFilePath = `${keyRootPath}/${options.networkId}/${options.accountId}.json`;

  // Check if the key pair exists, and create a new one if it does not
  if (!fs.existsSync(keyFilePath)) {
    console.log("Generating a new key pair")
    keyPair = near.KeyPair.fromRandom("ed25519");
  } else {
    let content = JSON.parse(fs.readFileSync(keyFilePath).toString());
    keyPair = near.KeyPair.fromString(content.private_key);

    console.log(`Key pair for account ${options.accountId} already exists, skipping creation`);
  }

  // Create a key pair in credentials directory
  await client.connection.signer.keyStore.setKey(options.networkId, options.accountId, keyPair);

  // Determine if account already exists
  try {
    await client.account(options.accountId)
    //return console.log(`Sorry, account '${options.accountId}' already exists.`);
  }
  catch (e) {
    if (!e.message.includes("does not exist while viewing")) {
      throw e;
    }
  }

  // Generate a public key for account creation step
  const publicKey = keyPair.getPublicKey()

  // Create the account
  try {
    const response = await client.createAccount(options.accountId, publicKey);
    console.log(`Account ${response.accountId} for network "${options.networkId}" was created.`);
    console.log("----------------------------------------------------------------");
    console.log("OPEN LINK BELOW to see account in NEAR Explorer!");
    console.log(`${options.explorerUrl}/accounts/${response.accountId}`);
    console.log("----------------------------------------------------------------");
  }
  catch(error) {
    console.log("ERROR:", error);
  }
}

async function getInfo() {
    // Configure the client with options
    const client = await near.connect(options);
    const provider = client.connection.provider;
    console.log("Client config:", client.config);

    // Let's get our own account status
    const account = await client.account(options.accountId);
    console.log("account state:", await account.state());
      
    // Get current node status
    const status = await provider.status();
    console.log("Status:", status);

    // Get the latest block
    let block = await provider.block({ finality: "final" });
    console.log("current block:", block);

    // Get the block by number
    block = await provider.block({ blockId: status.sync_info.latest_block_height });
    console.log("block by height:", block);

    // Get current gas price from the block header
    const anotherBlock = await provider.sendJsonRpc("block", { finality: "final" });
    console.log("gas price from header:", anotherBlock.header.gas_price);

    // Let's get the current validator set for the network
    const validators = await provider.validators(block.header.epoch_id);
    console.log("network validators:", validators);
}

async function makeTransfer() {
  const txSender = options.accountId;
  const txReceiver = "quid.testnet";
  const txAmount = formatAmount(1);

  const client = await near.connect(options);
  const account = await client.account(txSender);
  const provider = client.connection.provider;
  // Create a simple money transfer using helper method
  console.log(`Sending money to ${txReceiver}`);
  /*
  try {
    const result = await account.sendMoney(txReceiver, txAmount);

    console.log("Creation result:", result.transaction);
    console.log("----------------------------------------------------------------");
    console.log("OPEN LINK BELOW to see transaction in NEAR Explorer!");
    console.log(`${options.explorerUrl}/transactions/${result.transaction.hash}`);
    console.log("----------------------------------------------------------------");

    setTimeout(async function() {
      console.log("Checking transaction status:", result.transaction.hash);

      const status = await provider.sendJsonRpc("tx", [result.transaction.hash, options.accountId]);
      console.log("Transaction status:", status);
    }, 5000);
  }
  catch(error) {
    console.log("ERROR:", error);
  }
  */
  const keyRootPath = client.connection.signer.keyStore.keyDir;
  const keyFilePath = `${keyRootPath}/${options.networkId}/${options.accountId}.json`;
  // Load key pair from the file
  const content = JSON.parse(fs.readFileSync(keyFilePath).toString());
  const keyPair = near.KeyPair.fromString(content.private_key);

  // Get the sender public key
  const publicKey = keyPair.getPublicKey();
  console.log("Sender public key:", publicKey.toString())

  // Get the public key information from the node
  const accessKey = await provider.query(
    `access_key/${txSender}/${publicKey.toString()}`, ""
  );
  console.log("Sender access key:", accessKey);

  // Check to make sure provided key is a full access key
  if (accessKey.permission !== "FullAccess") {
    return console.log(`Account [${txSender}] does not have permission to send tokens using key: [${publicKey}]`);
  };

  // Each transaction requires a unique number or nonce
  // This is created by taking the current nonce and incrementing it
  const nonce = ++accessKey.nonce;
  console.log("Calculated nonce:", nonce);

   // Construct actions that will be passed to the createTransaction method below
   const actions = [near.transactions.transfer(txAmount)];

   // Convert a recent block hash into an array of bytes.
   // This is required to prove the tx was recently constructed (within 24hrs)
   const recentBlockHash = near.utils.serialize.base_decode(accessKey.block_hash);
 
   // Create a new transaction object
   const transaction = near.transactions.createTransaction(
     txSender,
     publicKey,
     txReceiver,
     nonce,
     actions,
     recentBlockHash
   );
 
   // Before we can sign the transaction we must perform three steps
   // 1) Serialize the transaction in Borsh
   const serializedTx = near.utils.serialize.serialize(
     near.transactions.SCHEMA,
     transaction
   );
 
   // 2) Hash the serialized transaction using sha256
   const serializedTxHash = new Uint8Array(sha256.array(serializedTx));
 
   // 3) Create a signature using the hashed transaction
   const signature = keyPair.sign(serializedTxHash);
 
   // Sign the transaction
   const signedTransaction = new near.transactions.SignedTransaction({
     transaction,
     signature: new near.transactions.Signature({
       keyType: transaction.publicKey.keyType,
       data: signature.signature
     })
   });
 
   // Send the transaction
   try {
     const result = await provider.sendTransaction(signedTransaction);
 
     console.log("Creation result:", result.transaction);
     console.log("----------------------------------------------------------------");
     console.log("OPEN LINK BELOW to see transaction in NEAR Explorer!");
     console.log(`${options.explorerUrl}/transactions/${result.transaction.hash}`);
     console.log("----------------------------------------------------------------");
 
     setTimeout(async function() {
       console.log("Checking transaction status:", result.transaction.hash);
 
       const status = await provider.sendJsonRpc("tx", [result.transaction.hash, options.accountId]);
       console.log("Transaction status:", status);
     }, 5000);
   }
   catch(error) {
     console.log("ERROR:", error);
   }
 
}

async function test() {
   // Configure the client with options and our local key store
   const client = await near.connect(options);
   const account = await client.account(options.accountId);
 
   // We'are using the same contract name, feel free to create a different one.
   const contractName = options.accountId;
 
   // Construct a new contract object, we'll be using it to perform calls
   const contract = new near.Contract(account, contractName, {
      viewMethods: [
        "get_pledge",
        "get_num_pledges",
        "get_pledges",
        "get_top"
      ], // our read function
      changeMethods: [
        "new",
        "sync",
        "register",
        "re_pledge",
        "clip",
        "renege",
        "borrow",
        "stake",
        "redeem",
      ], // our write function
      sender: options.accountId,   // account used to sign contract call transactions
   });
   
   // Initialize the contract
   
   try {
     result = await account.functionCall(
      contractName, "new",
      { 
        "owner_id": contractName,
        //"total_supply": "10" 
      }
     );
     console.log(result);
   } catch(e) {
     console.log(e)
   }
    
    // result = await account.functionCall(
    //   contractName, "borrow",
    //   { "amount": "8" }, 0, 10
    // );
    // console.log(result);
    result = await account.functionCall(
      contractName, "sync", {}
    );
    console.log(result);
    /*
    console.log("==== Get_NUM_Pledges ====");
    result = await contract.get_num_pledges({
      'account': contractName
    });
    console.log("Result:", result);
    */
    // console.log("==== Get_Pledge ====");
    // result = await contract.get_pledge({
    //   'account': contractName
    // });
    // console.log("Result:", result);
    
    // result = await account.functionCall(
    //   contractName, "renege",
    //   { "amount": "2", "ins": false }
    // );
    // console.log(result);
    
    // console.log("==== Get_Pledge ====");
    // result = await contract.get_pledge({
    //   'account': contractName
    // });
    // console.log("Result:", result);
}
  
//main();
test();
'''
'''--- scripts/near-utils.js ---

require("dotenv").config();
const fs = require('fs');
const nearAPI = require('near-api-js');
const getConfig = require('./config');
const { nodeUrl, networkId, contractName, contractMethods } = getConfig();
const {
    keyStores: { InMemoryKeyStore },
    Near, Account, Contract, KeyPair,
    utils: {
        format: {
            parseNearAmount
        }
    }
} = nearAPI;

// const credentials = JSON.parse(fs.readFileSync(process.env.HOME + '/.near-credentials/testnet/' + contractName + '.json'));
// const keyStore = {
//     keys: {},
// 	getKey(networkId, accountId) {
// 		const value = this.keys[`${accountId}:${networkId}`];
//         if (!value) {
//             return null;
//         }
//         return KeyPair.fromString(value);
//     },
//     setKey(networkId, accountId, keyPair) {
//         this.keys[`${accountId}:${networkId}`] = keyPair.toString();
//     }
// };
// keyStore.setKey(networkId, contractName, KeyPair.fromString(credentials.private_key))

const credPath = `./neardev/${networkId}/${contractName}.json`
console.log(
	"Loading Credentials:\n",
	credPath
);

let credentials
try {
	credentials = JSON.parse(
		fs.readFileSync(
			credPath
		)
	);
} catch(e) {
	console.warn(e)
	/// attempt to load backup creds from local machine
	credentials = JSON.parse(
		fs.readFileSync(
			`${process.env.HOME}/.near-credentials/${networkId}/${contractName}.json`
		)
	);
}
const keyStore = new InMemoryKeyStore();
keyStore.setKey(
	networkId,
	contractName,
	KeyPair.fromString(credentials.private_key)
);

const near = new Near({
	networkId, nodeUrl,
	deps: { keyStore },
});
const { connection } = near
const contractAccount = new Account(connection, contractName);
const contract = new Contract(contractAccount, contractName, contractMethods);

module.exports = {
    near,
    keyStore,
    connection,
    contract,
    contractName,
    contractAccount,
    contractMethods
}

'''
'''--- scripts/patch-config.js ---

const fs = require('fs');
const contractName = fs.readFileSync('./neardev/dev-account').toString()
const path = './scripts/config.js'
 
fs.readFile(path, 'utf-8', function(err, data) {
    if (err) throw err;
 
    data = data.replace(/.*const contractName.*/gim, `const contractName = '${contractName}';`);
 
    fs.writeFile(path, data, 'utf-8', function(err) {
        if (err) throw err;
        console.log('Done!');
    })
})

'''
'''--- scripts/sanity-check.js ---

// erf(x): error function (see: https://en.wikipedia.org/wiki/Error_function)
// by https://github.com/jeremybarnes/cephes/blob/master/cprob/ndtr.c
const P = [
  2.46196981473530512524E-10,
  5.64189564831068821977E-1,
  7.46321056442269912687E0,
  4.86371970985681366614E1,
  1.96520832956077098242E2,
  5.26445194995477358631E2,
  9.34528527171957607540E2,
  1.02755188689515710272E3,
  5.57535335369399327526E2,
];
const Q = [
  1.32281951154744992508E1,
  8.67072140885989742329E1,
  3.54937778887819891062E2,
  9.75708501743205489753E2,
  1.82390916687909736289E3,
  2.24633760818710981792E3,
  1.65666309194161350182E3,
  5.57535340817727675546E2,
];
const R = [
  5.64189583547755073984E-1,
  1.27536670759978104416E0,
  5.01905042251180477414E0,
  6.16021097993053585195E0,
  7.40974269950448939160E0,
  2.97886665372100240670E0,
];
const S = [
  2.26052863220117276590E0,
  9.39603524938001434673E0,
  1.20489539808096656605E1,
  1.70814450747565897222E1,
  9.60896809063285878198E0,
  3.36907645100081516050E0,
];
const T = [
  9.60497373987051638749E0,
  9.00260197203842689217E1,
  2.23200534594684319226E3,
  7.00332514112805075473E3,
  5.55923013010394962768E4,
];
const U = [
  3.35617141647503099647E1,
  5.21357949780152679795E2,
  4.59432382970980127987E3,
  2.26290000613890934246E4,
  4.92673942608635921086E4,
];
const MAXLOG = Math.log(Number.MAX_VALUE)

function polevl(x, c) {
  return c.reduce((r, c) => r * x + c, 0)
}
function p1evl(x, c) {
  return c.reduce((r, c) => r * x + c, 1)
}

function erf(x) {
  if (Math.abs(x) > 1) return 1 - erfc(x)
  const z = x * x
  return x * polevl(z, T) / p1evl(z, U)
}

// erfc(x) = 1 - erf(x)
function erfc(x0) {
  const x = Math.abs(x0)
  if (x < 1) return 1 - erf(x)
  const z = -x0 * x0
  if (z < -MAXLOG) return x0 < 0 ? 2 : 0
  const [p, q] = x < 8 ? [P, Q] : [R, S]
  const y = Math.exp(z) * polevl(x, p) / p1evl(x, q)
  return x0 < 0 ? 2 - y : y
}

function RationalApproximation(t) {
  // Abramowitz and Stegun formula 26.2.23.
  // The absolute value of the error should be less than 4.5 e-4.
  let c = [2.515517, 0.802853, 0.010328]
  let d = [1.432788, 0.189269, 0.001308]
  return t - ((c[2] * t + c[1]) * t + c[0]) /
      (((d[2] * t + d[1]) * t + d[0]) * t + 1.0)
}

function NormalCDFInverse(p) {
  if (p < 0.5) { // F^-1(p) = -G^-1(p)
      let n = -2.0 * Math.log(p)
      return -1.0 * RationalApproximation(Math.sqrt(n))
  }
  else { // F^-1(p) = G^-1(1-p)
      let l = 1.0 - p
      let n = -2.0 * Math.log(l)
      return RationalApproximation(Math.sqrt(n))
  }
}

function stress(alpha, sqrt_var, short) { // max portfolio loss in %
  let sqrt2pi = Math.sqrt(2.0 * Math.PI)
  let d = NormalCDFInverse(alpha)
  let e1 = -1.0 * (d * d) / 2.0
  let e2
  if (short) {
    e2 = Math.exp(e1) / sqrt2pi / (1.0 - alpha) * sqrt_var
    return Math.exp(e2) - 1.0
  } else {
    e2 = -1.0 * (Math.exp(e1) / sqrt2pi / (1.0 - alpha) * sqrt_var)
    return -1.0 * (Math.exp(e2) - 1.0)
  }
}

// stress test the collateral portfolio of each user, as measured by CVaR
// record amount by which user's stressed collateral value would drop below user's debt
function stressPledge(p, print = false) {
  let vol1 = 0.4
  let price1 = 1
  let vol2 = 0.9
  let price2 = 2
  
  let iW = (p.coll[0] * price1)
  let jW = (p.coll[1] * price2)
  let totalVal = iW + jW
  iW /= totalVal
  jW /= totalVal

  let portVariance = 2.0 * iW * jW * vol1 * vol2;
  portVariance += Math.pow(iW, 2) * Math.pow(vol1, 2);
  portVariance += Math.pow(jW, 2) * Math.pow(vol2, 2);
  
  let vol = Math.sqrt(portVariance)

  let stresscol = stress(0.90, vol, false) 
  //console.log('stresscol...', stresscol)

  let svalueofcol = (1.0 - stresscol) * totalVal
  //console.log('svalueofcol...', svalueofcol)
  
  let svalueofcole = Math.max(p.debt - svalueofcol, 0.0)
  //console.log('svalueofcole...', svalueofcole)

  if (print) {
      console.log('...vol...', vol)
      console.log('stresscol...', stresscol) 
      console.log('svalueofcol...', svalueofcol)
      console.log('svalueofcole...', svalueofcole)  
  }
  return svalueofcole
}

function compareColl() {
    let trin = {
        debt: 1500,
        coll: [1200, 100],
    }
    let neo = {
        debt: 1234,
        coll: [1888, 42]
    }
    let morph = {
        debt: 666,
        coll: [888, 420]
    }    

    // --------------------------------------------------------------------------
    let pool = {
        debt: trin.debt + neo.debt + morph.debt,
        coll: [
                (trin.coll[0] + neo.coll[0] + morph.coll[0]),
                (trin.coll[1] + neo.coll[1] + morph.coll[1])
              ],
    }
    let trinPool = {
        debt: trin.debt + neo.debt + morph.debt,
        coll: [
                (trin.coll[0] + neo.coll[0] + morph.coll[0]),
                (trin.coll[1] + neo.coll[1] + morph.coll[1])
              ],
    }
    let morphPool = {
        debt: trin.debt + neo.debt + morph.debt,
        coll: [
                (trin.coll[0] + neo.coll[0] + morph.coll[0]),
                (trin.coll[1] + neo.coll[1] + morph.coll[1])
              ],
    }
    let neoPool = {
        debt: trin.debt + neo.debt + morph.debt,
        coll: [
                (trin.coll[0] + neo.coll[0] + morph.coll[0]),
                (trin.coll[1] + neo.coll[1] + morph.coll[1])
              ],
    }

    let total = stressPledge(pool)
    console.log('total', total)

    let tally = 0 // we are testing if the aggregated s_val_col_e equals 
    // from the one received at the bottom (where portfolio's stressed as a whole)
    let sum_deltas = 0
    // --------------------------------------------------------------------------
    
    trin['stress'] = stressPledge(trin)
    tally += trin['stress']
    console.log("trin['stress']...", trin['stress'])
    // remove user from pool
    trinPool['debt'] -= trin['debt']
    trinPool['coll'][0] -= trin['coll'][0]
    trinPool['coll'][1] -= trin['coll'][1]

    trin['delta'] = total - stressPledge(trinPool)
    console.log("trin['delta']...", trin['delta'])
    sum_deltas += trin['delta'] 

    // --------------------------------------------------------------------------
    
    neo['stress'] = stressPledge(neo)
    tally += neo['stress']
    console.log("neo['stress']...", neo['stress'])
    // remove user from pool
    neoPool['debt'] -= neo['debt']
    neoPool['coll'][0] -= neo['coll'][0]
    neoPool['coll'][1] -= neo['coll'][1]

    neo['delta'] = total - stressPledge(neoPool)
    console.log("neo['delta']...", neo['delta'])
    sum_deltas += neo['delta'] 

    // --------------------------------------------------------------------------

    morph['stress'] = stressPledge(morph)
    tally += morph['stress']
    console.log("morph['stress']...", morph['stress'])
    
    // remove user from pool
    morphPool['debt'] -= morph['debt']
    morphPool['coll'][0] -= morph['coll'][0]
    morphPool['coll'][1] -= morph['coll'][1]

    morph['delta'] = total - stressPledge(morphPool)
    console.log("morph['delta']...", morph['delta'])
    sum_deltas += morph['delta'] 

    console.log('tally', tally)    
    console.log('sum_deltas', sum_deltas)    
}

compareColl()
'''
'''--- scripts/sanity-check2.js ---

// erf(x): error function (see: https://en.wikipedia.org/wiki/Error_function)
// by https://github.com/jeremybarnes/cephes/blob/master/cprob/ndtr.c
const P = [
  2.46196981473530512524E-10,
  5.64189564831068821977E-1,
  7.46321056442269912687E0,
  4.86371970985681366614E1,
  1.96520832956077098242E2,
  5.26445194995477358631E2,
  9.34528527171957607540E2,
  1.02755188689515710272E3,
  5.57535335369399327526E2,
];
const Q = [
  1.32281951154744992508E1,
  8.67072140885989742329E1,
  3.54937778887819891062E2,
  9.75708501743205489753E2,
  1.82390916687909736289E3,
  2.24633760818710981792E3,
  1.65666309194161350182E3,
  5.57535340817727675546E2,
];
const R = [
  5.64189583547755073984E-1,
  1.27536670759978104416E0,
  5.01905042251180477414E0,
  6.16021097993053585195E0,
  7.40974269950448939160E0,
  2.97886665372100240670E0,
];
const S = [
  2.26052863220117276590E0,
  9.39603524938001434673E0,
  1.20489539808096656605E1,
  1.70814450747565897222E1,
  9.60896809063285878198E0,
  3.36907645100081516050E0,
];
const T = [
  9.60497373987051638749E0,
  9.00260197203842689217E1,
  2.23200534594684319226E3,
  7.00332514112805075473E3,
  5.55923013010394962768E4,
];
const U = [
  3.35617141647503099647E1,
  5.21357949780152679795E2,
  4.59432382970980127987E3,
  2.26290000613890934246E4,
  4.92673942608635921086E4,
];
const MAXLOG = Math.log(Number.MAX_VALUE)

function polevl(x, c) {
  return c.reduce((r, c) => r * x + c, 0)
}
function p1evl(x, c) {
  return c.reduce((r, c) => r * x + c, 1)
}

function erf(x) {
  if (Math.abs(x) > 1) return 1 - erfc(x)
  const z = x * x
  return x * polevl(z, T) / p1evl(z, U)
}

// erfc(x) = 1 - erf(x)
function erfc(x0) {
  const x = Math.abs(x0)
  if (x < 1) return 1 - erf(x)
  const z = -x0 * x0
  if (z < -MAXLOG) return x0 < 0 ? 2 : 0
  const [p, q] = x < 8 ? [P, Q] : [R, S]
  const y = Math.exp(z) * polevl(x, p) / p1evl(x, q)
  return x0 < 0 ? 2 - y : y
}

function RationalApproximation(t) {
  // Abramowitz and Stegun formula 26.2.23.
  // The absolute value of the error should be less than 4.5 e-4.
  let c = [2.515517, 0.802853, 0.010328]
  let d = [1.432788, 0.189269, 0.001308]
  return t - ((c[2] * t + c[1]) * t + c[0]) /
      (((d[2] * t + d[1]) * t + d[0]) * t + 1.0)
}

function NormalCDFInverse(p) {
  if (p < 0.5) { // F^-1(p) = -G^-1(p)
      let n = -2.0 * Math.log(p)
      return -1.0 * RationalApproximation(Math.sqrt(n))
  }
  else { // F^-1(p) = G^-1(1-p)
      let l = 1.0 - p
      let n = -2.0 * Math.log(l)
      return RationalApproximation(Math.sqrt(n))
  }
}

function stress(alpha, sqrt_var, short) { // max portfolio loss in %
  let sqrt2pi = Math.sqrt(2.0 * Math.PI)
  let d = NormalCDFInverse(alpha)
  let e1 = -1.0 * (d * d) / 2.0
  let e2
  if (short) {
    e2 = Math.exp(e1) / sqrt2pi / (1.0 - alpha) * sqrt_var
    return Math.exp(e2) - 1.0
  } else {
    e2 = -1.0 * (Math.exp(e1) / sqrt2pi / (1.0 - alpha) * sqrt_var)
    return -1.0 * (Math.exp(e2) - 1.0)
  }
}

// stress test the collateral portfolio of each user, as measured by CVaR
// record amount by which user's stressed collateral value would drop below user's debt
function stressPledge(p, print = false) {
  let vol1 = 0.4
  let price1 = 1
  //let vol2 = 0.9
  //let price2 = 2
  
  let iW = (p.coll[0] * price1)
  //let jW = (p.coll[1] * price2)
  let totalVal = iW //+ jW
  iW /= totalVal
  //jW /= totalVal

  let portVariance = 2.0 * iW * vol1 //* jW * vol2;
  portVariance += Math.pow(iW, 2) * Math.pow(vol1, 2);
  //portVariance += Math.pow(jW, 2) * Math.pow(vol2, 2);
  
  let vol = Math.sqrt(portVariance)

  let stresscol = stress(0.90, vol, false) 
  //console.log('stresscol...', stresscol)

  let svalueofcol = (1.0 - stresscol) * totalVal
  //console.log('svalueofcol...', svalueofcol)
  
  let svalueofcole = Math.max(p.debt - svalueofcol, 0.0)
  //console.log('svalueofcole...', svalueofcole)

  if (print) {
      console.log('...vol...', vol)
      console.log('stresscol...', stresscol) 
      console.log('svalueofcol...', svalueofcol)
      console.log('svalueofcole...', svalueofcole)  
  }
  return svalueofcole
}

function compareColl() {
    let trin = {
        debt: 1500,
        coll: [1200, 100],
    }
    let neo = {
        debt: 1234,
        coll: [1888, 42]
    }
    let morph = {
        debt: 666,
        coll: [888, 420]
    }    

    // --------------------------------------------------------------------------
    let pool = {
        debt: trin.debt + neo.debt + morph.debt,
        coll: [
                (trin.coll[0] + neo.coll[0] + morph.coll[0]),
                //(trin.coll[1] + neo.coll[1] + morph.coll[1])
              ],
    }
    let trinPool = {
        debt: trin.debt + neo.debt + morph.debt,
        coll: [
                (trin.coll[0] + neo.coll[0] + morph.coll[0]),
                //(trin.coll[1] + neo.coll[1] + morph.coll[1])
              ],
    }
    let morphPool = {
        debt: trin.debt + neo.debt + morph.debt,
        coll: [
                (trin.coll[0] + neo.coll[0] + morph.coll[0]),
                //(trin.coll[1] + neo.coll[1] + morph.coll[1])
              ],
    }
    let neoPool = {
        debt: trin.debt + neo.debt + morph.debt,
        coll: [
                (trin.coll[0] + neo.coll[0] + morph.coll[0]),
                //(trin.coll[1] + neo.coll[1] + morph.coll[1])
              ],
    }

    let total = stressPledge(pool)
    console.log('total', total)

    let tally = 0 // we are testing if the aggregated s_val_col_e equals 
    // from the one received at the bottom (where portfolio's stressed as a whole)
    let sum_deltas = 0
    // --------------------------------------------------------------------------
    
    trin['stress'] = stressPledge(trin)
    tally += trin['stress']
    console.log("trin['stress']...", trin['stress'])

    // remove user from pool
    trinPool['debt'] -= trin['debt']
    trinPool['coll'][0] -= trin['coll'][0]
    //trinPool['coll'][1] -= trin['coll'][1]

    trin['delta'] = total - stressPledge(trinPool)
    console.log("trin['delta']...", trin['delta'])
    sum_deltas += trin['delta'] 

    // --------------------------------------------------------------------------
    
    neo['stress'] = stressPledge(neo)
    tally += neo['stress']
    console.log("neo['stress']...", neo['stress'])
    // remove user from pool
    neoPool['debt'] -= neo['debt']
    neoPool['coll'][0] -= neo['coll'][0]
    //neoPool['coll'][1] -= neo['coll'][1]

    neo['delta'] = total - stressPledge(neoPool)
    console.log("neo['delta']...", neo['delta'])
    sum_deltas += neo['delta'] 

    // --------------------------------------------------------------------------

    morph['stress'] = stressPledge(morph)
    tally += morph['stress']
    console.log("morph['stress']...", morph['stress'])
    
    // remove user from pool
    morphPool['debt'] -= morph['debt']
    morphPool['coll'][0] -= morph['coll'][0]
    //morphPool['coll'][1] -= morph['coll'][1]

    morph['delta'] = total - stressPledge(morphPool)
    console.log("morph['delta']...", morph['delta'])
    sum_deltas += morph['delta'] 

    console.log('tally', tally)    
    console.log('sum_deltas', sum_deltas)    
}

compareColl()
'''
'''--- scripts/test-utils.js ---

const BN = require('bn.js');
const nearAPI = require('near-api-js');
const { KeyPair, Account, Contract, utils: { format: { parseNearAmount } } } = nearAPI;
const { near, connection, keyStore, contract, contractAccount } = require('./near-utils')
const getConfig = require('./config');
const {
    networkId, contractName, contractMethods, DEFAULT_NEW_ACCOUNT_AMOUNT
} = getConfig();

/********************************
Internal Helpers
********************************/
async function createAccount(accountId, fundingAmount = DEFAULT_NEW_ACCOUNT_AMOUNT) {
	const contractAccount = new Account(connection, contractName);
	const newKeyPair = KeyPair.fromRandom('ed25519');
	await contractAccount.createAccount(accountId, newKeyPair.publicKey, new BN(parseNearAmount(fundingAmount)));
	keyStore.setKey(networkId, accountId, newKeyPair);
	return new nearAPI.Account(connection, accountId);
}

function generateUniqueSubAccount() {
	return `t${Date.now()}.${contractName}`;
}

/********************************
Exports
********************************/

const getAccountBalance = async (accountId) => (new nearAPI.Account(connection, accountId)).getAccountBalance();

const initAccount = async(accountId, secret) => {
	account = new nearAPI.Account(connection, accountId);
	const newKeyPair = KeyPair.fromString(secret);
	keyStore.setKey(networkId, accountId, newKeyPair);
	return account
}

async function initContract() {
	try {
		// let result = await contract.new({ owner_id: contractName }); // Same thing as below
		let result = await contractAccount.functionCall(
			contractName, "new",
			{ 
				"owner_id": contractName,
			}
		)
		// console.log(result)
	} catch (e) {
		if (!/Already initialized/.test(e.toString())) {
			throw e;
		}
	}
	return { contract, contractName };
}

const createOrInitAccount = async(accountId, secret) => {
	let account;
	try {
		account = await createAccount(accountId, DEFAULT_NEW_CONTRACT_AMOUNT, secret);
	} catch (e) {
		if (!/because it already exists/.test(e.toString())) {
			throw e;
		}
		account = new nearAPI.Account(connection, accountId);

		console.log(await getAccountBalance(accountId));

		const newKeyPair = KeyPair.fromString(secret);
		keyStore.setKey(networkId, accountId, newKeyPair);
	}
	return account;
};

async function getContract(account) {
	return new Contract(contractAccount, contractName, {
		...contractMethods,
		signer: account || undefined
	});
}

async function getAccount(accountId, fundingAmount = DEFAULT_NEW_ACCOUNT_AMOUNT) {
	accountId = accountId || generateUniqueSubAccount();
	const account = new nearAPI.Account(connection, accountId);
	try {
		await account.state();
		return account;
	} catch(e) {
		if (!/does not exist/.test(e.toString())) {
			throw e;
		}
	}
	return await createAccount(accountId, fundingAmount);
};

const getSignature = async (account) => {
	const { accountId } = account;
	const block = await account.connection.provider.block({ finality: 'final' });
	const blockNumber = block.header.height.toString();
	const signer = account.inMemorySigner || account.connection.signer;
	const signed = await signer.signMessage(Buffer.from(blockNumber), accountId, networkId);
	const blockNumberSignature = Buffer.from(signed.signature).toString('base64');
	return { blockNumber, blockNumberSignature };
};

const loadCredentials = (accountId) => {
	const credPath = `./neardev/${networkId}/${accountId}.json`;
	console.log(
		"Loading Credentials:\n",
		credPath
	);

	let credentials;
	try {
		credentials = JSON.parse(
			fs.readFileSync(
				credPath
			)
		);
	} catch(e) {
		console.warn('credentials not in /neardev');
		/// attempt to load backup creds from local machine
		credentials = JSON.parse(
			fs.readFileSync(
				`${process.env.HOME}/.near-credentials/${networkId}/${accountId}.json`
			)
		);
	}

	return credentials
}

module.exports = { 
    near,
    connection,
    keyStore,
    getContract,
	getSignature,
	loadCredentials,
    contract,
    contractName,
    contractAccount,
    initContract, getAccount,
	initAccount, createOrInitAccount
};

'''
'''--- src/bonk.rs ---
use crate::*;

use near_sdk::{env, log, Balance, Promise};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::json_types::{WrappedBalance, WrappedTimestamp, U128};

#[near_bindgen]
impl Contract 
{    
    // QuiD's bot script will continuously call this liquidation function on distressed 
    // Pledges. For this reason there is no liquidation fee, because there is an implicit
    // incentive for anyone to run this function, otherwise the peg will be destroyed.
    pub fn clip(&mut self, account: ValidAccountId) { 
        assert_one_yocto();
        let mut long_touched = false;
        let mut short_touched = false;
        let id: AccountId = account.clone().into();
        // We don't use fetch_pledge because we'd rather not absorb into
        // a pledge until after they are rescued, to keep their SP balances
        // as high as possible in the interest of rescuing
        if let Some(mut pledge) = self.pledges.get(&id) {
            // TODO clip biggest one first, or the lowest CR first if same size 
            let mut cr = computeCR(self.get_price(), pledge.long.credit, pledge.long.debit, false);
            // TODO if the position is in the user defined range, shrink it
            if cr < MIN_CR {
                let nums = self.try_kill_pledge(&pledge, false);
                pledge.long.credit = nums.1;
                pledge.long.debit = nums.3;
                pledge.near = nums.0;
                pledge.quid = nums.2;
                long_touched = true;
            }
            cr = computeCR(self.get_price(), pledge.short.credit, pledge.short.debit, true);
            if cr < MIN_CR {
                let nums = self.try_kill_pledge(&pledge, true);
                pledge.short.credit = nums.1;
                pledge.short.debit = nums.3;
                pledge.quid = nums.0;
                pledge.near = nums.2;
                short_touched = true;
            }
            self.save_pledge(&id, &mut pledge, long_touched, short_touched);
        }
    }

    pub(crate) fn try_kill_pledge(&mut self, pledge: &Pledge, short: bool) -> (Balance, Balance, Balance, Balance) {
        let available: Balance = self.token.ft_balance_of(
            ValidAccountId::try_from(pledge.id.clone()).unwrap()
        ).into(); 
        let mut old_nums: (Balance, Balance, Balance, Balance);
        let mut nums: (Balance, Balance, Balance, Balance);
        let mut cr: u128;
        /** Liquidation protection does an off-setting where deficit margin (delta from min CR)
        in a Pledge can be covered by either its SP deposit, or possibly (TODO) the opposite 
        borrowing position. However, it's rare that a Pledge will borrow both long & short. **/
        if short {
            old_nums = (
                pledge.quid, pledge.short.credit, 
                pledge.near, pledge.short.debit
            );
            nums = self.short_save(&pledge, available);
            cr = computeCR(self.get_price(), nums.1, nums.3, true);
            if cr < KILL_CR { // we are liquidating this pledge
                // undo asset displacement by short_save
                let now_available: Balance = self.token.ft_balance_of(
                    ValidAccountId::try_from(pledge.id.clone()).unwrap()
                ).into();
                if available > now_available {
                    self.token.internal_withdraw(&pledge.id, available - now_available);
                }
                if old_nums.0 > nums.0 { // SP QD changed
                    let delta = old_nums.0 - nums.0;
                    self.live.short.credit = self.live.short.credit
                        .checked_sub(delta).expect(ERR_SUB);
                    self.blood.credit = self.blood.credit
                        .checked_add(delta).expect(ERR_ADD);
                }
                if old_nums.2 > nums.2 { // SP NEAR changed
                    let delta = old_nums.2 - nums.2;
                    self.live.short.debit = self.live.short.debit
                        .checked_add(delta).expect(ERR_ADD);
                    self.blood.debit = self.blood.debit
                        .checked_add(delta).expect(ERR_ADD);
                }
                // move liquidated assets from LivePool to DeadPool
                self.snatch(nums.3, nums.1, true);
                return (old_nums.0, 0, old_nums.2, 0); // zero out the pledge
            } else if cr < MIN_CR {
                (nums.1, nums.3) = self.shrink(nums.1, nums.3, true);
            }
        } else {
            old_nums = (
                pledge.near, pledge.long.credit, 
                pledge.quid, pledge.long.debit
            );
            nums = self.long_save(&pledge, available);
            cr = computeCR(self.get_price(), nums.1, nums.3, false);
            if cr < KILL_CR {
                let now_available: Balance = self.token.ft_balance_of(
                    ValidAccountId::try_from(pledge.id.clone()).unwrap()
                ).into();
                if available > now_available {
                    self.token.internal_withdraw(&pledge.id, available - now_available);
                }
                if old_nums.0 > nums.0 { // SP NEAR changed
                    let delta = old_nums.0 - nums.0;
                    self.live.long.credit = self.live.long.credit
                        .checked_sub(delta).expect(ERR_SUB);
                    self.blood.debit = self.blood.debit
                        .checked_add(delta).expect(ERR_ADD);
                }
                if old_nums.2 > nums.2 { // SP QD changed
                    let delta = old_nums.2 - nums.2;
                    self.live.long.debit = self.live.long.debit
                        .checked_add(delta).expect(ERR_ADD);
                    self.blood.credit = self.blood.credit
                        .checked_add(delta).expect(ERR_ADD);
                }
                self.snatch(nums.3, nums.1, false);
                return (old_nums.0, 0, old_nums.2, 0);
            } else if cr < MIN_CR {
                (nums.1, nums.3) = self.shrink(nums.1, nums.3, false);
            }
        }
        return nums;
    }    

    pub(crate) fn shrink(&mut self, credit: Balance, debit: Balance, short: bool) -> (Balance, Balance) {
        /* Shrinking is atomically selling an amount of collateral and 
           immediately using the exact output of that to reduce debt to
           get its CR up to min. How to calculate amount to be sold:
           CR = (coll - x) / (debt - x)
           CR * debt - CR * x = coll - x
           x(1 - CR) = coll - CR * debt
           x = (CR * debt - coll) * 10
       */
       let mut coll: Balance;
       let mut debt: Balance;
       if short {
           coll = credit;
           debt = ratio(self.get_price(), debit, KILL_CR);
       } else {
           coll = ratio(self.get_price(), credit, KILL_CR);
           debt = debit;
       }
       let CR_x_debt = ratio(MIN_CR, debt, KILL_CR);
       let mut delta: Balance = 10;
       delta = delta.checked_mul(
           CR_x_debt.checked_sub(coll).expect(ERR_SUB)
       ).expect(ERR_MUL);
       coll = coll.checked_sub(delta).expect(ERR_SUB);
       debt = debt.checked_sub(delta).expect(ERR_SUB);
       if short {
           self.redeem(delta);
           self.live.short.credit = self.live.short.credit
               .checked_sub(delta).expect(ERR_SUB);
           delta = ratio(KILL_CR, delta, self.get_price());
           self.live.short.debit = self.live.short.debit
               .checked_sub(delta).expect(ERR_SUB);
           return (
               coll,
               ratio(KILL_CR, debt, self.get_price()),
           );
       } else {
           self.live.long.debit = self.live.long.debit
               .checked_sub(delta).expect(ERR_SUB);
           delta = ratio(KILL_CR, delta, self.get_price());
           self.invert(delta);
           self.live.long.credit = self.live.long.credit
               .checked_sub(delta).expect(ERR_SUB);
           return (
               ratio(KILL_CR, coll, self.get_price()),
               debt
           );    
       }
   }

   pub(crate) fn long_save(&mut self, pledge: &Pledge, available: Balance) -> (Balance, Balance, Balance, Balance) {
       let mut near = pledge.near;
       let mut quid = pledge.quid;
       let mut credit = pledge.long.credit;
       let mut debit = pledge.long.debit;
       // attempt to rescue the Pledge by dipping into its SolvencyPool deposit (if any)
       // try NEAR deposit *first*, because long liquidation means NEAR is falling, so
       // we want to keep as much QD in the SolvencyPool as we can before touching it 
       /*  How much to increase collateral of long side of pledge, to get CR to 110
           CR = ((coll + x) * price) / debt
           CR * debt / price = coll + x
           x = CR * debt / price - coll
           ^ subtracting the same units
       */ 
       let mut delta = ratio(MIN_CR, debit, self.get_price())
           .checked_sub(credit).expect(ERR_SUB);
       
       let mut min = std::cmp::min(near, delta);
       near -= min;
       credit = credit
           .checked_add(min).expect(ERR_ADD);
       self.live.long.credit = self.live.long.credit
           .checked_add(min).expect(ERR_ADD);
       self.blood.debit = self.blood.debit
           .checked_sub(min).expect(ERR_SUB);

       if delta > min {
           /*  how much to decrease long side's debt
               of  pledge, to get its CR up to min
               CR = (coll * price) / (debt - x)
               debt - x = (coll * price) / CR
               x = debt - (coll * price) / CR
               ^ subtracting the same units
           */
           delta = debit.checked_sub( // find remaining delta using updated credit
               ratio(self.get_price(), credit, MIN_CR)
           ).expect(ERR_SUB);
           // first, try to claim liquid QD from user's FungibleToken balance
           min = std::cmp::min(available, delta);
           delta -= min;
           debit = debit
               .checked_sub(min).expect(ERR_SUB);
           // we only withdraw, but do not deposit because we are burning debt 
           self.token.internal_withdraw(&pledge.id, min);
           
           if delta > 0 {
               min = std::cmp::min(quid, delta);
               quid -= min;
               debit = debit
                   .checked_sub(min).expect(ERR_SUB);
               self.live.long.debit = self.live.long.debit
                   .checked_sub(min).expect(ERR_SUB);
               self.blood.credit = self.blood.credit
                   .checked_sub(min).expect(ERR_SUB);
           }
       }
       return (near, credit, quid, debit); // we did the best we could, 
       // but there is no guarantee that the CR is back up to MIN_CR
   }

   pub(crate) fn short_save(&mut self, pledge: &Pledge, available: Balance) -> (Balance, Balance, Balance, Balance) {
       let mut near = pledge.near;
       let mut quid = pledge.quid;
       let mut credit = pledge.short.credit;
       let mut debit = pledge.short.debit;
       
       // attempt to rescue the Pledge using its SolvencyPool deposit (if any exists)
       // try QD deposit *first*, because short liquidation means NEAR is rising, so
       // we want to keep as much NEAR in the SolvencyPool as we can before touching it
       let val_debt = ratio(self.get_price(), debit, ONE);
        // first, try to claim liquid QD from user's FungibleToken balance
       // if they have NEAR in the SP it should stay there b/c it's growing
       // as we know this is what put the short in jeopardy of liquidation
       let final_qd = ratio(MIN_CR, val_debt, KILL_CR);
       let mut delta = final_qd.checked_sub(credit).expect(ERR_SUB);
       // first, try to claim liquid QD from user's FungibleToken balance
       let mut min = std::cmp::min(available, delta);
       delta -= min;

       credit = credit.checked_add(min).expect(ERR_ADD);
       self.token.internal_withdraw(&pledge.id, min);
       self.token.internal_deposit(&env::current_account_id(), min);
       self.live.short.credit = self.live.short.credit
           .checked_add(min).expect(ERR_ADD);
       
       if delta > 0 {
           min = std::cmp::min(quid, delta);
           credit = credit.checked_add(min).expect(ERR_ADD);
           self.live.short.credit = self.live.short.credit
               .checked_add(min).expect(ERR_ADD);
           
           delta -= min;
           quid -= min;
           self.blood.credit -= min;

           if delta > 0 {
               /*  How much to decrease debt of long side of pledge, to get its CR up to min
                   CR = coll / (debt * price - x)
                   debt * price - x = coll / CR
                   x = debt * price - coll / CR
               */
               delta = val_debt.checked_sub(
                   ratio(ONE, credit, MIN_CR)
               ).expect(ERR_SUB);
               
               min = std::cmp::min(near, delta);
               near -= min;
               debit -= min;
               self.blood.debit -= min;
               self.live.short.debit = self.live.short.debit
                   .checked_sub(min).expect(ERR_SUB);
           }
       }
       return (quid, credit, near, debit);
   }

   /**
     * You have to bring it back. That's why every magic trick has
     * a third act, the hardest part, which we call "The Prestige"
    */
    pub(crate) fn snatch(&mut self, debt: Balance, collat: Balance, short: bool) {
        if short { // we are moving crypto debt and QD collateral from LivePool to DeadPool
            self.live.short.credit = self.live.short.credit
                .checked_sub(collat).expect(ERR_SUB);

            self.dead.short.credit = self.dead.short.credit
                .checked_add(collat).expect(ERR_ADD);

            self.live.short.debit = self.live.short.debit
                .checked_sub(debt).expect(ERR_SUB);
            
            let val_debt = ratio(self.get_price(), debt, ONE);
            
            let delta = val_debt - collat; 
            assert!(delta > 0, "Borrower was not supposed to be liquidated");
            
            let delta_debt = ratio(ONE, delta, self.get_price());
                
            let debt_minus_delta = debt - delta_debt;
    
            self.dead.short.debit = self.dead.short.debit
                .checked_add(debt_minus_delta).expect(ERR_ADD);
            
            self.gfund.short.debit = self.gfund.short.debit
                .checked_add(delta_debt).expect(ERR_ADD);
        } 
        else { // we are moving QD debt and crypto collateral
            self.live.long.credit = self.live.long.credit
                .checked_sub(collat).expect(ERR_SUB);

            self.dead.long.credit = self.dead.long.credit
                .checked_add(collat).expect(ERR_ADD);
            
            self.live.long.debit = self.live.long.debit
                .checked_sub(debt).expect(ERR_SUB);

            let val_coll = ratio(self.get_price(), collat, ONE);

            let delta = debt - val_coll;
            assert!(delta > 0, "Borrower was not supposed to be liquidated");
            let debt_minus_delta = debt - delta;

            self.dead.long.debit = self.dead.long.debit
                .checked_add(debt_minus_delta).expect(ERR_ADD);
            
            self.gfund.long.debit = self.dead.long.debit
                .checked_add(delta).expect(ERR_ADD);
        }
    }
}
'''
'''--- src/get.rs ---
use crate::*;

use near_sdk::{env, log, Balance, Promise};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::json_types::{WrappedBalance, WrappedTimestamp, U128};

pub trait PledgeForTreeMap: Clone + BorshSerialize + BorshDeserialize {
    fn get_id(&self) -> AccountId;
    fn get_debt_amt(&self, short: bool) -> U128;
    fn get_coll_val(&self, short: bool) -> U128;
    fn get_CR(&self, short: bool, price: u128) -> U128;
}
impl PledgeForTreeMap for Pledge {
    fn get_id(&self) -> AccountId {
        self.id.clone()
    }

    fn get_debt_amt(&self, short: bool) -> U128 {
        if short {
            return self.short.debit.into()
        } else {
            return self.long.debit.into()
        }
    }

    fn get_coll_val(&self, short: bool) -> U128 {
        if short {
            return self.short.credit.into()
        } else {
            return self.long.credit.into()
        }
    }

    fn get_CR(&self, short: bool, price: u128) -> U128 {
        if short {
            return computeCR(price, self.short.credit, self.short.debit, true).into();
        } else {
            return computeCR(price, self.long.credit, self.long.debit, false).into();
        }
    }
}

#[near_bindgen]
impl Contract 
{
    pub fn get_price(&self) -> u128 { 
        return self.price;
    }
    
    pub fn get_vol(&self) -> u128 { 
        return self.vol;
    }

    // // TODO Flux, push-based not pull-based
    // https://github.com/fluxprotocol/fpo-near/blob/main/consumer/src/lib.rs
    // 1req/min rate limited
    pub fn set_price(&mut self, _price: u128) { // TODO remove
        self.price = _price;
    }
    
    pub fn set_vol(&mut self, _vol: u128) { // TODO remove
        self.vol = _vol;
    }    
    
    pub fn get_pool_stats(&self) -> PoolStats {
        PoolStats::new(&self)
    }

    pub fn get_pledge(&self, account: ValidAccountId) -> Option<PledgeView> {
        self.pledges.get(account.as_ref()).map(|a| (&a).into())
    }

    pub fn get_qd_balance(&self, account: ValidAccountId) -> WrappedBalance {
        let balance: WrappedBalance = self.token.ft_balance_of(
            ValidAccountId::try_from(account.clone()).unwrap()
        ).into();   
        return balance;
    }

    pub fn get_pledges(&self, from_index: u64, limit: u64) -> Vec<(AccountId, PledgeView)> {
        let account_ids = self.pledges.keys_as_vector();
        let pledges = self.pledges.values_as_vector();
        (from_index..std::cmp::min(from_index + limit, account_ids.len()))
            .map(|index| {
                let account_id = account_ids.get(index).unwrap();
                let pledge_view = (&pledges.get(index).unwrap()).into();
                (account_id, pledge_view)
            })
            .collect()
    }

    pub fn get_pledge_stats(&self, account: ValidAccountId, short: bool) -> Stats {
        if let Some(pledge) = self.pledges.get(account.as_ref()) {  
            if short {
                return pledge.stats.short.clone();
            } else {
                return pledge.stats.long.clone();
            }
        } else {
            if short {
                return self.stats.short.clone();
            } else {
                return self.stats.long.clone();
            }   
        }
    }

    pub fn get_pledge_tree(&self, from_index: u64, limit: u64) {
        let keys: Vec<AccountId> = self.long_crs.to_vec()
                                .iter()
                                .map(|(u, _)| u.id.clone())
                                .collect();

    }

    pub(crate) fn fetch_pledge(&mut self, id: &AccountId, create: bool) -> Pledge {
        if let Some(mut pledge) = self.pledges.get(&id) 
        {
            let val_near_sp = self.blood.debit
                .checked_div(KILL_CR).expect(ERR_DIV);
                    
            self.stats.val_near_sp = val_near_sp
                .checked_mul(self.get_price()).expect(ERR_MUL);
            
            self.stats.val_total_sp = self.blood.credit
                .checked_add(self.stats.val_near_sp).expect(ERR_ADD);
            
            if self.sp_stress(None, false) > 0.0 // stress the long side of the SolvencyPool
            && self.sp_stress(None, true) > 0.0 { // stress the short side of the SolvencyPool
                // retrieve the Pledge's pending allocation of fees as well as defaulted
                // long/short Pledges' collateral and debt, post redemptions/inversions
                // stressed value of SolvencyPool's short side, exclusing given pledge
                let s_stress_ins_x = self.sp_stress(Some(id.clone()), true);
                let s_delta = self.stats.short.stress_val - s_stress_ins_x;
                let s_pcs: f64 = s_delta / self.stats.short.stress_val; // % contrib. to short solvency
                
                // stressed value of SolvencyPool's long side, exclusing given pledge
                let l_stress_ins_x = self.sp_stress(Some(id.clone()), false);
                let l_delta = self.stats.long.stress_val - l_stress_ins_x;
                let l_pcs: f64 = l_delta / self.stats.long.stress_val; // % contrib. to long solvency
                
                if s_pcs > 0.0 && l_pcs > 0.0 {
                    // Calculate DeadPool shares to absorb by this pledge
                    // TODO attack where net postive DP is drained by repeated 
                    // micro pledge updates...limit updates to occur only once an hour
                    let mut near = (self.dead.long.debit as f64 * l_pcs).round() as Balance;
                    let mut near_debt = (self.dead.short.credit as f64 * s_pcs).round() as Balance;
                    let mut qd_debt = (self.dead.long.credit as f64 * l_pcs).round() as Balance;
                    let mut qd = (self.dead.short.debit as f64 * s_pcs).round() as Balance;
                    
                    if near_debt >= near 
                    { // net loss in terms of NEAR
                        let mut delta = near_debt - near;
                        self.dead.long.debit -= near; // the NEAR gain has been absorbed 
                        if delta > 0 {
                            // absorb as much as we can from the pledge
                            let min = std::cmp::min(pledge.near, delta);
                            self.dead.short.credit -= min; // TODO -= delta
                            
                            pledge.near = pledge.near // decrement user's recorded SP deposit
                                .checked_sub(min).expect(ERR_SUB);
                            self.blood.debit = self.blood.debit // decrement deposit from SP
                                .checked_sub(min).expect(ERR_SUB);
                            delta -= min;
                            if delta > 0 { // TODO calling multiple times will suck all money 
                                // from the cold pool until the DeadPool gets emptied out
                                // limit to once per hour, perhaps? Don't fuck with Batfrog
                                self.gfund.long.credit = self.gfund.long.credit
                                    .checked_sub(delta).expect(ERR_SUB);
                            }
                        }
                    } else 
                    { // net gain in terms of NEAR 
                        self.dead.short.credit -= near_debt;
                        self.dead.long.debit -= near;
                        near -= near_debt;
                        // TODO if pledge has any CR between 100-110, take the smaller one first
                        // add enough NEAR collat to long / remove enough NEAR debt from short
                        // such that the new CR is > 110, repeat again for larger CR side 
                        // remaining NEAR goes to SP deposit...
                        pledge.near = pledge.near
                            .checked_add(near).expect(ERR_ADD);
                        self.blood.debit = self.blood.debit
                            .checked_add(near).expect(ERR_ADD);
                    }
                    if qd_debt >= qd 
                    { // net loss in terms of QD
                        let mut delta = qd_debt - qd;
                        self.dead.short.debit -= qd; // the QD gain has been absorbed
                        if delta > 0 {
                            let min = std::cmp::min(pledge.quid, delta);
                            self.dead.long.credit -= min; // TODO -= delta
                            pledge.quid = pledge.quid
                                .checked_sub(min).expect(ERR_SUB);
                            self.blood.credit = self.blood.credit
                                .checked_sub(min).expect(ERR_SUB);
                            delta -= min;   
                            if delta > 0 {
                                // TODO
                                // use x_margin to absorb into the borrowing position, 
                                // only remainder after x_margin should be absorbed by gfund pool
                                self.gfund.short.credit = self.gfund.short.credit
                                    .checked_sub(delta).expect(ERR_SUB);
                            }
                        }
                    } else 
                    { // net gain in terms of QD
                        self.dead.long.credit -= qd_debt;
                        self.dead.short.debit -= qd;
                        qd -= qd_debt;
                        // TODO if pledge has any CR between 100-110, take the smaller one first
                        // let mut min = std::min(pledge.long.debit, qd);
                        // pledge.long.debit -= min;
                        // qd -= min;
                        // remove enough QD debt such that CR > 110
                        // if short CR between 100-110
                        // add enough QD to collat such that CR > 110 
                        // remaininf QD goes to SP deposit...
                        pledge.quid = pledge.quid
                            .checked_add(qd).expect(ERR_ADD);
                        self.blood.credit = self.blood.credit
                            .checked_add(qd).expect(ERR_ADD);
                    }
                }
            }
            return pledge;
        } 
        else if create {
            let mut prefix = Vec::with_capacity(33);
            prefix.push(b's');
            prefix.extend(env::sha256(id.as_bytes()));
            return Pledge {
                long: Pod::new(0, 0),
                short: Pod::new(0, 0),
                stats: PledgeStats::new(),
                quid: 0, near: 0,
                id: id.clone(),
                target: MIN_CR
            }
        } else {
            env::panic(b"Pledge doesn't exist"); 
        }
    }

}
'''
'''--- src/grab.rs ---
use crate::*;

use near_sdk::{env, log, Balance, Promise};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::json_types::{WrappedBalance, WrappedTimestamp, U128};

#[near_bindgen]
impl Contract 
{
    #[payable]
    pub fn swap(&mut self, amount: U128, repay: bool, short: bool) { // TODO rename 
        let mut amt: Balance = amount.into();
        let deposit = env::attached_deposit();
        let account = env::predecessor_account_id();
        assert!(self.crank.done, "Update in progress");
        assert!(deposit > 0, ERR_AMT_TOO_LOW);
        if !repay {
            if short { // NEAR ==> QD (short collat), AKA inverting NEAR debt
                assert!(deposit >= ONE, ERR_AMT_TOO_LOW);
                // TODO if account == richtobacco.near
                // do invertFrom
                self.invert(deposit);

                let mut quid = ratio(self.get_price(), deposit, ONE);        
                let mut fee_amt = ratio(FEE, quid, ONE);
                // https://www.youtube.com/watch?v=KoIqcDZ5ewY
                
                let gf_cut = fee_amt.checked_div(11).expect(ERR_DIV);
                self.gfund.short.credit = self.gfund.short.credit
                    .checked_add(gf_cut).expect(ERR_ADD);
                    
                quid -= fee_amt;
                fee_amt -= gf_cut;

                self.dead.short.debit = self.dead.short.debit
                    .checked_add(fee_amt).expect(ERR_ADD);
                
                self.token.internal_deposit(&account, quid);
            } 
            else { // QD ==> NEAR (long collat), AKA redeeming $QDebt 
                assert!(amt >= ONE, ERR_AMT_TOO_LOW);
                
                self.redeem(amt);
                self.token.internal_withdraw(&account, amt); // burn the QD being sold 
                let mut near = ratio(ONE, amt, self.get_price());
                let mut fee_amt = ratio(FEE, near, ONE);
            
                let gf_cut = fee_amt.checked_div(11).expect(ERR_DIV);
                self.gfund.long.credit = self.gfund.long.credit 
                    .checked_add(gf_cut).expect(ERR_ADD);
                
                near -= fee_amt;
                fee_amt -= gf_cut;
                
                self.dead.long.debit = self.dead.long.debit
                    .checked_add(fee_amt).expect(ERR_ADD);

                Promise::new(account).transfer(near); // send NEAR to redeemer
            }    
        } else { // decrement caller's NEAR or QDebt without releasing collateral
            let mut pledge = self.fetch_pledge(&account, false);
            if !short { // repay QD debt, distinct from premium payment which does not burn debt but instead distributes payment
                self.token.internal_withdraw(&account, amt); // burn the QD being paid in as premiums 
                self.turn(amt, true, false, &mut pledge);
            }
            else { // repay NEAR debt, distinct from premium payment (see previous comment next to `else if`)
                assert!(deposit > 1, ERR_AMT_TOO_LOW);
                self.turn(deposit, true, true, &mut pledge);
            }
        }
    }

    /**
     * The second act is called "The Turn". The magician takes the ordinary 
     * something and makes it do something extraordinary. Now you're looking
     * for the secret...but you won't find it, because of course you're not
     * really looking...you don't really want to know, you wanna be fooled, but
     * you wouldn't clap yet...because makin' somethin' disappear ain't enough  
     */
     pub(crate) fn turn(&mut self, amt: u128, 
                        repay: bool, short: bool,
                        pledge: &mut Pledge) -> Balance {
        let min: Balance;
        let id = pledge.id.clone();
        if !short { // burn QD up to the pledge's total long debt
            min = std::cmp::min(pledge.long.debit, amt);
            if min > 0 { // there is any amount of QD debt to burn
                pledge.long.debit -= min;
                self.live.long.debit = self.live.long.debit
                    .checked_sub(min).expect(ERR_SUB);
            }
        } 
        else { // burn NEAR debt
            min = std::cmp::min(pledge.short.debit, amt);
            if min > 0 {
                pledge.short.debit -= min;
                self.live.short.debit = self.live.short.debit
                    .checked_sub(min).expect(ERR_SUB);
            }
        }
        if min > 0 { // the Pledge was touched
            if !repay { 
                if !short { // release NEAR collateral as a consequence of redeeming debt
                    let redempt = ratio(KILL_CR, min, self.get_price());
                    
                    pledge.long.credit = pledge.long.credit
                        .checked_sub(redempt).expect(ERR_SUB);
                    
                    self.live.long.credit = self.live.long.credit
                        .checked_sub(redempt).expect(ERR_SUB);
                } 
                else { // release QD collateral...
                    // how much QD is `min` worth
                    let redempt = ratio(self.get_price(), min, ONE);
                        
                    pledge.short.credit = pledge.short.credit
                        .checked_sub(redempt).expect(ERR_SUB);
    
                    self.live.short.credit = self.live.short.credit
                        .checked_sub(redempt).expect(ERR_SUB);
                }
            } 
            self.save_pledge(&id, pledge, !short, short); 
        } 
        return min; // how much was redeemed, used for total tallying in turnFrom 
    }

    /*
     * loop through active Pledges in CR range 100-110%
     * by sorted order of increasing CR (lowest CR first),
     * through a composite key that prioritizes higher debt,
     * and burn from their QD/NEAR debt, while withdrawing 
     * equal value in NEAR/QD collateral to send to invoker
     */ 
    pub(crate) fn turnFrom(&mut self, mut amt: u128, short: bool, many: usize) -> Balance {
        // TODO what if there's not even `many` elements to iterate?
        if !short { // amt is interpreted as QD debt
            // TODO if many > the length 
            for (mut pledge, _) in self.long_crs.get_top(many) {
                if amt > 0 {
                    let CR = pledge.get_CR(false, self.get_price());
                    // For liquidation (full via `clip` or partial from
                    // within invert/redeem) we are only interested in 
                    // pledges between 90-100 LTV CR, since the map is 
                    // sorted we can break the loop on the first LTV<90
                    if CR.0 >= MIN_CR { break; }
                    else if CR.0 < KILL_CR { continue; }
                    // this is a rare edge case as 'clip bots'
                    // will continuously churn liquidatables
                    // by reading from the head of this map
                    // and calling `clip` on risky pledges
                }
                amt -= self.turn(amt, false, false, &mut pledge); // burn QD debt from pledge
            }
        } else { // amt is interpreted as NEAR debt 
            for (mut pledge, _) in self.short_crs.get_top(many) { 
                if amt > 0 {
                    let CR = pledge.get_CR(true, self.get_price());
                    if CR.0 >= MIN_CR { break; }
                    // TODO this fails by having big pledges on top, never reaching
                    // small Pledges with CRs above 90 because the magnitude of 
                    // big Pledges will just overtake their index in the treemap
                    else if CR.0 < KILL_CR { continue; }
                    // No need to skip the originator of the redemption/inversion
                    // if they are in the 100-110 range who cares if someone else
                    // partially liquidates them or if they do it to themselves
                    amt -= self.turn(amt, false, true, &mut pledge); // burn NEAR debt from pledge
                } else { break; }
            }
        }
        return amt; // remaining amount to redeem
    }

    // pub(crate) fn redeemFrom(&mut self, quid: Balance) {
    //     // TODO move turnFrom piece here and let `update` bot handle this using GFund for liquidity
    // }
    pub(crate) fn redeem(&mut self, quid: Balance) {
        let bought: Balance; // NEAR collateral to be released from DeadPool's long portion
        let mut redempt: Balance = 0; // amount of QD debt being cleared from the DP
        let mut amt = self.turnFrom(quid, false, 10); // TODO 10 hardcoded
        if amt > 0 {  // fund redemption by burning against pending DP debt
            let mut val_collat = ratio(self.get_price(), self.dead.long.debit, ONE);
            if val_collat > self.dead.long.credit { // QD in DP worth less than NEAR in DP
                val_collat = self.dead.long.credit; // max QDebt amount that's clearable 
                // otherwise, we can face an edge case where tx throws as a result of
                // not being able to draw equally from both sides of DeadPool.long
            } if val_collat >= amt { // there is more QD in the DP than amt sold
                redempt = amt; 
                amt = 0; // there will be 0 QD left to clear
            } else {
                redempt = val_collat;
                amt -= redempt; // we'll still have to clear some QD
            }
            if redempt > 0 {
                // NEAR's worth of the QD we're about to displace in the DeadPool
                bought = ratio(ONE, redempt, self.get_price());
                // paying the DeadPool's long side by destroying QDebt
                self.dead.long.credit = self.dead.long.credit
                    .checked_sub(redempt).expect(ERR_SUB);
                self.dead.long.debit = self.dead.long.debit
                    .checked_sub(bought).expect(ERR_SUB);
            }
            if amt > 0 { // there is remaining QD to redeem after redeeming from DeadPool  
                let mut near = ratio(ONE, amt, self.get_price());
                assert!(env::account_balance() > near, 
                    "Insufficient NEAR in the contract to clear this redemption"
                );
                let mut min = std::cmp::min(self.blood.debit, near); // maximum NEAR dispensable by SolvencyPool
                amt = ratio(self.get_price(), amt, ONE); // QD paid to SP for NEAR sold 
                self.token.internal_deposit(&env::current_account_id(), amt);
                self.blood.credit // offset, in equal value, the NEAR sold by SP
                    .checked_add(amt).expect(ERR_ADD);
                self.blood.debit -= min; // sub NEAR that's getting debited out of the SP
                near -= min;
                if near > 0 { // hint, das haben eine kleine lobstah boobie 
                    amt = ratio(self.get_price(), near, ONE); // in QD
                    self.token.internal_deposit(&env::current_account_id(), amt);
                    // DP's QD will get debited (canceling NEAR debt) in inversions
                    self.dead.short.debit = self.dead.short.debit
                        .checked_add(amt).expect(ERR_ADD);
                    // append defaulted NEAR debt to the DP as retroactive settlement
                    self.dead.short.credit = self.dead.short.credit
                        .checked_add(near).expect(ERR_ADD);   
                }
            }
        }
    }

    // pub(crate) fn invertFrom(&mut self, quid: Balance) {
    //     // TODO move turnFrom piece here and let `update` bot handle this using GFund for liquidity
    // }
    pub(crate) fn invert(&mut self, near: Balance) {
        let mut bought: Balance = 0; // QD collateral to be released from DeadPool's short portion
        let mut redempt: Balance = 0; // amount of NEAR debt that's been cleared from DP
        // invert against LivePool, `true` for short, returns NEAR remainder to invert
        let mut amt = self.turnFrom(near, true, 10); // TODO 10 hardcoded
        if amt > 0 { // there is remaining NEAR to be bought 
            // can't clear more NEAR debt than is available in the DeadPool
            let mut val = std::cmp::min(amt, self.dead.short.credit);
            val = ratio(self.get_price(), val, ONE); // QD value
            log!("vaaalll...{}", val);
            if val > 0 && self.dead.short.debit >= val { // sufficient QD collateral vs value of NEAR sold
                log!("self.dead.short.debit...{}", self.dead.short.debit);
                redempt = amt; // amount of NEAR credit to be cleared from the DeadPool
                log!("redempt...{}", redempt);
                bought = val; // amount of QD to debit against short side of DeadPool
                log!("bought...{}", bought);
                amt = 0; // there remains no NEAR debt left to clear in the inversion
            } else if self.dead.short.debit > 0 { // there is less NEAR credit to clear than the amount being redeemed
                bought = self.dead.short.debit; // debit all QD collateral in the DeadPool
                redempt = ratio(ONE, bought, self.get_price());
                amt -= redempt;
            }
            if redempt > 0 {
                log!("redempt...{}", redempt);
                self.dead.short.credit = self.dead.short.credit // NEAR Debt
                    .checked_sub(redempt).expect(ERR_SUB);
                self.dead.short.debit = self.dead.short.debit // QD Collat
                    .checked_sub(bought).expect(ERR_SUB);
            }
            if amt > 0 { // remaining NEAR to redeem after clearing against LivePool and DeadPool
                let mut quid = ratio(self.get_price(), amt, ONE);
                let liq_qd: Balance = self.token.ft_balance_of(
                    ValidAccountId::try_from(env::current_account_id()).unwrap()).into();
                assert!(liq_qd > quid, "Insufficient QD in the contract to clear this inversion");
                
                let min = std::cmp::min(quid, self.blood.credit);
                let min_near = ratio(ONE, min, self.get_price());
                self.token.internal_withdraw(&env::current_account_id(), min);
                self.blood.debit = self.blood.debit
                    .checked_add(min_near).expect(ERR_ADD);
                self.blood.credit -= min;
                amt -= min_near;
                quid -= min;
                if quid > 0 { // und das auch 
                    // we credit NEAR to the long side of the DeadPool, which gets debited when redeeming QDebt
                    self.dead.long.debit = self.dead.long.debit
                        .checked_add(amt).expect(ERR_ADD);
                    // append defaulted $QDebt to the DeadPool as retroactive settlement to withdraw SPs' $QD
                    self.dead.long.credit = self.dead.long.credit
                        .checked_add(quid).expect(ERR_ADD);
                    // TODO how come we don't get to print when we do this?
                }
            }
        }
    }
}
'''
'''--- src/lib.rs ---
/*! QD Fungible Token implementation with JSON serialization.
  - Maximum balance value is limited by U128 (2**128 - 1)...
  - JSON calls must pass U128 as base-10 string. E.g. "100".
  - The contract tracks the change in storage before and after the call. If the storage increases,
    the contract requires the caller of the contract to attach enough deposit to the function call
    to cover the storage cost. This is done to prevent a denial of service attack on the contract.
    If the storage decreases, the contract will issue a refund for the cost of the released storage.
    Unused tokens from the attached deposit are also refunded, so attach more deposit than required.
  - To prevent the deployed contract from abused, it should not have any access keys on its account.
*/ use near_contract_standards::fungible_token::FungibleToken;
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider, FT_METADATA_SPEC
}; 
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{
    env, log, near_bindgen, AccountId, Balance, PanicOnDefault, 
    PromiseOrValue, Promise, assert_one_yocto 
};
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::collections::{
    LazyOption, LookupMap, TreeMap,
    UnorderedMap, UnorderedSet
}; 
use uint::construct_uint;
use std::convert::TryFrom;
use std::convert::TryInto;
near_sdk::setup_alloc!();
construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}
use crate::pledge::*; mod pledge;
use crate::utils::*; mod utils;
use crate::pool::*; mod pool;
use crate::grab::*; mod grab;
use crate::bonk::*; mod bonk;
use crate::get::*; mod get;
use crate::out::*; mod out;

#[serde(crate = "near_sdk::serde")]
#[derive(BorshDeserialize, BorshSerialize, Debug, Serialize)]
pub struct Crank {
    pub done: bool, // currently updating
    pub index: usize, // amount of collateral
    pub last: u64, // timestamp of last time Crank was updated
} impl Crank {
    pub fn new() -> Self {
        Self {
            done: true,
            index: 0,
            last: 0,
        }
    }
}

#[serde(crate = "near_sdk::serde")]
#[derive(BorshSerialize, BorshDeserialize, Debug, Serialize)]
pub struct Data { // Used in weighted median voting for solvency target
    solvency: f64, // capital adequacy needed to back debt
    median: f64, // Median of votes for Solvency Target
    scale: f64, // (scale = target / solvency)
    k: u64, // approx. index of median (+/- 1)
    sum_w_k: Balance, // sum(W[0..k])
    total: Balance,
    // all the distinct votes for given property
    y: Vec<i64>,
    // all the weights associated with the votes
    w: Vec<Balance>
} impl Data {
    pub fn new() -> Self {
        Self { solvency: 1.0, 
            median: -1.0, scale: 1.0,
            k: 0, sum_w_k: 0, total: 0, 
            y: Vec::new(), w: Vec::new()
        }
    }
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract { token: FungibleToken, // this contract is NEP141 token
    price: u128,
    vol: u128,
    metadata: LazyOption<FungibleTokenMetadata>,
    //votes: LookupMap<AccountId, f64>, // current solvency target vote...
    data_s: Data, // Data structure related to voting for solvency target
    data_l: Data, // Same, but for the long budget (above is for shorts)
    crank: Crank, // Used in `update` function
    pledges: UnorderedMap<AccountId, Pledge>,
    short_crs: PledgesTreeMap<Pledge, ()>, 
    long_crs: PledgesTreeMap<Pledge, ()>,
    stats: PledgeStats, // Global Risk Vars
    blood: Pod, // Solvency Pool deposits 
    gfund: Pool, // gfundPool, // Guarantee Fund
    live: Pool, // Active borrower assets
    dead: Pool // Defaulted borrower assets
}

// TODO QD SVG decode
const SVG_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(
        owner_id: ValidAccountId,
    ) -> Self {
        let metadata = FungibleTokenMetadata {
            spec: FT_METADATA_SPEC.to_string(),
            name: "Qu!D".to_string(),
            symbol: "QD".to_string(),
            icon: Some(SVG_ICON.to_string()),
            reference: None,
            reference_hash: None,
            decimals: 24,
        };
        metadata.assert_valid();
        let mut this = Self {
            token: FungibleToken::new(b"q".to_vec()),
            price: ONE, // TODO remove
            vol: 4666066, // TODO remove
            metadata: LazyOption::new(b"m".to_vec(), Some(&metadata)),
            pledges: UnorderedMap::new(b"p".to_vec()),
            short_crs: PledgesTreeMap::new(b"s".to_vec(), Sort::Composite, true),
            long_crs: PledgesTreeMap::new(b"l".to_vec(), Sort::Composite, false),
            data_l: Data::new(),
            data_s: Data::new(),
            crank: Crank::new(),
            stats: PledgeStats::new(), 
            blood: Pod::new(0, 0),
            gfund: Pool::new(), 
            live: Pool::new(),
            dead: Pool::new(),
        };
        this.token.internal_register_account(owner_id.as_ref());
        this
    }

    /*  Weighted Median Algorithm for Solvency Target Voting
	 *  Find value of k in range(1, len(Weights)) such that 
	 *  sum(Weights[0:k]) = sum(Weights[k:len(Weights)+1])
	 *  = sum(Weights) / 2
	 *  If there is no such value of k, there must be a value of k 
	 *  in the same range range(1, len(Weights)) such that 
	 *  sum(Weights[0:k]) > sum(Weights) / 2
	*/
    pub(crate) fn rebalance(&mut self, d: &mut Data, new_total: Balance, 
                            new_stake: Balance, new_vote: i64, 
                            old_stake: Balance, old_vote: i64) {
        d.total = new_total;
        let mut len = d.y.len();
        assert!(len == d.w.len(), "Wrong Weights Length");	
        assert!(new_vote >= 100 && new_vote <= 200, 
        "Allowable SolvencyTarget range is 100-200%");

        let added: bool;
        match d.y.binary_search(&new_vote) {
            Ok(idx) => {
                if new_stake != 0 {
                    d.w[idx] = d.w[idx].saturating_add(new_stake);
                }
                added = false;
            },
            Err(idx) => {
                d.y.insert(idx, new_vote);
                d.w.insert(idx, new_stake);
                added = true;
                len += 1;
            }
        }
        let median = (d.median * 100.0) as i64;
        let mid_stake = d.total.checked_div(2).unwrap_or_else(|| 0);

        if old_vote != -1 && old_stake != 0 { // if not the first time user is voting
            let idx = d.y.binary_search(&old_vote).unwrap_or_else(|x| panic!());
            d.w[idx] = d.w[idx].saturating_sub(old_stake);
            if d.w[idx] == 0 {
                d.y.remove(idx);
                d.w.remove(idx);
                if (idx as u64) >= d.k {
                    d.k -= 1;
                }
                len -= 1;	
            }
        }
        if d.total != 0 && mid_stake != 0 {
            if len == 1 || new_vote <= median {
                d.sum_w_k = d.sum_w_k.saturating_add(new_stake.into());
            }		  
            if old_vote <= median {   
                d.sum_w_k = d.sum_w_k.saturating_sub(old_stake.into());
            }
            if median > new_vote {
                if added && len > 1 {
                    d.k += 1;
                }
                while d.k >= 1 && ((d.sum_w_k.saturating_sub(d.w[d.k as usize])) >= mid_stake) {
                    d.sum_w_k = d.sum_w_k.saturating_sub(d.w[d.k as usize]);
                    d.k -= 1;			
                }
            } else {
                while d.sum_w_k < mid_stake {
                    d.k += 1;
                    d.sum_w_k = d.sum_w_k.saturating_add(d.w[d.k as usize]);
                }
            }
            d.median = (d.y[d.k as usize] as f64) / 100.0; // convert (e.g.) 142 to 1.42
            if d.sum_w_k == mid_stake {
                let intermedian = d.median + (d.y[d.k as usize + 1] as f64) / 100.0;
                d.median = intermedian / 2.0;
            }
        }  else {
            d.sum_w_k = 0;
        }
    } // TODO port from https://github.com/ricktobacco/sputnik-dao-contract/commit/02a66f26bf53f4fa8682a5a461175bdc9afd85f0
        // * update voting weight when user update's their SolvencyDeposit
        // * vote function where user indicates their SolvencyTarget
        /**
            pub fn vote(&mut self, new_vote: i128)  {
                assert_eq!(env::attached_deposit(), 16 * env::storage_byte_cost());
                assert!(new_vote > 0, "Vote cannot be negative");
                let account = env::predecessor_account_id();
                let old_vote: i128;
                if let Some(vote) = self.votes.get(&account) {  
                    old_vote = vote;
                } else {
                    old_vote = -1;
                }
                self.votes.insert(&account, &new_vote);
            }
            pub fn on_stake_change(&mut self, account: AccountId, balances: (Balance, Balance, Balance)) {
                if let Some(old_vote) = self.votes.get(&account) {  
                    self.rebalance(balances.2, balances.1, old_vote, balances.0, old_vote);    
                }
            }
            pub fn on_vote_change(&mut self, old_vote: i128, new_vote: i128, balances: (Balance, Balance)) {
                self.rebalance(balances.1, balances.0, old_vote, balances.0, new_vote);
            }
        */
        
    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
        log!("Account @{} burned {}", account_id, amount);
    }
}

// ======================================================================================

near_contract_standards::impl_fungible_token_core!(Contract, token, on_tokens_burned);
near_contract_standards::impl_fungible_token_storage!(Contract, token, on_account_closed);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

'''
'''--- src/out.rs ---
use crate::*;

use near_sdk::{env, log, Balance, Promise};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::json_types::{WrappedBalance, WrappedTimestamp, U128};

#[near_bindgen]
impl Contract 
{
    #[payable]
    pub fn borrow(&mut self, amount: U128, short: bool) -> PromiseOrValue<U128> { 
        let mut cr: u128; 
        let mut transfer = false;
        
        let mut amt: Balance = amount.into();
        let deposit = env::attached_deposit();
        assert!(self.crank.done, "Update in progress");
        assert!(deposit > 0 && amt > ONE, ERR_AMT_TOO_LOW);
        
        let account = env::predecessor_account_id();
        let mut pledge = self.fetch_pledge(&account, true);
        
        if !short {
            cr = computeCR(self.get_price(), pledge.long.credit, pledge.long.debit, false);
            assert!(cr == 0 || cr >= MIN_CR, "Cannot borrow while your current CR is below minimum");
            if deposit >= ONE {
                pledge.long.credit = pledge.long.credit
                    .checked_add(deposit).expect(ERR_ADD);
               
                self.live.long.credit = self.live.long.credit
                    .checked_add(deposit).expect(ERR_ADD);
            }
            let new_debt = pledge.long.debit 
                .checked_add(amt).expect(ERR_ADD);
            
            //assert!(new_debt >= MIN_DEBT, "Value of debt must be worth above $90 of QD");
            
            cr = computeCR(self.get_price(), pledge.long.credit, new_debt, false);
            if cr >= MIN_CR { // requested amount to borrow is within measure of collateral
                self.mint(&account, amt);
                // TODO pull from GFund (or in mint)
                pledge.long.debit = new_debt;
            } 
            else { // instead of throwing a "below MIN_CR" error right away, try to satisfy loan
                assert!(true, "can't go below MIN CR");
                (self.live.long, pledge.long) = self.valve(account.clone(),
                    false, new_debt, 
                    self.live.long.clone(),
                    pledge.long.clone()
                ); 
            }
        } else { // borrowing short
            if deposit > 1 { /* if they dont have QD and they send in NEAR, 
                we can just immediately invert it and use that as coll */
                self.invert(deposit); // QD value of the NEAR debt being cleared 
                pledge.short.credit = pledge.short.credit.checked_add( // QD value of the NEAR deposit
                    ratio(self.get_price(), deposit, ONE)).expect(ERR_ADD);
            }
            cr = computeCR(self.get_price(), pledge.short.credit, pledge.short.debit, true);
            assert!(cr == 0 || cr >= MIN_CR, "Cannot borrow while your current CR is below minimum"); 
            
            let new_debt = pledge.short.debit
                .checked_add(amt).expect(ERR_ADD);

            let new_debt_in_qd = ratio(self.get_price(), new_debt, ONE);
            
            //assert!(new_debt_in_qd >= MIN_DEBT, "Value of debt must be worth above $90 of QD");
            
            cr = ratio(ONE, pledge.short.credit, new_debt_in_qd);
            if cr >= MIN_CR {
                transfer = true; // when borrowing within their means, we disperse NEAR that the borrower can sell
            } else {
                (self.live.short, pledge.short) = self.valve(account.clone(),
                    true, new_debt_in_qd, 
                    self.live.short.clone(),
                    pledge.short.clone()
                );
            }
        }
        self.save_pledge(&account, &mut pledge, !short, short);
        if transfer { // transfer bool is a workaround for "borrow after move" compile error
            return PromiseOrValue::Promise(Promise::new(account).transfer(amt));
        } 
        return PromiseOrValue::Value(U128(0));
    }

    // TODO make sure that insurers get also have internal accounts not just borrowers 
    pub(crate) fn mint(&mut self, id: &AccountId, amt: u128) { // mint $QD stablecoins
        if self.token.accounts.get(&id).is_some() {
            self.token.internal_deposit(&id, amt);
        } else {
            self.token.internal_register_account(&id);
            self.token.internal_deposit(&id, amt);
        }
    }

    // https://twitter.com/1x_Brasil/status/1522663741023731714
    pub(crate) fn valve(&mut self, id: AccountId, short: bool, new_debt_in_qd: u128, mut live: Pod, mut pledge: Pod) -> (Pod, Pod) {
        let mut check_zero = false;
        let now_liq_qd: Balance = self.token.ft_balance_of(
            ValidAccountId::try_from(id.clone()).unwrap()
        ).into();
        let now_coll_in_qd: Balance;
        let now_debt_in_qd: Balance;
        if short {
            now_debt_in_qd = ratio(self.get_price(), pledge.debit, ONE);
            now_coll_in_qd = pledge.credit; 
        } else {
            now_coll_in_qd = ratio(self.get_price(), pledge.credit, ONE);
            now_debt_in_qd = pledge.debit;   
        }
        let mut net_val: Balance = now_liq_qd
            .checked_add(now_coll_in_qd).expect(ERR_ADD)
            .checked_sub(now_debt_in_qd).expect(ERR_SUB);
        
        let mut fee_amt: Balance = net_val.checked_sub( // (net_val - (1 - 1 / 1.1 = 0.090909...) * col_init) / 11
            ratio(DOT_OH_NINE, now_coll_in_qd, ONE)
        ).expect(ERR_SUB).checked_div(11).expect(ERR_DIV); // = 1 + (1 - 1 / 1.1) / fee_% 
        
        let mut qd_to_buy: Balance = fee_amt // (fee_amt / fee_%) i.e div 0.009090909...
            .checked_mul(110).expect(ERR_MUL);
        let mut end_coll_in_qd: Balance = qd_to_buy
            .checked_add(now_coll_in_qd).expect(ERR_ADD);

        let max_debt = ratio(ONE, end_coll_in_qd, MIN_CR);    
        let final_debt: Balance;
        if new_debt_in_qd >= max_debt {
            final_debt = max_debt;
            check_zero = true;
        } else { // max_debt is larger than the requested debt  
            final_debt = new_debt_in_qd;
            end_coll_in_qd = ratio(MIN_CR, final_debt, ONE);
            qd_to_buy = end_coll_in_qd // no need to mint all this QD, gets partially minted in `redeem`, excluding the
                .checked_sub(now_coll_in_qd).expect(ERR_SUB); // amount cleared against DeadPool's QDebt
            fee_amt = ratio(FEE, qd_to_buy, ONE);
        }
        net_val -= fee_amt;
        self.mint(&env::current_account_id(), fee_amt); // mint fee in QD
        let eleventh = fee_amt.checked_div(11).expect(ERR_DIV);
        
        let rest = fee_amt.checked_sub(eleventh).expect(ERR_SUB);
        self.dead.short.debit = self.dead.short.debit.checked_add(rest).expect(ERR_ADD);
        self.gfund.short.credit = self.gfund.short.credit.checked_add(eleventh).expect(ERR_ADD);
    
        if short {
            pledge.credit = end_coll_in_qd;
            pledge.debit = ratio(ONE, final_debt, self.get_price());
            
            live.credit = live.credit
                .checked_add(qd_to_buy).expect(ERR_ADD);
            let near_to_sell = ratio(ONE, qd_to_buy, self.get_price());
            // NEAR spent on buying QD collateral must be paid back by the borrower to unlock the QD
            live.debit = live.debit
                .checked_add(near_to_sell).expect(ERR_ADD);
            
            // we must first redeem QD that we mint out of thin air to purchase the NEAR, 
            // before burning NEAR debt with it to purchase QD (undoing the mint) collat
            self.redeem(qd_to_buy);
            self.invert(near_to_sell);     
        } else {    
            // get final collateral value in NEAR
            let end_coll = ratio(ONE, end_coll_in_qd, self.get_price());
            pledge.credit = end_coll;
            pledge.debit = final_debt;

            let delta_coll = end_coll
                .checked_sub(pledge.credit).expect(ERR_SUB);
            live.credit = live.credit
                .checked_add(delta_coll).expect(ERR_ADD);
            // QD spent on buying NEAR collateral must be paid back by the borrower to unlock the NEAR
            live.debit = live.debit
                .checked_add(qd_to_buy).expect(ERR_ADD);
            
            /******/ self.redeem(qd_to_buy); /******/
        }
        /*
            Liquid NEAR value in QD
                = (FinalDebt + Net) * (1 - 1.10 / (Net / FinalDebt + 1))
            Net = liquid QD + initial QD collat - initial NEAR debt in QD                  
        */
        let net_div_debt = ratio(
            ONE, net_val, final_debt
        ).checked_add(ONE).expect(ERR_ADD);

        let between = ONE.checked_sub( // `between` must >= 0 as a rule
            ratio(ONE, MIN_CR, net_div_debt)    
        ).expect("Illegal borrow attempt"); 

        let end_liq_qd = ratio(between, 
            final_debt.checked_add(net_val).expect(ERR_ADD),
        ONE);

        assert!(!check_zero || end_liq_qd == 0, "Something went wrong in `borrow");
        
        let delta_liq_qd: i128 = end_liq_qd.try_into().unwrap();
        let mut liq_qd = delta_liq_qd
            .checked_sub(now_liq_qd.try_into().unwrap()).expect(ERR_SUB);
        if liq_qd > 0 {
            self.mint(&id, liq_qd.try_into().unwrap());
        } 
        else if liq_qd < 0 { liq_qd *= -1;
            self.token.internal_withdraw(&id, liq_qd.try_into().unwrap());   
        }
        assert!(computeCR(self.get_price(), pledge.credit, pledge.debit, short) >= MIN_CR, 
        "Cannot do operation that would result in short CR below min"); 
        return (live, pledge);
    }

    /**
     * This function exists to allow withdrawal of deposits, either from 
     * a user's SolvencyPool deposit, or LivePool (borrowing) position.
     * Hence, the first boolean parameter's for indicating which pool,
     * & last boolean parameter indicates the currency being withdrawn.
     * @param sp = SolvencyPool
     */
    #[payable]
    pub fn renege(&mut self, amount: U128, sp: bool, qd: bool) -> PromiseOrValue<U128> {
        // TODO change vote
        assert!(self.crank.done, "Update in progress");
        assert_one_yocto();
        
        let amt: Balance = amount.into();
        assert!(amt > ONE, ERR_AMT_TOO_LOW);
        
        let cr: u128; let mut min: u128; 
        let mut transfer: bool = false;
        
        let account = env::predecessor_account_id();
        let mut pledge = self.fetch_pledge(&account, false);
        
        let all_qd: Balance = self.token.ft_balance_of(
            ValidAccountId::try_from(env::current_account_id()).unwrap()).into();

        let mut fee = ratio(FEE, amt, ONE);
        let mut amt_sub_fee = amt.checked_sub(fee).expect(ERR_SUB);
        let gf_cut = fee.checked_div(11).expect(ERR_DIV);
        fee -= gf_cut;

        if !sp { // we are withdrawing collateral from a borrowing position
            if qd {
                pledge.short.credit = pledge.short.credit.checked_sub(amt).expect(ERR_SUB);
                cr = computeCR(self.get_price(), pledge.short.credit, pledge.short.debit, true);
                assert!(cr >= MIN_CR, ERR_BELOW_MIN_CR);

                min = std::cmp::min(all_qd, amt_sub_fee); // maximum dispensable QD
                if amt_sub_fee > min { // there's not enough QD in the contract to send
                    amt_sub_fee -= min; // remainder to be gfundn as...
                    self.gfund.long.debit = self.gfund.long.debit // ...protocol debt  
                        .checked_add(amt_sub_fee).expect(ERR_ADD);
                }
                self.token.internal_deposit(&account, amt_sub_fee); // send QD to the signer
                self.token.internal_withdraw(&env::current_account_id(), min);
                self.live.short.credit = self.live.short.credit.checked_sub(amt).expect(ERR_SUB);
                
                self.dead.short.debit = self.dead.short.debit.checked_add(fee).expect(ERR_ADD); // pay fee
                self.gfund.short.credit = self.gfund.short.credit.checked_add(gf_cut).expect(ERR_ADD);
            }
            else {
                transfer = true; // we are sending NEAR to the user
                pledge.long.credit = pledge.long.credit.checked_sub(amt).expect(ERR_SUB);
                cr = computeCR(self.get_price(), pledge.long.credit, pledge.long.debit, false);
                assert!(cr >= MIN_CR, ERR_BELOW_MIN_CR);
                let near = env::account_balance();
                if amt_sub_fee > near { // there's not enough NEAR in the contract to send
                    let in_qd = ratio(self.get_price(), amt_sub_fee - near, ONE);
                    amt_sub_fee = near;
                    self.token.internal_deposit(&account, in_qd); // mint requested QD
                    self.gfund.long.debit = self.gfund.long.debit // freeze as protocol debt  
                        .checked_add(in_qd).expect(ERR_ADD);
                }
                self.live.long.credit = self.live.long.credit.checked_sub(amt).expect(ERR_SUB);
                self.dead.long.debit = self.dead.long.debit.checked_add(fee).expect(ERR_ADD);
                self.gfund.long.credit = self.gfund.long.credit.checked_add(gf_cut).expect(ERR_ADD);
            }   
        } else { // we are withdrawing deposits from the SolvencyPool
            let mut remainder;
            if qd {
                pledge.quid = pledge.quid.checked_sub(amt).expect(ERR_SUB);
                min = std::cmp::min(self.blood.credit, amt); // maximum dispensable QD
                self.blood.credit -= min;
                remainder = amt - min;
                if remainder > 0 {
                    min = std::cmp::min(self.gfund.short.credit, remainder);
                    self.gfund.short.credit -= min;
                    if remainder > min {
                        remainder -= min;
                        self.gfund.long.debit = self.gfund.long.debit
                            .checked_add(remainder).expect(ERR_ADD);      
                    }
                }
                self.token.internal_withdraw(&env::current_account_id(), amt_sub_fee); 
                self.token.internal_deposit(&account, amt_sub_fee); // send QD to the signer
                self.dead.short.debit = self.dead.short.debit.checked_add(fee).expect(ERR_ADD); // pay fee
                self.gfund.short.credit = self.gfund.short.credit.checked_add(gf_cut).expect(ERR_ADD);
            } else {
                transfer = true;
                pledge.near = pledge.near.checked_sub(amt).expect(ERR_SUB);
                min = std::cmp::min(self.blood.debit, amt); // maximum dispensable NEAR
                self.blood.debit -= min;
                remainder = amt - min;
                if remainder > 0 {
                    min = std::cmp::min(self.gfund.long.credit, remainder); // maximum dispensable NEAR
                    self.gfund.long.credit -= min;
                    if remainder > min {
                        remainder -= min;
                        amt_sub_fee -= remainder;
                        let in_qd = ratio(self.get_price(), remainder, ONE);
                        self.token.internal_deposit(&account, in_qd); // mint requested QD
                        self.gfund.long.debit = self.gfund.long.debit // freeze as protocol debt  
                            .checked_add(in_qd).expect(ERR_ADD);
                    }
                }
                self.dead.long.debit = self.dead.long.debit.checked_add(fee).expect(ERR_ADD); // pay fee
                self.gfund.long.credit = self.gfund.long.credit.checked_add(gf_cut).expect(ERR_ADD);
            }
        }
        self.save_pledge(&account, &mut pledge, !sp && !qd, !sp && qd);
        if transfer { // workaround for "borrow after move" compile error
            return PromiseOrValue::Promise(Promise::new(account).transfer(amt_sub_fee));
        }
        return PromiseOrValue::Value(U128(0));
    }

    // Close out caller's borrowing position by paying
    // off all pledge's own debt with own collateral
    #[payable]
    pub fn fold(&mut self, short: bool) { 
        assert_one_yocto();
        let id = env::predecessor_account_id();
        let mut pledge = self.fetch_pledge(&id, false);
        if short {
            let cr = computeCR(self.get_price(), pledge.short.credit, pledge.short.debit, true);
            if cr > KILL_CR { // mainly a sanity check, an underwater pledge will almost certainly
                // take QD and sell it for NEAR internally in the interest of proper accounting
                let qd = ratio(self.get_price(), pledge.short.debit, ONE);
                self.redeem(qd); // https://youtu.be/IYXRSR0xNVc?t=111 pledges will probably
                // be clipped before its owner can fold in time to prevent that from occuring...
                self.turn( pledge.short.debit, false, true, &mut pledge);
            }
        } else {
            let cr = computeCR(self.get_price(), pledge.long.credit, pledge.long.debit, false);
            if cr > KILL_CR {
                let near = ratio(ONE, pledge.long.debit, self.get_price());
                self.invert(near);
                self.turn(pledge.long.debit, false, false, &mut pledge);
            }
        }   
    }
}
'''
'''--- src/pledge.rs ---

use crate::*;
use libm;

use near_sdk::{env, log, Balance, Promise};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::json_types::{WrappedBalance, WrappedTimestamp, U128};

#[serde(crate = "near_sdk::serde")]
#[derive(BorshDeserialize, BorshSerialize, Clone, Serialize)]
pub struct Stats {
    pub val_near: Balance, // $ value of crypto assets
    pub stress_val: f64, //  $ value of the Solvency Pool in stress 
    pub avg_val: f64, // $ value of the Solvency Pool in average stress 
    pub stress_loss: f64, // % loss that Solvency pool would suffer in a stress event
    pub avg_loss: f64, // % loss that Solvency pool would suffer in an average stress event
    pub premiums: f64, // $ amount of premiums borrower would pay in a year to insure their collateral
    pub rate: f64, // annualized rate borrowers pay in periodic premiums to insure their collateral
}
impl Stats {
    pub fn new() -> Self {
        Self {
            val_near: 0,
            stress_val: 0.0,
            avg_val: 0.0,
            stress_loss: 0.0,
            avg_loss: 0.0,
            premiums: 0.0,
            rate: 0.0,
        }
    }
    pub fn clone(&self) -> Self {
        Self {
            val_near: self.val_near.clone(),
            stress_val: self.stress_val.clone(),
            avg_val: self.avg_val.clone(),
            stress_loss: self.stress_loss.clone(),
            avg_loss: self.avg_loss.clone(),
            premiums: self.premiums.clone(),
            rate: self.rate.clone(),
        }
    }
}

#[serde(crate = "near_sdk::serde")]
#[derive(BorshDeserialize, BorshSerialize, Clone, Serialize)]
pub struct PledgeStats {
    pub long: Stats,
    pub short: Stats,
    pub val_near_sp: Balance, // $ value of the NEAR solvency deposit
    pub val_total_sp: Balance, // total $ value of val_near plus $QD solvency deposit
}
impl PledgeStats {
    pub fn new() -> Self {
        Self {
            long: Stats::new(),
            short: Stats::new(),
            val_near_sp: 0,
            val_total_sp: 0
        }
    }
    pub fn clone(&self) -> Self {
        Self {
            long: self.long.clone(), 
            short: self.short.clone(),
            val_near_sp: self.val_near_sp.clone(),
            val_total_sp: self.val_total_sp.clone()
        }
    }
}

#[serde(crate = "near_sdk::serde")]
#[derive(BorshDeserialize, BorshSerialize, Clone, Serialize)]
pub struct Pledge { // each User is a Pledge, whether or not borrowing
    // borrowing users will have non-zero values in `long` and `short`
    pub long: Pod, // debt in $QD, collateral in NEAR
    pub short: Pod, // debt in NEAR, collateral in $QD
    // pub assets: Pool, // pledge.assets.long.debit
    // instead of pledge.long.debit
    pub stats: PledgeStats, // risk management metrics
    pub near: Balance, // SolvencyPool deposit of NEAR
    pub quid: Balance, // SolvencyPool deposit of $QD
    pub id: AccountId,
    pub target: u128
}
/*
 * Every great magic trick consists of three parts or acts. 
 * The first part is called "The Pledge". The magician shows 
 * you something ordinary: a deck of Troves, a cake or a pie.
 * He shows you this object, perhaps asks you to inspect it,
 * to see if it is indeed real, unaltered, normal...it's not.
*/
impl Pledge {
    pub fn clone(&self) -> Self {
        Self {
            long: self.long.clone(),
            short: self.short.clone(),
            stats: self.stats.clone(),
            near: self.near,
            quid: self.quid,
            id: self.id.clone(),
            target: self.target
        }
    }
}

pub trait PledgeForTreeMap: Clone + BorshSerialize + BorshDeserialize {
    fn get_id(&self) -> AccountId;
    fn get_debt_amt(&self, short: bool) -> U128;
    fn get_coll_val(&self, short: bool) -> U128;
    fn get_CR(&self, short: bool, price: u128) -> U128;
}
impl PledgeForTreeMap for Pledge {
    fn get_id(&self) -> AccountId {
        self.id.clone()
    }

    fn get_debt_amt(&self, short: bool) -> U128 {
        if short {
            return self.short.debit.into()
        } else {
            return self.long.debit.into()
        }
    }

    fn get_coll_val(&self, short: bool) -> U128 {
        if short {
            return self.short.credit.into()
        } else {
            return self.long.credit.into()
        }
    }

    fn get_CR(&self, short: bool, price: u128) -> U128 {
        if short {
            return computeCR(price, self.short.credit, self.short.debit, true).into();
        } else {
            return computeCR(price, self.long.credit, self.long.debit, false).into();
        }
    }
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct PledgeView {
    pub debit: WrappedBalance,
    pub s_debit: WrappedBalance,
    pub credit: WrappedBalance,
    pub s_credit: WrappedBalance,
    pub quid_sp: WrappedBalance,
    pub near_sp: WrappedBalance
}
 
impl From<&Pledge> for PledgeView {
    fn from(p: &Pledge) -> Self {
        Self {
            debit: p.long.debit.into(),
            s_debit: p.short.debit.into(),
            credit: p.long.credit.into(),
            s_credit: p.short.credit.into(),
            near_sp: p.near.into(),
            quid_sp: p.quid.into(),
        }
    }
}

#[near_bindgen]
impl Contract {
    pub(crate) fn save_pledge(&mut self, id: &AccountId,  pledge: &mut Pledge, long_touched: bool, short_touched: bool) {
        let mut dead_short = false;
        let mut dead_long = false;
        if short_touched {
            if self.short_crs.contains_key(&pledge, self.get_price()) {
                self.short_crs.remove(&pledge, self.get_price());
            }
            if pledge.short.debit > 0 && pledge.short.credit > 0 {
                self.short_crs.insert(&pledge, &(), self.get_price());
            } else {
                dead_short = true;
            }
        }
        if long_touched {
            if self.long_crs.contains_key(&pledge, self.get_price()) {
                self.long_crs.remove(&pledge, self.get_price());
            }
            if pledge.long.debit > 0 && pledge.long.credit > 0 {
                self.long_crs.insert(&pledge, &(), self.get_price());
            } else {
                dead_long = true; // TODO check
            }
        }
        if dead_short && dead_long && (pledge.quid == 0)
        &&  (pledge.near == 0) { self.pledges.remove(id); }
        else { self.pledges.insert(id, pledge); }
    }

    pub(crate) fn stress_pledge(&mut self, id: AccountId) { 
        let mut p: Pledge = self.pledges.get(&id).unwrap(); 
        let mut iVvol = self.get_vol() as f64; // get annualized volatility of NEAR
        let mut short_touched = false;
        let mut long_touched = false;
        let mut due: Balance = 0;         
        let mut cr = computeCR(self.get_price(), p.short.credit, p.short.debit, true);
        if cr < KILL_CR { 
            let nums = self.try_kill_pledge(&p, true);
            p.quid = nums.0; 
            p.near = nums.2;
            p.short.credit = nums.1;
            p.short.debit = nums.3;
            short_touched = true;
        }
        // TODO check precision stuff
        p.stats.short.val_near = self.get_price() * p.short.debit / ONE; // will be sum of each borrowed crypto amt * its price
        let mut val_near = p.stats.short.val_near as f64;
        let mut qd: f64 = p.short.credit as f64;
        if val_near > 0.0 { // $ value of Pledge' NEAR debt
            let mut iW: f64 = val_near; // the amount of this crypto in the user's short debt portfolio, times the crypto's price
            iW /= val_near; // 1.0 for now...TODO later each crypto will carry a different weight in the portfolio
            let var: f64 = (iW * iW) * (iVvol * iVvol); // aggregate for all Pledge's crypto debt
            let mut vol: f64 = var.sqrt(); // portfolio volatility of the Pledge's borrowed crypto
            short_touched = true;

            // $ value of borrowed crypto in upward price shocks of avg & bad magnitudes
            let mut pct: f64 = stress(true, vol, true);
            let avg_val: f64 = (1.0 + pct) * val_near;
            pct = stress(false, vol, true);
            let stress_val: f64 = (1.0 + pct) * val_near;
            let mut stress_loss: f64 = stress_val - qd; // stressed value
    
            if stress_loss < 0.0 {
                stress_loss = 0.0; // better if this is zero, if it's not 
                // that means liquidation (debt value worth > QD collat)
            } 
            let mut avg_loss: f64 = avg_val - qd;
            if avg_loss < 0.0 {   avg_loss = 0.0;   }

            // stats.short.stress_loss += stress_loss; 
            p.stats.short.stress_loss = stress_loss;
            // stats.short.avg_loss += avg_loss; 
            p.stats.short.avg_loss = avg_loss;

            vol *= self.data_s.scale; // market determined implied volaility
            let delta: f64 = pct + 1.0;
            let ln: f64 = delta.ln() * self.data_s.scale; // * calibrate
            let i_stress: f64 = ln.exp() - 1.0;
            let mut payoff: f64 = val_near * (1.0 + i_stress);
            if payoff > qd {
                payoff -= qd;
            } else {
                payoff = 0.0;
            };
            p.stats.short.rate = price(
                payoff, self.data_s.scale, val_near, qd, vol, true
            );
            p.stats.short.premiums = p.stats.short.rate * val_near;
            self.stats.short.premiums += p.stats.short.premiums;
            due = (p.stats.short.premiums / PERIOD).round() as Balance;
            
            p.short.credit = p.short.credit // the user pays their due by losing a bit of QD collateral
                .checked_sub(due).expect(ERR_SUB);
            
            self.live.short.credit = self.live.short.credit // reduce QD collateral in the LivePool
                .checked_sub(due).expect(ERR_SUB);
            
            // TODO scale for this
            let gf: Balance = due.checked_div(11).expect(ERR_DIV);
            due -= gf; // decrement from what is being paid into the gfund pool 
            self.gfund.short.credit = self.gfund.short.credit
                .checked_add(gf).expect(ERR_ADD);
            
            // pay SolvencyProviders by reducing how much they're owed to absorb in QD debt
            if self.dead.long.credit > due { 
                self.dead.long.credit -= due;
            } else { // take the remainder and add it to QD collateral to be absorbed from DeadPool
                due -= self.dead.long.credit;
                self.dead.long.credit = 0;
                self.dead.short.debit = self.dead.short.debit
                    .checked_add(due).expect(ERR_ADD);
            }     
        }     
        cr = computeCR(self.get_price(), p.long.credit, p.long.debit, false);
        if cr < KILL_CR { 
            let nums = self.try_kill_pledge(&p, false);
            p.near = nums.0; 
            p.quid = nums.2;
            p.long.credit = nums.1;
            p.long.debit = nums.3;
            long_touched = true;         
        }
        // TODO unsafe
        p.stats.long.val_near = self.get_price() * p.long.credit / ONE; // will be sum of each crypto collateral amt * its price
        val_near = p.stats.long.val_near as f64;
        qd = p.long.debit as f64;
        if val_near > 0.0 {
            let mut iW: f64 = val_near; // the amount of this crypto in the user's long collateral portfolio, times the crypto's price
            iW /= val_near; // 1.0 for now...TODO later each crypto will carry a different weight in the portfolio
            let var: f64 = (iW * iW) * (iVvol * iVvol); // aggregate for all Pledge's crypto collateral
            let mut vol: f64 = var.sqrt(); // total portfolio volatility of the Pledge's crypto collateral
            long_touched = true;

            // $ value of crypto collateral in downward price shocks of bad & avg magnitudes
            let mut pct: f64 = stress(true, vol, false);
            let avg_val: f64 = (1.0 - pct) * val_near;
            pct = stress(false, vol, false);
            let stress_val: f64 = (1.0 - pct) * val_near;
            
            let mut stress_loss: f64 = qd - stress_val;
            if stress_loss < 0.0 {   stress_loss = 0.0;  }
            let mut avg_loss: f64 = qd - avg_val;
            if avg_loss < 0.0 {   avg_loss = 0.0;   }

            // stats.long.stress_loss += stress_loss; 
            p.stats.long.stress_loss = stress_loss;
            // stats.long.avg_loss += avg_loss; 
            p.stats.long.avg_loss = avg_loss;
            
            vol *= self.data_l.scale; // market determined implied volaility
            let delta: f64 = (-1.0 * pct) + 1.0;
            let ln: f64 = delta.ln() * self.data_l.scale; // calibrate
            let i_stress: f64 = -1.0 * (ln.exp() - 1.0);
            let mut payoff: f64 = val_near * (1.0 - i_stress);
            if payoff > qd {
                payoff = 0.0;
            } else {
                payoff = p.long.debit as f64 - payoff;
            };
            p.stats.long.rate = price(payoff, self.data_l.scale, val_near, qd, vol, false);
            p.stats.long.premiums = p.stats.long.rate * qd;
            self.stats.long.premiums += p.stats.long.premiums;
            due = (p.stats.short.premiums / PERIOD).round() as Balance;
            let mut due_in_near = ratio(1, self.get_price(), due);
            
            p.long.credit = p.long.credit // A Pledge's long side is credited with NEAR collateral
                .checked_sub(due_in_near).expect(ERR_SUB);
            
            self.live.long.credit = self.live.long.credit
                .checked_sub(due_in_near).expect(ERR_SUB);

            let gf: Balance = due_in_near.checked_div(11).expect(ERR_DIV);
            due_in_near -= gf;
            self.gfund.long.credit = self.gfund.long.credit
                .checked_add(gf).expect(ERR_ADD);
            
            // pay SolvencyProviders by reducing how much they're owed to absorb in NEAR debt
            if self.dead.short.credit > due_in_near { 
                self.dead.short.credit -= due_in_near;
            } else { // take the remainder and add it to NEAR collateral to be absorbed from DeadPool
                due_in_near -= self.dead.short.credit;
                
                self.dead.short.credit = 0;
                self.dead.long.debit = self.dead.long.debit
                    .checked_add(due_in_near).expect(ERR_ADD);
            }  
        }
        self.save_pledge(&id, &mut p, long_touched, short_touched);
    }
}

'''
'''--- src/pool.rs ---
use crate::*;

use near_sdk::{env, log, Balance, Promise};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::json_types::{WrappedBalance, WrappedTimestamp, U128};

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct PoolStats {
    pub blood_credit: U128,
    pub blood_debit: U128,
    pub gfund_long_credit: U128,
    pub gfund_long_debit: U128,
    pub gfund_short_credit: U128,
    pub gfund_short_debit: U128,
    pub live_short_credit: U128,
    pub live_short_debit: U128,
    pub live_long_credit: U128,
    pub live_long_debit: U128,
    pub dead_short_credit: U128,
    pub dead_short_debit: U128,
    pub dead_long_credit: U128,
    pub dead_long_debit: U128
} impl PoolStats { 
    pub fn new(c: &Contract) -> Self {
        Self {
            blood_credit: U128::from(c.blood.credit),
            blood_debit: U128::from(c.blood.debit),
            gfund_long_credit: U128::from(c.gfund.long.credit),
            gfund_long_debit: U128::from(c.gfund.long.debit),
            gfund_short_credit: U128::from(c.gfund.short.credit),
            gfund_short_debit: U128::from(c.gfund.short.debit),
            live_short_credit: U128::from(c.live.short.credit),
            live_short_debit: U128::from(c.live.short.debit),
            live_long_credit: U128::from(c.live.long.credit),
            live_long_debit: U128::from(c.live.long.debit),
            dead_short_credit: U128::from(c.dead.short.credit),
            dead_short_debit: U128::from(c.dead.short.debit),
            dead_long_credit: U128::from(c.dead.long.credit),
            dead_long_debit: U128::from(c.dead.long.debit)
        }
    }
}

#[serde(crate = "near_sdk::serde")]
#[derive(BorshDeserialize, BorshSerialize, Debug, Clone, Serialize)]
pub struct Pod { // Used in all Pools, and in individual users' Pledges
    pub credit: Balance, // amount of QD collateral in shorts, NEAR in longs
    pub debit: Balance // amount of QDebt in longs, NEAR debt in shorts
} impl Pod { 
    pub fn new(ins: Balance, outs: Balance) -> Self {
        Self { 
            credit: ins, 
            debit: outs 
        } 
    }
    pub fn clone(&self) -> Self {
        Self {
            credit: self.credit, 
            debit: self.debit,
        }
    }
}

#[serde(crate = "near_sdk::serde")]
#[derive(BorshDeserialize, BorshSerialize, Debug, Serialize)]
pub struct Pool { // Pools have a long Pod and a short Pod
    pub long: Pod, // debt and collateral of QD borrowers
    pub short: Pod, // debt and collateral of NEAR borrowers
} impl Pool { // There are 4 capital pools in QuiD Protocol
    pub fn new() -> Self {
        Self {
            long: Pod::new(0, 0),
            short: Pod::new(0, 0)
        }
    }
}

#[near_bindgen]
impl Contract 
{    
    #[payable]
    // add collateral to LivePool / deposits to SolvencyPool
    // attach a deposit for adding NEAR, amount's for adding QD
    pub fn deposit(&mut self, qd_amt: U128, live: bool) {
        // TODO change vote
        assert!(self.crank.done, "Update in progress");
        let deposit = env::attached_deposit();
        assert!(deposit > 0, ERR_AMT_TOO_LOW);
        let mut amt: Balance = qd_amt.into();
        let mut left = amt;
        let mut min: Balance;
        
        let account = env::predecessor_account_id();
        let mut pledge = self.fetch_pledge(&account, true);
        let mut long_touched = false; let mut short_touched = false;

        // TODO if live = true && no borrowing position open

        if deposit > 1 {
            if live { // adding NEAR collateral to borrower's long position
                long_touched = true;
                pledge.long.credit = pledge.long.credit
                    .checked_add(deposit).expect(ERR_ADD);

                self.live.long.credit = self.live.long.credit
                    .checked_add(deposit).expect(ERR_ADD);
            } 
            else { // adding NEAR deposit to user's SolvencyPool position
                pledge.near = pledge.near
                    .checked_add(deposit).expect(ERR_ADD);

                self.blood.debit = self.blood.debit // crypto can be loaned out as debit to SP
                    .checked_add(deposit).expect(ERR_ADD);            
            }
        }
        if amt > 0 {
            let liq_qd: Balance = self.token.ft_balance_of(
                ValidAccountId::try_from(account.clone()).unwrap()
            ).into();
            min = std::cmp::min(liq_qd, amt);
            if min > 0 {
                self.token.internal_withdraw(&account, min);
                self.token.internal_deposit(&env::current_account_id(), min);
                left -= min;
            }
            if left > 0 {
                min = std::cmp::min(left, pledge.quid);
                left -= min;
                pledge.quid -= min;
            }
            amt -= left;
            if amt > 0 {    
                if live { // adding QD collateral to borrower's short position
                    short_touched = true;
                    pledge.short.credit = pledge.short.credit
                        .checked_add(amt).expect(ERR_ADD);
                    self.live.short.credit = self.live.short.credit
                        .checked_add(amt).expect(ERR_ADD);
                } 
                else { // adding QD deposit to user's SolvencyPool position
                    pledge.quid = pledge.quid
                        .checked_add(amt).expect(ERR_ADD);
                    self.blood.credit = self.blood.credit
                        .checked_add(amt).expect(ERR_ADD);
                }
            }
        }
        self.save_pledge(&account, &mut pledge, long_touched, short_touched);
    }

    // Invoked a la github.com/Narwallets/meta-pool-heartbeat
    // Script must call it regularly, it drives stress testing,
    // and re-pricing options for borrowers on account of this, 
    // and SolvencyTarget as SP's weighted-median voting concedes
    pub fn update(&mut self) {
        if !self.crank.done {
            // let mut pledges = &mut self.pledges; // BUG inside loop throws 
            // "cannot borrow `*self` as mutable more than once at a time"
            let mut keys = &self.pledges.to_vec();
            let len = self.pledges.len() as usize;
            let start = self.crank.index.clone();
            let left: usize = len - start;
            let mut many = 42; // arbitrary number of Pledges to iterate at a time
            // limited by maximum gas that can be burned in one transaction call
            if 42 > left {    many = left;    }
            let stop = start + many;
            for idx in start..stop { 
                let id = keys[idx].0.clone();
                self.stress_pledge(id);
                self.crank.index += 1;
            }
            if self.crank.index == len {
                self.crank.index = 0;
                self.crank.done = true;
                self.crank.last = env::block_timestamp();
            }  
        } else {
            let timestamp = env::block_timestamp();
            let time_delta = timestamp - self.crank.last;
            if time_delta >= EIGHT_HOURS {
                self.crank.done = false;
                let price = self.get_price();
                self.stats.val_near_sp = self.blood.debit.checked_mul(price).expect(
                    "Multiplication Overflow in `update`"
                );
                self.stats.val_total_sp = self.blood.credit
                    .checked_add(self.stats.val_near_sp).expect(ERR_ADD);
                self.sp_stress(None, false); // stress the long side of the SolvencyPool
                self.sp_stress(None, true); // stress the short side of the SolvencyPool
                self.risk(false); self.risk(true); // calculate solvency and scale factor 
            } else {
                env::panic(b"Too early to run an update, please wait"); 
            }
        }
    }  

    pub(crate) fn sp_stress(&mut self, maybe_id: Option<AccountId>, short: bool) -> f64 {
        let ivol = self.get_vol() as f64;
        let price = self.get_price();
        let mut global = true;
        let mut iW: f64 = 0.0; 
        let mut jW: f64 = 0.0;
        if self.stats.val_near_sp > 0 {
            iW = self.stats.val_near_sp
                .checked_div(self.stats.val_total_sp).expect(ERR_DIV) as f64;
     
            jW = self.blood.credit
                .checked_div(self.stats.val_total_sp).expect(ERR_DIV) as f64;
        }
        if let Some(id) = maybe_id {
            global = false;
            if let Some(p) = self.pledges.get(&id) {
                let p_near_val = p.near
                    .checked_mul(price).expect(ERR_MUL);
            
                let value = p.quid.checked_add(p_near_val).expect(ERR_ADD);

                let mut delta_near: Balance = 0;
                let mut delta_qd: Balance = 0;
                if value > 0 {
                    if self.stats.val_near_sp > 0 {
                        delta_near = self.stats.val_near_sp
                            .checked_sub(p_near_val).expect(ERR_SUB);
                    }
                    if self.blood.credit > 0 {
                        delta_qd = self.blood.credit
                            .checked_sub(p.quid).expect(ERR_SUB);
                    }
                    let delta_val = self.stats.val_total_sp
                        .checked_sub(value).expect(ERR_SUB);
                    
                    iW = delta_near
                        .checked_div(delta_val).expect(ERR_DIV) as f64;

                    jW = delta_qd
                        .checked_div(delta_val).expect(ERR_DIV) as f64;
                }            
            }
        }
        let var: f64 = (2.0 * iW * jW * ivol) + (iW * iW * ivol * ivol);
        if var > 0.0 {
            let vol = var.sqrt(); // total volatility of the SolvencyPool
            // % loss that total SP deposits would suffer in a stress event
            let stress_pct = stress(false, vol, short);
            let avg_pct = stress(true, vol, short);
            let mut stress_val: f64 = self.stats.val_total_sp as f64;
            let mut avg_val: f64 = stress_val;
            if !short {
                stress_val *= 1.0 - stress_pct; 
                avg_val *= 1.0 - avg_pct;
                if global {
                    self.stats.long.stress_val = stress_val;
                    self.stats.long.avg_val = avg_val;
                } 
            } else {
                stress_val *= 1.0 + stress_pct;
                avg_val *= 1.0 + avg_pct;
                if global {
                    self.stats.short.stress_val = stress_val;
                    self.stats.short.avg_val = avg_val;
                } 
            }
            return stress_val;
        } else {
            return 0.0;
        }
    }
    
    pub(crate) fn risk(&mut self, short: bool) {
        let mvl_s: f64; // market value of liabilities in stressed markets 
        let mva_s: f64; // market value of assets in stressed markets 
        let mva_n = self.stats.val_total_sp; //market value of insurance assets in normal markets,
        // includes the reserve which is implemented as an insurer, collateral is not an asset of the insurers
        
        let mut vol = self.get_vol() as f64; 
        let val_near: f64;
        if !short {
            val_near = self.live.long.credit
                .checked_mul(self.get_price()).expect(ERR_MUL) as f64;

            let qd: f64 = self.live.long.debit as f64;
            let mut pct: f64 = stress(false, vol, false);
            
            let stress_val = (1.0 - pct) * val_near;
            let stress_loss = qd - stress_val;
            
            mva_s = stress_val; // self.stats.long.stress_val;
            mvl_s = stress_loss; // self.stats.long.stress_loss;
        } else {
            val_near = self.live.short.debit
                .checked_mul(self.get_price()).expect(ERR_MUL) as f64;
            
            let qd: f64 = self.live.short.credit as f64;
            let mut pct: f64 = stress(false, vol, true);
            
            let stress_val = (1.0 + pct) * val_near;
            let stress_loss = stress_val - qd;

            mva_s = stress_val; // self.stats.short.stress_val;
            mvl_s = stress_loss; // self.stats.short.stress_loss;
        }    
        let own_n = mva_n as f64; // own funds normal markets
        let mut own_s = mva_s - mvl_s; // own funds stressed markets
        if short && own_s > 0.0 {
            own_s *= -1.0;   
        }
        // S.olvency C.apial R.equirement is the amount of... 
        // deposited assets needed to survive a stress event
        let scr = own_n - own_s;
        assert!(scr > 0.0, "SCR can't be 0");
        let solvency = own_n / scr; // represents capital adequacy to back $QD
        if short {
            let mut target = self.data_s.median;
            if target == -1.0 {
                target = 1.0;
            }
            // assume target = 1.5 or 150%
            let mut scale = target / solvency;
            if scale > 4.2 {
                scale = 4.2;    
            } else if scale < 0.042 {
                scale = 0.042;
            }
            self.data_s.scale = scale;
            self.data_s.solvency = solvency
        } else {
            let mut target = self.data_l.median;
            if target == -1.0 {
                target = 1.0;
            }
            let mut scale = target / solvency;
            if scale > 4.2 {
                scale = 4.2;    
            } else if scale < 0.042 {
                scale = 0.042;
            }
            self.data_l.scale = scale;
            self.data_l.solvency = solvency;
        }
    }
}
'''
'''--- src/utils.rs ---

use crate::pledge::*; //mod pledge;
use crate::*;

use near_sdk::collections::TreeMap;
use near_sdk::IntoStorageKey;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use std::ops::Bound;
use core::f64;

pub const TWO_PI: f64 = 2.0 * PI;
pub const PERIOD: f64 = 1095.0; // = (365*24)/8h of dues 
pub const ONE_HOUR: u64 = 360_000_000_000;
pub const EIGHT_HOURS: u64 = 28_800_000_000_000; // nanosecs
pub const ONE: u128 = 1_000000_000000_000000_000000;
pub const PI: f64 = 3.14159265358979323846264338327950288;
pub const MIN_CR: u128 = 1_100_000_000_000_000_000_000_000;
pub const KILL_CR: u128 = 1_000_000_000_000_000_000_000_000;
pub const DOT_OH_NINE: u128 = 90_909_090_909_090_909_090_909;
pub const FEE: u128 = 9_090_909_090_909_090_909_090; // TODO votable FEE, via SputnikV3
pub const MIN_DEBT: u128 = 90_909_090_909_090_909_090_909_090;

// pub stNEAR: AccountId = "meta-pool.near".parse().unwrap(); // mainnet
// pub stNEAR: AccountId = "meta-v2.pool.testnet".parse().unwrap();
// pub stNEAR: AccountId = "v2.ref-finance.near".parse().unwrap(); // mainnet
// pub stNEAR: AccountId = "v2.ref-finance.testnet".parse().unwrap();

// ======= Error Strings ==================

pub const ERR_ADD: &'static str =
    "Addition overflow";
pub const ERR_DIV: &'static str =
    "Division overflow";
pub const ERR_MUL: &'static str =
    "Multiplication overflow";
pub const ERR_SUB: &'static str =
    "Subtraction underflow";
pub const ERR_BELOW_MIN_CR: &'static str =
    "Cannot do operation that would result in CR below min";
pub const ERR_AMT_TOO_LOW: &'static str = 
    "Amount must be larger than 0";
pub const ERR_MAX_LEVERAGE: &'static str = 
    "Leverage must be between 2-10x";
// TODO
// pub const OldVoteNotFound: &'static str = 
//     "OldVoteNotFound";
// pub const WrongWeightsLength: &'static str = 
//     "WrongWeightsLength";
// pub const MustStakeBeforeVote: &'static str = 
//     "MustStakeBeforeVote";
// pub const ZeroStakeBeforeVote: &'static str = 
//     "ZeroStakeBeforeVote";
// ========================================

#[derive(Debug, BorshDeserialize, BorshSerialize)]
pub enum Sort {
    Composite,
    CollaterlizationRatio,
}

pub fn ratio(multiplier:u128, numerator: u128, denominator: u128) -> u128 { 
    return (
        U256::from(numerator)
            .checked_mul(U256::from(multiplier)).expect("Overflow")
            .checked_div(U256::from(denominator)).expect("Overflow")
    ).as_u128();
}

pub fn computeCR(_price: u128, _collat: u128, _debt: u128, _short: bool) -> u128 {
    if _debt > 0 {
        // assert!(_collat > 0, "never supposed to happen");
        if _collat > 0 {
            if _short {
                let debt = ratio(_price, _debt, ONE);
                return ratio(ONE, _collat, debt);
            } else {
                return ratio(_price, _collat, _debt);
            }
        }
        else {
            return 0;
        }
    } 
    else if _collat > 0 {
        return u128::MAX;
    }
    return 0;
}

// Newton's method of integer square root. 
// pub fn integer_sqrt(value: U256) -> U256 {
//     let mut guess: U256 = (value + U256::one()) >> 1;
//     let mut res = value;
//     while guess < res {
//         res = guess;
//         guess = (value / guess + guess) >> 1;
//     }
//     res
// }

pub fn RationalApproximation(t: f64) -> f64 {
    // Abramowitz and Stegun formula 26.2.23.
    // The absolute value of the error should be less than 4.5 e-4.
    let c: [f64; 3] = [2.515517, 0.802853, 0.010328];
    let d: [f64; 3] = [1.432788, 0.189269, 0.001308];
    t - ((c[2] * t + c[1]) * t + c[0]) / 
        (((d[2] * t + d[1]) * t + d[0]) * t + 1.0)
}

pub fn NormalCDFInverse(p: f64) -> f64 {
    assert!(p > 0.0 && p < 1.0);
    // See article above for explanation of this section.
    if p < 0.5 { // F^-1(p) = -G^-1(p)
        let n: f64 = -2.0 * p.ln();
        return -1.0 * RationalApproximation( n.sqrt() );
    }
    else { // F^-1(p) = G^-1(1-p)
        let l: f64 = 1.0 - p;
        let n: f64 = -2.0 * l.ln();
        return RationalApproximation(n.sqrt());
    }
}

// calculate % loss given short Pledge's portfolio volatility & the statistical assumption of normality
pub fn stress(avg: bool, sqrt_var: f64, short: bool) -> f64 { // max portfolio loss in %
    let mut alpha: f64 = 0.90; // 10% of the worst case scenarios
    if avg {
        alpha = 0.50;  // 50% of the avg case scenarios
    }
    let cdf = NormalCDFInverse(alpha);
    let e1 = -1.0 * (cdf * cdf) / 2.0;
    let mut e2 = ((e1.exp() / TWO_PI.sqrt()) / (1.0 - alpha)) * sqrt_var;
    if short {
        return e2.exp() - 1.0;    
    } else {
        e2 *= -1.0;
        return -1.0 * (e2.exp() - 1.0);
    }
}

// Used for pricing put & call options for borrowers contributing to the ActivePool
pub fn price(payoff: f64, scale: f64, val_crypto: f64, val_quid: f64, ivol: f64, short: bool) -> f64 {
    let max_rate: f64 = 0.42;
    let min_rate: f64 = 0.0042 * scale; // * calibrate
    let sqrt_two: f64 = 2.0_f64.sqrt();
    let div = val_crypto / val_quid;
    let ln = div.ln();
    let d: f64 = (ln + (ivol * ivol / -2.0)/* times calibrate */) / ivol; // * calibrate
    let D = d / sqrt_two;
    let mut rate: f64;
    if short { // erfc is used instead of normal distribution
        rate = (payoff * libm::erfc(-1.0 * D) / 2.0) / val_crypto;
    } else {
        rate = (payoff * libm::erfc(D) / 2.0) / val_quid;
    }
    // rate *= calibrate;
    if rate > max_rate {
        rate = max_rate;
    } else if rate < min_rate {
        rate = min_rate;
    }
    return rate;
}

// ======= TreeMap wrapper for sorting by CR, by 4ire Labs ==================

#[derive(BorshDeserialize, BorshSerialize, Clone)]
pub enum SortKeys<U: PledgeForTreeMap> {
    CRKey { pledge: U, key: (u128, AccountId) },
    CompositeKey { pledge: U, key: (i128, u128, AccountId) },
}

impl<U: PledgeForTreeMap> std::cmp::PartialEq for SortKeys<U> {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (
                SortKeys::CRKey {
                    pledge: _,
                    key: self_key,
                },
                SortKeys::CRKey {
                    pledge: _,
                    key: other_key,
                },
            ) => self_key == other_key,
            (
                SortKeys::CompositeKey {
                    pledge: _,
                    key: self_key,
                },
                SortKeys::CompositeKey {
                    pledge: _,
                    key: other_key,
                },
            ) => self_key == other_key,
            (SortKeys::CRKey { pledge: _, key: _ }, SortKeys::CompositeKey { pledge: _, key: _ }) => {
                env::panic(b"Using different sort")
            }
            (SortKeys::CompositeKey { pledge: _, key: _ }, SortKeys::CRKey { pledge: _, key: _ }) => {
                env::panic(b"Using different sort")
            }
        }
    }
}

impl<U: PledgeForTreeMap> std::cmp::PartialOrd for SortKeys<U> {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        match (self, other) {
            (
                SortKeys::CRKey {
                    pledge: _,
                    key: self_key,
                },
                SortKeys::CRKey {
                    pledge: _,
                    key: other_key,
                },
            ) => Some(self_key.cmp(other_key)),
            (
                SortKeys::CompositeKey {
                    pledge: _,
                    key: self_key,
                },
                SortKeys::CompositeKey {
                    pledge: _,
                    key: other_key,
                },
            ) => Some(self_key.cmp(other_key)),
            (SortKeys::CRKey { pledge: _, key: _ }, SortKeys::CompositeKey { pledge: _, key: _ }) => {
                env::panic(b"Using different sort")
            }
            (SortKeys::CompositeKey { pledge: _, key: _ }, SortKeys::CRKey { pledge: _, key: _ }) => {
                env::panic(b"Using different sort")
            }
        }
    }
}

impl<U: PledgeForTreeMap> std::cmp::Eq for SortKeys<U> {}
impl<U: PledgeForTreeMap> std::cmp::Ord for SortKeys<U> {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        match (self, other) {
            (
                SortKeys::CRKey {
                    pledge: _,
                    key: self_key,
                },
                SortKeys::CRKey {
                    pledge: _,
                    key: other_key,
                },
            ) => self_key.cmp(other_key),
            (
                SortKeys::CompositeKey {
                    pledge: _,
                    key: self_key,
                },
                SortKeys::CompositeKey {
                    pledge: _,
                    key: other_key,
                },
            ) => self_key.cmp(other_key),
            (SortKeys::CRKey { pledge: _, key: _ }, SortKeys::CompositeKey { pledge: _, key: _ }) => {
                env::panic(b"Using different sort")
            }
            (SortKeys::CompositeKey { pledge: _, key: _ }, SortKeys::CRKey { pledge: _, key: _ }) => {
                env::panic(b"Using different sort")
            }
        }
    }
}

impl<U: PledgeForTreeMap> SortKeys<U> {
    pub fn new(pledge: &U, id: AccountId, sort: &Sort, short: bool, price: u128) -> Self {
        match sort {
            Sort::Composite => {
                let mut deb = pledge.get_debt_amt(short).0;
                let mut i = 0;
                let magnitude: i128 = loop {
                    if deb / 10 == 0 {
                        break i;
                    }
                    deb /= 10;
                    i += 1;
                };
                SortKeys::CompositeKey {
                    pledge: pledge.clone(),
                    key: (-magnitude, pledge.get_CR(short, price).0, id),
                }
            }
            Sort::CollaterlizationRatio => SortKeys::CRKey {
                pledge: pledge.clone(),
                key: (pledge.get_CR(short, price).0, id),
            },
        }
    }
    pub fn get_pledge(&self) -> U {
        match self {
            SortKeys::CRKey { pledge, key: _ } => pledge.clone(),
            SortKeys::CompositeKey { pledge, key: _ } => pledge.clone(),
        }
    }
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct PledgesTreeMap<K: PledgeForTreeMap, V: BorshSerialize + BorshDeserialize> {
    value: TreeMap<SortKeys<K>, V>,
    type_of_sort: Sort,
    short: bool
}

impl<V: BorshSerialize + BorshDeserialize, K: PledgeForTreeMap> PledgesTreeMap<K, V> {
    pub fn new<S: IntoStorageKey>(prefix: S, type_of_sort: Sort, short: bool) -> Self {
        let prefix = prefix.into_storage_key();
        PledgesTreeMap {
            type_of_sort,
            value: TreeMap::new([&prefix[..], &[b'v']].concat()),
            short
        }
    }

    pub fn len(&self) -> u64 {
        self.value.len()
    }

    pub fn clear(&mut self) {
        self.value.clear()
    }

    pub fn contains_key(&self, key: &K, price: u128) -> bool {
        self.value
            .contains_key(&SortKeys::new(key, key.get_id(), &self.type_of_sort, self.short, price))
    }

    pub fn get(&self, key: &K, price: u128) -> Option<V> {
        self.value
            .get(&SortKeys::new(key, key.get_id(), &self.type_of_sort, self.short, price))
    }

    pub fn insert(&mut self, key: &K, val: &V, price: u128) -> Option<V> {
        self.value
            .insert(&SortKeys::new(key, key.get_id(), &self.type_of_sort, self.short, price), val)
    }

    pub fn remove(&mut self, key: &K, price: u128) -> Option<V> {
        self.value
            .remove(&SortKeys::new(key, key.get_id(), &self.type_of_sort, self.short, price))
    }

    pub fn min(&self) -> Option<K> {
        self.value.min().map(|sort_key| sort_key.get_pledge())
    }

    pub fn max(&self) -> Option<K> {
        self.value.max().map(|sort_key| sort_key.get_pledge())
    }

    pub fn higher(&self, key: &K, price: u128) -> Option<K> {
        self.value
            .higher(&SortKeys::new(key, key.get_id(), &self.type_of_sort, self.short, price))
            .map(|sort_key| sort_key.get_pledge())
    }

    pub fn lower(&self, key: &K, price: u128) -> Option<K> {
        self.value
            .lower(&SortKeys::new(key, key.get_id(), &self.type_of_sort, self.short, price))
            .map(|sort_key| sort_key.get_pledge())
    }

    pub fn ceil_key(&self, key: &K, price: u128) -> Option<K> {
        self.value
            .ceil_key(&SortKeys::new(key, key.get_id(), &self.type_of_sort, self.short, price))
            .map(|sort_key| sort_key.get_pledge())
    }

    pub fn floor_key(&self, key: &K, price: u128) -> Option<K> {
        self.value
            .floor_key(&SortKeys::new(key, key.get_id(), &self.type_of_sort, self.short, price))
            .map(|sort_key| sort_key.get_pledge())
    }

    pub fn iter<'a>(&'a self) -> impl Iterator<Item = (K, V)> + 'a {
        self.value
            .iter()
            .map(|(sort_key, val)| (sort_key.get_pledge(), val))
    }

    pub fn iter_from<'a>(&'a self, key: K, price: u128) -> impl Iterator<Item = (K, V)> + 'a {
        self.value
            .iter_from(SortKeys::new(&key, key.get_id(), &self.type_of_sort, self.short, price))
            .map(|(sort_key, val)| (sort_key.get_pledge(), val))
    }

    pub fn iter_rev<'a>(&'a self) -> impl Iterator<Item = (K, V)> + 'a {
        self.value
            .iter_rev()
            .map(|(sort_key, val)| (sort_key.get_pledge(), val))
    }

    pub fn iter_rev_from<'a>(&'a self, key: K, price: u128) -> impl Iterator<Item = (K, V)> + 'a {
        self.value
            .iter_rev_from(SortKeys::new(&key, key.get_id(), &self.type_of_sort, self.short, price))
            .map(|(sort_key, val)| (sort_key.get_pledge(), val))
    }

    pub fn range<'a>(&'a self, r: (Bound<K>, Bound<K>), price: u128) -> impl Iterator<Item = (K, V)> + 'a {
        let (lo, hi) = r;
        let lo = match &lo {
            Bound::Included(key) => {
                Bound::Included(SortKeys::new(key, key.get_id(), &self.type_of_sort, self.short, price))
            }
            Bound::Excluded(key) => {
                Bound::Excluded(SortKeys::new(key, key.get_id(), &self.type_of_sort, self.short, price))
            }
            _ => Bound::Unbounded,
        };
        let hi = match &hi {
            Bound::Included(key) => {
                Bound::Included(SortKeys::new(key, key.get_id(), &self.type_of_sort, self.short, price))
            }
            Bound::Excluded(key) => {
                Bound::Excluded(SortKeys::new(key, key.get_id(), &self.type_of_sort, self.short, price))
            }
            _ => Bound::Unbounded,
        };
        self.value
            .range((lo, hi))
            .map(|(sort_key, val)| (sort_key.get_pledge(), val))
    }

    pub fn to_vec(&self) -> Vec<(K, V)> {
        self.iter().collect()
    }

    pub fn get_top(&self, n: usize) -> Vec<(K, V)> {
        self.iter().take(n).collect::<Vec<(K, V)>>()
    }
}

impl<'a, K: PledgeForTreeMap, V: BorshSerialize + BorshDeserialize> IntoIterator
    for &'a PledgesTreeMap<K, V>
{
    type Item = (K, V);
    type IntoIter = PledgesTreeMapIntoIterator<'a, K, V>;

    fn into_iter(self) -> Self::IntoIter {
        PledgesTreeMapIntoIterator {
            map: &self.value,
            current_key: self.value.min(),
        }
    }
}

pub struct PledgesTreeMapIntoIterator<'a, K: PledgeForTreeMap, V: BorshSerialize + BorshDeserialize> {
    map: &'a TreeMap<SortKeys<K>, V>,
    current_key: Option<SortKeys<K>>,
}

impl<'a, K: PledgeForTreeMap, V: BorshSerialize + BorshDeserialize> Iterator
    for PledgesTreeMapIntoIterator<'a, K, V>
{
    type Item = (K, V);
    fn next(&mut self) -> Option<Self::Item> {
        match &self.current_key {
            None => None,
            Some(current_key) => {
                let result = self
                    .map
                    .get(current_key)
                    .map(|val| (current_key.get_pledge(), val));
                self.current_key = self.map.ceil_key(current_key);
                result
            }
        }
    }
}

'''