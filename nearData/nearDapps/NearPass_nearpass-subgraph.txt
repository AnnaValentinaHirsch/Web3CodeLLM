*GitHub Repository "NearPass/nearpass-subgraph"*

'''--- License.md ---
MIT License

Copyright (c) 2022 NearPass

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

'''
'''--- README.md ---
### NearPass SubGraph

-   The subgraph makes it easy to query blockchain information via API endpoints.

#### Install dependencies

```bash
npm install
```

You will need to have `graph-cli` installed globally.

```
# NPM
npm install -g @graphprotocol/graph-cli

# Yarn
yarn global add @graphprotocol/graph-cli
```

Build using

```bash
yarn build
```

Re-Deploy using

```bash
yarn deploy
```

#### Subgraph is deployed [here](https://thegraph.com/hosted-service/subgraph/therealharpaljadeja/nearpass)

'''
'''--- generated/schema.ts ---
// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class Event extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Event entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Event must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Event", id.toString(), this);
    }
  }

  static load(id: string): Event | null {
    return changetype<Event | null>(store.get("Event", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get title(): string {
    let value = this.get("title");
    return value!.toString();
  }

  set title(value: string) {
    this.set("title", Value.fromString(value));
  }

  get description(): string | null {
    let value = this.get("description");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set description(value: string | null) {
    if (!value) {
      this.unset("description");
    } else {
      this.set("description", Value.fromString(<string>value));
    }
  }

  get thumbnail(): string | null {
    let value = this.get("thumbnail");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set thumbnail(value: string | null) {
    if (!value) {
      this.unset("thumbnail");
    } else {
      this.set("thumbnail", Value.fromString(<string>value));
    }
  }

  get active(): boolean {
    let value = this.get("active");
    return value!.toBoolean();
  }

  set active(value: boolean) {
    this.set("active", Value.fromBoolean(value));
  }

  get price(): string {
    let value = this.get("price");
    return value!.toString();
  }

  set price(value: string) {
    this.set("price", Value.fromString(value));
  }

  get ticketsRemaining(): i32 {
    let value = this.get("ticketsRemaining");
    return value!.toI32();
  }

  set ticketsRemaining(value: i32) {
    this.set("ticketsRemaining", Value.fromI32(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get eventType(): string | null {
    let value = this.get("eventType");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set eventType(value: string | null) {
    if (!value) {
      this.unset("eventType");
    } else {
      this.set("eventType", Value.fromString(<string>value));
    }
  }

  get venue(): string | null {
    let value = this.get("venue");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set venue(value: string | null) {
    if (!value) {
      this.unset("venue");
    } else {
      this.set("venue", Value.fromString(<string>value));
    }
  }

  get tickets(): Array<string> | null {
    let value = this.get("tickets");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toStringArray();
    }
  }

  set tickets(value: Array<string> | null) {
    if (!value) {
      this.unset("tickets");
    } else {
      this.set("tickets", Value.fromStringArray(<Array<string>>value));
    }
  }

  get host(): string {
    let value = this.get("host");
    return value!.toString();
  }

  set host(value: string) {
    this.set("host", Value.fromString(value));
  }

  get telegram(): string | null {
    let value = this.get("telegram");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set telegram(value: string | null) {
    if (!value) {
      this.unset("telegram");
    } else {
      this.set("telegram", Value.fromString(<string>value));
    }
  }

  get discord(): string | null {
    let value = this.get("discord");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set discord(value: string | null) {
    if (!value) {
      this.unset("discord");
    } else {
      this.set("discord", Value.fromString(<string>value));
    }
  }

  get question1(): string | null {
    let value = this.get("question1");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set question1(value: string | null) {
    if (!value) {
      this.unset("question1");
    } else {
      this.set("question1", Value.fromString(<string>value));
    }
  }

  get question2(): string | null {
    let value = this.get("question2");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set question2(value: string | null) {
    if (!value) {
      this.unset("question2");
    } else {
      this.set("question2", Value.fromString(<string>value));
    }
  }

  get faq(): string | null {
    let value = this.get("faq");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set faq(value: string | null) {
    if (!value) {
      this.unset("faq");
    } else {
      this.set("faq", Value.fromString(<string>value));
    }
  }

  get attendees(): BigInt {
    let value = this.get("attendees");
    return value!.toBigInt();
  }

  set attendees(value: BigInt) {
    this.set("attendees", Value.fromBigInt(value));
  }
}

export class FAQ extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FAQ entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type FAQ must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("FAQ", id.toString(), this);
    }
  }

  static load(id: string): FAQ | null {
    return changetype<FAQ | null>(store.get("FAQ", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get question1(): string | null {
    let value = this.get("question1");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set question1(value: string | null) {
    if (!value) {
      this.unset("question1");
    } else {
      this.set("question1", Value.fromString(<string>value));
    }
  }

  get answer1(): string | null {
    let value = this.get("answer1");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set answer1(value: string | null) {
    if (!value) {
      this.unset("answer1");
    } else {
      this.set("answer1", Value.fromString(<string>value));
    }
  }

  get question2(): string | null {
    let value = this.get("question2");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set question2(value: string | null) {
    if (!value) {
      this.unset("question2");
    } else {
      this.set("question2", Value.fromString(<string>value));
    }
  }

  get answer2(): string | null {
    let value = this.get("answer2");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set answer2(value: string | null) {
    if (!value) {
      this.unset("answer2");
    } else {
      this.set("answer2", Value.fromString(<string>value));
    }
  }
}

export class Host extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Host entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Host must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Host", id.toString(), this);
    }
  }

  static load(id: string): Host | null {
    return changetype<Host | null>(store.get("Host", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get name(): string {
    let value = this.get("name");
    return value!.toString();
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get address(): string {
    let value = this.get("address");
    return value!.toString();
  }

  set address(value: string) {
    this.set("address", Value.fromString(value));
  }

  get email(): string | null {
    let value = this.get("email");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set email(value: string | null) {
    if (!value) {
      this.unset("email");
    } else {
      this.set("email", Value.fromString(<string>value));
    }
  }

  get events(): Array<string> | null {
    let value = this.get("events");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toStringArray();
    }
  }

  set events(value: Array<string> | null) {
    if (!value) {
      this.unset("events");
    } else {
      this.set("events", Value.fromStringArray(<Array<string>>value));
    }
  }
}

export class Ticket extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Ticket entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Ticket must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Ticket", id.toString(), this);
    }
  }

  static load(id: string): Ticket | null {
    return changetype<Ticket | null>(store.get("Ticket", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get event(): string {
    let value = this.get("event");
    return value!.toString();
  }

  set event(value: string) {
    this.set("event", Value.fromString(value));
  }

  get used(): boolean {
    let value = this.get("used");
    return value!.toBoolean();
  }

  set used(value: boolean) {
    this.set("used", Value.fromBoolean(value));
  }

  get redeemable(): boolean {
    let value = this.get("redeemable");
    return value!.toBoolean();
  }

  set redeemable(value: boolean) {
    this.set("redeemable", Value.fromBoolean(value));
  }

  get answer1(): string | null {
    let value = this.get("answer1");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set answer1(value: string | null) {
    if (!value) {
      this.unset("answer1");
    } else {
      this.set("answer1", Value.fromString(<string>value));
    }
  }

  get answer2(): string | null {
    let value = this.get("answer2");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set answer2(value: string | null) {
    if (!value) {
      this.unset("answer2");
    } else {
      this.set("answer2", Value.fromString(<string>value));
    }
  }

  get name(): string {
    let value = this.get("name");
    return value!.toString();
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get email(): string | null {
    let value = this.get("email");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set email(value: string | null) {
    if (!value) {
      this.unset("email");
    } else {
      this.set("email", Value.fromString(<string>value));
    }
  }

  get phone(): string | null {
    let value = this.get("phone");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set phone(value: string | null) {
    if (!value) {
      this.unset("phone");
    } else {
      this.set("phone", Value.fromString(<string>value));
    }
  }

  get accountId(): string {
    let value = this.get("accountId");
    return value!.toString();
  }

  set accountId(value: string) {
    this.set("accountId", Value.fromString(value));
  }
}

'''
'''--- networks.json ---
{
  "near-testnet": {
    "Event": {}
  }
}
'''
'''--- package.json ---
{
    "name": "nearpass",
    "license": "UNLICENSED",
    "scripts": {
        "codegen": "graph codegen",
        "build": "graph build",
        "deploy": "graph deploy --product hosted-service therealharpaljadeja/nearpass",
        "create-local": "graph create --node http://localhost:8020/ nearpass/nearpass",
        "remove-local": "graph remove --node http://localhost:8020/ nearpass/nearpass",
        "deploy-local": "graph deploy --node http://localhost:8020/ --ipfs http://localhost:5001 nearpass/nearpass",
        "test": "graph test"
    },
    "dependencies": {
        "@graphprotocol/graph-cli": "0.35.0",
        "@graphprotocol/graph-ts": "0.28.1"
    }
}

'''
'''--- src/event.ts ---
import {
    near,
    JSONValue,
    json,
    ipfs,
    log,
    TypedMap,
    Bytes,
    BigInt,
} from "@graphprotocol/graph-ts";
import { Event, FAQ, Host, Ticket } from "../generated/schema";

export function handleReceipt(receipt: near.ReceiptWithOutcome): void {
    const actions = receipt.receipt.actions;
    for (let i = 0; i < actions.length; i++) {
        handleAction(actions[i], receipt);
    }
}

function handleAction(
    action: near.ActionValue,
    receipt: near.ReceiptWithOutcome
): void {
    if (action.kind != near.ActionKind.FUNCTION_CALL) {
        return;
    }

    const outcome = receipt.outcome;
    const funcitonCall = action.toFunctionCall();
    const methodName = funcitonCall.methodName;

    log.info("methodName {}", [methodName]);

    if (methodName == "createEvent") {
        handleCreateEvent(outcome);
    }

    if (methodName == "buyTicketCallback") {
        handleBuyTicket(outcome);
    }

    if (methodName == "redeem") {
        handleRedeem(outcome);
    }
}

function handleCreateEvent(outcome: near.ExecutionOutcome): void {
    for (let logIndex = 0; logIndex < outcome.logs.length; logIndex++) {
        const outcomeLog = outcome.logs[logIndex].toString();

        const jsonData = json.try_fromString(outcomeLog);

        const jsonObject = jsonData.value.toObject();

        let id = jsonObject.get("id");
        if (id) {
            let event = new Event(id.toString());
            let title = jsonObject.get("title");
            let active = jsonObject.get("active");
            let price = jsonObject.get("price");
            let timestamp = jsonObject.get("timestamp");
            let eventMetadata = (jsonObject.get(
                "eventMetadata"
            ) as JSONValue).toObject();

            event.title = (title as JSONValue).toString();
            event.active = (active as JSONValue).toBool();
            event.price = (price as JSONValue).toString();
            event.timestamp = (timestamp as JSONValue).toBigInt();

            let hostFromJson = jsonObject.get("host");
            let hostObject = (hostFromJson as JSONValue).toObject();

            let name = hostObject.get("name") as JSONValue;
            let address = hostObject.get("accountId") as JSONValue;
            let host = new Host(name.toString());
            let faq = new FAQ(id.toString());

            host.name = name.toString();
            host.address = address.toString();
            event.host = host.id;

            if (eventMetadata) {
                let hostEmail = (eventMetadata.get(
                    "hostemail"
                ) as JSONValue).toString();
                let telegram = (eventMetadata.get(
                    "telegram"
                ) as JSONValue).toString();
                let discord = (eventMetadata.get(
                    "discord"
                ) as JSONValue).toString();
                let venue = (eventMetadata.get(
                    "venue"
                ) as JSONValue).toString();
                let eventType = (eventMetadata.get(
                    "eventType"
                ) as JSONValue).toString();

                event.description = (eventMetadata.get(
                    "description"
                ) as JSONValue).toString();
                event.thumbnail = (eventMetadata.get(
                    "thumbnail"
                ) as JSONValue).toString();

                event.eventType = eventType;
                event.venue = venue;
                event.telegram = telegram;
                event.discord = discord;
                event.attendees = BigInt.fromString("0");

                event.question1 = (eventMetadata.get(
                    "question1"
                ) as JSONValue).toString();
                event.question2 = (eventMetadata.get(
                    "question2"
                ) as JSONValue).toString();

                faq.question1 = (eventMetadata.get(
                    "faqquestion1"
                ) as JSONValue).toString();
                faq.question2 = (eventMetadata.get(
                    "faqquestion2"
                ) as JSONValue).toString();
                faq.answer1 = (eventMetadata.get(
                    "answer1"
                ) as JSONValue).toString();
                faq.answer2 = (eventMetadata.get(
                    "answer2"
                ) as JSONValue).toString();

                event.faq = faq.id;
                host.email = hostEmail;
            }
            faq.save();
            host.save();
            event.save();
        }
    }
}

// function handleObjects(jsonObject: TypedMap<string, JSONValue>): void {
//     jsonObject.entries.forEach((entry) => {
//         switch (entry.value.kind) {
//             case 1:
//                 log.info("entry {} {} {}", [
//                     entry.key,
//                     entry.value.kind.toString(),
//                     entry.value.toBool().toString(),
//                 ]);
//                 break;
//             case 2:
//                 log.info("entry {} {} {}", [
//                     entry.key,
//                     entry.value.kind.toString(),
//                     entry.value.toU64().toString(),
//                 ]);
//                 break;
//             case 3:
//                 log.info("entry {} {} {}", [
//                     entry.key,
//                     entry.value.kind.toString(),
//                     entry.value.toString(),
//                 ]);
//                 break;
//             case 5:
//                 handleObjects(entry.value.toObject());
//                 break;
//         }
//     });
// }

function handleBuyTicket(outcome: near.ExecutionOutcome): void {
    for (let i = 0; i < outcome.logs.length; i++) {
        const outcomeLog = outcome.logs[i].toString();

        const jsonData = json.try_fromString(outcomeLog);

        const jsonObject = jsonData.value.toObject();

        const ticketId = jsonObject.get("ticketId");
        if (ticketId) {
            let ticket = new Ticket(ticketId.toString());
            let eventId = (jsonObject.get("eventId") as JSONValue).toString();
            let accountId = (jsonObject.get(
                "accountId"
            ) as JSONValue).toString();
            let used = (jsonObject.get("used") as JSONValue).toBool();
            let redeemable = (jsonObject.get(
                "redeemable"
            ) as JSONValue).toBool();
            let name = (jsonObject.get("name") as JSONValue).toString();
            let email = (jsonObject.get("email") as JSONValue).toString();
            let phone = (jsonObject.get("phone") as JSONValue).toString();
            let answer1 = (jsonObject.get("answer1") as JSONValue).toString();
            let answer2 = (jsonObject.get("answer2") as JSONValue).toString();

            ticket.answer1 = answer1;
            ticket.answer2 = answer2;
            ticket.used = used;
            ticket.redeemable = redeemable;
            ticket.name = name;
            ticket.email = email;
            ticket.phone = phone;
            ticket.accountId = accountId;

            ticket.event = eventId;
            let event = Event.load(eventId);
            if (event) {
                event.attendees = BigInt.fromI32(event.attendees.toI32() + 1);
                event.save();
            }

            ticket.save();
        }
    }
}

function handleRedeem(outcome: near.ExecutionOutcome): void {
    for (let i = 0; i < outcome.logs.length; i++) {
        const outcomeLog = outcome.logs[i].toString();
        const jsonData = json.try_fromString(outcomeLog);
        const jsonObject = jsonData.value.toObject();

        const ticketId = jsonObject.get("ticketId");
        if (ticketId) {
            let ticket = Ticket.load(ticketId.toString());
            if (ticket) {
                ticket.used = true;
                ticket.redeemable = false;
                ticket.save();
            }
        }
    }
}

'''
'''--- tsconfig.json ---
{
  "extends": "@graphprotocol/graph-ts/types/tsconfig.base.json",
  "include": ["src"]
}

'''