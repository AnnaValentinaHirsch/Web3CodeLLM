*GitHub Repository "jacksonmori755/new-crosstalk-sample"*

'''--- cosmwasm/Cargo.toml ---
[workspace]
members = ["packages/*", "contracts/*"]
resolver = "2"

[profile.release]
rpath = false
lto = true
overflow-checks = true
opt-level = 3
debug = false
debug-assertions = false

[workspace.metadata.scripts]
optimize = """docker run --rm -v "$(pwd)":/code \
  --mount type=volume,source="$(basename "$(pwd)")_cache",target=/code/target \
  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \
  cosmwasm/workspace-optimizer:0.12.13
"""

'''
'''--- cosmwasm/contracts/cw20-token/Cargo.toml ---
[package]
name = "cw20-token"
version = "0.1.0"
edition = "2021"
authors = ["Gaurav Agarwal <gaurav@routerprotocol.com>"]
description = "The CW20 token contract"
repository = "https://github.com/router-protocol/new-crosstalk-sample.git"

exclude = [
  # Those files are rust-optimizer artifacts. You might want to commit them for convenience but they should not be part of the source code publication.
  "contract.wasm",
  "hash.txt",
]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[profile.release]
opt-level = 3
debug = false
rpath = false
lto = true
debug-assertions = false
codegen-units = 1
panic = 'abort'
incremental = false
overflow-checks = true

[features]
# for more explicit tests, cargo test --features=backtraces
backtraces = ["cosmwasm-std/backtraces"]
# use library feature to disable all instantiate/execute/query exports
library = []

[package.metadata.scripts]
optimize = """docker run --rm -v "$(pwd)":/code \
  --mount type=volume,source="$(basename "$(pwd)")_cache",target=/code/target \
  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \
  cosmwasm/rust-optimizer:0.12.13
"""

[dependencies]
serde_json="1"
cosmwasm-storage = "1.0.0"
cw-utils = "1.0.1"
cosmwasm-std = "1.0.0"
cw-storage-plus = { version = "0.13.4" }
schemars = "0.8.8"
serde = { version = "1.0.137", default-features = false, features = ["derive"] }
thiserror = { version = "1.0.31" }
cw20 = { version = "0.13.4" }
cw20-base = { version = "0.13.4", features = ["library"] }
cw0 = { version = "0.10.3" }
cw2 = { version = "0.13.2" }
cosmwasm-crypto = "1.0.0"
getrandom = { version = "0.2", features = ["js"] }
hex = "0.4"
arrayref = "0.3.6"
integer-sqrt = "0.1.5"
protobuf = { version = "2", features = ["with-bytes"] }
router-wasm-bindings = { version = "0.2.3", default-features = false, features = ["ethabi"] }
new-crosstalk-sample = { package = "new-crosstalk-sample", path = "../../packages/new-crosstalk-sample"}

[dev-dependencies]
cosmwasm-schema = "1.0.0"
cw-multi-test = "0.13.2"
'''
'''--- cosmwasm/contracts/cw20-token/src/lib.rs ---
#[cfg(not(feature = "library"))]
use cosmwasm_std::{entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
use cw20_base::contract::{
    execute as cw20_execute, instantiate as cw20_instantiate, query as cw20_query,
};
use cw20_base::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};
use cw20_base::ContractError;

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn instantiate(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: InstantiateMsg,
) -> Result<Response, ContractError> {
    cw20_instantiate(deps, env, info, msg)
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response, ContractError> {
    cw20_execute(deps, env, info, msg)
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn query(deps: Deps, env: Env, msg: QueryMsg) -> StdResult<Binary> {
    cw20_query(deps, env, msg)
}

'''
'''--- cosmwasm/contracts/ping-pong/Cargo.toml ---
[package]
name = "ping-pong"
version = "0.1.0"
edition = "2021"
authors = ["Gaurav Agarwal <gaurav@routerprotocol.com>"]
description = "The Cross Chain Ping Pong example contract"
repository = "https://github.com/router-protocol/new-crosstalk-sample.git"

exclude = [
  # Those files are rust-optimizer artifacts. You might want to commit them for convenience but they should not be part of the source code publication.
  "contract.wasm",
  "hash.txt",
]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[profile.release]
opt-level = 3
debug = false
rpath = false
lto = true
debug-assertions = false
codegen-units = 1
panic = 'abort'
incremental = false
overflow-checks = true

[features]
# for more explicit tests, cargo test --features=backtraces
backtraces = ["cosmwasm-std/backtraces"]
# use library feature to disable all instantiate/execute/query exports
library = []

[package.metadata.scripts]
optimize = """docker run --rm -v "$(pwd)":/code \
  --mount type=volume,source="$(basename "$(pwd)")_cache",target=/code/target \
  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \
  cosmwasm/rust-optimizer:0.12.13
"""

[dependencies]
serde_json="1"
cw721 = "0.17.0"
cw721-base = { version = "0.16.0", features = ["library"] }
cosmwasm-storage = "1.0.0"
cw-utils = "1.0.1"
cosmwasm-std = "1.0.0"
cw-storage-plus = { version = "0.13.4" }
schemars = "0.8.8"
serde = { version = "1.0.137", default-features = false, features = ["derive"] }
thiserror = { version = "1.0.31" }
cw20 = { version = "0.13.4" }
cw20-base = { version = "0.13.4", features = ["library"] }
cw0 = { version = "0.10.3" }
cw2 = { version = "0.13.2" }
cosmwasm-crypto = "1.0.0"
getrandom = { version = "0.2", features = ["js"] }
hex = "0.4"
arrayref = "0.3.6"
codec = { package = "parity-scale-codec", version = "2.0.0", features = ["derive"] }
router-wasm-bindings = { version = "0.2.3", default-features = false, features = ["ethabi"] }
new-crosstalk-sample = { package = "new-crosstalk-sample", path = "../../packages/new-crosstalk-sample"}

[dev-dependencies]
cosmwasm-schema = "1.0.0"
cw-multi-test = "0.13.2"
'''
'''--- cosmwasm/contracts/ping-pong/examples/schema.rs ---
use std::env::current_dir;
use std::fs::create_dir_all;

use cosmwasm_schema::{export_schema, remove_schemas, schema_for};

use new_crosstalk_sample::ping_pong::{ExecuteMsg, InstantiateMsg, QueryMsg};

fn main() {
    let mut out_dir = current_dir().unwrap();
    out_dir.push("schema/ping_pong");
    create_dir_all(&out_dir).unwrap();
    remove_schemas(&out_dir).unwrap();

    export_schema(&schema_for!(InstantiateMsg), &out_dir);
    export_schema(&schema_for!(ExecuteMsg), &out_dir);
    export_schema(&schema_for!(QueryMsg), &out_dir);
}

'''
'''--- cosmwasm/contracts/ping-pong/src/contract.rs ---
use crate::execution::i_ping;
use crate::query::handle_query;
use crate::state::{CREATE_I_SEND_REQUEST, PING_FROM_SOURCE, PONG_FROM_DESTINATION, REQUEST_ID};
#[cfg(not(feature = "library"))]
use cosmwasm_std::{entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
use cosmwasm_std::{from_binary, Coin, Event, Reply, StdError, SubMsgResult};
use new_crosstalk_sample::ping_pong::{ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg};

use cw2::set_contract_version;

use router_wasm_bindings::ethabi::{decode, ParamType};
use router_wasm_bindings::types::CrosschainRequestResponse;
use router_wasm_bindings::{RouterMsg, RouterQuery, SudoMsg};

// version info for migration info
const CONTRACT_NAME: &str = "PingPong";
const CONTRACT_VERSION: &str = "0.1.0";

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn instantiate(
    deps: DepsMut<RouterQuery>,
    _env: Env,
    _info: MessageInfo,
    _msg: InstantiateMsg,
) -> StdResult<Response> {
    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;
    REQUEST_ID.save(deps.storage, &0)?;
    Ok(Response::new().add_attribute("action", "ping_pong_init"))
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn reply(deps: DepsMut<RouterQuery>, _env: Env, msg: Reply) -> StdResult<Response<RouterMsg>> {
    match msg.id {
        CREATE_I_SEND_REQUEST => {
            deps.api.debug(&msg.id.to_string());
            // TODO: need to handle nonce data here, Nonce handling logic depends on the use-case.
            let response: Response<RouterMsg> = Response::new();
            match msg.result {
                SubMsgResult::Ok(msg_result) => match msg_result.data {
                    Some(binary_data) => {
                        deps.api.debug("Binary Data Found");
                        let cross_chain_req_res: CrosschainRequestResponse =
                            from_binary(&binary_data).unwrap();

                        let info_str: String = format!(
                            "Binary data {:?}, response {:?}",
                            &binary_data.to_string(),
                            cross_chain_req_res
                        );
                        deps.api.debug(&info_str);
                        return Ok(response);
                    }
                    None => deps.api.debug("No Binary Data Found"),
                },
                SubMsgResult::Err(err) => deps.api.debug(&err.to_string()),
            }
        }
        id => return Err(StdError::generic_err(format!("Unknown reply id: {}", id))),
    }
    Ok(Response::new())
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn execute(
    deps: DepsMut<RouterQuery>,
    _env: Env,
    _info: MessageInfo,
    msg: ExecuteMsg,
) -> StdResult<Response<RouterMsg>> {
    match msg {
        ExecuteMsg::IPing {
            ping,
            dest_contract_address,
            dest_chain_id,
            request_metadata,
        } => i_ping(
            deps,
            ping,
            dest_contract_address,
            dest_chain_id,
            request_metadata,
        ),
    }
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn sudo(deps: DepsMut<RouterQuery>, env: Env, msg: SudoMsg) -> StdResult<Response<RouterMsg>> {
    match msg {
        SudoMsg::HandleIReceive {
            request_sender,
            src_chain_id,
            request_identifier,
            payload,
        } => handle_sudo_request(
            deps,
            env,
            request_sender,
            src_chain_id,
            request_identifier,
            payload,
        ),
        SudoMsg::HandleIAck {
            request_identifier,
            exec_flag,
            exec_data,
            refund_amount,
        } => handle_sudo_ack(
            deps,
            env,
            request_identifier,
            exec_flag,
            exec_data,
            refund_amount,
        ),
    }
}

pub fn handle_sudo_request(
    deps: DepsMut<RouterQuery>,
    _env: Env,
    request_sender: String,
    src_chain_id: String,
    request_identifier: u64,
    payload: Binary,
) -> StdResult<Response<RouterMsg>> {
    let token_vec = match decode(&[ParamType::Uint(64), ParamType::String], &payload.0) {
        Ok(data) => data,
        Err(_) => {
            return Err(StdError::GenericErr {
                msg: String::from("err.into()"),
            })
        }
    };

    deps.api.debug("Inside the Inbound handler");
    let request_id: u64 = token_vec[0].clone().into_uint().unwrap().as_u64();
    let data_string: String = token_vec[1].clone().into_string().unwrap();

    PING_FROM_SOURCE.save(deps.storage, (&src_chain_id, request_id), &data_string)?;

    let mut res = Response::new()
        .add_attribute("sender", request_sender)
        .add_attribute("request_identifier", request_identifier.to_string())
        .add_attribute("src_chain_id", src_chain_id);
    res.data = Some(payload);
    Ok(res)
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn migrate(deps: DepsMut<RouterQuery>, env: Env, _msg: MigrateMsg) -> StdResult<Response> {
    let ver = cw2::get_contract_version(deps.storage)?;
    // ensure we are migrating from an allowed contract
    if ver.contract != CONTRACT_NAME.to_string() {
        return Err(StdError::generic_err("Can only upgrade from same type").into());
    }
    // note: better to do proper semver compare, but string compare *usually* works
    // if ver.version >= CONTRACT_VERSION.to_string() {
    //     return Err(StdError::generic_err("Cannot upgrade from a newer version").into());
    // }

    let info_str: String = format!(
        "migrating contract: {}, new_contract_version: {}, contract_name: {}",
        env.contract.address,
        CONTRACT_VERSION.to_string(),
        CONTRACT_NAME.to_string()
    );
    deps.api.debug(&info_str);
    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;
    Ok(Response::default())
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn query(deps: Deps<RouterQuery>, env: Env, msg: QueryMsg) -> StdResult<Binary> {
    handle_query(deps, env, msg)
}

fn handle_sudo_ack(
    deps: DepsMut<RouterQuery>,
    _env: Env,
    _request_identifier: u64,
    exec_flag: bool,
    exec_data: Binary,
    _refund_amount: Coin,
) -> StdResult<Response<RouterMsg>> {
    assert_eq!(exec_flag, true);
    let token_vec = match decode(&[ParamType::Uint(64), ParamType::String], &exec_data.0) {
        Ok(data) => data,
        Err(_) => {
            return Err(StdError::GenericErr {
                msg: String::from("err.into()"),
            })
        }
    };

    let request_id: u64 = token_vec[0].clone().into_uint().unwrap().as_u64();
    let data_string: String = token_vec[1].clone().into_string().unwrap();

    PONG_FROM_DESTINATION.save(deps.storage, &request_id.to_string(), &data_string)?;

    let event = Event::new("ExecutionStatus")
        .add_attribute("requestIdentifier", request_id.to_string())
        .add_attribute("execFlag", exec_flag.to_string());

    Ok(Response::new().add_event(event))
}

'''
'''--- cosmwasm/contracts/ping-pong/src/execution.rs ---
use cosmwasm_std::{Binary, DepsMut, Event, ReplyOn, Response, StdResult, SubMsg, Uint128};
use router_wasm_bindings::{
    ethabi::{encode, ethereum_types::U256, Token},
    Bytes, RouterMsg, RouterQuery,
};

use crate::{
    query::fetch_request_id,
    state::{CREATE_I_SEND_REQUEST, REQUEST_ID},
};

pub fn i_ping(
    deps: DepsMut<RouterQuery>,
    ping: String,
    dest_contract_address: String,
    dest_chain_id: String,
    request_metadata: Binary,
) -> StdResult<Response<RouterMsg>> {
    let request_id: u64 = fetch_request_id(deps.as_ref())? + 1;
    let u256: U256 = U256::from(request_id);
    REQUEST_ID.save(deps.storage, &(request_id))?;
    let payload: Vec<u8> = encode(&[Token::Uint(u256), Token::String(ping.clone())]);
    let info_str: String = format!("create_outbound_request-- payload: {:?}", payload.clone(),);
    deps.api.debug(&info_str);
    let route_amount: Uint128 = Uint128::zero();

    let info_str: String = format!(
        "create_outbound_request-- dest_chain_id: {}, dest_contract_address: {}, request_metadata: {}",
        dest_chain_id, dest_contract_address.clone(), request_metadata
    );
    deps.api.debug(&info_str);
    let request_packet: Bytes = encode(&[
        Token::String(dest_contract_address.clone()),
        Token::Bytes(payload),
    ]);

    let i_send_request: RouterMsg = RouterMsg::CrosschainCall {
        version: 1,
        route_amount,
        route_recipient: String::default(),
        dest_chain_id,
        request_metadata: request_metadata.0,
        request_packet,
    };
    let cross_chain_sub_msg: SubMsg<RouterMsg> = SubMsg {
        id: CREATE_I_SEND_REQUEST,
        msg: i_send_request.into(),
        gas_limit: None,
        reply_on: ReplyOn::Success,
    };
    let event: Event = Event::new("new_ping")
        .add_attribute("ping", ping)
        .add_attribute("request_id", request_id.to_string());
    let res = Response::new()
        .add_event(event)
        .add_submessage(cross_chain_sub_msg.into())
        .add_attribute("dest_contract_address", dest_contract_address);
    Ok(res)
}

'''
'''--- cosmwasm/contracts/ping-pong/src/lib.rs ---
pub mod contract;
pub mod execution;
pub mod query;
pub mod state;

pub use serde::{Deserialize, Serialize};
#[cfg(test)]
mod tests;

'''
'''--- cosmwasm/contracts/ping-pong/src/query.rs ---
use cosmwasm_std::{to_binary, Binary, Deps, Env, StdResult};
use cw2::get_contract_version;
use new_crosstalk_sample::ping_pong::QueryMsg;
use router_wasm_bindings::RouterQuery;

use crate::state::{PING_FROM_SOURCE, PONG_FROM_DESTINATION, REQUEST_ID};

pub fn handle_query(deps: Deps<RouterQuery>, _env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::GetContractVersion {} => to_binary(&get_contract_version(deps.storage)?),
        QueryMsg::FetchPing {
            chain_id,
            request_id,
        } => to_binary(&fetch_ping(deps, &chain_id, request_id)?),
        QueryMsg::FetchPong { request_id } => to_binary(&fetch_pong(deps, request_id)?),
        QueryMsg::FetchRequestId {} => to_binary(&fetch_request_id(deps)?),
    }
}

pub fn fetch_ping(deps: Deps<RouterQuery>, chain_id: &str, request_id: u64) -> StdResult<String> {
    PING_FROM_SOURCE.load(deps.storage, (chain_id, request_id))
}

pub fn fetch_pong(deps: Deps<RouterQuery>, request_id: u64) -> StdResult<String> {
    PONG_FROM_DESTINATION.load(deps.storage, &request_id.to_string())
}

pub fn fetch_request_id(deps: Deps<RouterQuery>) -> StdResult<u64> {
    REQUEST_ID.load(deps.storage)
}

'''
'''--- cosmwasm/contracts/ping-pong/src/state.rs ---
use cw_storage_plus::{Item, Map};

pub const CREATE_I_SEND_REQUEST: u64 = 1;
// PingMapping (src_chain_id, requestId) => pingFromSource
pub const PING_FROM_SOURCE: Map<(&str, u64), String> = Map::new("ping_from_source");

// PongMapping requestId => pongFromSource
pub const PONG_FROM_DESTINATION: Map<&str, String> = Map::new("pong_from_destination");

pub const REQUEST_ID: Item<u64> = Item::new("request_id");

'''
'''--- cosmwasm/contracts/ping-pong/src/tests.rs ---
use std::marker::PhantomData;

use crate::contract::instantiate;
use crate::contract::{execute, sudo};
use cosmwasm_std::testing::{MockApi, MockQuerier, MockStorage};
use cosmwasm_std::{
    testing::{mock_env, mock_info},
    DepsMut,
};
use cosmwasm_std::{Binary, Coin, CosmosMsg, OwnedDeps, Uint128};
use new_crosstalk_sample::ping_pong::{ExecuteMsg, InstantiateMsg};
use router_wasm_bindings::ethabi::{decode, ParamType};
use router_wasm_bindings::types::{AckType, ChainType, RequestMetaData};
use router_wasm_bindings::utils::convert_address_from_string_to_bytes;
use router_wasm_bindings::{Bytes, RouterMsg, RouterQuery, SudoMsg};

const INIT_ADDRESS: &str = "router1apapk9zfz3rp4x87fsm6h0s3zd0wlmkz0fx8tx";
const BRIDGE_ADDRESS: &str = "0xeedb3ab68d567a6cd6d19fa819fe77b9f8ed1538";

fn do_instantiate(mut deps: DepsMut<RouterQuery>) {
    let instantiate_msg = InstantiateMsg {};
    let info = mock_info(INIT_ADDRESS, &[]);
    let env = mock_env();
    let res = instantiate(deps.branch(), env.clone(), info, instantiate_msg).unwrap();
    assert_eq!(0, res.messages.len());
}

#[test]
fn test_basic() {
    let mut deps = OwnedDeps {
        storage: MockStorage::default(),
        api: MockApi::default(),
        querier: MockQuerier::default(),
        custom_query_type: PhantomData,
    };
    do_instantiate(deps.as_mut());
}

#[test]
fn test_sudo_inbound_function() {
    let mut deps = OwnedDeps {
        storage: MockStorage::default(),
        api: MockApi::default(),
        querier: MockQuerier::default(),
        custom_query_type: PhantomData,
    };
    do_instantiate(deps.as_mut());
    let env = mock_env();
    let payload: Bytes = hex::decode("0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000a68656c6c6f2070696e6700000000000000000000000000000000000000000000").unwrap();
    let binary: Binary = Binary(payload);
    let msg: SudoMsg = SudoMsg::HandleIReceive {
        request_sender: BRIDGE_ADDRESS.into(),
        src_chain_id: String::from("80001"),
        request_identifier: 2,
        payload: binary,
    };

    let result = sudo(deps.as_mut(), env, msg);
    if result.is_err() {
        println!("{:?}", result.as_ref().err());
        assert!(false);
        return;
    }
    let response = result.unwrap();
    assert_eq!(response.messages.len(), 0);
}

#[test]
fn test_sudo_outbound_ack_function() {
    let mut deps = OwnedDeps {
        storage: MockStorage::default(),
        api: MockApi::default(),
        querier: MockQuerier::default(),
        custom_query_type: PhantomData,
    };
    do_instantiate(deps.as_mut());
    let env = mock_env();

    let payload: Bytes = hex::decode("0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000a68656c6c6f2070696e6700000000000000000000000000000000000000000000").unwrap();
    let binary_data: Binary = Binary(payload);
    let msg: SudoMsg = SudoMsg::HandleIAck {
        request_identifier: 1,
        exec_flag: true,
        exec_data: binary_data,
        refund_amount: Coin::new(123u128, String::from("route")),
    };

    let result = sudo(deps.as_mut(), env, msg);
    if result.is_err() {
        println!("{:?}", result.as_ref().err());
        assert!(false);
        return;
    }
    let response = result.unwrap();
    assert_eq!(response.messages.len(), 0);
}

#[test]
fn test_execute_create_outbound_request() {
    let mut deps = OwnedDeps {
        storage: MockStorage::default(),
        api: MockApi::default(),
        querier: MockQuerier::default(),
        custom_query_type: PhantomData,
    };
    do_instantiate(deps.as_mut());
    let env = mock_env();
    let greeting: String = String::from("Hello Lord Venky");

    let msg: ExecuteMsg = ExecuteMsg::IPing {
        dest_contract_address: String::from(BRIDGE_ADDRESS),
        dest_chain_id: String::from("80001"),
        ping: greeting,
        request_metadata: Binary(vec![]),
    };
    let info = mock_info(INIT_ADDRESS, &[]);
    let response = execute(deps.as_mut(), env, info, msg).unwrap();
    assert_eq!(response.messages.len(), 1);

    let message = response.messages.get(0).unwrap();
    let router_msg = message.msg.clone();
    match router_msg {
        CosmosMsg::Custom(msg) => match msg {
            RouterMsg::CrosschainCall {
                version,
                route_amount,
                route_recipient,
                dest_chain_id,
                request_metadata,
                request_packet,
            } => {
                assert_eq!(route_amount, Uint128::zero());
                assert_eq!(route_recipient, "");

                assert_eq!(dest_chain_id, "80001");
                assert_eq!(version, 1);
                assert_eq!(hex::encode(request_metadata), "");
                assert_eq!(hex::encode(request_packet), "000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000002a30786565646233616236386435363761366364366431396661383139666537376239663865643135333800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000001048656c6c6f204c6f72642056656e6b7900000000000000000000000000000000");
            }
        },
        _ => {}
    }
}

#[test]
fn test_encode() {
    let addr: String =
        String::from("router1ghd753shjuwexxywmgs4xz7x2q732vcnkm6h2pyv9s6ah3hylvrq8h5484");
    println!(
        "{:?}",
        hex::encode(
            convert_address_from_string_to_bytes(addr, ChainType::ChainTypeCosmos.get_chain_code())
                .unwrap()
        )
    );

    let binary: Binary = Binary::from_base64("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKSGVsbG8gTG9yZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=").unwrap();
    println!(
        "{:?}",
        decode(&[ParamType::Uint(64), ParamType::String], &binary.0)
    );

    let rm: RequestMetaData = RequestMetaData {
        dest_gas_limit: 200_000,
        dest_gas_price: 50_000_000_000,
        ack_gas_limit: 200_000,
        ack_gas_price: 50_000_000_000,
        relayer_fee: Uint128::zero(),
        ack_type: AckType::AckOnBoth,
        is_read_call: false,
        asm_address: String::default(),
    };
    println!("{:?}", Binary(rm.get_abi_encoded_bytes()).to_base64());
}

'''
'''--- cosmwasm/contracts/test-dapp/Cargo.toml ---
[package]
name = "test-dapp"
version = "0.1.0"
edition = "2021"
authors = ["Gaurav Agarwal <gaurav@routerprotocol.com>"]
description = "The Cross Chain Test Dapp example contract"
repository = "https://github.com/router-protocol/new-crosstalk-sample.git"

exclude = [
  # Those files are rust-optimizer artifacts. You might want to commit them for convenience but they should not be part of the source code publication.
  "contract.wasm",
  "hash.txt",
]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[profile.release]
opt-level = 3
debug = false
rpath = false
lto = true
debug-assertions = false
codegen-units = 1
panic = 'abort'
incremental = false
overflow-checks = true

[features]
# for more explicit tests, cargo test --features=backtraces
backtraces = ["cosmwasm-std/backtraces"]
# use library feature to disable all instantiate/execute/query exports
library = []

[package.metadata.scripts]
optimize = """docker run --rm -v "$(pwd)":/code \
  --mount type=volume,source="$(basename "$(pwd)")_cache",target=/code/target \
  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \
  cosmwasm/rust-optimizer:0.12.13
"""

[dependencies]
serde_json="1"
cosmwasm-storage = "1.0.0"
cw-utils = "1.0.1"
cosmwasm-std = "1.0.0"
cw-storage-plus = { version = "0.13.4" }
schemars = "0.8.8"
serde = { version = "1.0.137", default-features = false, features = ["derive"] }
thiserror = { version = "1.0.31" }
cw20 = { version = "0.13.4" }
cw20-base = { version = "0.13.4", features = ["library"] }
cw0 = { version = "0.10.3" }
cw2 = { version = "0.13.2" }
cosmwasm-crypto = "1.0.0"
getrandom = { version = "0.2", features = ["js"] }
hex = "0.4"
arrayref = "0.3.6"
codec = { package = "parity-scale-codec", version = "2.0.0", features = ["derive"] }
router-wasm-bindings = { version = "0.2.3", default-features = false, features = ["ethabi"] }
new-crosstalk-sample = { package = "new-crosstalk-sample", path = "../../packages/new-crosstalk-sample"}

[dev-dependencies]
cosmwasm-schema = "1.0.0"
cw-multi-test = "0.13.2"
'''
'''--- cosmwasm/contracts/test-dapp/examples/schema.rs ---
use std::env::current_dir;
use std::fs::create_dir_all;

use cosmwasm_schema::{export_schema, remove_schemas, schema_for};

use new_crosstalk_sample::test_dapp::{ExecuteMsg, InstantiateMsg, QueryMsg};

fn main() {
    let mut out_dir = current_dir().unwrap();
    out_dir.push("schema/test_dapp");
    create_dir_all(&out_dir).unwrap();
    remove_schemas(&out_dir).unwrap();

    export_schema(&schema_for!(InstantiateMsg), &out_dir);
    export_schema(&schema_for!(ExecuteMsg), &out_dir);
    export_schema(&schema_for!(QueryMsg), &out_dir);
}

'''
'''--- cosmwasm/contracts/test-dapp/src/contract.rs ---
use crate::execution::send_i_request;
use crate::query::handle_query;
use crate::state::{CREATE_I_SEND_REQUEST, PING_FROM_SOURCE, PONG_FROM_DESTINATION, REQUEST_ID};
#[cfg(not(feature = "library"))]
use cosmwasm_std::{entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
use cosmwasm_std::{from_binary, Coin, Event, Reply, StdError, SubMsgResult};
use new_crosstalk_sample::test_dapp::{ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg};

use cw2::set_contract_version;

use router_wasm_bindings::ethabi::{decode, ParamType};
use router_wasm_bindings::types::CrosschainRequestResponse;
use router_wasm_bindings::{RouterMsg, RouterQuery, SudoMsg};

// version info for migration info
const CONTRACT_NAME: &str = "PingPong";
const CONTRACT_VERSION: &str = "0.1.0";

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn instantiate(
    deps: DepsMut<RouterQuery>,
    _env: Env,
    _info: MessageInfo,
    _msg: InstantiateMsg,
) -> StdResult<Response> {
    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;
    REQUEST_ID.save(deps.storage, &0)?;
    Ok(Response::new().add_attribute("action", "ping_pong_init"))
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn reply(deps: DepsMut<RouterQuery>, _env: Env, msg: Reply) -> StdResult<Response<RouterMsg>> {
    match msg.id {
        CREATE_I_SEND_REQUEST => {
            deps.api.debug(&msg.id.to_string());
            // TODO: need to handle nonce data here, Nonce handling logic depends on the use-case.
            let response: Response<RouterMsg> = Response::new();
            match msg.result {
                SubMsgResult::Ok(msg_result) => match msg_result.data {
                    Some(binary_data) => {
                        deps.api.debug("Binary Data Found");
                        let cross_chain_req_res: CrosschainRequestResponse =
                            from_binary(&binary_data).unwrap();

                        let info_str: String = format!(
                            "Binary data {:?}, response {:?}",
                            &binary_data.to_string(),
                            cross_chain_req_res
                        );
                        deps.api.debug(&info_str);
                        return Ok(response);
                    }
                    None => deps.api.debug("No Binary Data Found"),
                },
                SubMsgResult::Err(err) => deps.api.debug(&err.to_string()),
            }
        }
        id => return Err(StdError::generic_err(format!("Unknown reply id: {}", id))),
    }
    Ok(Response::new())
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn execute(
    deps: DepsMut<RouterQuery>,
    _env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> StdResult<Response<RouterMsg>> {
    match msg {
        ExecuteMsg::SendIRequest {
            payload,
            dest_contract_address,
            dest_chain_id,
            request_metadata,
            amount,
            route_recipient,
        } => send_i_request(
            deps,
            info,
            payload,
            dest_contract_address,
            dest_chain_id,
            request_metadata,
            amount,
            route_recipient,
        ),
    }
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn sudo(deps: DepsMut<RouterQuery>, env: Env, msg: SudoMsg) -> StdResult<Response<RouterMsg>> {
    match msg {
        SudoMsg::HandleIReceive {
            request_sender,
            src_chain_id,
            request_identifier,
            payload,
        } => handle_sudo_request(
            deps,
            env,
            request_sender,
            src_chain_id,
            request_identifier,
            payload,
        ),
        SudoMsg::HandleIAck {
            request_identifier,
            exec_flag,
            exec_data,
            refund_amount,
        } => handle_sudo_ack(
            deps,
            env,
            request_identifier,
            exec_flag,
            exec_data,
            refund_amount,
        ),
    }
}

pub fn handle_sudo_request(
    deps: DepsMut<RouterQuery>,
    _env: Env,
    request_sender: String,
    src_chain_id: String,
    request_identifier: u64,
    payload: Binary,
) -> StdResult<Response<RouterMsg>> {
    let token_vec = match decode(&[ParamType::Uint(64), ParamType::String], &payload.0) {
        Ok(data) => data,
        Err(_) => {
            return Err(StdError::GenericErr {
                msg: String::from("err.into()"),
            })
        }
    };

    deps.api.debug("Inside the Inbound handler");
    let request_id: u64 = token_vec[0].clone().into_uint().unwrap().as_u64();
    let data_string: String = token_vec[1].clone().into_string().unwrap();

    if data_string.clone() == "Fail Dest Req".to_string() {
        return Err(StdError::GenericErr {
            msg: String::from("String != Fail Dest Req"),
        });
    }

    PING_FROM_SOURCE.save(deps.storage, (&src_chain_id, request_id), &data_string)?;

    let mut res = Response::new()
        .add_attribute("sender", request_sender)
        .add_attribute("request_identifier", request_identifier.to_string())
        .add_attribute("src_chain_id", src_chain_id);
    res.data = Some(payload);
    Ok(res)
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn migrate(deps: DepsMut<RouterQuery>, env: Env, _msg: MigrateMsg) -> StdResult<Response> {
    let ver = cw2::get_contract_version(deps.storage)?;
    // ensure we are migrating from an allowed contract
    if ver.contract != CONTRACT_NAME.to_string() {
        return Err(StdError::generic_err("Can only upgrade from same type").into());
    }
    // note: better to do proper semver compare, but string compare *usually* works
    if ver.version >= CONTRACT_VERSION.to_string() {
        return Err(StdError::generic_err("Cannot upgrade from a newer version").into());
    }

    let info_str: String = format!(
        "migrating contract: {}, new_contract_version: {}, contract_name: {}",
        env.contract.address,
        CONTRACT_VERSION.to_string(),
        CONTRACT_NAME.to_string()
    );
    deps.api.debug(&info_str);
    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;
    Ok(Response::default())
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn query(deps: Deps<RouterQuery>, env: Env, msg: QueryMsg) -> StdResult<Binary> {
    handle_query(deps, env, msg)
}

fn handle_sudo_ack(
    deps: DepsMut<RouterQuery>,
    _env: Env,
    _request_identifier: u64,
    exec_flag: bool,
    exec_data: Binary,
    _refund_amount: Coin,
) -> StdResult<Response<RouterMsg>> {
    let mut request_id: u64 = 0;
    if exec_flag {
        let token_vec = match decode(&[ParamType::Uint(64), ParamType::String], &exec_data.0) {
            Ok(data) => data,
            Err(_) => {
                return Err(StdError::GenericErr {
                    msg: String::from("err.into()"),
                })
            }
        };

        request_id = token_vec[0].clone().into_uint().unwrap().as_u64();
        let data_string: String = token_vec[1].clone().into_string().unwrap();

        if data_string.clone() == "Fail Ack Req".to_string() {
            return Err(StdError::GenericErr {
                msg: String::from("String != Fail Ack Req"),
            });
        }

        PONG_FROM_DESTINATION.save(deps.storage, &request_id.to_string(), &data_string)?;
    }

    let event = Event::new("ExecutionStatus")
        .add_attribute("requestIdentifier", request_id.to_string())
        .add_attribute("execFlag", exec_flag.to_string());

    Ok(Response::new().add_event(event))
}

'''
'''--- cosmwasm/contracts/test-dapp/src/execution.rs ---
use cosmwasm_std::{
    Binary, DepsMut, MessageInfo, ReplyOn, Response, StdError, StdResult, SubMsg, Uint128,
};
use router_wasm_bindings::{
    ethabi::{decode, encode, ParamType, Token},
    Bytes, RouterMsg, RouterQuery,
};

use crate::state::CREATE_I_SEND_REQUEST;

pub fn send_i_request(
    deps: DepsMut<RouterQuery>,
    info: MessageInfo,
    payload: Binary,
    dest_contract_address: String,
    dest_chain_id: String,
    request_metadata: Binary,
    amount: Uint128,
    route_recipient: String,
) -> StdResult<Response<RouterMsg>> {
    let info_str: String = format!("create_outbound_request-- payload: {:?}", payload.clone(),);
    deps.api.debug(&info_str);

    if amount != Uint128::zero() {
        assert_eq!(info.funds.len(), 1);
        assert_eq!(info.funds[0].amount, amount);
    }
    let info_str: String = format!(
        "create_outbound_request-- dest_chain_id: {}, dest_contract_address: {}, request_metadata: {}",
        dest_chain_id, dest_contract_address.clone(), request_metadata
    );
    deps.api.debug(&info_str);
    let request_packet: Bytes = encode(&[
        Token::String(dest_contract_address.clone()),
        Token::Bytes(payload.clone().0),
    ]);

    let i_send_request: RouterMsg = RouterMsg::CrosschainCall {
        version: 1,
        route_amount: amount,
        route_recipient,
        dest_chain_id,
        request_metadata: request_metadata.0,
        request_packet,
    };

    let cross_chain_sub_msg: SubMsg<RouterMsg> = SubMsg {
        id: CREATE_I_SEND_REQUEST,
        msg: i_send_request.into(),
        gas_limit: None,
        reply_on: ReplyOn::Success,
    };

    let token_vec: Vec<Token> = match decode(&[ParamType::Uint(64), ParamType::String], &payload.0)
    {
        Ok(data) => data,
        Err(_) => {
            return Err(StdError::GenericErr {
                msg: String::from("err.into()"),
            })
        }
    };

    let greeting: String = token_vec[1].clone().into_string().unwrap();

    if greeting == "".to_string() {
        return Err(StdError::GenericErr {
            msg: String::from("greeting cannot be empty"),
        });
    }

    let res: Response<RouterMsg> = Response::new()
        .add_submessage(cross_chain_sub_msg.into())
        .add_attribute("dest_contract_address", dest_contract_address);
    Ok(res)
}

'''
'''--- cosmwasm/contracts/test-dapp/src/lib.rs ---
pub mod contract;
pub mod execution;
pub mod query;
pub mod state;

pub use serde::{Deserialize, Serialize};
#[cfg(test)]
mod tests;

'''
'''--- cosmwasm/contracts/test-dapp/src/query.rs ---
use cosmwasm_std::{to_binary, Binary, Deps, Env, StdResult};
use cw2::get_contract_version;
use new_crosstalk_sample::test_dapp::QueryMsg;
use router_wasm_bindings::RouterQuery;

use crate::state::{PING_FROM_SOURCE, PONG_FROM_DESTINATION};

pub fn handle_query(deps: Deps<RouterQuery>, _env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::GetContractVersion {} => to_binary(&get_contract_version(deps.storage)?),
        QueryMsg::FetchGreetingRecord {
            chain_id,
            request_id,
        } => to_binary(&fetch_ping(deps, &chain_id, request_id)?),
        QueryMsg::FetchAckRecord { request_id } => to_binary(&fetch_pong(deps, request_id)?),
    }
}

pub fn fetch_ping(deps: Deps<RouterQuery>, chain_id: &str, request_id: u64) -> StdResult<String> {
    PING_FROM_SOURCE.load(deps.storage, (chain_id, request_id))
}

pub fn fetch_pong(deps: Deps<RouterQuery>, request_id: u64) -> StdResult<String> {
    PONG_FROM_DESTINATION.load(deps.storage, &request_id.to_string())
}

'''
'''--- cosmwasm/contracts/test-dapp/src/state.rs ---
use cw_storage_plus::{Item, Map};

pub const CREATE_I_SEND_REQUEST: u64 = 1;
// PingMapping (src_chain_id, requestId) => pingFromSource
pub const PING_FROM_SOURCE: Map<(&str, u64), String> = Map::new("ping_from_source");

// PongMapping requestId => pongFromSource
pub const PONG_FROM_DESTINATION: Map<&str, String> = Map::new("pong_from_destination");

pub const REQUEST_ID: Item<u64> = Item::new("request_id");

'''
'''--- cosmwasm/contracts/test-dapp/src/tests.rs ---
use std::marker::PhantomData;

use crate::contract::instantiate;
use crate::contract::{execute, sudo};
use cosmwasm_std::testing::{MockApi, MockQuerier, MockStorage};
use cosmwasm_std::{
    testing::{mock_env, mock_info},
    DepsMut,
};
use cosmwasm_std::{Binary, Coin, CosmosMsg, OwnedDeps, Uint128};
use new_crosstalk_sample::test_dapp::{ExecuteMsg, InstantiateMsg};
use router_wasm_bindings::ethabi::{decode, ParamType};
use router_wasm_bindings::types::ChainType;
use router_wasm_bindings::utils::convert_address_from_string_to_bytes;
use router_wasm_bindings::{Bytes, RouterMsg, RouterQuery, SudoMsg};

const INIT_ADDRESS: &str = "router1apapk9zfz3rp4x87fsm6h0s3zd0wlmkz0fx8tx";
const BRIDGE_ADDRESS: &str = "0xeedb3ab68d567a6cd6d19fa819fe77b9f8ed1538";

fn do_instantiate(mut deps: DepsMut<RouterQuery>) {
    let instantiate_msg = InstantiateMsg {};
    let info = mock_info(INIT_ADDRESS, &[]);
    let env = mock_env();
    let res = instantiate(deps.branch(), env.clone(), info, instantiate_msg).unwrap();
    assert_eq!(0, res.messages.len());
}

#[test]
fn test_basic() {
    let mut deps = OwnedDeps {
        storage: MockStorage::default(),
        api: MockApi::default(),
        querier: MockQuerier::default(),
        custom_query_type: PhantomData,
    };
    do_instantiate(deps.as_mut());
}

#[test]
fn test_sudo_inbound_function() {
    let mut deps = OwnedDeps {
        storage: MockStorage::default(),
        api: MockApi::default(),
        querier: MockQuerier::default(),
        custom_query_type: PhantomData,
    };
    do_instantiate(deps.as_mut());
    let env = mock_env();
    let payload: Bytes = hex::decode("0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000a68656c6c6f2070696e6700000000000000000000000000000000000000000000").unwrap();
    let binary: Binary = Binary(payload);
    let msg: SudoMsg = SudoMsg::HandleIReceive {
        request_sender: BRIDGE_ADDRESS.into(),
        src_chain_id: String::from("80001"),
        request_identifier: 2,
        payload: binary,
    };

    let result = sudo(deps.as_mut(), env, msg);
    if result.is_err() {
        println!("{:?}", result.as_ref().err());
        assert!(false);
        return;
    }
    let response = result.unwrap();
    assert_eq!(response.messages.len(), 0);
}

#[test]
fn test_sudo_outbound_ack_function() {
    let mut deps = OwnedDeps {
        storage: MockStorage::default(),
        api: MockApi::default(),
        querier: MockQuerier::default(),
        custom_query_type: PhantomData,
    };
    do_instantiate(deps.as_mut());
    let env = mock_env();

    let payload: Bytes = hex::decode("0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000a68656c6c6f2070696e6700000000000000000000000000000000000000000000").unwrap();
    let binary_data: Binary = Binary(payload);
    let msg: SudoMsg = SudoMsg::HandleIAck {
        request_identifier: 1,
        exec_flag: true,
        exec_data: binary_data,
        refund_amount: Coin::new(123u128, String::from("route")),
    };

    let result = sudo(deps.as_mut(), env, msg);
    if result.is_err() {
        println!("{:?}", result.as_ref().err());
        assert!(false);
        return;
    }
    let response = result.unwrap();
    assert_eq!(response.messages.len(), 0);
}

#[test]
fn test_execute_create_outbound_request() {
    let mut deps = OwnedDeps {
        storage: MockStorage::default(),
        api: MockApi::default(),
        querier: MockQuerier::default(),
        custom_query_type: PhantomData,
    };
    do_instantiate(deps.as_mut());
    let env = mock_env();

    let msg: ExecuteMsg = ExecuteMsg::SendIRequest {
        payload: Binary(vec![]),
        dest_contract_address: String::from(BRIDGE_ADDRESS),
        dest_chain_id: String::from("80001"),
        request_metadata: Binary(vec![]),
        amount: Uint128::zero(),
        route_recipient: String::default(),
    };
    let info = mock_info(INIT_ADDRESS, &[]);
    let response = execute(deps.as_mut(), env, info, msg).unwrap();
    assert_eq!(response.messages.len(), 1);

    let message = response.messages.get(0).unwrap();
    let router_msg = message.msg.clone();
    match router_msg {
        CosmosMsg::Custom(msg) => match msg {
            RouterMsg::CrosschainCall {
                version,
                route_amount,
                route_recipient,
                dest_chain_id,
                request_metadata,
                request_packet,
            } => {
                assert_eq!(route_amount, Uint128::zero());
                assert_eq!(route_recipient, "");

                assert_eq!(dest_chain_id, "80001");
                assert_eq!(version, 1);
                assert_eq!(hex::encode(request_metadata), "");
                assert_eq!(hex::encode(request_packet), "000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000002a307865656462336162363864353637613663643664313966613831396665373762396638656431353338000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
            }
        },
        _ => {}
    }
}

#[test]
fn test_encode() {
    let addr: String =
        String::from("router1ghd753shjuwexxywmgs4xz7x2q732vcnkm6h2pyv9s6ah3hylvrq8h5484");
    println!(
        "{:?}",
        hex::encode(
            convert_address_from_string_to_bytes(addr, ChainType::ChainTypeCosmos.get_chain_code())
                .unwrap()
        )
    );

    let binary: Binary = Binary::from_base64("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKSGVsbG8gTG9yZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=").unwrap();
    println!(
        "{:?}",
        decode(&[ParamType::Uint(64), ParamType::String], &binary.0)
    );
}

'''
'''--- cosmwasm/contracts/xerc20/Cargo.toml ---
[package]
name = "xerc20"
version = "0.1.0"
edition = "2021"
authors = ["Gaurav Agarwal <gaurav@routerprotocol.com>"]
description = "The Cross Chain XERC20 example contract"
repository = "https://github.com/router-protocol/new-crosstalk-sample.git"

exclude = [
  # Those files are rust-optimizer artifacts. You might want to commit them for convenience but they should not be part of the source code publication.
  "contract.wasm",
  "hash.txt",
]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[profile.release]
opt-level = 3
debug = false
rpath = false
lto = true
debug-assertions = false
codegen-units = 1
panic = 'abort'
incremental = false
overflow-checks = true

[features]
# for more explicit tests, cargo test --features=backtraces
backtraces = ["cosmwasm-std/backtraces"]
# use library feature to disable all instantiate/execute/query exports
library = []

[package.metadata.scripts]
optimize = """docker run --rm -v "$(pwd)":/code \
  --mount type=volume,source="$(basename "$(pwd)")_cache",target=/code/target \
  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \
  cosmwasm/rust-optimizer:0.12.13
"""

[dependencies]
serde_json="1"
cosmwasm-storage = "1.0.0"
cw-utils = "1.0.1"
cosmwasm-std = "1.0.0"
cw-storage-plus = { version = "0.13.4" }
schemars = "0.8.8"
serde = { version = "1.0.137", default-features = false, features = ["derive"] }
thiserror = { version = "1.0.31" }
cw20 = { version = "0.13.4" }
cw20-base = { version = "0.13.4", features = ["library"] }
cw0 = { version = "0.10.3" }
cw2 = { version = "0.13.2" }
cosmwasm-crypto = "1.0.0"
getrandom = { version = "0.2", features = ["js"] }
hex = "0.4"
arrayref = "0.3.6"
router-wasm-bindings = { version = "0.2.3", default-features = false, features = ["ethabi"] }
new-crosstalk-sample = { package = "new-crosstalk-sample", path = "../../packages/new-crosstalk-sample"}

[dev-dependencies]
cosmwasm-schema = "1.0.0"
cw-multi-test = "0.13.2"
'''
'''--- cosmwasm/contracts/xerc20/examples/schema.rs ---
use std::env::current_dir;
use std::fs::create_dir_all;

use cosmwasm_schema::{export_schema, remove_schemas, schema_for};

use new_crosstalk_sample::xerc20::{ExecuteMsg, InstantiateMsg, QueryMsg};

fn main() {
    let mut out_dir = current_dir().unwrap();
    out_dir.push("schema/xerc20");
    create_dir_all(&out_dir).unwrap();
    remove_schemas(&out_dir).unwrap();

    export_schema(&schema_for!(InstantiateMsg), &out_dir);
    export_schema(&schema_for!(ExecuteMsg), &out_dir);
    export_schema(&schema_for!(QueryMsg), &out_dir);
}

'''
'''--- cosmwasm/contracts/xerc20/src/contract.rs ---
use crate::execution::handle_execute;
use crate::handle_sudo_execution::{handle_sudo_ack, handle_sudo_request};
use crate::query::handle_query;
use crate::state::{CREATE_I_SEND_REQUEST, CROSS_CHAIN_TOKEN, INSTANTIATE_REPLY_ID, OWNER};
#[cfg(not(feature = "library"))]
use cosmwasm_std::{entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
use cosmwasm_std::{
    from_binary, to_binary, Reply, ReplyOn, StdError, SubMsg, SubMsgResult, WasmMsg,
};
use cw0::parse_reply_instantiate_data;
use cw20::MinterResponse;
use new_crosstalk_sample::xerc20::{ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg};

use cw2::set_contract_version;

use cw20_base::msg::InstantiateMsg as TokenInstantiateMsg;
use router_wasm_bindings::types::CrosschainRequestResponse;
use router_wasm_bindings::{RouterMsg, RouterQuery, SudoMsg};

// version info for migration info
const CONTRACT_NAME: &str = "XERC20";
const CONTRACT_VERSION: &str = "0.1.1";

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn instantiate(
    deps: DepsMut<RouterQuery>,
    env: Env,
    info: MessageInfo,
    msg: InstantiateMsg,
) -> StdResult<Response> {
    OWNER.save(deps.storage, &info.sender.to_string())?;
    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;
    Ok(Response::new().add_submessage(SubMsg {
        // Create LP token
        msg: WasmMsg::Instantiate {
            admin: Some(info.sender.to_string()),
            code_id: msg.cw20_code_id,
            msg: to_binary(&TokenInstantiateMsg {
                name: msg.token_name,
                symbol: msg.token_symbol,
                decimals: 18,
                initial_balances: vec![],
                mint: Some(MinterResponse {
                    minter: env.contract.address.to_string(),
                    cap: None,
                }),
                marketing: None,
            })?,
            funds: vec![],
            label: "XERC20 TOKEN".to_string(),
        }
        .into(),
        gas_limit: None,
        id: INSTANTIATE_REPLY_ID,
        reply_on: ReplyOn::Success,
    }))
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn reply(deps: DepsMut<RouterQuery>, _env: Env, msg: Reply) -> StdResult<Response<RouterMsg>> {
    match msg.id {
        INSTANTIATE_REPLY_ID => {
            // let data = msg.result.unwrap().data.unwrap();
            let response = parse_reply_instantiate_data(msg).unwrap();
            CROSS_CHAIN_TOKEN.save(deps.storage, &response.contract_address)?;
            return Ok(
                Response::new().add_attribute("cw20token", response.contract_address.clone())
            );
        }
        CREATE_I_SEND_REQUEST => {
            deps.api.debug(&msg.id.to_string());
            // TODO: need to handle nonce data here, Nonce handling logic depends on the use-case.
            let response: Response<RouterMsg> = Response::new();
            match msg.result {
                SubMsgResult::Ok(msg_result) => match msg_result.data {
                    Some(binary_data) => {
                        deps.api.debug("Binary Data Found");
                        let cross_chain_req_res: CrosschainRequestResponse =
                            from_binary(&binary_data).unwrap();

                        let info_str: String = format!(
                            "Binary data {:?}, response {:?}",
                            &binary_data.to_string(),
                            cross_chain_req_res
                        );
                        deps.api.debug(&info_str);
                        return Ok(response);
                    }
                    None => deps.api.debug("No Binary Data Found"),
                },
                SubMsgResult::Err(err) => deps.api.debug(&err.to_string()),
            }
        }
        id => return Err(StdError::generic_err(format!("Unknown reply id: {}", id))),
    }
    Ok(Response::new())
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn execute(
    deps: DepsMut<RouterQuery>,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> StdResult<Response<RouterMsg>> {
    handle_execute(deps, env, info, msg)
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn sudo(deps: DepsMut<RouterQuery>, env: Env, msg: SudoMsg) -> StdResult<Response<RouterMsg>> {
    match msg {
        SudoMsg::HandleIReceive {
            request_sender,
            src_chain_id,
            request_identifier,
            payload,
        } => handle_sudo_request(
            deps,
            env,
            request_sender,
            src_chain_id,
            request_identifier,
            payload,
        ),
        SudoMsg::HandleIAck {
            request_identifier,
            exec_flag,
            exec_data,
            refund_amount,
        } => handle_sudo_ack(
            deps,
            env,
            request_identifier,
            exec_flag,
            exec_data,
            refund_amount,
        ),
    }
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn migrate(deps: DepsMut<RouterQuery>, env: Env, _msg: MigrateMsg) -> StdResult<Response> {
    let ver = cw2::get_contract_version(deps.storage)?;
    // ensure we are migrating from an allowed contract
    if ver.contract != CONTRACT_NAME.to_string() {
        return Err(StdError::generic_err("Can only upgrade from same type").into());
    }
    // note: better to do proper semver compare, but string compare *usually* works
    // if ver.version >= CONTRACT_VERSION.to_string() {
    //     return Err(StdError::generic_err("Cannot upgrade from a newer version").into());
    // }

    let info_str: String = format!(
        "migrating contract: {}, new_contract_version: {}, contract_name: {}",
        env.contract.address,
        CONTRACT_VERSION.to_string(),
        CONTRACT_NAME.to_string()
    );
    deps.api.debug(&info_str);
    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;
    Ok(Response::default())
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn query(deps: Deps<RouterQuery>, env: Env, msg: QueryMsg) -> StdResult<Binary> {
    handle_query(deps, env, msg)
}

'''
'''--- cosmwasm/contracts/xerc20/src/execution.rs ---
use cosmwasm_std::{
    to_binary, Binary, CosmosMsg, DepsMut, Env, Event, MessageInfo, ReplyOn, Response, StdResult,
    SubMsg, Uint128, WasmMsg,
};
use new_crosstalk_sample::xerc20::{ChainTypeInfo, ContractInfo, ExecuteMsg};
use router_wasm_bindings::{
    ethabi::{encode, ethereum_types::U256, Token},
    types::{AckType, RequestMetaData},
    Bytes, RouterMsg, RouterQuery,
};

use crate::{
    modifiers::is_owner_modifier,
    query::{fetch_oracle_gas_price, fetch_white_listed_contract},
    state::{
        CHAIN_ID, CHAIN_TYPE_MAPPING, CREATE_I_SEND_REQUEST, CROSS_CHAIN_TOKEN, OWNER,
        WHITELISTED_CONTRACT_MAPPING,
    },
};

pub fn handle_execute(
    deps: DepsMut<RouterQuery>,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> StdResult<Response<RouterMsg>> {
    match msg {
        ExecuteMsg::SetChainTypes { chain_type_info } => {
            set_chain_types_info(deps, env, info, chain_type_info)
        }
        ExecuteMsg::UpdateOwner { new_owner } => update_owner(deps, &env, &info, new_owner),
        ExecuteMsg::SetChainId { id } => set_chain_id(deps, env, info, id),
        ExecuteMsg::SetXerc20Addr { addr } => set_xerc20_addr(deps, env, info, addr),
        ExecuteMsg::Mint { recipient, amount } => mint(deps, &env, &info, recipient, amount),
        ExecuteMsg::SetWhiteListedContracts { contracts } => {
            set_white_listed_contracts(deps, &env, &info, contracts)
        }
        ExecuteMsg::TrasferCrossChain {
            amount,
            recipient,
            dest_chain_id,
        } => transfer_cross_chain(deps, env, info, amount, recipient, dest_chain_id),
    }
}

pub fn set_white_listed_contracts(
    deps: DepsMut<RouterQuery>,
    _env: &Env,
    info: &MessageInfo,
    contracts: Vec<ContractInfo>,
) -> StdResult<Response<RouterMsg>> {
    is_owner_modifier(deps.as_ref(), &info)?;

    for i in 0..contracts.len() {
        WHITELISTED_CONTRACT_MAPPING.save(
            deps.storage,
            &contracts[i].chain_id,
            &contracts[i].contract_addr,
        )?;
    }

    let res = Response::new().add_attribute("action", "SetCustodyContracts");
    Ok(res)
}

pub fn mint(
    deps: DepsMut<RouterQuery>,
    _env: &Env,
    info: &MessageInfo,
    recipient: String,
    amount: Uint128,
) -> StdResult<Response<RouterMsg>> {
    is_owner_modifier(deps.as_ref(), &info)?;
    deps.api.addr_validate(&recipient)?;
    let mint_msg = cw20_base::msg::ExecuteMsg::Mint { recipient, amount };

    let xerc20_token: String = CROSS_CHAIN_TOKEN.load(deps.storage)?;
    let exec_mint_msg: CosmosMsg<RouterMsg> = CosmosMsg::Wasm(WasmMsg::Execute {
        contract_addr: xerc20_token,
        funds: vec![],
        msg: to_binary(&mint_msg)?,
    });
    let info_str: String = format!("exec_mint_token {:?}", exec_mint_msg);
    deps.api.debug(&info_str);

    let res = Response::new().add_message(exec_mint_msg);
    Ok(res)
}

pub fn update_owner(
    deps: DepsMut<RouterQuery>,
    _env: &Env,
    info: &MessageInfo,
    new_owner: String,
) -> StdResult<Response<RouterMsg>> {
    is_owner_modifier(deps.as_ref(), &info)?;

    OWNER.save(deps.storage, &new_owner)?;
    let res = Response::new();
    Ok(res)
}

/**
 * @notice Used to set chain type info operations of the given chain (chainId, chainType).
 * @notice Only callable by Admin.
 * @param  chain_type_info   chain infos (chain_id & chain_type)

*/
pub fn set_chain_types_info(
    deps: DepsMut<RouterQuery>,
    _env: Env,
    info: MessageInfo,
    chain_type_info: Vec<ChainTypeInfo>,
) -> StdResult<Response<RouterMsg>> {
    is_owner_modifier(deps.as_ref(), &info)?;

    for i in 0..chain_type_info.len() {
        CHAIN_TYPE_MAPPING.save(
            deps.storage,
            &chain_type_info[i].chain_id,
            &chain_type_info[i].chain_type,
        )?;
    }
    let event_name: String = String::from("SetChainTypeInfo");
    let set_chain_bytes_info_event: Event = Event::new(event_name);

    let res = Response::new()
        .add_attribute("action", "SetChainTypeInfo")
        .add_event(set_chain_bytes_info_event);
    Ok(res)
}

pub fn set_chain_id(
    deps: DepsMut<RouterQuery>,
    _env: Env,
    info: MessageInfo,
    id: String,
) -> StdResult<Response<RouterMsg>> {
    is_owner_modifier(deps.as_ref(), &info)?;

    CHAIN_ID.save(deps.storage, &id)?;
    let event_name: String = String::from("SetChainId");
    let event: Event = Event::new(event_name);

    let res = Response::new()
        .add_attribute("action", "SetChainId")
        .add_event(event);
    Ok(res)
}

/**
 * @notice Used to set xerc20 token address
 * @notice Only callable by Admin.
 * @param  addr   xerc20 token address

*/
pub fn set_xerc20_addr(
    deps: DepsMut<RouterQuery>,
    _env: Env,
    info: MessageInfo,
    addr: String,
) -> StdResult<Response<RouterMsg>> {
    is_owner_modifier(deps.as_ref(), &info)?;

    CROSS_CHAIN_TOKEN.save(deps.storage, &addr)?;
    let event_name: String = String::from("SetXERC20Addr");
    let event: Event = Event::new(event_name);

    let res = Response::new()
        .add_attribute("action", "SetXERC20Addr")
        .add_event(event);
    Ok(res)
}

pub fn transfer_cross_chain(
    deps: DepsMut<RouterQuery>,
    _env: Env,
    info: MessageInfo,
    amount: Uint128,
    recipient: Binary,
    dest_chain_id: String,
) -> StdResult<Response<RouterMsg>> {
    let u256: U256 = U256::from(amount.u128());
    let payload: Vec<u8> = encode(&[Token::Bytes(recipient.0), Token::Uint(u256)]);
    let burn_msg = cw20_base::msg::ExecuteMsg::BurnFrom {
        owner: info.sender.to_string(),
        amount,
    };

    let xerc20_token: String = CROSS_CHAIN_TOKEN.load(deps.storage)?;
    let exec_burn_msg: CosmosMsg<RouterMsg> = CosmosMsg::Wasm(WasmMsg::Execute {
        contract_addr: xerc20_token,
        funds: vec![],
        msg: to_binary(&burn_msg)?,
    });
    let chain_id: String = CHAIN_ID.load(deps.storage)?;
    let ack_gas_price: u64 = fetch_oracle_gas_price(deps.as_ref(), chain_id)?;
    let dest_gas_price: u64 = fetch_oracle_gas_price(deps.as_ref(), dest_chain_id.clone())?;
    let dest_contract_address: String = fetch_white_listed_contract(deps.as_ref(), &dest_chain_id)?;
    let request_metadata: RequestMetaData = RequestMetaData {
        dest_gas_limit: 200_000,
        dest_gas_price,
        ack_gas_limit: 200_000,
        ack_gas_price,
        relayer_fee: Uint128::zero(),
        ack_type: AckType::AckOnBoth,
        is_read_call: false,
        asm_address: String::default(),
    };
    let info_str: String = format!(
        "create_outbound_request-- dest_chain_id: {}, dest_contract_address: {}, request_metadata: {:?}",
        dest_chain_id, dest_contract_address.clone(), request_metadata
    );
    deps.api.debug(&info_str);
    let request_packet: Bytes = encode(&[
        Token::String(dest_contract_address.clone()),
        Token::Bytes(payload),
    ]);

    let i_send_request: RouterMsg = RouterMsg::CrosschainCall {
        version: 1,
        route_amount: Uint128::zero(),
        route_recipient: String::default(),
        dest_chain_id,
        request_metadata: request_metadata.get_abi_encoded_bytes(),
        request_packet,
    };
    let cross_chain_sub_msg: SubMsg<RouterMsg> = SubMsg {
        id: CREATE_I_SEND_REQUEST,
        msg: i_send_request.into(),
        gas_limit: None,
        reply_on: ReplyOn::Success,
    };
    let res = Response::new()
        .add_message(exec_burn_msg)
        .add_submessage(cross_chain_sub_msg.into())
        .add_attribute("dest_contract_address", dest_contract_address);
    Ok(res)
}

'''
'''--- cosmwasm/contracts/xerc20/src/handle_sudo_execution.rs ---
use cosmwasm_std::{
    to_binary, Binary, Coin, CosmosMsg, DepsMut, Env, Event, Response, StdError, StdResult,
    Uint128, WasmMsg,
};
use router_wasm_bindings::{
    ethabi::{decode, ParamType},
    types::ChainType,
    utils::convert_address_from_bytes_to_string,
    Bytes, RouterMsg, RouterQuery,
};

use crate::{
    modifiers::is_white_listed_modifier,
    state::{CHAIN_TYPE_MAPPING, CROSS_CHAIN_TOKEN},
};

pub fn handle_sudo_request(
    deps: DepsMut<RouterQuery>,
    _env: Env,
    request_sender: String,
    src_chain_id: String,
    request_identifier: u64,
    payload: Binary,
) -> StdResult<Response<RouterMsg>> {
    deps.api.debug("XERC20 INFO: Handle Sudo Request");
    let src_chain_type: u64 = CHAIN_TYPE_MAPPING.load(deps.storage, &src_chain_id)?;
    let sender: String = match src_chain_type {
        1 => request_sender.to_lowercase(),
        _ => request_sender.clone(),
    };

    is_white_listed_modifier(deps.as_ref(), &src_chain_id, &sender)?;
    deps.api.debug("Request Coming from whitelisted Contract");
    // bytes memory packet = abi.encode(recipient, amount);
    let token_vec = match decode(&[ParamType::Bytes, ParamType::Uint(128)], &payload.0) {
        Ok(data) => data,
        Err(_) => {
            return Err(StdError::GenericErr {
                msg: String::from("err.into()"),
            });
        }
    };

    let u128_val: u128 = token_vec[1].clone().into_uint().unwrap().as_u128();
    let amount = Uint128::new(u128_val);
    let addr: Bytes = token_vec[0].clone().into_bytes().unwrap();

    let recipient =
        convert_address_from_bytes_to_string(&addr, ChainType::ChainTypeCosmos.get_chain_code())?;
    let info_str: String = format!("recipient {:?}, amount {:?}", recipient, amount);
    deps.api.debug(&info_str);

    deps.api.addr_validate(&recipient)?;
    let mint_msg = cw20_base::msg::ExecuteMsg::Mint { recipient, amount };

    let xerc20_token: String = CROSS_CHAIN_TOKEN.load(deps.storage)?;
    let exec_mint_msg: CosmosMsg<RouterMsg> = CosmosMsg::Wasm(WasmMsg::Execute {
        contract_addr: xerc20_token,
        funds: vec![],
        msg: to_binary(&mint_msg)?,
    });
    let info_str: String = format!("exec_mint_token {:?}", exec_mint_msg);
    deps.api.debug(&info_str);

    let res: Response<RouterMsg> = Response::new()
        .add_message(exec_mint_msg)
        .add_attribute("sender", request_sender)
        .add_attribute("request_identifier", request_identifier.to_string())
        .add_attribute("src_chain_id", src_chain_id);
    Ok(res)
}

pub fn handle_sudo_ack(
    deps: DepsMut<RouterQuery>,
    _env: Env,
    request_identifier: u64,
    exec_flag: bool,
    exec_data: Binary,
    _refund_amount: Coin,
) -> StdResult<Response<RouterMsg>> {
    let info_str: String = format!(
        "handle_sudo_ack, request_identifier {:?}, exec_data {:?}",
        request_identifier, exec_data
    );
    deps.api.debug(&info_str);
    let event = Event::new("ExecutionStatus")
        .add_attribute("requestIdentifier", request_identifier.to_string())
        .add_attribute("execFlag", exec_flag.to_string());

    Ok(Response::new().add_event(event))
}

'''
'''--- cosmwasm/contracts/xerc20/src/lib.rs ---
pub mod contract;
pub mod execution;
pub mod handle_sudo_execution;
pub mod modifiers;
pub mod query;
pub mod state;

pub use serde::{Deserialize, Serialize};
#[cfg(test)]
mod tests;

'''
'''--- cosmwasm/contracts/xerc20/src/modifiers.rs ---
use cosmwasm_std::{Deps, MessageInfo, StdError, StdResult};
use router_wasm_bindings::RouterQuery;

use crate::{query::is_white_listed_contract, state::OWNER};

pub fn is_owner_modifier(deps: Deps<RouterQuery>, info: &MessageInfo) -> StdResult<()> {
    let owner: String = match OWNER.load(deps.storage) {
        Ok(owner) => owner,
        Err(err) => return StdResult::Err(err),
    };
    if owner != info.sender {
        return StdResult::Err(StdError::GenericErr {
            msg: String::from("Auth: Invalid Owner"),
        });
    }
    Ok(())
}

pub fn is_white_listed_modifier(
    deps: Deps<RouterQuery>,
    chain_id: &str,
    contract: &str,
) -> StdResult<()> {
    let is_white_listed_contract = is_white_listed_contract(deps, chain_id, contract);
    let info_str: String = format!("--chain_id: {:?}, contract: {:?}", chain_id, contract);
    deps.api.debug(&info_str);
    if !is_white_listed_contract {
        let info_str: String = format!(
            "Auth: The Sender/Receiver contract is not whitelisted, chain_id: {:?}, contract: {:?}",
            chain_id, contract
        );
        deps.api.debug(&info_str);
        return StdResult::Err(StdError::GenericErr { msg: info_str });
    }
    Ok(())
}

'''
'''--- cosmwasm/contracts/xerc20/src/query.rs ---
use cosmwasm_std::{to_binary, Binary, Deps, Env, Order, StdResult, Uint128};
use cw2::get_contract_version;
use new_crosstalk_sample::xerc20::QueryMsg;
use router_wasm_bindings::{
    types::{GasPriceResponse, TokenPriceResponse},
    RouterQuerier, RouterQuery,
};

use crate::state::{
    CHAIN_ID, CHAIN_TYPE_MAPPING, CROSS_CHAIN_TOKEN, OWNER, WHITELISTED_CONTRACT_MAPPING,
};

pub fn handle_query(deps: Deps<RouterQuery>, _env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::GetContractVersion {} => to_binary(&get_contract_version(deps.storage)?),
        QueryMsg::FetchWhiteListedContract { chain_id } => {
            to_binary(&fetch_white_listed_contract(deps, &chain_id)?)
        }
        QueryMsg::FetchOwner {} => to_binary(&fetch_owner(deps)?),
        QueryMsg::FetchXerc20 {} => to_binary(&fetch_xerc20_addr(deps)?),
        QueryMsg::FetchChainId {} => to_binary(&fetch_chain_id(deps)?),
        QueryMsg::AllWhiteListedContract {} => to_binary(&fetch_all_white_listed_contract(deps)?),
        QueryMsg::FetchChainType { chain_id } => to_binary(&fetch_chain_type(deps, &chain_id)?),
    }
}

pub fn is_white_listed_contract(
    deps: Deps<RouterQuery>,
    chain_id: &str,
    contract_addr: &str,
) -> bool {
    match WHITELISTED_CONTRACT_MAPPING.load(deps.storage, chain_id) {
        Ok(contract) => return contract == contract_addr,
        _ => false,
    }
}

pub fn fetch_white_listed_contract(deps: Deps<RouterQuery>, chain_id: &str) -> StdResult<String> {
    WHITELISTED_CONTRACT_MAPPING.load(deps.storage, chain_id)
}

pub fn fetch_owner(deps: Deps<RouterQuery>) -> StdResult<String> {
    OWNER.load(deps.storage)
}

pub fn fetch_all_white_listed_contract(
    deps: Deps<RouterQuery>,
) -> StdResult<Vec<(String, String)>> {
    match WHITELISTED_CONTRACT_MAPPING
        .range(deps.storage, None, None, Order::Ascending)
        .collect()
    {
        Ok(data) => return Ok(data),
        Err(err) => return Err(err),
    };
}

/**
 * @notice Used to fetch chain_info.
 * @param   chain_id
*/
pub fn fetch_chain_type(deps: Deps<RouterQuery>, chain_id: &str) -> StdResult<u64> {
    CHAIN_TYPE_MAPPING.load(deps.storage, chain_id)
}

pub fn fetch_oracle_gas_price(deps: Deps<RouterQuery>, chain_id: String) -> StdResult<u64> {
    let router_querier: RouterQuerier = RouterQuerier::new(&deps.querier);
    let gas_price_response: GasPriceResponse = router_querier.gas_price(chain_id)?;
    Ok((gas_price_response.gas_price * 120) / 100)
}

pub fn fetch_oracle_token_price(deps: Deps<RouterQuery>, symbol: String) -> StdResult<Uint128> {
    let router_querier: RouterQuerier = RouterQuerier::new(&deps.querier);
    let token_price_response: TokenPriceResponse = router_querier.token_price(symbol)?;
    Ok(token_price_response.token_price)
}

pub fn fetch_xerc20_addr(deps: Deps<RouterQuery>) -> StdResult<String> {
    CROSS_CHAIN_TOKEN.load(deps.storage)
}

pub fn fetch_chain_id(deps: Deps<RouterQuery>) -> StdResult<String> {
    CHAIN_ID.load(deps.storage)
}

'''
'''--- cosmwasm/contracts/xerc20/src/state.rs ---
use cw_storage_plus::{Item, Map};

pub const INSTANTIATE_REPLY_ID: u64 = 1;
pub const CREATE_I_SEND_REQUEST: u64 = 2;

pub const OWNER: Item<String> = Item::new("owner");

pub const WHITELISTED_CONTRACT_MAPPING: Map<&str, String> = Map::new("forwarder_contract_mapping");

pub const CHAIN_TYPE_MAPPING: Map<&str, u64> = Map::new("chain_type_mapping");

pub const CHAIN_ID: Item<String> = Item::new("chain_id");

pub const CROSS_CHAIN_TOKEN: Item<String> = Item::new("cross_chain_token");

'''
'''--- cosmwasm/contracts/xerc20/src/tests.rs ---
//

use std::marker::PhantomData;
use std::vec;

use crate::contract::instantiate;
use crate::contract::{execute, sudo};
use cosmwasm_std::testing::{MockApi, MockQuerier, MockStorage};
use cosmwasm_std::{
    testing::{mock_env, mock_info},
    DepsMut,
};
use cosmwasm_std::{Binary, Coin, OwnedDeps, Uint128};
use new_crosstalk_sample::xerc20::{ChainTypeInfo, ExecuteMsg, InstantiateMsg};
use router_wasm_bindings::ethabi::{decode, ParamType};
use router_wasm_bindings::types::{AckType, ChainType, RequestMetaData};
use router_wasm_bindings::utils::{
    convert_address_from_bytes_to_string, convert_address_from_string_to_bytes,
};
use router_wasm_bindings::{Bytes, RouterQuery, SudoMsg};

const INIT_ADDRESS: &str = "router1apapk9zfz3rp4x87fsm6h0s3zd0wlmkz0fx8tx";
const BRIDGE_ADDRESS: &str = "0xeedb3ab68d567a6cd6d19fa819fe77b9f8ed1538";

fn do_instantiate(mut deps: DepsMut<RouterQuery>) {
    let instantiate_msg = InstantiateMsg {
        cw20_code_id: 1,
        token_name: String::from("sdsdsds"),
        token_symbol: String::from("dsdwdw"),
    };
    let info = mock_info(INIT_ADDRESS, &[]);
    let env = mock_env();
    let res = instantiate(deps.branch(), env.clone(), info.clone(), instantiate_msg).unwrap();
    assert_eq!(1, res.messages.len());

    let chain_types: ExecuteMsg = ExecuteMsg::SetChainTypes {
        chain_type_info: vec![
            ChainTypeInfo {
                chain_id: "80001".to_string(),
                chain_type: 1,
            },
            ChainTypeInfo {
                chain_id: "5".to_string(),
                chain_type: 1,
            },
            ChainTypeInfo {
                chain_id: "43113".to_string(),
                chain_type: 1,
            },
            ChainTypeInfo {
                chain_id: "router_9000-1".to_string(),
                chain_type: 2,
            },
        ],
    };
    execute(deps.branch(), env.clone(), info.clone(), chain_types).unwrap();
    let set_xerc20: ExecuteMsg = ExecuteMsg::SetXerc20Addr {
        addr: INIT_ADDRESS.to_string(),
    };
    execute(deps.branch(), env.clone(), info, set_xerc20).unwrap();
}

#[test]
fn test_basic() {
    let mut deps = OwnedDeps {
        storage: MockStorage::default(),
        api: MockApi::default(),
        querier: MockQuerier::default(),
        custom_query_type: PhantomData,
    };
    do_instantiate(deps.as_mut());
}

#[test]
fn test_sudo_inbound_function() {
    let mut deps = OwnedDeps {
        storage: MockStorage::default(),
        api: MockApi::default(),
        querier: MockQuerier::default(),
        custom_query_type: PhantomData,
    };
    do_instantiate(deps.as_mut());
    let env = mock_env();
    let binary: Binary = Binary::from_base64("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN4Lazp2QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBcm91dGVyMXJkbDdmZGp0azRjc3JmenBzc2ptenMwMzhyejd1bWRjbm03bmVkdDNoamNkZjc0enI5N3FqMm03ZmMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA").unwrap();
    let msg: SudoMsg = SudoMsg::HandleIReceive {
        request_sender: BRIDGE_ADDRESS.into(),
        src_chain_id: String::from("80001"),
        request_identifier: 2,
        payload: binary,
    };

    let result = sudo(deps.as_mut(), env, msg);
    if result.is_err() {
        println!("{:?}", result.as_ref().err());
        assert!(false);
        return;
    }
    let response = result.unwrap();
    assert_eq!(response.messages.len(), 0);
}

#[test]
fn test_sudo_outbound_ack_function() {
    let mut deps = OwnedDeps {
        storage: MockStorage::default(),
        api: MockApi::default(),
        querier: MockQuerier::default(),
        custom_query_type: PhantomData,
    };
    do_instantiate(deps.as_mut());
    let env = mock_env();

    let payload: Bytes = hex::decode("0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000a68656c6c6f2070696e6700000000000000000000000000000000000000000000").unwrap();
    let binary_data: Binary = Binary(payload);
    let msg: SudoMsg = SudoMsg::HandleIAck {
        request_identifier: 1,
        exec_flag: true,
        exec_data: binary_data,
        refund_amount: Coin::new(123u128, String::from("route")),
    };

    let result = sudo(deps.as_mut(), env, msg);
    if result.is_err() {
        println!("{:?}", result.as_ref().err());
        assert!(false);
        return;
    }
    let response = result.unwrap();
    assert_eq!(response.messages.len(), 0);
}

// #[test]
// fn test_execute_create_outbound_request() {
//     let mut deps = OwnedDeps {
//         storage: MockStorage::default(),
//         api: MockApi::default(),
//         querier: MockQuerier::default(),
//         custom_query_type: PhantomData,
//     };
//     do_instantiate(deps.as_mut());
//     let env = mock_env();
//     let greeting: String = String::from("Hello Lord Venky");

//     let msg: ExecuteMsg = ExecuteMsg::IPing {
//         dest_contract_address: String::from(BRIDGE_ADDRESS),
//         dest_chain_id: String::from("80001"),
//         ping: greeting,
//         request_metadata: Binary(vec![]),
//     };
//     let info = mock_info(INIT_ADDRESS, &[]);
//     let response = execute(deps.as_mut(), env, info, msg).unwrap();
//     assert_eq!(response.messages.len(), 1);

//     let message = response.messages.get(0).unwrap();
//     let router_msg = message.msg.clone();
//     match router_msg {
//         CosmosMsg::Custom(msg) => match msg {
//             RouterMsg::CrosschainCall {
//                 version,
//                 route_amount,
//                 route_recipient,
//                 dest_chain_id,
//                 request_metadata,
//                 request_packet,
//             } => {
//                 assert_eq!(route_amount, Uint128::zero());
//                 assert_eq!(route_recipient, "");

//                 assert_eq!(dest_chain_id, "80001");
//                 assert_eq!(version, 1);
//                 assert_eq!(hex::encode(request_metadata), "");
//                 assert_eq!(hex::encode(request_packet), "000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000002a30786565646233616236386435363761366364366431396661383139666537376239663865643135333800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000001048656c6c6f204c6f72642056656e6b7900000000000000000000000000000000");
//             }
//         },
//         _ => {}
//     }
// }

#[test]
fn test_encode() {
    let addr: String = String::from("0xEeDb3AB68d567A6CD6D19Fa819fe77b9f8Ed1538");
    println!(
        "{:?}",
        Binary(
            convert_address_from_string_to_bytes(addr, ChainType::ChainTypeEvm.get_chain_code())
                .unwrap()
        )
        .to_base64()
    );

    let binary: Binary = Binary::from_base64("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN4Lazp2QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBcm91dGVyMXJkbDdmZGp0azRjc3JmenBzc2ptenMwMzhyejd1bWRjbm03bmVkdDNoamNkZjc0enI5N3FqMm03ZmMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA").unwrap();
    println!(
        "{:?}",
        decode(&[ParamType::Bytes, ParamType::Uint(128)], &binary.0)
    );
    let cc: Bytes = vec![
        114, 111, 117, 116, 101, 114, 49, 114, 100, 108, 55, 102, 100, 106, 116, 107, 52, 99, 115,
        114, 102, 122, 112, 115, 115, 106, 109, 122, 115, 48, 51, 56, 114, 122, 55, 117, 109, 100,
        99, 110, 109, 55, 110, 101, 100, 116, 51, 104, 106, 99, 100, 102, 55, 52, 122, 114, 57, 55,
        113, 106, 50, 109, 55, 102, 99,
    ];
    println!(
        "{:?}",
        convert_address_from_bytes_to_string(&cc, ChainType::ChainTypeCosmos.get_chain_code())
    );
    let rm: RequestMetaData = RequestMetaData {
        dest_gas_limit: 200_000,
        dest_gas_price: 50_000_000_000,
        ack_gas_limit: 200_000,
        ack_gas_price: 50_000_000_000,
        relayer_fee: Uint128::zero(),
        ack_type: AckType::AckOnBoth,
        is_read_call: false,
        asm_address: String::default(),
    };
    let bin: Binary = Binary(rm.get_abi_encoded_bytes());
    println!("{:?}", hex::encode(bin.0));
}

'''
'''--- cosmwasm/contracts/xerc721/Cargo.toml ---
[package]
name = "XERC721"
version = "0.1.0"
edition = "2021"
authors = ["Gaurav Agarwal <gaurav@routerprotocol.com>"]
description = "The Cross Chain XERC721 example contract"
repository = "https://github.com/router-protocol/new-crosstalk-sample.git"

exclude = [
  # Those files are rust-optimizer artifacts. You might want to commit them for convenience but they should not be part of the source code publication.
  "contract.wasm",
  "hash.txt",
]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[profile.release]
opt-level = 3
debug = false
rpath = false
lto = true
debug-assertions = false
codegen-units = 1
panic = 'abort'
incremental = false
overflow-checks = true

[features]
# for more explicit tests, cargo test --features=backtraces
backtraces = ["cosmwasm-std/backtraces"]
# use library feature to disable all instantiate/execute/query exports
library = []

[package.metadata.scripts]
optimize = """docker run --rm -v "$(pwd)":/code \
  --mount type=volume,source="$(basename "$(pwd)")_cache",target=/code/target \
  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \
  cosmwasm/rust-optimizer:0.12.13
"""

[dependencies]
serde_json="1"
cw721 = "0.17.0"
cw721-base = { version = "0.16.0", features = ["library"] }
cosmwasm-storage = "1.0.0"
cw-utils = "1.0.1"
cosmwasm-std = "1.0.0"
cw-storage-plus = { version = "0.13.4" }
schemars = "0.8.8"
serde = { version = "1.0.137", default-features = false, features = ["derive"] }
thiserror = { version = "1.0.31" }
cw0 = { version = "0.10.3" }
cw2 = { version = "0.13.2" }
cosmwasm-crypto = "1.0.0"
getrandom = { version = "0.2", features = ["js"] }
hex = "0.4"
arrayref = "0.3.6"
codec = { package = "parity-scale-codec", version = "2.0.0", features = ["derive"] }
router-wasm-bindings = { version = "0.2.3", default-features = false, features = ["ethabi"] }
new-crosstalk-sample = { package = "new-crosstalk-sample", path = "../../packages/new-crosstalk-sample"}

[dev-dependencies]
cosmwasm-schema = "1.0.0"
cw-multi-test = "0.13.2"
'''
'''--- cosmwasm/contracts/xerc721/examples/schema.rs ---
use std::env::current_dir;
use std::fs::create_dir_all;

use cosmwasm_schema::{export_schema, remove_schemas, schema_for};

use new_crosstalk_sample::xerc721::{ExecuteMsg, InstantiateMsg, QueryMsg};

fn main() {
    let mut out_dir = current_dir().unwrap();
    out_dir.push("schema/xerc721");
    create_dir_all(&out_dir).unwrap();
    remove_schemas(&out_dir).unwrap();

    export_schema(&schema_for!(InstantiateMsg), &out_dir);
    export_schema(&schema_for!(ExecuteMsg), &out_dir);
    export_schema(&schema_for!(QueryMsg), &out_dir);
}

'''
'''--- cosmwasm/contracts/xerc721/src/contract.rs ---
use cosmwasm_std::Empty;
#[cfg(not(feature = "library"))]
use cosmwasm_std::{
    entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdError, StdResult,
};
use cw2::set_contract_version;
use cw721::ContractInfoResponse;
use cw721_base::MintMsg;
// use cw721::Cw721Query::ContractInfoResponse;
use router_wasm_bindings::{RouterMsg, RouterQuery, SudoMsg};

use crate::{
    execution::{handle_execute, handle_sudo, Cw721ExecuteMsg, Cw721NFTContract, Cw721QueryMsg},
    query::handle_query,
    state::OWNER,
};

use new_crosstalk_sample::xerc721::{InstantiateMsg, MigrateMsg, QueryMsg};

// version info for migration info
const CONTRACT_NAME: &str = "xerc721";
const CONTRACT_VERSION: &str = "1.0.0";

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    info: MessageInfo,
    msg: InstantiateMsg,
) -> StdResult<Response> {
    deps.api.debug("Instantiating the contract");

    // Store state with owner address
    OWNER.save(deps.storage, &info.sender.to_string())?;

    let tract = Cw721NFTContract::default();
    //TODO: correct this
    // let info = ContractInfoResponse {
    //     name: msg.name,
    //     symbol: msg.symbol,
    // };
    // tract.contract_info.save(deps.storage, &info)?;
    let minter = deps.api.addr_validate(&msg.minter)?;
    tract.minter.save(deps.storage, &minter)?;

    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;

    //mint nft to deployer
    let mint_msg = MintMsg {
        token_id: 1.to_string(),
        token_uri: None,
        owner: minter.into_string(),
        extension: Empty {},
    };
    match tract.mint(deps, _env, info, mint_msg) {
        Err(_) => return Err(StdError::GenericErr { msg: "".into() }),
        _ => {}
    }

    Ok(Response::new().add_attribute("action", "xcw721-init"))
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: Cw721ExecuteMsg,
) -> StdResult<Response<RouterMsg>> {
    handle_execute(deps, env, info, msg)
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn migrate(deps: DepsMut<RouterQuery>, env: Env, _msg: MigrateMsg) -> StdResult<Response> {
    let ver: cw2::ContractVersion = cw2::get_contract_version(deps.storage)?;
    // ensure we are migrating from an allowed contract
    if ver.contract != CONTRACT_NAME.to_string() {
        return Err(StdError::generic_err("Can only upgrade from same type").into());
    }
    // note: better to do proper semver compare, but string compare *usually* works
    if ver.version >= CONTRACT_VERSION.to_string() {
        return Err(StdError::generic_err("Cannot upgrade from a newer version").into());
    }

    let info_str: String = format!(
        "migrating contract: {}, new_contract_version: {}, contract_name: {}",
        env.contract.address,
        CONTRACT_VERSION.to_string(),
        CONTRACT_NAME.to_string()
    );
    deps.api.debug(&info_str);
    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;
    Ok(Response::default())
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn query(deps: Deps, env: Env, msg: Cw721QueryMsg) -> StdResult<Binary> {
    handle_query(deps, env, msg)
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn sudo(deps: DepsMut<RouterQuery>, env: Env, msg: SudoMsg) -> StdResult<Response<RouterMsg>> {
    handle_sudo(deps, env, msg)
}

'''
'''--- cosmwasm/contracts/xerc721/src/execution.rs ---
use cosmwasm_std::{
    Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdError, StdResult, Uint128,
};
use cw721_base::{state::TokenInfo, Cw721Contract};
use new_crosstalk_sample::xerc721::{ExecuteMsg, QueryMsg, TransferParams};
// use rand::Rng;
use router_wasm_bindings::{
    ethabi::{decode, encode, ParamType, Token},
    types::RequestMetaData,
    Bytes, RouterMsg, RouterQuery, SudoMsg,
};

use crate::state::{OWNER, REMOTE_CONTRACT_MAPPING};
pub type Cw721NFTContract<'a> = Cw721Contract<'a, Empty, Empty, ExecuteMsg, QueryMsg>;
pub type Cw721ExecuteMsg = cw721_base::ExecuteMsg<Empty, ExecuteMsg>;
pub type Cw721QueryMsg = cw721_base::QueryMsg<QueryMsg>;

pub fn handle_execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: Cw721ExecuteMsg,
) -> StdResult<Response<RouterMsg>> {
    match msg {
        Cw721ExecuteMsg::Extension { msg } => match msg {
            ExecuteMsg::EnrollRemoteContract {
                chain_id,
                remote_address,
            } => enroll_remote_contract(deps, env, info, chain_id, remote_address),
            ExecuteMsg::TransferCrossChain {
                dst_chain_id,
                token_id,
                recipient,
                request_metadata,
            } => transfer_crosschain(
                deps,
                env,
                info,
                dst_chain_id,
                token_id,
                recipient,
                request_metadata,
            ),
        },
        _ => match Cw721NFTContract::default().execute(deps, env, info, msg) {
            Ok(cw721_res) => {
                let response: Response<RouterMsg> = Response::<RouterMsg>::new()
                    .add_attributes(cw721_res.attributes)
                    .add_events(cw721_res.events);
                return Ok(response);
            }
            Err(err) => {
                return Err(StdError::GenericErr {
                    msg: err.to_string(),
                })
            }
        },
    }
}

pub fn only_owner(deps: Deps, info: MessageInfo) -> StdResult<Response<RouterMsg>> {
    if info.sender.to_string() != OWNER.load(deps.storage).unwrap() {
        return Err(StdError::GenericErr {
            msg: "Auth: Invalid Owner".into(),
        });
    } else {
        Ok(Response::new())
    }
}

pub fn enroll_remote_contract(
    deps: DepsMut,
    _env: Env,
    info: MessageInfo,
    chain_id: String,
    remote_address: String,
) -> StdResult<Response<RouterMsg>> {
    only_owner(deps.as_ref(), info)?;
    REMOTE_CONTRACT_MAPPING.save(deps.storage, chain_id, &remote_address)?;
    Ok(Response::new())
}

pub fn transfer_crosschain(
    deps: DepsMut,
    _env: Env,
    info: MessageInfo,
    dst_chain_id: String,
    token_id: u64,
    recipient: String,
    request_metadata: RequestMetaData,
) -> StdResult<Response<RouterMsg>> {
    let tract = Cw721NFTContract::default();
    let rider_info = tract.tokens.load(deps.storage, &token_id.to_string())?;
    match tract.check_can_send(deps.as_ref(), &_env, &info, &rider_info) {
        Err(_) => {
            return Err(StdError::GenericErr {
                msg: "ContractError::Unauthorized".to_string(),
            })
        }
        _ => (),
    }

    // burn nft
    tract.tokens.remove(deps.storage, &token_id.to_string())?;
    tract.decrement_tokens(deps.storage)?;

    let dst_contract_add: String = REMOTE_CONTRACT_MAPPING
        .load(deps.storage, dst_chain_id.clone())
        .unwrap();
    let transfer_params = TransferParams {
        nft_id: token_id,
        recipient,
    };

    let encoded_payload: Vec<u8> = encode(&[transfer_params.get_evm_encoding()?]);
    let request_packet: Bytes = encode(&[
        Token::String(dst_contract_add),
        Token::Bytes(encoded_payload),
    ]);

    let i_send_request: RouterMsg = RouterMsg::CrosschainCall {
        version: 1,
        route_amount: Uint128::new(0u128),
        route_recipient: String::from(""),
        dest_chain_id: dst_chain_id.clone(),
        request_metadata: request_metadata.get_abi_encoded_bytes(),
        request_packet,
    };

    Ok(Response::new().add_message(i_send_request))
}

pub fn handle_sudo(
    deps: DepsMut<RouterQuery>,
    env: Env,
    msg: SudoMsg,
) -> StdResult<Response<RouterMsg>> {
    match msg {
        SudoMsg::HandleIReceive {
            request_sender,
            src_chain_id,
            request_identifier,
            payload,
        } => handle_sudo_request(
            deps,
            env,
            request_sender,
            src_chain_id,
            request_identifier,
            payload,
        ),
        SudoMsg::HandleIAck {
            request_identifier: _,
            exec_flag: _,
            exec_data: _,
            refund_amount: _,
        } => Ok(Response::new()),
    }
}

pub fn handle_sudo_request(
    deps: DepsMut<RouterQuery>,
    _env: Env,
    request_sender: String,
    src_chain_id: String,
    _request_identifier: u64,
    payload: Binary,
) -> StdResult<Response<RouterMsg>> {
    let remote_contract_add = REMOTE_CONTRACT_MAPPING
        .load(deps.storage, src_chain_id.clone())
        .unwrap();

    if remote_contract_add != request_sender {
        return Err(StdError::GenericErr {
            msg: "Invalid sender".to_string(),
        });
    }

    let params = TransferParams::get_params_types();
    let param_vec: Vec<ParamType> = vec![params];
    let token_vec = match decode(&param_vec, &payload.0) {
        Ok(data) => data,
        Err(_) => {
            return Err(StdError::GenericErr {
                msg: String::from("err.into()"),
            })
        }
    };
    let transfer_params_tokens: Vec<Token> = token_vec[0].clone().into_tuple().unwrap();
    let transfer_params: TransferParams = TransferParams::from_token_tuple(transfer_params_tokens)?;

    // mint nft
    let tract = Cw721NFTContract::default();
    let token_info = TokenInfo {
        owner: deps.api.addr_validate(&transfer_params.recipient)?,
        approvals: vec![],
        token_uri: None,
        extension: Empty {},
    };
    tract.tokens.save(
        deps.storage,
        &transfer_params.nft_id.to_string(),
        &token_info,
    )?;
    tract.increment_tokens(deps.storage)?;

    let mut response = Response::new();
    let encoded_ack_payload: Vec<u8> = encode(&[Token::String(src_chain_id)]);
    response.data = Some(Binary(encoded_ack_payload));
    Ok(response)
}

'''
'''--- cosmwasm/contracts/xerc721/src/lib.rs ---
pub mod contract;
pub mod execution;
pub mod query;
pub mod state;

pub use serde::{Deserialize, Serialize};
#[cfg(test)]
mod tests;

'''
'''--- cosmwasm/contracts/xerc721/src/query.rs ---
use cosmwasm_std::{to_binary, Binary, Deps, Env, StdResult};
use cw2::get_contract_version;
use new_crosstalk_sample::xerc721::QueryMsg;

use crate::{
    execution::{Cw721NFTContract, Cw721QueryMsg},
    state::{OWNER, REMOTE_CONTRACT_MAPPING},
};

pub fn handle_query(deps: Deps, env: Env, msg: Cw721QueryMsg) -> StdResult<Binary> {
    let tract = Cw721NFTContract::default();
    match msg {
        Cw721QueryMsg::Extension { msg } => match msg {
            QueryMsg::GetContractVersion {} => to_binary(&get_contract_version(deps.storage)?),
            QueryMsg::GetOwner {} => to_binary(&get_owner(deps)?),
            QueryMsg::GetRemoteContract { chain_id } => {
                to_binary(&get_remote_contract(deps, chain_id)?)
            }
        },
        _ => tract.query(deps, env, msg),
    }
}

pub fn get_owner(deps: Deps) -> StdResult<String> {
    OWNER.load(deps.storage)
}

fn get_remote_contract(deps: Deps, chain_id: String) -> StdResult<String> {
    REMOTE_CONTRACT_MAPPING.load(deps.storage, chain_id)
}

'''
'''--- cosmwasm/contracts/xerc721/src/state.rs ---
use cw_storage_plus::{Item, Map};

pub const OWNER: Item<String> = Item::new("owner");
// chain chain id => address of our contract in bytes
pub const REMOTE_CONTRACT_MAPPING: Map<String, String> = Map::new("remote_contract_mapping");

'''
'''--- cosmwasm/contracts/xerc721/src/tests.rs ---
use crate::contract::{execute, instantiate, query};
use crate::execution::{Cw721ExecuteMsg, Cw721QueryMsg};
use cw721::{NftInfoResponse, OwnerOfResponse};
use cw721_base::MintMsg;
use new_crosstalk_sample::xerc721::{ExecuteMsg, InstantiateMsg, QueryMsg};
use router_wasm_bindings::types::RequestMetaData;
use router_wasm_bindings::RouterMsg;

use cosmwasm_std::testing::{
    mock_dependencies, mock_env, mock_info, MockApi, MockQuerier, MockStorage,
};
use cosmwasm_std::{CosmosMsg, Deps, Empty, Env, MessageInfo, Response, StdError, Uint128};

use cosmwasm_std::from_binary;
use cosmwasm_std::DepsMut;
use cosmwasm_std::OwnedDeps;
use std::marker::PhantomData;

const SENDER: &str = "router1apapk9zfz3rp4x87fsm6h0s3zd0wlmkz0fx8tx";

fn get_mock_dependencies() -> OwnedDeps<MockStorage, MockApi, MockQuerier> {
    OwnedDeps {
        storage: MockStorage::default(),
        api: MockApi::default(),
        querier: MockQuerier::default(),
        custom_query_type: PhantomData::default(),
    }
}

fn do_instantiate(mut deps: DepsMut) {
    let instantiate_msg = InstantiateMsg {
        name: "ERC721".into(),
        symbol: "ERC721".into(),
        minter: SENDER.to_string(),
    };
    let info = mock_info(SENDER, &[]);
    let env = mock_env();
    let res = instantiate(deps.branch(), env, info, instantiate_msg).unwrap();
    assert_eq!(0, res.messages.len());
}

fn set_remote_contract(
    deps: DepsMut,
    env: Env,
    _info: MessageInfo,
    chain_id: String,
    remote_contract: String,
) {
    let extension_msg = ExecuteMsg::EnrollRemoteContract {
        chain_id: chain_id.clone(),
        remote_address: remote_contract.clone(),
    };
    let enroll_msg = cw721_base::ExecuteMsg::Extension { msg: extension_msg };
    let res = execute(deps, env.clone(), _info, enroll_msg.clone());
    assert!(res.is_ok());
}

fn get_nft_owner_of(deps: Deps, env: Env, token_id: String) -> Result<OwnerOfResponse, StdError> {
    let query_msg = Cw721QueryMsg::OwnerOf {
        token_id,
        include_expired: Some(false),
    };
    let owner_of = query(deps, env, query_msg);
    match owner_of {
        Ok(brr) => from_binary(&brr),
        Err(_) => Err(StdError::NotFound { kind: "nft".into() }),
    }
}

fn get_nft_info(
    deps: Deps,
    env: Env,
    token_id: String,
) -> Result<NftInfoResponse<Empty>, StdError> {
    let query_msg = Cw721QueryMsg::NftInfo { token_id };
    let nft_info = query(deps, env, query_msg);
    match nft_info {
        Ok(brr) => from_binary(&brr),
        Err(_) => Err(StdError::NotFound { kind: "nft".into() }),
    }
}

#[test]
fn test_basic() {
    let mut deps = get_mock_dependencies();
    do_instantiate(deps.as_mut());
}

#[test]
fn test_enroll_and_get_remote_contract() {
    let mut deps = mock_dependencies();
    let env = mock_env();
    let info = mock_info(SENDER, &[]);
    let chain_id = "cosmos".to_string();
    let remote_contract = "wasm1kjd9yyyqx0jwfzzy9ls32vuuyfem38x2lg2y0g".to_string();

    do_instantiate(deps.as_mut());

    set_remote_contract(
        deps.as_mut(),
        env.clone(),
        info,
        chain_id.clone(),
        remote_contract.clone(),
    );
    // Get remote contract
    let extension_msg = QueryMsg::GetRemoteContract { chain_id };
    let query_msg = Cw721QueryMsg::Extension { msg: extension_msg };
    let res = query(deps.as_ref(), env.clone(), query_msg.clone());
    let remote_contract_result: String = from_binary(&res.unwrap()).unwrap();

    // Check if remote contract is set
    assert_eq!(remote_contract_result, remote_contract);
}

#[test]
fn test_mint_nft() {
    let mut deps = mock_dependencies();
    let env = mock_env();
    let info = mock_info(SENDER, &[]);

    do_instantiate(deps.as_mut());

    let mint_msg = MintMsg {
        token_id: "2".into(),
        token_uri: None,
        owner: SENDER.into(),
        extension: Empty {},
    };
    let mint_msg = Cw721ExecuteMsg::Mint(mint_msg);
    let res = execute(deps.as_mut(), env.clone(), info.clone(), mint_msg.clone());
    assert!(res.is_ok());
}

#[test]
fn test_transfer_crosschain() {
    let mut deps = mock_dependencies();
    let env = mock_env();
    let info = mock_info(SENDER, &[]);
    let remote_contract = "wasm1kjd9yyyqx0jwfzzy9ls32vuuyfem38x2lg2y0g".to_string();

    do_instantiate(deps.as_mut());
    set_remote_contract(
        deps.as_mut(),
        env.clone(),
        info.clone(),
        "1".into(),
        remote_contract,
    );

    let mint_msg = MintMsg {
        token_id: "2".into(),
        token_uri: None,
        owner: SENDER.into(),
        extension: Empty {},
    };
    let mint_msg = Cw721ExecuteMsg::Mint(mint_msg);
    let res = execute(deps.as_mut(), env.clone(), info.clone(), mint_msg.clone());
    assert!(res.is_ok());

    let request_metadata: RequestMetaData = RequestMetaData {
        dest_gas_limit: 0,
        ack_gas_limit: 0,
        dest_gas_price: 0,
        ack_gas_price: 0,
        relayer_fee: Uint128::from(0u32),
        ack_type: router_wasm_bindings::types::AckType::AckOnBoth,
        is_read_call: false,
        asm_address: "".into(),
    };
    let response = get_nft_info(deps.as_ref(), env.clone(), "2".into());
    assert!(response.is_ok());

    let respone = get_nft_owner_of(deps.as_ref(), env.clone(), "2".into());
    assert!(response.is_ok());
    assert_eq!(respone.unwrap().owner, SENDER);

    let ext_cc_msg = ExecuteMsg::TransferCrossChain {
        dst_chain_id: "1".into(),
        token_id: 2,
        recipient: "0x1C609537a32630c054202e2B089B9Da268667C5D".to_string(),
        request_metadata,
    };
    let exec_msg = Cw721ExecuteMsg::Extension { msg: ext_cc_msg };
    let res = execute(deps.as_mut(), env.clone(), info.clone(), exec_msg.clone());
    assert!(res.is_ok());

    if let Ok(result) = res {
        let _ok = match result.messages[0].msg.clone() {
            CosmosMsg::Custom(msg) => match msg {
                RouterMsg::CrosschainCall {
                    version: _,
                    route_amount: _,
                    route_recipient: _,
                    request_packet,
                    request_metadata: _,
                    dest_chain_id: _,
                } => {
                    // in order to verify encoded payload
                    // println!("{:?}", hex::encode(request_packet));

                    //Binary(hex::decode(op).unwrap())
                    Ok(Response::<RouterMsg>::new())
                }
            },
            _ => Err(StdError::NotFound {
                kind: "isend".into(),
            }),
        };
    }
    // nft should be burned with id 2
    let response = get_nft_info(deps.as_ref(), env, "2".into());
    assert!(response.is_err());
}

'''
'''--- cosmwasm/packages/new-crosstalk-sample/Cargo.toml ---
[package]
name = "new-crosstalk-sample"
version = "0.1.0"
edition = "2021"
authors = ["Gaurav Agarwal <gaurav@routerprotocol.com>"]
description = "The Cross Chain Samples package"
repository = "https://github.com/router-protocol/new-crosstalk-sample.git"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

exclude = [
  # Those files are rust-optimizer artifacts. You might want to commit them for convenience but they should not be part of the source code publication.
  "contract.wasm",
  "hash.txt",
]

[lib]
crate-type = ["cdylib", "rlib"]

[profile.release]
opt-level = 3
debug = false
rpath = false
lto = true
debug-assertions = false
codegen-units = 1
panic = 'abort'
incremental = false
overflow-checks = true

[features]
backtraces = ["cosmwasm-std/backtraces"]
# use library feature to disable all instanti`ate/execute/query exports
library = []

[dependencies]
cosmwasm-std = "1.0.0"
cw-storage-plus = { version = "0.13.4" }
schemars = "0.8.8"
serde = { version = "1.0.137", default-features = false, features = ["derive"] }
thiserror = { version = "1.0.31" }
cw20 = { version = "0.13.4" }
cw20-base = { version = "0.13.4", features = ["library"] }
cw0 = { version = "0.10.3" }
cw2 = { version = "0.13.2" }
cosmwasm-crypto = "1.0.0"
getrandom = { version = "0.2", features = ["js"] }
hex = "0.4"
arrayref = "0.3.6"
codec = { package = "parity-scale-codec", version = "2.0.0", features = ["derive"] }
cosmwasm-schema = { version = "0.16.0" }
router-wasm-bindings = { version = "0.2.4", default-features = false, features = ["ethabi"] }

[dev-dependencies]

'''
'''--- cosmwasm/packages/new-crosstalk-sample/src/lib.rs ---
pub mod ping_pong;
pub mod test_dapp;
pub mod xerc1155;
pub mod xerc20;
pub mod xerc721;

pub use serde::{Deserialize, Serialize};

'''
'''--- cosmwasm/packages/new-crosstalk-sample/src/ping_pong.rs ---
use crate::{Deserialize, Serialize};
use schemars::JsonSchema;

use cosmwasm_std::Binary;

// Define state for last lottery time and lottery unique limit

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct InstantiateMsg {}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ExecuteMsg {
    IPing {
        ping: String,
        dest_contract_address: String,
        dest_chain_id: String,
        request_metadata: Binary,
    },
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct MigrateMsg {}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum QueryMsg {
    // fetch contract version
    GetContractVersion {},
    FetchPing { chain_id: String, request_id: u64 },
    FetchPong { request_id: u64 },
    FetchRequestId {},
}

'''
'''--- cosmwasm/packages/new-crosstalk-sample/src/test_dapp.rs ---
use crate::{Deserialize, Serialize};
use schemars::JsonSchema;

use cosmwasm_std::{Binary, Uint128};

// Define state for last lottery time and lottery unique limit

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct InstantiateMsg {}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ExecuteMsg {
    SendIRequest {
        payload: Binary,
        dest_contract_address: String,
        dest_chain_id: String,
        request_metadata: Binary,
        amount: Uint128,
        route_recipient: String,
    },
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct MigrateMsg {}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum QueryMsg {
    // fetch contract version
    GetContractVersion {},
    FetchGreetingRecord { chain_id: String, request_id: u64 },
    FetchAckRecord { request_id: u64 },
}

'''
'''--- cosmwasm/packages/new-crosstalk-sample/src/xerc1155.rs ---
use crate::{Deserialize, Serialize};
use cosmwasm_std::{Binary, CustomMsg, StdResult, Uint128};
use router_wasm_bindings::{
    ethabi::{ethereum_types::U256, ParamType, Token},
    types::{ChainType, RequestMetaData},
    utils::{convert_address_from_bytes_to_string, convert_address_from_string_to_bytes},
    Bytes,
};
use schemars::JsonSchema;

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct InstantiateMsg {
    pub minter: String, // fee payer will be contract itself
    pub xerc1155_codeid: u64,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct TransferParams {
    pub nft_ids: Vec<Uint128>,
    pub nft_amounts: Vec<Uint128>,
    pub nft_data: Bytes,
    pub recipient: String,
}

impl TransferParams {
    pub fn get_evm_encoding(&self) -> StdResult<Token> {
        let nft_ids_len = self.nft_ids.clone().len();
        let nft_amounts_len = self.nft_ids.clone().len();
        assert!(nft_ids_len == nft_amounts_len); // both length should be equal

        let mut nft_ids = Vec::<Token>::new();
        for i in 0..nft_ids_len {
            nft_ids.push(Token::Uint(U256::from(Uint128::u128(
                &self.nft_ids.clone()[i],
            ))));
        }
        let nft_ids_array = Token::FixedArray(nft_ids);

        let mut nft_amounts = Vec::<Token>::new();
        for i in 0..nft_amounts_len {
            nft_amounts.push(Token::Uint(U256::from(Uint128::u128(
                &self.nft_amounts.clone()[i],
            ))));
        }
        let nft_amounts_array = Token::FixedArray(nft_amounts);
        let nft_data = Token::Bytes(self.nft_data.clone());
        let recipient = Token::Bytes(self.recipient.clone().into());

        Ok(Token::Tuple(vec![
            nft_ids_array,
            nft_amounts_array,
            nft_data,
            recipient,
        ]))
    }
    pub fn get_params_types() -> ParamType {
        return ParamType::Tuple(vec![
            ParamType::Array(Box::new(ParamType::Uint(256))),
            ParamType::Array(Box::new(ParamType::Uint(256))),
            ParamType::Bytes,
            ParamType::Bytes,
        ]);
    }
    pub fn from_token_tuple(tuple: Vec<Token>) -> StdResult<Self> {
        let nfts_ids_token = tuple[0].clone().into_array().unwrap();
        let mut nft_ids = Vec::<Uint128>::new();
        for i in 0..nfts_ids_token.len() {
            nft_ids.push(Uint128::from(
                nfts_ids_token[i].clone().into_uint().unwrap().as_u128(),
            ));
        }

        let nft_amounts_token = tuple[1].clone().into_array().unwrap();
        let mut nft_amounts = Vec::<Uint128>::new();
        for i in 0..nft_amounts_token.len() {
            nft_amounts.push(Uint128::from(
                nft_amounts_token[i].clone().into_uint().unwrap().as_u128(),
            ));
        }

        let nft_data = tuple[2].clone().into_bytes().unwrap();
        let has_prefix = true;
        let prefix = if has_prefix { "0x" } else { "" };
        let recipient = format!(
            "{}{}",
            prefix,
            tuple[3]
                .clone()
                .into_bytes()
                .unwrap()
                .iter()
                .map(|b| format!("{:02x}", b))
                .collect::<String>()
        );
        Ok(Self {
            nft_data,
            recipient,
            nft_amounts,
            nft_ids,
        })
    }
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ExecuteMsg {
    EnrollRemoteContract {
        chain_id: String,
        remote_address: String,
    },
    SetCw1155ContractAddress {
        address: String,
    },
    TransferCrossChain {
        dst_chain_id: String,
        token_ids: Vec<Uint128>,
        token_amounts: Vec<Uint128>,
        token_data: Binary,
        recipient: String,
        request_metadata: RequestMetaData,
    },
    BatchMint {
        to: String,
        batch: Vec<(String, Uint128)>,
        msg: String,
    },
    Mint {
        to: String,
        token_id: Uint128,
        amount: Uint128,
        msg: String,
    },
}

impl CustomMsg for ExecuteMsg {}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct MigrateMsg {}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum QueryMsg {
    // fetch contract version
    GetContractVersion {},
    GetOwner {},
    GetRemoteContract { chain_id: String },
    GetCw1155Address {},
}

impl CustomMsg for QueryMsg {}

'''
'''--- cosmwasm/packages/new-crosstalk-sample/src/xerc20.rs ---
use crate::{Deserialize, Serialize};
use cosmwasm_std::{Binary, Uint128};
use schemars::JsonSchema;

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct ContractInfo {
    pub chain_id: String,
    pub contract_addr: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct ChainTypeInfo {
    pub chain_id: String,
    pub chain_type: u64,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct InstantiateMsg {
    pub cw20_code_id: u64,
    pub token_name: String,
    pub token_symbol: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ExecuteMsg {
    SetWhiteListedContracts {
        contracts: Vec<ContractInfo>,
    },
    SetChainId {
        id: String,
    },
    SetXerc20Addr {
        addr: String,
    },
    Mint {
        recipient: String,
        amount: Uint128,
    },
    UpdateOwner {
        new_owner: String,
    },
    SetChainTypes {
        chain_type_info: Vec<ChainTypeInfo>,
    },
    TrasferCrossChain {
        amount: Uint128,
        recipient: Binary,
        dest_chain_id: String,
    },
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct MigrateMsg {}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum QueryMsg {
    // fetch contract version
    GetContractVersion {},
    FetchOwner {},
    FetchXerc20 {},
    FetchChainId {},
    FetchChainType { chain_id: String },
    FetchWhiteListedContract { chain_id: String },
    AllWhiteListedContract {},
}

'''
'''--- cosmwasm/packages/new-crosstalk-sample/src/xerc721.rs ---
use crate::{Deserialize, Serialize};
use cosmwasm_std::{CustomMsg, StdResult};
use router_wasm_bindings::{
    ethabi::{ethereum_types::U256, ParamType, Token},
    types::{ChainType, RequestMetaData},
    utils::{convert_address_from_bytes_to_string, convert_address_from_string_to_bytes},
    Bytes,
};
use schemars::JsonSchema;

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct InstantiateMsg {
    pub name: String,
    pub symbol: String,
    pub minter: String, // fee payer will be contract itself
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct TransferParams {
    pub nft_id: u64,
    pub recipient: String,
}

impl TransferParams {
    pub fn get_evm_encoding(&self) -> StdResult<Token> {
        let token_id = Token::Uint(U256::from(self.nft_id.clone()));
        let recipient: Bytes = convert_address_from_string_to_bytes(
            self.recipient.clone(),
            ChainType::ChainTypeEvm.get_chain_code(), //:: this will not always be evm
        )?;

        Ok(Token::Tuple(vec![token_id, Token::Bytes(recipient)]))
    }
    pub fn get_params_types() -> ParamType {
        return ParamType::Tuple(vec![ParamType::Uint(256), ParamType::Bytes]);
    }
    pub fn from_token_tuple(tuple: Vec<Token>) -> StdResult<Self> {
        let nft_id = tuple[0].clone().into_uint().unwrap().as_u64();

        let has_prefix = true;
        let prefix = if has_prefix { "0x" } else { "" };
        let recipient = format!(
            "{}{}",
            prefix,
            tuple[1]
                .clone()
                .into_bytes()
                .unwrap()
                .iter()
                .map(|b| format!("{:02x}", b))
                .collect::<String>()
        );
        Ok(Self { nft_id, recipient })
    }
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ExecuteMsg {
    EnrollRemoteContract {
        chain_id: String,
        remote_address: String,
    },
    TransferCrossChain {
        dst_chain_id: String,
        token_id: u64,
        recipient: String,
        request_metadata: RequestMetaData,
    },
}

impl CustomMsg for ExecuteMsg {}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct MigrateMsg {}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum QueryMsg {
    // fetch contract version
    GetContractVersion {},
    GetOwner {},
    GetRemoteContract { chain_id: String },
}

impl CustomMsg for QueryMsg {}

'''
'''--- cosmwasm/rustfmt.toml ---
# stable
newline_style = "unix"
hard_tabs = false
tab_spaces = 4

# unstable... should we require `rustup run nightly cargo fmt` ?
# or just update the style guide when they are stable?
#fn_single_line = true
#format_code_in_doc_comments = true
#overflow_delimited_expr = true
#reorder_impl_items = true
#struct_field_align_threshold = 20
#struct_lit_single_line = true
#report_todo = "Always"

'''
'''--- cosmwasm/scripts/build.sh ---
#!/bin/bash

# exit when any command fails
set -e

rustup target add wasm32-unknown-unknown
cargo wasm
# building the wasm artifacts

machine_info=$(uname -a)
apple_identifier="arm64"

if echo "$machine_info" | grep -q "$apple_identifier"; then
  echo "Apple-based chipset"
  docker run --rm -v "$(pwd)":/code \
    --mount type=volume,source="$(basename "$(pwd)")_cache",target=/code/target \
    --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \
    cosmwasm/workspace-optimizer-arm64:0.12.13
else
  echo "Intel-based chipset"
  docker run --rm -v "$(pwd)":/code \
    --mount type=volume,source="$(basename "$(pwd)")_cache",target=/code/target \
    --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \
    cosmwasm/workspace-optimizer:0.12.13
fi
echo "wasm build created"

'''
'''--- cosmwasm/tasks/execute_msg.ts ---
import {
  getEndpointsForNetwork,
  PrivateKey,
  privateKeyToPublicKeyBase64,
  ChainRestAuthApi,
  createTransaction,
  BigNumberInBase,
  TxRestClient,
  Network,
  TxGrpcClient,
  TxClientSimulateResponse,
  MsgInstantiateContract,
  MsgExecuteContract,
} from "@routerprotocol/router-chain-sdk-ts";
import dotenv from "dotenv";
import { parseRawLog } from "@cosmjs/stargate/build/logs";
import { logs } from "@cosmjs/stargate";
import { Log } from "@cosmjs/stargate/build/logs";
dotenv.config();

let network = Network.AlphaDevnet;
if (process.env.NETWORK == "devnet") {
  network = Network.Devnet
} else if (process.env.NETWORK == "testnet") {
  network = Network.Testnet
} else if (process.env.NETWORK == "mainnet") {
  network = Network.Mainnet
}
const privateKeyHash = process.env.PRIVATE_KEY;
const chainId = process.env.CHAIN_ID;
if (!chainId) {
  throw new Error("Please set your CHAIN_ID in the .env file");
}

if (!privateKeyHash) {
  throw new Error("Please set your PRIVATE_KEY in the .env file");
}

const endpoint = getEndpointsForNetwork(network);
const privateKey = PrivateKey.fromPrivateKey(privateKeyHash);

const alice = privateKey.toBech32();

const publicKey = privateKeyToPublicKeyBase64(
  Buffer.from(privateKeyHash, "hex")
);

const restClient = new TxRestClient(endpoint.lcdEndpoint);
const grpcClient = new TxGrpcClient(endpoint.grpcEndpoint);

export const exec_msg = async function (contractAddr: string, action: string, message: Object): Promise<readonly logs.Log[]> {
  /** Get Faucet Accounts details */
  const aliceAccount = await new ChainRestAuthApi(
    endpoint.lcdEndpoint
  ).fetchAccount(alice);
  const executeContractMsg = MsgExecuteContract.fromJSON({
    sender: alice,
    action: action,
    contractAddress: contractAddr,
    msg: message
  });

  let simulationResponse: TxClientSimulateResponse;
  {
    let { txRaw } = createTransaction({
      message: executeContractMsg.toDirectSign(),
      memo: "",
      pubKey: publicKey,
      sequence: parseInt(aliceAccount.account.base_account.sequence, 10),
      accountNumber: parseInt(
        aliceAccount.account.base_account.account_number,
        10
      ),
      chainId: chainId,
    });

    txRaw.setSignaturesList([""]);
    simulationResponse = await grpcClient.simulate(txRaw);
  }

  let amount = new BigNumberInBase(500000001)
    .times(
      parseInt(
        (
          simulationResponse.gasInfo.gasUsed * 1.3
        ).toString()
      )
    )
    .toString();
  let gas = parseInt(
    (
      simulationResponse.gasInfo.gasUsed * 1.3
    ).toString()
  ).toString();
  console.log(amount, gas)

  const { signBytes, txRaw } = createTransaction({
    message: executeContractMsg.toDirectSign(),
    memo: "",
    fee: {
      amount: [
        {
          amount: amount,
          denom: "route",
        },
      ],
      gas: gas,
    },
    pubKey: publicKey,
    sequence: parseInt(aliceAccount.account.base_account.sequence, 10),
    accountNumber: parseInt(
      aliceAccount.account.base_account.account_number,
      10
    ),
    chainId: chainId,
  });

  /** Sign transaction */
  const signature = await privateKey.sign(signBytes);

  /** Append Signatures */
  txRaw.setSignaturesList([signature]);

  /** Broadcast transaction */
  let txxResponse = await restClient.broadcast(txRaw);
  let txResponse = await restClient.waitTxBroadcast(txxResponse.txhash);
  const parsedLogs = parseRawLog(txResponse.raw_log)

  return parsedLogs;
}

'''
'''--- cosmwasm/tasks/init_contract.ts ---
import {
    getEndpointsForNetwork,
    PrivateKey,
    privateKeyToPublicKeyBase64,
    ChainRestAuthApi,
    createTransaction,
    BigNumberInBase,
    TxRestClient,
    Network,
    TxGrpcClient,
    TxClientSimulateResponse,
    MsgInstantiateContract,
} from "@routerprotocol/router-chain-sdk-ts";
import dotenv from "dotenv";
import { parseRawLog } from "@cosmjs/stargate/build/logs";
import { logs } from "@cosmjs/stargate";
dotenv.config();

let network = Network.AlphaDevnet;
if (process.env.NETWORK == "devnet") {
    network = Network.Devnet
} else if (process.env.NETWORK == "testnet") {
    network = Network.Testnet
} else if (process.env.NETWORK == "mainnet") {
    network = Network.Mainnet
}
const privateKeyHash = process.env.PRIVATE_KEY;
const chainId = process.env.CHAIN_ID;
if (!chainId) {
    throw new Error("Please set your CHAIN_ID in the .env file");
}

if (!privateKeyHash) {
    throw new Error("Please set your PRIVATE_KEY in the .env file");
}

const endpoint = getEndpointsForNetwork(network);
const privateKey = PrivateKey.fromPrivateKey(privateKeyHash);

const alice = privateKey.toBech32();

const publicKey = privateKeyToPublicKeyBase64(
    Buffer.from(privateKeyHash, "hex")
);

const restClient = new TxRestClient(endpoint.lcdEndpoint);
const grpcClient = new TxGrpcClient(endpoint.grpcEndpoint);

export const init_wasm_code = async function (codeId: string, label: string, instantiateMsg: string): Promise<string> {
    /** Get Faucet Accounts details */
    const aliceAccount = await new ChainRestAuthApi(
        endpoint.lcdEndpoint
    ).fetchAccount(alice);

    const initMsgObject = JSON.parse(instantiateMsg);
    const intantiateContractMsg = MsgInstantiateContract.fromJSON({
        sender: alice,
        admin: alice,
        codeId: parseInt(codeId),
        label: label,
        msg: initMsgObject,
    });
    let simulationResponse: TxClientSimulateResponse;
    {
        let { txRaw } = createTransaction({
            message: intantiateContractMsg.toDirectSign(),
            memo: "",
            pubKey: publicKey,
            sequence: parseInt(aliceAccount.account.base_account.sequence, 10),
            accountNumber: parseInt(
                aliceAccount.account.base_account.account_number,
                10
            ),
            chainId: chainId,
        });

        txRaw.setSignaturesList([""]);
        simulationResponse = await grpcClient.simulate(txRaw);
    }
    let amount = new BigNumberInBase(500000001)
        .times(
            parseInt(
                (
                    simulationResponse.gasInfo.gasUsed * 1.3
                ).toString()
            )
        )
        .toString();
    let gas = parseInt(
        (
            simulationResponse.gasInfo.gasUsed * 1.3
        ).toString()
    ).toString();
    console.log(amount, gas)
    const { signBytes, txRaw } = createTransaction({
        message: intantiateContractMsg.toDirectSign(),
        memo: "",
        fee: {
            amount: [
                {
                    amount: amount,
                    denom: "route",
                },
            ],
            gas: gas,
        },
        pubKey: publicKey,
        sequence: parseInt(aliceAccount.account.base_account.sequence, 10),
        accountNumber: parseInt(
            aliceAccount.account.base_account.account_number,
            10
        ),
        chainId: chainId,
    });

    /** Sign transaction */
    const signature = await privateKey.sign(signBytes);
    /** Append Signatures */
    txRaw.setSignaturesList([signature]);
    /** Broadcast transaction */
    let txxResponse = await restClient.broadcast(txRaw);
    console.log(txxResponse);
    let txResponse = await restClient.waitTxBroadcast(txxResponse.txhash);
    console.log(`txResponse =>`, txResponse);
    const parsedLogs = parseRawLog(txResponse.raw_log)

    const contractAddressAttr =
        typeof parsedLogs === "string"
            ? { value: "null" }
            : logs.findAttribute(parsedLogs, "instantiate", "_contract_address");
    let initInfo = {
        contractAddress: contractAddressAttr.value,
        logs: parsedLogs,
        transactionHash: txxResponse.txhash,
    };
    console.log("store code info", initInfo);
    return contractAddressAttr.value;
}

// if (process.argv.length != 5) {
//     console.log(process.argv);
//     console.error('Expected three argument!');
//   process.exit(1);
// }

// codeId, label, instantiateMsg
// init_wasm_code(process.argv[2], process.argv[3], process.argv[4]);

'''
'''--- cosmwasm/tasks/init_xerc20.ts ---
import fs from "fs";
import dotenv from "dotenv";
import { init_wasm_code } from "./init_contract";
import { upload_wasm_code } from "./upload_wasm";
import { Network, PrivateKey } from "@routerprotocol/router-chain-sdk-ts";
import { exec_msg } from "./execute_msg";
import { query_balance } from "./perform_query";
dotenv.config();

async function main() {
  let network = Network.AlphaDevnet;
  if (process.env.NETWORK == "devnet") {
    network = Network.Devnet
  } else if (process.env.NETWORK == "testnet") {
    network = Network.Testnet
  } else if (process.env.NETWORK == "mainnet") {
    network = Network.Mainnet
  } else if (process.env.NETWORK && process.env.NETWORK != "alpha-devnet") {
    throw new Error("Please set your NETWORK in the .env file");
  }

  const privateKeyHash = process.env.PRIVATE_KEY;
  const chainId = process.env.CHAIN_ID;
  if (!chainId) {
    throw new Error("Please set your CHAIN_ID in the .env file");
  }

  if (!privateKeyHash) {
    throw new Error("Please set your PRIVATE_KEY in the .env file");
  }

  const privateKey = PrivateKey.fromPrivateKey(privateKeyHash);
  const alice = privateKey.toBech32();

  let balance = await query_balance(network, alice);
  if (balance === 0) {
    throw new Error(`Please maintain atleast 1 route balance in your account ${alice}`,);
  }
  const xerc20SetupFilePath = "./deployment/config/xerc20.json";
  const xerc20Setup = JSON.parse(fs.readFileSync(xerc20SetupFilePath, "utf-8"));
  console.log(xerc20Setup)

  // const cw20_token_code_id = await upload_wasm_code(
  //   network,
  //   privateKeyHash,
  //   chainId,
  //   "./cosmwasm/artifacts/cw20_token-aarch64.wasm"
  // );

  // const xerc20CodeId = await upload_wasm_code(
  //   network,
  //   privateKeyHash,
  //   chainId,
  //   "./cosmwasm/artifacts/xerc20-aarch64.wasm"
  // );

  // console.log("cw20_token code id -> ", cw20_token_code_id);
  // console.log("xerc20CodeId code id ->", xerc20CodeId);

  // const xerc20InitMsg = JSON.stringify({
  //   "cw20_code_id": parseInt(cw20_token_code_id),
  //   "token_name": "XERC20",
  //   "token_symbol": "XCW"
  // });
  // const xerc20Addr = await init_wasm_code(xerc20CodeId, "xerc20", xerc20InitMsg);
  // console.log("xerc20Addr", xerc20Addr);

  // let set_chain_types_info = {
  //   "chain_type_info": [
  //     {
  //       "chain_id": "80001",
  //       "chain_type": 1
  //     },
  //     {
  //       "chain_id": "43113",
  //       "chain_type": 1
  //     },
  //     {
  //       "chain_id": "5",
  //       "chain_type": 1
  //     },
  //     {
  //       "chain_id": "97",
  //       "chain_type": 1
  //     },
  //     {
  //       "chain_id": "router_9000-1",
  //       "chain_type": 2
  //     }
  //   ]
  // };

  // await exec_msg(xerc20Addr, "set_chain_types", set_chain_types_info);
  // console.log("admin ->", alice);
  // console.log("xerc20 -> code_id-", xerc20CodeId, "addr-", xerc20Addr);

  let set_white_listed_contracts = {
    contracts: [
      {
        chain_id: "80001",
        contract_addr: "0x3db0994d4591727117f28a29f56dcff09f0ec63b"
      }
    ]
  };

  await exec_msg(xerc20Setup[network]["xerc20"]["addr"], "set_white_listed_contracts", set_white_listed_contracts);
  // 
  // if (!xerc20Setup[network]) {
  //   xerc20Setup[network] = {};
  // }
  // xerc20Setup[network]["xerc20"] = {
  //   "addr": xerc20Addr,
  //   "code_id": xerc20CodeId
  // };
  // xerc20Setup[network]["cw20_token"] = {
  //   "addr": "",
  //   "code_id": cw20_token_code_id
  // };

  // fs.writeFileSync(xerc20SetupFilePath, JSON.stringify(xerc20Setup));
}

main()

'''
'''--- cosmwasm/tasks/perform_query.ts ---
import {
    getEndpointsForNetwork,
    PrivateKey,
    privateKeyToPublicKeyBase64,
    ChainRestAuthApi,
    createTransaction,
    BigNumberInBase,
    TxRestClient,
    Network,
    MsgStoreCode,
    TxGrpcClient,
    TxClientSimulateResponse,
    ChainGrpcWasmApi,
    toUtf8,
    ChainGrpcBankApi,
} from "@routerprotocol/router-chain-sdk-ts";
import fs from "fs";
import dotenv from "dotenv";
import { parseRawLog } from "@cosmjs/stargate/build/logs";
import { logs } from "@cosmjs/stargate";
dotenv.config();

export const query_balance = async function (network: Network, account: string): Promise<number> {
    const endpoint = getEndpointsForNetwork(network);

    const bankClient = new ChainGrpcBankApi(endpoint.grpcEndpoint);

    const routersBalances = await bankClient.fetchBalance({
        accountAddress: account,
        denom: "route",
    });
    const bal = parseInt(routersBalances.amount.slice(0, -18));
    if (Number.isNaN(bal)) {
        return 0;
    }
    return bal;
}

export const perform_query = async function (network: Network, contract: string, msg: Object): Promise<any> {
    const endpoint = getEndpointsForNetwork(network);

    const wasmClient = new ChainGrpcWasmApi(endpoint.grpcEndpoint);
    const queryObject = toUtf8(JSON.stringify(msg));
    const fetchSmartContractStateResult = await wasmClient.fetchSmartContractState(
        contract,
        queryObject
    );
    return fetchSmartContractStateResult;
}

// async function main() {
//     try {
//         const balance = await query_balance(Network.Testnet, "router1z6ralzg5tsznq9s6xmutyeen7evylcj7harhmq");
//         console.log(balance);

//         const pair_info = await perform_query(
//             Network.Testnet,
//             "router1w27ekqvvtzfanfxnkw4jx2f8gdfeqwd3drkee3e64xat6phwjg0s3qz9pv",
//             {
//                 "pool": {}
//             });
//         console.log(JSON.stringify(pair_info));
//     } catch (e) {
//         return Promise.resolve("");
//     }

// }

// main()

'''
'''--- cosmwasm/tasks/scripts/create_pair.ts ---
import fs from "fs";
import dotenv from "dotenv";
import { init_wasm_code } from "./init_contract";
import { upload_wasm_code } from "./upload_wasm";
import { Network, PrivateKey } from "@routerprotocol/router-chain-sdk-ts";
import { exec_msg } from "./execute_msg";
dotenv.config();

export const create_pair = async function (routerSwapFactoryAddr: string, addr1: string, addr2: string, name1: string, name2: string): Promise<(string[])> {
    let network = Network.AlphaDevnet;
    if (process.env.NETWORK == "devnet") {
        network = Network.Devnet
    } else if (process.env.NETWORK == "testnet") {
        network = Network.Testnet
    } else if (process.env.NETWORK == "mainnet") {
        network = Network.Mainnet
    } else if (process.env.NETWORK && process.env.NETWORK != "alpha-devnet") {
        throw new Error("Please set your NETWORK in the .env file");
    }

    const privateKeyHash = process.env.PRIVATE_KEY;
    const chainId = process.env.CHAIN_ID;
    if (!chainId) {
        throw new Error("Please set your CHAIN_ID in the .env file");
    }

    if (!privateKeyHash) {
        throw new Error("Please set your PRIVATE_KEY in the .env file");
    }

    type Token = {
        contract_addr: string;
    }
    type AssetInfo = {
        token: Token;
    }
    type PairConfig = {
        asset_infos: AssetInfo[];
        token_name: string;
        token_symbol: string;
        token_decimal: number;
    };
    const token1: Token = {
        contract_addr: addr1
    }
    const token2: Token = {
        contract_addr: addr2
    }
    const assetInfo1: AssetInfo = {
        token: token1
    }
    const assetInfo2: AssetInfo = {
        token: token2
    }
    const createPairInitMsg: PairConfig = {
    asset_infos: [assetInfo1, assetInfo2],
    token_name: name1 + name2 + "pair",
    token_symbol: name1 + name2 + "pair",
    token_decimal: 18
    };
    console.log(JSON.stringify(createPairInitMsg));
    
    const createPairLogs = await exec_msg(routerSwapFactoryAddr, "create_pair", createPairInitMsg);
    
    let pair_contract_addr: string = "";
    let liquidity_token_addr: string = "";
    for (let i = 0; i < createPairLogs[0].events.length; i++) {
        if (createPairLogs[0].events[i].type == "wasm") {
            const attrs = createPairLogs[0].events[i].attributes;
            for (let j = 0; j < attrs.length; j++) {
                if (attrs[j].key == "pair_contract_addr") {
                    pair_contract_addr = attrs[j].value;
                }
                if (attrs[j].key == "liquidity_token_addr") {
                    liquidity_token_addr = attrs[j].value;
                }
            }
        }
    }

    return [pair_contract_addr, liquidity_token_addr];
}

'''
'''--- cosmwasm/tasks/scripts/execute_msg.ts ---
import {
  getEndpointsForNetwork,
  PrivateKey,
  privateKeyToPublicKeyBase64,
  ChainRestAuthApi,
  createTransaction,
  BigNumberInBase,
  TxRestClient,
  Network,
  TxGrpcClient,
  TxClientSimulateResponse,
  MsgInstantiateContract,
  MsgExecuteContract,
} from "@routerprotocol/router-chain-sdk-ts";
import dotenv from "dotenv";
import { parseRawLog } from "@cosmjs/stargate/build/logs";
import { logs } from "@cosmjs/stargate";
import { Log } from "@cosmjs/stargate/build/logs";
dotenv.config();

let network = Network.AlphaDevnet;
if (process.env.NETWORK == "devnet") {
  network = Network.Devnet
} else if (process.env.NETWORK == "testnet") {
  network = Network.Testnet
} else if (process.env.NETWORK == "mainnet") {
  network = Network.Mainnet
}
const privateKeyHash = process.env.PRIVATE_KEY;
const chainId = process.env.CHAIN_ID;
if (!chainId) {
  throw new Error("Please set your CHAIN_ID in the .env file");
}

if (!privateKeyHash) {
  throw new Error("Please set your PRIVATE_KEY in the .env file");
}

const endpoint = getEndpointsForNetwork(network);
const privateKey = PrivateKey.fromPrivateKey(privateKeyHash);

const alice = privateKey.toBech32();

const publicKey = privateKeyToPublicKeyBase64(
  Buffer.from(privateKeyHash, "hex")
);

const restClient = new TxRestClient(endpoint.lcdEndpoint);
const grpcClient = new TxGrpcClient(endpoint.grpcEndpoint);

export const exec_msg = async function (contractAddr: string, action: string, message: Object): Promise<readonly logs.Log[]> {
  /** Get Faucet Accounts details */
  const aliceAccount = await new ChainRestAuthApi(
    endpoint.lcdEndpoint
  ).fetchAccount(alice);
  const executeContractMsg = MsgExecuteContract.fromJSON({
    sender: alice,
    action: action,
    contractAddress: contractAddr,
    msg: message
  });

  let simulationResponse: TxClientSimulateResponse;
  {
    let { txRaw } = createTransaction({
      message: executeContractMsg.toDirectSign(),
      memo: "",
      pubKey: publicKey,
      sequence: parseInt(aliceAccount.account.base_account.sequence, 10),
      accountNumber: parseInt(
        aliceAccount.account.base_account.account_number,
        10
      ),
      chainId: chainId,
    });

    txRaw.setSignaturesList([""]);
    simulationResponse = await grpcClient.simulate(txRaw);
  }

  let amount = new BigNumberInBase(500000001)
    .times(
      parseInt(
        (
          simulationResponse.gasInfo.gasUsed * 1.3
        ).toString()
      )
    )
    .toString();
  let gas = parseInt(
    (
      simulationResponse.gasInfo.gasUsed * 1.3
    ).toString()
  ).toString();
  console.log(amount, gas)

  const { signBytes, txRaw } = createTransaction({
    message: executeContractMsg.toDirectSign(),
    memo: "",
    fee: {
      amount: [
        {
          amount: amount,
          denom: "route",
        },
      ],
      gas: gas,
    },
    pubKey: publicKey,
    sequence: parseInt(aliceAccount.account.base_account.sequence, 10),
    accountNumber: parseInt(
      aliceAccount.account.base_account.account_number,
      10
    ),
    chainId: chainId,
  });

  /** Sign transaction */
  const signature = await privateKey.sign(signBytes);

  /** Append Signatures */
  txRaw.setSignaturesList([signature]);

  /** Broadcast transaction */
  let txxResponse = await restClient.broadcast(txRaw);
  let txResponse = await restClient.waitTxBroadcast(txxResponse.txhash);
  const parsedLogs = parseRawLog(txResponse.raw_log)

  return parsedLogs;
}

'''
'''--- cosmwasm/tasks/scripts/init_contract.ts ---
import {
    getEndpointsForNetwork,
    PrivateKey,
    privateKeyToPublicKeyBase64,
    ChainRestAuthApi,
    createTransaction,
    BigNumberInBase,
    TxRestClient,
    Network,
    TxGrpcClient,
    TxClientSimulateResponse,
    MsgInstantiateContract,
} from "@routerprotocol/router-chain-sdk-ts";
import dotenv from "dotenv";
import { parseRawLog } from "@cosmjs/stargate/build/logs";
import { logs } from "@cosmjs/stargate";
dotenv.config();

let network = Network.AlphaDevnet;
if (process.env.NETWORK == "devnet") {
    network = Network.Devnet
} else if (process.env.NETWORK == "testnet") {
    network = Network.Testnet
} else if (process.env.NETWORK == "mainnet") {
    network = Network.Mainnet
}
const privateKeyHash = process.env.PRIVATE_KEY;
const chainId = process.env.CHAIN_ID;
if (!chainId) {
    throw new Error("Please set your CHAIN_ID in the .env file");
}

if (!privateKeyHash) {
    throw new Error("Please set your PRIVATE_KEY in the .env file");
}

const endpoint = getEndpointsForNetwork(network);
const privateKey = PrivateKey.fromPrivateKey(privateKeyHash);

const alice = privateKey.toBech32();

const publicKey = privateKeyToPublicKeyBase64(
    Buffer.from(privateKeyHash, "hex")
);

const restClient = new TxRestClient(endpoint.lcdEndpoint);
const grpcClient = new TxGrpcClient(endpoint.grpcEndpoint);

export const init_wasm_code = async function (codeId: string, label: string, instantiateMsg: string): Promise<string> {
    /** Get Faucet Accounts details */
    const aliceAccount = await new ChainRestAuthApi(
        endpoint.lcdEndpoint
    ).fetchAccount(alice);

    const initMsgObject = JSON.parse(instantiateMsg);
    const intantiateContractMsg = MsgInstantiateContract.fromJSON({
        sender: alice,
        admin: alice,
        codeId: parseInt(codeId),
        label: label,
        msg: initMsgObject,
    });
    let simulationResponse: TxClientSimulateResponse;
    {
        let { txRaw } = createTransaction({
            message: intantiateContractMsg.toDirectSign(),
            memo: "",
            pubKey: publicKey,
            sequence: parseInt(aliceAccount.account.base_account.sequence, 10),
            accountNumber: parseInt(
                aliceAccount.account.base_account.account_number,
                10
            ),
            chainId: chainId,
        });

        txRaw.setSignaturesList([""]);
        simulationResponse = await grpcClient.simulate(txRaw);
    }
    let amount = new BigNumberInBase(500000001)
        .times(
            parseInt(
                (
                    simulationResponse.gasInfo.gasUsed * 1.3
                ).toString()
            )
        )
        .toString();
    let gas = parseInt(
        (
            simulationResponse.gasInfo.gasUsed * 1.3
        ).toString()
    ).toString();
    console.log(amount, gas)
    const { signBytes, txRaw } = createTransaction({
        message: intantiateContractMsg.toDirectSign(),
        memo: "",
        fee: {
            amount: [
                {
                    amount: amount,
                    denom: "route",
                },
            ],
            gas: gas,
        },
        pubKey: publicKey,
        sequence: parseInt(aliceAccount.account.base_account.sequence, 10),
        accountNumber: parseInt(
            aliceAccount.account.base_account.account_number,
            10
        ),
        chainId: chainId,
    });

    /** Sign transaction */
    const signature = await privateKey.sign(signBytes);
    /** Append Signatures */
    txRaw.setSignaturesList([signature]);
    /** Broadcast transaction */
    let txxResponse = await restClient.broadcast(txRaw);
    console.log(txxResponse);
    let txResponse = await restClient.waitTxBroadcast(txxResponse.txhash);
    console.log(`txResponse =>`, txResponse);
    const parsedLogs = parseRawLog(txResponse.raw_log)

    const contractAddressAttr =
        typeof parsedLogs === "string"
            ? { value: "null" }
            : logs.findAttribute(parsedLogs, "instantiate", "_contract_address");
    let initInfo = {
        contractAddress: contractAddressAttr.value,
        logs: parsedLogs,
        transactionHash: txxResponse.txhash,
    };
    console.log("store code info", initInfo);
    return contractAddressAttr.value;
}

// if (process.argv.length != 5) {
//     console.log(process.argv);
//     console.error('Expected three argument!');
//   process.exit(1);
// }

// codeId, label, instantiateMsg
// init_wasm_code(process.argv[2], process.argv[3], process.argv[4]);

'''
'''--- cosmwasm/tasks/scripts/migrate.ts ---
import {
    getEndpointsForNetwork,
    PrivateKey,
    privateKeyToPublicKeyBase64,
    ChainRestAuthApi,
    createTransaction,
    BigNumberInBase,
    TxRestClient,
    Network,
    TxGrpcClient,
    TxClientSimulateResponse,
    MsgMigrateContract,
  } from "@routerprotocol/router-chain-sdk-ts";
  import dotenv from "dotenv";
  import { parseRawLog } from "@cosmjs/stargate/build/logs";
  import { logs } from "@cosmjs/stargate";
  dotenv.config();
  
  let network = Network.AlphaDevnet;
  if (process.env.NETWORK == "devnet") {
    network = Network.Devnet
  } else if (process.env.NETWORK == "testnet") {
    network = Network.Testnet
  } else if (process.env.NETWORK == "mainnet") {
    network = Network.Mainnet
  }
  const privateKeyHash = process.env.PRIVATE_KEY;
  const chainId = process.env.CHAIN_ID;
  if (!chainId) {
    throw new Error("Please set your CHAIN_ID in the .env file");
  }
  
  if (!privateKeyHash) {
    throw new Error("Please set your PRIVATE_KEY in the .env file");
  }
  
  const endpoint = getEndpointsForNetwork(network);
  const privateKey = PrivateKey.fromPrivateKey(privateKeyHash);
  
  const alice = privateKey.toBech32();
  
  const publicKey = privateKeyToPublicKeyBase64(
    Buffer.from(privateKeyHash, "hex")
  );
  
  const restClient = new TxRestClient(endpoint.lcdEndpoint);
  const grpcClient = new TxGrpcClient(endpoint.grpcEndpoint);

  export const migrateContract = async function (contractAddr: string, codeId: number, msg: Object): Promise<readonly logs.Log[]> {
    /** Get Faucet Accounts details */
    const aliceAccount = await new ChainRestAuthApi(
      endpoint.lcdEndpoint
    ).fetchAccount(alice);
    const executeContractMsg = MsgMigrateContract.fromJSON({
      senderAddress: alice,
      codeId: codeId,
      contractAddress: contractAddr,
      msg: msg
    });
  
    let simulationResponse: TxClientSimulateResponse;
    {
      let { txRaw } = createTransaction({
        message: executeContractMsg.toDirectSign(),
        memo: "",
        pubKey: publicKey,
        sequence: parseInt(aliceAccount.account.base_account.sequence, 10),
        accountNumber: parseInt(
          aliceAccount.account.base_account.account_number,
          10
        ),
        chainId: chainId,
      });
  
      txRaw.setSignaturesList([""]);
      simulationResponse = await grpcClient.simulate(txRaw);
    }
  
    let amount = new BigNumberInBase(500000001)
      .times(
        parseInt(
          (
            simulationResponse.gasInfo.gasUsed * 1.3
          ).toString()
        )
      )
      .toString();
    let gas = parseInt(
      (
        simulationResponse.gasInfo.gasUsed * 1.3
      ).toString()
    ).toString();
    console.log(amount, gas)
  
    const { signBytes, txRaw } = createTransaction({
      message: executeContractMsg.toDirectSign(),
      memo: "",
      fee: {
        amount: [
          {
            amount: amount,
            denom: "route",
          },
        ],
        gas: gas,
      },
      pubKey: publicKey,
      sequence: parseInt(aliceAccount.account.base_account.sequence, 10),
      accountNumber: parseInt(
        aliceAccount.account.base_account.account_number,
        10
      ),
      chainId: chainId,
    });
  
    /** Sign transaction */
    const signature = await privateKey.sign(signBytes);
  
    /** Append Signatures */
    txRaw.setSignaturesList([signature]);
  
    /** Broadcast transaction */
    let txxResponse = await restClient.broadcast(txRaw);
    let txResponse = await restClient.waitTxBroadcast(txxResponse.txhash);
    const parsedLogs = parseRawLog(txResponse.raw_log)
  
    return parsedLogs;
  }
  
  
'''
'''--- cosmwasm/tasks/scripts/migrate_texchange.ts ---
import fs from "fs";
import dotenv from "dotenv";
import { Network, PrivateKey } from "@routerprotocol/router-chain-sdk-ts";
import { upload_wasm_code } from "./upload_wasm";
import { migrateContract } from "./migrate";

dotenv.config();

async function main() {
    let network = Network.AlphaDevnet;
    if (process.env.NETWORK == "devnet") {
        network = Network.Devnet;
    } else if (process.env.NETWORK == "testnet") {
        network = Network.Testnet;
    } else if (process.env.NETWORK == "mainnet") {
        network = Network.Mainnet;
    } else if (process.env.NETWORK && process.env.NETWORK != "alpha-devnet") {
        throw new Error("Please set your NETWORK in the .env file");
    }

    const privateKeyHash = process.env.PRIVATE_KEY;
    const chainId = process.env.CHAIN_ID;
    if (!chainId) {
        throw new Error("Please set your CHAIN_ID in the .env file");
    }

    if (!privateKeyHash) {
        throw new Error("Please set your PRIVATE_KEY in the .env file");
    }

    const privateKey = PrivateKey.fromPrivateKey(privateKeyHash);
    const alice = privateKey.toBech32();

    const texchangeSetupFilePath = "config/texchange.json";
    const texchangeSetup = JSON.parse(
        fs.readFileSync(texchangeSetupFilePath, "utf-8")
    );

    const texchangeAddr = texchangeSetup[network]["texchange"]["addr"];
    if (!texchangeAddr) {
        throw new Error("Not able to find 'texchangeAddr' in texchange Setup file");
    }

    const texchangeCodeId = await upload_wasm_code(
        network,
        privateKeyHash,
        chainId,
        "../middleware/artifacts/texchange_bridge.wasm"
      );

    let jsonMsg = "{}";
    let msgObject = JSON.parse(jsonMsg);
    await migrateContract(texchangeAddr, parseInt(texchangeCodeId), msgObject);
    console.log("Setting Resources Complete");

}

main();

'''
'''--- cosmwasm/tasks/scripts/provide_liquidity.ts ---
import fs from "fs";
import dotenv from "dotenv";
import { init_wasm_code } from "./init_contract";
import { upload_wasm_code } from "./upload_wasm";
import { Network, PrivateKey } from "@routerprotocol/router-chain-sdk-ts";
import { exec_msg } from "./execute_msg";
import { create_pair } from "./create_pair";
dotenv.config();

type GiveAllowance = {
    spender: string;
    amount: string;
};

async function main() {
    let network = Network.AlphaDevnet;
    if (process.env.NETWORK == "devnet") {
        network = Network.Devnet
    } else if (process.env.NETWORK == "testnet") {
        network = Network.Testnet
    } else if (process.env.NETWORK == "mainnet") {
        network = Network.Mainnet
    } else if (process.env.NETWORK && process.env.NETWORK != "alpha-devnet") {
        throw new Error("Please set your NETWORK in the .env file");
    }

    const privateKeyHash = process.env.PRIVATE_KEY;
    const chainId = process.env.CHAIN_ID;
    if (!chainId) {
        throw new Error("Please set your CHAIN_ID in the .env file");
    }

    if (!privateKeyHash) {
        throw new Error("Please set your PRIVATE_KEY in the .env file");
    }

    const privateKey = PrivateKey.fromPrivateKey(privateKeyHash);
    const alice = privateKey.toBech32();

    const texchangeSetupFilePath = "config/texchange.json";
    const texchangeSetup = JSON.parse(fs.readFileSync(texchangeSetupFilePath, "utf-8"));
    

    const avaxusdcPairAddr = texchangeSetup[network]["avaxusdcPair"]["addr"];
    if (!avaxusdcPairAddr) {
        throw new Error("Not able to find 'avaxusdcPairAddr' in dex Setup file");
    }

    const maticusdcPairAddr = texchangeSetup[network]["maticusdcPair"]["addr"];
    if (!maticusdcPairAddr) {
        throw new Error("Not able to find 'maticusdcPairAddr' in texchange Setup file");
    }

    const wrappedMaticAddr = texchangeSetup[network]["wrappedMatic"]["addr"];
    if (!wrappedMaticAddr) {
        throw new Error("Not able to find 'wrappedMaticAddr' in texchange Setup file");
    }

    const wrappedAvaxAddr = texchangeSetup[network]["wrappedAvax"]["addr"];
    if (!wrappedAvaxAddr) {
        throw new Error("Not able to find 'wrappedAvaxAddr' in texchange Setup file");
    }

    const wrappedUsdcAddr = texchangeSetup[network]["wrappedUsdc"]["addr"];
    if (!wrappedUsdcAddr) {
        throw new Error("Not able to find 'wrappedUsdcAddr' in texchange Setup file");
    }

    let provideLiquidity = {
        "assets":[
            {
                "info": {
                    "token": {
                        "contract_addr": wrappedMaticAddr
                    }
                },
                "amount": "1000000000000000000"
            },
            {
                "info": {
                    "token": {
                        "contract_addr": wrappedUsdcAddr
                    }
                },
                "amount": "500000000000000000"
            }
        ]
    };
    console.log(maticusdcPairAddr, JSON.stringify(provideLiquidity));
    let logs = await exec_msg(maticusdcPairAddr, "provide_liquidity", provideLiquidity);
    console.log(logs);

    provideLiquidity = {
        "assets":[
            {
                "info": {
                    "token": {
                        "contract_addr": wrappedAvaxAddr
                    }
                },
                "amount": "1000000000000000000"
            },
            {
                "info": {
                    "token": {
                        "contract_addr": wrappedUsdcAddr
                    }
                },
                "amount": "500000000000000000"
            }
        ]
    };
    console.log(JSON.stringify(provideLiquidity));
    logs = await exec_msg(avaxusdcPairAddr, "provide_liquidity", provideLiquidity);
    console.log(logs);
}

main()

'''
'''--- cosmwasm/tasks/scripts/set_chain_types.ts ---
import fs from "fs";
import dotenv from "dotenv";
import { exec_msg } from "./execute_msg";
import { Network } from "@routerprotocol/router-chain-sdk-ts";

dotenv.config();

async function main() {
    let network = Network.AlphaDevnet;
    if (process.env.NETWORK == "devnet") {
        network = Network.Devnet;
    } else if (process.env.NETWORK == "testnet") {
        network = Network.Testnet;
    } else if (process.env.NETWORK == "mainnet") {
        network = Network.Mainnet;
    } else if (process.env.NETWORK && process.env.NETWORK != "alpha-devnet") {
        throw new Error("Please set your NETWORK in the .env file");
    }

    const texchangeSetupFilePath = "config/texchange.json";
    const texchangeSetup = JSON.parse(
        fs.readFileSync(texchangeSetupFilePath, "utf-8")
    );

    const texchangeAddr = texchangeSetup[network]["texchange"]["addr"];
    if (!texchangeAddr) {
        throw new Error("Not able to find 'texchangeAddr' in texchange Setup file");
    }

    let set_chain_types_info = {
        "chain_type_info": [
            {
                "chain_id": "80001",
                "chain_type": 1
            },
            {
                "chain_id": "43113",
                "chain_type": 1
            },
            {
                "chain_id": "5",
                "chain_type": 1
            },
            {
                "chain_id": "97",
                "chain_type": 1
            },
            {
                "chain_id": "router_9000-1",
                "chain_type": 2
            }
        ]
    };

    await exec_msg(texchangeAddr, "set_chain_types", set_chain_types_info);
    console.log("Setting Resources Complete");

}

main();

'''
'''--- cosmwasm/tasks/scripts/set_initial_configurations.ts ---
import fs from "fs";
import dotenv from "dotenv";
import { init_wasm_code } from "./init_contract";
import { upload_wasm_code } from "./upload_wasm";
import { Network, PrivateKey } from "@routerprotocol/router-chain-sdk-ts";
import { exec_msg } from "./execute_msg";
import { create_pair } from "./create_pair";
dotenv.config();

type GiveAllowance = {
    spender: string;
    amount: string;
};

async function main() {
    let network = Network.AlphaDevnet;
    if (process.env.NETWORK == "devnet") {
        network = Network.Devnet
    } else if (process.env.NETWORK == "testnet") {
        network = Network.Testnet
    } else if (process.env.NETWORK == "mainnet") {
        network = Network.Mainnet
    } else if (process.env.NETWORK && process.env.NETWORK != "alpha-devnet") {
        throw new Error("Please set your NETWORK in the .env file");
    }

    const dexSetupFilePath = "config/dex.json";
    const texchangeSetupFilePath = "config/texchange.json";
    const dexSetup = JSON.parse(fs.readFileSync(dexSetupFilePath, "utf-8"));
    const texchangeSetup = JSON.parse(fs.readFileSync(texchangeSetupFilePath, "utf-8"));
    console.log(dexSetup)
    console.log(texchangeSetup)

    const routerSwapFactoryAddr = dexSetup[network]["routerSwapFactory"]["addr"];
    if (!routerSwapFactoryAddr) {
        throw new Error("Not able to find 'routerSwapFactoryAddr' in dex Setup file");
    }

    const routerSwapRouterAddr = dexSetup[network]["routerSwapRouter"]["addr"];
    if (!routerSwapRouterAddr) {
        throw new Error("Not able to find 'routerSwapRouterAddr' in dex Setup file");
    }

    const texchangeAddr = texchangeSetup[network]["texchange"]["addr"];
    if (!texchangeAddr) {
        throw new Error("Not able to find 'texchangeAddr' in texchange Setup file");
    }

    const wrappedMaticAddr = texchangeSetup[network]["wrappedMatic"]["addr"];
    if (!wrappedMaticAddr) {
        throw new Error("Not able to find 'wrappedMaticAddr' in texchange Setup file");
    }

    const wrappedAvaxAddr = texchangeSetup[network]["wrappedAvax"]["addr"];
    if (!wrappedAvaxAddr) {
        throw new Error("Not able to find 'wrappedAvaxAddr' in texchange Setup file");
    }

    const wrappedUsdcAddr = texchangeSetup[network]["wrappedUsdc"]["addr"];
    if (!wrappedUsdcAddr) {
        throw new Error("Not able to find 'wrappedUsdcAddr' in texchange Setup file");
    }

    type SetConfig = {
        address: string;
    };
    const setRouteConfig: SetConfig = {
        address: routerSwapRouterAddr,
    };
    
    await exec_msg(texchangeAddr, "set_router_config", setRouteConfig);
    // for (let i = 0; i < logs[0].events.length; i++) {
    //     console.log(logs[0].events[i]);
    // }
    // console.log(logs);

    let pairInfo = await create_pair(routerSwapFactoryAddr, wrappedMaticAddr, wrappedUsdcAddr, "mt", "usd");
    let pair_contract_addr: string = pairInfo[0];
    let liquidity_token_addr: string = pairInfo[1];
    texchangeSetup[network]["maticusdcPair"] = {
        "addr": pair_contract_addr,
        "code_id": ""
    };
    texchangeSetup[network]["maticusdclp"] = {
        "addr": liquidity_token_addr,
        "code_id": ""
    };
    
    let giveAllowance: GiveAllowance = {
        spender: pair_contract_addr,
        amount: "1000000000000000000"
    }
    await exec_msg(wrappedMaticAddr, "increase_allowance", giveAllowance);
    await exec_msg(wrappedUsdcAddr, "increase_allowance", giveAllowance);

    pairInfo = await create_pair(routerSwapFactoryAddr, wrappedAvaxAddr, wrappedUsdcAddr, "avax", "usd");
    pair_contract_addr = pairInfo[0];
    liquidity_token_addr = pairInfo[1];
    texchangeSetup[network]["avaxusdcPair"] = {
        "addr": pair_contract_addr,
        "code_id": ""
    };
    texchangeSetup[network]["avaxusdclp"] = {
        "addr": liquidity_token_addr,
        "code_id": ""
    };
    
    fs.writeFileSync(texchangeSetupFilePath, JSON.stringify(texchangeSetup));

    giveAllowance = {
        spender: pair_contract_addr,
        amount: "1000000000000000000"
    }
    await exec_msg(wrappedAvaxAddr, "increase_allowance", giveAllowance);
    await exec_msg(wrappedUsdcAddr, "increase_allowance", giveAllowance);

}

main()

'''
'''--- cosmwasm/tasks/scripts/setup_evm.ts ---
import fs from "fs";
import dotenv from "dotenv";
import { Network, PrivateKey } from "@routerprotocol/router-chain-sdk-ts";
import { exec_msg } from "./execute_msg";
import { create_pair } from "./create_pair";
dotenv.config();

async function main() {
    let network = Network.AlphaDevnet;
    if (process.env.NETWORK == "devnet") {
        network = Network.Devnet
    } else if (process.env.NETWORK == "testnet") {
        network = Network.Testnet
    } else if (process.env.NETWORK == "mainnet") {
        network = Network.Mainnet
    } else if (process.env.NETWORK && process.env.NETWORK != "alpha-devnet") {
        throw new Error("Please set your NETWORK in the .env file");
    }

    const privateKeyHash = process.env.PRIVATE_KEY;
    const chainId = process.env.CHAIN_ID;
    if (!chainId) {
        throw new Error("Please set your CHAIN_ID in the .env file");
    }

    if (!privateKeyHash) {
        throw new Error("Please set your PRIVATE_KEY in the .env file");
    }

    const privateKey = PrivateKey.fromPrivateKey(privateKeyHash);
    const alice = privateKey.toBech32();

    const texchangeSetupFilePath = "config/texchange.json";
    const texchangeSetup = JSON.parse(fs.readFileSync(texchangeSetupFilePath, "utf-8"));
    
    const texchangeAddr = texchangeSetup[network]["texchange"]["addr"];
    if (!texchangeAddr) {
        throw new Error("Not able to find 'texchangeAddr' in texchange Setup file");
    }

    const wrappedMaticAddr = texchangeSetup[network]["wrappedMatic"]["addr"];
    if (!wrappedMaticAddr) {
        throw new Error("Not able to find 'wrappedMaticAddr' in texchange Setup file");
    }

    const wrappedAvaxAddr = texchangeSetup[network]["wrappedAvax"]["addr"];
    if (!wrappedAvaxAddr) {
        throw new Error("Not able to find 'wrappedAvaxAddr' in texchange Setup file");
    }

    const wrappedUsdcAddr = texchangeSetup[network]["wrappedUsdc"]["addr"];
    if (!wrappedUsdcAddr) {
        throw new Error("Not able to find 'wrappedUsdcAddr' in texchange Setup file");
    }

    let white_list_application_contract = {
        "chain_id": "80001",
        "chain_type": 1,
        "contract_address": "0xADA64Be2bC3C899Aa4791b7CDba82b910eC639D9"
    };
    let logs = await exec_msg(texchangeAddr, "white_list_application_contract", white_list_application_contract);
    console.log(logs);

    white_list_application_contract = {
        "chain_id": "43113",
        "chain_type": 1,
        "contract_address": "0xC305D1430BCb54388948f0cA1d5138f83DC7d97D"
    };
    logs = await exec_msg(texchangeAddr, "white_list_application_contract", white_list_application_contract);
    console.log(logs);
    
    let setSyntheticToken = {
        "contract_address": "0xC305D1430BCb54388948f0cA1d5138f83DC7d97D",
        "erc20_address": wrappedAvaxAddr,
        "dest_chain_id": "43113",
        "dest_chain_type": 1
    };
    logs = await exec_msg(texchangeAddr, "set_synthetic_token", setSyntheticToken);
    console.log(logs);

    setSyntheticToken = {
        "contract_address": "0xADA64Be2bC3C899Aa4791b7CDba82b910eC639D9",
        "erc20_address": wrappedUsdcAddr,
        "dest_chain_id": "80001",
        "dest_chain_type": 1
    };
    logs = await exec_msg(texchangeAddr, "set_synthetic_token", setSyntheticToken);
    console.log(logs);
    
}

main()

'''
'''--- cosmwasm/tasks/scripts/setup_texchange.sh ---
echo "current directory"
echo $PWD

cd ../../routerswap/deployment
echo "current directory"
echo $PWD

npx ts-node scripts/init_dex.ts 

cd -
echo "current directory"
echo $PWD

echo "copying the dex.json file"
cp ../../routerswap/deployment/config/dex.json config

npx ts-node scripts/init_texchange.ts 
npx ts-node scripts/set_initial_configurations.ts
npx ts-node scripts/provide_liquidity.ts

'''
'''--- cosmwasm/tasks/scripts/upload_wasm.ts ---
import {
    getEndpointsForNetwork,
    PrivateKey,
    privateKeyToPublicKeyBase64,
    ChainRestAuthApi,
    createTransaction,
    BigNumberInBase,
    TxRestClient,
    Network,
    MsgStoreCode,
    TxGrpcClient,
    TxClientSimulateResponse,
} from "@routerprotocol/router-chain-sdk-ts";
import fs from "fs";
import dotenv from "dotenv";
import { parseRawLog } from "@cosmjs/stargate/build/logs";
import { logs } from "@cosmjs/stargate";
dotenv.config();

export const upload_wasm_code = async function (network: Network, privateKeyHash: string, chainId: string, wasmFilePath: string): Promise<string> {
    const endpoint = getEndpointsForNetwork(network);

    const privateKey = PrivateKey.fromPrivateKey(privateKeyHash);

    const alice = privateKey.toBech32();

    const publicKey = privateKeyToPublicKeyBase64(
        Buffer.from(privateKeyHash, "hex")
    );

    const restClient = new TxRestClient(endpoint.lcdEndpoint);
    const grpcClient = new TxGrpcClient(endpoint.grpcEndpoint);
    /** Get Faucet Accounts details */
    const aliceAccount = await new ChainRestAuthApi(
        endpoint.lcdEndpoint
    ).fetchAccount(alice);
    const wasmFile = fs.readFileSync(wasmFilePath);

    const storeCodeMsg = MsgStoreCode.fromJSON({
        sender: alice,
        wasm: wasmFile,
    });
    let simulationResponse: TxClientSimulateResponse;
    {
        let { txRaw } = createTransaction({
            message: storeCodeMsg.toDirectSign(),
            memo: "",
            pubKey: publicKey,
            sequence: parseInt(aliceAccount.account.base_account.sequence, 10),
            accountNumber: parseInt(
                aliceAccount.account.base_account.account_number,
                10
            ),
            chainId: chainId,
        });

        txRaw.setSignaturesList([""]);
        simulationResponse = await grpcClient.simulate(txRaw);
    }
    let amount = new BigNumberInBase(500000001)
        .times(
            parseInt(
                (
                    simulationResponse.gasInfo.gasUsed * 1.3
                ).toString()
            )
        )
        .toString();
    let gas = parseInt(
        (
            simulationResponse.gasInfo.gasUsed * 1.3
        ).toString()
    ).toString();
    console.log(amount, gas)
    const { signBytes, txRaw } = createTransaction({
        message: storeCodeMsg.toDirectSign(),
        memo: "",
        fee: {
            amount: [
                {
                    amount: amount,
                    denom: "route",
                },
            ],
            gas: gas,
        },
        pubKey: publicKey,
        sequence: parseInt(aliceAccount.account.base_account.sequence, 10),
        accountNumber: parseInt(
            aliceAccount.account.base_account.account_number,
            10
        ),
        chainId: chainId,
    });

    /** Sign transaction */
    const signature = await privateKey.sign(signBytes);
    /** Append Signatures */
    txRaw.setSignaturesList([signature]);
    /** Broadcast transaction */
    let txxResponse = await restClient.broadcast(txRaw);
    console.log(txxResponse);
    let txResponse = await restClient.waitTxBroadcast(txxResponse.txhash);
    console.log(`txResponse =>`, txResponse);
    const parsedLogs = parseRawLog(txResponse.raw_log)

    const codeIdAttr =
        typeof parsedLogs === "string"
            ? { value: "null" }
            : logs.findAttribute(parsedLogs, "store_code", "code_id");

    console.log("store code info", codeIdAttr);
    return codeIdAttr.value;
}

'''
'''--- cosmwasm/tasks/upload_wasm.ts ---
import {
    getEndpointsForNetwork,
    PrivateKey,
    privateKeyToPublicKeyBase64,
    ChainRestAuthApi,
    createTransaction,
    BigNumberInBase,
    TxRestClient,
    Network,
    MsgStoreCode,
    TxGrpcClient,
    TxClientSimulateResponse,
} from "@routerprotocol/router-chain-sdk-ts";
import fs from "fs";
import dotenv from "dotenv";
import { parseRawLog } from "@cosmjs/stargate/build/logs";
import { logs } from "@cosmjs/stargate";
dotenv.config();

export const upload_wasm_code = async function (network: Network, privateKeyHash: string, chainId: string, wasmFilePath: string): Promise<string> {
    const endpoint = getEndpointsForNetwork(network);

    const privateKey = PrivateKey.fromPrivateKey(privateKeyHash);

    const alice = privateKey.toBech32();

    const publicKey = privateKeyToPublicKeyBase64(
        Buffer.from(privateKeyHash, "hex")
    );

    const restClient = new TxRestClient(endpoint.lcdEndpoint);
    const grpcClient = new TxGrpcClient(endpoint.grpcEndpoint);
    /** Get Faucet Accounts details */
    const aliceAccount = await new ChainRestAuthApi(
        endpoint.lcdEndpoint
    ).fetchAccount(alice);
    const wasmFile = fs.readFileSync(wasmFilePath);

    const storeCodeMsg = MsgStoreCode.fromJSON({
        sender: alice,
        wasm: wasmFile,
    });
    let simulationResponse: TxClientSimulateResponse;
    {
        let { txRaw } = createTransaction({
            message: storeCodeMsg.toDirectSign(),
            memo: "",
            pubKey: publicKey,
            sequence: parseInt(aliceAccount.account.base_account.sequence, 10),
            accountNumber: parseInt(
                aliceAccount.account.base_account.account_number,
                10
            ),
            chainId: chainId,
        });

        txRaw.setSignaturesList([""]);
        simulationResponse = await grpcClient.simulate(txRaw);
    }
    let amount = new BigNumberInBase(500000001)
        .times(
            parseInt(
                (
                    simulationResponse.gasInfo.gasUsed * 1.3
                ).toString()
            )
        )
        .toString();
    let gas = parseInt(
        (
            simulationResponse.gasInfo.gasUsed * 1.3
        ).toString()
    ).toString();
    console.log(amount, gas)
    const { signBytes, txRaw } = createTransaction({
        message: storeCodeMsg.toDirectSign(),
        memo: "",
        fee: {
            amount: [
                {
                    amount: amount,
                    denom: "route",
                },
            ],
            gas: gas,
        },
        pubKey: publicKey,
        sequence: parseInt(aliceAccount.account.base_account.sequence, 10),
        accountNumber: parseInt(
            aliceAccount.account.base_account.account_number,
            10
        ),
        chainId: chainId,
    });

    /** Sign transaction */
    const signature = await privateKey.sign(signBytes);
    /** Append Signatures */
    txRaw.setSignaturesList([signature]);
    /** Broadcast transaction */
    let txxResponse = await restClient.broadcast(txRaw);
    console.log(txxResponse);
    let txResponse = await restClient.waitTxBroadcast(txxResponse.txhash);
    console.log(`txResponse =>`, txResponse);
    const parsedLogs = parseRawLog(txResponse.raw_log)

    const codeIdAttr =
        typeof parsedLogs === "string"
            ? { value: "null" }
            : logs.findAttribute(parsedLogs, "store_code", "code_id");

    console.log("store code info", codeIdAttr);
    return codeIdAttr.value;
}

'''
'''--- evm/README.md ---
# Crosstalk Samples

## PING-PONG

Here, we will deploy a cross-chain ping pong smart contract built using the Router CrossTalk. It is a system where we can send a message from the source chain(EVM) to a destination chain(EVM) and receive back the acknowledgement from the destination chain on the source chain. So basically, we will send a ping to the destination chain and receive a pong back to the source chain. For that to work, kindly follow the below mentioned steps for deployment:

1. Compile your contracts by first adding `.env` file and run
   ```shell
   npx hardhat compile
   ```
2. After compilation, check if the gateway addresses and the fee payer address mentioned for the respective chains on which contracts have to be deployed are updated [here](./deployment/deployments.json).
3. We have already added a hardhat task for deployment of ping-pong contract [here](./tasks/deploy/PingPong.ts). Run
   ```shell
   npx hardhat
   ```
   and check if `TASK_DEPLOY_PINGPONG` is listed in the tasks list.
4. You just need to run the following command for respective chain to get your contracts deployed on that chain.
   ```shell
   npx hardhat TASK_DEPLOY_PINGPONG --network <network_name>
   ```
   For example:
   1. If you want to deploy your contract on Polygon mumbai, you just have to run:
   ```shell
   npx hardhat TASK_DEPLOY_PINGPONG --network mumbai
   ```
   2. If you want to deploy your contract on Avalanche Fuji, you just have to run:
   ```shell
   npx hardhat TASK_DEPLOY_PINGPONG --network fuji
   ```
   and likewise.

'''
'''--- evm/deployment/config/xerc20.json ---
{
    "testnet": {
        "xerc20": {
            "addr": "router1ukafgk6555pfxcqn3h3675dxd7jmfu7pxxnkwn5gmhqa7qk9a8msv2aas5",
            "code_id": "52"
        },
        "cw20_token": {
            "addr": "",
            "code_id": "51"
        }
    }
}
'''
'''--- evm/deployment/deployments.json ---
{
  "43113": {
    "gatewayContract": "0x3d9640d8489457e0e553BB89ec16Ffdf36f69Ef7",
    "PingPong": "0xAfBdc279d001498941500C666AFadA2A982BAc3E",
    "feePayerAddress": "0xAb771C0e0C33b8794BdE3a79568D829De399C094"
  },
  "80001": {
    "gatewayContract": "0xa5d3D08BCb456a4E16e475c619621de25822c3d8",
    "PingPong": "0xDC2bCa3a686FAf95C44253834E42A3D8090254eb",
    "feePayerAddress": "0xAb771C0e0C33b8794BdE3a79568D829De399C094"
  }
}

'''
'''--- evm/hardhat.config.ts ---
import { HardhatUserConfig } from "hardhat/config";
import "@nomiclabs/hardhat-waffle";
import "@typechain/hardhat";
import "@openzeppelin/hardhat-upgrades";
import "solidity-coverage";
import { resolve } from "path";
import { config as dotenvConfig } from "dotenv";
import { NetworkUserConfig } from "hardhat/types";
import "@nomiclabs/hardhat-etherscan";
import "./tasks";

dotenvConfig({ path: resolve(__dirname, "./.env") });

const chainIds = {
  ganache: 5777,
  goerli: 5,
  hardhat: 7545,
  kovan: 42,
  mainnet: 1,
  rinkeby: 4,
  bscTestnet: 97,
  bsc: 56,
  ropsten: 3,
  mumbai: 80001,
  avalanche: 43114,
  polygon: 137,
  fuji: 43113,
  arbitrum: 42161,
  arbitrum_rinkeby: 421611,
  fantom_testnet: 4002,
  optimism: 10,
  optimism_kovan: 69,
  fantom: 250,
  harmony: 1666600000,
  cronos: 25,
  aurora: 1313161554,
  kava: 2222,
  stardust: 588,
  moonbeam: 1284,
};

// Ensure that we have all the environment variables we need.
const mnemonic = process.env.PRIVATE_KEY;

if (!mnemonic) {
  throw new Error("Please set your MNEMONIC in a .env file");
}

const infuraApiKey = process.env.INFURA_API_KEY;
if (!infuraApiKey) {
  throw new Error("Please set your INFURA_API_KEY in a .env file");
}

function getChainConfig(network: keyof typeof chainIds): NetworkUserConfig {
  let url = "";
  url = "https://" + network + ".infura.io/v3/" + infuraApiKey;
  if (network == "polygon") {
    url =
      "https://polygon-mainnet.g.alchemy.com/v2/hCz4x1BLpLDP3NoomXivfaqND37qCSgS";
  } else if (network == "mumbai") {
    url = "https://matic-mumbai.chainstacklabs.com";
  } else if (network == "bsc") {
    url = "https://bsc-dataseed.binance.org/";
  } else if (network == "avalanche") {
    url = "https://api.avax.network/ext/bc/C/rpc";
  } else if (network == "arbitrum") {
    //42161
    url =
      "https://arbitrum-mainnet.infura.io/v3/fd9c5dbc69de41048405e7072cda9bf9";
  } else if (network == "optimism") {
    //10
    url = "https://mainnet.optimism.io";
  } else if (network == "fantom") {
    //250
    url = "https://rpc.ankr.com/fantom";
  } else if (network == "mainnet") {
    //1
    url = "https://mainnet.infura.io/v3/0d73cc5bbe184146957a9d00764db99f";
    // console.log(url, process.env.PRIVATE_KEY)
  } else if (network == "harmony") {
    //1
    url = "https://api.harmony.one";
    // console.log(url, process.env.PRIVATE_KEY)
  } else if (network == "aurora") {
    //1
    url = "https://mainnet.aurora.dev";
    // console.log(url, process.env.PRIVATE_KEY)
  } else if (network == "cronos") {
    //1
    url = "https://rpc.artemisone.org/cronos";
    //https://rpc.artemisone.org/cronos
    // console.log(url, process.env.PRIVATE_KEY)
  } else if (network == "kava") {
    //1
    url = "https://evm.kava.io";
    // console.log(url, process.env.PRIVATE_KEY)
  } else if (network == "stardust") {
    //1
    url = "https://stardust.metis.io/?owner=588";
    // console.log(url, process.env.PRIVATE_KEY)
  } else if (network == "moonbeam") {
    //1
    url = "https://moonbeam.api.onfinality.io/public";
    // console.log(url, process.env.PRIVATE_KEY)
  } else if (network == "fuji") {
    //1
    url = "https://api.avax-test.network/ext/bc/C/rpc";
    // console.log(url, process.env.PRIVATE_KEY)
  } else if (network == "goerli") {
    //1
    // url = "https://goerli.infura.io/v3/d19691ef05dc486a820545f387b66efc";
    url = "https://goerli.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161";
    // console.log(url, process.env.PRIVATE_KEY)
  } else if (network == "bscTestnet") {
    url = "https://bsc-testnet.public.blastapi.io";
  }
  return {
    // accounts: {
    //   count: 10,
    //   mnemonic,
    //   path: "m/44'/60'/0'/0",
    //   initialIndex:2,
    // },
    accounts: [`${process.env.PRIVATE_KEY}`],
    chainId: chainIds[network],
    url,
    // gas: 10000000,
    // // gasPrice: network == "bsc" ? 20000000000 : 200000000000,
    // gasPrice: 4500000000,
  };
}

const config = {
  defaultNetwork: "hardhat",
  gasReporter: {
    currency: "USD",
    enabled: process.env.REPORT_GAS ? true : false,
    excludeContracts: [],
    src: "./contracts",
  },
  networks: {
    hardhat: {
      accounts: [
        {
          privateKey:
            "c1367107a89e263a950c3dad299c93f413da3c594f7c92a0295b93836832e765",
          balance: "1000000000000000000000000",
        },
        {
          privateKey:
            "12e497f0b5743c8fae1d46078a8b220057626be62da081835a7de3dc8bdb9d80",
          balance: "1000000000000000000000000",
        },
        {
          privateKey:
            "f4b520a953f8dd09c0913a55228b48280acb1cf48920d680893df5529e2defcb",
          balance: "1000000000000000000000000",
        },
        {
          privateKey:
            "e4fac76eca7722938f19aa88dfa5ca28a42cf7e54897ddcdc50959948746ca2e",
          balance: "1000000000000000000000000",
        },
        {
          privateKey:
            "b57b6c96fb47d10493b5aa0be542a456af15617510512040344d01393a5e8f79",
          balance: "1000000000000000000000000",
        },
        {
          privateKey:
            "17981adb72e83b957c81993ef878f6529fec1385e6bbc25c6b602349d13dc04b",
          balance: "1000000000000000000000000",
        },
      ],
      chainId: chainIds.hardhat,
      mining: {
        auto: true,
        interval: 100,
      },
    },
    ganache1: {
      chainId: 7545,
      url: "https://rc-testnet1.routerprotocol.com/",
      accounts: [mnemonic],
    },
    ganache2: {
      chainId: 6545,
      url: "https://rc-testnet3.routerprotocol.com/",
      accounts: [mnemonic],
    },

    ropsten: {
      saveDeployments: true,
      accounts: {
        initialIndex: 0,
        mnemonic,
        // path: "m/44'/60'/0'/0",
      },
      chainId: chainIds["ropsten"],
      url: "https://ropsten.infura.io/v3/" + infuraApiKey + "",
    },
    rinkeby: {
      saveDeployments: true,
      accounts: {
        initialIndex: 0,
        mnemonic,
        // path: "m/44'/60'/0'/0",
      },
      chainId: chainIds["rinkeby"],
      url: "https://rinkeby.infura.io/v3/" + infuraApiKey + "",
    },
    polygonMumbai: {
      saveDeployments: true,
      accounts: [mnemonic],
      chainId: chainIds["mumbai"],
      url: "https://matic-mumbai.chainstacklabs.com",
    },

    kovan: getChainConfig("kovan"),
    polygon: getChainConfig("polygon"),
    bsc: getChainConfig("bsc"),
    avalanche: getChainConfig("avalanche"),

    arbitrum: getChainConfig("arbitrum"),
    fantom: getChainConfig("fantom"),
    optimism: getChainConfig("optimism"),
    mainnet: getChainConfig("mainnet"),
    harmony: getChainConfig("harmony"),
    aurora: getChainConfig("aurora"),
    cronos: getChainConfig("cronos"),
    kava: getChainConfig("kava"),
    stardust: getChainConfig("stardust"),
    moonbeam: getChainConfig("moonbeam"),
    fuji: getChainConfig("fuji"),
    goerli: getChainConfig("goerli"),
    mumbai: getChainConfig("mumbai"),
    bsctestnet: getChainConfig("bscTestnet"),
  },
  paths: {
    artifacts: "./artifacts",
    cache: "./cache",
    sources: "./contracts",
    tests: "./test",
    // deploy: "./deploy",
    deployments: "./deployments",
    // imports: "./imports",
  },
  solidity: {
    version: "0.8.7",
    settings: {
      evmVersion: "berlin",
      metadata: {
        // Not including the metadata hash
        // https://github.com/paulrberg/solidity-template/issues/31
        bytecodeHash: "none",
      },
      // You should disable the optimizer when debugging
      // https://hardhat.org/hardhat-network/#solidity-optimizer-support
      optimizer: {
        enabled: true,
        runs: 50000,
      },
    },
  },

  typechain: {
    outDir: "typechain",
    target: "ethers-v5",
  },
  namedAccounts: {
    deployer: 0,
  },
  etherscan: {
    apiKey: {
      kovan: process.env.MAINNET_ETHERSCAN_KEY,
      polygonMumbai: process.env.POLYGONSCAN_API_KEY,
      polygon: process.env.POLYGONSCAN_API_KEY,
      bsc: process.env.BSC_ETHERSCAN_KEY,
      avalanche: "QAE2JD7XIBCYB6Z6GSKNJIHKZ8XGVYM8AI",
      opera: process.env.FTMSCAN_KEY,
      arbitrumOne: process.env.ARBITRUM_KEY,
      optimisticEthereum: process.env.OPTIMISM_KEY,
      mainnet: process.env.ETH_ETHERSCAN_KEY,
      aurora: process.env.AURORA_KEY,
      harmony: process.env.HARMONY_KEY,
      moonbeam: process.env.MOONBEAM_ETHERSCAN_KEY,
      kava: process.env.MOONBEAM_ETHERSCAN_KEY,
      goerli: process.env.ETHERSCAN_API_KEY,
      avalancheFujiTestnet: "QAE2JD7XIBCYB6Z6GSKNJIHKZ8XGVYM8AI",
      bscTestnet: process.env.BSCSCAN_API_KEY
    },

    customChains: [
      {
        network: "cronos",
        chainId: 25,
        urls: {
          apiURL: "https://api.cronoscan.com/api",
          browserURL: "https://cronoscan.com/",
        },
      },
      {
        network: "kava",
        chainId: 2222,
        urls: {
          apiURL: "https://explorer.kava.io/api",
          browserURL: "https://explorer.kava.io/",
        },
      },
      {
        network: "moonbeam",
        chainId: 1284,
        urls: {
          apiURL: "https://api-moonbeam.moonscan.io/api/",
          browserURL: "https://moonscan.io/",
        },
      },
    ],
  },
};

export default config;

'''
'''--- evm/package-lock.json ---
{
  "name": "hardhat-project",
  "lockfileVersion": 2,
  "requires": true,
  "packages": {
    "": {
      "name": "hardhat-project",
      "dependencies": {
        "@openzeppelin/contracts": "^4.8.0",
        "evm-gateway-contract": "^1.0.3"
      }
    },
    "node_modules/@openzeppelin/contracts": {
      "version": "4.8.0",
      "resolved": "https://registry.npmjs.org/@openzeppelin/contracts/-/contracts-4.8.0.tgz",
      "integrity": "sha512-AGuwhRRL+NaKx73WKRNzeCxOCOCxpaqF+kp8TJ89QzAipSwZy/NoflkWaL9bywXFRhIzXt8j38sfF7KBKCPWLw=="
    },
    "node_modules/@openzeppelin/contracts-upgradeable": {
      "version": "4.8.0",
      "resolved": "https://registry.npmjs.org/@openzeppelin/contracts-upgradeable/-/contracts-upgradeable-4.8.0.tgz",
      "integrity": "sha512-5GeFgqMiDlqGT8EdORadp1ntGF0qzWZLmEY7Wbp/yVhN7/B3NNzCxujuI77ktlyG81N3CUZP8cZe3ZAQ/cW10w=="
    },
    "node_modules/evm-gateway-contract": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/evm-gateway-contract/-/evm-gateway-contract-1.0.3.tgz",
      "integrity": "sha512-pKwwlb5/nAmaFUyNuGpxtRvOfqY/NQGuD8E6wvo0SKWGRiDFHofxevAWlwVEJv+7ilrrX6OpsEZ7LoE/xtN2nQ==",
      "dependencies": {
        "@openzeppelin/contracts": "^4.4.1",
        "@openzeppelin/contracts-upgradeable": "^4.7.3",
        "evm-gateway-contract": "1.0.1"
      }
    },
    "node_modules/evm-gateway-contract/node_modules/evm-gateway-contract": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/evm-gateway-contract/-/evm-gateway-contract-1.0.1.tgz",
      "integrity": "sha512-VV5xdRr6NZ6jGE5N8fFxtL6n7RfEawqyb5QHSjZFJjyKPStvaqpHJU/b80uqoyYxfu6kUgJLN+ZaBCU1rFhGAg==",
      "dependencies": {
        "@openzeppelin/contracts": "^4.4.1",
        "@openzeppelin/contracts-upgradeable": "^4.7.3"
      }
    }
  },
  "dependencies": {
    "@openzeppelin/contracts": {
      "version": "4.8.0",
      "resolved": "https://registry.npmjs.org/@openzeppelin/contracts/-/contracts-4.8.0.tgz",
      "integrity": "sha512-AGuwhRRL+NaKx73WKRNzeCxOCOCxpaqF+kp8TJ89QzAipSwZy/NoflkWaL9bywXFRhIzXt8j38sfF7KBKCPWLw=="
    },
    "@openzeppelin/contracts-upgradeable": {
      "version": "4.8.0",
      "resolved": "https://registry.npmjs.org/@openzeppelin/contracts-upgradeable/-/contracts-upgradeable-4.8.0.tgz",
      "integrity": "sha512-5GeFgqMiDlqGT8EdORadp1ntGF0qzWZLmEY7Wbp/yVhN7/B3NNzCxujuI77ktlyG81N3CUZP8cZe3ZAQ/cW10w=="
    },
    "evm-gateway-contract": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/evm-gateway-contract/-/evm-gateway-contract-1.0.3.tgz",
      "integrity": "sha512-pKwwlb5/nAmaFUyNuGpxtRvOfqY/NQGuD8E6wvo0SKWGRiDFHofxevAWlwVEJv+7ilrrX6OpsEZ7LoE/xtN2nQ==",
      "requires": {
        "@openzeppelin/contracts": "^4.4.1",
        "@openzeppelin/contracts-upgradeable": "^4.7.3",
        "evm-gateway-contract": "1.0.1"
      },
      "dependencies": {
        "evm-gateway-contract": {
          "version": "1.0.1",
          "resolved": "https://registry.npmjs.org/evm-gateway-contract/-/evm-gateway-contract-1.0.1.tgz",
          "integrity": "sha512-VV5xdRr6NZ6jGE5N8fFxtL6n7RfEawqyb5QHSjZFJjyKPStvaqpHJU/b80uqoyYxfu6kUgJLN+ZaBCU1rFhGAg==",
          "requires": {
            "@openzeppelin/contracts": "^4.4.1",
            "@openzeppelin/contracts-upgradeable": "^4.7.3"
          }
        }
      }
    }
  }
}

'''
'''--- evm/package.json ---
{
  "name": "hardhat-project",
  "scripts": {
    "compile": "hardhat compile",
    "clean": "hardhat clean"
  },
  "devDependencies": {
    "@codechecks/client": "^0.1.11",
    "@commitlint/cli": "^13.1.0",
    "@commitlint/config-conventional": "^13.1.0",
    "@ethersproject/abi": "^5.4.0",
    "@ethersproject/abstract-signer": "^5.4.1",
    "@ethersproject/bignumber": "^5.4.1",
    "@ethersproject/bytes": "^5.4.0",
    "@ethersproject/providers": "^5.4.3",
    "@nomiclabs/hardhat-ethers": "^2.0.2",
    "@nomiclabs/hardhat-etherscan": "3.1.0",
    "@nomiclabs/hardhat-waffle": "^2.0.1",
    "@openzeppelin/hardhat-upgrades": "^1.20.0",
    "@routerprotocol/router-chain-sdk-ts": "^0.8.26",
    "@typechain/ethers-v5": "^7.0.1",
    "@typechain/hardhat": "^2.3.0",
    "@types/chai": "^4.2.21",
    "@types/fs-extra": "^9.0.12",
    "@types/lodash": "^4.14.186",
    "@types/mocha": "^9.0.0",
    "@types/node": "^16.18.23",
    "@typescript-eslint/eslint-plugin": "^4.29.0",
    "@typescript-eslint/parser": "^4.29.0",
    "chai": "^4.3.4",
    "commitizen": "^4.2.4",
    "cross-env": "^7.0.3",
    "cz-conventional-changelog": "^3.3.0",
    "dotenv": "^16.0.3",
    "eslint": "^7.32.0",
    "eslint-config-prettier": "^8.3.0",
    "ethereum-waffle": "^3.4.4",
    "ethers": "^5.7.2",
    "fs-extra": "^10.1.0",
    "hardhat": "^2.12.2",
    "hardhat-gas-reporter": "^1.0.4",
    "lint-staged": "^11.1.2",
    "lodash": "^4.17.21",
    "mocha": "^9.0.3",
    "pako": "^2.1.0",
    "prettier": "^2.7.1",
    "prettier-plugin-solidity": "^1.0.0-beta.24",
    "shelljs": "^0.8.4",
    "solc": "^0.8.16",
    "solhint": "^3.3.6",
    "solhint-plugin-prettier": "^0.0.5",
    "solidity-coverage": "^0.7.16",
    "ts-generator": "^0.1.1",
    "ts-node": "^10.1.0",
    "typechain": "^5.1.2",
    "typescript": "^4.3.5"
  },
  "dependencies": {
    "@openzeppelin/contracts": "^4.8.0",
    "@openzeppelin/contracts-upgradeable": "^4.8.3",
    "@routerprotocol/evm-gateway-contracts": "1.1.11",
    "@routerprotocol/router-crosstalk-utils": "^1.0.6",
    "hardhat-deploy-ethers": "^0.3.0-beta.13"
  }
}

'''
'''--- evm/tasks/deploy/DeployOnEachChain.ts ---
import { task } from "hardhat/config";
import { TaskArguments } from "hardhat/types";
import { ethers } from "ethers";
import { ChainType, ReturnType } from "../../utils/types";
import {
  getChainDeployment,
  getPrevDeployment,
  getSignerFromPrivateKeyOrMnemonic,
  isPreviousDeployed,
} from "../../utils/utils";
import { getChainId } from "../../utils/chain";
import { deployOnEachChains } from "../../utils/OnEachChain";
import { DeploymentArg } from "../../utils/OnEachChain";
import { log } from "console";

// Create a new provider using the custom network configuration
let hre: any;
async function deployOnSingleChain(
  signer: ethers.Signer,
  deploymentArg: DeploymentArg,
  chainInfo: ChainType
): Promise<ReturnType> {
  const hre = require("hardhat");
  const provider = signer.provider;
  if (!provider) throw new Error("signer provider is undefined");

  hre.provider = provider;
  hre.network.provider = provider;
  const { ethers } = hre;

  if (!deploymentArg.feePayer) {
    deploymentArg.feePayer = (
      await getChainDeployment(chainInfo.chainId)
    )?.feePayer;
  }

  if (!deploymentArg.feePayer) throw new Error("Feepayer is undefined");

  let deploymentData: { [name: string]: string } = {};

  for (const contract of deploymentArg.contractlist) {
    console.log(`Deploying ${contract}...`);
    // can be PingPong or XERC1155
    const Contract = await (
      await ethers.getContractFactory(contract)
    ).connect(signer);

    const contract_instance =
      contract == "PingPong"
        ? await Contract.deploy(
          chainInfo.gateway,
          1000000,
          1000000,
          deploymentArg.feePayer
        )
        : await Contract.deploy(
          "uri",
          chainInfo.gateway,
          1000000,
          deploymentArg.feePayer
        );

    await contract_instance.deployed();
    deploymentData[contract] = contract_instance.address;
    console.log(
      `Deployed ${contract} successfully with address ${contract_instance.address}`
    );
  }
  return deploymentData;
}

task("DEPLOY_ONEACH", "deploy contracts on provided chains")
  .addParam("chainlist", "Description of chainlist parameter")
  .addOptionalParam("contractlist", "pass list of contract to be deployed")
  .addOptionalParam("feepayer", "pass same feepayer for each deployment")
  .addOptionalParam(
    "pkm",
    "Description of private key or mnemonic as parameter"
  )
  .setAction(async (taskArgs: TaskArguments, hre: any) => {
    const { chainlist, pkm, feepayer, contractlist } = taskArgs;
    let signer;
    if (pkm) signer = getSignerFromPrivateKeyOrMnemonic(pkm);
    else {
      // load from env
      const morp = process.env.MNEMONIC || process.env.PRIVATE_KEY;
      if (!morp) throw new Error("Provide mnemonic or private key");
      signer = getSignerFromPrivateKeyOrMnemonic(morp);
    }
    const chainList: string[] = Array.from(
      new Set(chainlist.trim().split(" "))
    );
    const contractList: string[] = contractlist
      ? Array.from(new Set(contractlist.trim().split(" ")))
      : [];
    if (!contractList.length) contractList.push("PingPong"); // default config

    chainList.map((chain: string) => {
      if (!getChainId(chain)) throw new Error("invalid chain provided");
    });
    await deployOnEachChains(
      deployOnSingleChain,
      { chainList, feePayer: feepayer, contractlist: contractList },
      signer
    );

    let args: {
      chainlist: string;
      contractlist: string;
      pkm?: string;
      enrollwith?: string;
    } = {
      chainlist,
      contractlist,
    };
    if (pkm)
      args = {
        ...args,
        pkm,
      };

    console.log();
    const prevDeployment = await getPrevDeployment();
    if (Object.keys(prevDeployment).length) {
      let enrollwith = "";
      Object.keys(prevDeployment).map((key) => (enrollwith += `${key} `));
      args = {
        ...args,
        enrollwith,
      };
      await hre.run("ENROLLADDED_ONEACH", args);
    } else {
      await hre.run("ENROLL_ONEACH", args);
    }
  });
'''
'''--- evm/tasks/deploy/PingPong.ts ---
import { task, types } from "hardhat/config";
import { TaskArguments } from "hardhat/types";

task("TASK_DEPLOY_PINGPONG").setAction(async function (
  _taskArguments: TaskArguments,
  hre
) {
  const network = await hre.ethers.provider.getNetwork();
  const chainId = network.chainId;

  const deployments = require("../../deployment/deployments.json");

  const gatewayContract = deployments[chainId].gatewayContract;
  const feePayerAddress = deployments[chainId].feePayerAddress;
  const deployContract = "PingPong";

  console.log("Contract Deployment Started ");
  const PingPong = await hre.ethers.getContractFactory("PingPong");
  const pingPong = await PingPong.deploy(gatewayContract, feePayerAddress);

  await pingPong.deployed();

  console.log(deployContract + " Contract deployed to: ", pingPong.address);
  console.log("Contract Deployment Ended");

  await hre.run("TASK_STORE_DEPLOYMENTS", {
    contractName: deployContract,
    contractAddress: pingPong.address,
    chainID: chainId.toString(),
  });
  return null;
});

'''
'''--- evm/tasks/deploy/XERC1155.ts ---
import { task, types } from "hardhat/config";
import { TaskArguments } from "hardhat/types";

task("TASK_DEPLOY_XERC1155").setAction(async function (
  _taskArguments: TaskArguments,
  hre
) {
  const network = await hre.ethers.provider.getNetwork();
  const chainId = network.chainId;

  const deployments = require("../../deployment/deployments.json");

  const gatewayContract = deployments[chainId].gatewayContract;
  const feePayerAddress = deployments[chainId].feePayerAddress;
  const deployContract = "XERC1155";

  console.log("Contract Deployment Started ");
  const Erc1155 = await hre.ethers.getContractFactory("XERC1155");
  const erc1155 = await Erc1155.deploy("uri", gatewayContract, feePayerAddress);
  await erc1155.deployed();

  console.log(deployContract + " Contract deployed to: ", erc1155.address);
  console.log("Contract Deployment Ended");

  await hre.run("TASK_STORE_DEPLOYMENTS", {
    contractName: deployContract,
    contractAddress: erc1155.address,
    chainID: chainId.toString(),
  });
  return null;
});

'''
'''--- evm/tasks/deploy/XERC20.ts ---
import { task, types } from "hardhat/config";
import { TaskArguments } from "hardhat/types";

task("TASK_DEPLOY_XERC20").setAction(async function (
  _taskArguments: TaskArguments,
  hre
) {
  const network = await hre.ethers.provider.getNetwork();
  const chainId = network.chainId;

  const deployments = require("../../deployment/deployments.json");

  const gatewayContract = deployments[chainId].gatewayContract;
  const feePayerAddress = deployments[chainId].feePayerAddress;

  const deployContract = "XERC20";

  console.log("Contract Deployment Started ");
  const Erc20 = await hre.ethers.getContractFactory("XERC20");
  const erc20 = await Erc20.deploy(
    "XERC20",
    "XERC20",
    gatewayContract,
    feePayerAddress
  );
  await erc20.deployed();

  console.log(deployContract + " Contract deployed to: ", erc20.address);
  console.log("Contract Deployment Ended");

  await hre.run("TASK_STORE_DEPLOYMENTS", {
    contractName: deployContract,
    contractAddress: erc20.address,
    chainID: chainId.toString(),
  });
  return null;
});

'''
'''--- evm/tasks/deploy/XERC721.ts ---
import { task, types } from "hardhat/config";
import { TaskArguments } from "hardhat/types";

task("TASK_DEPLOY_XERC721").setAction(async function (
  _taskArguments: TaskArguments,
  hre
) {
  const network = await hre.ethers.provider.getNetwork();
  const chainId = network.chainId;

  const deployments = require("../../deployment/deployments.json");

  const gatewayContract = deployments[chainId].gatewayContract;
  const feePayerAddress = deployments[chainId].feePayerAddress;

  const deployContract = "XERC721";

  console.log("Contract Deployment Started ");
  const Erc721 = await hre.ethers.getContractFactory("XERC721");
  const erc721 = await Erc721.deploy(gatewayContract, feePayerAddress);
  await erc721.deployed();

  console.log(deployContract + " Contract deployed to: ", erc721.address);
  console.log("Contract Deployment Ended");

  await hre.run("TASK_STORE_DEPLOYMENTS", {
    contractName: deployContract,
    contractAddress: erc721.address,
    chainID: chainId.toString(),
  });
  return null;
});

'''
'''--- evm/tasks/enroll_added_chain.ts ---
import { task } from "hardhat/config";
import { TaskArguments } from "hardhat/types";
import { ethers, providers } from "ethers";
import { ChainType } from "./../utils/types";
import { getSignerFromPrivateKeyOrMnemonic } from "../utils/utils";
import { getChainId, getChainInfo, getUChainList } from "../utils/chain";
import { Args, enrollForEachChains } from "../utils/OnEachChain";
import { enrollOnSingleChain as enrollAOnSingleChain } from "./enroll_on_chain";

async function enrollOnSingleChain(
    signer: ethers.Signer,
    chain: ChainType,
    args: Args, // chainlist entered by user
    enrollWith: string[]
) {
    const uChainList = Array.from(new Set([...args.chainList, ...enrollWith]));

    await enrollAOnSingleChain(
        signer,
        chain,
        {
            chainList: uChainList,
            contractList: args.contractList,
        },
        []
    );
}

async function enrollOtherWithAddOnChain(
    signer: ethers.Signer,
    chain: ChainType,
    args: Args, // chainlist entered by user
    enrollWith: string[]
) {
    await enrollAOnSingleChain(
        signer,
        chain,
        {
            chainList: enrollWith,
            contractList: args.contractList,
        },
        []
    );
}

task("ENROLLADDED_ONEACH", "enroll contracts on provided chains")
    //   .addParam('contractlist', 'Description of contract list parameter')
    .addParam("chainlist", "list of newly added chain")
    .addParam(
        "enrollwith",
        "list of chain to which newly added chain should be linked"
    )
    .addOptionalParam(
        "pkm",
        "Description of private key or mnemonic as parameter"
    )
    .addOptionalParam(
        "contractlist",
        "contract list for which enrolling to chainlist should be done"
    )
    .setAction(async (taskArgs: TaskArguments, hre: any) => {
        const { chainlist, pkm, enrollwith, contractlist } = taskArgs;
        let signer;
        if (pkm) signer = getSignerFromPrivateKeyOrMnemonic(pkm);
        else {
            // load from env
            const morp = process.env.MNEMONIC || process.env.PRIVATE_KEY;
            if (!morp) throw new Error("Provide mnemonic or private key");
            signer = getSignerFromPrivateKeyOrMnemonic(morp);
        }

        // signer = (await hre.ethers.getSigners())[0];
        const chainList: string[] = Array.from(
            new Set(chainlist.trim().split(" "))
        );

        const enrollWith: string[] = Array.from(
            new Set(enrollwith.trim().split(" "))
        );

        chainList.map((chain: string) => {
            if (!getChainId(chain))
                throw new Error(`invalid chain provided ${chain}`);
        });
        enrollWith.map((chain: string) => {
            if (!getChainId(chain))
                throw new Error(`invalid chain provided ${chain}`);
        });

        const contractList: string[] = contractlist
            ? Array.from(new Set(contractlist.trim().split(" ")))
            : [];
        if (!contractList.length) contractList.push("XERC1155"); // by default
        await enrollForEachChains(
            enrollOnSingleChain,
            {
                chainList: getUChainList(chainList),
                contractList,
            },
            signer,
            getUChainList(enrollWith)
        );

        console.log("Enrolling enrollwith chains to add on");
        await enrollForEachChains(
            enrollOtherWithAddOnChain,
            {
                chainList: getUChainList(enrollWith),
                contractList,
            },
            signer,
            getUChainList(chainList)
        );
    });
'''
'''--- evm/tasks/enroll_on_chain.ts ---
import { task } from "hardhat/config";
import { TaskArguments } from "hardhat/types";
import ethers from "ethers";
import { ChainType } from "./../utils/types";
import {
    getChainDeployment,
    getSignerFromPrivateKeyOrMnemonic,
} from "../utils/utils";
import { getChainId } from "../utils/chain";
import { Args, enrollForEachChains } from "../utils/OnEachChain";

export async function enrollOnSingleChain(
    signer: ethers.Signer,
    chain: ChainType,
    args: Args, // chainlist entered by user
    addOn: string[]
) {
    const hre = require("hardhat");
    const provider = signer.provider;
    if (!provider) throw new Error("signer provider is undefined");

    const network = await provider.getNetwork();
    hre.provider = provider;
    hre.network.provider = provider;
    const { ethers } = hre;

    for (const contract_key of args.contractList) {
        console.log(`Enrolling remote contract for ${contract_key}...`);
        const contract_factory = await ethers.getContractFactory(contract_key);
        //@ts-ignore
        const contract_address = (await getChainDeployment(network.name))[
            contract_key
        ];
        if (!contract_address) throw new Error("contract address undefined");

        const contract = await (
            await contract_factory.attach(contract_address)
        ).connect(signer);
        for (const chain of args.chainList) {
            if (getChainId(chain) == getChainId(network.name)) continue; // not enrolling same contract

            //@ts-ignore
            const remote_contract_address = (await getChainDeployment(chain))[
                contract_key
            ];
            if (!remote_contract_address)
                throw new Error("remote contract address undefined");

            console.log(`EnrollRemoteContract[${network.name}-> ${chain}]: started `);
            const tx = await contract
                .connect(signer)
                .setContractOnChain(0, getChainId(chain), remote_contract_address, {
                    gasLimit: 50000,
                });
            console.log(
                `EnrollRemoteContract[${network.name} -> ${chain}]: tx send with hash `,
                tx.hash
            );
            await tx.wait();
            console.log(
                `EnrollRemoteContract[${network.name} -> ${chain}]: tx went successfully`
            );
        }
        console.log(`Enrolling of remote contract for ${contract_key} completed`);
    }
}
task("ENROLL_ONEACH", "enroll contracts on provided chains")
    .addParam("chainlist", "Description of chainlist parameter")
    .addOptionalParam(
        "contractlist",
        "contract list for which enrolling to chainlist should be done"
    )
    .addOptionalParam(
        "pkm",
        "Description of private key or mnemonic as parameter"
    )
    .setAction(async (taskArgs: TaskArguments, hre: any) => {
        const { chainlist, pkm, contractlist } = taskArgs;
        let signer;
        if (pkm) signer = getSignerFromPrivateKeyOrMnemonic(pkm);
        else {
            // load from env
            const morp = process.env.MNEMONIC || process.env.PRIVATE_KEY;
            if (!morp) throw new Error("Provide mnemonic or private key");
            signer = getSignerFromPrivateKeyOrMnemonic(morp);
        }

        // signer = (await hre.ethers.getSigners())[0];

        const chainList: string[] = Array.from(
            new Set(chainlist.trim().split(" "))
        );

        const contractList: string[] = contractlist
            ? Array.from(new Set(contractlist.trim().split(" ")))
            : [];
        if (!contractList.length) contractList.push("XERC1155"); // by default

        chainList.map((chain: string) => {
            if (!getChainId(chain)) throw new Error("invalid chain provided");
        });

        await enrollForEachChains(
            enrollOnSingleChain,
            {
                chainList,
                contractList,
            },
            signer,
            []
        );
    });
'''
'''--- evm/tasks/index.ts ---
import "./deploy/PingPong";
import "./deploy/XERC1155";
import "./deploy/XERC721";
import "./deploy/XERC20";
import "./storeDeployments";

'''
'''--- evm/tasks/storeDeployments.ts ---
import { task, types } from "hardhat/config";
import fs from "fs";

task("TASK_STORE_DEPLOYMENTS", "stores deployment addresses")
  .addParam<string>("contractName", "Contract Name", "", types.string)
  .addParam<string>("contractAddress", "Contract Address", "", types.string)
  .addParam<string>("chainID", "chain id", "", types.string)
  .setAction(async (taskArgs, { ethers }): Promise<null> => {
    const deployedContracts = require("../deployment/deployments.json");

    if (typeof deployedContracts[taskArgs.chainID] === "undefined") {
      deployedContracts[taskArgs.chainID] = {};
    }

    deployedContracts[taskArgs.chainID][taskArgs.contractName] =
      taskArgs.contractAddress;

    fs.writeFileSync(
      "deployment/deployments.json",
      JSON.stringify(deployedContracts)
    );

    return null;
  });

'''
'''--- evm/test/PingPong.ts ---
/* eslint-disable @typescript-eslint/no-unused-vars */
import chai, { expect } from "chai";
import { Contract } from "ethers";
import { solidity } from "ethereum-waffle";
import { ethers } from "hardhat";
import { SignerWithAddress } from "hardhat-deploy-ethers/signers";

chai.use(solidity);

describe("Ping-Pong", function () {
  let gateway: Contract;
  let pingPong: Contract;
  let owner: string;
  let otherAccount: string;

  before(async () => {
    [owner, otherAccount] = await ethers.getSigners();

    const Gateway = await ethers.getContractFactory("MockGateway");
    gateway = await Gateway.deploy();
    await gateway.initialize();
    console.log("Gateway deployed to:", gateway.address);
    const PingPong = await ethers.getContractFactory("PingPong");
    pingPong = await PingPong.connect(owner).deploy(
      gateway.address,
      "router1z6ralzg5tsznq9s6xmutyeen7evylcj7harabc"
    );
    console.log("Pingpong deployed to:", pingPong.address);
  });

  it("Should set dapp metadata if called by owner", async function () {
    await pingPong.setDappMetadata(
      "router1z6ralzg5tsznq9s6xmutyeen7evylcj7hjchjw"
    );
    console.log("metadata set");
  });

  it("Should NOT set dapp metadata if not called by owner", async function () {
    await expect(
      pingPong
        .connect(otherAccount)
        .setDappMetadata("router1z6ralzg5tsznq9s6xmutyeen7evylcj7hjchjw")
    ).to.be.revertedWith("only owner");
  });

  it("Should set gateway if called by owner", async function () {
    await pingPong.setGateway(gateway.address);
    expect(await pingPong.gatewayContract()).to.be.equal(gateway.address);
  });

  it("Should NOT set dapp metadata if not called by owner", async function () {
    await expect(
      pingPong.connect(otherAccount).setGateway(gateway.address)
    ).to.be.revertedWith("only owner");
  });

  it("Should send iPing", async function () {
    const metadata = await pingPong.getRequestMetadata(
      300000,
      30000000000,
      300000,
      30000000000,
      10000000000,
      1,
      false,
      "0x"
    );
    await pingPong.iPing("1", pingPong.address, "hello ping", metadata);
    const Logs1 = await pingPong.queryFilter("NewPing");
    const Logs2 = await gateway.queryFilter("ISendEvent");

    console.log("LOGS1:", Logs1[0].args);
    console.log("LOGS2:", Logs2[0].args);
    // await gateway.iReceive(
    //   [[otherAccount], [10], 1],
    //   ["0x23"],
    //   [
    //     0,
    //     1,
    //     10000,
    //     "1",
    //     "0x",
    //     "1",
    //     "0x",
    //     pingPong.address,
    //     pingPong.address,
    //     Logs[0].args.requestPacket,
    //     false,
    //   ],
    //   ""
    // );
  });
});

'''
'''--- evm/tsconfig.json ---
{
  "compilerOptions": {
    "target": "es2020",
    "module": "commonjs",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true
  }
}

'''
'''--- evm/utils/OnEachChain.ts ---
import { ethers } from "ethers";
import { getChainInfo } from "./chain";
import { updateChainDeploymentInfo } from "./utils";

export type DeploymentArg = {
    chainList: string[];
    contractlist: string[];
    feePayer: string | null | undefined;
};

export type Args = {
    chainList: string[];
    contractList: string[];
};

export async function deployOnEachChains(
    onSingleChain: Function,
    deploymentArg: DeploymentArg,
    signer: ethers.Signer
) {
    const { chainList, feePayer } = deploymentArg;
    console.log(`Deployment started...`);
    for (const chain of chainList) {
        const { rpc, chainName, key, chainId } = getChainInfo(chain);
        console.log(`Deploying on ${chainName}...`);
        const provider = new ethers.providers.JsonRpcProvider(rpc, {
            name: key,
            chainId: parseInt(chainId),
        });

        const deploymentData = await onSingleChain(
            signer.connect(provider),
            deploymentArg,
            getChainInfo(chain)
        );

        await updateChainDeploymentInfo(chain, deploymentData);
        console.log(`Deployment on ${chainName} completed!`);
    }
    console.log("Deployment Completed!!");
}

export async function verifyOnEachChains(
    onSingleChain: Function,
    chainList: string[],
    signer: ethers.Signer
) {
    for (const chain of chainList) {
        const { rpc, chainName, key, chainId } = getChainInfo(chain);
        console.log(`Verifying on ${chainName}...`);
        const provider = new ethers.providers.JsonRpcProvider(rpc, {
            chainId: parseInt(chainId),
            name: key,
        });
        await onSingleChain(provider, getChainInfo(chain));
    }
}

export async function enrollForEachChains(
    onSingleChain: Function,
    args: Args,
    signer: ethers.Signer,
    addOn: string[]
) {
    for (const chain of args.chainList) {
        const { rpc, chainName, key, chainId } = getChainInfo(chain);

        console.log(`Enrolling for ${chainName}: Started!!`);
        const provider = new ethers.providers.JsonRpcProvider(rpc, {
            name: key,
            chainId: parseInt(chainId),
        });

        await onSingleChain(
            signer.connect(provider),
            getChainInfo(chain),
            args,
            addOn
        );

        console.log(`Enrolling For ${chainName} Completed!!`);
        console.log();
    }
}
'''
'''--- evm/utils/chain.ts ---
// chainType -> chainId -> Data
export const chainIdsMap: { [chainId: string]: any } = {
    '80001': {
        chainId: '80001',
        key: 'polygonMumbai',
        rpc: 'https://polygon-mumbai.g.alchemy.com/v2/8NUj-xxS1p3mJMFBo0h_szwvmUhMjkH4',
        chainName: 'Polygon Mumbai',
        gateway: '0x3ddf956f27297cd1E4423E97D7DDF2552f539C2F',
    },
    '5': {
        chainId: '5',
        key: 'goerli',
        rpc: 'https://goerli.infura.io/v3/91531d5460e34331a77e37156c61e223',
        chainName: 'Goerli',
        gateway: '0x',
    },
    '43113': {
        chainId: '43113',
        key: 'avalancheFuji',
        rpc: 'https://avalanche-fuji.infura.io/v3/91531d5460e34331a77e37156c61e223',
        chainName: 'Avalanche Fuji',
        gateway: '0x1aD8B95ee94Ae3Ef08Ebf777403572eB99D0E1Aa',
    },
    '9000': {
        chainId: '9000',
        key: 'routerTestnet',
        rpc: 'https://devnet-alpha.evm.rpc.routerprotocol.com/',
        chainName: 'Router Testnet',
    },
};

export const chainKeysMap: { [chainKey: string]: string } = {
    goerli: '5',
    avalancheFuji: '43113',
    polygonMumbai: '80001',
    routerTestnet: '9000',
};

export function getChainInfo(chain: string) {
    if (chainKeysMap[chain]) return chainIdsMap[chainKeysMap[chain]];
    return chainIdsMap[chain] || null;
}

export function getChainId(chain: string): string | null {
    return getChainInfo(chain)?.chainId;
}

export function getChainKey(chain: string): string | null {
    return getChainInfo(chain)?.key;
}

export function getUChainList(chains: string[]): string[] {
    const array: string[] = [];
    chains.map((chain) => {
        const chainId = getChainId(chain);
        if (chainId) array.push(chainId);
    });
    return Array.from(new Set(array));
}
'''
'''--- evm/utils/types.ts ---
export interface ReturnType {
    [key: string]: string;
}

export interface ChainType {
    rpc: string;
    chainName: string;
    chainId: string;
    key: string;
    gateway: string;
}

export interface ContractInfo {
    feePayer?: string;
    PingPing?: string;
    XERC1155?: string;
    contractlist?: string;
}

export interface JsonType {
    [chainId: string]: {
        [key: string]: ContractInfo;
    };
}
'''
'''--- evm/utils/utils.ts ---
import path from "path";
import fs from "fs-extra";
import { ethers } from "ethers";
import { getChainId } from "./chain";
import { JsonType, ContractInfo } from "./types";

const filePath = path.resolve(__dirname, "../deployment/deployments.json");

export async function getChainDeployment(
    chain: string
): Promise<ContractInfo | null> {
    try {
        const json: JsonType = await fs.readJson(filePath);
        const chainId = getChainId(chain);
        if (!chainId) throw new Error("Invalid chain");
        return json[chainId];
    } catch (err) {
        //@ts-ignore
        console.error(`Failed to read file: ${err.message}`);
        process.exit(1);
    }
}

export async function isPreviousDeployed(): Promise<boolean> {
    try {
        const json: JsonType = await fs.readJson(filePath);
        if (Object.keys(json).length) return true;
        return false;
    } catch (err) {
        return false;
    }
}

export async function getPrevDeployment(): Promise<JsonType> {
    try {
        return await fs.readJson(filePath);
    } catch (err) {
        return {};
    }
}

export function getSignerFromPrivateKeyOrMnemonic(str: string) {
    const privateKeyRegex = /^[0-9a-fA-F]{64}$/;
    const mnemonicRegex = /^([a-z]+\s){11}[a-z]+$/;
    if (privateKeyRegex.test(str)) {
        return new ethers.Wallet(str);
    } else if (mnemonicRegex.test(str)) {
        return ethers.Wallet.fromMnemonic(str);
    } else {
        throw new Error("Invalid input: not a private key or mnemonic");
    }
}

const deploymentPath = path.join(__dirname, "../deployment");
const getLastDeployment = async () => {
    await fs.ensureDir(deploymentPath);
    const prevDetails = await fs
        .readJSON(`${deploymentPath}/deployments.json`)
        .catch(() => ({}));
    return prevDetails;
};

const updateDeployment = async (newDeployment: {}) => {
    await fs.writeJSON(`${deploymentPath}/deployments.json`, newDeployment);
};

export const updateChainDeploymentInfo = async (
    chain: string,
    chainInfo: {}
) => {
    const lastDeployment = await getLastDeployment();
    const chainId = getChainId(chain);
    if (!chainId) throw new Error("Invalid chain");
    await updateDeployment({
        ...lastDeployment,
        [chainId]: {
            ...lastDeployment[chainId],
            ...chainInfo,
        },
    });
};
'''
'''--- near/Cargo.toml ---
[workspace]
members = [
    "contracts/ping-pong",
    "contracts/near-e2e-dapp",
]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- near/README.md ---
# Router's NEAR Gateway Contracts

Router NEAR Gateway contract will bridge NEAR chain with the Router Chain.
We can deploy this gateway contract on NEAR chain.

## Overview

The NEAR gateway contract implements three funcitonlity.

1. Send request to the Router chain or any other destination chain.
2. Handle request from the Router chain or any other destination chain.
3. Update Validator set on the gateway contact.

## Please use the following instruction to setup, test and deploy the project

## Send Request to the Router Chain

To send request to router chain the user contract need to call the following function
and needs to provide the bridge contract address & payload bytes

```sh
# Gateway contract address variable
Gateway public gatewayContract;

# User/ Application contract constructor
constructor(address gatewayAddress) {
    gatewayContract = Gateway(gatewayAddress);
}

# example of send request to the Router chain
function sendRequestToRouter(bytes memory payload, string memory routerBridgeContract) public payable {
    # implement the business logic
    gatewayContract.requestToRouter(payload, routerBridgeContract);
}
```

## Handle Request from the Router

To handle request coming from the router chain, the user contract needs to implement
the following function in their contract

```sh
function handleRequestFromRouter(string memory sender, bytes memory payload) external {
    # implement the business logic
}
```

In case of state update from the _requestFromRouter_ function we are emitting the following event

```sh
# This is OutBound Request Acknowledgement event
event EventOutboundAck(
    uint256 ChainType,
    string  ChainId,
    uint256 OutboundTxNonce,
    bytes   contractAckResponses,
    uint8   exeCode,
    bool    status
);
```

Currently we are emitting this outbound acknowlegdement event in two cases only.
The ChainType, ChainId, and OutboundTxNonce will have same values in all cases.

- When the txn is valid but It is getting executed past the timeout.
  In this scenario, we will update the nonce mapping to 1 as executed and event will have the following values

  ```
  event EventOutboundAck(
      ChainType,
      ChainId,
      OutboundTxNonce,
      "",
      3,
      false
  );
  ```

- When the txn is valid and executed its handler calls to user contract
  In this scenario, we will update the nonce mapping to 1 as executed and event will have the following values
  ```
  event EventOutboundAck(
      ChainType,
      ChainId,
      OutboundTxNonce,
      data,
      0,
      success
  );
  ```
  Here, data and success values are coming from the _handlerExecuteCalls_ funciton.
  Data bytes can be decoded according to the success value. If it is true, then it will be
  array of bool values and if it is false, then it will string value.

## Update Validator Set

This is used to update validator set on the gateway contract.
This will be called by the router chain validator set only.

## Setup

```
cd router-gateway-contracts/substrate
rustup toolchain install nightly-2022-08-15
rustup target add wasm32-unknown-unknown --toolchain nightly-2022-08-15
rustup component add rust-src --toolchain nightly-2022-08-15
cargo +nightly-2022-08-15 contract build
```

## Run Tests

Use the following commands to run the test cases:

```
cargo +nightly-2022-08-15 contract test
```

## Deploy Gateway Contract on live network

Add gateway contract constructor arguments in args.json

```
cd router-gateway-contracts/substrate
npx hardhat deploy --network <network>
```

## Verify GateWay Contract on a network

```
cd router-gateway-contracts/substrate
npx hardhat verify --constructor-args <args-file-path> <gateway-contract-address> --network <network-name>
```

Example:-

```
npx hardhat verify --constructor-args scripts/arguments.js 0x610aEe9387488398c25Aca6aDFBac662177DB24D --network polygonMumbai
```

'''
'''--- near/build.sh ---
#!/usr/bin/env bash

echo ">> Building contracts"

rm -rf artifacts
mkdir artifacts

RUSTFLAGS='-C target-feature=-crt-static -C link-arg=-nostartfiles -C link-arg=-Wl,--no-entry'
rustup target add wasm32-unknown-unknown
cargo build --all --target wasm32-unknown-unknown --release

cp -r target/wasm32-unknown-unknown/release/*.wasm artifacts/

'''
'''--- near/contracts/near-e2e-dapp/Cargo.toml ---
[package]
name = "test-dapp"
version = "1.0.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0"
ethabi = { version = "18.0.0", default-features = false }
hex = { version = "0.4.3", default-features = false }
uint = { version = "0.9.3", default-features = false }
getrandom = {version = "0.2.0", features = ["custom"]}

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- near/contracts/near-e2e-dapp/build.sh ---
#!/bin/sh

echo ">> Building contract"

rustup target add wasm32-unknown-unknown
cargo build --all --target wasm32-unknown-unknown --release
'''
'''--- near/contracts/near-e2e-dapp/src/contract.rs ---
use std::str::FromStr;

use crate::external::*;
use crate::types::ISendParams;
use ethabi::{decode, ParamType, Token};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedMap;
use near_sdk::json_types::Base64VecU8;
use near_sdk::{serde_json, PromiseOrValue};
use near_sdk::{env, json_types::U128, near_bindgen, AccountId, Gas, Promise};

// Define the contract structure
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct TestDapp {
    gateway: AccountId,
    route_token: AccountId,
    owner: AccountId,
    greeting_record: UnorderedMap<(String, u64), String>,
    ack_record: UnorderedMap<U128, bool>,
}

impl Default for TestDapp {
    // The default trait with which to initialize the contract
    fn default() -> Self {
        Self {
            gateway: AccountId::from_str("gateway").unwrap(),
            route_token: AccountId::from_str("route").unwrap(),
            owner: env::predecessor_account_id(),
            greeting_record: UnorderedMap::new(b"g"),
            ack_record: UnorderedMap::new(b"a"),
        }
    }
}

// Implement the contract structure
#[near_bindgen]
impl TestDapp {
    #[init]
    pub fn new(gateway: AccountId, route_token: AccountId) -> Self {
        Self {
            gateway,
            route_token,
            owner: env::predecessor_account_id(),
            greeting_record: UnorderedMap::new(b"g"),
            ack_record: UnorderedMap::new(b"a"),
        }
    }

    pub fn get_gateway(&self) -> AccountId {
        self.gateway.clone()
    }

    pub fn get_owner(&self) -> AccountId {
        self.owner.clone()
    }

    pub fn get_greeting_record(&self, src_chain_id: String, request_id: u64) -> String {
        self.greeting_record
            .get(&(src_chain_id, request_id))
            .unwrap_or("".to_string())
    }

    pub fn get_ack_record(&self, request_id: U128) -> bool {
        self.ack_record.get(&(request_id)).unwrap_or(false)
    }

    pub fn set_dapp_metadata(&self, fee_payer_address: String) -> Promise {
        if env::predecessor_account_id() != self.owner.clone() {
            env::panic_str("only owner");
        }

        gateway_contract::ext(self.gateway.clone())
            .with_attached_deposit(env::attached_deposit())
            .with_static_gas(Gas(5 * TGAS))
            .set_dapp_metadata(fee_payer_address)
    }

    pub fn send_i_request(
        &self,
        payload: Vec<u8>,
        dest_contract_address: String,
        dest_chain_id: String,
        request_metadata: Vec<u8>,
        amount: U128,
        route_recipient: String,
    ) -> Promise {
        let dest_contract_addr_token: Token = Token::String(dest_contract_address);
        let payload_token: Token = Token::Bytes(payload.clone());

        let param_types: Vec<ParamType> = vec![ParamType::Uint(64), ParamType::String];
        let decoded = decode(&param_types, &payload);

        if decoded.is_err() {
            env::panic_str(&format!(
                "Error in decoding payload: {:?}",
                decoded.unwrap_err()
            ));
        }

        let decoded: Vec<Token> = decoded.unwrap();
        let greeting: String = decoded[1].clone().into_string().unwrap();

        let request_packet: Vec<u8> = ethabi::encode(&[dest_contract_addr_token, payload_token]);

        if amount > U128::from(0) {
            if route_recipient == "".to_string() {
                env::panic_str("Route recipient cannot be empty");
            }

            let request_params: ISendParams = ISendParams {
                version: U128::from(1),
                route_recipient,
                request_metadata: request_metadata.clone(),
                request_packet: request_packet.clone(),
                dest_chain_id,
            };
            let encoded: String =
                near_sdk::base64::encode(serde_json::to_string(&request_params).unwrap());
            let decoded = near_sdk::base64::decode(encoded);

            if decoded.is_err() {
                env::panic_str(&format!(
                    "unable to decode the message: {:?}",
                    decoded.unwrap_err()
                ));
            }

            let msg: Base64VecU8 = Base64VecU8::from(decoded.unwrap());

            let promise: Promise = route_token::ext(self.route_token.clone())
                .with_static_gas(Gas(5 * TGAS))
                .burn_and_call_gateway(false, amount, msg);

            if greeting == "".to_string() {
                env::panic_str("greeting cannot be empty");
            }

            return promise;
        }

        let promise: Promise = gateway_contract::ext(self.gateway.clone())
            .with_attached_deposit(env::attached_deposit())
            .with_static_gas(Gas(5 * TGAS))
            .i_send(
                U128::from(1),
                dest_chain_id,
                request_metadata,
                request_packet,
            );

        if greeting == "".to_string() {
            env::panic_str("greeting cannot be empty");
        }

        promise
    }

    pub fn i_receive(
        &mut self,
        request_sender: String,
        packet: Vec<u8>,
        src_chain_id: String,
    ) -> PromiseOrValue<Vec<u8>> {
        if self.gateway.clone() != env::predecessor_account_id() {
            env::panic_str("only gateway");
        }

        let res = ethabi::decode(&[ParamType::Uint(64), ParamType::String], &packet);

        if res.is_err() {
            let error = res.unwrap_err();
            let format_error_string: String = format!("Error in decoding packet: {:?}", error);
            env::panic_str(&format_error_string);
        }

        let res: Vec<Token> = res.unwrap();
        let nonce: u64 = res[0].clone().into_uint().unwrap().as_u64();
        let greeting: String = res[1].clone().into_string().unwrap();

        if greeting == "Fail Dest Req".to_string() {
            env::panic_str("String != Fail Dest Req");
        }

        self.greeting_record
            .insert(&(src_chain_id, nonce), &greeting);

        PromiseOrValue::Value(packet)
    }

    pub fn i_ack(&mut self, request_identifier: U128, exec_flag: bool, exec_data: Vec<u8>) {
        if self.gateway.clone() != env::predecessor_account_id() {
            env::panic_str("only gateway");
        }

        if exec_flag {
            let res = ethabi::decode(&[ParamType::Uint(64), ParamType::String], &exec_data);

            if res.is_err() {
                let error = res.unwrap_err();
                let format_error_string: String = format!("Error in decoding packet: {:?}", error);
                env::panic_str(&format_error_string);
            }

            let res: Vec<Token> = res.unwrap();
            let greeting: String = res[1].clone().into_string().unwrap();

            if greeting == "Fail Ack Req".to_string() {
                env::panic_str("String != Fail Ack Req");
            }
        }

        self.ack_record.insert(&request_identifier, &true);
    }
}

'''
'''--- near/contracts/near-e2e-dapp/src/external.rs ---
use near_sdk::{ext_contract, json_types::U128};

pub const TGAS: u64 = 1_000_000_000_000;

// Validator interface, for cross-contract calls
#[ext_contract(gateway_contract)]
trait GatewayContract {
    fn i_send(
        &mut self,
        version: U128,
        dest_chain_id: String,
        request_metadata: Vec<u8>,
        request_packet: Vec<u8>,
    ) -> bool;

    fn set_dapp_metadata(&self, fee_payer_address: String);
}

#[ext_contract(route_token)]
trait RouteToken {
    fn burn_and_call_gateway(
        &mut self,
        is_app_token_payer: bool,
        amount: U128,
        msg: near_sdk::json_types::Base64VecU8,
    );
}

'''
'''--- near/contracts/near-e2e-dapp/src/lib.rs ---
pub mod contract;
mod external;
#[cfg(test)]
mod tests;
mod types;

'''
'''--- near/contracts/near-e2e-dapp/src/tests.rs ---
use std::str::FromStr;

use ethabi::{encode, ethereum_types::U256, Token};
use near_sdk::{env, json_types::U128, AccountId};

use crate::contract::TestDapp;

#[test]
fn send_i_request_without_token() {
    let gateway: AccountId = AccountId::from_str("gateway").unwrap();
    let route_token: AccountId = AccountId::from_str("route").unwrap();

    let test_dapp: TestDapp = TestDapp::new(gateway, route_token);

    let nonce: u64 = 1;
    let greeting: String = "hello".to_string();

    let nonce_u256: U256 = U256::from(nonce);
    let nonce_token: Token = Token::Uint(nonce_u256);
    let greeting_token: Token = Token::String(greeting);

    let payload: Vec<u8> = encode(&[nonce_token, greeting_token]);

    test_dapp.send_i_request(
        payload,
        "abcd".to_string(),
        "80001".to_string(),
        vec![1, 2, 3, 4],
        U128::from(0),
        "".to_string(),
    );
}

#[test]
#[should_panic(expected = "greeting cannot be empty")]
fn send_i_request_without_token_with_empty_string() {
    let gateway: AccountId = AccountId::from_str("gateway").unwrap();
    let route_token: AccountId = AccountId::from_str("route").unwrap();

    let test_dapp: TestDapp = TestDapp::new(gateway, route_token);

    let nonce: u64 = 1;
    let greeting: String = "".to_string();

    let nonce_u256: U256 = U256::from(nonce);
    let nonce_token: Token = Token::Uint(nonce_u256);
    let greeting_token: Token = Token::String(greeting);

    let payload: Vec<u8> = encode(&[nonce_token, greeting_token]);

    test_dapp.send_i_request(
        payload,
        "abcd".to_string(),
        "80001".to_string(),
        vec![1, 2, 3, 4],
        U128::from(0),
        "".to_string(),
    );
}

#[test]
#[should_panic(expected = "Error in decoding payload: InvalidData")]
fn send_i_request_without_token_with_invalid_payload() {
    let gateway: AccountId = AccountId::from_str("gateway").unwrap();
    let route_token: AccountId = AccountId::from_str("route").unwrap();

    let test_dapp: TestDapp = TestDapp::new(gateway, route_token);

    test_dapp.send_i_request(
        vec![1, 1],
        "abcd".to_string(),
        "80001".to_string(),
        vec![1, 2, 3, 4],
        U128::from(0),
        "".to_string(),
    );
}

#[test]
fn send_i_request_with_token() {
    let gateway: AccountId = AccountId::from_str("gateway").unwrap();
    let route_token: AccountId = AccountId::from_str("route").unwrap();

    let test_dapp: TestDapp = TestDapp::new(gateway, route_token);

    let nonce: u64 = 1;
    let greeting: String = "hello".to_string();

    let nonce_u256: U256 = U256::from(nonce);
    let nonce_token: Token = Token::Uint(nonce_u256);
    let greeting_token: Token = Token::String(greeting);

    let payload: Vec<u8> = encode(&[nonce_token, greeting_token]);

    test_dapp.send_i_request(
        payload,
        "abcd".to_string(),
        "80001".to_string(),
        vec![1, 2, 3, 4],
        U128::from(12),
        "Hello".to_string(),
    );
}

#[test]
#[should_panic(expected = "greeting cannot be empty")]
fn send_i_request_with_token_with_empty_string() {
    let gateway: AccountId = AccountId::from_str("gateway").unwrap();
    let route_token: AccountId = AccountId::from_str("route").unwrap();

    let test_dapp: TestDapp = TestDapp::new(gateway, route_token);

    let nonce: u64 = 1;
    let greeting: String = "".to_string();

    let nonce_u256: U256 = U256::from(nonce);
    let nonce_token: Token = Token::Uint(nonce_u256);
    let greeting_token: Token = Token::String(greeting);

    let payload: Vec<u8> = encode(&[nonce_token, greeting_token]);

    test_dapp.send_i_request(
        payload,
        "abcd".to_string(),
        "80001".to_string(),
        vec![1, 2, 3, 4],
        U128::from(12),
        "Hello".to_string(),
    );
}

#[test]
#[should_panic(expected = "Error in decoding payload: InvalidData")]
fn send_i_request_with_token_with_invalid_payload() {
    let gateway: AccountId = AccountId::from_str("gateway").unwrap();
    let route_token: AccountId = AccountId::from_str("route").unwrap();

    let test_dapp: TestDapp = TestDapp::new(gateway, route_token);

    test_dapp.send_i_request(
        vec![1, 1],
        "abcd".to_string(),
        "80001".to_string(),
        vec![1, 2, 3, 4],
        U128::from(0),
        "".to_string(),
    );
}

#[test]
#[should_panic(expected = "Route recipient cannot be empty")]
fn send_i_request_with_token_with_empty_recipient() {
    let gateway: AccountId = AccountId::from_str("gateway").unwrap();
    let route_token: AccountId = AccountId::from_str("route").unwrap();

    let test_dapp: TestDapp = TestDapp::new(gateway, route_token);

    let nonce: u64 = 1;
    let greeting: String = "".to_string();

    let nonce_u256: U256 = U256::from(nonce);
    let nonce_token: Token = Token::Uint(nonce_u256);
    let greeting_token: Token = Token::String(greeting);

    let payload: Vec<u8> = encode(&[nonce_token, greeting_token]);

    test_dapp.send_i_request(
        payload,
        "abcd".to_string(),
        "80001".to_string(),
        vec![1, 2, 3, 4],
        U128::from(12),
        "".to_string(),
    );
}

#[test]
fn test_i_receive() {
    let gateway: AccountId = env::predecessor_account_id();
    let route_token: AccountId = AccountId::from_str("route").unwrap();

    let mut test_dapp: TestDapp = TestDapp::new(gateway, route_token);

    let request_id: u64 = 1;
    let request_id_u256 = ethabi::ethereum_types::U256::from(request_id);
    let request_id_token: Token = Token::Uint(request_id_u256);

    let greeting: String = "Hello".to_string();
    let greeting_token: Token = Token::String(greeting);

    let encoded_packet = ethabi::encode(&[request_id_token, greeting_token]);

    test_dapp.i_receive(
        "request_sender".to_string(),
        encoded_packet,
        "80001".to_string(),
    );

    let greeting: String = test_dapp.get_greeting_record("80001".to_string(), 1);
    assert_eq!(greeting, "Hello".to_string());
}

#[test]
#[should_panic(expected = "only gateway")]
fn test_i_receive_should_panic_wrong_gateway() {
    let gateway: AccountId = AccountId::from_str("gateway").unwrap();
    let route_token: AccountId = AccountId::from_str("route").unwrap();

    let mut test_dapp: TestDapp = TestDapp::new(gateway, route_token);

    test_dapp.i_receive(
        "request_sender".to_string(),
        vec![0, 0, 0],
        "80001".to_string(),
    );
}

#[test]
#[should_panic(expected = "Error in decoding packet: InvalidData")]
fn test_i_receive_should_panic_wrong_decoding() {
    let gateway: AccountId = env::predecessor_account_id();
    let route_token: AccountId = AccountId::from_str("route").unwrap();

    let mut test_dapp: TestDapp = TestDapp::new(gateway, route_token);

    test_dapp.i_receive(
        "request_sender".to_string(),
        vec![0, 0, 0],
        "80001".to_string(),
    );
}

#[test]
#[should_panic(expected = "String != Fail Dest Req")]
fn test_i_receive_should_panic_failure_string() {
    let gateway: AccountId = env::predecessor_account_id();
    let route_token: AccountId = AccountId::from_str("route").unwrap();

    let mut test_dapp: TestDapp = TestDapp::new(gateway, route_token);

    let request_id: u64 = 1;
    let request_id_u256: U256 = U256::from(request_id);
    let request_id_token: Token = Token::Uint(request_id_u256);

    let greeting: String = "Fail Dest Req".to_string();
    let greeting_token: Token = Token::String(greeting);

    let encoded_packet: Vec<u8> = ethabi::encode(&[request_id_token, greeting_token]);

    test_dapp.i_receive(
        "request_sender".to_string(),
        encoded_packet,
        "80001".to_string(),
    );
}

#[test]
fn test_i_ack() {
    let gateway: AccountId = env::predecessor_account_id();
    let route_token: AccountId = AccountId::from_str("route").unwrap();

    let mut test_dapp: TestDapp = TestDapp::new(gateway, route_token);

    let request_id: u64 = 1;
    let request_id_u256: U256 = U256::from(request_id);
    let request_id_token: Token = Token::Uint(request_id_u256);

    let greeting: String = "hello".to_string();
    let greeting_token: Token = Token::String(greeting);

    let encoded_packet: Vec<u8> = ethabi::encode(&[request_id_token, greeting_token]);

    test_dapp.i_ack(U128::from(12), true, encoded_packet);

    let ack_record = test_dapp.get_ack_record(U128::from(12));
    assert_eq!(ack_record, true);
}

#[test]
#[should_panic(expected = "only gateway")]
fn test_i_ack_should_panic_only_gateway() {
    let gateway: AccountId = AccountId::from_str("gateway").unwrap();
    let route_token: AccountId = AccountId::from_str("route").unwrap();

    let mut test_dapp: TestDapp = TestDapp::new(gateway, route_token);

    test_dapp.i_ack(U128::from(12), true, vec![0, 0, 0]);
}

#[test]
#[should_panic(expected = "String != Fail Ack Req")]
fn test_i_ack_should_panic_failure_string() {
    let gateway: AccountId = env::predecessor_account_id();
    let route_token: AccountId = AccountId::from_str("route").unwrap();

    let mut test_dapp: TestDapp = TestDapp::new(gateway, route_token);

    let request_id: u64 = 1;
    let request_id_u256: U256 = U256::from(request_id);
    let request_id_token: Token = Token::Uint(request_id_u256);

    let greeting: String = "Fail Ack Req".to_string();
    let greeting_token: Token = Token::String(greeting);

    let encoded_packet: Vec<u8> = ethabi::encode(&[request_id_token, greeting_token]);

    test_dapp.i_ack(U128::from(12), true, encoded_packet);
}

'''
'''--- near/contracts/near-e2e-dapp/src/types.rs ---
use near_sdk::{
    json_types::U128,
    serde::{Deserialize, Serialize},
};

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
#[serde(crate = "near_sdk::serde")]
pub struct ISendParams {
    pub version: U128,
    pub route_recipient: String,
    pub dest_chain_id: String,
    pub request_metadata: Vec<u8>,
    pub request_packet: Vec<u8>,
}

'''
'''--- near/contracts/ping-pong/Cargo.toml ---
[package]
name = "ping-pong"
version = "1.0.0"
authors = ["Router Protocol <shivam@routerprotocol.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0"
schemars = "0.8.12"
hex = { version = "0.4.3", default-features = false }
router-wasm-bindings = { version = "0.1.17", default-features = false, features = ["ethabi"] }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- near/contracts/ping-pong/README.md ---
# To deploy to testnet

use command to deploy:

```
near deploy xyz.abc.testnet --initFunction new --initArgs '{"gateway":"gateway.abc.testnet"}' --wasmFile target/wasm32-unknown-unknown/release/contract.wasm
```

> Note: Change the addresses of deployment and gateway before deploying.

'''
'''--- near/contracts/ping-pong/build.sh ---
#!/bin/sh
echo ">> Building contract"

rustup target add wasm32-unknown-unknown
cargo build --all --target wasm32-unknown-unknown --release

'''
'''--- near/contracts/ping-pong/package.json ---
{
  "name": "ping-pong",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {},
  "devDependencies": {
    "near-cli": "^3.3.0"
  },
  "dependencies": {}
}

'''
'''--- near/contracts/ping-pong/src/events.rs ---
use near_sdk::{
    json_types::U128,
    serde::{Deserialize, Serialize},
    serde_json,
};
use std::fmt;

use crate::{CONTRACT_NAME, CONTRACT_VERSION};

#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[serde(crate = "near_sdk::serde")]
#[non_exhaustive]
pub enum EventLogVariant {
    PingFromSource(Vec<PingFromSourceEvent>),
    NewPing(Vec<NewPingEvent>),
    ExecutionStatus(Vec<ExecutionStatusEvent>),
    AckFromDestination(Vec<AckFromDestinationEvent>),
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct EventLog {
    pub standard: String,
    pub version: String,

    // `flatten` to not have "event": {<EventLogVariant>} in the JSON, just have the contents of {<EventLogVariant>}.
    #[serde(flatten)]
    pub event: EventLogVariant,
}

impl EventLog {
    pub fn new(event: EventLogVariant) -> Self {
        Self {
            standard: CONTRACT_NAME.to_string(),
            version: CONTRACT_VERSION.to_string(),
            event,
        }
    }
}

impl fmt::Display for EventLog {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!(
            "EVENT_JSON:{}",
            &serde_json::to_string(self).map_err(|_| fmt::Error)?
        ))
    }
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct PingFromSourceEvent {
    pub src_chain_id: String,
    pub request_id: u64,
    pub message: String,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NewPingEvent {
    pub request_id: u64,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct ExecutionStatusEvent {
    pub request_identifier: U128,
    pub is_success: bool,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct AckFromDestinationEvent {
    pub request_id: u64,
    pub ack_message: String,
}

'''
'''--- near/contracts/ping-pong/src/external.rs ---
use near_sdk::{ext_contract, json_types::U128};

pub const TGAS: u64 = 1_000_000_000_000;

// Validator interface, for cross-contract calls
#[ext_contract(gateway_contract)]
trait GatewayContract {
    fn i_send(
        &mut self,
        version: U128,
        dest_chain_id: String,
        request_metadata: Vec<u8>,
        request_packet: Vec<u8>,
    ) -> bool;

    fn set_dapp_metadata(&self, fee_payer_address: String);
}

'''
'''--- near/contracts/ping-pong/src/lib.rs ---
mod events;
mod external;
#[cfg(test)]
mod tests;

use events::{
    AckFromDestinationEvent, EventLog,
    EventLogVariant::{AckFromDestination, ExecutionStatus, NewPing, PingFromSource},
    ExecutionStatusEvent, NewPingEvent, PingFromSourceEvent,
};
use external::*;
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::UnorderedMap,
    env,
    json_types::U128,
    near_bindgen, AccountId, Gas, Promise, PromiseOrValue,
};
use router_wasm_bindings::ethabi::{decode, encode, ethereum_types::U256, ParamType, Token};

pub const CONTRACT_VERSION: &str = "1.0.0";
pub const CONTRACT_NAME: &str = "PingPong";

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct PingPong {
    owner: AccountId,
    gateway: AccountId,
    current_request_id: u64,
    // srcChainType, srcChainId, requestId -> pingFromSource
    ping_from_source: UnorderedMap<(String, u64), String>,
    // requestId => ackMessage
    ack_from_destination: UnorderedMap<u64, String>,
}

impl Default for PingPong {
    fn default() -> Self {
        Self {
            owner: env::predecessor_account_id(),
            gateway: env::predecessor_account_id(),
            current_request_id: 0,
            ping_from_source: UnorderedMap::new(b'p'),
            ack_from_destination: UnorderedMap::new(b'a'),
        }
    }
}

#[near_bindgen]
impl PingPong {
    #[init]
    pub fn new(gateway: AccountId) -> Self {
        Self {
            owner: env::predecessor_account_id(),
            gateway,
            current_request_id: 0,
            ping_from_source: UnorderedMap::new(b'p'),
            ack_from_destination: UnorderedMap::new(b'a'),
        }
    }

    pub fn set_gateway(&mut self, gateway: AccountId) {
        if env::predecessor_account_id() != self.owner.clone() {
            env::panic_str("only owner");
        }

        self.gateway = gateway;
    }

    pub fn get_current_request_id(&self) -> u64 {
        return self.current_request_id.clone();
    }

    pub fn get_ping_from_source(&self, src_chain_id: String, request_id: u64) -> String {
        self.ping_from_source
            .get(&(src_chain_id, request_id))
            .unwrap_or("".to_string())
    }

    pub fn get_ack_from_destination(&self, request_id: u64) -> String {
        self.ack_from_destination
            .get(&request_id)
            .unwrap_or("".to_string())
    }

    pub fn get_gateway(&self) -> AccountId {
        self.gateway.clone()
    }

    pub fn get_owner(&self) -> AccountId {
        self.owner.clone()
    }

    #[payable]
    pub fn set_dapp_metadata(&mut self, fee_payer_address: String) -> Promise {
        if env::predecessor_account_id() != self.owner.clone() {
            env::panic_str("only owner");
        }

        gateway_contract::ext(self.gateway.clone())
            .with_attached_deposit(env::attached_deposit())
            .with_static_gas(Gas(5 * TGAS))
            .set_dapp_metadata(fee_payer_address)
    }

    pub fn get_request_metadata(
        dest_gas_limit: u64,
        dest_gas_price: u64,
        ack_gas_limit: u64,
        ack_gas_price: u64,
        relayer_fees: U128,
        ack_type: u8,
        is_read_call: bool,
        asm_address: String,
    ) -> Vec<u8> {
        let mut request_metadata: Vec<u8> = vec![];

        request_metadata.append(&mut dest_gas_limit.to_be_bytes().to_vec());
        request_metadata.append(&mut dest_gas_price.to_be_bytes().to_vec());
        request_metadata.append(&mut ack_gas_limit.to_be_bytes().to_vec());
        request_metadata.append(&mut ack_gas_price.to_be_bytes().to_vec());
        request_metadata.append(&mut u128::from(relayer_fees).to_be_bytes().to_vec());
        request_metadata.append(&mut ack_type.to_be_bytes().to_vec());

        if is_read_call {
            request_metadata.append(&mut vec![1]);
        } else {
            request_metadata.append(&mut vec![0]);
        }
        request_metadata.append(&mut asm_address.as_bytes().to_vec());

        request_metadata
    }

    #[payable]
    pub fn i_ping(
        &mut self,
        dest_chain_id: String,
        destination_contract_address: String,
        str: String,
        request_metadata: Vec<u8>,
        recipient: String
    ) -> Promise {
        self.current_request_id += 1;

        let request_id_token: Token = Token::Uint(U256::from(self.current_request_id.clone()));
        let message_token: Token = Token::String(str);
        let recipient_token: Token = Token::String(recipient);

        // abi.encode(request_id, message)
        let packet: Vec<u8> = encode(&[request_id_token, message_token, recipient_token]);

        let handler_token: Token = Token::String(destination_contract_address);
        let packet_token: Token = Token::Bytes(packet);

        // abi.encode(packet, message)
        let request_packet: Vec<u8> = encode(&[handler_token, packet_token]);

        let ping_event: EventLog = EventLog::new(NewPing(vec![NewPingEvent {
            request_id: self.current_request_id.clone(),
        }]));

        env::log_str(&ping_event.to_string());

        gateway_contract::ext(self.gateway.clone())
            .with_attached_deposit(env::attached_deposit())
            .i_send(
                U128::from(1),
                dest_chain_id,
                request_metadata,
                request_packet,
            )
    }

    pub fn i_receive(
        &mut self,
        request_sender: String,
        packet: Vec<u8>,
        src_chain_id: String,
    ) -> PromiseOrValue<Vec<u8>> {
        if env::predecessor_account_id() != self.gateway.clone() {
            env::panic_str("not gateway");
        }

        let param_vec: Vec<ParamType> = vec![ParamType::Uint(64), ParamType::String];

        let token_vec: Vec<Token> = match decode(&param_vec, &packet) {
            Ok(data) => data,
            Err(_) => env::panic_str("not able to decode the packet"),
        };

        let request_id: u64 = token_vec[0].clone().into_uint().unwrap().as_u64();
        let message: String = token_vec[1].clone().into_string().unwrap();

        if message == "".to_string() {
            env::panic_str("String should not be empty");
        }

        self.ping_from_source
            .insert(&(src_chain_id.clone(), request_id.clone()), &message);

        let ping_from_source: EventLog = EventLog::new(PingFromSource(vec![PingFromSourceEvent {
            src_chain_id: src_chain_id.clone(),
            request_id: request_id,
            message: message,
        }]));

        env::log_str(&ping_from_source.to_string());

        PromiseOrValue::Value(packet)
    }

    pub fn i_ack(
        &mut self,
        request_identifier: U128,
        exec_flag: bool,
        exec_data: Vec<u8>,
    ) {
        if env::predecessor_account_id() != self.gateway.clone() {
            env::panic_str("not gateway");
        }

        let decoded = decode(&[ParamType::Uint(64), ParamType::String], &exec_data);
        if decoded.is_err() {
            let format_str: String = format!(
                "Cannot decode the exec data for request_id: {:?}",
                request_identifier.clone()
            );
            env::panic_str(&format_str);
        }

        let decoded: Vec<Token> = decoded.unwrap();
        let request_id: u64 = decoded[0].clone().into_uint().unwrap().as_u64();
        let ack_message: String = decoded[1].clone().into_string().unwrap();

        self.ack_from_destination.insert(&request_id, &ack_message);

        let exec_status_event: EventLog =
            EventLog::new(ExecutionStatus(vec![ExecutionStatusEvent {
                request_identifier: request_identifier.clone(),
                is_success: exec_flag,
            }]));

        env::log_str(&exec_status_event.to_string());

        let ack_from_destination_event: EventLog =
            EventLog::new(AckFromDestination(vec![AckFromDestinationEvent {
                request_id,
                ack_message,
            }]));

        env::log_str(&ack_from_destination_event.to_string());
    }

    pub fn withdraw_fees(&self, recipient: AccountId) -> Promise {
        if env::predecessor_account_id() != self.owner {
            env::panic_str("Only owner");
        }

        let balance: u128 = env::account_balance() - Self::total_storage_cost();
        Promise::new(recipient).transfer(balance)
    }

    pub fn total_storage_cost() -> u128 {
        u128::from(env::storage_usage()) * env::storage_byte_cost()
    }
}

'''
'''--- near/contracts/ping-pong/src/tests.rs ---
use crate::*;
use near_sdk::{env, json_types::U128};
use router_wasm_bindings::ethabi::{decode, encode, ethereum_types::U256, ParamType, Token};

#[test]
fn test_ping_to_dest() {
    let gateway: AccountId = env::predecessor_account_id();
    let mut ping_pong: PingPong = PingPong::new(gateway.clone());

    let dest_gas_limit: u64 = 1000000;
    let dest_gas_price: u64 = 100000000000;
    let ack_gas_limit: u64 = 100000000000000;
    let ack_gas_price: u64 = 1000000000;
    let relayer_fees: U128 = U128::from(1000000000000000);
    let ack_type: u8 = 1;
    let is_read_call: bool = false;
    let asm_address: String = "".to_string();

    let mut request_metadata: Vec<u8> = vec![];

    request_metadata.append(&mut dest_gas_limit.to_be_bytes().to_vec());
    request_metadata.append(&mut dest_gas_price.to_be_bytes().to_vec());
    request_metadata.append(&mut ack_gas_limit.to_be_bytes().to_vec());
    request_metadata.append(&mut ack_gas_price.to_be_bytes().to_vec());
    request_metadata.append(&mut u128::from(relayer_fees).to_be_bytes().to_vec());
    request_metadata.append(&mut ack_type.to_be_bytes().to_vec());

    if is_read_call {
        request_metadata.append(&mut vec![1]);
    } else {
        request_metadata.append(&mut vec![0]);
    }
    request_metadata.append(&mut asm_address.as_bytes().to_vec());

    ping_pong.i_ping(
        "80001".to_string(),
        "shivam.near".to_string(),
        "hello".to_string(),
        request_metadata,
        "shivam".to_string()
    );
}

#[test]
fn test_ping_from_source() {
    let gateway: AccountId = env::predecessor_account_id();
    let mut ping_pong: PingPong = PingPong::new(gateway.clone());

    let message: String = String::from("hello");

    let dest_gas_limit: u64 = 1000000;
    let dest_gas_price: u64 = 100000000000;
    let ack_gas_limit: u64 = 100000000000000;
    let ack_gas_price: u64 = 1000000000;
    let relayer_fees: U128 = U128::from(1000000000000000);
    let ack_type: u8 = 1;
    let is_read_call: bool = false;
    let asm_address: String = "".to_string();

    let mut request_metadata: Vec<u8> = vec![];

    request_metadata.append(&mut dest_gas_limit.to_be_bytes().to_vec());
    request_metadata.append(&mut dest_gas_price.to_be_bytes().to_vec());
    request_metadata.append(&mut ack_gas_limit.to_be_bytes().to_vec());
    request_metadata.append(&mut ack_gas_price.to_be_bytes().to_vec());
    request_metadata.append(&mut u128::from(relayer_fees).to_be_bytes().to_vec());
    request_metadata.append(&mut ack_type.to_be_bytes().to_vec());

    if is_read_call {
        request_metadata.append(&mut vec![1]);
    } else {
        request_metadata.append(&mut vec![0]);
    }
    request_metadata.append(&mut asm_address.as_bytes().to_vec());

    ping_pong.i_ping(
        "80001".to_string(),
        "shivam.near".to_string(),
        "hello".to_string(),
        request_metadata,
        "shivam".to_string()
    );

    let request_id: u64 = ping_pong.get_current_request_id();

    let request_id_token: Token = Token::Uint(U256::from(request_id.clone()));
    let message_token: Token = Token::String(message.clone());
    let packet: Vec<u8> = encode(&[request_id_token, message_token]);

    ping_pong.i_receive(
        "hello".to_string(),
        packet,
        "80001".to_string(),
    );

    let ping_from_source = ping_pong.get_ping_from_source("80001".to_string(), request_id);
    assert_eq!(ping_from_source, message);
}

#[test]
fn test_crosstalk_ack() {
    let gateway: AccountId = env::predecessor_account_id();
    let mut ping_pong: PingPong = PingPong::new(gateway.clone());

    let message: String = String::from("hello");
    let request_id: u64 = 1;

    let request_id_token: Token = Token::Uint(U256::from(request_id.clone()));
    let message_token: Token = Token::String(message.clone());
    let payload: Vec<u8> = encode(&[request_id_token, message_token]);

    let request_identifier: U128 = U128::from(1);
    let exec_flags: bool = true;
    let exec_data: Vec<u8> = payload;

    ping_pong.i_ack(
        request_identifier,
        exec_flags,
        exec_data,
    );

    let ack_from_destination = ping_pong.get_ack_from_destination(request_id);
    assert_eq!(ack_from_destination, message);
}

#[test]
fn get_request_metadata() {
    let dest_gas_limit: u64 = 1000000;
    let dest_gas_price: u64 = 100000000000;
    let ack_gas_limit: u64 = 100000000000000;
    let ack_gas_price: u64 = 1000000000;
    let relayer_fees: U128 = U128::from(1000000000000000);
    let ack_type: u8 = 1;
    let is_read_call: bool = false;
    let asm_address: String = "".to_string();

    let mut request_metadata: Vec<u8> = vec![];

    request_metadata.append(&mut dest_gas_limit.to_be_bytes().to_vec());
    request_metadata.append(&mut dest_gas_price.to_be_bytes().to_vec());
    request_metadata.append(&mut ack_gas_limit.to_be_bytes().to_vec());
    request_metadata.append(&mut ack_gas_price.to_be_bytes().to_vec());
    request_metadata.append(&mut u128::from(relayer_fees).to_be_bytes().to_vec());
    request_metadata.append(&mut ack_type.to_be_bytes().to_vec());

    if is_read_call {
        request_metadata.append(&mut vec![1]);
    } else {
        request_metadata.append(&mut vec![0]);
    }
    request_metadata.append(&mut asm_address.as_bytes().to_vec());

    println!("Request Metadata: {:?}", request_metadata);
}

#[test]
fn abi_decode() {
    let data = hex
        ::decode(
            "00000000002dc6c0000000000000000000002d79883d20000000000000000000000000000000000000000000000000000100"
        )
        .unwrap();
    println!("{:?}", data);
    // let param_vec: Vec<ParamType> = vec![ParamType::String, ParamType::Bool];

    // let token_vec: Vec<Token> = match decode(&param_vec, &data) {
    //     Ok(data) => data,
    //     Err(_) => env::panic_str("not able to decode the payload"),
    // };

    // let hello_string: String = token_vec[0].clone().into_string().unwrap();
    // let to_revert: bool = token_vec[1].clone().into_bool().unwrap();

    // println!("hello: {}", hello_string);
    // println!("To revert: {}", to_revert);
}

#[test]
fn abi_decode_with_array() {
    let sample_vec: Vec<u8> = vec![
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 160, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    println!(
        "{:?}",
        decode(
            &[
                ParamType::Array(Box::new(ParamType::Bool)),
                ParamType::Array(Box::new(ParamType::Bytes)),
            ],
            &sample_vec
        )
    );
}

#[test]
fn abi_decode_request_packet() {
    let request_packet: Vec<u8> = vec![0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,65,114,111,117,116,101,114,49,100,110,121,48,55,106,118,110,107,101,109,118,53,115,110,100,118,97,119,110,48,120,117,114,120,121,53,55,112,55,119,104,110,57,103,112,120,109,102,115,104,113,56,53,114,108,99,116,115,122,103,115,115,113,120,122,54,104,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,71,13,228,223,130,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,64,123,153,57,15,28,109,145,134,104,105,58,54,185,111,122,226,72,163,79,108,44,63,32,248,200,126,4,239,177,24,163,165,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,34,117,115,100,99,45,50,46,114,111,117,116,101,114,112,114,111,116,111,99,111,108,97,108,112,104,97,46,116,101,115,116,110,101,116,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,114,111,117,116,101,114,112,114,111,116,111,99,111,108,97,108,112,104,97,46,116,101,115,116,110,101,116,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,34,117,115,100,99,45,50,46,114,111,117,116,101,114,112,114,111,116,111,99,111,108,97,108,112,104,97,46,116,101,115,116,110,101,116,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,224,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,15,168,120,26,131,228,104,38,98,27,59,192,148,234,42,2,18,231,27,35,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,15,168,120,26,131,228,104,38,98,27,59,192,148,234,42,2,18,231,27,35,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,237,254,224,46,252,203,197,161,149,181,13,233,50,219,118,3,132,203,128,69,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];

    let tokens = decode(
        &[
            ParamType::String,
            ParamType::Bytes,
        ],
        &request_packet
    ).unwrap();

    let packet: Vec<u8> = tokens[1].clone().into_bytes().unwrap();

    let decoded = decode(&[ParamType::Uint(64)], &packet).unwrap();
    println!("{:?}", decoded);
}

#[test]
fn hex_decode() {
    let data = hex
        ::decode(
            "00000000000F4240000000003B9ACA0000000000000000000000000000000000000000000000000000000000000000000000"
        )
        .unwrap();
    println!("{:?}", data);
}

'''
'''--- near/deploy.sh ---
#!/bin/sh

sh build.sh

cd deployment
npx ts-node scripts/deployPingPong.ts

'''
'''--- near/deployment/chains.json ---
{
  "alpha": {
    "80001": {
      "pingPong": "0xca2C7E0018CBACf6358308155f745D2Efa22b42f",
      "chainType": "EVM"
    },
    "43113": {
      "pingPong": "0x35Ac54Ee315042a74819e8EF6Fd381C951A9836f",
      "chainType": "EVM"
    },
    "router_9605-1": {
      "pingPong": "",
      "chainType": "ROUTER"
    }
  },
  "testnet": {
    "80001": {
      "pingPong": "0xc44809443091cea7E5531D565834Ea9Ac9931A3B",
      "chainType": "EVM"
    },
    "43113": {
      "pingPong": "0xD28582a0589003ceA101bC32835654ee7b7AE135",
      "chainType": "EVM"
    },
    "router_9601-1": {
      "pingPong": "router10kkn698hpzm07kj0klhj3hrkxjsmngj9598esypm5kh9hfpealpqu3vful",
      "chainType": "ROUTER"
    }
  }
}

'''
'''--- near/deployment/deployment.json ---
{
  "testnet": {
    "chain_id": "near-testnet",
    "gateway": "gateway-1687862701420.routerprotocol.testnet",
    "feePayer": "0xAb771C0e0C33b8794BdE3a79568D829De399C094",
    "pingPong": "ping-pong-1687870174098.routerprotocol.testnet"
  }
}

'''
'''--- near/deployment/package.json ---
{
  "name": "near-voyager-scripts",
  "version": "1.0.0",
  "description": "Near Chain Voyager Contract Scripts for Router Protocol",
  "repository": "https://github.com/router-protocol/voyager.git",
  "author": "Shivam Agrawal <shivam@routerprotocol.com>",
  "license": "MIT",
  "scripts": {},
  "dependencies": {
    "@types/fs-extra": "^11.0.1",
    "bn.js": "^5.2.1",
    "dotenv": "16.0.3",
    "fs-extra": "^11.1.1",
    "near-api-js": "^2.1.3",
    "ts-node": "^10.9.1",
    "typescript": "5.0.4",
    "@types/bn.js": "5.1.1",
    "@routerprotocol/router-chain-sdk-ts": "0.8.63"
  }
}

'''
'''--- near/deployment/scripts/approveFeePayer.ts ---
import {
  ChainRestAuthApi,
  createTransaction,
  BigNumberInBase,
  PrivateKey,
  TxRestClient,
  privateKeyToPublicKeyBase64,
  MsgApproveFeepayerRequest,
  TxClientSimulateResponse,
  TxGrpcClient,
} from "@routerprotocol/router-chain-sdk-ts";
import dotenv from "dotenv";
import fs from "fs-extra";
import { getChainInfo, getEndpoints } from "./utils";
dotenv.config();

const endpoints = getEndpoints();
const chainInfo = getChainInfo();
export async function approve() {
  let srcChainId: string = "";
  let dappAddress: string = "";
  try {
    const routerNetwork = process.env.ROUTER_NETWORK;
    if (!routerNetwork) {
      throw new Error("Please add ROUTER_NETWORK to .env file");
    }

    let nearNetwork = "testnet";
    if (routerNetwork == "mainnet") {
      nearNetwork = "mainnet";
    }

    const data = await fs.readJSONSync("deployment.json");

    if (!data[routerNetwork]) {
      data[routerNetwork] = {};
    }

    srcChainId = data[routerNetwork].chain_id;
    dappAddress = data[routerNetwork].pingPong;
    const privateKeyHash = process.env.FEE_PAYER_PRIVATE_KEY;

    if (!privateKeyHash) {
      throw new Error("Please set your FEE_PAYER_PRIVATE_KEY in the .env file");
    }

    const privateKey = PrivateKey.fromPrivateKey(privateKeyHash);

    const alice = privateKey.toBech32();

    const message = MsgApproveFeepayerRequest.fromJSON({
      feepayer: alice,
      chainid: srcChainId.trim(),
      dappaddresses: dappAddress.trim(),
    });

    const isApprovalComplete = await sendFeeApprovalTx(message, alice);
    if (isApprovalComplete) {
      console.log("Fee payer approval complete for ", srcChainId, dappAddress);
    }
  } catch (e) {
    console.error(
      "Fee payer approval failed for src chain and dapp address",
      srcChainId,
      dappAddress
    );
    console.log("error: ", e);
  }
}

async function sendFeeApprovalTx(
  message: MsgApproveFeepayerRequest,
  alice: string
) {
  try {
    const chainId = chainInfo.chainId;

    const privateKeyHash = process.env.FEE_PAYER_PRIVATE_KEY;

    if (!privateKeyHash) {
      throw new Error("Please set your FEE_PAYER_PRIVATE_KEY in the .env file");
    }

    const privateKey = PrivateKey.fromPrivateKey(privateKeyHash);

    const publicKey = privateKeyToPublicKeyBase64(
      Buffer.from(privateKeyHash, "hex")
    );

    const restClient = new TxRestClient(endpoints.lcdEndpoint);
    const grpcClient = new TxGrpcClient(endpoints.grpcEndpoint);

    /** Get Faucet Accounts details */
    const aliceAccount = await new ChainRestAuthApi(
      endpoints.lcdEndpoint
    ).fetchAccount(alice);

    let simulationResponse: TxClientSimulateResponse;
    {
      let { txRaw } = createTransaction({
        message: message.toDirectSign(),
        memo: "",
        pubKey: publicKey,
        sequence: parseInt(aliceAccount.account.base_account.sequence, 10),
        accountNumber: parseInt(
          aliceAccount.account.base_account.account_number,
          10
        ),
        chainId: chainId,
      });

      txRaw.setSignaturesList([""]);
      simulationResponse = await grpcClient.simulate(txRaw);
    }

    let amount = new BigNumberInBase(600000001)
      .times(parseInt((simulationResponse.gasInfo.gasUsed * 1.3).toString()))
      .toString();
    let gas = parseInt(
      (simulationResponse.gasInfo.gasUsed * 1.3).toString()
    ).toString();

    const { signBytes, txRaw } = createTransaction({
      message: message.toDirectSign(),
      memo: "",
      fee: {
        amount: [
          {
            amount: amount,
            denom: "route",
          },
        ],
        gas: gas,
      },
      pubKey: publicKey,
      sequence: parseInt(aliceAccount.account.base_account.sequence, 10),
      accountNumber: parseInt(
        aliceAccount.account.base_account.account_number,
        10
      ),
      chainId: chainId,
    });

    /** Sign transaction */
    const signature = await privateKey.sign(signBytes);

    /** Append Signatures */
    txRaw.setSignaturesList([signature]);

    /** Broadcast transaction */
    let txxResponse = await restClient.broadcast(txRaw);
    await restClient.waitTxBroadcast(txxResponse.txhash);

    return true;
  } catch (e) {
    console.error("Error in fee payer approval: ", e);
    return false;
  }
}

approve();

'''
'''--- near/deployment/scripts/deployPingPong.ts ---
import fs from "fs-extra";
import dotenv from "dotenv";
import * as nearAPI from "near-api-js";
import BN from "bn.js";
import { approve } from "./approveFeePayer";
import { getGateway } from "./utils";
dotenv.config();

export async function deployPingPong() {
  try {
    const routerNetwork = process.env.ROUTER_NETWORK;
    if (!routerNetwork) {
      throw new Error("Please add ROUTER_NETWORK to .env file");
    }

    let nearNetwork = "testnet";
    if (routerNetwork == "mainnet") {
      nearNetwork = "mainnet";
    }

    const signerAddress = process.env.NEAR_SIGNER_ADDRESS;
    if (!signerAddress) {
      throw new Error("Please add NEAR_SIGNER_ADDRESS to .env file");
    }

    const { keyStores, KeyPair, connect } = nearAPI;

    const homedir = require("os").homedir();
    const CREDENTIALS_DIR = ".near-credentials";
    const credentialsPath = require("path").join(homedir, CREDENTIALS_DIR);

    const myKeyStore = new keyStores.UnencryptedFileSystemKeyStore(
      credentialsPath
    );

    if ((await myKeyStore.getKey(nearNetwork, signerAddress)) == null) {
      const privateKey = process.env.NEAR_PRIVATE_KEY;
      if (!privateKey) {
        throw new Error("Please add NEAR_PRIVATE_KEY to .env file");
      }

      // creates a public / private key pair using the provided private key
      const keyPair = KeyPair.fromString(privateKey);

      // adds the keyPair you created to keyStore
      await myKeyStore.setKey(nearNetwork, signerAddress, keyPair);
    }

    const connectionConfig = {
      networkId: nearNetwork,
      keyStore: myKeyStore, // first create a key store
      nodeUrl: `https://rpc.${nearNetwork}.near.org`,
      walletUrl: `https://wallet.${nearNetwork}.near.org`,
      helperUrl: `https://helper.${nearNetwork}.near.org`,
      explorerUrl: `https://explorer.${nearNetwork}.near.org`,
    };
    const nearConnection = await connect(connectionConfig);

    const account = await nearConnection.account(signerAddress);

    const timestamp = Date.now();
    const pingPongKeyPair = nearAPI.KeyPair.fromRandom("ed25519");
    const pingPongAddress = "ping-pong-" + timestamp + "." + signerAddress;

    await account.createAccount(
      pingPongAddress, // new account name
      pingPongKeyPair.getPublicKey(), // public key for new account
      new BN("20000000000000000000000000") // initial balance for new account in yoctoNEAR
    );
    const pingPongAccount = await nearConnection.account(pingPongAddress);

    await myKeyStore.setKey(nearNetwork, pingPongAddress, pingPongKeyPair);

    console.log("Deploying Ping Pong started");

    const C11 = await pingPongAccount.deployContract(
      fs.readFileSync("../artifacts/ping_pong.wasm")
    );

    console.log("Ping Pong deployment status: ", C11.status);
    console.log("Deployed Ping Pong to ", pingPongAddress);

    console.log("Deploying Gateway started");

    console.log("Storing data started");
    const data = await fs.readJSONSync("deployment.json");

    if (!data[routerNetwork]) {
      data[routerNetwork] = {};
    }

    data[routerNetwork].pingPong = pingPongAddress;

    fs.writeJSONSync("deployment.json", data);
    console.log("Storing data ended");

    const pingPongContract: any = new nearAPI.Contract(
      account,
      pingPongAddress,
      {
        changeMethods: ["new", "set_dapp_metadata"], // your smart-contract has a function `my_smart_contract_function`
        viewMethods: [],
      }
    );

    let gateway = await getGateway();
    if (gateway == "") {
      gateway = data[routerNetwork].gateway;
    }

    console.log("Initializing PingPong contract started");
    await pingPongContract.new({
      args: {
        gateway,
      },
      gas: 50000000000000,
    });
    console.log("Initializing PingPong contract contract ended");

    console.log("Setting fee payer address started");
    await pingPongContract.set_dapp_metadata({
      args: {
        fee_payer_address: data[routerNetwork].feePayer,
      },
      gas: 50000000000000,
    });
    console.log("Setting fee payer address ended");

    console.log("Waiting for a minute started for approving fee payer");
    await new Promise((r) => setTimeout(r, 60000));
    console.log("Waiting for a minute ended for approving fee payer");

    console.log("Providing fee payer approval started");
    await approve(data[routerNetwork].chainId, pingPongAddress);
    console.log("Providing fee payer approval ended");
  } catch (e) {
    console.log(e);
  }
}

deployPingPong();

'''
'''--- near/deployment/scripts/sendPing.ts ---
import fs from "fs-extra";
import dotenv from "dotenv";
import * as nearAPI from "near-api-js";
dotenv.config();

const requestMetadata: { [key: string]: Array<number> } = {
  EVM: [
    0, 0, 0, 0, 0, 15, 66, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45, 121, 136, 61,
    32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 0,
  ],
  ROUTER: [
    0, 0, 0, 0, 0, 45, 198, 192, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45, 121, 136, 61,
    32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 0,
  ],
};

export async function sendPing(
  destChainId: string,
  str: string,
  recipient: string
) {
  console.log("Sending Ping started");

  const routerNetwork = process.env.ROUTER_NETWORK;
  if (!routerNetwork) {
    throw new Error("Please add ROUTER_NETWORK to .env file");
  }

  const data = await fs.readJSONSync("deployment.json");
  const pingPongAddr = data[routerNetwork].pingPong;

  const destFile = await fs.readJSONSync("chains.json");
  const destContractAddress = destFile[routerNetwork][destChainId].pingPong;
  const destChainType = destFile[routerNetwork][destChainId].chainType;

  let nearNetwork = "testnet";
  if (routerNetwork == "mainnet") {
    nearNetwork = "mainnet";
  }

  const signerAddress = process.env.NEAR_SIGNER_ADDRESS;
  if (!signerAddress) {
    throw new Error("Please add NEAR_SIGNER_ADDRESS to .env file");
  }

  const { keyStores, KeyPair, connect } = nearAPI;

  const homedir = require("os").homedir();
  const CREDENTIALS_DIR = ".near-credentials";
  const credentialsPath = require("path").join(homedir, CREDENTIALS_DIR);

  const myKeyStore = new keyStores.UnencryptedFileSystemKeyStore(
    credentialsPath
  );

  if ((await myKeyStore.getKey(nearNetwork, signerAddress)) == null) {
    const privateKey = process.env.NEAR_PRIVATE_KEY;
    if (!privateKey) {
      throw new Error("Please add NEAR_PRIVATE_KEY to .env file");
    }

    // creates a public / private key pair using the provided private key
    const keyPair = KeyPair.fromString(privateKey);

    // adds the keyPair you created to keyStore
    await myKeyStore.setKey(nearNetwork, signerAddress, keyPair);
  }

  const connectionConfig = {
    networkId: nearNetwork,
    keyStore: myKeyStore, // first create a key store
    nodeUrl: `https://rpc.${nearNetwork}.near.org`,
    walletUrl: `https://wallet.${nearNetwork}.near.org`,
    helperUrl: `https://helper.${nearNetwork}.near.org`,
    explorerUrl: `https://explorer.${nearNetwork}.near.org`,
  };
  const nearConnection = await connect(connectionConfig);

  const account = await nearConnection.account(signerAddress);

  const pingPongInstance: any = new nearAPI.Contract(account, pingPongAddr, {
    changeMethods: ["i_ping"],
    viewMethods: [],
  });

  const tx = await pingPongInstance.i_ping({
    args: {
      dest_chain_id: destChainId,
      destination_contract_address: destContractAddress,
      str: str,
      request_metadata: requestMetadata[destChainType],
      recipient: recipient,
    },
    gas: 100000000000000,
    amount: 1,
  });

  console.log(tx);
}

sendPing("43113", "Hello", "0x95810b6EC89149946e522439303bF4330dD0dd40");

'''
'''--- near/deployment/scripts/utils.ts ---
import {
  NetworkEndpoints,
  getEndpointsForNetwork,
  Network,
  getChainInfoForNetwork,
  ChainInfo,
  ChainGrpcMultiChainApi,
} from "@routerprotocol/router-chain-sdk-ts";
import dotenv from "dotenv";
dotenv.config();

const env = process.env.ROUTER_NETWORK;
let endpoints: NetworkEndpoints;
let chainInfo: ChainInfo;

if (env == "alpha") {
  endpoints = getEndpointsForNetwork(Network.AlphaDevnet);
  chainInfo = getChainInfoForNetwork(Network.AlphaDevnet);
} else if (env == "devnet") {
  endpoints = getEndpointsForNetwork(Network.Devnet);
  chainInfo = getChainInfoForNetwork(Network.Devnet);
} else if (env == "testnet") {
  endpoints = getEndpointsForNetwork(Network.Testnet);
  chainInfo = getChainInfoForNetwork(Network.Testnet);
} else if (env == "mainnet") {
  endpoints = getEndpointsForNetwork(Network.Mainnet);
  chainInfo = getChainInfoForNetwork(Network.Mainnet);
}

let nearChainId = "near-testnet";
if (env == "mainnet") {
  nearChainId = "near";
}

export function getEndpoints() {
  return endpoints;
}

export function getChainInfo() {
  return chainInfo;
}

export async function getGateway(
  chainId: String = nearChainId
): Promise<String> {
  try {
    const grpcEndpoint = endpoints.grpcEndpoint;
    const client = new ChainGrpcMultiChainApi(grpcEndpoint);

    const contractConfigs = await client.fetchAllContractConfig();
    const gateway = contractConfigs.contractconfigList.filter(
      (e) => e.chainid == chainId && e.contracttype == 0
    );

    return gateway[0].contractaddress;
  } catch (e) {
    console.log("Error in getting gateway from grpc: ", e);
    return "";
  }
}

'''
'''--- near/package.json ---
{
  "name": "router-gateway-contract",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "build": "sh build.sh",
    "deploy": "sh deploy.sh",
    "test": "cd gateway-upgradeable && cargo test"
  },
  "devDependencies": {
    "near-cli": "^3.3.0"
  },
  "dependencies": {}
}

'''