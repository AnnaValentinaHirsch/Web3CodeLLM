*GitHub Repository "nataliebrooks/near-collect"*

'''--- README.md ---
Collect
==========
for the common good.

[![Build Status](https://travis-ci.com/near-examples/guest-book.svg?branch=master)](https://travis-ci.com/near-examples/guest-book)

[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/near-examples/guest-book)

<!-- MAGIC COMMENT: DO NOT DELETE! Everything above this line is hidden on NEAR Examples page -->

Sign in with [NEAR] and add a message to the guest book! A starter app built with an [AssemblyScript] backend and a [React] frontend.

Quick Start
===========

To run this project locally:

1. Prerequisites: Make sure you have Node.js ≥ 12 installed (https://nodejs.org), then use it to install [yarn]: `npm install --global yarn` (or just `npm i -g yarn`)
2. Run the local development server: `yarn && yarn dev` (see `package.json` for a
   full list of `scripts` you can run with `yarn`)

Now you'll have a local development environment backed by the NEAR TestNet! Running `yarn dev` will tell you the URL you can visit in your browser to see the app.

Exploring The Code
==================

1. The backend code lives in the `/assembly` folder. This code gets deployed to
   the NEAR blockchain when you run `yarn deploy:contract`. This sort of
   code-that-runs-on-a-blockchain is called a "smart contract" – [learn more
   about NEAR smart contracts][smart contract docs].
2. The frontend code lives in the `/src` folder.
   [/src/index.html](/src/index.html) is a great place to start exploring. Note
   that it loads in `/src/index.js`, where you can learn how the frontend
   connects to the NEAR blockchain.
3. Tests: there are different kinds of tests for the frontend and backend. The
   backend code gets tested with the [asp] command for running the backend
   AssemblyScript tests, and [jest] for running frontend tests. You can run
   both of these at once with `yarn test`.

Both contract and client-side code will auto-reload as you change source files.

Deploy
======

Every smart contract in NEAR has its [own associated account][NEAR accounts]. When you run `yarn dev`, your smart contracts get deployed to the live NEAR TestNet with a throwaway account. When you're ready to make it permanent, here's how.

Step 0: Install near-cli
--------------------------

You need near-cli installed globally. Here's how:

    npm install --global near-cli

This will give you the `near` [CLI] tool. Ensure that it's installed with:

    near --version

Step 1: Create an account for the contract
------------------------------------------

Visit [NEAR Wallet] and make a new account. You'll be deploying these smart contracts to this new account.

Now authorize NEAR CLI for this new account, and follow the instructions it gives you:

    near login

Step 2: set contract name in code
---------------------------------

Modify the line in `src/config.js` that sets the account name of the contract. Set it to the account id you used above.

    const CONTRACT_NAME = process.env.CONTRACT_NAME || 'your-account-here!'

Step 3: change remote URL if you cloned this repo 
-------------------------

Unless you forked this repository you will need to change the remote URL to a repo that you have commit access to. This will allow auto deployment to GitHub Pages from the command line.

1) go to GitHub and create a new repository for this project
2) open your terminal and in the root of this project enter the following:

    $ `git remote set-url origin https://github.com/YOUR_USERNAME/YOUR_REPOSITORY.git`

Step 4: deploy!
---------------

One command:

    yarn deploy

As you can see in `package.json`, this does two things:

1. builds & deploys smart contracts to NEAR TestNet
2. builds & deploys frontend code to GitHub using [gh-pages]. This will only work if the project already has a repository set up on GitHub. Feel free to modify the `deploy` script in `package.json` to deploy elsewhere.

  [NEAR]: https://near.org/
  [yarn]: https://yarnpkg.com/
  [AssemblyScript]: https://www.assemblyscript.org/introduction.html
  [React]: https://reactjs.org
  [smart contract docs]: https://docs.near.org/docs/develop/contracts/overview
  [asp]: https://www.npmjs.com/package/@as-pect/cli
  [jest]: https://jestjs.io/
  [NEAR accounts]: https://docs.near.org/docs/concepts/account
  [NEAR Wallet]: https://wallet.near.org
  [near-cli]: https://github.com/near/near-cli
  [CLI]: https://www.w3schools.com/whatis/whatis_cli.asp
  [create-near-app]: https://github.com/near/create-near-app
  [gh-pages]: https://github.com/tschaub/gh-pages

'''
'''--- babel.config.js ---
module.exports = {
  presets: ['@babel/preset-env', '@babel/preset-react']
}

'''
'''--- market-contract/Cargo.toml ---
[package]
name = "market"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "=4.0.0-pre.4"
serde_json = "1.0"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- market-contract/README.md ---
# Market Contract

This contract contains the logic to create and manage orders

## Deploying the Contract

Build the contract:
./build.sh

This will compile the contract into a wasm you can find in ./res

Test contract (TODO)

cargo test -- --no-capture

Quick deploy:

cd ..
near dev-deploy --wasmFile ./out/market.wasm

This will print out a dev account contract was deployed to.
Set it to CONTRACT_NAME
source neardev/dev-account.env

Initialize the contract:

near call $CONTRACT_NAME new '{"owner_id": "'$CONTRACT_NAME'"}' --accountId $CONTRACT_NAME

Now fun stuff:

Login to your near testnet account

near login

export ACCOUNT_ID={{WALLET_ID}}

near call $CONTRACT_NAME create_order '{"requester_id": "'$ACCOUNT_ID'", "token_id": "9999"}' --accountId $ACCOUNT_ID --depositYocto 1

near view $CONTRACT_NAME get_supply_orders

near view $CONTRACT_NAME get_supply_by_requester_id '{"requester_id": "'$ACCOUNT_ID'"}'

near view $CONTRACT_NAME get_orders_by_requester '{"requester_id": "'$ACCOUNT_ID'", "limit": 5}'

'''
'''--- market-contract/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../out
cp target/wasm32-unknown-unknown/release/*.wasm ../out/market.wasm

'''
'''--- market-contract/src/events.rs ---
use std::fmt;

use near_sdk::serde::{Deserialize, Serialize};

/// Enum that represents the data type of the EventLog.
/// The enum can either be an NftMint or an NftTransfer.
#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[serde(crate = "near_sdk::serde")]
#[non_exhaustive]
pub enum EventLogVariant {
    OrderLog(Vec<OrderLog>)
}

/// Interface to capture data about an event
///
/// Arguments:
/// * `standard`: name of standard e.g. nep171
/// * `version`: e.g. 1.0.0
/// * `event`: associate event data
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct EventLog {
    pub standard: String,
    pub version: String,

    // `flatten` to not have "event": {<EventLogVariant>} in the JSON, just have the contents of {<EventLogVariant>}.
    #[serde(flatten)]
    pub event: EventLogVariant,
}

impl fmt::Display for EventLog {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!(
            "EVENT_JSON:{}",
            &serde_json::to_string(self).map_err(|_| fmt::Error)?
        ))
    }
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct OrderLog {
    pub status: String,
    pub order_id: String,
    pub token_id: String,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

'''
'''--- market-contract/src/external.rs ---
use crate::*;

/// external contract calls

//initiate a cross contract call to the nft contract. This will transfer the token to the buyer and return
//a payout object used for the market to distribute funds to the appropriate accounts.
#[ext_contract(ext_contract)]
trait ExtContract {
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId, //purchaser (person to transfer the NFT to)
        token_id: TokenId, //token ID to transfer
        approval_id: u64, //market contract's approval ID in order to transfer the token on behalf of the owner
        memo: String, //memo (to include some context)
        /*
            the price that the token was purchased for. This will be used in conjunction with the royalty percentages
            for the token in order to determine how much money should go to which account. 
        */
        balance: U128,
        //the maximum amount of accounts the market can payout at once (this is limited by GAS)
		max_len_payout: u32,
    );
}
'''
'''--- market-contract/src/internal.rs ---
use crate::*;

//used to generate a unique prefix in our storage collections (this is to avoid data collisions)
pub(crate) fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    //get the default hash
    let mut hash = CryptoHash::default();
    //we hash the account ID and return it
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

// impl Contract {
//     //internal method for removing a sale from the market. This returns the previously removed sale object
//     pub(crate) fn internal_remove_sale(
//         &mut self,
//         nft_contract_id: AccountId,
//         token_id: TokenId,
//     ) -> Sale {
//         //get the unique sale ID (contract + DELIMITER + token ID)
//         let contract_and_token_id = format!("{}{}{}", &nft_contract_id, DELIMETER, token_id);
//         //get the sale object by removing the unique sale ID. If there was no sale, panic
//         let sale = self.sales.remove(&contract_and_token_id).expect("No sale");

//         //get the set of sales for the sale's owner. If there's no sale, panic. 
//         let mut by_owner_id = self.by_owner_id.get(&sale.owner_id).expect("No sale by_owner_id");
//         //remove the unique sale ID from the set of sales
//         by_owner_id.remove(&contract_and_token_id);
        
//         //if the set of sales is now empty after removing the unique sale ID, we simply remove that owner from the map
//         if by_owner_id.is_empty() {
//             self.by_owner_id.remove(&sale.owner_id);
//         //if the set of sales is not empty after removing, we insert the set back into the map for the owner
//         } else {
//             self.by_owner_id.insert(&sale.owner_id, &by_owner_id);
//         }

//         //get the set of token IDs for sale for the nft contract ID. If there's no sale, panic. 
//         let mut by_nft_contract_id = self
//             .by_nft_contract_id
//             .get(&nft_contract_id)
//             .expect("No sale by nft_contract_id");
        
//         //remove the token ID from the set 
//         by_nft_contract_id.remove(&token_id);
        
//         //if the set is now empty after removing the token ID, we remove that nft contract ID from the map
//         if by_nft_contract_id.is_empty() {
//             self.by_nft_contract_id.remove(&nft_contract_id);
//         //if the set is not empty after removing, we insert the set back into the map for the nft contract ID
//         } else {
//             self.by_nft_contract_id
//                 .insert(&nft_contract_id, &by_nft_contract_id);
//         }

//         //return the sale object
//         sale
//     }
// }

'''
'''--- market-contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::{U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    assert_one_yocto, env, ext_contract, near_bindgen, AccountId, Balance, Gas, PanicOnDefault,
    CryptoHash, BorshStorageKey,
};
use std::collections::HashMap;

use crate::external::*;
use crate::internal::*;
use crate::events::*;
// use crate::sale::*;
use crate::order::*;
use near_sdk::env::STORAGE_PRICE_PER_BYTE;

mod external;
mod internal;
// mod nft_callbacks;
// mod sale;
mod order;
mod order_flow;
mod order_views;
mod events;
// mod sale_views;

//GAS constants to attach to calls
// const GAS_FOR_ROYALTIES: Gas = Gas(115_000_000_000_000);
// const GAS_FOR_NFT_TRANSFER: Gas = Gas(15_000_000_000_000);

// //constant used to attach 0 NEAR to a call
// const NO_DEPOSIT: Balance = 0;

// //the minimum storage to have a sale on the contract.
// const STORAGE_PER_SALE: u128 = 1000 * STORAGE_PRICE_PER_BYTE;

//every sale will have a unique ID which is `CONTRACT + DELIMITER + TOKEN_ID`
static DELIMETER: &str = ".";

//Creating custom types to use within the contract. This makes things more readable. 
pub type SalePriceInYoctoNear = U128;
pub type TokenId = String;
pub type FungibleTokenId = AccountId;
pub type RequesterAndTokenId = String;
//defines the payout type we'll be parsing from the NFT contract as a part of the royalty standard.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: HashMap<AccountId, U128>,
} 

//main contract struct to store all the information
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    //keep track of the owner of the contract
    pub owner_id: AccountId,

    /*
        to keep track of the orders, we map the RequesterAndTokenId to a Order. 
        the RequesterAndTokenId is the unique identifier for every order. It is made
        up of the `requester ID + DELIMITER + token ID`
    */
    pub orders: UnorderedMap<RequesterAndTokenId, Order>,

    //keep track of all the Order IDs requested by an account ID
    pub by_requester: LookupMap<AccountId, UnorderedSet<RequesterAndTokenId>>,

    pub by_requestee: LookupMap<AccountId, UnorderedSet<RequesterAndTokenId>>,
    pub by_transporter: LookupMap<AccountId, UnorderedSet<RequesterAndTokenId>>,

    // /*
    //     to keep track of the sales, we map the ContractAndTokenId to a Sale. 
    //     the ContractAndTokenId is the unique identifier for every sale. It is made
    //     up of the `contract ID + DELIMITER + token ID`
    // */
    // pub sales: UnorderedMap<ContractAndTokenId, Sale>,
    
    // //keep track of all the Sale IDs for every account ID
    // pub by_owner_id: LookupMap<AccountId, UnorderedSet<ContractAndTokenId>>,

    //keep track of all the token IDs for sale for a given contract
    // pub by_nft_contract_id: LookupMap<AccountId, UnorderedSet<TokenId>>,

    //keep track of the storage that accounts have payed
    pub storage_deposits: LookupMap<AccountId, Balance>,
}

/// Helper structure to for keys of the persistent collections.
#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKey {
    Orders,
    ByRequester,
    ByRequesterInner { account_id_hash: CryptoHash },
    ByRequestee,
    ByRequesteeInner { account_id_hash: CryptoHash },
    ByTransporter,
    ByTransporterInner { account_id_hash: CryptoHash },
    // Sales,
    // ByOwnerId,
    // ByOwnerIdInner { account_id_hash: CryptoHash },
    // ByNFTContractId,
    // ByNFTContractIdInner { account_id_hash: CryptoHash },
    // ByNFTTokenType,
    // ByNFTTokenTypeInner { token_type_hash: CryptoHash },
    // FTTokenIds,
    StorageDeposits,
}

#[near_bindgen]
impl Contract {
    /*
        initialization function (can only be called once).
        this initializes the contract with default data and the owner ID
        that's passed in
    */
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        let this = Self {
            //set the owner_id field equal to the passed in owner_id. 
            owner_id,

            //Storage keys are simply the prefixes used for the collections. This helps avoid data collision
            orders: UnorderedMap::new(StorageKey::Orders),
            by_requester: LookupMap::new(StorageKey::ByRequester),
            by_requestee: LookupMap::new(StorageKey::ByRequestee),
            by_transporter: LookupMap::new(StorageKey::ByTransporter),
            // sales: UnorderedMap::new(StorageKey::Sales),
            // by_owner_id: LookupMap::new(StorageKey::ByOwnerId),
            // by_nft_contract_id: LookupMap::new(StorageKey::ByNFTContractId),
            storage_deposits: LookupMap::new(StorageKey::StorageDeposits),
        };

        //return the Contract object
        this
    }

    // //Allows users to deposit storage. This is to cover the cost of storing sale objects on the contract
    // //Optional account ID is to users can pay for storage for other people.
    // #[payable]
    // pub fn storage_deposit(&mut self, account_id: Option<AccountId>) {
    //     //get the account ID to pay for storage for
    //     let storage_account_id = account_id 
    //         //convert the valid account ID into an account ID
    //         .map(|a| a.into())
    //         //if we didn't specify an account ID, we simply use the caller of the function
    //         .unwrap_or_else(env::predecessor_account_id);

    //     //get the deposit value which is how much the user wants to add to their storage
    //     let deposit = env::attached_deposit();

    //     //make sure the deposit is greater than or equal to the minimum storage for a sale
    //     assert!(
    //         deposit >= STORAGE_PER_SALE,
    //         "Requires minimum deposit of {}",
    //         STORAGE_PER_SALE
    //     );

    //     //get the balance of the account (if the account isn't in the map we default to a balance of 0)
    //     let mut balance: u128 = self.storage_deposits.get(&storage_account_id).unwrap_or(0);
    //     //add the deposit to their balance
    //     balance += deposit;
    //     //insert the balance back into the map for that account ID
    //     self.storage_deposits.insert(&storage_account_id, &balance);
    // }

    // //Allows users to withdraw any excess storage that they're not using. Say Bob pays 0.01N for 1 sale
    // //Alice then buys Bob's token. This means bob has paid 0.01N for a sale that's no longer on the marketplace
    // //Bob could then withdraw this 0.01N back into his account. 
    // #[payable]
    // pub fn storage_withdraw(&mut self) {
    //     //make sure the user attaches exactly 1 yoctoNEAR for security purposes.
    //     //this will redirect them to the NEAR wallet (or requires a full access key). 
    //     assert_one_yocto();

    //     //the account to withdraw storage to is always the function caller
    //     let owner_id = env::predecessor_account_id();
    //     //get the amount that the user has by removing them from the map. If they're not in the map, default to 0
    //     let mut amount = self.storage_deposits.remove(&owner_id).unwrap_or(0);
        
    //     //how many sales is that user taking up currently. This returns a set
    //     let sales = self.by_owner_id.get(&owner_id);
    //     //get the length of that set. 
    //     let len = sales.map(|s| s.len()).unwrap_or_default();
    //     //how much NEAR is being used up for all the current sales on the account 
    //     let diff = u128::from(len) * STORAGE_PER_SALE;

    //     //the excess to withdraw is the total storage paid - storage being used up.
    //     amount -= diff;

    //     //if that excess to withdraw is > 0, we transfer the amount to the user.
    //     if amount > 0 {
    //         Promise::new(owner_id.clone()).transfer(amount);
    //     }
    //     //we need to add back the storage being used up into the map if it's greater than 0.
    //     //this is so that if the user had 500 sales on the market, we insert that value here so
    //     //if those sales get taken down, the user can then go and withdraw 500 sales worth of storage.
    //     if diff > 0 {
    //         self.storage_deposits.insert(&owner_id, &diff);
    //     }
    // }

    // /// views
    // //return the minimum storage for 1 sale
    // pub fn storage_minimum_balance(&self) -> U128 {
    //     U128(STORAGE_PER_SALE)
    // }

    // //return how much storage an account has paid for
    // pub fn storage_balance_of(&self, account_id: AccountId) -> U128 {
    //     U128(self.storage_deposits.get(&account_id).unwrap_or(0))
    // }
}

'''
'''--- market-contract/src/nft_callbacks.rs ---
use crate::*;

/// approval callbacks from Orders

/*
    trait that will be used as the callback from the NFT contract. When nft_approve is
    called, it will fire a cross contract call to this marketplace and this is the function
    that is invoked. 
*/
trait NonFungibleTokenApprovalsReceiver {
    fn order_on_accept(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    );
}

//implementation of the trait
#[near_bindgen]
impl NonFungibleTokenApprovalsReceiver for Contract {

    fn order_on_accept(
        &mut self,
        token_id: TokenId,
        requester_id: AccountId,
        approval_id: u64,
        msg: String,
    ) {
        // get the account id of who approved the order
        let order_approver_id = env::predecessor_account_id();
        // get the account id of who created the order
        let order_creator_id = env::signer_account_id();

        //make sure that the signer isn't the predecessor. This is so that we're sure
        //this was called via a cross-contract call
        assert_ne!(
          order_approver_id,
          order_creator_id,
            "order_on_accept should only be called via cross-contract call"
        );
        //make sure the owner ID is the signer. 
        assert_eq!(
          requester_id,
          order_creator_id,
            "Provided requester_id should be same as order_creator_id"
        );

        create_transport_order(order_creator_id, order_approver_id, token_id);
}

'''
'''--- market-contract/src/order.rs ---
use crate::*;
// use near_sdk::promise_result_as_success;

// Person B wants Person A's item
// So Person B creates an order for it

//struct that holds important information about each order on the market
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Order {
    pub requester_id: AccountId,
    pub requestee_id: AccountId,
    pub transporter_id: Option<AccountId>,
    // pub nft_contract_id: String, // nft contract where token was minted... common-good
    pub token_id: String, // token Id of Person A's item
    pub status: String,   // lifecycle status
                          // pub instructions: String, // instructions on how to deliver
}

impl Contract {
    pub fn create_order(&mut self, to: AccountId, from: AccountId, token_id: String) -> Order {
        // TODO : enforce that the order creator has enough storage
        // (to create this request as well as the transfer order)

        let requester_and_token_id = format!("{}{}{}", to, DELIMETER, token_id);

        let order = Order {
            requester_id: to.clone(),
            requestee_id: from.clone(),
            transporter_id: None,
            token_id: token_id.clone(),
            status: "NEW".to_string(),
        };

        //insert the order, but first make sure it doesn't exist
        assert!(
            self.orders
                .insert(&requester_and_token_id, &order)
                .is_none(),
            "Order already exists"
        );
        // insert into more organized sets

        //get the orders by requester ID for the given requester. If there are none, we create a new empty set
        let mut by_requester_set = self.by_requester.get(&to).unwrap_or_else(|| {
            UnorderedSet::new(
                StorageKey::ByRequesterInner {
                    //we get a new unique prefix for the collection by hashing the owner
                    account_id_hash: hash_account_id(&to),
                }
                .try_to_vec()
                .unwrap(),
            )
        });
        //insert the unique sale ID into the set
        by_requester_set.insert(&requester_and_token_id);
        //insert that set back into the collection for the owner
        self.by_requester.insert(&to, &by_requester_set);

        //get the orders by requester ID for the given requester. If there are none, we create a new empty set
        let mut by_requestee_set = self.by_requestee.get(&from).unwrap_or_else(|| {
            UnorderedSet::new(
                StorageKey::ByRequesterInner {
                    //we get a new unique prefix for the collection by hashing the owner
                    account_id_hash: hash_account_id(&from),
                }
                .try_to_vec()
                .unwrap(),
            )
        });
        //insert the unique sale ID into the set
        by_requestee_set.insert(&requester_and_token_id);
        //insert that set back into the collection for the owner
        self.by_requestee.insert(&from, &by_requestee_set);

        let order_log: EventLog = EventLog {
            // Standard name ("nep171").
            standard: "col1".to_string(),
            // Version of the standard ("nft-1.0.0").
            version: "order-1.0.0".to_string(),
            // The data related with the event stored in a vector.
            event: EventLogVariant::OrderLog(vec![OrderLog {
                status: "NEW".to_string(),
                order_id: requester_and_token_id,
                token_id: token_id,
                memo: None
            }]),
        };
        env::log_str(&order_log.to_string());

        order
    }

    pub fn accept_order(
        &mut self,
        requester_id: AccountId,
        token_id: String,
        expected_status: String,
        next_status: String,
        transporter_id: Option<AccountId>
    ) -> Order {

        let requester_and_token_id = format!("{}{}{}", requester_id, DELIMETER, token_id);

        let mut order = self
            .orders
            .get(&requester_and_token_id)
            .expect("No order for token from requester");

        assert_eq!(
            order.status, expected_status,
            "Order's current status is not as expected"
        );

        order.status = next_status.clone();
        order.transporter_id = transporter_id;
        self.orders.insert(&requester_and_token_id, &order);

        let order_log: EventLog = EventLog {
            // Standard name ("nep171").
            standard: "col1".to_string(),
            // Version of the standard ("nft-1.0.0").
            version: "order-1.0.0".to_string(),
            // The data related with the event stored in a vector.
            event: EventLogVariant::OrderLog(vec![OrderLog {
                status: next_status,
                order_id: requester_and_token_id,
                token_id: token_id,
                memo: None
            }]),
        };
        env::log_str(&order_log.to_string());

        return order;
    }

    // //removes a order from the market.
    // #[payable]
    // pub fn remove_order(&mut self, nft_contract_id: AccountId, token_id: String) {
    //     //assert that the user has attached exactly 1 yoctoNEAR (for security reasons)
    //     assert_one_yocto();
    //     //get the order object as the return value from removing the order internally
    //     let order = self.internal_remove_order(nft_contract_id.into(), token_id);
    //     //get the predecessor of the call and make sure they're the owner of the order
    //     let owner_id = env::predecessor_account_id();
    //     //if this fails, the remove order will revert
    //     assert_eq!(owner_id, order.owner_id, "Must be order owner");
    // }

    // //updates the price for a sale on the market
    // #[payable]
    // pub fn update_price(
    //     &mut self,
    //     nft_contract_id: AccountId,
    //     token_id: String,
    //     price: U128,
    // ) {
    //     //assert that the user has attached exactly 1 yoctoNEAR (for security reasons)
    //     assert_one_yocto();
    //     //create the unique sale ID from the nft contract and token
    //     let contract_id: AccountId = nft_contract_id.into();
    //     let contract_and_token_id = format!("{}{}{}", contract_id, DELIMETER, token_id);

    //     //get the sale object from the unique sale ID. If there is no token, panic.
    //     let mut sale = self.sales.get(&contract_and_token_id).expect("No sale");

    //     //assert that the caller of the function is the sale owner
    //     assert_eq!(
    //         env::predecessor_account_id(),
    //         sale.owner_id,
    //         "Must be sale owner"
    //     );
    //     //set the sale conditions equal to the passed in price
    //     sale.sale_conditions = price;
    //     //insert the sale back into the map for the unique sale ID
    //     self.sales.insert(&contract_and_token_id, &sale);
    // }

    //place an offer on a specific sale. The sale will go through as long as your deposit is greater than or equal to the list price
    // #[payable]
    // pub fn offer(&mut self, nft_contract_id: AccountId, token_id: String) {
    //     //get the attached deposit and make sure it's greater than 0
    //     let deposit = env::attached_deposit();
    //     assert!(deposit > 0, "Attached deposit must be greater than 0");

    //     //convert the nft_contract_id from a AccountId to an AccountId
    //     let contract_id: AccountId = nft_contract_id.into();
    //     //get the unique sale ID (contract + DELIMITER + token ID)
    //     let contract_and_token_id = format!("{}{}{}", contract_id, DELIMETER, token_id);
    //     //get the sale object from the unique sale ID. If the sale doesn't exist, panic.
    //     let sale = self.sales.get(&contract_and_token_id).expect("No sale");
    //     //get the buyer ID which is the person who called the function and make sure they're not the owner of the sale
    //     let buyer_id = env::predecessor_account_id();
    //     assert_ne!(sale.owner_id, buyer_id, "Cannot bid on your own sale.");
    //     //get the u128 price of the token (dot 0 converts from U128 to u128)
    //     let price = sale.sale_conditions.0;

    //     //make sure the deposit is greater than the price
    //     assert!(deposit >= price, "Attached deposit must be greater than or equal to the current price: {:?}", price);

    //     //process the purchase (which will remove the sale, transfer and get the payout from the nft contract, and then distribute royalties)
    //     self.process_purchase(
    //         contract_id,
    //         token_id,
    //         U128(deposit),
    //         buyer_id,
    //     );
    // }

    // //private function used when a sale is purchased.
    // //this will remove the sale, transfer and get the payout from the nft contract, and then distribute royalties
    // #[private]
    // pub fn process_purchase(
    //     &mut self,
    //     nft_contract_id: AccountId,
    //     token_id: String,
    //     price: U128,
    //     buyer_id: AccountId,
    // ) -> Promise {
    //     //get the sale object by removing the sale
    //     let sale = self.internal_remove_sale(nft_contract_id.clone(), token_id.clone());

    //     //initiate a cross contract call to the nft contract. This will transfer the token to the buyer and return
    //     //a payout object used for the market to distribute funds to the appropriate accounts.
    //     ext_contract::nft_transfer_payout(
    //         buyer_id.clone(), //purchaser (person to transfer the NFT to)
    //         token_id, //token ID to transfer
    //         sale.approval_id, //market contract's approval ID in order to transfer the token on behalf of the owner
    //         "payout from market".to_string(), //memo (to include some context)
    //         /*
    //             the price that the token was purchased for. This will be used in conjunction with the royalty percentages
    //             for the token in order to determine how much money should go to which account.
    //         */
    //         price,
    // 		10, //the maximum amount of accounts the market can payout at once (this is limited by GAS)
    //         nft_contract_id, //contract to initiate the cross contract call to
    //         1, //yoctoNEAR to attach to the call
    //         GAS_FOR_NFT_TRANSFER, //GAS to attach to the call
    //     )
    //     //after the transfer payout has been initiated, we resolve the promise by calling our own resolve_purchase function.
    //     //resolve purchase will take the payout object returned from the nft_transfer_payout and actually pay the accounts
    //     .then(ext_self::resolve_purchase(
    //         buyer_id, //the buyer and price are passed in incase something goes wrong and we need to refund the buyer
    //         price,
    //         env::current_account_id(), //we are invoking this function on the current contract
    //         NO_DEPOSIT, //don't attach any deposit
    //         GAS_FOR_ROYALTIES, //GAS attached to the call to payout royalties
    //     ))
    // }

    // /*
    //     private method used to resolve the promise when calling nft_transfer_payout. This will take the payout object and
    //     check to see if it's authentic and there's no problems. If everything is fine, it will pay the accounts. If there's a problem,
    //     it will refund the buyer for the price.
    // */
    // #[private]
    // pub fn resolve_purchase(
    //     &mut self,
    //     buyer_id: AccountId,
    //     price: U128,
    // ) -> U128 {
    //     // checking for payout information returned from the nft_transfer_payout method
    //     let payout_option = promise_result_as_success().and_then(|value| {
    //         //if we set the payout_option to None, that means something went wrong and we should refund the buyer
    //         near_sdk::serde_json::from_slice::<Payout>(&value)
    //             //converts the result to an optional value
    //             .ok()
    //             //returns None if the none. Otherwise executes the following logic
    //             .and_then(|payout_object| {
    //                 //we'll check if length of the payout object is > 10 or it's empty. In either case, we return None
    //                 if payout_object.payout.len() > 10 || payout_object.payout.is_empty() {
    //                     env::log_str("Cannot have more than 10 royalties");
    //                     None
    //                 //if the payout object is the correct length, we move forward
    //                 } else {
    //                     //we'll keep track of how much the nft contract wants us to payout. Starting at the full price payed by the buyer
    //                     let mut remainder = price.0;

    //                     //loop through the payout and subtract the values from the remainder.
    //                     for &value in payout_object.payout.values() {
    //                         //checked sub checks for overflow or any errors and returns None if there are problems
    //                         remainder = remainder.checked_sub(value.0)?;
    //                     }
    //                     //Check to see if the NFT contract sent back a faulty payout that requires us to pay more or too little.
    //                     //The remainder will be 0 if the payout summed to the total price. The remainder will be 1 if the royalties
    //                     //we something like 3333 + 3333 + 3333.
    //                     if remainder == 0 || remainder == 1 {
    //                         //set the payout_option to be the payout because nothing went wrong
    //                         Some(payout_object.payout)
    //                     } else {
    //                         //if the remainder was anything but 1 or 0, we return None
    //                         None
    //                     }
    //                 }
    //             })
    //     });

    //     // if the payout option was some payout, we set this payout variable equal to that some payout
    //     let payout = if let Some(payout_option) = payout_option {
    //         payout_option
    //     //if the payout option was None, we refund the buyer for the price they payed and return
    //     } else {
    //         Promise::new(buyer_id).transfer(u128::from(price));
    //         // leave function and return the price that was refunded
    //         return price;
    //     };

    //     // NEAR payouts
    //     for (receiver_id, amount) in payout {
    //         Promise::new(receiver_id).transfer(amount.0);
    //     }

    //     //return the price payout out
    //     price
    // }
}

//this is the cross contract call that we call on our own contract.
/*
    private method used to resolve the promise when calling nft_transfer_payout. This will take the payout object and
    check to see if it's authentic and there's no problems. If everything is fine, it will pay the accounts. If there's a problem,
    it will refund the buyer for the price.
*/
#[ext_contract(ext_self)]
trait ExtSelf {
    fn resolve_purchase(&mut self, buyer_id: AccountId, price: U128) -> Promise;
}

// #[cfg(all(test, not(target_arch = "wasm32")))]
// mod tests {
//     use near_sdk::test_utils::{accounts, VMContextBuilder};
//     use near_sdk::testing_env;

//     use super::*;

//     const MINT_STORAGE_COST: u128 = 5870000000000000000000;

//     fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
//         let mut builder = VMContextBuilder::new();
//         builder
//             .current_account_id(accounts(0))
//             .signer_account_id(predecessor_account_id.clone())
//             .predecessor_account_id(predecessor_account_id);
//         builder
//     }

//     #[test]
//     fn test_create_order() {
//         let mut context = get_context(accounts(0));
//         testing_env!(context.build());
//         let mut contract = Contract::new(accounts(0).into());

//         testing_env!(context
//             .storage_usage(env::storage_usage())
//             .attached_deposit(MINT_STORAGE_COST)
//             .predecessor_account_id(accounts(0))
//             .build());

//         let token_id = "0".to_string();
//         let order = contract.create_order(accounts(0), token_id.clone());

//         // let requester_and_token_id = format!("{}{}{}", accounts(0), DELIMETER, token_id);
//         // assert_eq!(order.requester_id, accounts(0));
//         assert_eq!(order.token_id, token_id);
//         assert_eq!(order.status, "NEW".to_string());
//         // assert_eq!(order.instructions, "email_me".to_string());
//     }
// }

'''
'''--- market-contract/src/order_flow.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
  pub fn distributor_req_pile_from_producer(
    &mut self,
    distributor_id: AccountId,
    producer_id: AccountId,
    token_id: String,
  ) {
    // Producer creates pile, made visible to the distributor
    // Distributor creates order to request pile

    // //assert that the user has attached exactly 1 yoctoNEAR (for security reasons)
    // assert_one_yocto();
    self.create_order(distributor_id, producer_id, token_id);
  }

  pub fn producer_acc_req_from_distributor(
    &mut self,
    producer_id: AccountId,
    distributor_id: AccountId,
    token_id: String,
  ) {
    // Producer accepts request from Distributor
    // TODO : This triggers a callback for the distributor to create a transport order

    // Verify contract was called by producer
    let signer_id = env::signer_account_id();
    assert_eq!(
      signer_id, producer_id,
      "Order can only be accepted by producer"
    );
    let requester_and_token_id = format!("{}{}{}", distributor_id, DELIMETER, token_id);
    // Accept order then add to list of orders needing transport
    let order = self.accept_order(
      distributor_id,
      token_id,
      "NEW".to_string(),
      "NEEDS_TRANSPORT".to_string(),
      None,
    );
  }

  pub fn transporter_acc_transfer_req(&mut self, requester_id: AccountId, token_id: String) {
    let signer_id = env::signer_account_id();
    let requester_and_token_id = format!("{}{}{}", requester_id, DELIMETER, token_id);

    self.accept_order(
      requester_id,
      token_id,
      "NEEDS_TRANSPORT".to_string(),
      "IN_TRANSIT".to_string(),
      Some(signer_id),
    );

    // TODO: There should be a better way...
    let signer_id = env::signer_account_id();
    
    let mut by_transporter_set = self.by_transporter.get(&signer_id).unwrap_or_else(|| {
      UnorderedSet::new(
        StorageKey::ByRequesterInner {
          //we get a new unique prefix for the collection by hashing the owner
          account_id_hash: hash_account_id(&signer_id),
        }
        .try_to_vec()
        .unwrap(),
      )
    });
    //insert the unique sale ID into the set
    by_transporter_set.insert(&requester_and_token_id);
    //insert that set back into the collection for the owner
    self.by_transporter.insert(&signer_id, &by_transporter_set);
  }

  pub fn distributor_complete_order(&mut self, distributor_id: AccountId, token_id: String) {
    // Verify contract was called by distributor
    let signer_id = env::signer_account_id();
    assert_eq!(
      signer_id, distributor_id,
      "Order can only be accepted by distributor"
    );

    self.accept_order(
      distributor_id,
      token_id,
      "IN_TRANSIT".to_string(),
      "DELIVERED".to_string(),
      None,
    );
  }
}

'''
'''--- market-contract/src/order_views.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    // total number of orders on contract
    pub fn get_supply_orders(&self) -> U64 {
        U64(self.orders.len())
    }
    // total number of orders by requester
    pub fn get_supply_by_requester_id(&self, requester_id: AccountId) -> U64 {
        let by_requester = self.by_requester.get(&requester_id);
        if let Some(by_requester) = by_requester {
            U64(by_requester.len())
        } else {
            U64(0)
        }
    }

    //returns paginated order objects for a given account. (result is a vector of sales)
    pub fn get_orders_by_requester(
        &self,
        requester_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<Order> {
        //get the set of orders for a given requester
        let by_requester = self.by_requester.get(&requester_id);
        //if there was some set, we set the sales variable equal to that set. If there wasn't, sales is set to an empty vector
        let orders_by_requester = if let Some(by_requester) = by_requester {
            by_requester
        } else {
            return vec![];
        };
        //we'll convert the UnorderedSet into a vector of strings
        let keys = orders_by_requester.as_vector();

        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));
        //iterate through the keys vector
        keys.iter()
            //skip to the index we specified in the start variable
            .skip(start as usize)
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 0
            .take(limit.unwrap_or(0) as usize)
            //we'll map the token IDs which are strings into Sale objects
            .map(|requester_token_id| self.orders.get(&requester_token_id).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }

    //returns paginated order objects for a given account. (result is a vector of sales)
    pub fn get_orders_by_requestee(
        &self,
        requestee_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<Order> {
        let by_requestee = self.by_requestee.get(&requestee_id);

        let orders_by_requestee = if let Some(by_requestee) = by_requestee {
            by_requestee
        } else {
            return vec![];
        };

        let keys = orders_by_requestee.as_vector();

        let start = u128::from(from_index.unwrap_or(U128(0)));

        keys.iter()
            .skip(start as usize)
            .take(limit.unwrap_or(0) as usize)
            .map(|requestee_token_id| self.orders.get(&requestee_token_id).unwrap())
            .collect()
    }

      //returns paginated order objects for a given account. (result is a vector of sales)
      pub fn get_orders_by_transporter(
        &self,
        transporter_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<Order> {
        let by_transporter = self.by_transporter.get(&transporter_id);

        let orders_by_transporter = if let Some(by_transporter) = by_transporter {
            by_transporter
        } else {
            return vec![];
        };

        let keys = orders_by_transporter.as_vector();

        let start = u128::from(from_index.unwrap_or(U128(0)));

        keys.iter()
            .skip(start as usize)
            .take(limit.unwrap_or(0) as usize)
            .map(|transporter_token_id| self.orders.get(&transporter_token_id).unwrap())
            .collect()
    }

    pub fn get_order(&self, requester_token_id: RequesterAndTokenId) -> Option<Order> {
        self.orders.get(&requester_token_id)
    }
}

// #[cfg(all(test, not(target_arch = "wasm32")))]
// mod tests {
//     use near_sdk::test_utils::{accounts, VMContextBuilder};
//     use near_sdk::testing_env;

//     use super::*;

//     const MINT_STORAGE_COST: u128 = 5870000000000000000000;

//     fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
//         let mut builder = VMContextBuilder::new();
//         builder
//             .current_account_id(accounts(0))
//             .signer_account_id(predecessor_account_id.clone())
//             .predecessor_account_id(predecessor_account_id);
//         builder
//     }

//     #[test]
//     fn test_get_orders_by_requester() {
//         let mut context = get_context(accounts(0));
//         testing_env!(context.build());
//         let mut contract = Contract::new(accounts(0).into());

//         let requester = accounts(0).clone();
//         let token_id = "9999".to_string();

//         testing_env!(context
//             .storage_usage(env::storage_usage())
//             .attached_deposit(MINT_STORAGE_COST)
//             .predecessor_account_id(requester)
//             .build());

//         let test_by_requester_set = UnorderedSet::new(
//             StorageKey::ByRequesterInner {
//                 //we get a new unique prefix for the collection by hashing the owner
//                 account_id_hash: hash_account_id(&requester),
//             }
//             .try_to_vec()
//             .unwrap(),
//         );

//         let requester_and_token_id = format!("{}{}{}", requester, DELIMETER, token_id);

//         test_by_requester_set.insert(&requester_and_token_id);

//         contract.by_requester.insert(&requester, &test_by_requester_set);

//         let orders = contract.get_orders_by_requester(&requester);

//         contract.by_requester = UnorderedSet::new(
//             StorageKey::ByRequesterInner {
//                 //we get a new unique prefix for the collection by hashing the owner
//                 account_id_hash: hash_account_id(&requester_id),
//             }
//             .try_to_vec()
//             .unwrap(),
//         )

//         // assert_eq!(order.requester_id, accounts(0));
//         assert_eq!(order.token_id, token_id);
//         assert_eq!(order.status, "NEW".to_string());
//         // assert_eq!(order.instructions, "email_me".to_string());
//     }
// }

'''
'''--- market-contract/src/sale.rs ---
// use crate::*;
// use near_sdk::promise_result_as_success;

// //struct that holds important information about each sale on the market
// #[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
// #[serde(crate = "near_sdk::serde")]
// pub struct Sale {
//     //owner of the sale
//     pub owner_id: AccountId,
//     //market contract's approval ID to transfer the token on behalf of the owner
//     pub approval_id: u64,
//     //nft contract where the token was minted
//     pub nft_contract_id: String,
//     //actual token ID for sale
//     pub token_id: String,
//     //sale price in yoctoNEAR that the token is listed for
//     pub sale_conditions: SalePriceInYoctoNear,
// }

// #[near_bindgen]
// impl Contract {
    
//     //removes a sale from the market. 
//     #[payable]
//     pub fn remove_sale(&mut self, nft_contract_id: AccountId, token_id: String) {
//         //assert that the user has attached exactly 1 yoctoNEAR (for security reasons)
//         assert_one_yocto();
//         //get the sale object as the return value from removing the sale internally
//         let sale = self.internal_remove_sale(nft_contract_id.into(), token_id);
//         //get the predecessor of the call and make sure they're the owner of the sale
//         let owner_id = env::predecessor_account_id();
//         //if this fails, the remove sale will revert
//         assert_eq!(owner_id, sale.owner_id, "Must be sale owner");
//     }

//     //updates the price for a sale on the market
//     #[payable]
//     pub fn update_price(
//         &mut self,
//         nft_contract_id: AccountId,
//         token_id: String,
//         price: U128,
//     ) {
//         //assert that the user has attached exactly 1 yoctoNEAR (for security reasons)
//         assert_one_yocto();
        
//         //create the unique sale ID from the nft contract and token
//         let contract_id: AccountId = nft_contract_id.into();
//         let contract_and_token_id = format!("{}{}{}", contract_id, DELIMETER, token_id);
        
//         //get the sale object from the unique sale ID. If there is no token, panic. 
//         let mut sale = self.sales.get(&contract_and_token_id).expect("No sale");

//         //assert that the caller of the function is the sale owner
//         assert_eq!(
//             env::predecessor_account_id(),
//             sale.owner_id,
//             "Must be sale owner"
//         );
        
//         //set the sale conditions equal to the passed in price
//         sale.sale_conditions = price;
//         //insert the sale back into the map for the unique sale ID
//         self.sales.insert(&contract_and_token_id, &sale);
//     }

//     //place an offer on a specific sale. The sale will go through as long as your deposit is greater than or equal to the list price
//     #[payable]
//     pub fn offer(&mut self, nft_contract_id: AccountId, token_id: String) {
//         //get the attached deposit and make sure it's greater than 0
//         let deposit = env::attached_deposit();
//         assert!(deposit > 0, "Attached deposit must be greater than 0");

//         //convert the nft_contract_id from a AccountId to an AccountId
//         let contract_id: AccountId = nft_contract_id.into();
//         //get the unique sale ID (contract + DELIMITER + token ID)
//         let contract_and_token_id = format!("{}{}{}", contract_id, DELIMETER, token_id);
        
//         //get the sale object from the unique sale ID. If the sale doesn't exist, panic.
//         let sale = self.sales.get(&contract_and_token_id).expect("No sale");
        
//         //get the buyer ID which is the person who called the function and make sure they're not the owner of the sale
//         let buyer_id = env::predecessor_account_id();
//         assert_ne!(sale.owner_id, buyer_id, "Cannot bid on your own sale.");
        
//         //get the u128 price of the token (dot 0 converts from U128 to u128)
//         let price = sale.sale_conditions.0;

//         //make sure the deposit is greater than the price
//         assert!(deposit >= price, "Attached deposit must be greater than or equal to the current price: {:?}", price);

//         //process the purchase (which will remove the sale, transfer and get the payout from the nft contract, and then distribute royalties) 
//         self.process_purchase(
//             contract_id,
//             token_id,
//             U128(deposit),
//             buyer_id,
//         );
//     }

//     //private function used when a sale is purchased. 
//     //this will remove the sale, transfer and get the payout from the nft contract, and then distribute royalties
//     #[private]
//     pub fn process_purchase(
//         &mut self,
//         nft_contract_id: AccountId,
//         token_id: String,
//         price: U128,
//         buyer_id: AccountId,
//     ) -> Promise {
//         //get the sale object by removing the sale
//         let sale = self.internal_remove_sale(nft_contract_id.clone(), token_id.clone());

//         //initiate a cross contract call to the nft contract. This will transfer the token to the buyer and return
//         //a payout object used for the market to distribute funds to the appropriate accounts.
//         ext_contract::nft_transfer_payout(
//             buyer_id.clone(), //purchaser (person to transfer the NFT to)
//             token_id, //token ID to transfer
//             sale.approval_id, //market contract's approval ID in order to transfer the token on behalf of the owner
//             "payout from market".to_string(), //memo (to include some context)
//             /*
//                 the price that the token was purchased for. This will be used in conjunction with the royalty percentages
//                 for the token in order to determine how much money should go to which account. 
//             */
//             price,
// 			10, //the maximum amount of accounts the market can payout at once (this is limited by GAS)
//             nft_contract_id, //contract to initiate the cross contract call to
//             1, //yoctoNEAR to attach to the call
//             GAS_FOR_NFT_TRANSFER, //GAS to attach to the call
//         )
//         //after the transfer payout has been initiated, we resolve the promise by calling our own resolve_purchase function. 
//         //resolve purchase will take the payout object returned from the nft_transfer_payout and actually pay the accounts
//         .then(ext_self::resolve_purchase(
//             buyer_id, //the buyer and price are passed in incase something goes wrong and we need to refund the buyer
//             price,
//             env::current_account_id(), //we are invoking this function on the current contract
//             NO_DEPOSIT, //don't attach any deposit
//             GAS_FOR_ROYALTIES, //GAS attached to the call to payout royalties
//         ))
//     }

//     /*
//         private method used to resolve the promise when calling nft_transfer_payout. This will take the payout object and 
//         check to see if it's authentic and there's no problems. If everything is fine, it will pay the accounts. If there's a problem,
//         it will refund the buyer for the price. 
//     */
//     #[private]
//     pub fn resolve_purchase(
//         &mut self,
//         buyer_id: AccountId,
//         price: U128,
//     ) -> U128 {
//         // checking for payout information returned from the nft_transfer_payout method
//         let payout_option = promise_result_as_success().and_then(|value| {
//             //if we set the payout_option to None, that means something went wrong and we should refund the buyer
//             near_sdk::serde_json::from_slice::<Payout>(&value)
//                 //converts the result to an optional value
//                 .ok()
//                 //returns None if the none. Otherwise executes the following logic
//                 .and_then(|payout_object| {
//                     //we'll check if length of the payout object is > 10 or it's empty. In either case, we return None
//                     if payout_object.payout.len() > 10 || payout_object.payout.is_empty() {
//                         env::log_str("Cannot have more than 10 royalties");
//                         None
                    
//                     //if the payout object is the correct length, we move forward
//                     } else {
//                         //we'll keep track of how much the nft contract wants us to payout. Starting at the full price payed by the buyer
//                         let mut remainder = price.0;
                        
//                         //loop through the payout and subtract the values from the remainder. 
//                         for &value in payout_object.payout.values() {
//                             //checked sub checks for overflow or any errors and returns None if there are problems
//                             remainder = remainder.checked_sub(value.0)?;
//                         }
//                         //Check to see if the NFT contract sent back a faulty payout that requires us to pay more or too little. 
//                         //The remainder will be 0 if the payout summed to the total price. The remainder will be 1 if the royalties
//                         //we something like 3333 + 3333 + 3333. 
//                         if remainder == 0 || remainder == 1 {
//                             //set the payout_option to be the payout because nothing went wrong
//                             Some(payout_object.payout)
//                         } else {
//                             //if the remainder was anything but 1 or 0, we return None
//                             None
//                         }
//                     }
//                 })
//         });

//         // if the payout option was some payout, we set this payout variable equal to that some payout
//         let payout = if let Some(payout_option) = payout_option {
//             payout_option
//         //if the payout option was None, we refund the buyer for the price they payed and return
//         } else {
//             Promise::new(buyer_id).transfer(u128::from(price));
//             // leave function and return the price that was refunded
//             return price;
//         };

//         // NEAR payouts
//         for (receiver_id, amount) in payout {
//             Promise::new(receiver_id).transfer(amount.0);
//         }

//         //return the price payout out
//         price
//     }
// }

// //this is the cross contract call that we call on our own contract. 
// /*
//     private method used to resolve the promise when calling nft_transfer_payout. This will take the payout object and 
//     check to see if it's authentic and there's no problems. If everything is fine, it will pay the accounts. If there's a problem,
//     it will refund the buyer for the price. 
// */
// #[ext_contract(ext_self)]
// trait ExtSelf {
//     fn resolve_purchase(
//         &mut self,
//         buyer_id: AccountId,
//         price: U128,
//     ) -> Promise;
// }

'''
'''--- market-contract/src/sale_views.rs ---
// use crate::*;

// #[near_bindgen]
// impl Contract {
//     /// views
    
//     //returns the number of sales the marketplace has up (as a string)
//     pub fn get_supply_sales(
//         &self,
//     ) -> U64 {
//         //returns the sales object length wrapped as a U64
//         U64(self.sales.len())
//     }
    
//     //returns the number of sales for a given account (result is a string)
//     pub fn get_supply_by_owner_id(
//         &self,
//         account_id: AccountId,
//     ) -> U64 {
//         //get the set of sales for the given owner Id
//         let by_owner_id = self.by_owner_id.get(&account_id);
        
//         //if there as some set, we return the length but if there wasn't a set, we return 0
//         if let Some(by_owner_id) = by_owner_id {
//             U64(by_owner_id.len())
//         } else {
//             U64(0)
//         }
//     }

//     //returns paginated sale objects for a given account. (result is a vector of sales)
//     pub fn get_sales_by_owner_id(
//         &self,
//         account_id: AccountId,
//         from_index: Option<U128>,
//         limit: Option<u64>,
//     ) -> Vec<Sale> {
//         //get the set of token IDs for sale for the given account ID
//         let by_owner_id = self.by_owner_id.get(&account_id);
//         //if there was some set, we set the sales variable equal to that set. If there wasn't, sales is set to an empty vector
//         let sales = if let Some(by_owner_id) = by_owner_id {
//             by_owner_id
//         } else {
//             return vec![];
//         };
        
//         //we'll convert the UnorderedSet into a vector of strings
//         let keys = sales.as_vector();

//         //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
//         let start = u128::from(from_index.unwrap_or(U128(0)));
        
//         //iterate through the keys vector
//         keys.iter()
//             //skip to the index we specified in the start variable
//             .skip(start as usize) 
//             //take the first "limit" elements in the vector. If we didn't specify a limit, use 0
//             .take(limit.unwrap_or(0) as usize) 
//             //we'll map the token IDs which are strings into Sale objects
//             .map(|token_id| self.sales.get(&token_id).unwrap())
//             //since we turned the keys into an iterator, we need to turn it back into a vector to return
//             .collect()
//     }

//     //get the number of sales for an nft contract. (returns a string)
//     pub fn get_supply_by_nft_contract_id(
//         &self,
//         nft_contract_id: AccountId,
//     ) -> U64 {
//         //get the set of tokens for associated with the given nft contract
//         let by_nft_contract_id = self.by_nft_contract_id.get(&nft_contract_id);
        
//         //if there was some set, return it's length. Otherwise return 0
//         if let Some(by_nft_contract_id) = by_nft_contract_id {
//             U64(by_nft_contract_id.len())
//         } else {
//             U64(0)
//         }
//     }

//     //returns paginated sale objects associated with a given nft contract. (result is a vector of sales)
//     pub fn get_sales_by_nft_contract_id(
//         &self,
//         nft_contract_id: AccountId,
//         from_index: Option<U128>,
//         limit: Option<u64>,
//     ) -> Vec<Sale> {
//         //get the set of token IDs for sale for the given contract ID
//         let by_nft_contract_id = self.by_nft_contract_id.get(&nft_contract_id);
        
//         //if there was some set, we set the sales variable equal to that set. If there wasn't, sales is set to an empty vector
//         let sales = if let Some(by_nft_contract_id) = by_nft_contract_id {
//             by_nft_contract_id
//         } else {
//             return vec![];
//         };

//         //we'll convert the UnorderedSet into a vector of strings
//         let keys = sales.as_vector();

//         //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
//         let start = u128::from(from_index.unwrap_or(U128(0)));
        
//         //iterate through the keys vector
//         keys.iter()
//             //skip to the index we specified in the start variable
//             .skip(start as usize) 
//             //take the first "limit" elements in the vector. If we didn't specify a limit, use 0
//             .take(limit.unwrap_or(0) as usize) 
//             //we'll map the token IDs which are strings into Sale objects by passing in the unique sale ID (contract + DELIMITER + token ID)
//             .map(|token_id| self.sales.get(&format!("{}{}{}", nft_contract_id, DELIMETER, token_id)).unwrap())
//             //since we turned the keys into an iterator, we need to turn it back into a vector to return
//             .collect()
//     }

//     //get a sale information for a given unique sale ID (contract + DELIMITER + token ID)
//     pub fn get_sale(&self, nft_contract_token: ContractAndTokenId) -> Option<Sale> {
//         //try and get the sale object for the given unique sale ID. Will return an option since
//         //we're not guaranteed that the unique sale ID passed in will be valid.
//         self.sales.get(&nft_contract_token)
//     }
// }

'''
'''--- nft-contract/Cargo.toml ---
[package]
name = "nft_simple"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "=4.0.0-pre.4"
serde_json = "1.0"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- nft-contract/README.md ---
# NFT Contract

This contract contains the logic to create and manage items

## Deploying the Contract

Build the contract:
./build.sh

This will compile the contract into a wasm you can find in ./res

Test contract (TODO)

cargo test -- --no-capture

Quick deploy:

cd ..
near dev-deploy --wasmFile ./out/market.wasm

This will print out a dev account contract was deployed to.
Set it to CONTRACT_NAME
source neardev/dev-account.env

Initialize the contract:

near call $CONTRACT_NAME new_default_meta '{"owner_id": "'$CONTRACT_NAME'"}' --accountId $CONTRACT_NAME

Now fun stuff:

Login to your near testnet account

near login

export ACCOUNT_ID={{WALLET_ID}}

near call $CONTRACT_NAME create_order '{"requester_id": "'$ACCOUNT_ID'", "token_id": "9999"}' --accountId $ACCOUNT_ID --depositYocto 1

near view $CONTRACT_NAME get_supply_orders

near view $CONTRACT_NAME get_supply_by_requester_id '{"requester_id": "'$ACCOUNT_ID'"}'

near view $CONTRACT_NAME get_orders_by_requester '{"requester_id": "'$ACCOUNT_ID'", "limit": 5}'

'''
'''--- nft-contract/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../out
cp target/wasm32-unknown-unknown/release/*.wasm ../out/main.wasm
'''
'''--- nft-contract/src/approval.rs ---
use crate::*;
use near_sdk::{ext_contract, Gas};

const GAS_FOR_NFT_APPROVE: Gas = Gas(10_000_000_000_000);
const NO_DEPOSIT: Balance = 0;

pub trait NonFungibleTokenCore {
    //approve an account ID to transfer a token on your behalf
    fn nft_approve(&mut self, token_id: TokenId, account_id: AccountId, msg: Option<String>);

    //check if the passed in account has access to approve the token ID
	fn nft_is_approved(
        &self,
        token_id: TokenId,
        approved_account_id: AccountId,
        approval_id: Option<u64>,
    ) -> bool;

    //revoke a specific account from transferring the token on your behalf
    fn nft_revoke(&mut self, token_id: TokenId, account_id: AccountId);

    //revoke all accounts from transferring the token on your behalf
    fn nft_revoke_all(&mut self, token_id: TokenId);
}

#[ext_contract(ext_non_fungible_approval_receiver)]
trait NonFungibleTokenApprovalsReceiver {
    //cross contract call to an external contract that is initiated during nft_approve
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    );
}

#[near_bindgen]
impl NonFungibleTokenCore for Contract {

    //allow a specific account ID to approve a token on your behalf
    #[payable]
    fn nft_approve(&mut self, token_id: TokenId, account_id: AccountId, msg: Option<String>) {
        /*
            assert at least one yocto for security reasons - this will cause a redirect to the NEAR wallet.
            The user needs to attach enough to pay for storage on the contract
        */
        assert_at_least_one_yocto();

        //get the token object from the token ID
        let mut token = self.tokens_by_id.get(&token_id).expect("No token");

        //make sure that the person calling the function is the owner of the token
        assert_eq!(
            &env::predecessor_account_id(),
            &token.owner_id,
            "Predecessor must be the token owner."
        );

        //get the next approval ID if we need a new approval
        let approval_id: u64 = token.next_approval_id;

        //check if the account has been approved already for this token
        let is_new_approval = token
            .approved_account_ids
            //insert returns none if the key was not present.  
            .insert(account_id.clone(), approval_id)
            //if the key was not present, .is_none() will return true so it is a new approval.
            .is_none();

        //if it was a new approval, we need to calculate how much storage is being used to add the account.
        let storage_used = if is_new_approval {
            bytes_for_approved_account_id(&account_id)
        //if it was not a new approval, we used no storage.
        } else {
            0
        };

        //increment the token's next approval ID by 1
        token.next_approval_id += 1;
        //insert the token back into the tokens_by_id collection
        self.tokens_by_id.insert(&token_id, &token);

        //refund any excess storage attached by the user. If the user didn't attach enough, panic. 
        refund_deposit(storage_used);

        //if some message was passed into the function, we initiate a cross contract call on the
        //account we're giving access to. 
        if let Some(msg) = msg {
            ext_non_fungible_approval_receiver::nft_on_approve(
                token_id,
                token.owner_id,
                approval_id,
                msg,
                account_id, //contract account we're calling
                NO_DEPOSIT, //NEAR deposit we attach to the call
                env::prepaid_gas() - GAS_FOR_NFT_APPROVE, //GAS we're attaching
            )
            .as_return(); // Returning this promise
        }
    }

    //check if the passed in account has access to approve the token ID
	fn nft_is_approved(
        &self,
        token_id: TokenId,
        approved_account_id: AccountId,
        approval_id: Option<u64>,
    ) -> bool {
        //get the token object from the token_id
        let token = self.tokens_by_id.get(&token_id).expect("No token");

        //get the approval number for the passed in account ID
		let approval = token.approved_account_ids.get(&approved_account_id);

        //if there was some approval ID found for the account ID
        if let Some(approval) = approval {
            //if a specific approval_id was passed into the function
			if let Some(approval_id) = approval_id {
                //return if the approval ID passed in matches the actual approval ID for the account
				approval_id == *approval
            //if there was no approval_id passed into the function, we simply return true
			} else {
				true
			}
        //if there was no approval ID found for the account ID, we simply return false
		} else {
			false
		}
    }

    //revoke a specific account from transferring the token on your behalf 
    #[payable]
    fn nft_revoke(&mut self, token_id: TokenId, account_id: AccountId) {
        //assert that the user attached exactly 1 yoctoNEAR for security reasons
        assert_one_yocto();
        //get the token object using the passed in token_id
        let mut token = self.tokens_by_id.get(&token_id).expect("No token");

        //get the caller of the function and assert that they are the owner of the token
        let predecessor_account_id = env::predecessor_account_id();
        assert_eq!(&predecessor_account_id, &token.owner_id);

        //if the account ID was in the token's approval, we remove it and the if statement logic executes
        if token
            .approved_account_ids
            .remove(&account_id)
            .is_some()
        {
            //refund the funds released by removing the approved_account_id to the caller of the function
            refund_approved_account_ids_iter(predecessor_account_id, [account_id].iter());

            //insert the token back into the tokens_by_id collection with the account_id removed from the approval list
            self.tokens_by_id.insert(&token_id, &token);
        }
    }

    //revoke all accounts from transferring the token on your behalf
    #[payable]
    fn nft_revoke_all(&mut self, token_id: TokenId) {
        //assert that the caller attached exactly 1 yoctoNEAR for security
        assert_one_yocto();

        //get the token object from the passed in token ID
        let mut token = self.tokens_by_id.get(&token_id).expect("No token");
        //get the caller and make sure they are the owner of the tokens
        let predecessor_account_id = env::predecessor_account_id();
        assert_eq!(&predecessor_account_id, &token.owner_id);

        //only revoke if the approved account IDs for the token is not empty
        if !token.approved_account_ids.is_empty() {
            //refund the approved account IDs to the caller of the function
            refund_approved_account_ids(predecessor_account_id, &token.approved_account_ids);
            //clear the approved account IDs
            token.approved_account_ids.clear();
            //insert the token back into the tokens_by_id collection with the approved account IDs cleared
            self.tokens_by_id.insert(&token_id, &token);
        }
    }
}
'''
'''--- nft-contract/src/enumeration.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    //Query for the total supply of NFTs on the contract
    pub fn nft_total_supply(&self) -> U128 {
        //return the length of the token metadata by ID
        U128(self.token_metadata_by_id.len() as u128)
    }

    //Query for nft tokens on the contract regardless of the owner using pagination
    pub fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonToken> {
        //get a vector of the keys in the token_metadata_by_id collection.  
        let keys = self.token_metadata_by_id.keys_as_vector();

        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));

        //iterate through the keys vector
        keys.iter()
            //skip to the index we specified in the start variable
            .skip(start as usize) 
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 0
            .take(limit.unwrap_or(0) as usize) 
            //we'll map the token IDs which are strings into Json Tokens
            .map(|token_id| self.nft_token(token_id.clone()).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }

    //get the total supply of NFTs for a given owner
    pub fn nft_supply_for_owner(
        &self,
        account_id: AccountId,
    ) -> U128 {
        //get the set of tokens for the passed in owner
        let tokens_for_owner_set = self.tokens_per_owner.get(&account_id);

        //if there is some set of tokens, we'll return the length as a U128
        if let Some(tokens_for_owner_set) = tokens_for_owner_set {
            U128(tokens_for_owner_set.len() as u128)
        } else {
            //if there isn't a set of tokens for the passed in account ID, we'll return 0
            U128(0)
        }
    }

    //Query for all the tokens for an owner
    pub fn nft_tokens_for_owner(
        &self,
        account_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<JsonToken> {
        //get the set of tokens for the passed in owner
        let tokens_for_owner_set = self.tokens_per_owner.get(&account_id);
        //if there is some set of tokens, we'll set the tokens variable equal to that set
        let tokens = if let Some(tokens_for_owner_set) = tokens_for_owner_set {
            tokens_for_owner_set
        } else {
            //if there is no set of tokens, we'll simply return an empty vector. 
            return vec![];
        };
        //we'll convert the UnorderedSet into a vector of strings
        let keys = tokens.as_vector();

        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));

        //iterate through the keys vector
        keys.iter()
            //skip to the index we specified in the start variable
            .skip(start as usize) 
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 0
            .take(limit.unwrap_or(0) as usize) 
            //we'll map the token IDs which are strings into Json Tokens
            .map(|token_id| self.nft_token(token_id.clone()).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }
}
'''
'''--- nft-contract/src/events.rs ---
use std::fmt;

use near_sdk::serde::{Deserialize, Serialize};

/// Enum that represents the data type of the EventLog.
/// The enum can either be an NftMint or an NftTransfer.
#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[serde(crate = "near_sdk::serde")]
#[non_exhaustive]
pub enum EventLogVariant {
    NftMint(Vec<NftMintLog>),
    NftUpdateLog(Vec<NftUpdateLog>),
    NftTransfer(Vec<NftTransferLog>),
}

/// Interface to capture data about an event
///
/// Arguments:
/// * `standard`: name of standard e.g. nep171
/// * `version`: e.g. 1.0.0
/// * `event`: associate event data
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct EventLog {
    pub standard: String,
    pub version: String,

    // `flatten` to not have "event": {<EventLogVariant>} in the JSON, just have the contents of {<EventLogVariant>}.
    #[serde(flatten)]
    pub event: EventLogVariant,
}

impl fmt::Display for EventLog {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!(
            "EVENT_JSON:{}",
            &serde_json::to_string(self).map_err(|_| fmt::Error)?
        ))
    }
}

/// An event log to capture token minting
///
/// Arguments
/// * `owner_id`: "account.near"
/// * `token_ids`: ["1", "abc"]
/// * `memo`: optional message
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftMintLog {
    pub owner_id: String,
    pub token_ids: Vec<String>,
    pub root_id: Option<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

/// An event log to capture token updates
///
/// Arguments
/// * `owner_id`: "account.near"
/// * `token_ids`: ["1", "abc"]
/// * `memo`: optional message
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftUpdateLog {
    pub token_ids: Vec<String>,
    pub category: Option<String>,
    pub labels: Option<Vec<String>>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

/// An event log to capture token transfer
///
/// Arguments
/// * `authorized_id`: approved account to transfer
/// * `old_owner_id`: "owner.near"
/// * `new_owner_id`: "receiver.near"
/// * `token_ids`: ["1", "12345abc"]
/// * `memo`: optional message
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftTransferLog {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorized_id: Option<String>,

    pub old_owner_id: String,
    pub new_owner_id: String,
    pub token_ids: Vec<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

// #[cfg(test)]
// mod tests {
//     use super::*;

//     #[test]
//     fn nep_format_vector() {
//         let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"foundation.near","token_ids":["aurora","proximitylabs"]},{"owner_id":"user1.near","token_ids":["meme"]}]}"#;
//         let log = EventLog {
//             standard: "nep171".to_string(),
//             version: "1.0.0".to_string(),
//             event: EventLogVariant::NftMint(vec![
//                 NftMintLog {
//                     owner_id: "foundation.near".to_owned(),
//                     token_ids: vec!["aurora".to_string(), "proximitylabs".to_string()],
//                     memo: None,
//                 },
//                 NftMintLog {
//                     owner_id: "user1.near".to_owned(),
//                     token_ids: vec!["meme".to_string()],
//                     memo: None,
//                 },
//             ]),
//         };
//         assert_eq!(expected, log.to_string());
//     }

//     #[test]
//     fn nep_format_mint() {
//         let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"foundation.near","token_ids":["aurora","proximitylabs"]}]}"#;
//         let log = EventLog {
//             standard: "nep171".to_string(),
//             version: "1.0.0".to_string(),
//             event: EventLogVariant::NftMint(vec![NftMintLog {
//                 owner_id: "foundation.near".to_owned(),
//                 token_ids: vec!["aurora".to_string(), "proximitylabs".to_string()],
//                 memo: None,
//             }]),
//         };
//         assert_eq!(expected, log.to_string());
//     }

//     #[test]
//     fn nep_format_transfer_all_fields() {
//         let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_transfer","data":[{"authorized_id":"market.near","old_owner_id":"user1.near","new_owner_id":"user2.near","token_ids":["token"],"memo":"Go Team!"}]}"#;
//         let log = EventLog {
//             standard: "nep171".to_string(),
//             version: "1.0.0".to_string(),
//             event: EventLogVariant::NftTransfer(vec![NftTransferLog {
//                 authorized_id: Some("market.near".to_string()),
//                 old_owner_id: "user1.near".to_string(),
//                 new_owner_id: "user2.near".to_string(),
//                 token_ids: vec!["token".to_string()],
//                 memo: Some("Go Team!".to_owned()),
//             }]),
//         };
//         assert_eq!(expected, log.to_string());
//     }
// } 
'''
'''--- nft-contract/src/internal.rs ---
use crate::*;
use near_sdk::{CryptoHash};
use std::mem::size_of;

//convert the royalty percentage and amount to pay into a payout (U128)
pub(crate) fn royalty_to_payout(royalty_percentage: u32, amount_to_pay: Balance) -> U128 {
    U128(royalty_percentage as u128 * amount_to_pay / 10_000u128)
}

//calculate how many bytes the account ID is taking up
pub(crate) fn bytes_for_approved_account_id(account_id: &AccountId) -> u64 {
    // The extra 4 bytes are coming from Borsh serialization to store the length of the string.
    account_id.as_str().len() as u64 + 4 + size_of::<u64>() as u64
}

//refund the storage taken up by passed in approved account IDs and send the funds to the passed in account ID. 
pub(crate) fn refund_approved_account_ids_iter<'a, I>(
    account_id: AccountId,
    approved_account_ids: I, //the approved account IDs must be passed in as an iterator
) -> Promise
where
    I: Iterator<Item = &'a AccountId>,
{
    //get the storage total by going through and summing all the bytes for each approved account IDs
    let storage_released: u64 = approved_account_ids.map(bytes_for_approved_account_id).sum();
    //transfer the account the storage that is released
    Promise::new(account_id).transfer(Balance::from(storage_released) * env::storage_byte_cost())
}

//refund a map of approved account IDs and send the funds to the passed in account ID
pub(crate) fn refund_approved_account_ids(
    account_id: AccountId,
    approved_account_ids: &HashMap<AccountId, u64>,
) -> Promise {
    //call the refund_approved_account_ids_iter with the approved account IDs as keys
    refund_approved_account_ids_iter(account_id, approved_account_ids.keys())
}

//used to generate a unique prefix in our storage collections (this is to avoid data collisions)
pub(crate) fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    //get the default hash
    let mut hash = CryptoHash::default();
    //we hash the account ID and return it
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

//used to make sure the user attached exactly 1 yoctoNEAR
pub(crate) fn assert_one_yocto() {
    assert_eq!(
        env::attached_deposit(),
        1,
        "Requires attached deposit of exactly 1 yoctoNEAR",
    )
}

//Assert that the user has attached at least 1 yoctoNEAR (for security reasons and to pay for storage)
pub(crate) fn assert_at_least_one_yocto() {
    assert!(
        env::attached_deposit() >= 1,
        "Requires attached deposit of at least 1 yoctoNEAR",
    )
}

//refund the initial deposit based on the amount of storage that was used up
pub(crate) fn refund_deposit(storage_used: u64) {
    //get how much it would cost to store the information
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    //get the attached deposit
    let attached_deposit = env::attached_deposit();

    //make sure that the attached deposit is greater than or equal to the required cost
    assert!(
        required_cost <= attached_deposit,
        "Must attach {} yoctoNEAR to cover storage",
        required_cost,
    );

    //get the refund amount from the attached deposit - required cost
    let refund = attached_deposit - required_cost;

    //if the refund is greater than 1 yocto NEAR, we refund the predecessor that amount
    if refund > 1 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}

impl Contract {
    //add a token to the set of tokens an owner has
    pub(crate) fn internal_add_token_to_owner(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
    ) {
        //get the set of tokens for the given account
        let mut tokens_set = self.tokens_per_owner.get(account_id).unwrap_or_else(|| {
            //if the account doesn't have any tokens, we create a new unordered set
            UnorderedSet::new(
                StorageKey::TokenPerOwnerInner {
                    //we get a new unique prefix for the collection
                    account_id_hash: hash_account_id(&account_id),
                }
                .try_to_vec()
                .unwrap(),
            )
        });

        //we insert the token ID into the set
        tokens_set.insert(token_id);

        //we insert that set for the given account ID. 
        self.tokens_per_owner.insert(account_id, &tokens_set);
    }

    //remove a token from an owner (internal method and can't be called directly via CLI).
    pub(crate) fn internal_remove_token_from_owner(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
    ) {
        //we get the set of tokens that the owner has
        let mut tokens_set = self
            .tokens_per_owner
            .get(account_id)
            //if there is no set of tokens for the owner, we panic with the following message:
            .expect("Token should be owned by the sender");

        //we remove the the token_id from the set of tokens
        tokens_set.remove(token_id);

        //if the token set is now empty, we remove the owner from the tokens_per_owner collection
        if tokens_set.is_empty() {
            self.tokens_per_owner.remove(account_id);
        } else {
        //if the token set is not empty, we simply insert it back for the account ID. 
            self.tokens_per_owner.insert(account_id, &tokens_set);
        }
    }

    //transfers the NFT to the receiver_id (internal method and can't be called directly via CLI).
    pub(crate) fn internal_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        token_id: &TokenId,
        //we introduce an approval ID so that people with that approval ID can transfer the token
        approval_id: Option<u64>,
        memo: Option<String>,
    ) -> Token {
        //get the token object by passing in the token_id
        let token = self.tokens_by_id.get(token_id).expect("No token");

        //if the sender doesn't equal the owner, we check if the sender is in the approval list
		if sender_id != &token.owner_id {
			//if the token's approved account IDs doesn't contain the sender, we panic
			if !token.approved_account_ids.contains_key(sender_id) {
				env::panic_str("Unauthorized");
			}

			// If they included an approval_id, check if the sender's actual approval_id is the same as the one included
			if let Some(enforced_approval_id) = approval_id {
                //get the actual approval ID
				let actual_approval_id = token
					.approved_account_ids
					.get(sender_id)
                    //if the sender isn't in the map, we panic
					.expect("Sender is not approved account");

                //make sure that the actual approval ID is the same as the one provided
                assert_eq!(
					actual_approval_id, &enforced_approval_id,
					"The actual approval_id {} is different from the given approval_id {}",
					actual_approval_id, enforced_approval_id,
				);
			}
		}

        //we make sure that the sender isn't sending the token to themselves
        assert_ne!(
            &token.owner_id, receiver_id,
            "The token owner and the receiver should be different"
        );

        //we remove the token from it's current owner's set
        self.internal_remove_token_from_owner(&token.owner_id, token_id);
        //we then add the token to the receiver_id's set
        self.internal_add_token_to_owner(receiver_id, token_id);

        //we create a new token struct 
        let new_token = Token {
            owner_id: receiver_id.clone(),
            //reset the approval account IDs
            approved_account_ids: Default::default(),
            next_approval_id: token.next_approval_id,
            //we copy over the royalties from the previous token
            royalty: token.royalty.clone(),
        };
        //insert that new token into the tokens_by_id, replacing the old entry 
        self.tokens_by_id.insert(token_id, &new_token);

        //if there was some memo attached, we log it. 
        if let Some(memo) = memo.as_ref() {
            env::log_str(&format!("Memo: {}", memo).to_string());
        }

        // Default the authorized ID to be None for the logs.
        let mut authorized_id = None;
        //if the approval ID was provided, set the authorized ID equal to the sender
        if approval_id.is_some() {
            authorized_id = Some(sender_id.to_string());
        }

        // Construct the transfer log as per the events standard.
        let nft_transfer_log: EventLog = EventLog {
            // Standard name ("nep171").
            standard: NFT_STANDARD_NAME.to_string(),
            // Version of the standard ("nft-1.0.0").
            version: NFT_METADATA_SPEC.to_string(),
            // The data related with the event stored in a vector.
            event: EventLogVariant::NftTransfer(vec![NftTransferLog {
                // The optional authorized account ID to transfer the token on behalf of the old owner.
                authorized_id,
                // The old owner's account ID.
                old_owner_id: token.owner_id.to_string(),
                // The account ID of the new owner of the token.
                new_owner_id: receiver_id.to_string(),
                // A vector containing the token IDs as strings.
                token_ids: vec![token_id.to_string()],
                // An optional memo to include.
                memo,
            }]),
        };

        // Log the serialized json.
        env::log_str(&nft_transfer_log.to_string());
        
        //return the preivous token object that was transferred.
        token
    }
} 
'''
'''--- nft-contract/src/lib.rs ---
use std::collections::HashMap;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::{Base64VecU8, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, near_bindgen, AccountId, Balance, CryptoHash, PanicOnDefault, Promise, PromiseOrValue,
};

use crate::internal::*;
pub use crate::metadata::*;
pub use crate::mint::*;
pub use crate::update::*;
pub use crate::nft_core::*;
pub use crate::approval::*;
pub use crate::royalty::*;
pub use crate::events::*;

mod internal;
mod approval; 
mod enumeration; 
mod metadata; 
mod mint; 
mod update; 
mod nft_core; 
mod royalty; 
mod events;

/// This spec can be treated like a version of the standard.
pub const NFT_METADATA_SPEC: &str = "nft-1.0.0";
/// This is the name of the NFT standard we're using
pub const NFT_STANDARD_NAME: &str = "nep171";

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub owner_id: AccountId,
    pub tokens_per_owner: LookupMap<AccountId, UnorderedSet<TokenId>>,
    pub tokens_by_id: LookupMap<TokenId, Token>, 
    pub token_metadata_by_id: UnorderedMap<TokenId, TokenMetadata>,
    pub metadata: LazyOption<NFTContractMetadata>,
}

#[derive(BorshSerialize)]
pub enum StorageKey {
    TokensPerOwner,
    TokenPerOwnerInner { account_id_hash: CryptoHash },
    TokensById,
    TokenMetadataById,
    NFTContractMetadata,
    TokensPerType,
    TokensPerTypeInner { token_type_hash: CryptoHash },
    TokenTypesLocked,
}

#[near_bindgen]
impl Contract {
    /*
        initialization function (can only be called once).
        this initializes the contract with default metadata so the
        user doesn't have to manually type metadata.
    */
    #[init]
    pub fn new_default_meta(owner_id: AccountId) -> Self {
        //calls the other function "new: with some default metadata and the owner_id passed in 
        Self::new(
            owner_id,
            NFTContractMetadata {
                spec: NFT_METADATA_SPEC.to_string(),
                name: "NEAR Collect".to_string(),
                symbol: "COLLECT".to_string(),
                icon: None,
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
        )
    }

    /*
        initialization function (can only be called once).
        this initializes the contract with metadata that was passed in and
        the owner_id. 
    */
    #[init]
    pub fn new(owner_id: AccountId, metadata: NFTContractMetadata) -> Self {
        let this = Self {
            //Storage keys are simply the prefixes used for the collections. This helps avoid data collision
            tokens_per_owner: LookupMap::new(StorageKey::TokensPerOwner.try_to_vec().unwrap()),
            tokens_by_id: LookupMap::new(StorageKey::TokensById.try_to_vec().unwrap()),
            token_metadata_by_id: UnorderedMap::new(
                StorageKey::TokenMetadataById.try_to_vec().unwrap(),
            ),
            owner_id,
            metadata: LazyOption::new(
                StorageKey::NFTContractMetadata.try_to_vec().unwrap(),
                Some(&metadata),
            ),
        };
        this
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;

    use super::*;

    const MINT_STORAGE_COST: u128 = 5870000000000000000000;

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.nft_token("1".to_string()), None);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }
}
'''
'''--- nft-contract/src/metadata.rs ---
use crate::*;
pub type TokenId = String;
//defines the payout type we'll be returning as a part of the royalty standards.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: HashMap<AccountId, U128>,
} 

// Defines the common good project, anything that needs to define or be built atop this contract
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct NFTContractMetadata {
    pub spec: String,              // required, essentially a version like "nft-1.0.0"
    pub name: String,              // required, ex. "Mosaics"
    pub symbol: String,            // required, ex. "MOSIAC"
    pub icon: Option<String>,      // Data URL
    pub base_uri: Option<String>, // Centralized gateway known to have reliable access to decentralized storage assets referenced by `reference` or `media` URLs
    pub reference: Option<String>, // URL to a JSON file with more info
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

// Metadeta describing an item; Producer takes picture, describes it, 
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenMetadata {
    pub title: Option<String>, // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
    pub description: Option<String>, // free-form description
    pub media: Option<String>, // URL to associated media, preferably to decentralized, content-addressed storage
    pub media_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    pub copies: Option<u64>, // number of copies of this set of metadata in existence when token was minted.
    pub issued_at: Option<u64>, // When token was issued or minted, Unix epoch in milliseconds
    pub expires_at: Option<u64>, // When token expires, Unix epoch in milliseconds
    pub starts_at: Option<u64>, // When token starts being valid, Unix epoch in milliseconds
    pub updated_at: Option<u64>, // When token was last updated, Unix epoch in milliseconds
    pub extra: Option<String>, // anything extra the NFT wants to store on-chain. Can be stringified JSON.
    pub reference: Option<String>, // URL to an off-chain JSON file with more info.
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
    pub category: Option<String>,
    pub labels: Option<Vec<String>>
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Token {
    //owner of the token
    pub owner_id: AccountId,
    //list of approved account IDs that have access to transfer the token. This maps an account ID to an approval ID
    pub approved_account_ids: HashMap<AccountId, u64>,
    //the next approval ID to give out. 
    pub next_approval_id: u64,
    //keep track of the royalty percentages for the token in a hash map
    pub royalty: HashMap<AccountId, u32>,
}

//The Json token is what will be returned from view calls. 
// This is what will be visible to the UI
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonToken {
    //token ID
    pub token_id: TokenId,
    //owner of the token
    pub owner_id: AccountId,
    //token metadata
    pub metadata: TokenMetadata,
    //list of approved account IDs that have access to transfer the token. This maps an account ID to an approval ID
    pub approved_account_ids: HashMap<AccountId, u64>,
    //keep track of the royalty percentages for the token in a hash map
    pub royalty: HashMap<AccountId, u32>,
}

pub trait NonFungibleTokenMetadata {
    //view call for returning the contract metadata
    fn nft_metadata(&self) -> NFTContractMetadata;
}

#[near_bindgen]
impl NonFungibleTokenMetadata for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}
'''
'''--- nft-contract/src/mint.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    #[payable]
    pub fn nft_mint(
        &mut self,
        token_id: TokenId, // for Producers, this should be AccountId + Timestamp?, for Distributors, this should be Account Id + Original + Timestamp?
        metadata: TokenMetadata,
        receiver_id: AccountId,
        root_id: Option<TokenId>,
        perpetual_royalties: Option<HashMap<AccountId, u32>>
    ) {
        //measure the initial storage being used on the contract
        let initial_storage_usage = env::storage_usage();

        // create a royalty map to store in the token
        let mut royalty = HashMap::new();

        // if perpetual royalties were passed into the function: 
        if let Some(perpetual_royalties) = perpetual_royalties {
            //make sure that the length of the perpetual royalties is below 7 since we won't have enough GAS to pay out that many people
            assert!(perpetual_royalties.len() < 7, "Cannot add more than 6 perpetual royalty amounts");

            //iterate through the perpetual royalties and insert the account and amount in the royalty map
            for (account, amount) in perpetual_royalties {
                royalty.insert(account, amount);
            }
        }

        let token = Token {
            owner_id: receiver_id,
            //we set the approved account IDs to the default value (an empty map)
            approved_account_ids: Default::default(),
            //the next approval ID is set to 0
            next_approval_id: 0,
            //the map of perpetual royalties for the token (The owner will get 100% - total perpetual royalties)
            royalty,
        };

        assert!(
            self.tokens_by_id.insert(&token_id, &token).is_none(),
            "Token already exists"
        );

        self.token_metadata_by_id.insert(&token_id, &metadata);

        //call the internal method for adding the token to the owner
        self.internal_add_token_to_owner(&token.owner_id, &token_id);

        // Construct the mint log as per the events standard.
        // This information will be available to subgraph
        let nft_mint_log: EventLog = EventLog {
            // Standard name ("nep171").
            standard: NFT_STANDARD_NAME.to_string(),
            // Version of the standard ("nft-1.0.0").
            version: NFT_METADATA_SPEC.to_string(),
            // The data related with the event stored in a vector.
            event: EventLogVariant::NftMint(vec![NftMintLog {
                // Owner of the token.
                owner_id: token.owner_id.to_string(),
                // Vector of token IDs that were minted.
                token_ids: vec![token_id.to_string()],
                root_id: root_id,
                // An optional memo to include.
                memo: None
            }]),
        };
        env::log_str(&nft_mint_log.to_string());

        let required_storage_in_bytes = env::storage_usage() - initial_storage_usage;
        
        //refund any excess storage if the user attached too much. Panic if they didn't attach enough to cover the required.
        refund_deposit(required_storage_in_bytes);
    }
}
'''
'''--- nft-contract/src/nft_core.rs ---
use crate::*;
use near_sdk::{ext_contract, Gas, PromiseResult};

const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(10_000_000_000_000);
const GAS_FOR_NFT_TRANSFER_CALL: Gas = Gas(25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER.0);
const MIN_GAS_FOR_NFT_TRANSFER_CALL: Gas = Gas(100_000_000_000_000);
const NO_DEPOSIT: Balance = 0;

pub trait NonFungibleTokenCore {
    //transfers an NFT to a receiver ID
    fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce an approval ID so that people with that approval ID can transfer the token
        approval_id: u64,
        memo: Option<String>,
    );

    //transfers an NFT to a receiver and calls a function on the receiver ID's contract
    /// Returns `true` if the token was transferred from the sender's account.
    fn nft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce an approval ID so that people with that approval ID can transfer the token
        approval_id: u64,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<bool>;

    //get information about the NFT token passed in
    fn nft_token(&self, token_id: TokenId) -> Option<JsonToken>;
}

#[ext_contract(ext_non_fungible_token_receiver)]
trait NonFungibleTokenReceiver {
    //Method stored on the receiver contract that is called via cross contract call when nft_transfer_call is called
    /// Returns `true` if the token should be returned back to the sender.
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> Promise;
}

#[ext_contract(ext_self)]
trait NonFungibleTokenResolver {
    /*
        resolves the promise of the cross contract call to the receiver contract
        this is stored on THIS contract and is meant to analyze what happened in the cross contract call when nft_on_transfer was called
        as part of the nft_transfer_call method
    */
    fn nft_resolve_transfer(
        &mut self,
        //we introduce an authorized ID for logging the transfer event
        authorized_id: Option<String>,
        owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce the approval map so we can keep track of what the approvals were before the transfer
        approved_account_ids: HashMap<AccountId, u64>,
        //we introduce a memo for logging the transfer event
        memo: Option<String>,
    ) -> bool;
}

/*
    resolves the promise of the cross contract call to the receiver contract
    this is stored on THIS contract and is meant to analyze what happened in the cross contract call when nft_on_transfer was called
    as part of the nft_transfer_call method
*/ 
trait NonFungibleTokenResolver {
    fn nft_resolve_transfer(
        &mut self,
        //we introduce an authorized ID for logging the transfer event
        authorized_id: Option<String>,
        owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce the approval map so we can keep track of what the approvals were before the transfer
        approved_account_ids: HashMap<AccountId, u64>,
        //we introduce a memo for logging the transfer event
        memo: Option<String>,
    ) -> bool;
}

#[near_bindgen]
impl NonFungibleTokenCore for Contract {

    //implementation of the nft_transfer method. This transfers the NFT from the current owner to the receiver. 
    #[payable]
    fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce an approval ID so that people with that approval ID can transfer the token
        approval_id: u64,
        memo: Option<String>,
    ) {
        //assert that the user attached exactly 1 yoctoNEAR. This is for security and so that the user will be redirected to the NEAR wallet. 
        assert_one_yocto();
        //get the sender to transfer the token from the sender to the receiver
        let sender_id = env::predecessor_account_id();

        //call the internal transfer method and get back the previous token so we can refund the approved account IDs
        let previous_token = self.internal_transfer(
            &sender_id,
            &receiver_id,
            &token_id,
            Some(approval_id),
            memo,
        );

        //we refund the owner for releasing the storage used up by the approved account IDs
        refund_approved_account_ids(
            previous_token.owner_id.clone(),
            &previous_token.approved_account_ids,
        );
    }

    //implementation of the transfer call method. This will transfer the NFT and call a method on the reciver_id contract
    #[payable]
    fn nft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce an approval ID so that people with that approval ID can transfer the token
        approval_id: u64,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<bool> {
        //assert that the user attached exactly 1 yocto for security reasons. 
        assert_one_yocto();

        //get the GAS attached to the call
        let attached_gas = env::prepaid_gas();

        /*
            make sure that the attached gas is greater than the minimum GAS for NFT transfer call.
            This is to ensure that the cross contract call to nft_on_transfer won't cause a prepaid GAS error.
            If this happens, the event will be logged in internal_transfer but the actual transfer logic will be
            reverted due to the panic. This will result in the databases thinking the NFT belongs to the wrong person.
        */
        assert!(
            attached_gas >= MIN_GAS_FOR_NFT_TRANSFER_CALL,
            "You cannot attach less than {:?} Gas to nft_transfer_call",
            MIN_GAS_FOR_NFT_TRANSFER_CALL
        );

        //get the sender ID 
        let sender_id = env::predecessor_account_id();

        //transfer the token and get the previous token object
        let previous_token = self.internal_transfer(
            &sender_id,
            &receiver_id,
            &token_id,
            Some(approval_id),
            memo.clone(),
        );

        //default the authorized_id to none
        let mut authorized_id = None; 
        //if the sender isn't the owner of the token, we set the authorized ID equal to the sender.
        if sender_id != previous_token.owner_id {
            authorized_id = Some(sender_id.to_string());
        }

        // Initiating receiver's call and the callback
        ext_non_fungible_token_receiver::nft_on_transfer(
            sender_id,
            previous_token.owner_id.clone(),
            token_id.clone(),
            msg,
            receiver_id.clone(), //contract account to make the call to
            NO_DEPOSIT, //attached deposit
            env::prepaid_gas() - GAS_FOR_NFT_TRANSFER_CALL, //attached GAS
        )
        //we then resolve the promise and call nft_resolve_transfer on our own contract
        .then(ext_self::nft_resolve_transfer(
            authorized_id, // we introduce an authorized ID so that we can log the transfer
            previous_token.owner_id,
            receiver_id,
            token_id,
            previous_token.approved_account_ids,
            memo, // we introduce a memo for logging in the events standard
            env::current_account_id(), //contract account to make the call to
            NO_DEPOSIT, //attached deposit
            GAS_FOR_RESOLVE_TRANSFER, //GAS attached to the call
        )).into()
    }

    //get the information for a specific token ID
    fn nft_token(&self, token_id: TokenId) -> Option<JsonToken> {
        //if there is some token ID in the tokens_by_id collection
        if let Some(token) = self.tokens_by_id.get(&token_id) {
            //we'll get the metadata for that token
            let metadata = self.token_metadata_by_id.get(&token_id).unwrap();
            //we return the JsonToken (wrapped by Some since we return an option)
            Some(JsonToken {
                token_id,
                owner_id: token.owner_id,
                metadata,
                approved_account_ids: token.approved_account_ids,
                royalty: token.royalty,
            })
        } else { //if there wasn't a token ID in the tokens_by_id collection, we return None
            None
        }
    }
}

#[near_bindgen]
impl NonFungibleTokenResolver for Contract {
    //resolves the cross contract call when calling nft_on_transfer in the nft_transfer_call method
    //returns true if the token was successfully transferred to the receiver_id
    #[private]
    fn nft_resolve_transfer(
        &mut self,
        //we introduce an authorized ID for logging the transfer event
        authorized_id: Option<String>,
        owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce the approval map so we can keep track of what the approvals were before the transfer
        approved_account_ids: HashMap<AccountId, u64>,
        //we introduce a memo for logging the transfer event
        memo: Option<String>,
    ) -> bool {
        // Whether receiver wants to return token back to the sender, based on `nft_on_transfer`
        // call result.
        if let PromiseResult::Successful(value) = env::promise_result(0) {
            //As per the standard, the nft_on_transfer should return whether we should return the token to it's owner or not
            if let Ok(return_token) = near_sdk::serde_json::from_slice::<bool>(&value) {
                //if we need don't need to return the token, we simply return true meaning everything went fine
                if !return_token {
                    /* 
                        since we've already transferred the token and nft_on_transfer returned false, we don't have to 
                        revert the original transfer and thus we can just return true since nothing went wrong.
                    */
                    //we refund the owner for releasing the storage used up by the approved account IDs
                    refund_approved_account_ids(owner_id, &approved_account_ids);
                    return true;
                }
            }
        }

        //get the token object if there is some token object
        let mut token = if let Some(token) = self.tokens_by_id.get(&token_id) {
            if token.owner_id != receiver_id {
                //we refund the owner for releasing the storage used up by the approved account IDs
                refund_approved_account_ids(owner_id, &approved_account_ids);
                // The token is not owner by the receiver anymore. Can't return it.
                return true;
            }
            token
        //if there isn't a token object, it was burned and so we return true
        } else {
            //we refund the owner for releasing the storage used up by the approved account IDs
            refund_approved_account_ids(owner_id, &approved_account_ids);
            return true;
        };

        //we remove the token from the receiver
        self.internal_remove_token_from_owner(&receiver_id.clone(), &token_id);
        //we add the token to the original owner
        self.internal_add_token_to_owner(&owner_id, &token_id);

        //we change the token struct's owner to be the original owner 
        token.owner_id = owner_id.clone();

        //we refund the receiver any approved account IDs that they may have set on the token
        refund_approved_account_ids(receiver_id.clone(), &token.approved_account_ids);
        //reset the approved account IDs to what they were before the transfer
        token.approved_account_ids = approved_account_ids;

        //we inset the token back into the tokens_by_id collection
        self.tokens_by_id.insert(&token_id, &token);

        /*
            We need to log that the NFT was reverted back to the original owner.
            The old_owner_id will be the receiver and the new_owner_id will be the
            original owner of the token since we're reverting the transfer.
        */
        let nft_transfer_log: EventLog = EventLog {
            // Standard name ("nep171").
            standard: NFT_STANDARD_NAME.to_string(),
            // Version of the standard ("nft-1.0.0").
            version: NFT_METADATA_SPEC.to_string(),
            // The data related with the event stored in a vector.
            event: EventLogVariant::NftTransfer(vec![NftTransferLog {
                // The optional authorized account ID to transfer the token on behalf of the old owner.
                authorized_id,
                // The old owner's account ID.
                old_owner_id: receiver_id.to_string(),
                // The account ID of the new owner of the token.
                new_owner_id: owner_id.to_string(),
                // A vector containing the token IDs as strings.
                token_ids: vec![token_id.to_string()],
                // An optional memo to include.
                memo,
            }]),
        };

        //we perform the actual logging
        env::log_str(&nft_transfer_log.to_string());

        //return false
        false
    }
}
'''
'''--- nft-contract/src/royalty.rs ---
use crate::*;

pub trait NonFungibleTokenCore {
    //calculates the payout for a token given the passed in balance. This is a view method
    fn nft_payout(&self, token_id: String, balance: U128, max_len_payout: u32) -> Payout;
    
    //transfers the token to the receiver ID and returns the payout object that should be payed given the passed in balance. 
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: u64,
        memo: String,
        balance: U128,
        max_len_payout: u32,
    ) -> Payout;
}

#[near_bindgen]
impl NonFungibleTokenCore for Contract {

    //calculates the payout for a token given the passed in balance. This is a view method
    fn nft_payout(&self, token_id: String, balance: U128, max_len_payout: u32) -> Payout {
        //get the token object
		let token = self.tokens_by_id.get(&token_id).expect("No token");

        //get the owner of the token
        let owner_id = token.owner_id;
        //keep track of the total perpetual royalties
        let mut total_perpetual = 0;
        //get the u128 version of the passed in balance (which was U128 before)
        let balance_u128 = u128::from(balance);
		//keep track of the payout object to send back
        let mut payout_object = Payout {
            payout: HashMap::new()
        };
        //get the royalty object from token
		let royalty = token.royalty;

        //make sure we're not paying out to too many people (GAS limits this)
		assert!(royalty.len() as u32 <= max_len_payout, "Market cannot payout to that many receivers");

        //go through each key and value in the royalty object
		for (k, v) in royalty.iter() {
            //get the key
			let key = k.clone();
            //only insert into the payout if the key isn't the token owner (we add their payout at the end)
			if key != owner_id {
                //
				payout_object.payout.insert(key, royalty_to_payout(*v, balance_u128));
				total_perpetual += *v;
			}
		}

		// payout to previous owner who gets 100% - total perpetual royalties
		payout_object.payout.insert(owner_id, royalty_to_payout(10000 - total_perpetual, balance_u128));

        //return the payout object
		payout_object
	}

    //transfers the token to the receiver ID and returns the payout object that should be payed given the passed in balance. 
    #[payable]
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: u64,
        memo: String,
        balance: U128,
        max_len_payout: u32,
    ) -> Payout { 
        //assert that the user attached 1 yocto NEAR for security reasons
        assert_one_yocto();
        //get the sender ID
        let sender_id = env::predecessor_account_id();
        //transfer the token to the passed in receiver and get the previous token object back
        let previous_token = self.internal_transfer(
            &sender_id,
            &receiver_id,
            &token_id,
            Some(approval_id),
            Some(memo),
        );

        //refund the previous token owner for the storage used up by the previous approved account IDs
        refund_approved_account_ids(
            previous_token.owner_id.clone(),
            &previous_token.approved_account_ids,
        );

        //get the owner of the token
        let owner_id = previous_token.owner_id;
        //keep track of the total perpetual royalties
        let mut total_perpetual = 0;
        //get the u128 version of the passed in balance (which was U128 before)
        let balance_u128 = u128::from(balance);
		//keep track of the payout object to send back
        let mut payout_object = Payout {
            payout: HashMap::new()
        };
        //get the royalty object from token
		let royalty = previous_token.royalty;

        //make sure we're not paying out to too many people (GAS limits this)
		assert!(royalty.len() as u32 <= max_len_payout, "Market cannot payout to that many receivers");

        //go through each key and value in the royalty object
		for (k, v) in royalty.iter() {
            //get the key
			let key = k.clone();
            //only insert into the payout if the key isn't the token owner (we add their payout at the end)
			if key != owner_id {
                //
				payout_object.payout.insert(key, royalty_to_payout(*v, balance_u128));
				total_perpetual += *v;
			}
		}

		// payout to previous owner who gets 100% - total perpetual royalties
		payout_object.payout.insert(owner_id, royalty_to_payout(10000 - total_perpetual, balance_u128));

        //return the payout object
		payout_object
    }
}
'''
'''--- nft-contract/src/update.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    // Method called by Organizers when they submit category or labels
    #[payable]
    pub fn nft_update(
        &mut self,
        token_id: TokenId,
        category: Option<String>,
        labels: Option<Vec<String>>
    ) {
        let mut token_metadata = self
          .token_metadata_by_id
          .get(&token_id)
          .expect("No token found from id");
        
        if let Some(category) = category {
          // TODO: do manipulations based on existing + prior category selections
          token_metadata.category = Some(category);
        }
        
        if let Some(labels) = labels {
          // TODO: do manipulations based on existing + prior labels
          token_metadata.labels = Some(labels);
        }

        self.token_metadata_by_id.insert(&token_id, &token_metadata);

        // Construct the mint log as per the events standard.
        // This information will be available to subgraph
        let nft_update_log: EventLog = EventLog {
            // Standard name ("nep171").
            standard: NFT_STANDARD_NAME.to_string(),
            // Version of the standard ("nft-1.0.0").
            version: NFT_METADATA_SPEC.to_string(),
            // The data related with the event stored in a vector.
            event: EventLogVariant::NftUpdateLog(vec![NftUpdateLog {
                // Vector of token IDs that were updated.
                token_ids: vec![token_id.to_string()],
                
                category: token_metadata.category,
                labels: token_metadata.labels,
                // An optional memo to include.
                memo: None
            }]),
        };
        env::log_str(&nft_update_log.to_string());
    }
}
'''
'''--- package.json ---
{
  "name": "near-collect",
  "version": "0.1.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "build": "yarn build:web",
    "build:contract": "cd nft-contract && ./build.sh && cd .. && ls && cd market-contract && ./build.sh && cd ..",
    "build:web": "yarn build:styles && parcel build src/index.html --public-url ./",
    "build:styles": "npx tailwindcss -i ./src/global.css -o ./dist/output.css",
    "deploy": "yarn build && (yarn test:contract && near dev-deploy --wasmFile res/non-fungible_token.wasm)",
    "dev": "yarn build:contract && near dev-deploy && yarn dev:start",
    "set:contract": "source contracts/nft/neardev/dev-account.env",
    "lint": "eslint \"./**/*.js\" \"./**/*.jsx\"",
    "start": "yarn build:web && parcel src/index.html",
    "dev:start": "env-cmd -f ./neardev/dev-account.env parcel src/index.html",
    "test:contract": "(cd contracts/nft && cargo test -- --nocapture)",
    "test": "yarn test:contract && jest"
  },
  "devDependencies": {
    "@babel/core": "^7.14.0",
    "@babel/preset-env": "^7.16.4",
    "@babel/preset-react": "^7.13.13",
    "@typescript-eslint/eslint-plugin": "^4.22.1",
    "@typescript-eslint/parser": "^4.33.0",
    "autoprefixer": "^10.4.2",
    "babel-jest": "^27.4.2",
    "eslint": "^7.32.0",
    "gh-pages": "^3.2.3",
    "jest": "^26.6.3",
    "jest-environment-node": "^26.6.2",
    "near-cli": "^3.0.0",
    "near-sdk-as": "3.2.3",
    "nodemon": "^2.0.7",
    "parcel-bundler": "^1.12.5",
    "parcel-plugin-static-files-copy": "^2.6.0",
    "postcss": "^8.4.5",
    "react-test-renderer": "^17.0.2",
    "sass": "^1.44.0",
    "tailwindcss": "^3.0.15",
    "typescript": "^4.5.2"
  },
  "dependencies": {
    "@apollo/client": "^3.5.8",
    "@heroicons/react": "^1.0.5",
    "@tailwindcss/forms": "^0.4.0",
    "axios": "^0.25.0",
    "big": "^0.5.2",
    "big.js": "^6.1.1",
    "env-cmd": "^10.1.0",
    "graphql": "^16.2.0",
    "near-api-js": "^0.44.0",
    "prop-types": "^15.7.2",
    "react": "^17.0.2",
    "react-camera-pro": "^1.1.1",
    "react-dom": "^17.0.2",
    "react-infinite-scroll-hook": "^4.0.2",
    "react-router-dom": "^6.2.1",
    "react-table": "^7.7.0",
    "regenerator-runtime": "^0.13.9",
    "styled-components": "^5.3.3"
  },
  "resolutions": {
    "@babel/preset-env": "7.13.8"
  },
  "staticFiles": {
    "staticPath": [
      "public"
    ]
  },
  "jest": {
    "projects": [
      {
        "displayName": "User interface tests",
        "testEnvironment": "jsdom",
        "testMatch": [
          "<rootDir>/src/tests/ui/*.js"
        ]
      },
      {
        "displayName": "Integration tests",
        "testEnvironment": "near-cli/test_environment",
        "testMatch": [
          "<rootDir>/src/tests/integration/*.js"
        ]
      }
    ],
    "testPathIgnorePatterns": [
      "assembly/*"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- src/App.js ---
import "regenerator-runtime/runtime";
import React from "react";
import PropTypes from "prop-types";
import { Link, Outlet } from "react-router-dom";

const App = () => {
  // const signOut = () => {
  //   wallet.signOut();
  //   window.location.replace(window.location.origin + window.location.pathname);
  // };

  return (
    <main className="flex flex-col h-full w-full text-black bg-white pb-32">
      <header className="h-32">
        <div className="z-40 mx-8">
          <div className="relative flex items-center text-gray-500">
            <div>
              {/* <h2 className="text-xl">{currentUser.accountId}</h2> */}
            </div>
            <div className="ml-auto -my-1 hover:text-gray-700">
              {/* <button onClick={signOut}>Log out</button> */}
            </div>
          </div>
        </div>
      </header>
      <Outlet />
    </main>
  );
};

// App.propTypes = {
//   currentUser: PropTypes.shape({
//     accountId: PropTypes.string.isRequired,
//     balance: PropTypes.string.isRequired,
//   }).isRequired,
//   wallet: PropTypes.shape({
//     requestSignIn: PropTypes.func.isRequired,
//     signOut: PropTypes.func.isRequired,
//   }).isRequired,
// };

export default App;

'''
'''--- src/components/camera/ReactCameraDivs.js ---
import styled from 'styled-components';

export const Wrapper = styled.div`
  position: fixed;
  width: 100%;
  height: 100%;
  z-index: 1;
`;

export const Control = styled.div`
  position: fixed;
  display: flex;
  right: 0;
  width: 20%;
  min-width: 130px;
  min-height: 130px;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  z-index: 10;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 50px;
  box-sizing: border-box;
  flex-direction: column-reverse;
  @media (max-aspect-ratio: 1/1) {
    flex-direction: row;
    bottom: 0;
    width: 100%;
    height: 20%;
  }
  @media (max-width: 400px) {
    padding: 10px;
  }
`;

export const Button = styled.button`
  outline: none;
  color: white;
  opacity: 1;
  background: transparent;
  background-color: transparent;
  background-position-x: 0%;
  background-position-y: 0%;
  background-repeat: repeat;
  background-image: none;
  padding: 0;
  text-shadow: 0px 0px 4px black;
  background-position: center center;
  background-repeat: no-repeat;
  pointer-events: auto;
  cursor: pointer;
  z-index: 2;
  filter: invert(100%);
  border: none;
  &:hover {
    opacity: 0.7;
  }
`;

export const TakePhotoButton = styled(Button)`
  background: url('https://img.icons8.com/ios/50/000000/compact-camera.png');
  background-position: center;
  background-size: 50px;
  background-repeat: no-repeat;
  width: 80px;
  height: 80px;
  border: solid 4px black;
  border-radius: 50%;
  &:hover {
    background-color: rgba(0, 0, 0, 0.3);
  }
`;

export const ChangeFacingCameraButton = styled(Button)`
  background: url(https://img.icons8.com/ios/50/000000/switch-camera.png);
  background-position: center;
  background-size: 40px;
  background-repeat: no-repeat;
  width: 40px;
  height: 40px;
  padding: 40px;
  &:disabled {
    opacity: 1;
    cursor: default;
  }
  @media (max-width: 400px) {
    padding: 40px 5px;
  }
`;

export const ImagePreview = styled.div`
  width: 120px;
  height: 120px;
  ${({ image }) => (image ? `background-image:  url(${image});` : '')}
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  @media (max-width: 400px) {
    width: 50px;
    height: 120px;
  }
`;
'''
'''--- src/components/shared/utils.js ---
export function classNames(...classes) {
  return classes.filter(Boolean).join(" ");
}
'''
'''--- src/config.js ---
const CONTRACT_NAME = process.env.CONTRACT_NAME || 'common-good.collect.testnet';

function getConfig(env) {
  switch(env) {
    case 'mainnet':
      return {
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.near.org',
        helperUrl: 'https://helper.mainnet.near.org'
      };
    // This is an example app so production is set to testnet.
    // You can move production to mainnet if that is applicable.
    case 'production':
    case 'development':
    case 'testnet':
      return {
        networkId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org'
      };
    case 'betanet':
      return {
        networkId: 'betanet',
        nodeUrl: 'https://rpc.betanet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.betanet.near.org',
        helperUrl: 'https://helper.betanet.near.org'
      };
    case 'local':
      return {
        networkId: 'local',
        nodeUrl: 'http://127.0.0.1:57583',
        keyPath: '/Users/ebraem/.neartosis/2022-01-31T17.52.46/validator-key.json',
        walletUrl: 'http://127.0.0.1:57631',
        contractName: CONTRACT_NAME
      };
    case 'test':
    case 'ci':
      return {
        networkId: 'shared-test',
        nodeUrl: 'https://rpc.ci-testnet.near.org',
        contractName: CONTRACT_NAME,
        masterAccount: 'test.near'
      };
    case 'ci-betanet':
      return {
        networkId: 'shared-test-staging',
        nodeUrl: 'https://rpc.ci-betanet.near.org',
        contractName: CONTRACT_NAME,
        masterAccount: 'test.near'
      };
    default:
      throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`);
  }
}

module.exports = getConfig;

'''
'''--- src/global.css ---
@tailwind base;
@tailwind components;
@tailwind utilities;

'''
'''--- src/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="./favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <link rel="apple-touch-icon" href="./favicon.ico" />
    <link href="../dist/output.css" rel="stylesheet">
    <!-- <link rel="stylesheet" href="global.scss"> -->
    <title>NEAR collect</title>
    <meta property="og:title" content="NEAR collect">
    <meta property="og:description" content="for the common good.">
    <!-- <meta property="og:image" content=""> -->
    <!-- <meta property="og:url" content=""> -->
    <!-- <meta name="twitter:card" content="summary_large_image"> -->
  </head>
  <body class="bg-white text-black">
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `yarn dev`.
      To create a production bundle, use `yarn build`.
    -->
    <script src="./index.js"></script>
  </body>
</html>

'''
'''--- src/index.js ---
import React from "react";
import ReactDOM from "react-dom";
import {
  BrowserRouter,
  Routes,
  Route,
  Navigate,
  useLocation,
} from "react-router-dom";
import { ApolloClient, InMemoryCache, ApolloProvider } from "@apollo/client";
import * as nearAPI from "near-api-js";

// Routes //
import App from "./App";
import NotFound from "./routes/NotFound";
import SignIn from "./routes/SignIn";
import Start from "./routes/Start";
// producer
import ProducerApp from "./routes/producer/ProducerApp";
import ProducerDashboard from "./routes/producer/ProducerDashboard";
import ProducerItems from "./routes/producer/Items";
import ProducerOrders from "./routes/producer/Orders";
// distributor
import DistributorApp from "./routes/distributor/DistributorApp";
import DistributorDashboard from "./routes/distributor/DistributorDashboard";
import DistributorItems from "./routes/distributor/Items";
import DistributorOrders from "./routes/distributor/Orders";
// organizer
import OrganizerApp from "./routes/organizer/OrganizerApp";
// transporter
import TransporterApp from "./routes/transporter/TransporterApp";
import TransporterDashboard from "./routes/transporter/TransporterDashboard";
import TransporterOrders from "./routes/transporter/Orders";
// vendor
import VendorApp from "./routes/vendor/VendorApp";
import VendorDashboard from "./routes/vendor/VendorDashboard";
import Ideas from "./routes/vendor/Ideas";
// storage
import StorageApp from "./routes/storage/StorageApp";
import StorageDashboard from "./routes/storage/StorageDashboard";
import StorageItems from "./routes/storage/Items";
// camera
import Camera from "./routes/camera/Camera";
import Question from "./routes/camera/Question";
import Submit from "./routes/camera/Submit";

// Config
import getConfig from "./config.js";

// Initializing contract
// async function initContract() {
//   const nearConfig = getConfig(process.env.NEAR_ENV || "testnet");

//   // create a keyStore for signing transactions using the user's key
//   // which is located in the browser local storage after user logs in
//   const keyStore = new nearAPI.keyStores.BrowserLocalStorageKeyStore();

//   // Initializing connection to the NEAR testnet
//   const near = await nearAPI.connect({ keyStore, ...nearConfig });

//   // Initialize wallet connection
//   const walletConnection = new nearAPI.WalletConnection(near);

//   // Load in user's account data
//   let currentUser;
//   if (walletConnection.getAccountId()) {
//     currentUser = {
//       accountId: walletConnection.getAccountId(),
//       balance: (await walletConnection.account().state()).amount,
//     };
//   }

//   // Initializing our contract APIs by contract name and configuration
//   const contract = await new nearAPI.Contract(
//     walletConnection.account(),
//     nearConfig.contractName,
//     {
//       // View methods are read-only – they don't modify the state, but usually return some value
//       viewMethods: [""],
//       // Change methods can modify the state, but you don't receive the returned value when called
//       changeMethods: ["nft_mint"],
//       // Sender is the account ID to initialize transactions.
//       // getAccountId() will return empty string if user is still unauthorized
//       sender: walletConnection.getAccountId(),
//     }
//   );

//   return { contract, currentUser, nearConfig, walletConnection };
// }

// // Initializing client to common-good subgraph
// const client = new ApolloClient({
//   uri: "https://api.thegraph.com/subgraphs/name/elliotbraem/common-good",
//   cache: new InMemoryCache(),
// });

// window.nearInitPromise = initContract().then(
//   ({ contract, currentUser, nearConfig, walletConnection }) => {
ReactDOM.render(
  // <ApolloProvider client={client}>
    <BrowserRouter>
      <Routes>
        <Route path="/login" element={<SignIn />} />
        <Route
          path="/"
          element={
            // <RequireAuth currentUser={currentUser}>
            <App />
            // </RequireAuth>
          }
        >
          <Route index element={<Start />} />
          <Route path="producer" element={<ProducerApp />}>
            <Route index element={<ProducerDashboard />} />
            <Route path="piles" element={<ProducerItems />} />
            <Route path="orders" element={<ProducerOrders />} />
          </Route>
          <Route path="distributor" element={<DistributorApp />}>
            <Route index element={<DistributorDashboard />} />
            <Route path="piles" element={<DistributorItems />} />
            <Route path="orders" element={<DistributorOrders />} />
          </Route>
          <Route path="organizer" element={<OrganizerApp />} />
          <Route path="transporter" element={<TransporterApp />}>
            <Route index element={<TransporterDashboard />} />
            <Route path="orders" element={<TransporterOrders />} />
          </Route>
          <Route path="vendor" element={<VendorApp />}>
            <Route index element={<VendorDashboard />} />
            <Route path="ideas" element={<Ideas />} />
          </Route>
          <Route path="storage" element={<StorageApp />}>
            <Route index element={<StorageDashboard />} />
            <Route path="items" element={<StorageItems />} />
          </Route>
          <Route path="camera" element={<Camera />} />
          <Route path="question" element={<Question />} />
          <Route path="submit" element={<Submit />} />
          <Route path="*" element={<NotFound />} />
        </Route>
      </Routes>
    </BrowserRouter>,
  // </ApolloProvider>,
  document.getElementById("root")
);

function RequireAuth({ currentUser, children }) {
  let location = useLocation();

  if (!currentUser) {
    // Redirect to login page
    return <Navigate to="/login" state={{ from: location }} replace />;
  } else {
    return children;
  }
}

'''
'''--- src/neardev/dev-account.env ---
CONTRACT_NAME=dev-1643666280054-49542898614731
'''
'''--- src/tests/integration/App-integration.test.js ---
// these are made available by near-cli/test_environment
// note: do not remove the line below as it is needed for these tests
/* global nearlib, nearConfig */

import 'regenerator-runtime/runtime';

let near;
let contract;
let accountId;

beforeAll(async function() {
  near = await nearlib.connect(nearConfig);
  accountId = nearConfig.contractName;
  contract = await near.loadContract(nearConfig.contractName, {
    viewMethods: ['get', 'getById'],
    changeMethods: ["create", "update", "del"],
    sender: accountId
  });
});

it('create an item and retrieve it', async() => {
  const item = await contract.create({ name: 'rock' });
  const actualItem = await contract.getById({ id: item.id });
  const expectedItem = {
    id: item.id,
    name: 'rock',
    labelled: false,
    category: null,
    labels: null,
    creator: accountId
  };
  expect(expectedItem).toEqual(actualItem);
});

'''
'''--- src/tests/ui/App-ui.test.js ---
// import 'regenerator-runtime/runtime';
// import React from 'react';
// import TestRenderer from 'react-test-renderer';
// import App from '../../App';
// const { act } = TestRenderer;

// // Declare stubs for contract, walletConnection, and nearConfig
// const contract = {
//   account: {
//     connection: {},
//     accountId: 'test.near'
//   },
//   contractId: 'test.near',
//   getMessages: () => new Promise(() => {}),
//   addMessage: () => ''
// };
// const walletConnection = {
//   account: () => ({ _state: { amount: '1' + '0'.repeat(25) } }),
//   requestSignIn: () => null,
//   signOut: () => null,
//   isSignedIn: () => false,
//   getAccountId: () => 'test.near'
// };
// const nearConfig = {
//   networkId: 'testnet',
//   nodeUrl: 'https://rpc.testnet.near.org',
//   contractName: 'test.near',
//   walletUrl: 'https://wallet.testnet.near.org',
//   helperUrl: 'https://near-contract-helper.onrender.com'
// };

// // For UI tests, use pattern from: https://reactjs.org/docs/test-renderer.html
// let container;

// beforeEach(() => {
//   container = document.createElement('div');
//   document.body.appendChild(container);
// });

// afterEach(() => {
//   document.body.removeChild(container);
//   container = null;
// });

// it('renders with proper title', () => {
//   let testRenderer;

//   act(() => {
//     testRenderer = TestRenderer.create(
//       <App contract={contract} wallet={walletConnection} nearConfig={nearConfig} />
//     );
//   });

//   const testInstance = testRenderer.root;

//   expect(testInstance.findByType('h1').children).toEqual(['NEAR Guest Book']);
// });

'''
'''--- src/utils/colors.js ---
export const PRODUCER = "red"
export const DISTRIBUTOR = "orange"
export const ORGANIZER = "yellow"
export const TRANSPORTER = "green"
export const VENDOR = "blue"
export const WAREHOUSE = "purple"
'''
'''--- src/utils/near.js ---

'''
'''--- src/utils/piles.js ---
export const piles = [
  {
    token_id: "producer.collect.testnet1644537274182",
    receiver_id: "producer.collect.app",
    metadata: {
      description:
        "elliot on a plane, mask, plain white t shirt, flannel",
      media: "data:image/jpeg;base64,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"
    }
  },
  {
    "token_id": "producer.collect.testnet1644538726875",
    "receiver_id": "producer.collect.app",
    "metadata": {
      "description": "pax, alcohol wipe, napkin",
      "media": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4gIoSUNDX1BST0ZJTEUAAQEAAAIYAAAAAAQwAABtbnRyUkdCIFhZWiAAAAAAAAAAAAAAAABhY3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlkZXNjAAAA8AAAAHRyWFlaAAABZAAAABRnWFlaAAABeAAAABRiWFlaAAABjAAAABRyVFJDAAABoAAAAChnVFJDAAABoAAAAChiVFJDAAABoAAAACh3dHB0AAAByAAAABRjcHJ0AAAB3AAAADxtbHVjAAAAAAAAAAEAAAAMZW5VUwAAAFgAAAAcAHMAUgBHAEIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFhZWiAAAAAAAABvogAAOPUAAAOQWFlaIAAAAAAAAGKZAAC3hQAAGNpYWVogAAAAAAAAJKAAAA+EAAC2z3BhcmEAAAAAAAQAAAACZmYAAPKnAAANWQAAE9AAAApbAAAAAAAAAABYWVogAAAAAAAA9tYAAQAAAADTLW1sdWMAAAAAAAAAAQAAAAxlblVTAAAAIAAAABwARwBvAG8AZwBsAGUAIABJAG4AYwAuACAAMgAwADEANv/bAEMAAwICAgICAwICAgMDAwMEBgQEBAQECAYGBQYJCAoKCQgJCQoMDwwKCw4LCQkNEQ0ODxAQERAKDBITEhATDxAQEP/bAEMBAwMDBAMECAQECBALCQsQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEP/AABEIAtABwQMBIgACEQEDEQH/xAAdAAACAgMBAQEAAAAAAAAAAAADBAIFAAEGBwgJ/8QAPRAAAgIBAwMDAwMDAwMDAwQDAQIAAxEEEiEFMUETIlEGYXEUMoEjkaEHFVJCscEzU2IIFhcYVHKS0eHw/8QAGgEAAwEBAQEAAAAAAAAAAAAAAQIDAAQFBv/EACYRAAMBAAMAAwACAgIDAAAAAAABAhEDEiEEEzEFQRRRImEyccH/2gAMAwEAAhEDEQA/APIulWCu4GwzombeoNbYnKaN1U+48zo9GTdWAqkgz0aeFO7G9NS9j7i+eZfaPpwcBnXMB0rpwUh3Bx3l/SyVnAHE4+S2yk0wQrNahUSO0NYFCiQVl3FiuRDaY1uxbOMTiqmy6om1LOOe8i9ZCYBMPvUgkHiRF1ROIqC+Qgqn0hnvJU4GSeZC+0oQAOJKtwRxGwk6TJMlV1gUrJHSuj+ztNohHvURpXcrmHBsRCuogDdCNjgfExH3nBHbzMFe58QrwVoJXWLBlYb9OCu11BEJRQEAx/MOqqCczp4+TCbRyHXPp97c3UV8dyJzqaOyqzBGMT1Ra0cFHGQZQdZ6GEJ1FIyCeRO2efEUidOc0dIRw7LPQvoD6a1P1H1WjR0pn1GGcjsJzXS+m16hgtnGJ9V//Tf/AKf1VUP9QajTkh8LUWH98Tzvlc/Z9UehEfXHdnof0x9IJ0bo9GkFQBRRnAlk+hRQSR2nYPpkVQAPE5D686jX0Hod+qTi23+nXj/kZ5vLfRayfHf21iPCv9WdWes9XGh0Tj0tJwcdi0qekf6HdZ+sPpvVdZqUV1UqxUlclyO+0eZfdD+l9Z9Q9Xq05O6zUWcsfv3M+n+g9G0vQekabpOlQCrT1hO3f5MX4XJ/kU2vwr8zk/xZUr9PzC+rPp5+mXvS4yVJHbHacdbpMsa8cT6+/wDqz+idD0v6h0fVem6VKU6kjG1VX2m0efgT5W6tpH01jb12mevw8nvU521cKzlNYv6a7aoyDEba1cEucZ8Sz1e5rDleB5lZqAATPV45TXpwclpCGoJqO1RmJvfdp2FgpZwTg7RnEeFXqPjn+ZYaLQBu65H4nQpSObdN9N9G6gW8g9xniPK6lCXA4hrNFUKfaMY+ImoO0qoJkrwaUwVrBidvAm/X9OvAPEjaVrXaV7xaxmFZcj2zmv1lp1GG7nfu4iWquYWj0+R5grdSSdqDgw2krDNl+YnUomwtRyQR3llTqSi4KgiANVaYNYBz3jK1Iaic4MP4H1k/WrZNyn3fEkL2KgOefiKJ/TYk9oTC3AMvcfaK/TejBvcNsxxJE5wpMjWQ2MjmERAXJIziZQmJTZtbNinIxNJqnwUPI+ZF3BbGzgRVmwxKnEVwhVpY6ewN7TNW22U+5cYi9LkAEQt1vqAAjBEm+MvLZpdZuQjHeaTdYc/EypFDe5eDGtIgRi2MiHrgWmzKTYzAMpwPmMNWu7Im0YM547yVqbP2mBvCTQqy3MxAUbR95lLYYqxx8Sb2emMmKEl33qcQdmBPP6HksBs2KP5ljoEDvyIl04VOxV/3eZaV0MSDSQOYG9HVIf2bVwIra5QHLRjUWehp8k84lI+ptss2g5z4k/q0eaGv1S/JmQP6PU/+y39pkH0j9jzXSIr3jPz2nc9F0nsVtmJzfSelm3UraQcA5+09E0NdT0KtaAYE6uXk0goQzSqLWAFELUiZw3mALGt9vfEm1qv24M4rbN+DeEXgdprNK8dsyGnQEbnf+JGwqX4xJYzO0hhiqVcEkSIKgBgIIsCNueJouysAQSsdSJ20Lu3sAxhyqIo2wSopG/E2u4sCBxG/sKGanbsY0m7GMd4BbFC5K8xjT73GTwIynSiaMSpg32jG3aAQOZCuxQ4DQ9mGIKw9Qtm6zYTz2hiCBmaqAbGTiFdAOFbMAhlLhjjEcShLUKsvBiVZ2nOJZaV1YcjETl5ei8OjhnWN/TX0WvWeuaPQ6dWLX3KoC9+8+5PpjodHQOj6XpmnqVEprAwB5xyZ8d/SfWW6N1HT67TtttocOpn1z9E/WWi+q+lV6mt1GpUAXVg8qfmeTx/JV8j39Or5atcaz8OgeontPE/9TetP136hXoujbdptCRu29msPf+09Y+r+v0/TPQNV1O1l3qu2pSf3OeAJ4v8AS/TtT17q9VSkGy6w2WPjtzkmed/NfJfFM8U/+VD/AMRxdqfNf5J3v+lf0sdN6nWtVXtb/wBOlT4Hkz0mL6HSVaLTV6alQFRQOIxPd/jvjf4vx5h/v9nl/M+Q/k8z5P6/o8c/+pvpNev+j9Hq20wc6XVglwOUBBH9sz4Y+remvXqbC5BXJxP0O/1u0yan/TnqYdc7Arj+DPhH6x0QrTO3uM8946px8n/o6/jtV8fP9HlOvqVRKS4KW/b2l71ZG9y5I5lQun2gbmzPf4+RHFfGgVFCWWAKnIlxRoSo3QfTtMDYGI4zLawJUMMRiO+QRcaKp7dpKFceIo4VAxUjmO66zTcsuCcSk1Op2AkN/Ek+TSihIDa9m87orqdSGr9JnwJJ9T6qYBwT2ihAJw4yYnrD4BsqfaPSbucx/Q0WlgWbvBrW3p+0ARrRtZWvvBz8gQbgvYdFJ3YVgMQFl715UwjWMeV7xW2xicEQ/oexNLTYuAe0LVYasgmD09la+6zjEDqrltOKzgZ7yqhMzvCxTUEjJHEnTqnckDiJ0lWQYbxJ71r5UwucE7aMtqQrEEZM0RW6524b8RdbksOQQTHQa/TGOWMTB1OmUKioSzYMyuwPcB4g2OF7TdNYGHc4HeP1Q6losQldg28SIK0qQDNCytQNvOZtwv72PEnUm9RHR6h0ybD54ja3BjuJiqim3ATjEi2aW45BkXAPTd1gtsIELRSMgsICqp7Ldx/tLfS6E3EBuAJGpwaY03p9F79y8Zltp6WpAOTCafTIqYGOJu20VrhpJvBuiK/qdxchAZr6d6Ndrup1kZKLyeOJIodTaFVeSZ3X030g6LTqxXDNN9uA6pB/9op/9tf7TJb+gfvMi/abDxnpmjqoUJsGRLZMVH2dostYB47xupCB78S3bWT7IkpWxskyL/0yWBziRYDJVTF10rLZ6r2Mcf8ATniZzpJ16N0W737mNPUFw/z4ldXaFswBH032LycCTawyWhBSp944xN7iW2kcQlbbF2nBmVlHs2kcxOxRQiVeB+IUNWAfbNmj4MkqKp2mNumzCCe/sI1Q749wIkqqkBziNCtCmOMwgYBQpbdjJEbUrsG4QNGmIszkERtqQBkjiK7FaYq5OfY2JKjUPWcNkwp06N78mbNVZHwYn2AyiY1aE5xHtM+QCOxlcKV4IxxHNM5ztAMjyUrRfipyy50dgFg5nf8A0V9WdR+neq0a3S6l9qEb688OvkGea12FMHzLTQ6q4urjjE8nm+Ot1Hox8hNZR7h/qJ/qFX9aavQabp9N1Wh0y+o4sGGa0/btgT0P/SToC0aA9btQhrxtqz/x8n+Z8/dL1nqoAwyxxmfVn0frek636f0b9HsrNCVKm1ONrAcgjwczk+PxT8r+RVcr9lbgfkcv0fD+viXjfpdTJkyfWHhHI/6q0V6n6H6hTa2FZVBP8z4a/wBRakqudKzlewn3Z/qRULvo/XqTjCBv7GfD/wDqMtN9z2VkHk9p5PLzdfmrj/609X4cduBv/s8T6rWu5iRyJWafTNa3KeZddXpLWECE6dplWrNi4+5nucdkOWMF6dKKVDsBFNfarKQrdpaazFakqeJy3UtUFDAMJTtpzelZrdT6Zba5lYupey3ZjcDM1V76gkKO3mLAGobweRGQcZO5yt3s8Tb2hQHfiLpqLLLMlOI0KjdgnkSykDeDuj1FOxcnMPZqFHCxP0hWBgdoPeWuxzN0EVaNnUOcYAx5kSlj2BlOBJhq1VVdRzCC6kj2nGJlJRLSD6c4GTIGkeDgQvrbv28mDuyADyCZRGqGzF2MprVsQdTsjem+SPBM3XgcY5PmTtqcYKzUTSwlWoQ7hxmN1WAHdu4+Myvrt3ua/I7wjoQoAaTfheaws/WUrkYMi+oVh27RapE2DL/5m3BT7zdsKKxujUg4LDgw9rh/2NxKqt2D7WGAYb9QtNm0nMZUmK6bHVaytcpxMFttrAESCOLVABxC1BsbcjMV4wyt/R7QqQ/v5l/oufaBzKTTJtwzHMudMc4dTic9ydE4NHfS4B5BmtQQ67sYmnsDjLHtB1k6i0VKSc8Tk5FhZRpafS/TbNXrfUwCicz0nTaZRWFAxiVn0h0SvQaVdy5Z/cxM6Y1Ih9oxOK6w31psT/SiZHdo+f8AEyR+0P0nhAb3AAxgOWAWK+1exzDIpIyDPWSPHdhAPdzMsdAuDIkkNtJ7yS0qxwTmOLrYuikWblORHF3gAg8TK6tvG3GIVaSV4ERjyzaOcgeYzXWocOTzMp06kB88iFFZY8SdNIfcJ72yMcyfpsfcciSqRU/d3EYWg3DIbiJ3Qjem9Mgde8PVUa245z8zEVKUAEIuoVRyAIrrQaSFZT3ZxmTWwkY7xe3UbzhTJb1RMk8ybbG1mPcxO0cTdas2YBCztvPaOVMNsm2NrMoYoxDiNU2bWyvEFWgbnvDIqg/BiaOtDozltxEtdFYCnMqK7wTs8x3T2CsjJkrlsrLw63pGpKMrdsT13/T76wv6G4akG3T2EevUO/5H3nhmi1204xidj9N9bGntUZIBnzH8v8blWc/A8ufUz0/jVFr679TPrbp+v0/U9HVrdJYHqtUMpEZnkv0T9Ynpu2l7C+kc5ZPNZPkfb7T1XT6inVUrfRYro4yGByDPf/gf5qP5Xh635yz/AOS/+r/o8r5vwq+Jf+5f4zn/APUcE/RHWCvcaVyP7T4W+tbg9mxgAcdp96fWelOt+lOq6VTg2aWwD+0+Bvqymy7UB7Dg9pH+Q7R/Kcdf01/9Oz4Hvx7X/Z5/qem+paWHMW11Yq0+w8S71Gnetiynic91e5uQTkCfR8NNnLyUU2u1HoV7S05XWt6rFQ+M/Jll1fUhwRu7feczbdYXIbOJ2zLZz9kDO8WFVPEIKN+MmB3E2ZGcRyndndHUs3ZEF0wBwO0YpQIMZ7QtKoHzZ/aa1GFJKER0mTr0C7kPhsD4mkqxYHPAMEtyucMMmMeptXHgSiEXhl6N3U5EAMgjcvA7wrXgYHzI+qGGD5h0btgVbVTlBCPdT6WWwW8cQAtrRCvzEH1OGIbkfEAysaGpKWc8iMfqS1ZIz8Sp9UPYCOcRk2ErgDERsOph9PYtVh3JknzDH1GtyORERcudp4x5jen1QwFPOIrZtG66kZw4BBH3mamzbz3MxrUxlPMWtcqPcOIj0yoIt24hmHaF3B23RTS2AsQADntD+5D/AOINaHTHKmKrzGKC5sAUGJ0W5OCvaXehpUr6mRmK+TCsjmkpc4z5l3pVT/08gYldpSAQHj61BP6iNJVyD4zL/baFB4nR/R/RRq9V+oZCVQ5nOgG6xVRdxJwAJ6x9KdJ/Q6FA6gM4yROLk5P6LS2kWWkpKkKowBHiVHBHM2ECD2iAcEHM4OSy8sJuWZA5PzMkNKdjwvZkZkqy6uABkQ4qUVgkYMgcrzPXXKfONEbG3HIGDJVkLzk5+JJHSz2gfzNenhsgZx3lFyBSZqzUOxwAY5Va2wbhBDY6jjkQlZViAP5mdaP6NUbmyTD15VuJqqpT2hUoKtkniSph9YWuouAzDiFdmqA2HAm63AGAeBBW5J3ZJkdN0bCGw2L+ItZY7YVD2h0atgQDzIBMEnEdUD62QBYEcw1lo2hR3gcEmGrrUgFu8FUMpaJ1u1a88iMac+rk5xAAndtIzmNV1njAkW2VSGdOG34XtGzWCfiLUWijhu5hUuBbkwookbKCttwEb0rLYfcYvlTmQS1an5MZozRcVP6Tbc5l30/VBdpU8icrXfuIYHIlt0/UqDyJx/I4e8tFeNuWeldD656OzNhB8z1P6Q+vK+m2LVqGZtLZ+4DnYfkCfP2l1yjDA4I+8u9F122orh+J8nXwuX4vyFz8PjR632cfPxfXyfh9aX2afqnSbbNPYtlV9LbWXnIInwX9YaN9JrtTpnI3VXOv4GZ9H/6d/wCoy9L1Y0XUbyvTrRzkFtjfIA8TwT/VZdOn1V1TU6c7qNRqHtrbGMgnM+h+Ryf5c8fM1/yX6cHxp/x6vjb8Z5pr7lWth5E4Lr9tr7ihxidV1bUgO2TxOL6xqDaStXH3nu/Dp0lpz80rTk9ULLHJLHMUZMjOMxrVVXixjziLIrg578z2IWo4nIxp9KHXhYzTotpy3MzTCzggcGN1sAhXPPmUSwUWupqUbt2DEdQRgANHNVjdgniV99ibCAMnxHRmZ+nQH1QZA+oeAeIPF5TKkgTQutDBPEbBQqIQrMw/ETfVW0vgrx8xmy5uEOJBkUqd/OZvBOrYOy9WYOxmbFcGwY+0WuVR+35hatu3aXzJ1SQylhK1Rfc2MwpUA5zwe0UsIZwqsQDGq69pAd8jE53RQi+mFgyW2yVVTp7VJ/MLfavpjYA2PENpcsocoBnuJlQGtJKrYyWxia5JKnnMIa2sbg8SKsqnaw5ELoMyBrRq7+DiWGmqa20b+xiW5XfOM4j+gcrZuLZU/ac9XheJRY1aSo27QeZZUaUUMCDkHvA6apLcODHlUA7AcyXZssvBms1kDmSv1Som1Gi/pMoOMmLaWqzV69aWOFLAEn4kuSsQy9O++geknqF41ltfsTsT8z1SuoIq4HEo/pPR6HQdOrppZeAM4M6VVV1BXxOHk5MRWZbYQICmccxe6n4MOd68YkSjNzON32LqWhP02+Jkb9MTIuhxnh9pBXbjtACr1PJEw2Pjkcza3f8AQBz+J6uJHiqdNqErG1VwYzVWhqweGPmZVUtgye8y2srjDQqhuhGqhFJGc5h1oVOVGDA1qVXv3haWcsEJ4h7f0BrBmhTnOYQvn25glf0zwZjuP3LA0wrBhLAvAMkGBOImthB3eZtb2TvzmJ1KLBhgqft7wikis57wVZJG9+IY2rjiFIOIDUWweYSpmZtjcTaVE5ZRxJojHsOZnIH4MVqqNljmHFmTgAfaC/SFlBJIIhKq8EqRF6iaTbOQSRmEWsghjBsvpDOZNNT7ORzGnEFayZJbJEE2R8yS2AHMILV/4xm0OpYTT2MAF2x7T2hDkmVzWEcqcTQuszy3Bk6SYcaOgTWA/taP16xwVy3+ZzFN23jPMf0mqXIV2zOW+FUx5to7TQdSKAEP/EQ+rNJX1vRsD/6ijKnzK9dT6K5VuPzB29TITk5HxG4+FfgXTPGvqItpbbdM6kMCRzOL1XqF+GM9s+r/AKeo67phqtOgS9OTx+4Tx7X6d9Lqba3QgocGer8eVIlPSh1KuR7smL16R3tAHbyJabPVfIEcr0WACBPSm8IMVr0o9PGSMRO+t6gRWePJlzZSUrOCCMSnvLMxXPEb7BOpW32WI248iL3rYRvC8GP2117SO5ESsds4BxHVpgcgk3hMMf4zC11rt3AA5m0SsjeTz5+8i7BFO3sY3ZE8YCx1ps94zAX60FsAcCQu2vZtyd01sVj6bcYi0xkD3WWHsNuYehFU5LAZmErSuBgiAYB8vnB+0569KeDN9tS8gDibS0MNx/bFFDMNpUEHzCtXivap79xEUtk6eB3tTvXzmOaRb9u48LKqlbFICrulpTqyoVHUDMdQxU3o2EfBYGQCndhucyTagFAFPHxANeVYAngwUmi0+jddaVHDDGYWoqtmEPESDu7ZZiR4j2mQkjjkznqW2WXhddOZiMnIEsKjXXl+5PzE9CVKAMpUj5hLrakGDF6MHZmruqNQWK+e0W0/VXW3fnnPeKX3IzHcOIsjK7kKOIt8aaKcdNM9C6N9Y9V0RU1270PBUz1D6V+rk6jWtVuFtI7Znz/pNU1ZWtDmdF0/qmq6dYmppcggieXzcLTO+LVI+ixZvXkzXqEZAnG/Tn1emtqQaiwK+MTqqtQlo3A95xVDRZMPu/EyR9vyP7zInofDwwqdoJhUqU+8iRqZTjeMxq1x6YVF7z23KPD9Qur7mIXiHRWI5MhVXtG6TV1HcxWkDWRZLKzubkSSKxO4SbXI2F7wZ1CqdqrDKB6wrp7cg8wLWWKOF7d4Su4txiTZQhyecyqSDjAp6till4mVCwHL8w9TDaVB7zDSdmS2DM0jKWZuZuM8Q2nRrG2nxFl3IDnmH0rujEkd5Kmh5lliSKl2KYTTZ3ZxxNUadbgGYx1UqQcEcSVMZ+Gs57wTWLnjxJ3WZ4Ai+0HzF7E2zLbnPGCZoNhYRVJOIG0bbOe0dAltk/W4z2hK793BHMFmkEZ5kWuCsNo4mLJsZLllPyJumwkYIgVY2DIOIQHbgEzYHRpVGQ2Y1VhfdFKfbz3m3d2xtOI6gTsW1epLDaZIIlpO5sCI0thRzkzZuZSDNmAdDxbYPSUAj5M4f6z+la9UG1emrAfuwA7zsRqi2AozDGlbv3rkHvLTeCdjwQ6JNLuLoe/kRnT0NaPaOJ6H9T/SVThtTRUCDyQBOM1Onv0akV14A758Sy5BljKnU0KgK7sSi16ekTg5JlrqbwbCGJyZX6jTu7EryJSa0dpJFOjKQwsJDRX0rLCV2nHzLLU6cFcr4gFR9hZPE6JZKhVwtfsLHJ7CCuVsYMe9FWT1WByIjfajKRnBEomRwWb08c9xEWudrMbDzGnsHIKn8wWSARt+4MJs9AXGxEPJ3eBB6TVWE4tTHM2bmazNnPOBCGlm92OJlGhDB1NwKZ2nxJPeq3hNp5iqG+okYz8faSrtuezBHOeTGXGxWixpZeWUYMIgD5JHIi21yQcnmTCWKTgmP1wMyHRwFLL3mxYlnB7yDFVrBXv5kNOSSQwxJMslhYacFuVHbzLvRUghXBGZTaNLCfaDtl/odPYGBxkSbSGHl45YYAg7VS5S3gRnbxhxxKzX6gplF4Em8AVXUL3V8VjMEtxCiw8TLLkbzmK6iyxgFXMWlo6ZcdM1KrZvJzOk0d4vwGIxOGosNYB34l103qfp+1zx/mcvJx9i08mHofTNVXpwuWxjtO46H9TKyrVY+B2BzPH6Ne1wDI548S50WtsRQwYzzuXgaOiebT2j/dKf/eX+8yeT/wC/Xf8AI/2mTn+sfuCyo9ytzDUuGGWbmIUlSO/MYKkAET0dPNb38HCxVDhoCt8E7x3hakbUIB8eYR6FA24hWC4KvbjxJ1vWxGV5kXqIPYmEprrC5Yc/ebw3VjKkBScSKMrnGcwLh2/a3ELTVjlRzNum/CRq9Fsgd5r1WZu/Em+4qVJ5iqUWZ5sx/MdIKsY7HOcw9d204IzAKuxcE5haVUtycTOUDuxynVPuAGQI0dQAMk94mDWhAEkzhm2ntI1KFdtjK378zW/A/dn+YtgKdoPeHQ1KuJPBdbCV27ue2JG1C3OeZjuijxJLau07x+IRksYozE+0HBHmGReMsMibWnecgcQgY1+1l4MKLJmI2B7RDINxEDZ7QCuJOm3ngR0ZtDJs2nAGIStSzd4FTvIyI3T3xHSJNoYpVUxnHMYelGTK4zA1qGODHKKg2QCABErwXRWvTkN+7mOqRWoUjJgyuGyPEYpTd+4DBkfseh0IlFV1JW3sZ599adGbSFrdOhNTZ5+J6IVAXaInq9NptVQ2nvUMrDkESvHejdsPnXXq3rHK4Iifr3YKhsZ4nd/WH0s/T9W1tYzUxyrf+Jx2o0orOMc/ad/F6HtpXvXZs/buHnEkoWqnaK/c3mPVIURgwA+MxLUMyE5OROpIX9Ebg9atvYfiUmoddxOecy/uqW1TuPeUmq0DV2MxOVMrMgfgj+oVrNpktRXYyBlIwJo1KH/aeJp7Sqkf4llAjoVHP717eYWvVY9n9pJVZ0JK8yS6avbuAw3mU/BHRFGGeTy0MFCHcBA1VguR/wBRh2Pophzk+IdB2YZNRWi5ZcyL61bM7MYMioWyklxtgl05zhTxA1o6phAwVC7Nn7RnRN6vBXEhptE1jBQcjzLvQdNGQCAPiQtJFpbGOk6ezeAQGHxidLUq1suVAA8RfpWjFLbSBn5lhqaMe4DtOKq9HE9ZqquUUgGUmqDOxZjkR3VV7GazMrH1G4MvPEmm2YqtZYqMRXx5MHpb/WOGBUfJhdQq+tkjvNV1na2VGI6Yyw36eSxzwJBbWQ45kGdk5zgTS6ipjtYQi0jo+h6mhPabCzHvOv0N2nKDkZnAaB6Fy1aDJ7tOi6a+AGss4P3keSE/00NnSbqvkTJXfqNP/wAmmTl+uS3ZjelZSdoMslVSgXcJUb10+SIzpbw65dsSf6jnzCzruFC4zJ/qAylieJXtaNpOczVdruvbAgaYdGmtLHA7Sd5ArGB3iDPYR7COO8kmps27Wb+8GM2odpY7QMw9b7WxmJU6heFPeM14ALEiHGLqCsx35PIgbrCzbU4xB1XA2GvOcmHc1KvuPuPaVmdFbw0thKgN3jFJrPZpXqbWBwv8wtVZX9pOe8p1J1Q+F54OYQDHY8xOt2DbW7xkEhcRXIusJUOSzHtCrmwkAmLgsRxG9KVVeZGvBkS9AZGeTI31vkFcw1dibj5M2bdxK7YvZFEaqcogzMNiueTNrQXOc8TH0+07pk9H1IzCkYzmCBZLNqmTOTwo5m66Dw7d4RGxmpWyCY/TgsBjmJCxlAEaoswd4AEPbwnrLDYqruJwZpXx+1u8jTYtgy5hFVC3HiTp6VS/2Fopew5jSo4XnjEXqsZBgGE9V1GCe8ng2I362xsEwbOCSRNY3eZmUBAxHh4I0I9Q6dV1ShqbkBBHHE8o+o/pfV9N1tgYZTuuPie0LtP7TKvr/Rk6rQVIAYDgzu4uTALw8E1aXJwBnHmKNU1v78zrOt9Hu0N9iWVkYPH3nNXWGqwjtO6OTsUxCmpRBWFQciV+pVtnIlg7Ndnb3iVgdiVLcSqpgaX9lf6aYORnMS1FAzlfHiWToASMjiAChmz5ErNsRpMBp0Fgw/AgLwK32qe/mWqpWAQQMmCTSiy33JuWN2J9WV9ahCXHPEkGFmQ6Yx9pY26akAisYPxBVaVyCbB+OIVSMpYtWAvtAyDGK6hnJHEI1CqoKn+IxRVux/5j90VmWyem0nG9PM6LptA2cjJEQ0dJIAUCXmmQ1BRjM5uSkyqkbopG0k8RbV64VD0weBGzbsQgiUnULa9+3PM5GtZmsFeoaxyMKu78SnOt9NiHU5+I9Y4U+45lTrNVp6bCzgn+IUkgGFl1Fu8nBk2sZBtTkeYDTr6r71yoPIhnpNZPuzkRlgGBsqa6snIBiVSqlvptHErfOXb2mL6gIHyveHwXWWmm9gChuJYU6wK+A5wO8pKLTXXyc5jA1AZQV7xKlMeaz9L79dR/yP8AaZKj9R+Zkl9ZX7Ed2cE4cZkWtVHAXIzJtlTiKMWLE4zPPlkWP12rtyTNrczkqpOIgbWIA7Ad4Wm4bcKZVM56pobW1UbG7mT3Ybv3itVRcliY0tfbPMPhPuyWnW0XFmPtjvq59vzxA1jI2qOZtVcsARiL4grswtaJU+8DJjDBXGYJAFPzGamTOSBB2wfGYhWscrIWsSwZeJO5kKbl8eIpXa9hORgCMr02DW/47w9TsRhxFKwTZ2jW4gYXvKJaAJWxVzvPH2j1KBgDuP4iFS8gYzLKpQihm7QOB0jewbsgdpJuBwJjW5/YvEnXg85knMoKk1WtzEHsIy1Tuu0GRqOTth67ADiReIfPQFNAXORzCekM89oVV3PyYw2mUJnMHYbqLrWjDgciRfCNy3EOKwgyTAWhTkxlQjWBK7SpG05zGqWcnceBK+vdgYjVFzKwB5HmPmit4x6vBPLHELawOFQxRrVKHaMGFpBABJzB1MrCI7K2CCZvPuJIk7tRSiAKuTAm8dz5mxBVIJQ4Nn4joVLO5xK4WKpyMcw1dpGSx/EpLwOoqPqz6d03VdG4CgOoypHfM8U6106zSXPVYhDLnkjGZ7/YxYYbzOL+tvpmvqela7THFyc8DuJ1cfJgO54ydyAnsRK3Vm4vhPPeXvU+lW6dipzxKZqbFs93OO064tMV22KVglirjvGa61Q4CiS9I7s4jACKm4gEymoCbAYqI3bcjtmaR2RyBWNsO+1wM8faaqKhiQv94OyLITuJzvVCMQ1O5x7xDtWMlif4kVdc4Aiu8KKdAnToORmN6cCxQgHMLTVVYOTHNDolyXBHftN9o2Yb0VNhfbLauu5CPj7yNVddfPmNGwkA4xEfImL6K23f1NjSp6kN77l7y4dambJ7yt1X6cll3+6I6FaZRagMvcZzANQpX1LEzGdWWXO0E/aBS3KEWY/ERsGYKKzC8c4WPvWrJkc5le6l7sdlEdW0qnB4h9N2QrqLAqisYz5kK9Olykr+6Q1fucMQRMquC4FfBjLQaiS6NkJ3OP4mVJhiO4E2LHWz35APeN1ipxlSBiNgNQHJ+TMhN1fzMi4DUegPYHGCvMVfdv8AbgCCs1xB9oH8yLan1BjbgiePKZqYwyZXJkKmqL7AeZFNQTkfEZ0tND+4jmWSYnXRutNqAd4zUW7MBE67CHKDIAjhIrr3ZmxjzCJhyjggiNVsj+eZWi6t+7AYhatVU2QrdonVj5KLFgFXKyNZODmInUlW75EMLg68dpsYrwOGyDkze0Y9p5MRSxt+0HvD7bk57iEniY5RWUXOckwiqVOGEVrv2EZbMZ3LYQwMrLA5G6SCw4lh6qbNplbU4BEbQpjk5jNhSGAygY8TFUE7l/mCQg9ziFBVULBsmI50ol/omzFeUOSIXTtvO5jEw2494fTK6gmTqUMkWtdYYZEI25MA8iK03Oo5k7NUNuT2k3ODpaTuIK5g619T2kTK3Fo/P3h6k9M57/eBAqSPoBeB3mjhBnEO2CC3mLu/OJaaOa5aC17bftJNbYntSCRigyokXtZSGaUXpBtoxrXb9xziYLWIzzgdppl9XJQYJ8SIR04aHEZUxmvUoF9zQiapScZlZYvu4MJU2OMGK8RRay1ybBxIGgbSGHea01m0bTDOy5zmKrwopOB+sfpFnrfXaWvJxlhPMtTpTU5DVnP4n0Rcgur2MvtIxPPfrT6KasNr+nIXU8svxLTzYUmUeVhAWIAImm0TbQd2TnMtLdB6DlrMg/EUvyvJyB4lfvKqExZ9KVALSAUVnlZOzUOeByIAtqS/9RECDsQckzfc2OowMzCwYCyJqKAADJkqSzthFx8xtdoADiMrGU/6Eloccq2D8S16ZXfsy4xIppUYB8/xiWmlwo/bxHVaK0zdft9zDOJj2s/I4HxGT6bDwAO8r9Xq6gxpqzx5xGwHRiustdD+7kyrsLVktnOYzqWsz+4N/MXRWJyZuuBzAZIYYYRS7SM4Lq3Etk0m4B2A/ELXo0rDE458RWybls5lEb1QuMyws0qisNu5lh+koLEisbv+0V1BSgEWNx2mRN8ZV6zaoC+YuV2ruHEPqGrZwPPiCtUAgeDKJCOcMtsBp3AjMTTUtu4bmEfncm7GIntCWDBGIyRNj/qGZFvWHzMm6ienf2KzWe0cCTCOf2EwhZRkosnTsDbvmeLNnS+LCYqWpAzd8QtOQN3gyOfVyniGqUZFcp2EawNXYF9zCSs1DONoJAMXdgrbe8nagNPqbtuPEdUhdf8ARBlBIHgQqAp7lXgwWnZbQCMkDvLAqnpAIRzGVIGUALORlYRLiigP3mFAighuZoekzgMYG0b0KtgzvA5EML7WIIOYN6wF/pydKOBl+8VpATDhAPcx7xmkZgNhsAxniOVKFXJWBMbsSL7eQMmSNzKNwBzNbVX3EZg7r6sYXGR4j6bskPV6oMnIwYWu0EcmVtb7lABwYxWTkCHBlY4H92QMxul3P2iOnzv57R9cA5EXppTuG3YMhYQR8iQewkYAh6QpA3QVAv2YE04HtwMRtrWUYA4haKkChlEhe6E7TxiScpAfI2BtuIGAeIEMSe03dkttHmbUEgY7iLqTB/yomLCo5PE02LefEmKwyZbkzBsrB/7Sisy49B7mrGZH1XcklZjMGB5mIy4IYzOxvrF3t3Hkw1DBh3zItUh5I4kUUVncg4k22bqWFdhThhB+rddbt8QR1IG1cZhEsAUssm2H8LKs4QKTyJlmyytqrFyrDES017FsEEx0DPJhVBWnmH1t9NtprDqNJUfTYnOPE4G+i5n2HsJ9FarQVa/TPp7EBDDHaeWfVH0y3Sb2JrbYf2tjj8SstFo08+/SMrltpxJGsEAkYlnZX79uOB3ieqQlsqMAfMsihBKhjdWCPxCJVgFn/jM1QtznJbjtHTRuQJjA8xk2hXTRDSAhSX7Rhb9nsUcTXppXTguBjtF/WCP3H5looHZsY1GoZUwPMr7MnDZxmSusBtyr5z4kCxbidCYdIKvuOecyfp4ODMrqcNyRGn07WIG3AERXQrZBblrTaRgzTHK7s8yC02K3u5AhlpZwMCT/AEV0zFWsVlmHJ8yg6om4EknbmXmpGK9oIBEpdZgjbmPEaJXIJVKhAJHHzM1zUisMpGZhG1dpOJV6gsGKA5+JdQc9XrBWr6uSlpUkd/iAprtUbbzkjz8xmvRMCX37c8nmacZGByRHxIX1kPTSZNzIum6nqVdalM+PEEVw2FOJNkauoqhJ+8XFZdGBfa3zPDiDpdoYrZ9wGOIz6iJ45Mr9PvD7N2cRpFO/LSvXBNTD4A955JkHHqg1t2MI6naCh4xMrr9u5jzAElURUnpoAAIRLHzjGYJgfI7SdXB7wKWLrQwV3DBkFrqVwd3bxNnJHE3Rpiz7j5j9RG2xlb0ZhWq/zGfTxjnM1+kThgMYjOnrQt35iU8MpC6RUbCkYjN1K1KNvM3WioMgczLuUyTFV4HoJ32OSBnC/EXu09hYMhGPMLcR45MgLrAmAvMZcmiOQ2nVgBzzHKV8kxOguBkkZPeHBZvanA+ZRVoUsGhaBYEUR2olhtzgytq9hy0cqDl94bErKNo0qsG5EaFYYgxSu7L4aPAgoMTUjY2MJaUXHiC1OzG4Wd4o+p2+yLX34HDczltMopDNqSr45x8yaalgcjtK+t2tOCYwxCJgGS6Mf8HU1BOee0z1g2c8SvpuO7BMaHPAh6m7YyTFgcg8TBcpGAIKxzgqBBKD5gH7DXr4HabrtD+BFlKk8mSJVDwYAdg9ip3XxJUuS3fEXVzu75hQGHuziBmTLPS7Q3YRxnrXA3cmVWn1G1BnvGsLYQ7GSaYywsqHC8wfVOn0dW0b6W1VZWHnxBKdy4UxvTqyoMmNDY6Z4v8AU30tqeiaqwMB6ZOUIE5fUaZ7SA5wPmfRHXOj6XrGiam8ZbHtOOxnj31D0NtDedOaiNvOfE6obH7ajntLpBp0wpLfmMO2ys5HM2VZAOcQGpsATLuJ1xLYjwXexbRiJ21vgkt+JFtUu8gSLOzrnOT4nREYA0qOBum6/U5y2IxWuavcRnE3RWN+GHOY7RsYfT6dwu/92e0IyunuPmFUuntIwphkoa4he4kqWgwUQb257Qo3Vg/Esq9CiKcjmJ6moqSAMTTKFbKXXvZhjn+ZRanUAHB5b5lz1ewV1kE9++Jy11m59q8g+Z0xJGiLLe1ptN7bfC+JPgHLAE/eLPa9RwHyIN7ntAIOJX/0IpHmCW+0NgdzFjYgsNeOPmbros27s/mA9m8qSciTG/A+yr/n/mZFdi/8j/eZBiNp6w2SuAcRNg2/zDVsTndxMOoSttuJ481gM0CEsQ7+fzDq4bGDN+qLVwRxBrXtfcvb4jN6Mlg5XZt9rHIMYzWteQ/MTwGxiGCKoBPOIrY2oMroy7SO8kDt4AkNyHbhY9VUuAzATJhzQVCM7ZccR8bVAC8Yi7su7ap7SNlhXHMDoKSG7NQ4AGMRrR217fd3ld6gIB/vGKLEIwveRpNm7JFitxZsDIAmX31+mVDcyvsvcEDPE1uDZA7mJ1Y26SBbOc8RihkZuTxAKAMKSMzMGs+0/mFS0BpDrtUv/pmSoYlsiIFnBBXnPiPUDYMkS8bpNpIM4J5Ea0qMy4ZokLdz4AOI9VZWFHPM65pImMpSqjvzCtqPTXaYvUHJ3FoHUXbWJaZtMZIhfeSxOYmzs7Ft5P2g9TazE44EBVeA2AM/Mm5QdLJLSoAxCre1rBcRNCW55Aha2FThicwdUbuOttqQMw7Qa6o2N/TBwITD6hQVHEitTVuRgASVShW2wy2Bl57zasGBwYsSRYeYRHCjBksHW4YpOSP8zfuBAJzMUgniScYG4cw4MFr7gYjCrlcGKpcQRgRlGYjMVoZE0UrgHtGqzlcZgEJIyRGNOynOROetKJYM6du2DLLT2Dhe8plZkf2cyx0bblDWYBk12024WX9Nh95UfUH0xp+t6Y4GyxRkMBLBrMH28iSXUuvC8ZnVxOhXSPCevdOs6dqLqHVg9Z7EYzOQ1L6ixtrrgeZ9DfWv0xV1/Q+pVhNVWMqcd/sZ4T1nTWaa2yh0IsrJBBnpcLYrooHuAsCLGqt3Y9ooyM752HOfiWOm01pxleDO9IHcYIHpjCn8w1GlYkWMSJYaPpxdB6oHEsqen1jHGR5gaCrEK6EdQGP+IyqCnCr28GHs0ao5CtgTforjMjUs3c3lmT5lZqlckhj/ADLCwFBuQ9pW6q4c57wzIvbTner4G5cZnK3FfU2D25l71O8m1sHgHzKHUAuxsJHHadMIVrQeopULndyYutnpKdw/BjPD17yQcSuuuyTXiV6g8Q5XrXA27sgyNBNljbgAPmIqxDDP+ZY6apHUktg4gcC6T9Gv/kJkzYfmZF6v/RtPSLbcHCjJgHUF95P8QodCOByIK0hj7Z4KWCpjFJrPtY8+JP0rUOQc5gqhWpXcCc+ZZVCtgAYrrCoGhWQe9YRrawcZhLXRRgDiBetLhlWwZN0B+foeu9Aw9scpsBYDdgSoKms85H5jtFgOCeMRezD2D3sqMWij3G3OG58Q1wUjJbvANXlRsEOsPZjGmFrIQzZzG1U1ICjHPmB0+akBMcOxq8nzGX4L2F31BfuvIkluO3LDmQsUYwrQVtmE2hgYNHmgo1J3cd45UzPjBz8ykDlG3Ey30Lhk7mbRmxxVAPMObRs255il16U4zkkyAv8AU5AMKpong7XcANo7yddrbsExJRg5Bhg2cZjK2DEWn6xa6wpbkxO7Ub+WaLakgAHeIjZrSDtxkCUVsbqM3W7jhTmapsqWztyO/EXrvUoXzzILqFHLCOmxGkXleopZe4mepW/8SoDsRurPEPXcrKQWAMIpf0XBaBtcbpB7WcY3YPmU66o149/+YYaxsbhzEc6bwsxsJHPMLWoOWI4EqkvsY7o9o7bXJD9oFxsPYLY4Vhtkhd9plqKx4BBmFCF57xujCqJqcDMcoK4GJVqbFcEn2/EbRymCO0S4ZRMtaygBBxmQdxWdyxZbS65DSaObDsnPUF16N0OrjdgCN1PkYzFaalRcscRhNg7HiBQK5G0WwrlcxipV29+Yh67JwvaTTVMWAErPjJuUNsSrZbkTi/rb6J03WQ2u0dYrvx7iB+6dj6gtBGZtCo9pGROrjrCbxHg1v0yuhJNmNw4IxN6fQ1IckZ+09R+qfperVK2t0wwce4CcPbofSyuO07ovUJoClKyvgYmKrO3t4Eg1LqMhpJHbGFHIj/1oypG3Ra2G45z5kL2CYCg8w6j1cFhgjxIvQ1j/ABiIZ0hOwnbkiIala2ViR2EubqglZDYnO9Y1Ho1sQMf+Y8oXucf1rUVi90VcYlKi2OW3H2+JZ66xbiSR7jK1VZs4btOqUDsaXTt6TAnmVxoYMSWOQY5dfbUhXOSfMSFpZsbScyvVg/TLqiMWLk/Mb0lVhAfx5mqlcD+onB7R2hXZNgwMTYzJG9tXzMmvTb/l/iZMHDvjg4VeM95t69q7ospeskkkgfMxrbLDweB4nzfYoowNQzu2G554EsVcKAW4lZRayMGY4jB1JvGABx5kaKKBmwm3G05E0rtW4GJGmzZgN3k3tXPaRNUENTczvgCSptccMOJpFSxs55k7QteN3aPKRJvqTe4kbRzGtIhYgMeIlXarn2+ZYaXcFxgfmO8RlWlmKUFYPEWsaxjjOFkkuVjsYniRttT/AKcTJozQB2Rexitz5/aDJahd7ZPaRdN4AU4AmSTFptGKC2I2t71LtHEAisq4HMk4yvu4MzSMqGKtV6vFh7Q6XhOy5Eq1YBvbGUu9u0jBijplnTchPeB1eodD7TgRVdQlYBJ5i+o1RfPu4jyjakTt1llvG4xc3WZwTxFrNYikAHJ8yK2C7sOZaZ0DssEcdlb/ADGFAfiA0mgdhxmWNWj9HGTzLqCbrRdw9XCZ5jFems9L1ByxjGxMc4/mGr2JWSW7RugjYiqPjDjBEKt618O38Qep1IJwuJVX3t6h93JhXGI6aL+q9GGVaO6XVe8AGc1p3uWvcmGz8mWWiusUgnufEb6zK2dOtgK5I5k87qyCcExWne9QIH3h6rFIxjJEVyVVMigOcOJO1gVAEHuZs5GJlJyduMmQpFZoNpWIYg9o8jKBlRzF6KCTyOYwKip5JkHOllyYHrsLDJzJNeqDGYsXNbfmbCmw58QqQvkYwNUOxEZ0riwkjxEcrnGJNLHr/YOD5jOUJ30sw+Dgd43UvqDDcSuosLgE949Q2RyTmIqwH6xl662r9Mcg95x/1J9NmoNqNMmQf3D4nYUo2cntCW1125SzkEY7To4+QDk8WvpepjuHE1+n43jz951P1R9PajS2WXIm6ljkEeJzC6a8e1c7ROyLTJVoPO0EnxNfqCqZHJkLUs3EDMGFYNg5Mt4yDbAau8hckcmc/wBWf1EK2nkdp0Opryvu4lB1KutyeckR5wGs5HVIDYcKMytv9NFyp93mdJqdIgBIXkzl9fpnptJXdiXloCpldqbWJIXJzNVMp8YIk2UB9vzILU3rYUS3YrNMdFz+n+3kdoOvVXbgmMZ4hEAIwxmIiJYWJyPEHYpoTNnzMmb0/wCcyLoT0EoSm9vMVZiTuQE44MeBV2Cf5m3qVBwOZ8p2OpNMDTT6x74hxpnXGcfxBoSpBGI0iMRktmDdH8IWOlK5Y5MXGp9dsLiG1FIYc/zIUadazkDj5gwWg1ashD5hbCLRzIAlidvYQ1FZP7h/ETWvwhUNmtPSoYZ4jmSOATIHZt9owRM9bI5E2sVQFrJLDce8YsqRQPdn8QFJXb7jMawZyphWjfhhVHOORJlFHAGIxpa6rFyRyI0NPUwy2P7xk2Lmlblk7rmKapr2b2HA+I/qraq3wMED7wHq0WODkY+JtbGUAdKlh9pHJjWoosrQOVGJOr00cuomtbqt9YwOJWJBUlXrNQB28RV9RvQhe8JcPUYnEVFZRsH5nRMok0H0qVscOOTLbSadRztBitFFYUMRzHq2wMLK6kTbH6NyEAjAjLWVhgp5iJtBrHuw0MAAgdjk/Mab0XcGGRSCQYnqLieAcY8SF+odh/TbErdX1CuhSbbOfnMp+mTHBXvYsW5gNXp84dP5MU6f1Wi9iiuMj7y0T+opGMxsYfGE0XpeiFUD7xgEVkbV7dprRaJ19+3jxC3bl/cMD5iawYW+g1G6raBgxilgjHcRzKXRX4b2txHWtbnBHMm2POIsyy54MnRtNuFimjT1E9xJjlKLS27vmTa0sqRZIqqobzB2WbTlpr1RtBI4g7tRWVwZPqHsibutgBE16+1doEUYu2NmMeYQ2BEzjkQqQdgi3AHLQy2ggAHvK8FruAYyqmvaT4mc4hky0077AMx+q1ccmVdD7lHMZQsoziQpYUU76XOnuXHeStcFhEqGTZkNzCrbv8dpLu0UzwbbS16ug0WjcGHmcf1/6bbpi5qTKHnOJ2+jYFMYHEzqGmq1emeq1c5HEtHKydJHi3UacZI4IiKIQhdvidR9R9IbTXFADt8Tn3qXlS3advHyNnLZT6q5rMqTjEp7qyxbnP3lxr6O5QyvGnBBLGdU0T6tlY1BNbcZ+85vq9YCHK4IPxO0CItZGZR9TorsBDJz8y00FSzjTXRsPgxV8MRtbH3lnqen+laXfgNBJol35Hu+JZMdLAdNLkAnJEJdprCM4xiNBDWO2JB3YcPZmbsOkIejZ8zIxlf+X+Jk3YJ3+ksWkf1RnMnYGtbIY4+0VZ2c5rXMJT6oJ3DA8T5nEZOjdhFYxnMPptWCNg7xRlexiSOJvT0MlpIbP2g8RROhohtxJ5mLcwUq2MntJYJ4HeDsqIHfmDUFugumNgP9Rhz8GMG73hB2+ZXCl8j3EQ4yozntClpN1g5qLVqAKsIJNYr+3AzKjWa4q2094suvZDknafmMoEfIdWlqhMs2JE6qhcjdkzn6dddqc7nyIVAQ/uciN0wXtpcpr3Q+04B+IVtZaU3FjiVtVgTKsOfEaa9fRxjmHEMmZdcrLnPeS0FQDbj5OeYvph6zncOI+VKqCmAYylDPkaD2Ps9qiLWUPbkiwj7Zm13JzaeTIO7KxdGOD3jdUT+1ggAj4YZxIFFewOq8ZhXZQN2c5hEtQgAAQo3fSRy4XauDJA2bhgSRdANxZR/MU1vV9No0Ls4OI6nRWN3vsxlsQLdRZFwXwB95yHWPqW6xgaOw7ZMo9L1nqOt1TUm05Y8KJ1cfDpz02d1q/qNKDsVS5PxOe631WyxMkbSeZKnp+pLAWE7z8yt69RfpWFdo5IzOpcKQibLH6UtRtUxU4d8Z5noWl9Xj0xk/E8r+lLQnUA2cn4+J6tobwqBgMZgqMKSy607sKgH4PxA61PWTAwIMXEgFj3k7HUV7h3kKkorkV0y+g/5lnTV6i7g4z8SpexnHtXH3jejexgPmQpJDy0y5oc117RwY1WWcfeV9ddjYYc5jtHqKNhHMk2iylMY34rwWg7KzbXlWxDCgMnuMHyuVivkQegqHspHDZk0Flwyx4PgTS02WPgLxHBQa0+8X7EDoDRAgwIetHYYJ5+8DWLFcs2MeIzU75zjiLV6b8D1jauB3EYptLDmBQgnkQqAKDt48yFspOjFdhTJjdFoGIkjhueCIdcHGJCiq0uaLwq5EK125c5lSL9qBVHeMqx9PMeBaF+q9Nr19LDb7scGeY9d6bqNFcwasqRPVhe2O0qev9Hq6ppiwH9RRkTu4mQqTxXU6l63IIJB8xcWVsu3JBlz13o92m1DKUPB7SpGnAPwZ6EdcFUsUfyo7RLW1nbkgyzsqDMOeRImnevbI+8fskP1w5LXaG2/GCeILT6b0uHTn8TqtRpAFyqSsarZbhhxB9oGkVttQwcgYMrtWq14OM5l3qwg7dvtKTqKt/wBPaPL7CdhTI/8Aj/aZFMWfBmR8YNPTqaFofaSJK8IhBB7+Is+o3HcDF77Cylls5M+Y1luxK65lfC8ZkK7rVcFW794FcsMuxZh5kgcEZg9HVJlvRfWDm0gHExvSY5rMrmYlOczS3hiCHxibcC/S0ODXuZgCO8W3hgcNmJ26hSCLLOD4zBPraNNXuDZ/ErFkalgeoWsrHfWB8GV9l5tAAA4h79dXq/ZkE/8AaI37qeACfxOuMZFyy06Y2GznAlpmt7AWbkTmNPqdQWUL7QfmW1WoUMBY2I7lGWovCyEAiFrX1cAjiJ1WhkyORGEuwvfGIjkftg6AKRwoE3VqVyd8q9T1evTjNzjE5zX/AFiK9501RbHY5jTxtk6o7G/WKzHDDAgDrkVTk4HzPN2+tNVqK2Ppek5PIidv1J1C4bLLWx9jKLgoCWnpV/VdKtR3Wjj7ysf6nqpDeiu5h2zOJo1NmoO/1SfyZJ7nd9q+Iy4GXmF/Z0Vn1HqtSxO8j7DiQfXNcmLXOfvKequ4YtVCftJFLruGUqx8Tq4/jjvqkQ1t+GITJEs/oiuuzqxutAOOBnnEVr6LdcqpY21jLfofRdZ0rqNVqjNbn3idUx1IWl/R1PUlVdbXZWRwO05b60ck1upYEDkY7zrNTUbdTUVHaUn1loiKhYxXBHMqmjlpHL/St9A6mu0n1CeQZ7LoKksrXPAIzPHPp3SE9UrepOVbJOJ7R0sZpXKkcReTBE2MGtFYIkMdOWTuIG0H1BxjEYDH085nByVg8rRZaylhDLkRuhVRuBiRqy3uYcRlUBAx2nHdadfGkhmp2wCOIzU207m5kKakK4z2mrMDzOajqlpDR1KsQOx+JoWBzyMYihsCsCOYYtkAjj5kaG0OG2cqcQqnecFol7i454jSoR2PMRPCbphGAzgSQOAABI7CvJMmxCr8mNqJOmFrawcgcTb3lRmLnUsBtm8lhzA2mUljmn1AdeFxHKbdw5HaJVVrs9knvasYJi9dLLB4XIDxiEbUHGd0rlIPIYTGuU8Bu0dRhmkWIvGOBC13pkBj3lMuqYkgA4EmuoCkHPMpNdQddB/U309Xr621OlADgZI+Z5jr9GdPea2XBzPU9X1VaqSQw7czzvrGqOp1jOFAyZeeZoykpDplGSZHaqpnEZtBWANhVcOvAlfsdC1IvqdxTIXtKW8ElsCW2s1JI2ocCIWAFOO8adZFyUmoSys7nErtUq2Vk8cCWmoXUMxG/wBv3lRrN3KKP5nZx6KoK3+Zkl6dnxMltN1OmbVgH0wZI311oAx4/wAznjrHdvUzxN29Q9RQBnM+cdIsuJl+msorU4OSfmLanqBUgoM/iUtd7jlmJhqLUOd7Hn5knWlJ4sLJuqvYoqAIJ+ICzUX0qeTg+YJAoDFPHzIXa2yxRUyrgf3i+sopkyvU32P6bsSO+SZK19jHL5+BFnZCd3u47SSqLBk9z8yiRmkiaaimjJCAMTk4jFepF9ntGQfmVr1ksVAJxDaRLQRg8ZjqsMpTLT0t3CjBk0rIIWwZz5kqcoNxAzDVqXcHPEaeR6F8KYeu1kAUMQog+p9bq0OnJdvceAPkx39EtlYcE/cTm/qKsZ2gDidPG9IXwpGtPTb1Ul31GAefxKnWW6bRapqWGcHk+JZdAQimwCzDHxKrqOiL61lY5OeZ6HEjjuepYa3ouj1+g/W6dhW4G4AeZydocWFcH2+ROrpvr02mGmLcdsRizpOj/QtciAE84+Z0pCds/Cg6TpG1bCqrO4y90HRGTVelaBj/ALw30zVTXqSAoHHHEtCrDqWM94cN3YG4aHpbqLwAphtKmi1d7XV1j/8AxKD6u1KJrFqQszYyD4h/ozWJXca9TacN4J7TLUBtse1DJp9Wbb7fapyAJbaTqtOqtrWr9vyYt1fpen1JZktCjueZXaXWaXQXohbhfMPrFdM7R78X1hMADvnzKn6ztT9OrCoE5/iI9Q64j4bTE+3yRJaV9f17bTZQdqnuwwIPUK22S+kNAzakXso2Dn+Z6NpdRWV2AYIinQ+jV6XTitVB/Aj/APt/p2Z/6ZDk5AzG/pveWbbiEO3hPBkTtqOZB7uNw7icd3pWYSHgi7QAeIStgMKBENNa9n7jHEVhyDyJBrSqHV3qNw7QwTfXuXvFa7W24HMaDHaCOMSdQVlgBUos95jdda2HaBxBKwsfay8w9ftOBIUsKJ6HqpRD7hGDSNoZZlKixQG8xvNdaCoyNVgeuiHpM5xiaall/cI7YoA4OM+YtZvU5zkSf2G+sGunLc4hkpyMngTK7hnbib3kHvxHT0HVImhFI75m3xYO8BZYTMNq7cMZWVojeEnPp8ZPEC2oXO0CadwATu4it2qoqXcx5lOrYFTY+upqAPzK7X9c0+lrbJG6UfUutGtj6R5nO6zqFttg9Vs5MKgtLZc6jrV+oJJYhYgXFthbMyquuykgnPEXYikEDiVmCm4R1bKhzvxFXY2LjM1bcrk74s9nY1+J1RArMtrwME95D0kUe45z4krbGFY3LzIK4YYx/eXmSeIV1VNYrLDAlBrqfVU7ByZf6qh7VYq2BKiysU5DnMp6jYij/wBsv/5N/eZLf16vkf3mQdmbw5b9UqEVY7+YWx6UUMDkyqtYkK2cESa2N2PIM8Fcenc2kNjUg5bPbxGFu43HwIglSn3E/gfMI5bbjBwYfqRKqRYafUseWPBhnQMoNRDN8SrosCnBjwXTkB9xDQ9cET0LpuX3WKMDvGbrEqO5FBzElwWzkwg2KCCe8X1DqUzS3OW24GD5jWj04DBi5GD2zF9ONjFmXA+THFeth7O8R6VmUhksWbaCQB3jK4VQoiVT+nhmMaosFv7jj7TJaUzwdXqJrT0yORKTrNiXYdgAY9rBkA18ESh63eFpYb8EjE7eJacvKH6BqKmvdMZ8Sv8AqLX2aTqJSuhCSOXJ5H4kPpK2xr3FjA4HzFPqZlbW+4nPaetwwedysQXX6rU6hSCP3c/id3VufpQKjJKzgEX0rF2jj7Tq9B9SnQaJaBpPVY+T2E6lBzaOdATU16os4A+xjPUNVXpuoi17QGxjGZTJ1Dqevsa1K9oPChRiYnQdfrrg9iOCvljBmGWguu6ivU3epWQc/EQpsfTuGrYlj8Tqavo3cB6pIx8S10H0joqve1WT4zD9koL047S3dU1moFBFu3+Za6P6R6p1C/OpZ6aweDnkztK9DptOw9PTqpH27yzoNCkF+/iLXyJX4TaZTdK+k6NOQbmNpX5nV9O6bVX2rAH2kNMqlwMjBl/paqlQYxOTk+Sq/BlIOtUqX2GGSs2rndjMmaa2JOYCwlAQjGctW6KrwrdfRqKX9jBuYsDaPmPah2YZbxBI6gdhmTw3ZEtIzEgEHMsagxbaMweio9Qh9uJd06JMbh3it4UmtFaSKjtIzmHVXZicYmWUmtww5+IwHAUZGJC7wsgNNRFuSe8dFaKR8wde123iHADHmc9U2HUEDKuDmSLhhn4gWXEkCAu7v9pNzo8vCTtuTBPMX9Qq2LG4mW2bmyDAnDnLcwdB2wxdcEocmQra1iQ3ExNoOO0OoU8COpI1oD1STtMhqbQq8mb1IWnJziUXU+rU0VMHb3eMS8S2IMarqQ0tRO/+JzXUevXXLtX2gH5iep11moOWPGeIlawY4PedccYxO3X2W/uJgSVvYEEg5+YCxwuVhNKyou1vJleiCrwtK7HrrC5MBbdyRYcQB1Nm/avI7TVwDLl+CPEKSQv2sHqrARhTAUnJzzIH3vgEnxGaq2RNpXvKy0bu2CuudmFeCR8yOGAMlcoVs+Ytdc+Mf3llQVbZNrW2kHlRKfqKFgWHAlg+r21EHBxKrU3vapGJnrM6EMD5mSPpv8/4mRcYunInUJauFHaGpZcAZ5iFYA4Ucw250wxzjyZ5HRnobo8CQ24HEnZqC2FAgKV9asuLSp8SCWWBgGPI8xlIrWlpp0Upkrz8mGCoeGOBKxdRb/0uZY6GprgWZgYcE64TViGGBx95Nvd+3xN20lFMgQFQLnmK5HQZrmKckDE3TaSPaOYAUvYQxYjHiOUqgx2zJuEPrJ1La52k/iWCKK1474iaFkYlfHk+JBdUUf8AquTzNMrTdmZqdaxLr2C+fmcx1bVrqvbW2OeZZ9W6mnuVVABnKqLdRq/ZnGZ28SIcjLDp+ou6ZmxGJLecxp9LrOqt6pRnbxxLDo/03ba2/Ubsf9Kzt+l6OjR0AClQfxPRi1KODk9OH0P0vrrWVbk2c8zrND9JaVUAt5OOZcBEL528xoN2C8DyY1c7X4RSEqOj6Wkqtaft47Swq0JB2oomVuqPnPMZr1tKncWGROW+dlEkgZ05XIK8w1Jq2em6/wBoO/qVDgnIiNnWNNVhVM53yUzYMam0U53gYkdLqKb7cMcKvmV3UNWup0+8HHwYvpW1Hpem3f5EXaYrOibqKh9tWBtl/wBP162UKT3nF6HSWM5Jck+J0mjY1UhGIyJlLEbZaNqrC5AbAkWsI9xYmJuXY+1uZtWtLBT4jpC9mMXE2DgYmaerLDjiDa3YdphqXwNymZg0tKn9MBVOBLTTu238yjocPyZaabUrt2DvIWmN2YxqVKEPnM1WyWcGasfcm094HT1tvyDmc1JoomywRFQe0zPUdWyRxMc7axkf2kU5HMUotJs77SV5m134yYNiyjA7SSXoo+8yH1o1tRic95FUAbvmZYVbLDiA3nadrdo6lMOscNSuc+IO+9NNWWDCV1/UjSp93InO9U6tdd7VOAfvKzwpg7MY6t9QvYWrQ9vM5fWam+1t1jHvHAu87jEdUAH9xx8S88WG0HXqETOV7wgsosPDcnxFWQ5yMEQL2FLBgS2YHQupoJbCjiFr0zl1BziRodyfcN35lklilQNuDFbMxe6paVDZGYjZcLLDk9o3rASMscSswVYkQJaSZKxzWd1YjOk1rONtgzEWd2YFRx8TS2hbSEzGUsKofverv5gHNT17gBg8RcPuYgg5PmKizULaQy4UHj7yibQ6aZvVIv8A0DGIhdeq+3iWNx3LnsTKTqHtJwTLRQWE9VPmZKz1GmSmg05msqF2qBmbe9VGxh3lcutwMLkfeRbVGzmznBnkaej2SLP1H2ZXgTVd6O4DMMiLJ1DSlNgsG8d1ir3tY3HHxiEHdM6KltNt97QlN/6Zj6bEg8yjqsCANccn4jC631CVQhcwZoNRe/rS6brfME+syw2iU/qXovubOJB9fZkYxgQdGwd8L4auxQcnGO8NVdjbarkgyj9TUXoHD941pPV/a78CDoH7UXg11RXZYx57Su6lqcV+xsCSAVsHjj7RLWU22MTu9sM8Yr5UyvuudkIJzLH6Z6ell5tuPnIEq7q7EfbtMf6LqzReFY8/eXnwjb09G0RRUChe3GY87hF7cyq6fqFtpBXEas1AK7cjcJTszmpDT6hUr3HGYsNXc4JTmRap9QmM4OO8lo9FfSMMcg9ptIMBZ1SypvTOSfMC+q1ti7sjb4HmWjdJWxt7KMwg6ci7VOIvaTelFR+p1JYDePGTD/oLkU+o/J7S6u0tKV7R7T9jAm/Tejixh7O5Jh2WFNi+loAqWuzLAc8yyqp2r2ABlVZr1UYowSe0LVr7yAHHJmzTOi409mnoyzuMzV3U6c/u58YlJaltxLKGPMPV06xuScZ+YVJKmWOl6y63bWbg8CXCarcud3uM59NCtdgYnOJY0J6hABjKBNLagNcd7cgRjclYIzjMjphXRXtyIrqLFuYqMiN0Bo/XqgiZzwJPT9SPq9+JQ6vUmlBWrZx3g9BqmdxngZk7gpNHcVavfjIzGKbAp3Ad/Ep9HaNoPmWlR3KBmcfJGHRNIt6QtmNx4m7lReFgdKoVRzM1Nyqp+05mminZAncgY7iKu5VxtPHmSGrUggjgRS7VKoZiMfE06wP38C6zVbFGxvzKm/q/6cH+pkxbXdU4KKQTKmz+qc/PJl4RvRq3qNl+W3cExDVajdnb3k1NajaYpqCu4gHE6ZeC+jNBsKAmA1Navy/ia094UbWaFtZTXuAyTKqg4yqussU4E0itgM/OYzZXv9zIRMspAAxxD+jLwjRagfIOMR82oV3j4laun53cjMmrvWNgBMXrodCal/UQ+YmigNgxrAZM+YNqWCb1MZTgc0Cyqp3QWFZsYx94TDEe4Re6xqnCKCc+Yz8CpQ5WqFcP3xxFrGCt714kQzu+GbAEHqtQF9oG6TbB4hfU2gkqh4lTqinIZu0bucKCxBzKrXbmUlT3jQ2hGwG7T/8AIzIj6dnxMlewpxCWtZlu0MjFhnBIjOn6VaLRWyMFI/d4lpX0PYucbiT2nDh2+MpGSvAPZoMvaCDWvbzLrVdBbdkcCF0nSa0X+pzzFbSCkU4ttsxuU/mYtNpu3qzcePE6N+lVcBMASNvTgvtr5PniDukFJsra6NWy48Hv95Ovpz2HaQRLWlBXtrPnvkS4qSjaBgcRvsRujZSJoLK0AUn+YVFaohSvPmWttAY/uz8Rd8KpHp5aDsB8bBC1RnAz9pGt9xIdD+IbT0qWy4H5ja6dGbKrnEHcH1MrLtJvBITvAabpVxsB2kYl56RcFtvbxJZZKww7ib7AdCejuu0aCsqT943XqN75J8yvXWsxNRHI7mQ/Un1QqjnyYfsZKoOqo1KIgCsPvGDrwleTZ2nMfqLKk3bgc9pjW3sgI4m7aScF+OuNkgEGSTqbudzDModFo9RqGy4wCeCJb06daMI1oLDxCkL1aA6zX6hL+SxV+0jptBqrg9jE7X/6THg+jcgvtLL8ys1n1EtLNVp+SpwZSUFIsKtBUNoc7SO8eb9Jo6TdewCj5nJ63reqNavUxUnvFH6rq9Qn6ey1rMDk/EqpYep2ml+oek6phXRagPYfeWaNuXfPPOgsteqUmkNg/ubxO3q16KAHwAfMbGiNQNLtPuHc+IxSSgDr2HeJpajN39sZW0KNqAEH5h1knA5Xqg7HBPE3lsl2OBFtIFa7aBwe8a6hfXXXsQfbMZaL1E7K6rn974HeAqVkuwnbPEELXVyd2QYZXO9WEWkFYdL0z3IN3BEuqW8JOd6a65B3d50ek9i5M5bReVo/p7GUDJ5mashkyx4i4tyeJX9R6j6AZWectHRHHpHUa6rTA4M5vqnXLi21OMwes1tmotYDgeDEfTbJFmGMMFHx4RTVNvLN3bvCnUWAEqeJo+ioA9MZmMq2IQhGR2E6Zwk/DPUYJ6ggGNlxJh1bbWAwGYWg1I24jj4jt4BIDptPt5sBzDtW7A7FmWaqtjsQYjVRyAAJlQ34ICq5TizMJdU/pgIA0csr3DkCBrq9PIDH+ZVUSqiA0pCAHviRXTZORHlr9Rc+JqytkUCteDG0VU9KzUBaTu2kxHUXsq8DAl1cpUHcuZUawhycrjEDLSxR9TZaO/A7SPFi5bhh2g0f3keIT1KFBLntAyyRBkscE/5gLadik5GZYJqqhWAqj+YO5FtRmI7xNFcopSQ5Kv2iGsVR2PEtbdKUBxnn5i9ugFgGeTB2CoKfbV/7cyWv+2D7f3mQdw9UUNNeMAgbRGlVRn2jHgw50mAGGMfE1Zp3WrePE4HylFDK3VnBLA9ovtcqGCx9kVss55iZsxbhj7AfECrSilmh64XKgt8CF04uBJdQHPwcyep1FAAGmbgjzMr3qNzPmMOkzV1IZg5BJHgTES3PFhH2MYqKupcA7hNK55LKB8wdsG6sNVTqAmWYfmBK2mwsF3Af5knvZSBu9sw6g49h4PiHuHqErTKA2KoPkCS2msh8kYmV1FhuJOYd6jsDPjEO6hKWGlaw5GQQeYNy/K9/mHp9OkEjGJqzL5ZFyB3MKWkysudaxncAZKlh+/Gc/MjdSjktaBgHP4mVYJwhyI2YMoTHF2tjJ/EbrR2UYHEFRpSyhmYSz04qOFHiAz4kL06izTAgDiVF/UtVp9Y1lz+xzgfmXfUWrrG1QBKTVVjVJt2gfEpBKoSBf7hqWuZ1sOP+8Joq31ZtdRuIh+l9JsVD+oZTntLfR6KvQk4bIPM64whSSOfZNS1JV6WLKewEu+ndJqs0auU2sRyD3lrWulGWKAkyTWKp9vA+JVURqsKaroli2l1sKjPYS1ClKxWeTCLYCCR4gXzv34mbIutDI9i+3Maqa5tqKSMmB04DkccS009IQhzA3gM0e0dBRN54IEDqAzEluZDUasnAViB9po3MUHGYVWkqlirhAcAYMyk2GwVryIX2WftjGiorSzeTz8RmtJY9LLpwCHHmXulvbG1j+JRpbWOxwZZ6N1bBLTl5I06eOsGNXr7aKG9NAW8Tlepa3Uai7NrntjAnSdQZDWcMO04rqWrWmzDHJzOSuP07ePkwkb/T9pPIkluLkENEWvTVVkqPdNUlkwr8MIFOFe/YdsYg7pugBm3E94BWZ2weYxS4r4fsPEtLwRolqK1RcgnPiCpZhyx4+JPUWbxmsAn4Jg0G5gcR1WiOWNqu73KO8crcKoHmAVkrrHPMxdTW54MKQmMbB3nb5mW0c5yZCmwEblBBHmHZ1wMtkxvwVyCWx1A+IR9UirkjtB6hgqFhKxS1tnnEPZivwNfq3tckDiL31q67h5hfTZX3Ht8RpaEsQEj+IyYZs5bUA12HavEUsO1S58y/6npFB3dhKHU6d7CQj4xG3wtNNjOlrL1b1MbpbI2tEOnq9fsYk/ePIrA8SNMdaDu/cawuYs1QVSxODHdnuLnM0tPq7iAcDvxOZttjLUVu8/8AKZH/AEE+Jk3puzOet1CFsKMKJC3VIUNcE1+ndhXWpJHfM2dMMl2Xx4nM4R09hDUEA8jiJ3ksPaMCNahTuOFJitnqP4P4jpG0WVMEnOI2moUqBzmBaplG98gSZG3aQo5j4PI5SX2nHBPiGUhaz6uAYmLmQDLTLL7HG04i9SqQS2xHIUciFo066h8bsbYrQdmd5GTHqnNYBgxj54OVU7cJnEldWfnIEjVelykKSSIN9Tsyrd5lpKkRrtU3bXjVzpVWWEra/daXL4I55hr3ayvvniOt/sk5K/VahixKcjzM07vwewHgQLllbYy8E941SlZr4J4jeP8ASkDlGpGDnMa0ut2248feV1J7bSeIUPYzY2DI8iLnpUf1r+vaCp9sSt/pXBQwIHmRusfO05Bg7FL4y2T5GZWEc/Kkizr1CKQVfxDnVM6Ag8HzKNb9jbNvA8xmvVgqQCeOwndxxp5fLWFp65yNrZhf1AUe5uTK+q1du4nnHE2o3jb6h58mdM8aOGuRjf6xlYbSeY4LrHA9oOR3lUEUNhnPHmWPTMtYFyCsFSkKqbLHQ1sXBzx5EuBZXswD2iuzT0rxhWx3iF+uKnbjC/M56ZWWNPYBZnPE22psf2oOJUrrVa7azSwqtTb7IqY/6N6TK/u7mGa1UfLPiILqbVJ2CYNFfYPVdsZlUyLks6Llst9tvbnEs6NTghS05ypRprQSxlrpSl7hs4iW0NMsubUNqY395y3WOn+ndvI4M6NHKADOf5iPW/dpNwXkTlpI6olnJNqWpYqo/EhXqbhZuLZz8+Jqwh9zETSsteD3MHVF/UOpfk5ZsH4hBdznMVo01l1guQ4x3EadFAPHImaSDrJmzcuc9vEmrWGv+mQCfmKqyLj1Gxn5jVKsSCvaBM2B6rWVQl3P3hqnprycf3iV5ZSAOZFnfA2jkyiCi5TUVsgCzNwOWLGVlep9FcHgyLapjxu/dDgM0s2sVxjdyISgLuzgSuoc42nmO1OFXCnMVtoRygtwViWU9pussUHgxOy96933m6L8cM8aWxEkiWuSu9fTI5nO6rTsjn093B8idMqh7NwPeC1uiVlLAAymjyUdFQVAxPPxGwA1YKj3QboKwQRiToJHuByJK2WTMBdjh0I8dpZ6OlFqK7e8BWouIYDAEfTFYGJDQMV/SU/8Jkf9Yf8AFf7TIdQp5NUu6z1OAJYV371as4A8RGukj2nvGEC1kETmOvq0BtoeskjDCAWkltw/mPkmzjcAP+8jXtQtnkiBvCiQCzSB6+Rx4iradK8M5ziP2aj1xtVQqrEtZTuQFrMY7YMKodYJ3lQ4bfgfHzNCuqw8NlvEK1dd1YyeRxmLJpXSz1AcYlFWjDFaZO3HIjtSB/a34ibW7QrKPdJae13t5OJmw9dHQr6QHapGfiKW25sJtLfcxs6gOoRuSIK3U1ICgQFsQawdACnL7g2V8CE9RihA4Bi1TMrDgcmNsgsGM9oewjjBWw7/AGAZPzI5KnavMOpQZG3zN2VLvBTjMV0ZeGqnKYwI1TYBYHVu3cfM1XRuBwOQIpbdZSxx4mXo/fEP6/UKw3lACPiUmq6gdOwIJOfiD1nVGFbK5APic/qeqNYGAGT4nXxw2c3LyI6hdYlgDq2T5E0+rA91WQR3nMdN6pYLlS5Sqtx+JeMwRC1ZBDfM7+OcPM5WmWSa1mAbP5h9Jrmd++QJz/rFQRz/ABH+n2BlGDzKd0iKhM6bTD1mHHEuNOi1YNeFPciUOh6jXThCnMc/Wl2zu4kLtDfWi/Fnre08mL62pWUrjma0F1aLvZskwlty2KcSDoHTBDT6T37mwRLarT4UYHEU0oRidxwZb6JFbvziDukFIFSRSCbEJ+OIZDZexOcL8SxRaBWWYAjEQtvqps9rDBjK0JSM1GjrZeTgwmnxUMKZB9XUVznJ+BI6XUJc5Xsw8QN6Km0WNd1jcf5kdapt0zAvggQ2jarG1xzNapanqZcxGkdEWcNqLHrsesAEZi62WH9ix/qOkNNjupzuPAg9NQSwPjzFbSK92yVFl7qFr3KfOJYLXYMBmLH7yNSbbAAODLFKRjIk3SNrE7avaNwBPj7Q2jtSsH1UzDnTAndnMHbUoGAeYE0ZaLX6itnO0/8A+ou2pKHAIJk9QqVA4AyZXkszhiY6odawzamx3y+cRhLkswqjkROwhyNvfzDVv6NedvJjqkHGWVbbSMmHrvVCc+ZUrcSRjiN0KWBLGOsJ0mO5W3gnEA4KMShmFvTXGcyLB3GQO0PhNpjWnuZP3HiMo/qKdrf3lbXZu9uI9p0C+3vmZsZCGo91xDDIm9OAAVVTg/aM6qpa2BxwYNbVr5A48yNelExnS4X+myxklVXJ7SqOvrxvJxBv1I2Mff7Yin0dLS09dPkTJTfrqv8Al/iZKdA9Th/VZe795Jriq5/zKazU2erggE/IMkdexr2lu04VB1u9LevUKoL5i768Bjh/zFqtTW9QRmwR3lfr9RUrcOAPzKdEbsyxbqCcnB5+IudWbWKO3B7CUra4ltqPxNrqs2AHJP5m6IV3heg+ig2MCJMaqtlwe8pbtYQQjNtI8Gbr1m8bq2B29+ZuuG+1FyzJ7cjBM3YfTTch5+RKmzqJs2kt+2Ds60MhWb7GDGOuZFpTqNqlrLTu+ZL9Qre52H5nP6vq1aVjYwid3XfaFJGAO8ZQ2b7Tozq1WwkPkGSHUiq7Q/fvOU/3dKve1hOeQJg60l4zjB8QuDfadimrXIBh69ZUCMnnM42vqrHJtLDb2+8COvW+phAcDsTJuBvsR6KutrWsuvYd5z/V+u0IGCn3faUL9b1L14rcrkciVNupe69Vs3Et3MrEtE75EH1/VbGbdnI+0TN7u/qDyIR1rT+mADIWGtBhSBkczv4/Di5LbJUa4hxvbsZc19TZ0Azwvac3Uu5znjEcpsKAjxOnsc1LWXK9SckMRwO8Zq6uK2FoOD5EoA7PkKfbD0jHtPaSbCp06Cjr7WXHJwJZ09crX3Ox4+Jxu7cxSruJjX3Lhdxk2tGUnotH1JUyqUs5+I9X9T0YDO/bjE8wr1FqHhjn4jOl1dqMXdic+DFaQrls9J/3hLLQ63AY5Iz2lnpPqemuogWjI4nnGk1bMxBXv5jO+2pSe+ee8XJF6UekN9SrbTtR8fJ+ZTX9Zsss2pb/ABmcpX1DVJWBtAX8yB1lig2Ec/ab/ihXxs7zpvUGJG9/7mXNNtHqi9Xy32nmVHW3xguQYVPqbU07tjnbA2gKGj1tL8AWBsAzTa+t/aWE8sH1l1FqxUlmR95BPqnqZuBR1wDyDJvWOk0d91VkZ8jGIlXYQw2nmcvqPqzUXEE17R2MY6b1U6izbv8AcT8xGg60dro1DkMeZaFRsx2lDotRZSBnuY5b1G7aOAR9pKh1RY7NyYrPMTtRkBDnkfEHRqtUM7QcHuZXanqGpW8oKjt+Yno6ozVWgMQeYsji0bh2gbLL7Xyam574ELVTcvtStuftKLUOq/0GSv3bjCgF2CntBf162wabD+FMdpSw17jUR/EypoZPQW1Q444kvUZWwvaZYGUb3GBIZyM4xnkSk2Kw4sV2GM5zDeoEzluIgrsRvUEAfaCN1hO+04GY/YXNLep0flWzHNOQpwc8+YhomqZM47/Eeo3g4K5HiHdNgXU7LK/b3XvmVzNj93aX9WkFle4rn5lR1LSkvkJjbyJRSDSi1mdxbJC/GINN2zhiRGdX/U/ptwZXXWWU/wBNcmMpQysJk/MyJb9V9pkbEbsee1a5XYksYO/VMcmtsiV1OCvc5MPTZ6ftccGc304OuQO2tsCcd4k1l2qcrmO+mH5yOZIU00NkdzCuND/YVj02UOCrH+Zv1CGDF8HxHdUa2rYng+BK6xT6e7HMZQiVWxm0s6h7LCTjEA1jVe2l8Z7mBre0rhjn/wAQyUW3nCr2hUIn2YC7VWr7QxPkwb6kquWJ5j2o0LKAqpzFH6VrLzxWSg7w/Wgp0Vtt9jN7Tn4m92U98ZHTrgShAHxJJ0nVO3pgDmHokPtCDWK6HOOOJGklGzkkCdJ/9qEUKww2e4B7SLfTLKjEIYHKN2ZUNrgQFOcGGparHIxCHol9TBmTOP8AEXvruqJJX+MQdUbuxoIWyQTgQNli1k9g0CdTYK8A4MFtewh35MKkV0He1AQe5gLbwHChchvMirqtvAkrHrbkJ28y6nBGyNmoNfGMwtN9YRfUDMGPjxFdU9e5FQ5LcH7TCDWMBwfxCbUWIvqx7M5HgyderDttIxK3TsQGJkq3JszuxEa0yrCwbVbH2jiSNisAwOYk9qFsOwJELWcqQg48RPwPYfpdbMcdpY6WtV7j+8q9HTYeVOMS30xwuMZP3k6oKotdNVWQDt/MNatTEAPj8RBLGPHqYA7/AHkbtUFO/aOJJtjIbv2Iu0N/eQTXU1gpYoYkeZU3atrySB2i1loJyzHIjymFpMsrHUAsgwMwdTk8k5zEW1RcbQcKJFdS6cJKdCbkuEZQ4BOMx2iqteQc/ec8mqcctkmWGn1q7cct9hB0YPC4XTG7hcGNaas6Rg+PcDxAdOcCrBPeMNZztPJEVrA9dOj0XVmao+qDuHaMp1csACOMzjq7tTuYpYQs0eo2VH93nzEaTD9Z35+pq9NWKxWpzwSfEWbr2mtYhAC3xOF1euexQxY5H37zVXVPSIc5MRwHqeg6XrVIB9VFB+ZYU9e0AI2qu4meZt1k2qSrED7SOk6z6dnJJMVwwo9jp6/08KAK1L+eAYXT9b6ba+LK1GO4nlg603plqz2HfMFV9RFVJJOc/MXoxnR7ENT0O1v6iIV+DGKX+mGYF/TCr4+J44v1KFXe1jZ/M0n1RQG3JYQTwcxlLQjensfW9H9Ovpkt09la7vAMDo/p7oetVAbVIHyZ5BrfqmzOF1DMp7c9oXR/V1lZVF1LD55jPRfT3jR/SHRQQEsGf/5Szr+itCSpewY8czwuj6/1VNgAvbjt7pbV/wCovUrSuzqDoo+DmDs0JV0j3jS/Q+msASq8Ln/EB1D/AEuQgvVqg2fBnleh/wBSdfWvqDqNgYDye8n/APlfrlTb/wDcnZD9+0pNsi+Zo6Xq/wDpVrax6ulsRj5Wczf/AKZ/UrWnHTyfjacyv1X+sPX6bN9fUWsGeQ4HMd03+v8A13SFbKzQ/HIZe8qqbDPMmQ//ABn9U/8A7Bv/AOpmRr/9S31J/wDstD//AFmRtZX7EfNdCA+4gibvuNK57iXC9MX0dyZ454iN+nVeCM58Sqxl+gHT2PZUHHYxksgOGzx5g00+FwowPAjAoO3BAz95nOB6gHoFuNozIHSFz27eJY0rUgAc/wAQ5qXhkXOZOqwZRpVU9ORTuC8mWmm0CogKKFh6tMMgnuYV9yE147STsZcQuNIzEhlHEG2mKA7WOD4lhQwQZJzB3jed6LgGHWOoRX2aKt8EDBH+ZH9PtcHAyI4rYYhjB1oWJyJnTKLj0NpyqHgDd5hrr0tG30wD9ouunsY8cYjlGmK4Zxx95KmxvpTELNOjrkL7hEz0mp+bgM+J0qaFLSO3PxHx9OGwB0wRiZNojfEkeZdY6G1ebNMuAO8obLLacq3B7cz1fX9MGnLVHkn5nn31H0xtNcbNmQ3mXijmqcKVQgX1C3J7wd1pGAg/mGpRMYI5kfRY2bWHAl1QiQIlcBucmYBuODwIWykDnI+wgQ+zt3gbD1RJSyPjPBmihd/37cyS7CMkc+ZpXrydwJ4ivQ9SQq2tywOe+JZUKtYGO0r6wu0AHmNV2OmEPbxJvQdS1rsTAw2MfEaFw2dzzKisBmClsEx2hsPtfJAiNaHqxxNWtYyASM8yb3VkBipAaLn0fUwgmMvty7cDmBJIfqzVzGrLIcqftBon6k8jA+TMbUB1CgcdsxpEZax6YzmUXgGAbSel3KsDAts3du3xLI1CxNj94tfpVrGa+4+JdUhWtB11bsblwDHdJV6L+9eD2kaXdqx7eV+Y3TWX5aaqkXqWlAdMFOBjvNG0lyucH5i6Neg25O2RcYXeTgzksdahl7vSQnMSsu9U7SefEG75OS5x8SJZB7iPxJpDOmSse0VYJPHmAKWcc5jDMrquCc/EDYzqeJVITswT2PXwjYPmD09qvbg3jcO4zJO24b8EkeIKjSo1vqugDeDiHDIuE1CpVgGKPqCbMjgSRUJgbhj4grlwRxiDqghxblCCe8XuwFwvMkjKqkbYNiu7lu/iMpQj8FrdVcSoJKlT48xnTX1li5zk+IrqhlwEPHzJaeoh8/MzSBrH01TE85zLPTaokDJIxK2uhiN/fmOVgKMNJtIXo6LSnqLAjLHEjrNY4Qutpx/xzK9nRkIQgRPV6m1UwQSRMngj4TNf1O2sZVuDEG6ldYAxdsHxB6l2srwSMeYruJQgeO0qmKuNId/W2f8AKZKz1Lv+A/vMh0bqdjSHQbc9+8g9K+pyuc+YTZajkBSRI2hlJZjjiQjlPUaEradlvtfj4gvXZLNuDye8FfcTaTzxJVMrWLu5nVNaTwdXTfqFywjdFboNmcYkNFqA9pqUYC/IlhYilQexzJ2tCvAtFAK7smEGiV+cd5uldqBRyJNXbOAMYnM9Q6B39LNVW7PDdoo9bpWa2OM9oxaNRqNQjeuwrTkqOxkrlLncw5HaD7MKLCsWrBAYE5OMyxo09RU7zjEXe0f+ns5+YRyxqJPjvD3HkFdy+KsLiNoWtrAJGQOZXC4OQB3+83XqHRiGMGlC40X9MZsftLBepugxWfb5lHXcliYJPPiMqdteRgxkTtaC6jqWts3tzOY+oKqrqbA5JPg/EvNVYTxnaJS9RqIpcO2cjvLScfJJxJqsFhCA8ccw9db7/dzjuZLU5qszWcyNWoIJGMiU3DmfhmpSrPf+Im1W05KkAxwehZZliQf+83eu87T2AzMZMTqrVucgyFlLbspgSYXc+EBAEYNINeGbnuJtKJAtMi+oA5jrU5IPgdooFZcHbwPMeRxZXtyCR8wMOAijbwRxG667FQsD+IOtdw57/ab32V8N2ihHKGJAZhgiSd85APtMTr1JV1Y1EqYyLBYSErwT2hSM2LNalb4zz8RunUWouVfH2itukfJsNZJ8zEBxy3MbETfpY022u29mGDGK6y/jkyv04Xuz8+JaaF66GDahzgH4iusGSJnQ3kKKCFHkmPVdP2Ku64Fo3UFs5r5BhlWtW9wyZCuRsvKRAUqawzjhe0S1QrAOD+I3qbCE25JEotY9htJ9wB+YFrNXUzU3VqAMe6Kq97MWPbxJ8NwRCrXnBJwJaUjmp/6IC9skFTNJ78hiYVwawTUuT8wIdg3IBlHhF9gmnVSxGPbCXqqEMg7TdaIi5zN2n1E48SbeDy2AsdWAbuYWqsWL7mEA+Au1cZPeG0dqUEmxA2RjmBNlBa9lQlS34igrvdy7v7fEPrdrvuQY5zxB+rurCg8w6LSZNa952kj8yelQraQx4+ZBAgXBPMibHQkg/iKKmXC2Ki4LcfE2rbgcMcGVemvaz/1OCIxZqCiccRXLLS0NW1GtRsbdF7gGrIc4MENWzKDuB/mA1NrN5zmBSxmkDtUBCueTAhAybRww/wAzLyXwMmZUDxtzmUWoi0jfo2f8JkNi/wD92ZD6DEdYL0X2uMRXU2rcCBgfE3apA5OYs2VPzOCXh6H6L20IW3SGno2sWJB5h1TfkniE9FVXkkZnRHKHqhjTvWvPGRC26gsvGBiV6YrBySSZIkqBkHB+DLfZoHJcabUtXUAx5PyZIa1mfayjBlYr2WDaqwqbguGB3CJXplJb1WrwPHxNm9WYqVxEtNwORjMJYwXlmx8SFQxurDCukjIIzK3U2XksvbwIZXU92HeM16QP/WcZU+JlODJUinw6ZOeYXSOq2brhnMev0He0KR9pW3rcDnJ4lFg6THlIY+z/ABD1W7BsY5zKepr1bOe/iNq72V4CkH5jf+jNMa1AW329gPMpOr7P07J58GO2XLpk/qPK68G8khsqT2lIRz8hyboQzZEDgnx2nTv0quw+4YkKOiqSy3rgA8bR3E6ZnTkvDl0bLlVGfmH2OF5zOiPR9MjHYu3HgSY6XUy525xDUk00cttYsRggTR3Lxyczr06FTbjavf7SFv05RuyQQRJtDqkcxXa4GHXP5hEQkHwDOlT6Zqur/dgnzJJ9I6ksNuCvmI3gyZQUV7RhXwYwmmdwPdk/edCfpG3A2gbvBhh9MX1VBWwxiO8CcrjYfTK8w9FZXLqOfmdEn0pbzawA+0Df0XU1ArXTnPxB3FaKYsxJD8kiKvSpbdnBloOkdRa3DVnHzB63oHUKzu9BtvyBmN2JvwRoODjzLKi0OwFh5+IvV0nU+qGIbA7jEsv9tvBV0qP34iv03ZosNJqGrAIHAhbtaApJ4PiL+hdp6gLFb3fA7RHU2vUpZs8QdEMuRjh1bKC20MT4Mq9VrbWc7lECmvcZfP7vEA172NgrwY8ykHvof9SMduYxpXOAXGfsYnpzWrFWGT4kv1PdUOOf7R8w36W1l9N9YrVAhUckeYBKXDE8bTBKq7PUV5s2MVBz/EzNiJMjLxziCxtGWY94ZrGcBcYMFamFAJIzFYrQH1kGS2c5mlL3nCrkTLdM54ABU9zJ12DTjCDkeYNMkwOoWys4ZcYgqdqHJGcxi/UNa4GeT3kl06JhnMDaDjYsQA5YjEgb0YniWdmhF1YZT7jF7OnLUh3qeYNQvVoSfVemAyHJziTrt9U4fO4zTJVV7FXP5h6sY3KMfMpLQNaAkMjYzMB5wTGHQOpZhyIobFBIbOY/gNZt9QUPuQNmAGrX19g4+0m2bBuxj8wOPStBKZz5ELwXKY7+qf4EyZur/wCMyJpulHRBL7W/+I4EkdPxk8Yk6jtbdiSf3nIzPH7HsrjAIibve3bt94S4C7CDAExqVQZPf8wIZt2c4EZUN1w261qwUHP2hAEtHHGINAC5OOZNnXT8bcyk2DDdOdPeGLEqTyB4jT3o1m9OV+/ErW1G58A4MNVfWDtbEdWMpQ8l6s3tOMd5Ky0Fc98Sos1QS/CZ2kxg69cbVAwfmOq0bAqsucgeZY127qdivKk2nHwDM02qKO2+1Qo8Rv0yLgatsbGOQO8G1aWnOOIoNdUW4Akj1DToMlgpPiTcsdPA/p0g42iCtC1oxU4MC+qDe8OAIrdqTdlOTiGW1+k7tf0CsdLjgnJElVUCOAYXQ6Q2Hc44MtaNHzhAMTq46R5/LTZVppXU+of2jxCABuy4xLNqD+1R/E2vTrduWXgy65EcdKmVBoVnL1jntzCVaV2XcVIMu6un0U15cZzJJRWinP8AED5EBRX9lfp6fTzwJA6ZrXJBj5JYmtK+32k66LFBCp7jEdjzOClOkYEK3tPxLNKfTQbO48zVem1GQbVA/wAxxaAExOe6bKp4RoTeMngmT9A7t2P7x3SaVAM4k/QsNu0qNpnM6ZT9E30xVclM7oFNKM8jH8S7XTD9oJA+InqtJYtvszgwdsNiZX26FWcOADj7SVWiax8leO3aW+n06BcOQZNNNtJZcCMrFcoqKOi0NbkoufxLJOm6cLg6dSR5xHtGtK5Nq5mtRq1qBKLxKKxepSa/plGR7BKDW9P0oY5Qc/btOk1OqVySByZQ6p1NrBjyewlO5upUnoujufcKAWHwJKvo2gRybNNluw+0s6azWpszj8QmlsruOSp475EP2B6lM309pMs+zaTzFf8A7e05bAU8nzOw9CqweTAX6XgIqAg/3m+wZSzmbvp+tagpYgfAgf8AZmChS06xtLXagWzsPmCfTBWBVMgdofsTD1ZzS9GIXLNg/Mhb0a9uxzOsfS7q9xWbWsBQoXMHYR6ji16draxsKA57xe/perLYCHjtO1v0ysfYsXegEFeMiOmgdmjgb9BrabgTWT8keI7p67HZVKk/xOk1GnQggrz8wNOn2EbU3NM8GVMSNT14OOILUWWlCTSSPsJ1CaWq6rDJgyR01KoEatcRcRtbOGtoZ13enzI4sSsEITngCd2enaaxSTWBn7TWl6RoScbFOftCsJ1rOJs01/obyCJXtQ7ZsdcAdp6dqOmaL0vQCYX5xEH6NoUqZWVSD8iN2wVJnnjKxGM+2NU6etq/cOZ1T/T2itBK1gAdhMH0/TWoCjt4iPkKzJzf6RJk6X/ZF/4D+8yJ9iGxiucHJ7D7wb25f2HiV+p6gKkx5+0V/wBws24JAz5zOJQdqsu3sd/aRFrLxSSGH8SsHWlqBBbce0Tu6q97HccZmctDdkzpF1KVL6hxg9otrNdtYPuBBnPDWagqULk88QOouuZMb+3M3oGy31GufhlImv8AcwrAu+Md5SC63YpJOZM12WtkfzKSBMuLOqVumEPPzFm6sw52k/aK1ackbF5MK2iIXjJb4llg6pjo6tY6qufHb4gbLNS20q3BPJildNyscr/eP1klAnkSqaB3YxTc9ancTnHEifUc+oxJPjmSK4QFhxNBXXJIypm8Eds0l9rP6eTtlhoyw7c54lVdqUpBYEAyfSdd/WCu5IJiuSNWzrdKu0DPbuZb6VK2wx4B7ylrurUhckk/EtqLahTy+CInWkQqwi+m95Ck4HmMuWchV5AgtO1VoOeP/MZ09ihShX7DzNtIVciApTac7wCsC1W73ofap5EdYuMgdovYhzkcRtYyuWQS5KxgrDowY7s4izhMgscQ1XpoMs3B7TesOpjtdquNvxDUVVZZ3Jz2idT1KD7s/wAzDrqxkK3aK5bFZe6MK7BQRgQ9xpR/dt48zkh1e6s/02xz8wlnU3ev+pYfxnvFcabWjon1lCHcXBlbqeuDeyooIHmUlur3jhjg+DFE1Qa3YATjvFfExHZf09Ra2wHOPtG21di+4MSJQgsuGzjPYx17mNYCtz/3i/U0L30t6NYHBJOTB361SChA5+ZW1X/pwXbOIld1E32k18Be8dQxlQ5ftDE7uIhZXW7li3M2dUrjJ4EWtuRwQre74jpNFE0N6Wrc2N/A8R70lxgACVmjJA4zmMpbaW2g8H5gej+Mfpwgw3AmmcI4I/iBLOF93EXe9xYMgkSbY6GLx3I4zILYAm0nIEjbcpUktwPAmlsrsUBfMKM6CLc7nYVwvg/MHudWKkdvMnyuGXxB2O7HMdek29JBjzkCB/TK5NrtwZpvV7L5mmZlA3GMmZSAvpQNkNwIKhNtm5TxCXMSwVTkHuZOtVJxWv5jKgdQ7XVsNgBz9pAqSpBzmFFJXHBB8QRZvWw/GIQBKbGVNpIxBJqPRuypys3crP7azgwP6Y1nO4mZCvWPWXh1APYwdr0FW9Q44g1yU/7QfpCw7XPHmFrTJMEmytdtFjMO+W7zbajsMzT7ajtrTiLW1tjcTjPaI5G9Q766f/8AGZKvB/5N/eZE6jazhq9U1ind3MXevUvYVawhTHF0pFgIUY8xqqpGfaRk+Imo6MYimmTaATkzXorvyVyJaHp7O+4KQJuyhKiARu45g7IOMpr0ZMemuB9oP0LHIyOJaPpxu39l+IK4lMGqvP3g1BUsUFCqwRjx4Ec9B1CqqZB7yKL6vL8GOBgijnMVtDpAqqDW3sbmMMjVje3uJ7CEsqqNYdThj3gwdv7iSJlbCbfTepWCTtJg1qZGByMCSu1abAue/aJ26+uhDlh/eUVMDaLN7dOKfceRzK+/qKEemr4lG/Untdv6h2ntBV6hfUGTuOZVMjVJDmqds53ZWa0V7+uAnjzAa68sgwcQGl1DV2h5VPDmp6ej9LayxEcH3Ac/eWVSEWEtnmcx0Xr+lrr/AK1gB8Sxt+q9BWhKsWaNukGjoqitfuL4H5jadR0lSjdYoPnM8v6n9aahbD6KDbjvnzKz/wC5NXqRlrDz4mUuhG8PZb+tdOrQFb1b5we0puo/VGmqwVyR4nl1XV7fWwLGUHuueI7qtdYa93c+I/0ifYdPrfqprea8j7R3p/V7tRWCzHGPM4Wu57EBIwT4nR9FsJQDg/OJumBXMdhptSK09RjuBHaDNzvk4K5i9FjFRwAR2jJc4DbMnzibEVnk0g5LEEAiMqN2DwcTKijphhzMVGQZBm6plV6SNQfLYwB4gqVrWw5GJM6k4IPEWW7LcRHBnKLFtjkKCMDvJF7Gcbew7ROh/eBnvHb7AawE7j4gwTqjLbXKhQM7orbX6OSMHPfE2bSe+eJq5GVN58xkkbEJvYxbYqnmTFYT/wDkfMxmYgcYPzM9G29c1k+3uY3TTakErZ0rymT8xqm5wuTyYjWL63OeVjNdzI2QM7vEnXGMrwsmcPUIpYXGQB98yBuLNgHaIRWUIw3bs8ST48D9jBqSaySBmQqttVsFcCHFIKcNBFjjZ5BhUIm6Y0lrsp9sGhfJbEweqiYVecTKM2YDnGDzM5RlTJLXaQTnAMDdlPbZz8SxdqwoHiV+rb3A4B+JNstNChYltoXuY3Qw05AABz8zAKxhiOftMrdXu7Qph3/ZaItdgDNwYvfUHu7DELUd444xN2IGOM4MfTCt4CrhRyYNUYj9sYbTsTuY4AhsIKw24ceIug/BBxsGczavVj3AfmatpLsbN3HxAn01JTn+02g1kgK7GJC4x8xfU0b8/Ecpq9YYAM3fpig/MDY69Kr9Mf8AiZkf2N8f4mTaN1OIpoDDLDg9ozVpalO4gZh9tNLhVOQPmSZFb3DicDs7XIK60pXgcCK2YHude8PYWwQQDzxF3sR1K4OYvcXqQZg3jiCWtd2M8Sae1CWHH3gbLquX3YAjptmRllGxuCDmbRayM7uR4idvUqVGd/aI39c06KQHBJ4jpNmdJFzZataliwMT1GvRFyX4nO67rNrAKr4Ge4ilvUXbHOQe+TKTDI1youtR1QH3L2lVq9Y9ntOcHsRFjduxz3m2vqKEHAYSynDnrkb/AAhVcEba7GGptHqkq2QPmJsy8EEc94Za9teVYSspE22Pa+/dUoQ9vERW6xnUM2AO81ixsKQTmSNbk7MHjzH8F0sK7gFwpMJ/VZTjPEDolGNhPMYYmrIJxCjaiu1KsGyxJB8TW8qAFwIXWNWVBzkiIm6XnwDSZZUChmG/BaNPqUCbCe3aU9do3BmyAYylZsG5Wl00SfGWNdzsmFGJf9DaxCMN3lDoV3HYxxOg6QDW5AUECB4L9Z09FrkYaNJqLEG0DIMRptUDJjKWIOXb8SNJDpNDdbPjvzN/rGAKkQaOGOVgbC9dmW7ExMwqrwaDUEguwyYJlU3baxxBLWttyufHaWCUBTx3+YO2BVaaqGBkqMibZxnOe/eMpRxlu8HbpbPU3KcL8CDuv7GzQZfBwvGZgFjZVv2+cw60VlgbjgjxGGoQ+2vkQ6mBwJppWccY48wB31OR2xLD0GrJVSceZG6pAALGGT2zNv8AoRwKM7WJjHaBq3d24IhrMFdqjBgVWwEk9oG2BLAqugyGkluCHJGAYK1gFDYGTImxHTaDgzYHcGFvySAZMhQBubLd+8RV2pOSMwiWepyQQYUkDRo6t/2gTakfvD4MEK124zkntIhAH2s0Skh5WhrdS9mFTxJLWXwLCOZKtayQPPzCrSzWZB4Ek0jomED/AE1ysNvIjdWmqrXke494wlFjgDPAjSaRce45MCQtLCvVTX+wgknt8Q338kSWqrWnkcxSzUFu3iN1J9sDlTsOYGtFAYueZGvU769r8GJPqX3FcHERyxlSY4iFmycYgraUFn5gRdYnYmRN7k42/wAzKGHskPC+mlNqsN0gmqFoPI/mV1jIP+o7jIDeDweDG6A+wtfVX5WZKrP3MyH6zfaylAqZskjAm9Q1e0Cph+RK625sBgcD7GDs1KkexsY7zynJ6nZDFpYKWHiIvqVpO98DMDqeolCFzkSs1+uDgDM0wxHSLDqPUFasbWA4lJd1mulSCNzfeV3UuoNUMs+AfvKc2+s2WbPxOmIJPkSH9Vq9RqLS5QKp7AeIIqSPeDgxf1bN6oTxDtYypg9p0zBC+RMHfzVsVefmLJY24VkfzGd+DnJwYNa1Zy2ePmU64cz9C1NhwCeJDUBbH/p45k7Cqj5PaAfv7eIWjJEtgHDEw9ddjY2twOcRQ25AUd/Mmt7q2FPEUfwu9Ka/TJbH8xW+8byEH8xeuwkEsxkHJY+zJJmBiH9NaxbBXB8GHvNp9p8xCm9v27uVjS3Fhy2MRk2jdUAu0dvpbi39orXTtJ3GWT6gYwTxEb7a85K8/EoqB1Nn3rlQPbD6a/2bMYMSpybP3FVjKgOwAbHxG7i9WWeludWwygGdF0u5a1LMefAnNV+zB7mWejsLsBuOJu4UdVRqTZyRwY0u4DMqdO5qQKT+I2mrKA+eO0HYfqNpq7VfYrFfvHKn9c4du0rK9VW6biMH8RnTWIDk9zN2FcMt0/p8YGI1TluBzKhNTafa3YeY5XdwCH4itiNMsdOW3YaOlsdgD/EqqtQgcMe8e/Us4OAAMSbWhWoDq7VZvb3HeTo1JUAkxXegclsHmT31AZxCoZu7Q5dYrJlGibYuYGxu0wWEDA5zMalRyzc9+8PVo3fQjUUbN6uc+AYvYGVeCDCDY4CA8Qz0K9Y2j+YdwK9K4+8qD/M21IRgcZBjf6da1JxB43ZBaVmpM5FLKhnuTCKjKuMY4hRsrOCcmbJJGBH/AOLAoB6dmFm0DmT1NDo3LcmaVGrbcAfzJ4exgpyYrmSkzgOsOhCbjzLjSoVQM8DToMj1Ce3iN01eodu7jtIuEO3gQWnspwDCDWGs7Av8mDbTsnccQNlZYcHtF6oR0xjUXVWLl8ZEr81pYWPIM1rH/o5YNkfEU/U+z3xkhdC3GsPms5EDa4AJAyYD1uTtPebblMkyqkDZiah29pUDMmuoWonIBidlhqYHPEANSvqHc0PVCukOXFbG3IcHvIe79xMW/VAthMSb6yoAAY+IrxBTQbcZkD+oT5mRNGOFs1hJwthwDBfqG37dx5idrbRlB3mJZtXI7meZ1PSdrBh2dgQ/cfEr9U+3PGIY227tpifUbAiEseZSZI3WlJ1Mm9wGHbtFgrVgEkg/HzGyyvk9yIuzo1gB5InTCOamSrDu24jkQrlmGzH8zGc8EAATasXOceZUnpB3ITYOYOpyufMJau44HBmLVsHuBg0LF7r7N37eDIo1jEndx8SewFjkHAM2QF5wfwIOyF0irDwOZKvI9zHMEjNvIA7/ADDJWQu4/wBptNowl+DgV9+8kWDghF2nzB0WKG3EcfENYayd6HGYdBpCoDJzniO1GkpljyJWPaBZtU9+8LWWUk5zCMmOtZWy7VHaJXOocZHYzFuHIbiayGOO33g0fTPV3ZwvPiFrc7hmAw9bbsBh+IzTh2Dnz4g0H6O+paNuVwPBzLLp7qrgtnmIs+QpSvt/iN6V0JAwBmL2AdIrpbSrIeRCA7FyWwfvK3SgoCfUkbr3s9oJOPMHYdMtEsVmyjQmnsK2Zd+JU1O6L35MLVZZv3P2g7aN3R0K6qxiCuMRqu9nXtx8ym093ODLWkZTch/IlFj/AEVtMdpYvtIzxLGu5kTlST8RLQoSpYYwOTDm4uwNY4HeUWCvA6Vra2TxnvmavKKQFHaLajUlDjOMzQuD43GOmkI0Ne30i2cQXqhzweMQiNWU2ZyJBqFA9nabUBQzVGd+7dkS0pJKbc4/8yrTCHaec/EaFhCgE9oj9KKBo0s5ww4iWp0h3D3kYMaTV+lyQeYOwtqTkDH3iNYByBauhQVJOZi42Z8D5kjQFcZbOPElqKdyAJ/iD1AzDVZW3jMf0ujY+7ZwPMV6fSCPd4ltReEQoDx2MXaD3N1VgArmTShan3Fhkwb6ylF4PPmAfWBverdvEDqjK9LRdj1EHBMR1ChRhDzBLqsgOW4MjZrK2yEYE+YFTHTTIWDdWdw7Sr1Xp+mT5jN+u7oMYlXqb1IOH9x7S02Fiwt9EFiSR8SK6lnBKt3+ZG4DAUAkwBVkzgYMvNpk36EvutddqcEf5gDVY2GBwRN1lwCzZm13sQBzmP2kVyRUk8jvJpp0dtxJyO0aXS49xPPkSdQSsk7c5iNwDMA/px8zI1ur+/8AaZE2Qnlzs55KyCsU5btIm4gEZ7wT2BUIZsbp56WnZ2YS7Wp+5VwR5lLrdbZflF5PzDajWV1ZrXkRNNjgusrMiOgKV2qhdj/EHXW1lmRGQrf9RM2jopyF7S6RCmRZNgyTzCJeqpwATBOWJLEcGCXhuTMxdwObwXycZmPc+MFu8A+0HeWgtU2+vKORj4i9QOwq2DftAJmnYM+3wIKmwAAkfzMAZrMriFSgdtGGqrRAw7maD5BAORI2q4XcTwIA3FTtVeDNgyYwhIzxiZYxGCe3iarOMF5PVqrrmoY+02GbBkM7BlEZIKICScmLUiwIQ3GOxh6dzsNzA4g0XQldW9s9/tDW6fYhY+Jol6TuTjME/qOMsxxAxkzVVpPsIjulVQ2OMyvqwpOfEe0zLndiTZRLSySshd2RiZS6raD4BgkuZ8gDAx3mqgS5QHJ7zaZyWd1rlQKjgGE0zuik28yuzaj45AEZW9mTEDYMLOq6tnAPbzDuBnKj2jtKvTWqgbc+Se0Zr1R3BB5gTwDQ/Ra2/J7S409r8MmQPMqqjnG7GB4Eeo1Sh/QGcDvHTQhcVX7RtVuTD6bVP7i+Fx4lT6g35Q5Am3tZiCjEk9xHVIZaO3W+taDu7HsIVmpUZ3AnGJWIbK2O5WwZsqxOeeY3YZFtXaV4zkHzH67KfQ2sTulJp0uGN7cfGY7liuFOJuwyY3WRWSwOZpibnDDiBqsAG0ZMkSydjHT0Gh3tG5axzGG1Hp07VWIKy8kfu+YWq1iMMv8AMDBoSss5DucZjdd1dWFcgxGy8KFVcAxivRPcA+4SbaNmljQamBKCBvs9LJJxmBXdUcBsYgbtWjtsPOI8s3Unv3o2T/JgktNakZzAW6kkkIOIrZe5XGcSnjD0Q/ZejDAfj4EUF5oszv7xVLef35+ZoojtvYn7RGkFTg7Zej5JOOJVXl2uBByPEeWpWHLjHnMDqagqYTAz5irAuWCDtW2SBxBXak2NkjAhl0NuFLWKwPxN29PK4+8osJtNCvrNlUxwTHaEXaSAc/MxNEGIUjP3j4pVKtoAyIjaJ9hVSRkZyZKxnoo9REL89h3mmVlBPcyFJsWzDHiRbHTNerd/7LzI76v/AMpkHpvDx3IVjiIavVpu2kciT1GuFZKBeZWaiz1GyR/MSTpbRq5kZtwbmDVwi4HHME9bfu3YhtOgc5ds4nQkQYVLiy/+YVVQjGRIrXgYAE0lJ3nL4zGwBu/KgBTmCSsMNxIzCakFFxkGLLuKnBwYBXgRqRnJOc+JH9MrjBPthVA29+R3kN787TxNojQvdSNvsPAkRlFBB5htxGdw48SPoK/JOMwaZIG1rOMAzK1Dt7jyO0MK66xgDJm0CDjPMYbGRLbW27Mw5IFXI5meogUqB7vkySMorIIyTMbGKraGJVeB94ekZXIJgXVN3HEZ09Jdgqnj5isGjIIdV3tiQKsW2gZEeTRKqAkzFVBZtVf5xFYNKz08PiHr9hG1fzN21VrccnBzGFRDtKeIuDK2OVlLKwVXafiDRHSwuGAbxN102ZBzj7ST1spBJisoqJXOXAaxuftBF3HAYY+0JbS7Vbz2MHtTZhYptC0glsgyzp2gDP7vmVunb08CP1ZsYDnMIjLOliibyRmETVHOW7jz8xYhgoBEIdqoCBzMLvo9p72c/EZTVitwq8H5lD6zLk5MPTq1I5BJ+8wybLwa6yx/eQYQWlznwJVU6hP3DkjvGTrUZBtGCPibWUTLSq6vb7u+YWxipG0yrWxQgbdDV3+9ctnMGsOlrp7ucN3MZuYemMcExEWIpBEPXZ63tIziOqwVmVFi+CvEYL7BzwJusJswc7hA3unbPMDsyTJ01DUXBnJAEtW1KVJ6aMMjiV9GxVDTGLWsSoidx0sCPaxJG7kxKxTu9z7YydNYAH3D8RTULtzkZMK5B8IPaUJBPfzE7r3UYDDn5k7Xf0/evERsVbeQ2QDKrlErUFFmeVGCZPNp9uCYTTVK64IwYZa3DhcHHzH+xC9mhdbLMisBo5tL17Whq6hjnH5xNlPTPyDB2Q80R0qbFw5yB2jF2dgAHBkK7VY+mcD7wtwxV/R4EV2FzoLT/wBLJfkzZ1KpYS3mJvZYi+4/zI4Fibt2Ynck+MLbqlDk4mhcmA7H+0XNbhsEe0yJR2O3Hb5hSTYFODP6ur/gZkB+mu/+P9xMlOqGw8Y1tW18iwMfkGKou5gN0irPuILZAg1ci3njEjKYKocapAvPMEm1X2jgGTFm5cY4kEHqNtQZ/MsJocuVHtM0jDfljIvWykheRFbPUUkrkmMMNX2bzyIJWNlnGBiDDsU3E8we6xXBPY+YofBl2AbGZFrEUYzBWuWYBR47yDVsB3GYykDaCetvGFHb5kEWyxzhuBBqrMcLxiF04Nb4bz3hzAaiR3qTjmC9QmwYhrwwb2ngyNdArbc3mBm0LZTuwQcEQ9IrUYY5i1rkD2Z+JlW/cFJyD5m0Doncaskgc/MLp79hG08mTs01WzJJzAU0r6gJPGYoulwTYyDB5h9IjKpNggqbFVQAAYY2CxdpOMfEVhFdRQtjEntCaKgV145IHyZJ1GOM9u8E1pRQA/8AEGmHWsCrkGKN1AG0VFG74ziQBewZzxCKgIVuDiK0NLGdxdcKeDJCggjaO8BVdstwg/vHPVIrOQcntiDCvXTVGld7QADxzmWGnV1YnaMRWhyEyp9w4xG9PYGXIBz5hXgHAcWk8AZH/aaLMQRknEiwesFsHBk6rAFIxnM3YXoAUMxJbtIiza/x8Q9oVB7G/IkfRBTeT3m1hcEqncMcccQ1JcqeM5gBuGFAz941plxywxMhH4EopuJ3E8DxmMVpYLS55A7SJZFXIaQGpfso4jYFMtV1jLXyBuh6NeK8EHlvEpF1ID4djz2mIL2sBQkjMRorPp0x1rFN+eYGrfc/qHtFNNXbaQrkhZe6fS1JUFDrxJtDoxCBWAIVr0VNqj3Re90T2o2TErtQV5H7ouAdYNNrbK22Fu/+IK27cMscxL1WssBLYMYtO1QQM5hzAd9A3M13sAODIUaVaj2IyY5pwtq57EQ3pqCS/aLoNbNJUoQHPMaRUNYymfvABV2AjmGBIQZ7zKzYTwAQVU7YtfqK1B3EZhmuetSD2Mrb6zcC68w9gfgWqxf3qYRNZbWxGQUbjEXoREQh85PiRUqxJ5wIdHWm9ZuvGA2IOupqwPdx8zHZt37eJJFsdcsfYIvYfqbWxixIct9j4kmcuuW4xBOy1nKNwRJNfW9YVRGVAc4D3mZBbaP+J/vMj92Lh4lpnDEhjCqtZfLc/iAWvaxKdpKoWIxLdjOjrhBjHFQ4ziYMHDJxNA7+W5k1FY5+ZgZhPDOeJBiFBHeatZsBaziRNFhQ8+O8wVrA2vggYzmTNRZcEYmV0sCA3P3mX2FTtBhTMwdgIXAEhUpLYP7YcKpr9zd4JkCuADGTFzSa7Q20L/MKle85xBg/MPQ6jIzDocA37Vb9pmVPuXkHE3eSbNwM3SyZJbj8RTYRZdoJmqrkVwTzNsGsYgdpJdI20KO83gvUPbfvAXEGpIwRHdPTStRFgy0i6IPaFEDwOB9Dp3uIYHiW9WhorJLgbmlVobABtrbkRv13yNxMR+sODeoqVU2Jt4lZYaxnIEcds1k7u8qNUpBID5m6gwm+pTaUA/tMq1HA2AnPGIm6Y4JzmGqGwDaeYeoPwtawmQx+I2m5/wD01zK2ux2x8S20Kgr7e8R+FE2Hp06qe3uMNUpqfdxkzbI+wZOD9oA7w20vE0ZWxr9VWWNZgt21iQTNNp12792TBplyQrZIgTRuzCh8t/UHBhTtJ/ccAdpoVHZg8GbAKrt2mOmgOtN1WBW9/IjIsQplc5MWXT5AyRzHadGBXzyYdQjYo7WFgoBweI/pqmUFGIIm69NuXDKNwjdWjdcE4m7IyTEGRbbTWBkj/Ee0lJqPPIk69OisTtAPz8yTM9eQBxEdaWnRlNSicBRmYusdSRk8xel0Y9jmTsos7qpwYvgfQT6qxbMhiYTc1h3E4zJjQk15I5+Zn6Z8bQ3EOIm9IgBGDMdx+I/SVZcP3P8AiKOoqAGMkSSapWOAuPzFaHljDNssC9h8wzlCmC2f5i4U38JjP3g7GCts3ciTcj6NK7KAqDiTvfUJUGr5MDU//UGBEx9X6jemoOB5g6gCCyy2sC4d/iCCGvJU5EhbqVp9pbOfEBdrtlWdvt8mbANMkLvdkntJWWqOV4iK2q/uGee0gz2AYMZIZDlmoVU8SC6nNZBJGYg94qBa39s3+qRq9gU47jjvCpH01qXvVgUY7fMZoG8b2aaq/q17gsnWyqu1lzDmCt6T9vzMmvVT/hMhAeEpZctufUyg/wCnEYOpYjjEHala2bQZFVCv9hPQaRy6NadrH9rDGIwlZc4LcCAofAzmat11VT7GbGZGkZUOipQNwOcSSlQMEfxEhqTjdWpYn4MLVa5bLjgxVLD2RKzk7h/aBvUYDY/JhL7URTnOfEXNjWV/A+8dIDrSJdT+1s4mlfLe5eYMVsG4P8zb7lORgxhUw1hQfuYyNR3HgnECCtg2nOY3Qv8A0hcw6h9BXFs4zNI+0jJzC31biOQCIIrsOccwNo3YZqsTdgnEObdvOYgqPu9QZMOg9QDcOIj9CrHa97qGHEJdqUdQjAbhwSIvSW5WH/2+3Ic9jFaM60hpT6Vox2Jlk5ss2hBFtPpQtvu5E6npujp9u5R27wakD0pDXca8bMSq1andjGDO+u0NBGFIBM5XrOnSiwYXgmMqRvSlIbOGGDD6elFXJPMhZu3AqM5hkpsVN3cGOjaNVNsGG5HiN0arYo2iVi2sow0f0lfqIG3YBiudMmO1axncB24EnYy28q/MXSvY+0jOY1XpVZ8IcSbgZJmIzgemeRC6ekVNvxmGGkeohnTIMaIUps2jHzJucKJMzSBXJLjIEdFdKoCyjB8RPStQr7LCVX5jNltedqNuX5geg6oLpdElj8Y+0ffTJp04YEmVR1JDhUfAzyZvUa0IR6bFh8yb0fqixo2q4JWM2sLMEAKBwMSkq6o5yMCHGuNie5sEQf8AIdJFg5Tbk447yKencvB4+YlRaSCS2QYQsc+2ZN/2bwYVa6mxkGNIzMnDSrV23YJxGdMa0BLud3iMvRWy0V1CFW7RF9VShIQAEfEyxrXqLITtEqmYlySP5jom6LFtV5PMH6rM3AAlf69hGM5+01ZqnrGV7wg7FoNSyLtDYaQyWyS3JlQl9zkszc/EKWuVNzPFNpZCx1UgEgfaSbVe3CHHzKuvWO4xX/mOV0WW1crmYPYDZcWP7jmSRrWUqz+2as0Z24JKzFQqApOcQNDaYC3jv4jC17k3O0CFIO4cQqkAcGBeAbAtp6r223cgHtN6kVIBjgD4hF2IxZ0bntIuvrNjGBG7CthdNZXVVuHuz4k7GQrvAxB1ab01/d/EkuM7TmBsy0F6i/8AEzIz6SfEyKOeELl7NyrkyTs6tyvMEXctsXx3hQTjBnptnIwlPuDCRNSk+4AyOmZq9+TmSHvPt7+YumJ0MKScydl+7lD2gGDbcE5MGqWliAcQoDDWXDaDccyC2ByFA4PaBuRtvMCu+ttxOfiDBUyx27O5gz7+QO0DXa7NljlfiMrYiKRjvFaKThuqpyd4HAhRcaycLj8TaW+wKOBNsFYEAcHzBg7Yv629iMH8wgcMMHiDK7c7eJra7KAR3m6iaF9UocLggRmkFxkYgK9ONv3+8d0tTJ5AzNgUielQC0fOZ0LUYoVtviUlen9G1bGfIz2nR0XV3UYHxJtFUkivrVGf2DzzOn6cmnXTAE5ecyFCs3GMw+h1rV3bHPsidWHUi+1G4Kdp/M5/rTHZgjdiW12vqRMBu/zOc6rr67XKK5GDHmBHSKy5jkYhqbWdcCwjETNrFzgzKLnF+wjEr+E3Wluunp1ACsSCPPzH9PpmrU8e0dohp3IbBXJ8S30bWIhDDIMWrwefSKLY7btpwOBHqAaiGYc+OITSFK23WoMH5mtW4sOKgAJN8haZYW29mTgd4KtmVcE5MlXtVACRzBmtixwYvbQvUTXDNsJ5kzdXV7WPaAX+m2S/5gtQquwY8/Bi6gaxlrAwLIJFPUb3NwogC+xe8nW7bMA94NMhgugwFHJhdOhsPJwIkC3jvGdCzFm3cRX6HSwS+qpdg7jiRbV7CAFzmJ2ZD7wcyLJqc71UgRcYe2FiLkxy0kbV2CxSQPvKtVtUZJPEMhdgCWOIUg90MWdSvVhWufTPeCs1O7gPj7SOckrtzInQPYPUDYIjIGml1DVvgDOe8Mimz3kZEV9J2fGefMfqqNVYZiDMFYZTpHZiQYRNNYj4ce0wldoUg4IzxHzdp2rClSDABpCfoVDjAxHEKhAlffEXIDthOZIpZXgpjMXWDwlej4944EB6YI3FeR2jjm81jfFdRWLawgsK5+O8wdQN70HtYYkfcOa+RIvQV4/d94fSqLKyh4x5My9/RWaLZT+pgfiRW5QMjPEHerVtx7swaluQUI+8zQvo4dSFX8+JtLBjOIlXWxtDMTiOsFWsMnebqwpE/VMyB3vMhwJ4ZTXYMn5hU2qTuMy52HCjE1VpjZmwNz8T0GcrTMVfVcqjAHvN2hqVIRvdNINjEE4M1ZlmwTBgPSNNxzizuYSxyCGBwBAbWLccYkmRiAAeRGFCvh/aQefMXvVaVyTnEPvKIEc5MBqjvIAhNjAo7btwPEbrYtyV/EAtB2AkkCFrs9M4xkRfBlLG0ANeHODCLtRODmKMTZx2haMAHJ4gGw2D6hOT2haxuwBkRX1EFhP3jVVyMRtMBkg4B7CEUnjJxgyKhWUsh/ME9h7ExWUllgzNgZPEtNDq1pTbgHMoNPY7sAc4j2lrc3+0nEA2jer1GHynEVbVOrAKOY7qtHYMN4PeAWmuu5WducweCMHZbq9QVTkGD1OitAyVy0vns0exSMBlEq9ZrVBYpyY+ilAm/wDUMrcYlhpKEL72IyIjbeGY4XBMa6fXZa4y0VthS0vqEwofA48R9H9mQdpgdGlaJsYg5HYyTBWytRORIPS0pIObjgE8yQdjz4MXrY1D3gkxm25XqUAD+IMK6jM88nBHaSZ2BGTE13epnOB8Ritg/B7CbANm3YMwJ4mWFQuVaQOGYqueJooQdpMUTQDP6jKqvgx2lkxtI58GK2V1owCryIatgP3cGHAahlauOO5MZ/T2hNyg8d5CmwIgeWFNy307QcEwDL0TpXDZcZA7Rl7d1W1QBj5kHrNR+YJj7s9swIPXSVdYdTk/xI7HBwp4zDpQgqzk5M3wqBQQTCDpgEIPUC5jDOoTbX3gRT6hJDc/EIiqi88GEOYLpS5sLsOMxxDkAEEgRdtaoJCpz2jNTBlUggE/MPgG8JKMg48SWn32ZV15HxM4Dd/zCcK2UPEDNuh0WtOx58iSX3WAFhzFVDucsZIVOH3JkxWxkkOX+1ihbsIoFBJb4m7rWWrD/uMV0xtZiO+fmKMkhqkhnyVjIoXfx2MWDipstjMYq1CuuX7+BGSQ+I3fpqqwHOD9oG6hRVvGMnxCuxZgzdoBbd9pGePiMsFpJC1e/nfXjEKzI+AFIIhba+MgiB9X0huK5MbCDeMzj4mQX6x/+AmQdRex/9k="
    }
  },
  {
    "token_id": "producer.collect.testnet1644538788601",
    "receiver_id": "producer.collect.app",
    "metadata": {
      "description": "jacket",
      "media": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4gIoSUNDX1BST0ZJTEUAAQEAAAIYAAAAAAQwAABtbnRyUkdCIFhZWiAAAAAAAAAAAAAAAABhY3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlkZXNjAAAA8AAAAHRyWFlaAAABZAAAABRnWFlaAAABeAAAABRiWFlaAAABjAAAABRyVFJDAAABoAAAAChnVFJDAAABoAAAAChiVFJDAAABoAAAACh3dHB0AAAByAAAABRjcHJ0AAAB3AAAADxtbHVjAAAAAAAAAAEAAAAMZW5VUwAAAFgAAAAcAHMAUgBHAEIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFhZWiAAAAAAAABvogAAOPUAAAOQWFlaIAAAAAAAAGKZAAC3hQAAGNpYWVogAAAAAAAAJKAAAA+EAAC2z3BhcmEAAAAAAAQAAAACZmYAAPKnAAANWQAAE9AAAApbAAAAAAAAAABYWVogAAAAAAAA9tYAAQAAAADTLW1sdWMAAAAAAAAAAQAAAAxlblVTAAAAIAAAABwARwBvAG8AZwBsAGUAIABJAG4AYwAuACAAMgAwADEANv/bAEMAAwICAgICAwICAgMDAwMEBgQEBAQECAYGBQYJCAoKCQgJCQoMDwwKCw4LCQkNEQ0ODxAQERAKDBITEhATDxAQEP/bAEMBAwMDBAMECAQECBALCQsQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEP/AABEIAtABwQMBIgACEQEDEQH/xAAdAAADAQEBAQEBAQAAAAAAAAACAwQBAAUGCAcJ/8QAOBAAAgICAgEDAwIFAwMEAgMAAQIAAxEhBBIxEyJBBQZRMmEHCBQjcYGRoUJSsRUzwfAkchY0Yv/EABoBAQEBAQEBAQAAAAAAAAAAAAECAAMEBQb/xAAmEQEBAQADAAICAwEBAAMBAAAAARECEiEDMQRBBRNRcSIjMjNh/9oADAMBAAIRAxEAPwD8yLRgAiUoSoAk6lhrBlVAzgmfVx5tNrUNox9Vao2ANwF0wwJfx6S+CBuFmNqjigfI8z0ePT3cBRE8bikkCe79N4XZhkCRysk2mc8XfTuEzlVVMn9hP7j/AAT/AIbcv7n+rVm3isa0/byZ8J9lfQX5/wBSooqr7M7AAT/QP+B38O0+1PoNPM5NKrfcuQMeJ835ec5csjvx5bH8p5n2ly/s7ktxeTxWrpce1iuAZ8f91fTPpvM49vbpkgmfsT7k+2/p33N9Ofgc+oEEe1sbUz8rfxd/h/y/tLmDj1clrKbwSh+cTyfNyvD7dOPr8h/xK+hcWxrSibQkAifxH6x9Oeuxl6an6g+7vtfmWhwayRs5n8Y+5vtvkUWsHqwB84nLhztvjp0j+Q8z6cAC2NzxeZxWVTj4n9B+ofTQAcjxPmOfxUBK4nu4W2OXKY+LsoHclvgxdvXr48T2ORwyzHCnA/aefbUqZyNiW568m6sv4EnagBTkbnov4PVfEitcgEETbgfP8uixeR3Uaz8Rl1rJUvZZfaiHZ8yHng9ApGpfHlossSPb3XQ1EMPUOtR/UhNDJkjGwNjriVeLaXZwiz9swLqiMLX5EpJsVczKgP8A3Gkcj1151vqqR2XEbW4srKmU8kC4ZUYky0upnOnrSUJSwqRGtZWqnYzOsP4ERbWX2IyVtwB62WbaMsTBGDFCrec4jLlIA3mXNOss0owcQUp7e5jmAwbODH15VI9rE6JgUXIEUtxHwNwrHYpgRaVMwyJU5J9Nq22WMdhW1iTqGQx3ZdbnbjyTdOcf2uokoR0yfEoQ7BIyI8oeSeqV+J3l1z2xHUz534npcWrwQPMmsVaPYy7hDk2KoCanTPGn3r0DUWJ6Ce99q8JvXNr+BPn+Dc4GG3mfYfRQUp7+MzyfNsd+GPU5tLWjCDxPOsoYIVYbnpHkKiZDbkHK5A85G54eVdNecODYXzk4lXFD8YljnAj6eVxvT9xGZDzufX1KVETl9HaDmfUA9hAaeZzLX/UnzI25Ki492MG3nHOF2JfG6m2mUB7XIc/7yg2f0o9zanmHlN2JTzMHL9ZStnxOsweq7+UGX2HzIn5SlCraMw3VIMZyYtqhfsamyHaSnIZW86jquR3YhjHUcD1V/T4m/wBL6TaG5UkbaAlycEkCVcevtUR21J2Qj3GdTZYNDwZVdJysO/p0/wC4zoep0Fd6/TChLG/TiUV0BNyap3L5xiegiMwyZ9OzHhxtFYLZInp8YBNKJNxaw3keJ6XGq7HQk/bYu4NLFgSPM+v+hfTP6hlwPmeV9F4DXYys/qn2L9rcn6jzuPxePSWZ3CgAZzPJ+Tz6RXHjr+zfyv8A8MT9Y+4l+qczj/8A43DAsJPz+BP2miLWoRFAVRgAT5D+Fv2VT9lfbFHD6Acm5VsuOMYOPH+k+xnh+Oedq75jCQoLE4A2Z+dv4oc8/eP3MaOKO9XHPpJj53sz+w/xD+4z9B+iNXxz/wDlcvNVWDtR8tPj/wCGH2aL7m+u/Uaw4Vv7YYZy35ni/L+eX5J8PH7dvj45O9eXxv5c/ov1j6NS31PltTdYgYqtYbGf3zP4B/Hf+WH6j9p8G76z9OT+s4A/U6KT0/8A2/E/dcl+qfS+B9a4F30z6lxkv4/IQo6OoIIP+fmezj8M4zxz73X+LP3J9v8A9K7r1IGTP559X+mGlixE/W38xP8ADQ/ZH3Z9S+lrSy0LaXo7YJNZ8HI0f9J+afr/ABz2Zep1J4/LviuXHXwNlSqCvSeNz+Om9T6TmL0cqVnkc3jeX+DOs5a53i+auqIBAE8+2gtmezygRkBZ5ruUySJWiR5VqhG2PEkv/vNgjQnoXsrPvUGxKumiJUrWPLVFoJbGZLd0ssyBj/SW8jCAnz+JF1YguF8Su7SRPap7YiuwB6Ax4JZvdE2KqOSJF5K3CmfqepO4l7iQUhMrO+Yt+OWbUJYm86Gte2QTF2MKycwxTdU+TsRV6MWJxOksR2/0ok2NldRgV89mbUOrj4XtmBYDkgS5YOwn2MhoCORozEBJ3HekoXOdwuGUpy3x4nVu418Qk6lsE6mWYU6OYaR1r2JJMx0OcjxBUHro7m9XxideMTr0OOUNY1KK+SeMMqvmRcOs43Llr9ReuJ1lxBBKcl+z+Y+vjI0F+KqbzuDULAc9tTp/ZhkWcUrVcA+MCfQ/+pLTQFrM+WGXb3HGI/8AqT6fRdkTj8l7OvGY9Wz6jyHHtfEF+VaasM2zPMpttIJMq49gc4c7HxPNy4SrizihlXLt5knKrPq9leNuuwnXxPNe6xbNtI6QzBvxa2bs7YMk5aej7lOodzO+8xecjDnMm8bPpcnEHEb1Gj7eOqnR8yP1FpfKQrOS74YGRlbOMbbSajknMxeSQcCKt5gYYYwFZDvMqSotk+n030nq9ZLnEj5ZKcglTkSenmiivzHUciu8F23OklGp7HfOSDiLrty/XBAltl9TDoEETfSqqGQYJmsp7D9Rf/pnSTrZ+Z0Mp7R+r6quwwupfRU2QpkdJI2JdxnbIJn1bXjlXUVKp8T2/p3HW1lws83jV98an030Ljr3GRItz1cj6f6Dwu1lapXP1z/K/wDY1HP+qP8AWOXxe1XDAZSRrv8AE/Pn8PPt636n9RpprrJ7sB4n+g/8NftSj7R+1eL9PSpUtdRZbgeWInyfn5f2/J1j0ccnF9VMJAGT4E2eJ92/Vj9K+kuazi6/+3X+2fJ/2m+T5OPw8Lz5fUHGdrkfG/clp+6frg4tA7pS3p148edmff8A0b6fX9M4FXErGkXf+Z8x9i/Rypf6lcu29qZ/5M+1nyP43478/Pl+Xz/f09Pz8pxk+Pj+nTp06fbeV+N/5z/t1OR9wL9SVP1cNAdeTkz8Ifc3DCWWArjBM/0k/m84DtwuJy1HbvWykfsDP8+PvfgH1nZFwcmfMny8eXy8uM/T0SZxlfx76xSA2VGDPH5K5qIM+s+q8LyW8z5nn0dQcT2/HXHn4+d5FIYneMzyeci1AqfP5nrclWVjkzzuZWLj5BxOvjnrw7qi5zJGptD4J1PUtHpMZDe7E4A1LkTbiO7rnq0UAVUgDIgX9kvDOdRn9TVtQfiazDx5RC472dVGzJ+XxrEYEjUcX6X9sfMbfyBYQCJzvJ0yVCR7R+0CwnGVEusoRlDZkrmsHpCcoOXAsHtUWPkSLv2fcuDKMgDUjvAP6F3OvGxxvG6x2ZPHiLZs+6GiuVPYRZRgcATtMqYzJJ0I4VsUznAg04rbLiPRxYxXwI5FpPT92RMZGUz0U4nZsD5hvwQBhjDw5UnGoLfq1mWJw+o/VnMop4wZMAbEIUuNkHAh3bMMo4HVM4gOfSbr8mb/AFtiDqNwOt1pNhE05ptibkPbW3k4MGu4k7MqsKsnV1wRIynv9viNujaq6+3uWm8ceoSBEMeiYJjeMzVr3HzDFTlVFCOluGziUvWqt6iHBk9XK7NgiMvuwuVOoSLBbe+cNJ3w5yTgzluDHLRV2GORK6yjcGo7azqRcm4izqkeWZRqSMxZ+3UwvGDsJanbbZmrWQcZjDYwTQ8xId2M5XDlpNtLdtiU8fjZwSYyoqNvibZeqnA8STOALwFGI/ijFWfEjtuRmzH02O4wBgR2xc4nVq3ftn5nqIEvqCADM8sMajuU8TmrXZuMquir/wBOsnR//qaTo6ej9OcZAwxiW0VgOAZFxCynBE9Xj05YEz314ZHt8HjqawZ9j9tcAW2KoXJJnzP0qnsVQ+J/VfsH6BZzeVUtS5yQJ5PyfkvDi7cOMtfpT+WH+G68zmj63zav7HDwwBHl/gT9XeJ8d/Cf7ZX7X+y+DxHr632oLbcjByfA/wBp9lPF8Mudr9125X3GE4GT8T4L65e/3B9er4lILVVHov8Avsz6H7w+sn6R9KY1MBff7K/z+5nmfYnAdqG+o8hD2c9UJ/HyZ8j+U+Xl8/ycfw/j+79u/wAE6S/LX1PC4ycXjpTWuFVQBHzp0+z8Xxcfh4Thx+o89tt2unTp06B/FP5oPp6cj7U43Ibythr8fkZ/+J/nt988Kui20EZwTP8AR7+ZHiWX/wAPbOSi5HGuV2/YHU/zr++nFt9oA+TPzvLeH8jzn+yPdwy/DH8Q+u+y1j8ZnyX1I9j7RPt/uGnNjDrPj+fQVU9Z9f4683ySPlOfS5J/eePavosezT3+a7qSCJ4fKrDMcnzPVMee68rlkqe2MiSC6tshhPSvr9pQEGeRanRjmdJlc7Kk5oJ8DIkj1FEDlTPRYdz40IF/Q1FciN9bjx9ebUqPYOxGI/kUJjsg1IiSLcKfmUNa+OmfM53i7zwux1C4JkNhCtnEbysqckmTLeGOGGZPRXYXcE+2CKX7dvIhVgWZ6/EopptJwQcSpLB9l0cV7nwPEeeEiN1YiepweIqLn5MdyOLWqdsZM6cbjf18Xz78EGzA3HL9LwQc4lqqqklhjEGu93sxjCyryp/r4wqvjGqwBvEZyFUtgSx1V1GtyK6z03HzJ1rMNowi4IireSwYoFGDC/qOwyFiiTY+l3GTXO64KhYE4jHvAHVBoSaym8klSYBW5V+Z06xA3LOSCNRTIVP7RRvtDYJmXC5hlc4/xJ+hsECLLgpMseleupBx0KsHbZnobdfbKmElQUbUdbRZYo6nRmOqGvt8iN4toK4J0I7FTjam5FAorHYjJnVIppLsYzlj1DnOpMSQOhk3kehRZWfAOo1EpGS0TZXhSRnP5k5Zww3/AJkXaMw669NqsXXcqg9oTpWV7HzJ2X1D1QQwdrG2Xkn2xwNTVZJ90QazSPcv+8UC5/TmGNOVUrWrmU1FU0D4ki2BU35i/XYNlfEOtXx5R6hDWDMPjcUu+T4ktfJKV5J8yjjclguR4M041242V6X9Kk6S/wBYfyZ0rKvY/WtKAgZnr8NCcanl0N2Uans/TXLsqqs9vLlnr50uvqPt/iPyLVVV2TP1l/LL/Dg/W/riXc5T/TcXFz6848Cfnz7F+iNbdUyJ2dyABP8ARH+Bn2an2v8AZ9HIuqC8nnKLH/IX4E+R+R8v93yThHo+Pya/o6qEUKoAAGAB8TicDJmzyfuX6qv0r6a9gP8Act9lY/cyvk+Tj8Px3ny+orjLyuR8x9XD/dH3DXxqyf6bjkpn/wAmfccXj1cWhKKVCqgwAPieB9nfTDxuH/V27svOf8CfST5P8V8XL5by/M+T75fX/Hf57J/8c+o6dOnT7TzunTp0zPg/438Kznfwz+tVVrkpT6p/wpyZ/m399cdFtsx5M/1I+8fpx+r/AGt9V+mBgP6jiWJk/wD6mf5g/wARaWr5V6nyrFf9jPjfmcZx/L48/wDY9PxXfjvF/Fvrta9mB8z4j6mhVicT7j63/wC4SfifHfVmDE68T3cK418nz0BafOc0dHJ3PpObtiJ4H1A1rnc7yjY8e209sgSO6r1f8yi/3ZdYml+zYOpcqbiB3FJ6tJORXY4JVtS/6nWin2/MhZutIUiOorzLUet8iELTkH8T0FpW2rONzzeQprfAlxyvOlcu4t8YgcWhLCWaOShrXAYHE9Xi8GoJjrszrGnOkcDg1B+xxj8T0noqH6ABqS28Y0WKUJP7SpVfIO5N/wD46znQcdmSwgjEK3khn6fE2xkUzf8A8d96zJzXTtpFqI5wdAxRpCkKsbygpwQcYh1msU9gMsBHq3pRBr3nMh5CtbZkA4Mu46u5LONTnNSN4mzATUgVPcJtL1hifmMsU2KSoxPOst6NjwYadiy2zqCfzIhyV7dTgzsl12dQRwuv9xTqOp0i90WzxHV3ArgjUm5fVn18QqbVK9MyLU5pj9Rhh4ldDBqzgTz1Ks/p9pZh6k9u48a2Mts6qRjMCq326EcgWxcsNwDUF38TpDNHWvc+5tQOZQqkdTCNTMAyt7ZlqYxg5xC0yo7LAB0Ik7MEbIGZY1VbnJ8zVoqLAGReTddRZDnM2llqsziUcjjqhJXxIy+G8Se0VOCq+yp8ZST2OieBGM4ZRqS8k4xgSpUcuLbHDLoYi60JP+ZisWHjxCQup740JexH0ciNnq41LKLEKmseZLXyVP61lXDpqZ++YdzI302/P/M6XdK503Zfr9a8L3ELifV/ReEzWKAs+a+nA1kayZ9p9vV8nkcqpal8sBL/ACefXi8/Ca/Rn8t32XyPuH7s4dFlJNKEO5xoAT/QCilKKUprXCIoVR+AJ/Bf5Tvsq36L9tXfXedQFu5WFrJGwvzP79Pm/j8dt516vrx0+D+ocwfcv3Sn02lmbjcU4bHjI/Uf/ifRfdv1ur6H9Gu5DOBa4NdQzssZ4/8ADr6W1P09vqXIQ+tyTnsT5WeD+S5X5+fH8Ph+/v8A47fF/wCJfkfXU1LTWtaAAKMCMnTp9fhwnx8Zx4/UcLd9dOnTpTOnTp0zBsRbK2rcZVgQR+0/zG/j9wG+i/e31v6cK+i1cuzov4UnI/4n+nc/zw/nC+nHg/xS+ruydRyRXcuvI6gf/E+V/KTJw5/5Xb4b7Y/KP1ZSXZjPjfq657dZ9l9bcDsAd7nx3NcHsCZ2+LlLIjlK+O5y3ZOtTwOWpyc/M+r5zoWZOvmeDz6VUZxPTPXLHh31hE0PM8+8qgyDgz1OUw9M5nhXqWsJ7S5A109SosWzPOtuC/2yMz1qULVECRtwAbC5GZ0jVMpfp7dSW6mxnyVM9ZOMSwGNRx4yqCcA4mvKCcLUPE4uAMiX9FqXUTU+bMBdR74XBM3a1U4koGsclh/iMaxVBUeYNtvpL2Aia767CSRuPY9Sb70PtH6oNSsG7HxNNKPaTKHArryRgCXOUayluqWggHE3joqDAOYhwrjsj7jeOrVISxzHvFTYMOFbEmsC2WE5hi3LENE2vXsA7m7RrT/UUL0yMyPkcTPvEdx+N6rdi3+kZepQ4HiMkceXK/pDlVXBXEwsSeiHRg22Bm69f9Zis1fuxmNidup+XxmX3iTccDuQxwZfyL3Zf04E8qwEvldTjVzksroBu7I3zK7bjWoXyZ5tDWVt2J1K9kBzsQkrXkehdlLHUFlexcKcxd3JUIFBAiqeSyMADmd+KLyqpRYlZDmTi2zsQGzmVWH16vGDIVrdXJIjeOtOZ69hlnED1R31Naz24MzjKj29TrM48+DrOYOTY4G5MLFYYPmepzOIVUEDInmGkKSTON446dqUtxSwdvEs60WLnzPPfD2YEaMowAJmnib62/omkgVsfBEY9XbeZtaqT1IjtHXSjgyjj29cEZh3UqiaxuAvRE0YxU4VX/Uj8mdI+5/E6Kulftv6WC7gET+1fwU+z7Pun7n4fAVSQXUnA+J/JPt2hbLR6gn7Q/lH+zinMf7hsq9oISvI/wCZw/N58resHxcJmv2T9r/SOP8AQ/oPC+l8ZAqUVKuAPnGzPUJxuLoYekv+BPmv4i/dVX2t9tcrmLYBybFNdC52XM535+Pw/D2v6M43lyyPjvuXlWfef37R9E4bluNxD0cg5GfLH/4n9V4nHr4vHr49S4StQoH7Cfyn+Bn0LkNw+R9y88s13JYhC3z8kz+uT538Tx5fPy5/mfJ98r5/x1+e9c+Ofp06dOn3HndOnTpmdOnTMj8w2Rmz8Pfz2fSTxvuvhfVgAF5PDCf6qTn/AMz9u2X01KXstVVHkk4E/G38+fO+n8yv6EeHzKL2VbVf07Fbr484Op83+T5cb8H27fDL3fgv601bFyfM+Q5yjZBn0v1oEWt/mfM8uxQpDf7Sfxec5cIefHK8Dkhd63PB5lgLYYan0PMNb5CT5/kqpcgjJn0OPJxx43OpFhIWeHfx3rt9w1PpOVX0P7zy+Sgc+4TpKm+IkZv0oJRWpH6xCq9Kn9QEG69PA+YjXdkGQoBk11pCEKNygdKqyzN5+JL61TAjIzMqXUldjoxJEoW9GGXk5qsLH8Q/Swm/MrIcoOXYbDhBqJqb01LFcYjVdVPU+YdoX0ySBuFicsSvygRlRgxd/wBRFlfpMMTFTuxws6zhozZIh1btSKn6aQ+ZV/UlE953EtQtRz2/0gZWx8NqE44uVTVYtpi2oRHLE/6QbAK2X0jia6O+G7SsxXlN4jEknxC5NzIDrMWFKAGY3IRc9zKF4xM+x3ImLaGXBEc9qunUCSFmV+gGjNtc7xxtzqa8CeaWDWYE9TkVrXQSfJE8QZ7nr8mORzsh7Wge0S7jYesqTJuLxRY+XMv9Oupfb5l+JedyqyjfsZnGDNYAu4zmWFhjqYP09gHyTsTN116bIaqxrZElbs2TKXvFgC+cRdprVMgTXkrj8RCdMEsdxJbrZ2QxoKf/AETGqUnKnUi3XTpgzy7GXq7ZEnufKnU5gO2MzLeiLmRZBliRQ2SwExbW7bzKFuVkI6xSoCTmTkO4NH7EDsY8AL7hgydV8kRqB1HuzHFTk2x2fQnJU3cdtTKz/cnW2H1NGZ0Vej+4nST1rPyZ0zP9Bf4ffR+T9Y+s8Th10s/q2KuB/mf6V/wh+3OL9s/QuJxK6gjKgLf5n42/lv8AtUN9Zr+pcioEU4ZSR8z9qfSud6FS+4A4nj+Xlt0ceGP6K/1JKqshsYE/g/8AEf67yfvP7t430LgObFqcV4B0WJ3PpPvn74P0D6Nbclg9Vx0TfyZ4H8Afoln1z69d9z8sF1oz1J+XPzPh/m2/JZ8XH9vT8fHr/wCq/vP219KT6J9E4n0xB/7FSqf8/P8AzPUmDAEXfyauOhaxwP8AJn6D4pw/F+Gcb5JHktvO6bMJA8mfKfWP4kfbH0St7Od9SrUoNqDufxH74/nD+i/SXt4v0LgC+xMgM5yD/tPnfkfzn43wcd114fj8+dfpG/nUUKWssVVHyTifG/dX8Xvsr7UoN31L6zSWH/RW4JM/Gf3P/M993/c62g8ocStgQK6z/wDM/kX1f7m5PPL8nlcl3YnJLNmfD+T+Z/I/J/8Axnj08fxuHD/71+xvuX+cPh8ctX9v/RxYngWWv/8AE/lX3J/Nf9/csu30/wCqHhdvisCfm/8A/kVrgor5AkPJ+uZOGJzDh8P5f5Hvyc6by+Lh9R/U/uH+O3379Tqs/rPunmN38/3MZ/2n8s+r/cfN5nY38m27t/3uW/8AM8j6j9QNm8zybfqAKN2bxPd8P8fl/wDV1HL55+kX1a0WuxM+P5+rWydZnv8AP5Hbsc4zPm+fWzAureJ9j4/jnCZHmvybUNwrAJBnl8k0p7iIfMuatTPG5PLdlOcz0cZUWx3MKWkkank2jB3G28l8yXk2scCdZLE2xlyAgfJkzU9mzvUepYLk7nNcuMdfMuWpz/EXIPZSuZA1DgGxM6nolA74xN5ISmgjHkSpYfY8urndvYTgiU13hxPOWpVtLMdGWI9a1EjzKsjdqnsdv6oAfmX4W1QpnnUd77uxGMT0SyhMDRAgrtHXVVU1+07nnvyejAYyDM5FjseuSROHpoo7gZg2wjkF3bKwArZGRHNZX27jUxS1+1WFbQWtX2GDuVU4CdmPiS/0+Dk+ZSqHpjPmaYdv6c9wsU4GcSJkDtsyxE6gj8yVq2WzXiVMTezOpH7QHde2jsR7OAhyN4kNdNjXBgdGVMRbTHuaw9W8SK+kq/ZBPVv4zKncLgyBm3ho3Eh49vpHe8yutu5yT5kaFWs6gZzL6eMVUsZOGcS2Wtc9/EX6Vee9cpu4j215WTVN6I9NpnWcZDSFRciLe6tkKnzMYjtpsg/ESQpswYKYOwBODiIHIbsVE9FWUIUx8Tz7KkWzOICy0u1bVPbcOpTYPfBcu7BCNR3tQBRszYnrSnUUnI+ZtDds9vELkKWUbxDCVpQCpy0MpZ6Yr2IXqA/rxmJa0hcmLNvfZ+JulV2ihV93cRdjIDn5gDkkKUEGpCz9jHrgvIXqfsf9p0bidN4ntX+1X8Gfo9/0b6dSLh7+oLf5n9YT63dVYVLaE/nf23zU4NKqzAHEr+v/AHJR9O+n3c2y4KFUnOZ875LsdJXl/fv3Xf8AWvr1f0kWf2qyFxn5M/Q38OPrX239hfaNNf1DmU8dQvqWOzAZJn4A5/8AE4/Tvq9v1Wz+8wsLgZ/2nx/3l/HP7p+672HL5j10AdUqRiABPlcpnLv+3TtbMf6L/eH82/8ADf7coY8PmjnWjOErOf8AxPzv9/8A83f3P9w2WN9EI4VXhRnJxPx9xPrnJDs5cnscnJjj9avLn3k/6zzfPw/K/KmW5Dx5ceFf1T61/Fj6/wDUy1n1H6jY7udksdz5K37lsvuJss7dj5zPkOR9Qaw+9tQV5KV+/vr/ADOXxfwu3efq+X5P+PsX+rJ/0nZkPO+pu9fQHAM+YP1Nu+VfUcfqIavLeZ9n4fwuHxzyPPflvJeOU1QLFsyW3ni3J7Ynm3c5mBw2p59nMAyA09fH4pxRtr0eVziR17yCy9iNHEht5OTntFHl66zpOBjOVfYzFPieXzmdEIB8yvlcqutctjM8Lm89rAQp1LnFsiO61WYiwankc0oMsoGJddZrLCeZymDnok7ceIuIrb0G+si5LtYwwCJXYgyOw8RTsA2AJViMpRJRACYlLB3z5EdyK2s8GR8hTUQAdSKv6PtvQHOJNyLxavQiDbdXgZMjusPbsnxGca1sdZx86+IXpqK+o3O9fNWWEXXYSwUbzL3EXj2N49RTeIyxWs0uo5LFVevWIs5iocBYdx/XQ+l01omRX0s1mXbEuQh/eDkmSchXZ9nErjdHXCauIbLMdtSv0/6YYXxMqQ1p2zmDdazL4MvrKnb+kb2M/IxDuvdSAp8Qj1rIZvJjESt27P4kcuMdOPLlAUG2z3ZhXsEXxkyhWpU9UOIm6osdsDOeOnf/AFCG7tgnEoRAi9gdxdlS5wDuYg/BzjzKkF5Q5rLbB1bxPP5lfU6lR5Jx11iS8k5XOZeI0ihvTcMw1PTF3av2GeXWDYMASyul0qJBmsbRj6jZX7MakXJtLN3I8xtbIWIfzAtKk9canOqBSysdtMZlFmjuC9IX3KSIi1gDo7ket2VPfrzF+qtpHjUUGPp4MWoYHKmVlVOcWNavjE6joz9iRJjaCOh8wkBUEg4lendM5OTkqZN2sGgTuU09ScvnE20IzZT4mtsGanrWyxwrHzH8jgvQAxGiIJOCGOiJ1nLsfFbtlZF58k2JgMN4lC5VMgTGCZBWE7DqBDvqb4X2snTfUH4nStba/wBgfq33nxfofDfkcmzARc4z5n8E++v45/V/uC1uDxSaOKCRjO2m/wAZfuj0+LXxa7WDsckZ+J/C35+bixfzPB8vG/UduFj7Hl/cNlue9mcyD+uVm7E5E+bfnZ0HzCTn9NMRH4/hn3Ty5Pom+olThDr/ADCr+pnGjgz59fqCk4MXZzGD4WdukcbX0d3MtcA+pFWcy4oF7Txl55UgFo08zAzmOYl61fKZACxzGW/U16YzPEPNWwAKTFWXMGwfEYZHsr9RQ+3Mne7L5Bnlm3ByDHJyP7eSdxxSu1jr3RXIvSlQQ2zIrOUQclpHyLGf3dpUitFzr7Lj51+0gycENCtvKjz4kV3KLHCy42aVyriW6r4nn2MwszKrG65dpFbyVc+JWp6k8ouTr5ktwKrljKbLV8ZibHU6YZ/1ha0lRpYwOS+QJnJHrJlZvJX24WL41vU9Wg1lSBQrYfc270+vtgcos93UDAMYtQGAdmXLI53jXntYwcJ8ZlldK5Vx8CaeMgt7usfa9S1ZTzDYcsdWwY4Mi+ouqDFY3KEsyuAMmJ5HEa33kYzNkbtYk4vJsU5lFoe4d10Zq8SupchskRtDJ06+ZskO2k8ZLi4DH2yrkopAVR/mZZclPxJuVy+q5XbGOnqHk8VrAGX4i2qcKNGdV9QCLi2Zd9RrtXqmBjzKmUHCuvWTuBZlHznIg0cgXjqF3+Z1yDA903WJrrDWwLAbiKg6uf3j6gnUgmTO3S39oW42NspAY6O5Lya3rX9JOZa7BwGHkTLz3qAxsSdp6oqFwutRhvYKUmMCg8QO2NsJtacaWtJ75/MeOLlhOWxcdj4E5bLGPdfAhbV9W3cbAwfE8+/jkHOZ6B5fqN0IAxEcofjc0F41GFOMEzVQg5G4LEA+TH0GvGWMcRlhFhAcHrC2d/EO7qRoRCtk4PxNi5afkARZcLORSz4yZSaqyuDiFlX2qTt2OjDRB5YwjSg2p3MAPgiTlTeRiVj4nPTk4goTWck6jbbh1BAmwfZX9OPzOmeq3/dOm9PV+1/4xcoWvXYo+DP4xZfZ3J7T+q/xPtSytj6gJHgT+NW8krb1z8wvDaJa9FOSq7Zp1nKRv0NPNeztoNCoG9mXOBtr1KuZ18y0XKy9s7ngWP6bBhmULyiwGTNeKHovyMHPbxDHL7j9U8mwvZ+gmZXyLKvYwzJsT2exXyfTORG2cpXTOdzyV5CkbOJXQFsxvzBUquly52Z1t/pthWnWolVWV0Z54dmsJaY5q/1R0y0hv5eW6qYu/kMfao1J0asv7zuJxl9tgGdxFZJPYyyy2nqQSMiQ8nk11IcHZjKMwPLYlCAJ5qKCzd49Ly+Sx1J26u+AZWhPanXLBvESjWM2wcSm4oGCeYjk8j0yFUQOuepmBOMiT1oVsy40IxuTb6ehBoJt2RuGqDbbQzYxuS+p1vG9f5noNxVJ9wAMj5tJ45D/ABDT2w2/kUvX1YYiESsrnOoPp+vXmAzGtPT3NlovySHUMoJK/wCkxrypIc6kacnqegzBtZmb2mM41yvyw5ipBIYgmZx06kszwLEwgabkNV7PMcafJpXL5Khjj4kRvLOCdj8Qyhe0h4NlQRx13Mv7ONCckdsYiTw0pOS0srqdU7LI+SbSc4Oo7jYq4xrU+2ZyFCt3BzJeNY+cR9pyPcZu1GMNoYYXRizhWHbcAK9h9g8RtNTMff8AECahT/EG5S36DDsq9uEktjvU+JNqpeImUrojMRyGymDqU9nIyy6k9yerrOMQlpvKfpMjMV6gajqrug6QGsWkYXBk72v37iVKm8r+j7AFJY6zFNccbOYmy17juEtfbTR2otrDWbcsBmYFZPMYjemSoMXZY7HBEO1aaYhLnHxG9aaxvyYhQ6L28Qe4JPcw7Vc8bn35TUciZ2WzJlXs+jDrsKP1JyJUtpuGH2H5xOZ86E1m76K4iwvv85janDUYeHgWsPCwnCf4Mxawyn8zafonDTo/0W/E6bW2v0p98fWv6rlOO/tH7z+c8q8eqSm9z3/q7DkWswfOTPEt4Y/UINfChbZkFvmNS9h+gRLAJ7SZxurAwDuXHO8qsF3qJ1PmcLGTQnlrfZ6uFMY/LsQ+8Yhlp169PMGcEbmvcpJOZ5VVxsJC+TK0RsAEybxbyrEHqrkS7i2ekvu+IjjVhVEG+4BuqycKy/neonUeZItxJwxxJ2f94FjlsMdYj1OrTaq5UnzJXYK3YtqJtuIwfMVZYbF87m6t2FfaqjOdybr62WZpjqG8nxMXQ1GcQW/sGAZL6vSzZldiNZ+mRWKqP7jsS5GyCtdf1nzFr1duzbmWOGYID5ibA9b6McEyLyEtXqoAxEB/SuC9fERx77hZiHY2H7MZFdJYfZcGf8SHnO7sFzmdfbvIkdllptBGYSa15SG+o9WFxE33AkD8w7LWxhhJ+QpdQ4EuTHLlZRdEVCzEZPiIrFq2ZxlSYzj5t9r51LUNQPpgCNuOeSlFu69IhmFR6xt7LUSVIzmIrb1G92zOfLlq+PHGY93Yx1VVVylvkQLBo/mbSHWtiD5ku3HjRiwISgGYvkVf2yV/6o2mk9ckZJk3KsdDgDUF5U3HpYOcmHfnPWNqZcdjozmr9Un4j9udlDxnWnJGDmBZyAGOBiU08L2kkxV3FCDJlzii63h5sY9jF8yoJZ2+BDpBrfKeIN9qtZh9R6RPsKfloaypG8SEWOWJ3iVchKkXsrZM89bX74B1DrDtZcx7ZggORs4jXGVyRuLyzfGoySNOWiqQdu3xKO9ZGBrET2CphBkwBW7e45EKqegbs1mowv0xkDMJQirkHJiHDM/u8SLNXg7LWcanJWHGzuDg5wsdVSwHZjiT9NW1IqHfzOeqtX7QGb3Yh467aG0Y1goIPxCrpDuGU6kr2nt1Bj62ZAGGZW05g72RXCY3OQb1FXsrOGJ3H8d1B3HKzcvOlHq1To5U6/o45pY5Y5gWc9cEfiebVyAFORuJutABOfMvNMrn5dl/IIGhGkAeTueabvTsAU+ZaloZRmH03WDRijlsajrCt668zrGqFPtG4vij9sw7VU4RTxKzUQTPTqUMOxk1HGY+9xgShnVBgfEftusi1ORXVXhsTz3vD3HB1OY+qujFKor90ZxBrMa2yTqBdf7cLOazuATI77VWzA3KkRdVKzdcuNQe4ZvYdCJ/q/b1K6mh0Ayp8wEUCutwWJ8Sb1UBKgzmLHJRv8zz3VzbntJtMit73TOBIeQp5HuGQRLqShUhzuLV6UcgjUO1a8deaVuQg4OBGDvY47R3LsyM1roSai7u4zqHe0dMc1rU246/6w2b1CCfEbya1Zc4k/RlrOIbTIc9dLrkEak1ttNYz13FhrEQ9pN6vUlmGZtXipqxamQcGMRK3q9MgeIPFrF9fcHEZ/SkfpbcbyHWJDxnqJKjUUoOyTgz0LrPTrww8Tz7HLPlZF5JvGFmhnbJeMNBReymIsYlsAmV0V8m1QCp6iaWtIk9K9s+THUUXnWNT0Kqhnq2BOuZqDhAJeukiJjcpKrFnsd243KrMqPUb5ifTe8dvAjFYmwCdDxKKXpXVmIyqjqDldfmS8lEVsiOVNii25RgVHUHkFWRRnc7jopXLjURc6LZ1BjNTQC30n6yPlh7HLJPQ/ojYvqdhAurSlNkGVrnylrxnd20xgVqC+MwrvfYepnVoBnsdyeTSf6O1WAwPEbxkQKcjJiS/t69pldxVvE43XWSNswjZEZ3LKMCJv8AfsTvUZAAQZpV5G204AYGatfdc5gteGUqRAXkdBiPp8UVqin94q60tlcwK7Az5JMbW1TPiKbYTUN9m8TrLPUbqP8AEpuStaiQdmRoMtBGnLQqgOxyZQQr1kL5kp17S0NHKYVT5i1pRqcnJB1G+ooAUeZUK8pv5iDxlQlsxlqb6Dv+06Fgfn/idK2jq+wfk+nsmT+ub3wTqQcp7LMFTuO4+VAcncqY12K7GpqGTHcW2u5NGTO1NtZDHcnoduOSEOpXWUS17Lh8YBzLuBV/1ETzuBZ62Oxnsp1RAV1JvHFyqTcygIBqA47AxDXYYTbHI92cAyFDVuiwT2Y4+JiDt7s6gci/B6oPEuNWX2FMKCJNkNZkwDb2fBMIlVOfmOoMsTqP2klnKCHrmOuZmxg/6RF/HU4b5k2xOmUWuxySdwbX6Po5gVDGm1AvZUbHaS24qrA69+2zJbQ7scKYIvK6B8wl5nUYYCS6S6NXFa9bPnUWaFUhl1mASz2BzsRvIcFB08iVGreSrrWMGIqtJX3CMR3uTDCLUqHKYj4i0qy5GYpiQuwFvQjUvuqUMGA8wVppawFhI5YeNtHSPRQemdGV1IzYeD6CgAKZXUoWvB+JOOuJ7+OlmjPM5FIrs6rPTvc9sL4kvKtqQdmG5fHiLIkr4bF+/XQlhvNadV8+IjjcxrGKhfbOvapT2J3/AJl9ZHK+fTPUsqJd2zmIblWO/bBxMa0O+CciMVQ46qBIqpaK7++qjvgSisBKwqEGIfjFk0cYmVVvWnbtmEV2UtaoqKnRnlWHLbMpvPasnO5ArFiVOZ0kGrhZirx4kRJazPWOoYNmsmMK11MfBl9YfaF7SKsKTPPvNjL7jkSrFjueviSci1kciTRZUbVitiQdwAWc+YdgLnsfES1mNCQk9a6z5bcU3sbCnUX3YHO5qL6rbMM0mB1zsmYbT2wY9KK18nJk9q9GMOp0x1rIyPMQUJJIGoaZfQEYy+mNmb6F0pVwP3g7VswyQBmB2yf2jPQcjqww25ikLZ+0FV+V1O6OT4lTgnXWgFsg6nI/VgfOIwVD/JimUqc4j0sM5av7f2+/wINVq3grnxJ1a116/BgEPS/4hI2rf6YfmdJ/WadKHZ7dKIznsY1vTRupOBIltCMDDvc3YNYkyPRsWhKmBKtmLWtjYFx5klTWqeuCJ9D9O43esORuXLjjyhvCp9GvJWPFzO3RfEGy8JlfxEpchJbIEc1F8Pe0g9Ie+uWM8p+ZjkZzrMvs5CmtWEOquNi9GCV5BkV3JBbBijzfbjczujqWMPpeSjBXzOcdvB3MpZAcnYirOWhuwowJNp6nVBg3ZzoQbbQr9l3F38tQoRUO5qPWEyZPlF4hcq57k7k3QuxYtr94RfL4+MxtlCsmQcTY53ih9Vq2ONxlWL293mCwVCRNpHX3gzVpxsWPitMaiVuXOITZdNiYvE9Qe07m1cmiS7GQohd6+hbr7piIlXtOzMvVQABrMTiG2+1m64mqLV22cCOsRO6RtvUprWpGDMBx+agYK3kStuWXPUDU8pOMz2Bx4noPYqV464MqHs42Dvg7m38am+sAeZMpYkk7zG12hP1zpLitlAOJ6S+wSS3jNY2Z6DfUFGK1XMTZcobYxmV2c7xiC/i2VYYR/HOF8+6dyLmf2LsQa1epS7DMkZn7OuLGvrnBMGkmtMNIxynstJb4+IdlpcYBwRCcY1uGXMoyZEeRV3IHmHmx0KEbMkSo02lrQcSpGnJVXUXy4M1FcsTYTiCOUFUlPmb/AFA6e4eYrnIY5K1AjE83lWB7Mk/MqsVSO5JkFyF21Jxe2l29mGF8Q+NSjN/cmivGiZwIVvMnMT11vKrpTSHMnqX3ZjnDW7TJgqevtZdwvLG6ud2DgLBvDnZ8RmFz53CKjwTOd5WtmJ6SQYy1Q2y0XoHUFySfM32K4j4E4LjzGUVhtmZYv9zBlDDazWE2BmC1jE4UQlZE9oGTCWyvtsYld2/rZSrEEtOdt46ZjWtXQUTgARnEe+t/WypST+mFZxmc9yIzqETI2ZhstOgNSp604Qv0v/8AP/E6F/pOlYekPpHZMt5M9Dg0hE7suZ5gFocFRkZn0fBo9SkMwwcSQymiu492QDEvSyupOoIEWlSjIziIsQHPY+Ixs05qzcSQYm9BShUncyjklD1+BJ+Ve1lgIGhLlc+XB1XHDt2aUDKnqfAgFe1QZDj/ABMBZK+xOZXaOfWwTOhbxjEZWyE4+JOpFik4iluep+iLmTc5KnLFZvWpyGYYkbOLLSytgAxd6Nae5MFaiFyPEi/HFf2K25SDGcHE3+rrbRUzzHWxmwvielx0qFPZsE4k3hjdrSm5Klio0RG18sqmDkyNujWH4jKHw4X4kSL9Fatn6yNGatgUDeMftKr2X0cACSVVescYwI+MdxbbuS5RR7RKij1tgGDUo4y/2xJTbyHt7Z1NcZY4DED/AKoNiAn3HxEMHZwe2Ib5QdmMi2L4zSh7uQBg4+JZZw81ltyJbldsggER7c9gOgYQnJd4J6nNdnWFySW/xJ3tYsWIGvmNS0NWe5E6cUcuMjePahtFeRG82llGUklCoLfUzKrearDpmdJEX1DU5RyznOIw3qxziJep2OV8GGeN0TsHyfxL8TjhYoOfEYb0YEHxEdQwy2sQSANmTY3VOxZrcVjUyyyxDjMfxuhsOYV6J3/IkeHrRV3imsMVyTJeTYL27MMCU+0DY1J8o7lZtkacKPjcVLFwCMQLa1V8fAmBHqYhGmKHD9njOcX1K5D6wDgSX1kXx5lPP6AHqcZnmpX2Oe3/ADK7w7h9txO1+ZOXYnZMs9JAu4taq99jJvKHayi8qcCa65BcmAihX9uxCu2MCTcb0unDPsx9tYUBgYmpMtn8Q2dvBk1NpBDQkXWW8TiC5/aYzH9IgkT2EHFfiD3J/UYadFGGg9ASTmPjbWoAGDZjLV7e9WxFIMnEoFWvOpWRtrqB2PuMpc1gAL5iAjAYUTVIQkP5myHTkZlBfyIfHc3tgjAnK69M4i0cZPQYjJU7FfoL+BOk/aydHOTbHqfSawdWKCZ7aEUr41PL4tIT3Df4lT8nXRodl+ie2t2JR8GKDdsozCCtK57D5grUQ5IOpUqbaNq1pGc6gVNXY2hA5RJQAGLpqsUhk8Spg9ek9XSrKyVrVVSpPmGb8AKTmKvRMd5FuDraCtm7YUaMJ16sCdR1N9AUAefxE8nLNneJuw/ptBa2RqKDEgoTiY13VsEaEB3Rm9pheWtPjz7GGFQKnYi2v6aB8xHKduwA+Jgqcp3PiTlp8hqn1DoyhB2HVf1SOu0I29SlLlLg1ncucK3bTGW9D18z0eKK0rHbAJ8yUCwjuTDqxY2C8LwqpVjlGBVN68yK11pJzsyhWFeVXch5YzZk/Mi8XSVrXGzDJrcpdlesBjEtSVpyq4xI77LPT6g4MOp2MsAVyQ05fOz5g8an1GxY0qvoAUemcx6i1gUYKsYmxWQZU6lFPEsfBZoPMrNXtaP052amW0gZGYL2MF7AblHGpqKnuYm4oGKLGch1MXmr6OD5gDkHBbIiErNuUAxMPCdT+qVq5xUZZ17w1TsPd4k9NrI3QtkCbba+TgwtV1g+9SsQsDvl8fEnALNmNrUAdm+JJ+h3lnACfERlU8/EcnIUkgGefZa4sYYPmV10d8V+qv6pwvVzjMjIcjsBMxkZziV0T/bGc093xFV0hfcWmXJYD27TEYsMGRjTlKe1gbCLMPHUHJbzFYKbzNa3K4Pmc6uYMmuptDM5mVh2URYrLrkHJmKtlR34M0a2DrJCk4yYAZmf3DU1rCo1FrYQdyom2U3qGOtTOq1nLbEWbDnUx2J+ZsGQxyth9sYoRBhomgEncc9RfAzDKTa1rAyu5oXvrOIFKAMEyI+yrp7gYXS7staknZETXW99nfGoxU7jMeiFE9gjNHWUFlLAATaaiMkQXN1o6jWJ1JurOG8TrLR/XDuhnTO7TpXY/wBfF7lLqnsHgTLwgIbtJGtyMroxKO9tnRmO5zxEtr0G5CFOitsxQa+tcDeYDcYVOG7ZEet9bDHzLnFU46Spc6eVU31VrhyP95Ff3z7WwIYorKAu+T/mFquigrWx9TtqT8i7t/bTxOa2ukdTsRBJb3AGT7RmH8eoIwdm8fEdbyqWcLkGQWeoF7ht/iTK7JYGabpReePSvFR0ujIGyrZ8Spj2UPJnJstx8R659jdCgZmywlVjj0CqeY8cRPTDdsHEBaAu2OpUsiLwtefXU1hO9xtVNldgJGBK1oX1OwIAh2L20v8A5j3h62NW9wOrLqZVdWrFlMNKmaoqBJRWFs6nULyXPFFfM7MRjUmu5LeuCBkCUmqsJ7BuRvU7WaE5Wq1fZ9QVahmQPb6uW3FsP7oV/Ee5qUBcYkXk5239IreQ3hMjEp419jrjMQzUmzqBmejwuICOy/MP7BJyVcG1l/VvER9QtFraHiUeh6W87iyK3VgQNye+uk41IHUphfMl9JvV7k6jXxW/VfmdalgAKnUZTeFdhlBcfEmttuYF1zKlBFXuMW9iBOoAM6ypyxEjXM/bxKyCRkbiR7n6pKhWUTJbcZYNpXuXBxj/AEgXXdVwojlIsGD8TrKRjA2TMdqdAvplh+qKWtnOSJR6ZqTazuPlmO/E2i+jFSV1e7zI3UuTjxLbx8HGJOQlak5ErXPq8+6zDdPgTK3xsCdf1JJB+ZiEFYWqkba2oksYwoSwJ2I3063wBJ8XJYGm3qNwbbjZr4jLKUAwp3JiGGpm9ERrZnYDCYASJ3iVLiXEBYSBf+qYCD5mNntgHUdYxG9+FlKZJ8ai6ETsMncbawq0pyZhvrgoWwbxkyu1f7IxueeossYEz0VcCnDfibxRFdnReuJrXsEwFxCr6Elz8TrfcMgDE3i9K472tk4hvcwXB8wUJr92IIra1+2TiMRbYz1H/M6N/pz+J0cT25PReypXJUgzlNZYWA4iuiID3O51QrYkdpMlbsotu9Q4B8RQUj3FvEAoQ+FM20sgwfmXtVKcreumB5ENKnXbtqLourrqyRuKHP7P1bxDXSVZZWjrnPiK7qh6EanWX1qox8xXItX0+6iacsFrLASdnU70UdeznxJvUstXMdS5CdHm7udB/UgH0l2BNXsXyZp4qs3ZIwMEbq058rp4wS22O4XtoR1tVvXLHUAPSmGA3FW33XN1QnEmusEqljgNKaq2UbJMDj8fqvextz0Vag0+BmRtlVjaXRK+qjJMU9dJOXAyYp7PTOVGpwZX97GOjrHWJ6SZX5kL8h6m8eZ6lhrKeRPH5Cv6wHxFNhq9X93zA5Nb2AADxBHatwx8Rj35IIMLInCU4yhwWIlvF5DUv1HieXdZZ6nmX8VT1BOzIvGOnHHp2cmo1lnG8Tzn5I7EKp3Ov9Vj7M/4nAJUnewbkYv/AIkfu+SF3DF9iV9WjBcrAkLJ7bGscKBidOMRy1htawhPAm2VGvGTowmr6AMDuaxLplj4nXPHLaClE7dl8wuRkrsnU3jGrtjMD6jdWHCp4h9NKlaxu+EMq9Rwo0cxfDqW09jKr2qpUCc7V6JLFsTrYoH7yY1FHLJ4jAfUTIOoPqqoK+ZUrWhJ9YYJxiS3VnGA06/kFM9RiRNyHJO5cRbGOADjzMx10ROQ5cdo64hgAJrWlkB2wpAGYsMwOQdx1IIOManMAjk9ZGq7QHu8n5hrUGGYBbJyDoTDY4OiYi8oI1vX8RR/VHeo7DDTFUE5M3qNLYEbmrg7hWtvxBUE7jtbfDUOTkx1aozZbcnryT1j1Uqd5EydhrafC+ITuFXGYhnJ/TOS5VbDwVLDVLdSRBrZmyoaE9oVMr4MTSwZi2cSpTpzMyphhOViiZIxGjpYMkwbAuM/AlSttD6jToPqr+J0ptXXEFggPicagF7DOYQpwS2MwPVwCpnbyIwuux0bDGHd3twSYa8Oy0BlGY00FE9x3JtjSViUA1gYibeGQQUEfTeUUqw1+Zi8hSxAM5Wq9gVqsZB3GMRPJxgIhlDXFlKyVlKsSxk7idan9urA8zBaV2wi2ez/ALdQiMrhj5hqor41qvoQbSS2xE0EU7J8w2ZrH9p1Dx1g1GVIJjOMr1nsw1ILDetnzgSyq8mvDTbCpttDrgNDRbFrABzPPsycFTLKGdahuTbFz1Qlnt9Nl2YB4zBSQcRvGVM9rDGW3pnqqjE0TYlqqsB951/mBZ/7wQr/AKx17e3RwRIW5FiWBjvEvdTmH8unOEA3NTggV92ME3NawcY/xEcnm3LlAuoXjqu3H9g5NAyGByJZQVSnsR8TyUtuNmH8Ez1Sw9AKBJ6teUTtyGVu2Yu3mCwANrEcKhj3GS8ilVEeqf7DqbkAwAMQm6s3bUk7CtRkzRajDRlyJvO0171JxnUNnr6ftJbKyR2TZnKH6YcERwfYm0cpFWL32Y6vuFx18/tMur6qDCthlRWmvKiKttFzZYeILXBFCmT2uevtMmwrKW9p92hI35BSwiIW+xB1z5gdj29wmkGjtsZ22Z2U/E7qDuLIOdSp42Q6yoBeyjzAStm2TA9WzGJgZx8wvp8VoT1IURJs9x7QkvKrjES+yT+ZGN5T1VX2DicSijGNxClsYBnWLYoywMZBkPRe5ziE6MASMRdFvRM/MIXMck+JUlFkJZi2dQQxGgYwOQSR8zQgY9pfVOyNqbDA+cS6sCxcsJAiEtgT1eOV9PoRua8U56lSrFmcaiOSEazC6ltmKgWJkZCW2ZXUjFyMYhUCEzFpbHb4g8itkPmMotBTqTNI3hlKP4zmXUcTuMMfMk45JP7T0ablo2wzF0k40X/ptP5/4nQv66v8To+K6cQVcwKpUrn95MpWywmUNxRVX2yDmT014DOWxNULKOb6aenjcTyeSxklHIVbyrfMpsTvseIWiFl7La+qjGfmFxuI6tljnM0slYGCP9JrcsCrAO5FtVkv2easNogxHKAVe5PiTHl3D3A6jEY8hSX3Ccq3WfpOl7PkEaE0Eu+MyiuqtQQwxBZK+w6bMe6caKA+PcDC6vVYAPExqrEHZDiALmL4s8wvJfFaxW1MBdibXxu6ZYYxF0W1o+ScxpuO+p1J2uuSwKJW7dCRGtQ6bDak1FYZyS2JWe2Qrk4lyWpxiF/AzHVrvLfExSgsHXwPMO1ux9krqmwu3jva/ZTqTchUr9uMkRrcxkPQeRMIFh7WaJj1Ran44JbJ8fiDyrFBxgRhHoksTozzbmsawnyIep8V1iskFsSh7FRciecquPeczjcxOD4gcNt5Od5mHkrauCYNaq+c+It6lAITRlRLbEypYHImcYKclplPZFIcxqdAucxHZtVhVzkZEoWxXGcSZ/8A2yVncRxWSH3NlV2iprl/T1xFXuGXIgX3E/oXEma09SCfMFS6Ta5sfA+JjtgYI8wquoO/JmXLk6EfGylDqdxjshHjGIQ4gdcodzX4wRfcTmA61OWA0s3oxXMKqoE5MOwhf0zJsqcaODHKKwPdFH8icMkeZFaw5lQYIORAYqfiYW9uIE2NBoo8gw7CXXDRYzjUIuOuD5lSKanVayPmK95bAhKDjM4Ng6lYWshXedyjjU9gWYiTlXc+Y5K7euEOczeouKeOlXqEZl5rrRfb8zza6nqHZhGix22TqOo7SN5ie0ZaTVdF2RHNX6jDLRtnGU1ErjUmql1Jf1s2DkRSdAMZ3GKqDKFtmdZSiL+rZhpx1NvQ4lrX1lAWMlr43dMgwLq2K4BiYp/qafyJ0870X/E6Ctex6tjggxYZgpUxoIcErBrCMSPmdOqdKqpRm7Noj5hWXHt0HgQ29rEAaEQR2Y43N1xNrrQUTuYC3V2DGcGbZ2cdDFLxR2AzsyLGnJT7CnVY7ilUGDAs4rVIOpzEh2U78ycdJTOWzd/adRdbkEfmM0/6ou6sqPadzSMeLWIwzRlXFWwlvOInjBbEwx3KqlNWQD5lzjGRWqfV6oTmehRWqKPU3mRWVMLe2dymkucdvibIrT7KhkGoETAzMpDf7x3qAJjruItchdQM5GUOo9mI9iEU5M8+u8Ve5zGPyPWXUfRsKH/9jsdiN5DVkBlbBHxFgqpIzuSFWDksdQypuCusttbA3GUjoMWL5nI9Qxg7/wAxXLssyAo1DKIq9ND8jEmNIDnI1A4xsL+4kSlhosDKwk6r92NQbGDL2UQuyuOrY1CWkH4wJuqeSD1uzYaavYthTox1/C6nssmDtWcYl8eGOd9Uiuxh51G8cJWfeMydbbGQkTKuQdhxsS/IOp3I5aBuqrgSLkHufbDf+425tdYzszlyq+PGxOh6kZMcbTjGMwLUWts5gNYWGpz10lsOqvKEzGuZny24pUZhmEoxtoxXYwMF90RZYXOtQ2XsCcxaqWbHibRbokUhdzGyIzqUOzF2NkwTWY1madiai52fE5hk+2bBuDHtTAGZjKNbg92TzBLMTnMrMMuq6qk6nJiLK2BOpi2uPzG/+4uhuGtpNSuwwJVx2dM5MnVmqbAj6u2exGppdFq1gba85E6goVNZA/zFeprAjUqwO+Z0kjlYS1Ld9McTbW6VFe0a9iFcY3JOQuRmV0hiZUZznMY6MxHVswVxjAMNQykEHUm8VyUys2Vr1zG0YOm2Yl2YJlplVhX3EwxUiz0x/wBonSf+rnTZDkPvb0EPpnJMTx7WB7E7MevH1mw6irVrDYQzWp6083hhvEEWKDgY3FgAJvzARSWznUNo6qLEU4IO4tGC2gGbc6qoy0FXrZTg5M322KrOSoGF3ITZl8mawONGD6WBkmOKilj2QFYKurjq+oNasy4Q5ifTtrs9+hHxWq6+lJ7Azn5Lufb4imXuuQYfGrDe0sBM1unorWspaXCoN1CY15i146qvbvnEfx7EKnHkQBPLFuMr4EnJLJswbeTabCnxC65XZjOKbqNve5Un5ldNIZeqtA/p0B7FhMFgpb2tmX1kQO/jMo7BtyQqxbzLLuR2qzIqc2WZBk2GVyYV8scYlP8AU1FCAATEW1F36ATEpFPtJkXVes9RmYlRqNrscoVPmDbZWi9U8mDVaE/VHY3pVpYMMfmN/qT1AzjEXa1Zfv28xVtiAYU+ZXaJu1V/UGzWc4inVTtlk9VjI3jUebSRsak3m046FmCJ7fEBbU+RuHYysoAnClCvbQkX5Fz4yLHJbQmqzJG5pwc4yItzlfaJpdN42F2e/ZMWBvUIZJjhWnkmVJqLbClLAgQ7MADAhBU8qfEBnDaHxN4nbaEMR5gklTkQ8ayYGTN4qN7MdzMMYxcddiBkTZG13gYhVnfiBCUlRkibWs8baMwPPmM9jLs7iyCJrdaf4JSBoTVdh+mBgnwJoypk0iUM9gz+dz0C1YUASGt1zsTS2TgZzDcVPXooqFRgZMfTUQ3v8SLi2suA0vezNeQRmVKMhN1ADEodSaymy44A0I31TsE+YyrIU4GzL7jqhbi40vkRZruXZPiVOlisSwkt9rLlTC86Y3JsHWEUNY2IrjWgNsSpmDkSe1YnI/BnSjov4/4nQ7thpuBTBMEUh8ETOmTsTDaqHCmFtdbyh7VqtZJPieZbc4JC6lXd7cqTowRxlPmaVy5J8WMuXJjq6/7eVjLGRU6gZxFKxPjUuWOV7G1Y6e6EQGXAMEgINmBxmzYVZtRuU8bRrYaBnMtQJylGSM4ieRRWQGV51K4I6k6hkXrL6PTPVDuLRXRwG1LFTDdnirrEZx1E3h1TXjAHaPuNfHrHXyZ55tZSpAlFjsyhzsRtGk2OP1ddxL3dtE4MIP3sxiYKgbC2PEJcFloLDb11mLrZi2HnoB0ZCpGx+0gcdWJAxHumcKL1H7dfiAzGluw1NU52ZlnVxlviF+TV8eNGvJ7HsYjkXntnMw21HXjES9ZtOV8Sbyi/YJbAWyxmNZ5AOZgpwmfxCrC9T+YWxtJJdj8wuh8kxlbAE5GcQLH7ZxNLE2ND4IEyyxidQEOGyYxrVII6+Y/afY4WDREdvp2kyAj3R/8AUDrgibFd7E7Alj8TB3PtzDdwxyBiOpCAbIyYa22gCBV35gHLfMdeAvjcSrANuOt1tcQUXAPmChHbc0uO37TGIJyBEZYawQDRikZA47DU4EYwYMBPDrCpOF8QCq+PmCO3xDY6GRuS3gMFTDNgb24mMfEE48jzK1WStIwcgQyCyZxCpZcZcwrmUqCs3aNgKa+5xnEy9FrbZzNrfHidapZsmOwYxShOAZVVxwxDSVagTqNW9qTg+JvFSRaeOQOyTBRdjIJ/3nLzFFWvM6q+wrk+Jm8anHYbeGbDWu18TfVBGMzjyKwnSxcn4hVeJLeQ9nuxqSkCwz0LORxxSU6DJkCYycQ1sg0pA/SY+tFXbRSWqg87mrb3OMbjuoskVepV+J0lw86bwbFZHk5kDqxuzjUfTZ2BLGabEGgJF1TaxkZ+IPqHJEYj5XqJmETbDZgLNJRgQSR4igSz4Go12y2AMCFXWg2DuVLE2VluVQA5zEIHD+fMu9JLFyxxiAyKGGMal7EyVyuyLhvmM47EP2PiLcqfb8yqhUCe/wAmc7XTjKpRkfAPiMv4/HUDqNxClEGYt+Rk4En1djb1FfkTRYHr6gxF7tYuD8RVeR8y56JkULS2SYw9VQgeYgXMqlRuT2PYoyzTYuZVKErk5iBYXsIZdRP9WWHUHcFbnU+5ZPosNtJDZGhBuZTVmBdabPGoo2ZHWaOe4DqWGYdT9Pb+ZnYKNQVb39jH7M5Ki4Vd/Ml7EscfMO1w5yBiChUfuZo1oVZkJnDLHzNOzub7APwZSLQEETsETSfn4nE5E302tyQuBBBOcTgcncPpgZzNut9BYEGZkgjc3sfkTCcnM0mtNMNmQAYBXO8TmI8x63VCvBXccPpCqANzegIyDDZFKlgYsEjIzE40VkwThdGcXYfMEsT5hjY0PjxCBLwQudkxiV4I2MTaeolp7ZJM00gLnMK7CKOhi6wz6Jk63Uo/5hKS3tMc3GwP1TRxwuCTDtD15EgkNibYzZ8RpAXajJmovqAl47E2Uut8MCRG2tVZjAwYL1hBoQVZVOHEqcoMPqqB3Ca7oegBxC41le9zbFRySsuWDqxXAxqbylJUMFnVABgrjzLnqT08n8TWaMseJa5OsRZLDxH3lfVI64iywzjGpGKlo6lXHYmWcdaDkk4knVAntOzOA9NckncNbV+KvzOnnep+5nTadge7NoGU1Vmwa3FCrroTktep8LHyt7FPZajs7i35Ck+6b6fqHs5ivSDWY+JONpvqV9CdZnU7/wBYF6AABRCpda12dzTiLTbjgBQ0EqAue0VYSx7YhBWuwqeY5hh/GqUv2c6j2x30NTqaNBT5hX1ivfmbYdwFjq3tzEuQpwDBIPbtnUDDGzJj4LyrTa/fHxCAI3ObqmS0FbDYNeIxG2sfkdDjEmsvazXxC5WzoRH6RNVS4ML6eGAzmG7MSMjEyggnBEK33NhTJsP27GfbBNfzmZ0sLYXMcK+o9xk4iypTnxOAxuPsRQpYYzJyxi3oyA3iHWqgZ+YCEDPzGBzjOMD/ABHDuBswB43FhS24Tt3OoRuHXrgCOU6WB8GaozkGCW3/AJjKWBPUiTdbNCqEt+wmucQr8K2FMS2T5M09OQxVDLkmYAvj5ggE+IQQ43HKLkCV3jzNwB5EzYMMhyu1j63ra1L5CiY1TDJIh8dmrbsBqM5FyuowNzet1qXGficyY8xhA65Bg/qM3rewOMiZhvGYbkY1M7ftBtrQSnmcGbOVnM/bRE5VJ0sHSchtY5204WM2hBHYnq0NiFXCjc3Vf9mN7EGbZaFAAH+0WisT7jjMMhMYO4Xim85TKsXaHmdyKVA2dzKCK2yPE20es2QYfVR9tprwmv8AiCrOWwBvMKsOpwfENM9/aJc9TuNLe9e3kSm+/wDtgLJraizgwxS+QDK6t3TW5xlhEeoMYAlvKQquChkSVgtsam60dtbW+Dkx3ZHG/MAVrjMz0bDtRJGWj6r+J0H+7+P+J0GynrVle2YDmtRrHacgtZNfMUabEYMw1HF6xntz+0Oq4Zw061iQAoiSjDZmwasS5DnK5imdO+xiM41BKZPzOt4oJydRgzTAoZMjGJ3G9tmVEFVZVwp1Dqf0vcRN9qkw269629sJOSHTD7MCywuuesQqZJYnEOitPRPUfGdTuSqVD2HJmVFV2TFXkZO8iM4YiprrS3kwuNYQCCNSexgz4WU1Vsqg41KwYC1u0SAWPWUsmTk+INvpqAa/M2M4Vqi6OzOFb+RqAMsNnf8Ama9rBeoEmxcsMJ9Jex8wEsZgWMV3b/qGYQz4UQN5BawnUCacg78wiMrnE2Odcn6TGA5TcSM41N7nGJUGa4AZ0YXp53AHmGQyjMPVFk4OMQlc+YBPaGAOuT5hTfGswbzBJBm9T8TOp/E3g8arBYxSbNDUUBnxGKSoyvmbKMMNagZxkic1wx1xEi1xo7mgKfe3ib10lkb3IGBAbON/Mxmy2QNTe3Y7E3raJEZhn4mfoJhepjUwAPNqLdCAWM4r1ODNJ66HmZ1Y7jgc35xNQke4TupI3DQL+knE2Nv+AZmzkzg5zuU2VUhNNJ1AZsE6ERojZrxOrKsD2ODGKiEYG4lkAOoXWlNFYVCxMBLcGLLMfbmb1AG5OK3Fr3p6Q6jcHiHsx7mBUyFMMNwAwBPU4lSDVVgIfTah1tYHyNyX186zuUcewqw1nMuQ7FFtgcYZdyP+2WI0JTfkn9PmSOgXJHmaymWCBQeDMFpPgSdAzsR5jURq9OJPU9oLs86b3nTdT2PoUWpo4gWnJ6ecRVYsGwcTGLD5nPuucYN2WsYxmYafVTQ3A6mzB/ErpPVfaMzdk2SE02mk9XxCtc2N7TqKtAa3JO4ypfeMnEqepMV1I6kYM4AWawNTrK0LjBjVTZC+JTBW5UHQjM10rx2zjMU5VX6nzB5NgOApjo1zrjwYsf3faYGbPmB6hDgA4iGWVdXxjxKVsLVdMQS1fl/M0Wp19o3BigjliDNNH5m+oR7mEJrgy+3cqWp8L6lMdRkxdgbyRiWcYA7abdShE32Pr6R5AHYDMMWFlyq4MW5KtgHUI2dRjriGK7AdhnLDcAuXGAMTWIOyIVboCCy4jkO6DDAYM4rjZjrClhysFkBXzJuCaUFJOQIXZj7WnDsoyJgsYE6zBWOAAzqYNmcW1uYp34gchobBGI90QLknzJiy41nMFmZvmSc4n9K18N5gAFWO85gqO3zCYFfmYXAOCDuOpNZrPeIb3HcKsqDhvE1nifGiss3t8TGXp8x79VQFZMST5mmh37mapIOZmx8Q0xnc301CxycxlbdtQrUUjKxAONRlH2a9gBwIHn5nDqYJxnUcaR2T+ZoH7zACYXpn8zYTaMrvzGNsYKj/AGi6bFpOHGZt14tOFGBDafC2UBtTsMdGYyEbzOVyfJm2t4cq4XB+YC15J3GV4cdc5m2qKxqbvU4SKznZ8S/ihNFmGp53ZmOMxqkgYzLnKpserZZWw6rgmSOoRiXiKXdG75JAh3MeTgqTOnpmAQhGLrOa8Wtuaa/TTJOJMMsxCmTVzFOR+Z0n9Oz8zoa2xQOyAgncnYsp2ZrGzPfJgO/acpxV2NqsCeT5l3HsT0ydSLj8Zn9xGo9ytWANR6tugchrsymyhWVejYJgLQrr3GzDrsWs4cbEqSQ470GrwSdQkcBsCDyeUrpgak6OcZlRPXDmXvaTOupBUdYkPYXwBqVKpK9nPiVlBSYrrPcDMkerLdxGWszXhQDiG6FRjEMrYQoy2zH+khXXmIYN314lNKZXOZUiaT89Gjq+KV9y7EQ4LW4Otz06XRKCo2ZfVFRFhWwmWXBsAHz+8yytix7HAmCkLhgcyeshhL4V8idZarDxGXIv6jJiOzYE53z6MujyhA1NsFWgINidAIIUH5k2rlOFa40YDowP7TgQoxmMDqtezJmnSS5C9QYIJE7yTicMEShric+ROVcnU6aGx4EwGtBYZHxOasgZmrf1GMTmuLJgiYelqpbxMbPyYSZwdwfncKXDzNK/IgwwfbuDX/RqTjBiyN6hEkL4gjOM5hJRGkjH7zkQncwKSOwnK+8EypxXIaqFhjtF2IUMJmK7U4iw2WHaV1bxo15E7rnYnOe7Y+ISjB/aPVNuOC5GMxlNas+GbEWfOpxJP6RDoNN5KVqcqcwAo65UTkTtt4zsinqDGcFeUsAuNnE1alxtptlRJysThi4XxN1hwXRlbKwuzP7TGnNa/pzFhj2zDyIwsIRZiPcADEB3GYPYGaWT6azViBFq3udW6H2qMZk3qkAA+I6he+1EqctbIzk12A7bMynjED1H8Q7ywOMEzO9hrOsTZp8M7U/tOkeW/E6bpW8OatioA+JOayDuVNblwEibyVPjzORFRyWrPUeIdzrZ4+YuqksvYxwpK+4DMqBtBsr8+I9lFq94HucbXETc9lXtXOJc46r0q1Oz+dR6hAvXMX1d17YwY6nhE+5mMucU/wDRUhe/UmUvWhXHbEnPGdXznUe6DpttxyweEZSttgEiZdcWI9uBCKIuOxyZz9SPGpF1cxOVFjdRHCo1jRIghkqbsPMpsBesP1k6KlR0ezDDEaLaEb9Q1FqmycYzBbhMR2B2ZpyqbcN5FlVigp4iFYZ69os121t03D/pbCQZu1HZnK69RiS1n3ZMtsVFXoxyZG2Q2BC40u+Ds9zedCLcjOFmHPzMhsXI0knzOYsRrM3Ax+85TDWYvjZ3NasqOxnMuB2BnF2dQD8ROBhDBHiYAIX6R2jBY5CinBGZrsp8Qf1H95hUiAxoBPiaEwdmHUuRs4g2nJ14hR+2FB8GcVyNQVODGBHIyAZvpr45XUDq0ByAcL4nFTBhpmGIyqhBisZbU2aOo3HVOJPgwiykD8zlX1DgbnejZnBWaVrAt515E3t/mYwwcTiMGVtSIb3DptVG9wihnOo6uoWDxsTbRjrrgc4HmJUgt7ow0uWwFJjP6N/+oYm1QTaVHtOYBtHcNjEanGZ365m28JkcLjzKHZrWM6YgKOoOZcnE9NQWEZ/SVsMzdbWeR1ycxorwA2JTbwCrdh4lFNdfXDLGfHVYj/p2uGRqW8SlaR+8JMYPSOqRSPc2DGcMGJ3TtZkJkQWasaKym11qBGMyF3BYkiOyDo3Nf/YJ0D1B+J03YdEqdlPia9gbTxjJrK7k7I3bJE8s2ukxXxzgD8Rlt6jSiLrYBIsq9je2Hq//ACa/IsC+0f7CZUWsPvGTKkrRKfeBmCtefcBKlp2KeJx1G3GpQUqUjBGJE9zKnUGbQxbTE4nWWouLHFOc5nn8rsz+wjEZdWwOQ2otKjnLtOk39uXKxHf6gYYyY0WB6wPkQ3IL9QJh4vT35hYiX/AJs7HiWLYCMAE4khHU/uZZQoVcsJysdZaWWGSeuBJrOYyv0US5wjHtnEjsqR7cibBaMOCvZhuAtthPUjUP2k9PxMKmtu0Mc9B6XZiXkdpCvgSq68gyVyHOcYjIqFk5mfvNdDnC7j+PQD+vUcX9TxPNwY6zj9DnORAYZGoDWA+0gwVGYXpsVyNxlNZZT+ZpG3Civ4mlh6eDDKOgIxBVA2zKxuzqqwwz2muozjzMHsOoaozvr5jJE3kHGNbhItZ+cytPpzvWXLgf6yd6hScZyZXWNOUo14tZ92RH/wBsL1AEk/ugjGcSisDGTC8ZVwh6QrZzozUoQyjFRXDtMratM/MnD4S/GB8CIegjUuVy50NRNrf3AAJORvIXSqVD3HZjfe3gajDUrgajlC1oAvmbI2vPeomyHZQAAeu5VYhXDBdzB2Y5ZY+J3UlfFssYdRLV45qUdhKKSq7Cwrj2XcfFRy0VqnYYJiSXyQRCLkLhZtbksO6y+MibpDUuPcARG1ZLgv8AEfdZWcINRdtQ11JnTyOeVQVWz5i/UStsEaiWFyfpziZ0a0ZJ38w/4ZbDXsW04SLwwBUjzBrpZD2hM7nOAZW1rzoavZlZm8/rIigLFJJbc7uVPZpz5WtORzWKEw+zI2sDtqNvJZMgSWsknx4nK2u3GmZE6dgfidD1fhFTs3tEc46gE4kqt12PMaHLrhpMmuOKajWy5AhFSELIJnFNagBxLlrqZSF+Y2Gagrtez2N8R9aWjC51MaoVNuPR81aOTJ+jC7KnXxuM46Mw6gYMAXuPa6xldvX3L5lyqyDvPROp2ZLVVc9nY/pj25ABLWjM1LQynrrMvUXjAFAtn6Yi+4s/QLgSgB1JZjkRDsr2glcTWicIUKXwbDvEdTY7oVjXevHUEYmq9QTqo3Ix0yROhLOa2acahU2Ow3AdGV+2Zuez92bxHEWhs9jaO4Rdim/Mw+98rudara+P2lOdT2p2APbcw1L0HU7jbKSwyNRXp2IdHIk2mQoKytsx1WASS0Agb3uYq6JzJtWJ2wT7siLqI7HOxCCeocA7jPRFS5J3NJrFlymcDUNbPbkagghsgwmVUTxnMqcU6A3NuGqCxCwGDOrVehLLDqsX9KSp4C+oGBg5j6UA2TuIsZlfJmi0iLZDzZYCVDnESx7vjPiaGOifEbTUtlmf944JMoSMjUdSgI85nXooPRRO449PIaS6YTeo2VMnXsxxPUrSnfqDzJuVStZzXuRa2Mqyg2YXoFj6kWmDs+ZSlwVMHxJbqQLWUEY8QuNa3bsynEJujDIxKeMKmHXAm2K6ltcCx7eJi3IQQViuWyq5VfiBXbWdYjKMVV8gKOoGYJu7vg+BFZ9M9yNTvUVznxLlI7i7MCmcSuhkZOrjBkzcpFTqBuJo5BNpJ8S4Oy9+OjtntsQyVXA8kSd7wRlDOpJbZMPptil7gw69ZI16I3tOY570Wsp1GfzI6KA7MWMNOzDjzAV8RNfIdiQBMcVVnqCTBrdEfORibUfZikk5fUDkMvXKmDyuSlo6ocGKTKr79iTbTODa+QWBUiYGVTqAGQZKiDpvmRrpkh3rp+Z0R6JnR7DA1qGbBlldaqmT4iK+Oxb8SkVsB1zK4uVv+FHLNlRoSvj2b8Q+JQhHv1Gj0UY9cYlKmpeWSxznEPhqcZJ1GWUpYchtGcR0HSs5/wASdjXR2mtSCRJ7eSlTDoNGMZXYBWE23jVKnnJlTlE+kmz1iNZzGrU9Y92hE0sK2zj/ABH3u1qgiOmSuZsDqDEunRckQVDKwyTCLNY/QnAgrIUuXbUOwPUwY7jPRFJDAxvpryBjMLTkTWkMA2YxakevTbMB6DW+D4m2Vsi9kk7RZG11/wBOC3YExDuXfs2Jqi67ONYiX7oerf8AiM0eGMWf2jxMNoT2YmhvSXuZM9xduwGprG8dYrMSRAyyjEL1CxwJlikbk0BRyhyDCe5mOcwUAY/tCAC5OYK9FW2tiMIBA/EBLUxsRqtXJuqkYXRUxiZQB+rGI566ivZTArx2/AlS0WQPJH4H/EGtOygkRtuD4ii6oMCXEHgVsvUDBENbEoGR5iq1ZvcsyyhiwyJrcOruP0tPqMJt9YZiUiEzXgA4EqWxFGZF5HULMckfiDXZ2b3x1irYxZPMSy9R7pPZtNVEZ/2nWhQOog1sFXI3DwHHb8TfbaQpPgHcKj1Q+8jM5cF84hM+ThfiODWXgVns2yYpWVj7V3NuLFfd8SZbSjZAmbVd4foN+YBJRPGzFf1NjEZGQI12JUMRHa2k9mDdiNShbVC5A3EtYrDEBbMtjGBHvT11XTYzZC/MerlF92pLSWrsyuxKbGDrkgAw7Wt1ElqHb7hMVG1ktXUtv4jnsrQdv/mVh6lXVlx2AkvpWOcS1OWraYQSQN5E1acKkbjvUe3mNVxdWRjBEGy5i2PiUIlYr9nmHqutQDIJB8RqAdwAf9IVigAgeYpEce/xJynJFfpidJ/Xb8zpsrf+XomkYypi7EKDs0AXWLZ8mNe/1h1KYxLyo2OS8Feo+Y/+lUVdw43ILRYn6RiaORZ02TqTtVMVFfCg6jAUq84zJKrQx0dTrbezgDOJM42r2Kri7gFRqC4JTLmCeelaisiD6nrNj4M68eDneRa31r7WEdQ62N1+IT8WhFDN5krMUs9mhO/Hg5XmrvqHbKxQ47tsnE4mxl9p3GgWLTvzLvGJnLSbGyvTPiHS/pIfzErU5bJEoKgDq05cpjpKxWNrZaNa5AvTAifSOwDiC1eF35kSaezRYiNlfBnWtW6diBmSMHzgRtSdkILS5wTeRR/uA58ScsqnosfaQilV2ZIhPfOIcuONPW56tNawtqY69j2mBD2GJzvE7BMhUAwDsgAyi0e0ZxJwpDTZjTloxWwhrW2MnIhIwUAsJ1lwfCqMSfttoQx/T2MZ3VV85izRrOYLApjJjOI2mdyg3OVe57MYvD3MANyqur0l98LDraT7gimPfKN7oFVYB7gzrUsdsiTfWlH3Ww6+I1+oq652ZJUG74A3GclXC58SMq4ZSiKpy+zJ7sM3UnUwBmXPbcBSxOHjlO4YStS4Xcbx3UA9j5iB1bWJPY9iMVBxNlOyq7GCseuhAR/SbudgxVRd1PaF09pDNJ90Y7k2Btr4M6ihHQk+YgMQ2DsRtNhV8DwZY6uChD1x/rGdg2E+IFow2Ya+mE7A7m7YucZQ3cfH6RFekT8GUU3DvhhqU2tSFBVYzlBeGIlt9PR3HgG0A9sCBYiOO3iKFhPtVjqdePVxsqw0hVJU5MgtFpJ7EyxWZUDCLusGASvmde0iNsSp27DJlBs8L5k1je726E6tiTvM53lrrxtVP6TEYG5RVWgGjgyJB2OQcYj6S2dmc7tdZXWVgPsxV7dRgQ3bDbMnuyTmHrW6Xkzpk6bQ9JWCtnEPsMdgAIuxQcdWiezluo8CV21HU5rGJ3CKqUywxEFXz5jyPYFLCbDiMn0rMrsShFZh2ja+KrDJOcRpReuAcRmQXjUd1QOz5Eo41RKgoZo47Ee4+ZlRei3oPBnScpHPlwtM5GemCdyR1cbOTKuSvZs58w66lK4Y/E6d4n+uu4TDGGxmMvcKcDEnVGUnoNQQLFYlwdzdo04YJbnazQ1GW3DX5EWpKtkjAM56lO8+Zzvq546u8l9+J11hdsAak5YI4AjGf2dvmTipQM/XUD07G9wJxOCNYCc7jBa1NTIRkzbY1mkXKoUYO5PoHxN7M7bnWADQk3lanGFtYEOthn4zF4OMzJuzZKba+WjKRXjLHcQASdxjAAZz4heTZjrx2bCzFrAOHOIQcABpjP6knaqNZG/UCcTGrYgMxjVsyvUTncHAIGI7TsHx2WohsR3ItV0yAJPpwAp8TbOyqMgybq5eJlJbGBKaL1BKuupHXcVGQuoaXq58YkpuG3W1VvlPMRdcSMk+Yjk/qzmLaxrML+I4FNVyjzCZkILRCsFXBG4FrsZsonpqW+TiAe1j+MQg611jQJmJyB22MTeqw2teujMavJz2iXuPY4Opy2H5Ov8AM0aw1lRh4iA3RvMM2bMWay2TKkTqhOt+icTjQK/+rMRUTWZVX1cEk5mxU5NC1+n2HmLW38maUJBUeJ1dHwYdVd1Ciu5cZAiMJVZjAxAVHrs8mZb3758xkotVGxH0BqC9lTf2yBqLwwTsBuJr7dyXEfU2R16qDhYgEqNCMZsPvxOYDORDU7gRawGDDruK+SYs+Zy5B1MuclChXbsxg3phgRsTigKjoxz/AJhCtlT3SNPYHt/7Z0LP7GdDW7Gil1Q7/wCYNauPM6q5i3Voxzg6lTYj0DFx7oNdjWNgjxNIc/M4gKMgjMrs3ql7jXXgRHq2McrF12F36E6MrFaKuQRHymWuFjFdnxBNpBBmeoCeoMd6SOgGQIzjGtrcCwBs/wDMYegABO/8xK0Ee0PNPHIYZaXIi05ORXWwDCZyb1sHtAGJworbwckRPUdyGMvIO1RvybScfAlNbl68n8RN3pKxAj+OoK4yNzdU3lSSMvmGWQsEhW19Wi7VTHbOCJF2Kl/1T6ahfaZ53KLq/mE9zgaaLFpY5bcFaWGPjG5uGG8RjdcggTGfOgJrE6Ak+JkIYzuayr5EOp1y73OLZODBD9TgTgSTkjcOpE4XGoAzCNbkb8RhCisAQxsYocKSoyJtNbWZycR1RzX4mI2GwBiTeWHBBTSc+Zt3MDgKV2IVt9YUKRuICJZvUm8rS31QVnA5OhjMVb7GAEYXIQTTjrWVt1JVezmIBU7EdZYz19Wk+gPMuRHpisG1iC3nGIAODKEUOMkgTZR7E5J8TgpMbbWBsHMWOy7xNh2iWvJwZpHTRmFzjIgEknZhlb00lDsTV7M2hqB0br2HiMrt6jxHKxdg92oVZZcDeIZCWnK6jUQYmtq5BVgsdQ7uyDKDYgoPxCexFTJO4zkbCEvLNgjcOwgDtEKwa0sNCbeHYZU5ErdTaJOR2HUCD6iKTnzBrACedxbq3kwsqXH3NC6HHmCtbEdhCTJIU/Mn6OBx+ROVh2xiN5FXVQRE1qM5PxHYuQ8J0HYGathyA58zkZSOucwSM2AAw8Vijov4nTvTP5nQyMlAY2dxGlzrOJjKU34hLUXXOYVz9a2MAgxLo77AjVTowDGUOAo7CTvpyoUpdT2IhWPZodpr3PkjIxFH1H8AmXKMM6tXhh8xltrBR7txRawKAwMZ6fcBmnWcoi6ZXaxH7zf6li2GmLVhsgwbUKtkf5j2icqqq0qSceYFgIOfzMrcMmQIRbsmx4mnJU4lChGOSYZATAUxC2EMQZltxU+2PZXUy63BxEu3ZIthZZ7sQ6ypAVjuTeQ6FFSQdQANjBMptUINHUnBwZPZc4rK6VADExdqB7MJ8zhZ2UAmD2NbdgcxnLW6RllTIcGCMZ3Kg3cdmglKjnPmVsTeOJWhVg9porJfBGo4qK8YEPBlE1TBMkzGrQJ284hNaWTEyvK+5/Ei+mRqclAvUriIazLZSV1103AkCIZK628yepylsVK5OczaSN7mP0xowFrY+Izi20djp215mtcoWIYFSczlw2sR+lTkYXLrkRU4gqcZmgEjOJtTRIoO4Wc6Bgo2NTQB5m0HKqgYJ8zLSirgiLFi5g2OX/ab0zDC1ZAEW4H/AEwVUmMDdBC2t4bxyQCGGpvohslTGUuvTOPP4inYjSnEjtTOLK0CggHcOn1FbY1BVSF7GPS9WUDr4mlrp1axYbURDq75jzZkgCBexTBHzOkTeNqR67Ejqz1T3x1fVgDZA5DowwmNStiLxsKdB+oGLFoBwRmYe51mL64ODNa0V+oOnsHmKLDIJPiMR61XriIfGdSN06cXazWdf4i3XB/zMrJAwfMJfOSIbDoG9h0DmD7s5zH+pWR7huavp4yBK8TbSvUs/M6O7VTptg7U+wLYckRbFqm0dRbXsDjGot7GfQMizV7FXYPsw1tQr0MmUlU2dwVySSDIw6bZWp2DFJaUYj4nIxGe0BwPIlSfpWyLe1VtWwMyax2VgvxErcy6ExixPYypxo7RctuhFWsWOtxSN7dxtTKD7vmHsTbo+PcoIVzGcvlVqvSoCYnFRj3BOIp60L9ZU5yJ9Tq7McSsBFTLxXWuo6zmC7tZox779Nqk2J16gDcnurwe2RBNh0uPE52Yrsyfae0jG2Mk5iifwYWT4mRkw6ZSN+6OKoG7MRFBcJn5mLlj7jqTUdjhahfqdCBehVuyma6JrrGdUKbO5tF5J/VYD95ocv5MNqe3iYtWDgmVo0S2KuvMLkKRWCD5iumGm3Wa6gza0tClrVpoxbOWOWmTpsdJaLGBkGEt2IvE7ofOJvo9j2ZLFzjcUpFbZxBGvE0jImGxpIZhDcoBhYoDEJUJ3Nja5QO2/BjwisuFk+epwZVWyY0RC2w5KnasqMwcHziPYecwFyfjxNOScdWQG93idcoxlZpAxkxyis15PmbsMTU2FMg+Jvuds5hOU2AIARs+2byrlOWxhonMwOFJAHmKrDB8mVCs/qxiXILyZWxznOodjIVwfMB7EVeoxmJHYvmZu9E7nGCcQQwA2czrF77zEwsT2tOVxnUEjs24KjeoWcHckWhOm3uHUqs3ZjoQH8zAcRwmWOmfaJynIyYJC9cg7goTnHxNkOVpUkwivX5lAVMaOTJ7VcNjGpsGUGZ07qZ02NhvZCuxuKJ/E4n8TVGYJ+mZOdmb3x4MxvMyKpRq5JwTNZQTgGLm5mwtZepxNUgjBEHbfvG0dSerCFGUGMkAalPpV+n53EWKK30Yyp1LbhW9cl715TOoNfuszmPKIT4EB6RWpIO5pD6XaVLYE00sqdz8xJx2yY4OXXqDqN8HUFaD9beBBsfs2R4lCBAvUjZk9yFW18zTlKcBNxicBjzNznUdZ2SMDMZglcgQcgjBHiNGl8agiyke7OzHV2qD7viC6E7EAp8zeE9+R2PVIKlux3OqRRsiYcq2diaWM71MZBEWFZznEx27GEl4QYA3HTgWXEzH7wncvvEAHM322VoODmGX7axAxrMyON9iyAZmN5+JmMxqITC+KmOatVHYwVceIx3GOpitDwJM0WQTJn3CZXp5xclcfiYufiVmjwy5jnR1BL+3CzUVn2RMJVTjzCwwSZK4M7BB6wq/d8YjbUGiJH7NlIVB33CL9HwsBjvR3OBHkmVBdGxAw4MNeT7cHEmZyTOClhLiTrBWw7KYrswOpwfqvVvMZSoddmVh+yex/M3o3zCCdLMsNZjuQwZQVk04SqMBkQlIXHcQa2IzNZuw3IGNuVcgKZo4ljJ2xqLUgsCT4lycxVrNeARC2x04zXnlSpxDrG8ERzdDkzayuPE3ZfQlx1OVbcwszDDR7ouO3zJy2ToeIy65cpW4M6d6n7zpvUZyYV+Jw9sYhRs5+IuyMPVmiZuAIA34mknxHBZ+nYydQxge3H+s0qqp2B3ArbJ9wzBc8+xFQq5ExCoGfmcwJOs4gnA+ZovtBMpbZMKtfbkTEHcYj1Va6zsQqGAuVnV97Gw2xF+qw8TheyHxN7FSRTbTUF/BiqwieTBNjWnWYX9JY22bAhlOQuy4E4QYxFs7MRn4hPUVbqDBdOhzKkg3BPoA+IsZJ1N750ZqEKd+IyZE2nIyhdrucX1jEBrB4AhVjvojGZGDRK4A8QsI6ZHmZegrTHzE1OVPmPWtppDL8QXuB9pEFrSTFFt5jOI+2sN/5mlQPJmsysBjzOVOxH4ji5AEnOJ2CBGWqinCzawHGDNuNmFhvgQumsw2RVHtmK3bCQ3U47CKufJgdz5EJ8A4gMc+JmwO2aU115X3CThTiOrtZV6mLaOxERMiJUTnJY+dQRnHmb2N4rqZehUak7J7/Ih0spBzoxdj+7UPbTKJbOjY+Iw5Y9u2pPgnc5XIPUQs065zhsTgfzCKDzma1J69h4i10uEGK+JygFTk7mAEnEqJxvtY5aPX01XRxEhPdjM5lPbrNa0lMtsU4xBb3KAJt1aooIiAxB1J+1aaqlTgzGwIeQy5+YonMybWN4yISLlfJmYOJqt1Mza091E1bMfBgs5OvicCMYmx0nI8t6i5XMV1O9Qq7FQYmOwXwc5k/QvpeDOm+oP/AKJ0r0ZGBseJ2CdzIYOBuVidxh1BnToCuJPz4nA/icRmbUAG93iOKlz7MQr1IPzBsUL4+ZjkdtTGYtJk9VsZ2K6Eag7rgnYicgn94aN1OY1Nrtg9RMJOcEQwR2BlLVoR6jDENxppFRNfuh+va28nEU+Wb2+JbxakYYYybcWiyS3bMwt2PujuVWK29snOfmVPUcqzAzNwZoXWTMJOYp02usBh2+Y5qwjhs6ie56iLNjk7YzTR9ncmwNJwcwzWWXsTuLGBrMVSRsEwwMxq1r1yYXlipxCiArDQqsPACYWAKWYZmnLVZgGwx/eCQy+I1KmDYxmE6dRuXmi1iVOy5imRlMp7OK8KIn1caeHRNpOSW3NAydDUaqpYdahYFeV/5m6ovL9FEgThlgRN9MufZKaeHYF7t4mnFtif0WCZHmKGQcET0QFxseJOw7N+nAj4YVjqNTlCAZPmOHH7eGnCgI47HOJFsMJKMwyBqAEbPjcssvr69VEQXA2BJ0lMjr+rIEIWP1651DNpsIBEF1PwI6wSpGz8w0qJHaCrFjgwmLqdTep1q1v27EaECwntkCEL3xiCCXm9PawDuzeZygfMIrgbgx/426YR0ExR28CEcBcmdRYO+MQbwLKwM5lxsSxrKVXBGDJbSD+nxGRsKxmcAAfEICcfOY0a2ytgAwGoABMoN3ZOpAxFKAXwPmGrk0GB+J0p9Jf/AKZ0Ox6p8GZCzqcFJ+I65b/oZpGJxUiaDmDMwPzDULiARucVImZxG5wBPiaCPmaSP0iLbfoGB+J2MeYw1MPE5kAXfmY/YK294P4jrbWsGAfEQiktiE4wcAws9XPB1vgdcRysyDIk2ehB+Y4uWXzCxU5RzMW2TEuBnUwse25hPbxKngtlEVYD9puvxuYrEDBnAEtgTa53FARSoYmJsXByIxrHACEYnKD2AIjo6lgFhN9EDzGthDnEHsHOcx2D2F9VTRhFwAAJjlT/AJmJgNgznVzkaCGHXMaO1K5+JG7FXyDGNyC69Zss+nWXVVLqW7fMC4BrMtqSBmUggkS5FR072NkzpK1kcHVUI8yYrWz+8aj7bK1XGJI13Y6ErUXjFT01IoNZnVrnTDzFVWnPu8Q7Lt+2a6jIOrpXYdajjysgpnUjVnAORsxbdkOZKtkWBP8AqzowbOoXAEStxK4jPURlAGjJsbtB1IcfMGy1e/Q+PzDFgqr3I7HBOR5mxG6ZZWAcg5EIIhTcBdjcIK2PBlThqbyxqVqdoITYIwRudTonAmdgbDncLwVOTDQOpb5mLhh1xH9wwwBEjuj7XUnF7APV+FiurKfGJ6dTIxHZRA5KVs3VBMMecc/JhV1tYdCVH6c6p6jA4mVkVRbCbayo653N46FDl1MZ6tbN5zDdh0ImynwrkdX2PiYiqUwZnwfmAMq2I+w+U6umsZyczLkRVyJiV2OcgHEOylxgEak2qnGFCrsvmYKXBzDYMgz8TBcxU/tCa1yO906Z6rfvOjg7QAKr5hi4KMAQCoY+0zmTHzHHHJ+2FidzUU5yRqd2UDGIyuwdMGbCHqpOBOYAnAMFlOciYucw60zGvX13mYBjDRmPb7jMYr19pjJQw2sT5nA9/MFU7ZP4moQCRibDLjMhP8zQCxBEGxdxldoVcEQvi5dbbSxAIEMV4rx8za78nfiBdb7sqZpWyFFGJx1M1a2zoQxefGIWcbMrW6sCHGSIyirue/4jKbKyMN4nOypn0zqSOlpfLZcgDyJisARkxFjBnzDNRYArMLLDOSw8AxGQoxMPYtgzn1HEuAJbH5nMvQ+Zy/8AiGqdtkxzSUd+ZqLg5PiGqqzYJgv2DBVldTNay52DCrtKggkzFDWe3xAsqatsGbo20Vh7nMAa8CEBrcAnBxNlg+zJoHzBHibkpsQtsTYaLFzsRdjhoJb9pnkybbWkEmo5UUDtEYH5hhiF8zSCtaztozq60bZMDqCSSZmcH27jlbDyoA1CrsKDDCJ9Q5AOYbuOsdoxvqjvoeZjdwQQIAXr7zKfVRkBXzDtXTjNczdKwQNwGssKBsR9dYsrJJ3+IvqAvUx+3ScRUdmXM1HAclhuJqsNbFRNUs9hJGBN1H09NLWup6HxPO5QVMqY5bSgxmT8s+oQVlSIpFaEN2/1lIIYEn4nU1o1eO24B9rdVGZ0kjly2l2Ag5EOmo2MCYwVdR2beYxPZhgNCFmq46cXWhAvWJssNw0MRi9rskjUzCqpA8yOrp2TN46mKarAyPE27sGxnM5c9cGM4453lpeR+J0PoZ0fRpI1sTsnzmZOnLXR00HE0AETIaNGr51NYH4ioQc/Jm0Y0liMTMaxmaMsczDkHEqYwlRgpI8TCQB+84OQMTDiPjeuX3NgzmTBwJq4XcwsxORJxQq8Z6tqUOlHTGcmSAHyfM0mz9W4ZFTBohDRloDJo4xF0licsdTSOz4B1HcOwKv1QjMxbGOj4Me3HBGpw4wK7bGJt0dsIKjOjmPS1VTHzJ3XqcTlJBmwXlonBz2E47GxHVgKuX+fzMYjP+fE6SRzvIrr1+JqZJAz5jOhIyRqYVGMjzKwShuo9PBzuFT6ZB7ecQXWxtnJhIimsnO4XxUvgamxaTGMnqNkxdXtOWEoyjjXmR2pTOADgTM19SMbjX49nbIGotqiDDuKXnMLAA35hrWB5mWKIWjttL/zC9PWQZ3QEQlU+SdTSadAo3samnfiEW+BB2DLkb7DuEhCnc50I3AkU/cPc14yBuAo9Q4gg/mamAcgwE44aVwOpMFa2Q9viY1nujKrw3tYTLkwP9SynC5xCqsLnLTfTRicDZglGrGc6lym8ldddZJaT3M1b6HmCeR7fboxbuz/AKjN2iLbWeo5b9XmUoFZcA5MSqouzOa0KfZDsN/wYrdXLDU0ZayCOQxQ58waWYuTN2pixipUD5m+708Y1Eq4LY+Yx36LHurHJf0UqYks/csCcQ62R9sRMNqsSgl8eUc+UKYdznO4xasLnME1ENqczOmtytc7t+h9P3nQfUf/ALTOj2gzkkwZk4kg7E0AEZBnnx6HDM7yZoGJhznM3UN6/vOKH4hIuRkwmbGsTdanboMFR5mY3mHnIi/B2ZWGOJzMhhe04hR85hZSctalNmLKqh85jKWIHjIEU2bLMSMtMEVB9w8RhZbE648TBQ2dHUMcZvIMetGEemwGFjaVCDLw1BU4MVyHI+Y9acNtsXICGYjEnBMk7ZOcxnYDYMZxFNvRPI3FIgLACGGVvMYqDsCPEcxOV1wXATwYoDp5aVvXSy5Y4MT/AEpz3z7ZmnGsW/r7TNqy768Rb1e7IHicj9f0+YbVYruHWvUmIPQtnELLuME+ZjUsRgGPpmOrIKY8mUU8dQndtRNNYrYAz0bArU6MladnHQqvmRsrgksdR+lgtiz25xKmI5S1Nks2AIxqSoy2o1OOlfu7Rd1wLdfiVI55Qoiu2Mw7K8L1Ah0UKT2BxKLKwie7yY4eqSqpMb8wLKSz5UalNdJILmLVxkqIK+nJQAPfE2KM6EsCZXOdyZlJbqIdW2JsEtgCEawozmUOirgY3BerK5XcnqxCL30ZzKazKeNWCcEbjruMCpxjMmyxvUCuyntNaxnGSYXpFTgjU4KM4AhrUrY3OLE/MOxQo0YvcYZ79jGW+ZxQwASDGKWxM3V3XIh06U6iWZh8xiXAJ1xM2DrB7dsxlzgoNxAsI2Rqczmw4Go7raxn1hYVADNljBKKMbja6+xABim3TLLApAUw06j3NMt4pCgggxT1W9QAfEewkxV6tP4H+06R+k/5P+86btDr/9k="
    }
  },
  {
    "token_id": "producer.collect.testnet1644538861217",
    "receiver_id": "producer.collect.app",
    "metadata": {
      "description": "paper bag, safety information",
      "media": "data:image/jpeg;base64,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"
    }
  },
  {
    "token_id": "producer.collect.testnet1644538861218",
    "receiver_id": "producer.collect.app",
    "metadata": {
    "description": "purrell wipe, headphones, airpods, chapstick, wallet",
    "media": "data:image/jpeg;base64,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"
    }
  }
];
'''
'''--- src/utils/roles.js ---
export const PRODUCER = "PRODUCER"
export const DISTRIBUTOR = "DISTRIBUTOR"
export const ORGANIZER = "ORGANIZER"
export const WAREHOUSE = "WAREHOUSE"
export const TRANSPORT = "TRANSPORT"
'''
'''--- subgraphs/README.md ---
# NEAR Template Subgraph

A NEAR Template Subgraph project to help you get started with The Graph for NEAR. For more information see the docs for [Building Subgraphs on NEAR](https://thegraph.com/docs/supported-networks/near).

Customize the following files:
- subgraph.yaml
- schema.graphql
- src/mappings.ts

We've commented the three files to indicate what likely needs changing.

'''
'''--- subgraphs/generated/schema.ts ---
// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class User extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save User entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save User entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("User", id.toString(), this);
    }
  }

  static load(id: string): User | null {
    return changetype<User | null>(store.get("User", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get tokensInPossession(): Array<string> {
    let value = this.get("tokensInPossession");
    return value!.toStringArray();
  }

  set tokensInPossession(value: Array<string>) {
    this.set("tokensInPossession", Value.fromStringArray(value));
  }

  get tokensCreated(): Array<string> {
    let value = this.get("tokensCreated");
    return value!.toStringArray();
  }

  set tokensCreated(value: Array<string>) {
    this.set("tokensCreated", Value.fromStringArray(value));
  }
}

export class Token extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("owner", Value.fromString(""));
    this.set("ownerId", Value.fromString(""));
    this.set("creator", Value.fromString(""));
    this.set("creatorId", Value.fromString(""));
    this.set("tokenId", Value.fromString(""));
    this.set("rootId", Value.fromString(""));
    this.set("image", Value.fromString(""));
    this.set("metadata", Value.fromString(""));
    this.set("status", Value.fromString(""));
    this.set("category", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Token entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Token entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Token", id.toString(), this);
    }
  }

  static load(id: string): Token | null {
    return changetype<Token | null>(store.get("Token", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get owner(): string {
    let value = this.get("owner");
    return value!.toString();
  }

  set owner(value: string) {
    this.set("owner", Value.fromString(value));
  }

  get ownerId(): string {
    let value = this.get("ownerId");
    return value!.toString();
  }

  set ownerId(value: string) {
    this.set("ownerId", Value.fromString(value));
  }

  get creator(): string {
    let value = this.get("creator");
    return value!.toString();
  }

  set creator(value: string) {
    this.set("creator", Value.fromString(value));
  }

  get creatorId(): string {
    let value = this.get("creatorId");
    return value!.toString();
  }

  set creatorId(value: string) {
    this.set("creatorId", Value.fromString(value));
  }

  get tokenId(): string {
    let value = this.get("tokenId");
    return value!.toString();
  }

  set tokenId(value: string) {
    this.set("tokenId", Value.fromString(value));
  }

  get rootId(): string {
    let value = this.get("rootId");
    return value!.toString();
  }

  set rootId(value: string) {
    this.set("rootId", Value.fromString(value));
  }

  get image(): string {
    let value = this.get("image");
    return value!.toString();
  }

  set image(value: string) {
    this.set("image", Value.fromString(value));
  }

  get metadata(): string {
    let value = this.get("metadata");
    return value!.toString();
  }

  set metadata(value: string) {
    this.set("metadata", Value.fromString(value));
  }

  get status(): string {
    let value = this.get("status");
    return value!.toString();
  }

  set status(value: string) {
    this.set("status", Value.fromString(value));
  }

  get category(): string {
    let value = this.get("category");
    return value!.toString();
  }

  set category(value: string) {
    this.set("category", Value.fromString(value));
  }

  get labels(): Array<string> | null {
    let value = this.get("labels");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toStringArray();
    }
  }

  set labels(value: Array<string> | null) {
    if (!value) {
      this.unset("labels");
    } else {
      this.set("labels", Value.fromStringArray(<Array<string>>value));
    }
  }
}

export class Log extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("tokenId", Value.fromString(""));
    this.set("receiverId", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Log entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Log entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Log", id.toString(), this);
    }
  }

  static load(id: string): Log | null {
    return changetype<Log | null>(store.get("Log", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get tokenId(): string {
    let value = this.get("tokenId");
    return value!.toString();
  }

  set tokenId(value: string) {
    this.set("tokenId", Value.fromString(value));
  }

  get receiverId(): string {
    let value = this.get("receiverId");
    return value!.toString();
  }

  set receiverId(value: string) {
    this.set("receiverId", Value.fromString(value));
  }
}

export class Order extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("orderId", Value.fromString(""));
    this.set("tokenId", Value.fromString(""));
    this.set("status", Value.fromString(""));
    this.set("token", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Order entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Order entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Order", id.toString(), this);
    }
  }

  static load(id: string): Order | null {
    return changetype<Order | null>(store.get("Order", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get orderId(): string {
    let value = this.get("orderId");
    return value!.toString();
  }

  set orderId(value: string) {
    this.set("orderId", Value.fromString(value));
  }

  get tokenId(): string {
    let value = this.get("tokenId");
    return value!.toString();
  }

  set tokenId(value: string) {
    this.set("tokenId", Value.fromString(value));
  }

  get status(): string {
    let value = this.get("status");
    return value!.toString();
  }

  set status(value: string) {
    this.set("status", Value.fromString(value));
  }

  get token(): string {
    let value = this.get("token");
    return value!.toString();
  }

  set token(value: string) {
    this.set("token", Value.fromString(value));
  }
}

'''
'''--- subgraphs/package.json ---
{
  "name": "near-receipts",
  "version": "0.1.0",
  "repository": "https://github.com/VitalPointAI/graph-near-receipts.git",
  "license": "MIT",
  "scripts": {
    "codegen": "graph codegen",
    "build": "graph build",
    "deploy": "graph deploy <GITHUBNAME/SUBGRAPH> --ipfs https://api.thegraph.com/ipfs/ --node https://api.thegraph.com/deploy/"
  },
  "devDependencies": {
    "@graphprotocol/graph-cli": "0.25.1",
    "@graphprotocol/graph-ts": "0.24.1"
  },
  "dependencies": {
    "babel-polyfill": "^6.26.0",
    "babel-register": "^6.26.0"
  }
}

'''
'''--- subgraphs/src/handlers/item.ts ---
import { near, JSONValue, json, ipfs, log } from "@graphprotocol/graph-ts";
import { Token, User } from "../../generated/schema";

export function handleReceipt(receipt: near.ReceiptWithOutcome): void {
  const actions = receipt.receipt.actions;

  for (let i = 0; i < actions.length; i++) {
    handleAction(
      actions[i],
      receipt.receipt,
      receipt.block.header,
      receipt.outcome
    );
  }
}

function handleAction(
  action: near.ActionValue,
  receipt: near.ActionReceipt,
  blockHeader: near.BlockHeader,
  outcome: near.ExecutionOutcome
): void {
  if (action.kind != near.ActionKind.FUNCTION_CALL) {
    log.info("Early return: {}", ["Not a function call"]);
    return;
  }

  const functionCall = action.toFunctionCall();
  // const ipfsHash =
  //   "bafybeiew2l6admor2lx6vnfdaevuuenzgeyrpfle56yrgse4u6nnkwrfeu";

  if (functionCall.methodName == "nft_mint") {
    // item (NFT) has been minted on common good
    // we need to reflect that here to be easily queryable
    // but we will not expose the owner or any fine details

    if (outcome.logs[0] != null) {
      // grab the event log and parse into an object
      const parsed = outcome.logs[0].toString().replace("EVENT_JSON:", "");
      log.info("outcomeLog {}", [parsed]);
      const jsonData = json.try_fromString(parsed);
      const jsonObject = jsonData.value.toObject();

      const eventData = jsonObject.get("data");
      if (eventData) {
        const eventArray: JSONValue[] = eventData.toArray();

        const data = eventArray[0].toObject();
        const tokenIds = data.get("token_ids");
        const ownerId = data.get("owner_id");
        const rootId = data.get("root_id");
        if (!tokenIds || !ownerId) return;

        const ids: JSONValue[] = tokenIds.toArray();
        const tokenId = ids[0].toString();

        let token = new Token(tokenId);
        token.tokenId = tokenId;
        // Set token root id if provided (for derivatives created by Distributor)
        token.rootId = rootId ? rootId.toString() : tokenId;

        token.ownerId = ownerId.toString();
        token.owner = ownerId.toString();

        token.creatorId = ownerId.toString();
        token.creator = ownerId.toString();

        // token.image = ipfsHash + "/" + tokenId + ".png";
        // const metadata = ipfsHash + "/" + tokenId + ".json";
        // token.metadata = metadata;

        // Set status depending on mint from producer or
        // derivative mint from distributor
        token.status = rootId ? "NEEDS_LABELLING" : "NEW";
        token.category = "uncategorized";
        token.labels = ["unlabelled"];

        let user = User.load(ownerId.toString());
        if (!user) {
          user = new User(ownerId.toString());
        }

        token.save();
        user.save();
      }
    }
  } else if (functionCall.methodName == "nft_update") {
    // item (NFT) has been updated by an organizer
    // we need to reflect those changes here

    if (outcome.logs[0] != null) {
      // grab the event log and parse into an object
      const parsed = outcome.logs[0].toString().replace("EVENT_JSON:", "");
      log.info("outcomeLog {}", [parsed]);
      const jsonData = json.try_fromString(parsed);
      const jsonObject = jsonData.value.toObject();

      const eventData = jsonObject.get("data");
      if (eventData) {
        const eventArray: JSONValue[] = eventData.toArray();

        const data = eventArray[0].toObject();
        const tokenIds = data.get("token_ids");
        if (!tokenIds) return;

        const ids: JSONValue[] = tokenIds.toArray();
        const tokenId = ids[0].toString();

        let token = Token.load(tokenId);
        if (!token) return;

        const category = data.get("category");
        if (category) {
          token.category = category.toString();
        }

        const labels = data.get("labels");
        if (labels) {
          const lbls: JSONValue[] = labels.toArray();
          token.labels = lbls.map<string>((data: JSONValue) => data.toString());        
        }
        token.save();
      }
    }
  }
}

'''
'''--- subgraphs/src/handlers/order.ts ---
import { near, JSONValue, json, ipfs, log } from "@graphprotocol/graph-ts";
import { Order, Token } from "../../generated/schema";

export function handleReceipt(receipt: near.ReceiptWithOutcome): void {
  const actions = receipt.receipt.actions;

  for (let i = 0; i < actions.length; i++) {
    handleAction(
      actions[i],
      receipt.receipt,
      receipt.block.header,
      receipt.outcome
    );
  }
}

function handleAction(
  action: near.ActionValue,
  receipt: near.ActionReceipt,
  blockHeader: near.BlockHeader,
  outcome: near.ExecutionOutcome
): void {
  if (action.kind != near.ActionKind.FUNCTION_CALL) {
    log.info("Early return: {}", ["Not a function call"]);
    return;
  }

  const functionCall = action.toFunctionCall();

  // change the methodName here to the methodName emitting the log in the contract
  if (functionCall.methodName == "create_order") {
    if (outcome.logs[0] != null) {
      // grab the event log and parse into an object
      const parsed = outcome.logs[0].toString().replace("EVENT_JSON:", "");
      log.info("outcomeLog {}", [parsed]);
      const jsonData = json.try_fromString(parsed);
      const jsonObject = jsonData.value.toObject();

      const eventData = jsonObject.get("data");
      if (eventData) {
        const eventArray: JSONValue[] = eventData.toArray();

        const data = eventArray[0].toObject();
        const status = data.get("status");
        let orderId = data.get("order_id");
        let tokenId = data.get("token_id");
        if (!orderId || !tokenId) return;

        let order = new Order(orderId.toString());
        if (order) {
          order.orderId = orderId.toString();
          order.tokenId = tokenId.toString();
          if (status) {
            order.status = status.toString();
          }
          let token = Token.load(tokenId.toString());
          if (token) {
            order.token = token;
          }
          
          order.save();
        }
      }
    }
  } if (functionCall.methodName == "accept_order") {

    if (outcome.logs[0] != null) {
      // grab the event log and parse into an object
      const parsed = outcome.logs[0].toString().replace("EVENT_JSON:", "");
      log.info("outcomeLog {}", [parsed]);
      const jsonData = json.try_fromString(parsed);
      const jsonObject = jsonData.value.toObject();

      const eventData = jsonObject.get("data");
      if (eventData) {
        const eventArray: JSONValue[] = eventData.toArray();

        const data = eventArray[0].toObject();
        const status = data.get("status");
        let orderId = data.get("order_id");
        let tokenId = data.get("token_id");
        if (!orderId || !tokenId) return;

        let order = Order.load(orderId.toString());
        if (order) {
          if (status) {
            order.status = status.toString();
          }
          order.save();
        } 
      }
    }
  }

  //   // Unique ID for item
  //   const receiptId = receipt.id.toHexString();
  //   let item = new Order(`${receiptId}`);

  //   item.signerId = receipt.signerId; // orig owner
  //   item.rootId = receiptId;
  //   item.status = "NEW";
  //   item.category = "uncategorized";
  //   item.labels = [];

  //   // Do I even care about anything else?

  //   // https://github.com/decentraland/marketplace/blob/master/indexer/src/modules/nft/index.ts

  // // if function call is update
  // // item.load( unHex)

  //   // Maps the JSON formatted log to the LOG entity
  //   // let logs = new Log(`${receiptId}`);
  //   // if (outcome.logs[0] != null) {
  //   //   logs.id = receipt.signerId;
  //   //   const parsed = outcome.logs[0].toString();

  //   //   log.info("outcomeLog {}", [parsed]);

  //   //   const jsonData = json.try_fromString(parsed);
  //   //   const jsonObject = jsonData.value.toObject();

  //   //   const eventData = jsonObject.get("EVENT_JSON");

  //   //   if (eventData) {
  //   //     const data = eventData.toObject();
  //   //     const tokenId = data.get("token_id");
  //   //     const receiverId = data.get("receiver_id");
  //   //     const status = data.get("status");

  //   //     if (status && status.toString() == "NEW") {
  //   //       item.status = status.toString();
  //   //       item.category = "uncategorized";
  //   //       item.labels = [];
  //   //     }

  //   //     if (tokenId) {
  //   //       logs.tokenId = tokenId.toString();
  //   //     }
  //   //     if (receiverId) {
  //   //       logs.receiverId = receiverId.toString();
  //   //     }
  //   //   }
  //   //   logs.save();

  //   //   item.log.push(logs.id);
  //   // } else {
  //   //   log.info("Not processed - FunctionCall is: {}", [
  //   //     functionCall.methodName,
  //   //   ]);
  //   // }

  //   item.save();
  // }
}

'''
'''--- tailwind.config.js ---
const colors = require('tailwindcss/colors')

module.exports = {
  content: ["./src/**/*.{html,js,jsx}"],
  theme: {},
  plugins: [
    require('@tailwindcss/forms')
  ],
}

'''