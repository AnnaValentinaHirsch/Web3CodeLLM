*GitHub Repository "Meowomen/NEARYou_contract"*

'''--- .travis.yml ---
language: rust

rust:
  - stable
  - nightly

jobs:
  include:
    - name: build and test
      script:
        - cargo build --release --all --verbose
        - cargo test --release --all --verbose
    
    - name: fossa
      before_script:
        - "curl -H 'Cache-Control: no-cache' https://raw.githubusercontent.com/fossas/fossa-cli/fc60c6631a5d372d5a45fea35e31665b338f260d/install.sh | sudo bash"
      script:
        - fossa init
        - fossa analyze --server-scan
        - fossa test

'''
'''--- Cargo.toml ---
[package]
name = "nearyou"
version = "0.1.0"
authors = ["Meowoman"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[dependencies]
near-sdk = "4.0.0-pre.1"

'''
'''--- README.md ---
# NEARYou Contract

## üóù Table of Contents
- [About NEARYou](https://github.com/Meowomen/NEARYou_contract#-about-nearyou)
- [Getting Started](https://github.com/Meowomen/NEARYou_contract#%EF%B8%8F-getting-started)
- [How NEARYou Contract Works](https://github.com/Meowomen/NEARYou_contract#-how-nearyou-contract-works)
  - [Features](https://github.com/Meowomen/NEARYou_contract#features)
  - [send()](https://github.com/Meowomen/NEARYou_contract#send)
  - [claim()](https://github.com/Meowomen/NEARYou_contract#claim)
  - [create_account_and_claim()](https://github.com/Meowomen/NEARYou_contract#create_account_and_claim)
- [Suggestions](https://github.com/Meowomen/NEARYou_contract#-suggestions)

## üîé About NEARYou

### For [2021 NEAR MetaBUIDL Hackathon](https://near.org/metabuidl)
NEARYou allows NEAR wallet users(sender) to create a link for gifting their NFTs(Non-Fungible-Token) which follow [NEP-171](https://github.com/near/NEPs/blob/ea409f07f8/specs/Standards/NonFungibleToken/Core.md) standard. The user's friends(receiver) can claim NFT through the link. NEARYou contract stores the sender's NFT ``token_id`` and minimum amount of NEAR to activate new account.

### Contributors
- [Juyeon Lee](https://github.com/kwklly) | Ewha Womans University
- [Seungwon Choi](https://github.com/seungwon2) | Ewha Womans University
- [Heesung Bae](https://github.com/HeesungB) | DSRV

## üèÉ‚Äç‚ôÄÔ∏è Getting Started

Clone this repository

```bash
git clone https://github.com/Meowomen/NEARYou_contract
cd NEARYou_contract
```

Compile Contract code

```bash
cargo build --target wasm32-unknown-unknown --release
```

Deploy Contract

```jsx
near deploy --wasmFile target/wasm32-unknown-unknown/release/nearyou.wasm --accountId YOUR_ACCOUNT_HERE
```
- Otherwise, you can skip the previous step(Compile) and deploy [``nearyou.wasm``](https://github.com/Meowomen/NEARYou_contract/blob/master/res/nearyou.wasm) directly.

Init Contract

```bash
near call YOUR_ACCOUNT new '{"nft_contract":"NFT_MINTED_CONTRACT"}' --accountId SIGNER_ACCOUNT
```
- ``NFT_MINTED_CONTRACT`` means an account that minted your NFT
- If you don't have NFT, you can deploy a minting contract [here](https://github.com/kwklly/NEP171_Factory).

After deploying, you can use NEARYou contract with your account id in the [demo page](https://github.com/Meowomen/NEARYou/blob/master/README.md#modify-configjs).

## üé® How NEARYou Contract Works

### Features

Sender, who owns NFT:

- Call `send` function to create new key pair and store sender's NFT `token_id` and balance.
- `send` function adds an access key to give NEARYou contract authority for moving sender's NFT.

Receiver, who doesn't have NEAR wallet account:

- Call `create_account_and_claim` function of contract with private key.
- `create_account_and_claim` function calls `create_account` and creates the sender's subaccount as a receiver's new account.
- `create_account_and_claim` function calls `nft_transfer` function of ``NFT_MINTED_CONTRACT``(account that minted NFT) to give sender's NFT to receiver.

Receiver, who has NEAR wallet account:

- Call `claim` function of contract with private key.
- `claim` function calls `nft_transfer` function of ``NFT_MINTED_CONTRACT`` to give sender's NFT to receiver.

- - - 

### **send()**

```rust
/// Map public_key with nft_id & balance to make a promise call.
#[payable]
    pub fn send(&mut self, public_key: PublicKey, nft_id: String) -> Promise {
        assert!(
            env::attached_deposit() > ACCESS_KEY_ALLOWANCE,
            "Attached deposit must be greater than ACCESS_KEY_ALLOWANCE"
        );

        let pk = public_key.into();
        let value = self.accounts.get(&pk).unwrap_or(0);

        self.nft_accounts.insert(&pk, &nft_id);
        self.accounts.insert(
            &pk,
            &(value + env::attached_deposit() - ACCESS_KEY_ALLOWANCE),
        );

        /// Add access key to the contract.
        Promise::new(env::current_account_id()).add_access_key(
            pk,
            ACCESS_KEY_ALLOWANCE,
            env::current_account_id(),
            (&"claim,create_account_and_claim").to_string(),
        )
    }
```

- Inserts [public key, nft_id] pair and [public key, amount] pair into the ``accounts``, ``nft_accounts`` respectively.
- Make promise and add an access key to NEARYou contract.

- - - 

### **claim()**

```rust
/// Claim NFT to existing account.
pub fn claim(&mut self, account_id: AccountId) -> Promise {
        assert_eq!(
            env::predecessor_account_id(),
            env::current_account_id(),
            "Claim only can come from this account"
        );
        assert!(
            env::is_valid_account_id(account_id.as_bytes()),
            "Invalid account id"
        );

        let nft_id = self
            .nft_accounts
            .remove(&env::signer_account_pk())
            .expect("Unexpected public key");

        Promise::new(env::current_account_id()).delete_key(env::signer_account_pk());
        Promise::new(self.nft_contract.clone()).function_call(
            (&"nft_transfer").to_string(),
            format!(
                "{{\"receiver_id\": \"{}\", \"token_id\": \"{}\"}}",
                account_id, nft_id
            )
            .into_bytes(),
            1,
            NFT_TRANSFER_GAS,
        )
    }
```

- Get `nft_id` from ``nft_accounts`` map.
- Call `nft_transfer()` from ``NFT_MINTED_CONTRACT``.

- - - 

### **create_account_and_claim()**

```rust
/// Create new account and and claim NFT to it.
pub fn create_account_and_claim(
        &mut self,
        new_account_id: AccountId,
        new_public_key: PublicKey,
    ) -> Promise {
        assert_eq!(
            env::predecessor_account_id(),
            env::current_account_id(),
            "Create account and claim only can come from this account"
        );
        assert!(
            env::is_valid_account_id(new_account_id.as_bytes()),
            "Invalid account id"
        );

        let nft_id = self
            .nft_accounts
            .remove(&env::signer_account_pk())
            .expect("Unexpected public key");
        let amount = self
            .accounts
            .remove(&env::signer_account_pk())
            .expect("Unexpected public key");

        /// Modify new_account_id from wallet to create subAccount of the sender.
        let nft_contract = format!(".{}", &env::current_account_id());
        let new_new_account_id = new_account_id
            .clone()
            .to_string()
            .replace(".testnet", &nft_contract);

        /// Create subAccount of the sender.
        Promise::new(AccountId::new_unchecked(new_new_account_id.clone()))
            .create_account()
            .add_full_access_key(new_public_key.into())
            .transfer(amount);
        Promise::new(self.nft_contract.clone())
            .function_call(
                (&"nft_transfer").to_string(),
                format!(
                    "{{\"receiver_id\": \"{}\", \"token_id\": \"{}\"}}",
                    new_new_account_id, nft_id
                )
                .into_bytes(),
                1,
                NFT_TRANSFER_GAS,
            )
            .then(ext_self::on_account_created_and_claimed(
                nft_id,
                env::current_account_id(),
                NO_DEPOSIT,
                ON_CREATE_ACCOUNT_CALLBACK_GAS,
            ))
    }

```

- Get `amount` and `nft_id` from map.
- Create sub account(`new_new_account`) of sender's account.
- Call `nft_transfer()` from ``NFT_MINTED_CONTRACT``.

## üßë‚Äçüíª Suggestions

- Update [``createNewAccount``](https://github.com/near/near-wallet/blob/b98294ed8125ca63b6123f56195cc6d35995df37/packages/frontend/src/utils/wallet.js#L409) function in NEAR wallet

``fundingContract`` and ``fundingAccount`` must be included in the drop-link to receive NFT at the same time as account creation through the official wallet. However, if both exist, wallet call the function ``createNewAccountLinkdrop``, which [calls the ``create_account_and_claim``](https://github.com/near/near-wallet/blob/b98294ed8125ca63b6123f56195cc6d35995df37/packages/frontend/src/utils/wallet.js#L489) in the ``fundingContract``. For NEARYou contract to work in the official wallet, both the function name and the number of factors had to be the same. However, we needed the id of the ``NFT_MINTED_CONTRACT`` in ``create_account_and_claim`` [to transfer nft](https://github.com/Meowomen/NEARYou_contract/blob/master/src/lib.rs#L155), so we declared it a global variable through the init function because it shouldn't be hard-coded for scalability. If NEAR wallet flexibly handles account creation with ``fundingAccounts`` and ``fundingContracts``, init function will not be necessary.

- Support `subaccount creation` in NEAR wallet

This proposal begins with what we did not realize about the signer of the cross-contract call. When calling ``create_account`` of the ``testnet``(official contract) within the NEARYou contract, the top-level-account will be made normally because ``testnet`` signs it, but if ``NEARYou`` signs, only subAccount can be made. We realized this late, so we made subAccount using [a little trick](https://github.com/Meowomen/NEARYou_contract/blob/master/src/lib.rs#L144) because of the naming rules. We will, of course, update the contract later, but adding ``subaccount creation`` feature in official wallet can make NEAR users easily attract others through their own contract so that expand the NEAR ecosystem.

'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/linkdrop.wasm ./res/

'''
'''--- src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, Balance, BorshStorageKey, Gas, PanicOnDefault,
    Promise, PromiseResult, PublicKey,
};

#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct NearYou {
    pub nft_contract: AccountId,
    pub accounts: LookupMap<PublicKey, Balance>,
    pub nft_accounts: LookupMap<PublicKey, String>,
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Accounts,
    NftAccounts,
}

/// Access key allowance for linkdrop keys.
pub const ACCESS_KEY_ALLOWANCE: u128 = 1_000_000_000_000_000_000_000_000;

/// Gas attached to the functionCall.
pub const ON_CREATE_ACCOUNT_CALLBACK_GAS: Gas = Gas(20_000_000_000_000);
pub const NFT_TRANSFER_GAS: Gas = Gas(20_000_000_000_000);

/// Indicates there are no deposit for a callback for better readability.
pub const NO_DEPOSIT: u128 = 0;

#[ext_contract(ext_self)]
pub trait ExtLinkDrop {
    /// Callback after creating account and claiming linkdrop.
    fn on_account_created_and_claimed(&mut self, nft_id: String) -> bool;
}

fn is_promise_success() -> bool {
    assert_eq!(
        env::promise_results_count(),
        1,
        "Contract expected a result on the callback"
    );
    match env::promise_result(0) {
        PromiseResult::Successful(_) => true,
        _ => false,
    }
}

#[near_bindgen]
impl NearYou {
    /// Initialize contract with an account that minted NFT.
    #[init]
    pub fn new(nft_contract: AccountId) -> Self {
        Self {
            nft_contract,
            accounts: LookupMap::new(StorageKey::Accounts),
            nft_accounts: LookupMap::new(StorageKey::NftAccounts),
        }
    }

    /// Map public_key with nft_id & balance to make a promise call.
    #[payable]
    pub fn send(&mut self, public_key: PublicKey, nft_id: String) -> Promise {
        assert!(
            env::attached_deposit() > ACCESS_KEY_ALLOWANCE,
            "Attached deposit must be greater than ACCESS_KEY_ALLOWANCE"
        );

        let pk = public_key.into();
        let value = self.accounts.get(&pk).unwrap_or(0);

        self.nft_accounts.insert(&pk, &nft_id);
        self.accounts.insert(
            &pk,
            &(value + env::attached_deposit() - ACCESS_KEY_ALLOWANCE),
        );

        /// Add access key to the contract.
        Promise::new(env::current_account_id()).add_access_key(
            pk,
            ACCESS_KEY_ALLOWANCE,
            env::current_account_id(),
            (&"claim,create_account_and_claim").to_string(),
        )
    }

    /// Claim NFT to existing account.
    pub fn claim(&mut self, account_id: AccountId) -> Promise {
        assert_eq!(
            env::predecessor_account_id(),
            env::current_account_id(),
            "Claim only can come from this account"
        );
        assert!(
            env::is_valid_account_id(account_id.as_bytes()),
            "Invalid account id"
        );

        let nft_id = self
            .nft_accounts
            .remove(&env::signer_account_pk())
            .expect("Unexpected public key");

        Promise::new(env::current_account_id()).delete_key(env::signer_account_pk());
        Promise::new(self.nft_contract.clone()).function_call(
            (&"nft_transfer").to_string(),
            format!(
                "{{\"receiver_id\": \"{}\", \"token_id\": \"{}\"}}",
                account_id, nft_id
            )
            .into_bytes(),
            1,
            NFT_TRANSFER_GAS,
        )
    }

    /// Create new account and and claim NFT to it.
    pub fn create_account_and_claim(
        &mut self,
        new_account_id: AccountId,
        new_public_key: PublicKey,
    ) -> Promise {
        assert_eq!(
            env::predecessor_account_id(),
            env::current_account_id(),
            "Create account and claim only can come from this account"
        );
        assert!(
            env::is_valid_account_id(new_account_id.as_bytes()),
            "Invalid account id"
        );

        let nft_id = self
            .nft_accounts
            .remove(&env::signer_account_pk())
            .expect("Unexpected public key");
        let amount = self
            .accounts
            .remove(&env::signer_account_pk())
            .expect("Unexpected public key");

        /// Modify new_account_id from wallet to create subAccount of the sender.
        let nft_contract = format!(".{}", &env::current_account_id());
        let new_new_account_id = new_account_id
            .clone()
            .to_string()
            .replace(".testnet", &nft_contract);

        /// Create subAccount of the sender.
        Promise::new(AccountId::new_unchecked(new_new_account_id.clone()))
            .create_account()
            .add_full_access_key(new_public_key.into())
            .transfer(amount);
        Promise::new(self.nft_contract.clone())
            .function_call(
                (&"nft_transfer").to_string(),
                format!(
                    "{{\"receiver_id\": \"{}\", \"token_id\": \"{}\"}}",
                    new_new_account_id, nft_id
                )
                .into_bytes(),
                1,
                NFT_TRANSFER_GAS,
            )
            .then(ext_self::on_account_created_and_claimed(
                nft_id,
                env::current_account_id(),
                NO_DEPOSIT,
                ON_CREATE_ACCOUNT_CALLBACK_GAS,
            ))
    }

    /// Callback after execution `create_account_and_claim`.
    pub fn on_account_created_and_claimed(&mut self, nft_id: String) -> bool {
        assert_eq!(
            env::predecessor_account_id(),
            env::current_account_id(),
            "Callback can only be called from the contract"
        );

        let creation_succeeded = is_promise_success();
        if creation_succeeded {
            Promise::new(env::current_account_id()).delete_key(env::signer_account_pk());
        } else {
            // In case of failure, put the amount back.
            self.nft_accounts.insert(&env::signer_account_pk(), &nft_id);
        }
        creation_succeeded
    }

    /// Returns the nft_id associated with given key.
    pub fn get_key_balance(&self, key: PublicKey) -> String {
        self.nft_accounts
            .get(&key.into())
            .expect("Key is missing")
            .into()
    }
}

'''