*GitHub Repository "NEARFT/API"*

'''--- .eslintrc.yml ---
env:
  es6: true
  node: true
extends:
  - 'eslint:recommended'
parserOptions:
  ecmaVersion: 2018
rules:
  indent:
    - error
    - 4
  linebreak-style:
    - error
    - unix
  quotes:
    - error
    - single
  semi:
    - error
    - always
  no-console: off
globals:
  window: true
  fetch: true
  Headers: true
  document: true

'''
'''--- .github/ISSUE_TEMPLATE/bug_report.md ---
---
name: Bug report
about: Create a report to help us improve
title: ''
labels: 'bug'
assignees: ''

---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Desktop (please complete the following information):**
 - OS: [e.g. MacOS]
 - Version [e.g. 22]

**Additional context**
Add any other context about the problem here.

'''
'''--- .github/ISSUE_TEMPLATE/feature_request.md ---
---
name: Feature request
about: Suggest an idea for this project
title: ''
labels: 'enchancement'
assignees: ''

---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.

'''
'''--- .github/dependabot.yml ---
version: 2
updates:
- package-ecosystem: npm
  directory: "/"
  schedule:
    interval: daily
  open-pull-requests-limit: 10
  ignore:
  - dependency-name: typescript
    versions:
    - 4.0.5
    - 4.0.6
    - 4.0.7
    - 4.2.3
    - 4.2.4
  - dependency-name: browserify
    versions:
    - 17.0.0
  - dependency-name: semver
    versions:
    - 7.3.5
  - dependency-name: ts-morph
    versions:
    - 10.0.1
    - 10.0.2
    - 9.1.0
  - dependency-name: mustache
    versions:
    - 4.2.0
  - dependency-name: typedoc
    versions:
    - 0.20.19
    - 0.20.20
    - 0.20.23
    - 0.20.24
    - 0.20.25
    - 0.20.27
    - 0.20.28
    - 0.20.29
    - 0.20.30
    - 0.20.32
    - 0.20.33
    - 0.20.34
  - dependency-name: highlight.js
    versions:
    - 10.4.1
    - 10.6.0
  - dependency-name: node-notifier
    versions:
    - 8.0.1

'''
'''--- .github/workflows/docs.yml ---
# This workflow builds the docs and deploys them to GitHub Pages on every commit to the master branch
# For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions

name: Build & Deploy Docs

on:
  push:
    branches: [ master ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - uses: actions/setup-node@v1
      with:
        node-version: '12.x'
    - run: yarn install --frozen-lockfile
    - uses: sterlingwes/gh-pages-deploy-action@v1.1
      with:
        access-token: ${{ secrets.ACCESS_TOKEN }}
        source-directory: docs
        build-command: yarn doc

'''
'''--- .github/workflows/stale.yml ---
name: 'Close stale issues and PRs'
on:
  schedule:
    - cron: '30 1 * * *'

jobs:
  stale:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/stale@v3
        with:
          stale-pr-message: 'This PR is stale because it has been open for 7 days with no activity. Remove stale label or comment or this will be closed in another 7 days.'
          days-before-pr-stale: 7
          days-before-pr-close: 7

'''
'''--- .gitpod.yml ---
tasks:
  - init: yarn install && yarn run build
    command: yarn run dev
github:
  prebuilds:
    addCheck: true
    addComment: true

'''
'''--- .travis.yml ---
language: node_js

node_js: 10

env:
  - NODE_ENV=ci
  - NODE_ENV=ci-betanet
    #  - NODE_ENV=betanet

cache: yarn

jobs:
  include:
    - name: yarn
      script:
      - yarn lint
      - yarn test
      - yarn browserify && yarn run bundlewatch

    - name: fossa     
      before_script:
        - "curl -H 'Cache-Control: no-cache' https://raw.githubusercontent.com/fossas/fossa-cli/fc60c6631a5d372d5a45fea35e31665b338f260d/install.sh | sudo bash"
      script:
        - fossa init
        - fossa analyze --server-scan
        - fossa test
    - name: danger
      script:
        - yarn danger ci

'''
'''--- CODE_OF_CONDUCT.md ---
# Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, sex characteristics, gender identity and expression,
level of experience, education, socio-economic status, nationality, personal
appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment
include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or
 advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic
 address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a
 professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting the project team at social@nearprotocol.com. All
complaints will be reviewed and investigated and will result in a response that
is deemed necessary and appropriate to the circumstances. The project team is
obligated to maintain confidentiality with regard to the reporter of an incident.
Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good
faith may face temporary or permanent repercussions as determined by other
members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see
https://www.contributor-covenant.org/faq

'''
'''--- CONTRIBUTING.md ---
# Contributing to NEAR

NEAR welcomes help in many forms including development, code review, documentation improvements, and outreach.
Please visit [the contribution overview](https://docs.nearprotocol.com/docs/contribution/contribution-overview) for more information.

## Using Github issues and pull requests

Some repositories have specific issue templates that will be helpful for maintainers and community contributors. Please use the templates whenever available.

Please include steps to reproduction, if reporting an error. Information on all applicable versions is quite helpful. Some versions can be found using the command line. (For example: `node --version` or `rustc --version`.) Other version information may be packaged as dependencies. (For example: in `package.json` or `Cargo.toml`.)

If there are verbosity flags available, please include those to offer as much information as possible.

When opening a pull request, please use the typical open-source flow of forking the desired repository and opening a pull request from your forked repository. (More information on [technical contributions here](https://docs.nearprotocol.com/docs/contribution/technical-contribution).)

## Testing

Please note that for technical contributions, NEAR runs a battery of continuous integration tools and tests for each pull request.

It's encouraged to write unit tests on new features. Many NEAR repositories have built-in scripts that run tests locally. Tests may check linting and must be addressed.

For this repository, please follow testing directions outlined in the `README.md` file.

### Thank you

NEAR values all contributors to the projects in the ecosystem and invites public discussion on the tech and vision. Please feel free to join the conversation using the links offered at [near.help](https://near.help).

'''
'''--- README.md ---
# near-api-js

[![Build Status](https://travis-ci.com/near/near-api-js.svg?branch=master)](https://travis-ci.com/near/near-api-js)
[![Gitpod Ready-to-Code](https://img.shields.io/badge/Gitpod-Ready--to--Code-blue?logo=gitpod)](https://gitpod.io/#https://github.com/near/near-api-js) 

A JavaScript/TypeScript library for development of DApps on the NEAR platform

# Documentation

[Read the TypeDoc API documentation](https://near.github.io/near-api-js/)

---

# Examples

## [Quick Reference](https://github.com/near/near-api-js/blob/master/examples/quick-reference.md)
_(Cheat sheet / quick reference)_

## [Cookbook](https://github.com/near/near-api-js/blob/master/examples/cookbook/README.md)
_(Common use cases / more complex examples)_

---

# Contribute to this library

1. Install dependencies

       yarn

2. Run continuous build with:

       yarn build -- -w

# Publish

Prepare `dist` version by running:

    yarn dist

When publishing to npm use [np](https://github.com/sindresorhus/np).

---

# Integration Test

Start the node by following instructions from [nearcore](https://github.com/nearprotocol/nearcore), then

    yarn test

Tests use sample contract from `near-hello` npm package, see https://github.com/nearprotocol/near-hello

# Update error schema

Follow next steps:

1. [Change hash for the commit with errors in the nearcore](https://github.com/near/near-api-js/blob/master/gen_error_types.js#L7-L9)
2. Fetch new schema: `node fetch_error_schema.js`
3. `yarn build` to update `lib/**.js` files

# License

This repository is distributed under the terms of both the MIT license and the Apache License (Version 2.0).
See [LICENSE](LICENSE) and [LICENSE-APACHE](LICENSE-APACHE) for details.

'''
'''--- browser-exports.js ---
window.nearApi = require('./lib/browser-index');
window.Buffer = Buffer;

'''
'''--- dangerfile.ts ---
import { schedule, danger } from 'danger';
import {
    checkForRelease,
    checkForNewDependencies,
    checkForLockfileDiff,
    checkForTypesInDeps
} from 'danger-plugin-yarn';

schedule(async () => {
    const packageDiff = await danger.git.JSONDiffForFile("package.json")
    checkForRelease(packageDiff)
    checkForNewDependencies(packageDiff)
    checkForLockfileDiff(packageDiff)
    checkForTypesInDeps(packageDiff)
  })
'''
'''--- examples/cookbook/README.md ---
# NEAR-API-JS Cookbook

> Collection of common use cases for [`near-api-js`](https://github.com/near/near-api-js).

---

## Overview

| Name                                                          | Description                                                                                                      |
| ------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- |
| **ACCOUNTS**                                                  |                                                                                                                  |
| [Create Account](./accounts/create-testnet-account.js)        | Create [NEAR accounts](https://docs.near.org/docs/concepts/account) without using NEAR Wallet.                   |
| [Access Key Rotation](./accounts/access-keys/README.md)       | Create and delete [access keys](https://docs.near.org/docs/concepts/account#access-keys) for added security.     |
| **TRANSACTIONS**                                              |                                                                                                                  |
| [Get Transaction Status](./transactions/get-tx-status.js)     | Gets transaction status using a tx hash and associated account/contract ID.                                      |
| [Recent Transaction Details](./transactions/get-tx-detail.js) | Get recent transaction details without using an [indexing](https://docs.near.org/docs/concepts/indexer) service. |
| [Batch Transactions](./transactions/batch-transactions.js)    | Sign and send multiple [transactions](https://docs.near.org/docs/concepts/transaction).                          |
| **UTILS**                                                     |                                                                                                                  |
| [Deploy Contract](./utils/deploy-contract.js)                 | Deploys a contract using a pre-compiled .wasm file                                                               |
| [Calculate Gas](./utils/calculate-gas.js)                     | Calculate [gas burnt](https://docs.near.org/docs/concepts/gas) from any contract call.                           |
| [Read State w/o Account](./utils/get-state.js)                | Read state of a contract without instantiating an account.                                                       |

---

## Requirements

-   [NEAR Account](https://docs.near.org/docs/develop/basics/create-account)
-   [Node.js](https://nodejs.org/en/download/package-manager/)
-   [npm](https://www.npmjs.com/get-npm) or [Yarn](https://yarnpkg.com/getting-started/install)

---

## Setup

1. Navigate to the root directory

```bash
cd ../..
```

2. Install dependencies

```bash
npm install
```

3. Navigate back to the cookbook directory

```bash
cd examples/cookbook
```

4. Run Commands

Example:

```bash
node utils/get-state
```

'''
'''--- examples/cookbook/accounts/access-keys/README.md ---
# Access Key Rotation

> When rotating access keys be sure to follow these three steps in order.

1) Create new [full access key](./create-full-access-key.js) or [function access key](./create-function-access-key.js).
2) Confirm key creation 
3) [Delete old access key](./delete-access-key.js)
'''
'''--- examples/cookbook/accounts/access-keys/create-full-access-key.js ---
const { KeyPair, keyStores, connect } = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
const ACCOUNT_ID = "example.testnet";
const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
  keyStore,
  networkId: "testnet",
  nodeUrl: "https://rpc.testnet.near.org",
};

createFullAccessKey(ACCOUNT_ID);

async function createFullAccessKey(accountId) {
  const keyPair = KeyPair.fromRandom("ed25519");
  const publicKey = keyPair.publicKey.toString();
  const near = await connect(config);
  const account = await near.account(accountId);
  await keyStore.setKey(config.networkId, publicKey, keyPair);
  await account.addKey(publicKey);
}

'''
'''--- examples/cookbook/accounts/access-keys/create-function-access-key.js ---
const { KeyPair, keyStores, connect } = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
const ACCOUNT_ID = "example.testnet";
const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
  keyStore,
  networkId: "testnet",
  nodeUrl: "https://rpc.testnet.near.org",
};

addFunctionAccessKey(ACCOUNT_ID);

async function addFunctionAccessKey(accountId) {
  const keyPair = KeyPair.fromRandom("ed25519");
  const publicKey = keyPair.publicKey.toString();
  const near = await connect(config);
  const account = await near.account(accountId);
  await keyStore.setKey(config.networkId, publicKey, keyPair);
  await account.addKey(
    publicKey,                   // public key for new account
    "example-account.testnet",   // contract this key is allowed to call (optional)
    "example_method",            // methods this key is allowed to call (optional)
    "2500000000000"              // allowance key can use to call methods (optional)
  );
}

'''
'''--- examples/cookbook/accounts/access-keys/delete-access-key.js ---
const { keyStores, connect } = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
// NOTE: replace "example.testnet" with your accountId
const ACCOUNT_ID = "example.testnet";
// NOTE: replace this PK with the one that you are trying to delete
const PUBLIC_KEY = "ed25519:4yLYjwC3Rd8EkhKwVPoAdy6EUcCVSz2ZixFtsCeuBEZD";
const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
    keyStore,
    networkId: "testnet",
    nodeUrl: "https://rpc.testnet.near.org",
};

deleteAccessKey(ACCOUNT_ID, PUBLIC_KEY);

async function deleteAccessKey(accountId, publicKey) {
    const near = await connect(config);
    const account = await near.account(accountId);
    await account.deleteKey(publicKey);
}

'''
'''--- examples/cookbook/accounts/create-mainnet-account.js ---
const HELP = `Please run this script in the following format:

  node create-mainnet-account.js CREATOR_ACCOUNT.near NEW_ACCOUNT.near AMOUNT"
`;

const { connect, KeyPair, keyStores, utils } = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
  keyStore,
  networkId: "mainnet",
  nodeUrl: "https://rpc.mainnet.near.org",
};

if (process.argv.length !== 5) {
  console.info(HELP);
  process.exit(1);
}

createAccount(process.argv[2], process.argv[3], process.argv[4]);

async function createAccount(creatorAccountId, newAccountId, amount) {
  const near = await connect(config);
  const creatorAccount = await near.account(creatorAccountId);
  const keyPair = KeyPair.fromRandom("ed25519");
  const publicKey = keyPair.publicKey.toString();
  await keyStore.setKey(config.networkId, newAccountId, keyPair);

  return await creatorAccount.functionCall({
    contractId: "near",
    methodName: "create_account",
    args: {
      new_account_id: newAccountId,
      new_public_key: publicKey,
    },
    gas: "300000000000000",
    attachedDeposit: utils.format.parseNearAmount(amount),
  });
}

'''
'''--- examples/cookbook/accounts/create-testnet-account.js ---
const HELP = `Please run this script in the following format:

    node create-testnet-account.js CREATOR_ACCOUNT.testnet NEW_ACCOUNT.testnet AMOUNT
`;

const { connect, KeyPair, keyStores, utils } = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
  keyStore,
  networkId: "testnet",
  nodeUrl: "https://rpc.testnet.near.org",
};

if (process.argv.length !== 5) {
  console.info(HELP);
  process.exit(1);
}

createAccount(process.argv[2], process.argv[3], process.argv[4]);

async function createAccount(creatorAccountId, newAccountId, amount) {
  const near = await connect({ ...config, keyStore });
  const creatorAccount = await near.account(creatorAccountId);
  const keyPair = KeyPair.fromRandom("ed25519");
  const publicKey = keyPair.publicKey.toString();
  await keyStore.setKey(config.networkId, newAccountId, keyPair);

  return await creatorAccount.functionCall({
    contractId: "testnet",
    methodName: "create_account",
    args: {
      new_account_id: newAccountId,
      new_public_key: publicKey,
    },
    gas: "300000000000000",
    attachedDeposit: utils.format.parseNearAmount(amount),
  });
}

'''
'''--- examples/cookbook/package.json ---
{
  "name": "cookbook",
  "version": "1.0.0",
  "description": "",
  "main": "main.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "chalk": "^4.1.1",
    "homedir": "^0.6.0",
    "near-api-js": "file:../../lib/index.js"
  }
}
'''
'''--- examples/cookbook/transactions/batch-transactions.js ---
const { connect, transactions, keyStores } = require("near-api-js");
const fs = require("fs");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
// NOTE: replace "example" with your accountId
const CONTRACT_NAME = "contract.example.testnet";
const WHITELIST_ACCOUNT_ID = "whitelisted-account.example.testnet";
const WASM_PATH = path.join(__dirname, "../utils/wasm-files/staking_pool_factory.wasm");

const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
    keyStore,
    networkId: "testnet",
    nodeUrl: "https://rpc.testnet.near.org",
};

sendTransactions();

async function sendTransactions() {
    const near = await connect({ ...config, keyStore });
    const account = await near.account(CONTRACT_NAME);
    const newArgs = { staking_pool_whitelist_account_id: WHITELIST_ACCOUNT_ID };
    const result = await account.signAndSendTransaction({
        receiverId: CONTRACT_NAME,
        actions: [
            transactions.deployContract(fs.readFileSync(WASM_PATH)),
            transactions.functionCall(
                "new",
                Buffer.from(JSON.stringify(newArgs)),
                10000000000000,
                "0"
            ),
        ],
    });

    console.log(result);
}

'''
'''--- examples/cookbook/transactions/get-tx-detail.js ---
const { connect, keyStores } = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
// block hash of query start (oldest block)
const START_BLOCK_HASH = "GZ8vKdcgsavkEndkDWHCjuhyqSR2TGnp9VDZbTzd6ufG";
// block hash of query end (newest block)
const END_BLOCK_HASH = "8aEcKhF7N1Jyw84e6vHW6Hzp3Ep7mSXJ6Rvnsy5qGJPF";
// contract ID or account ID you want to find transactions details for
const CONTRACT_ID = "relayer.ropsten.testnet";

const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

// NOTE: we're using the archival rpc to look back in time for a specific set
// of transactions. For a full list of what nodes are available, visit:
// https://docs.near.org/docs/develop/node/intro/types-of-node
const config = {
  keyStore,
  networkId: "testnet",
  nodeUrl: "https://archival-rpc.testnet.near.org",
};

getTransactions(START_BLOCK_HASH, END_BLOCK_HASH, CONTRACT_ID);

async function getTransactions(startBlock, endBlock, accountId) {
  const near = await connect(config);

  // creates an array of block hashes for given range
  const blockArr = [];
  let blockHash = endBlock;
  do {
    const currentBlock = await getBlockByID(blockHash);
    blockArr.push(currentBlock.header.hash);
    blockHash = currentBlock.header.prev_hash;
    console.log("working...", blockHash);
  } while (blockHash !== startBlock);

  // returns block details based on hashes in array
  const blockDetails = await Promise.all(
    blockArr.map((blockId) =>
      near.connection.provider.block({
        blockId,
      })
    )
  );

  // returns an array of chunk hashes from block details
  const chunkHashArr = blockDetails.flatMap((block) =>
    block.chunks.map(({ chunk_hash }) => chunk_hash)
  );

  //returns chunk details based from the array of hashes
  const chunkDetails = await Promise.all(
    chunkHashArr.map(chunk => near.connection.provider.chunk(chunk))
  );

  // checks chunk details for transactions
  // if there are transactions in the chunk we
  // find ones associated with passed accountId
  const transactions = chunkDetails.flatMap((chunk) =>
    (chunk.transactions || []).filter((tx) => tx.signer_id === accountId)
  );

  //creates transaction links from matchingTxs
  const txsLinks = transactions.map((txs) => ({
    method: txs.actions[0].FunctionCall.method_name,
    link: `https://explorer.testnet.near.org/transactions/${txs.hash}`,
  }));
  console.log("MATCHING TRANSACTIONS: ", transactions);
  console.log("TRANSACTION LINKS: ", txsLinks);
}

async function getBlockByID(blockID) {
  const near = await connect(config);
  const blockInfoByHeight = await near.connection.provider.block({
    blockId: blockID,
  });
  return blockInfoByHeight;
}

'''
'''--- examples/cookbook/transactions/get-tx-status.js ---
// demonstrates how to get a transaction status
const { providers } = require("near-api-js");

//network config (replace testnet with mainnet or betanet)
const provider = new providers.JsonRpcProvider(
    "https://archival-rpc.testnet.near.org"
);

const TX_HASH = "9av2U6cova7LZPA9NPij6CTUrpBbgPG6LKVkyhcCqtk3";
// account ID associated with the transaction
const ACCOUNT_ID = "sender.testnet";

getState(TX_HASH, ACCOUNT_ID);

async function getState(txHash, accountId) {
    const result = await provider.txStatus(txHash, accountId);
    console.log("Result: ", result);
}

'''
'''--- examples/cookbook/utils/calculate-gas.js ---
const { connect, keyStores, utils } = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();
const chalk = require("chalk");

const CREDENTIALS_DIR = ".near-credentials";
const ACCOUNT_ID = "near-example.testnet";
const CONTRACT_ID = "guest-book.testnet";
const METHOD_NAME = "addMessage";
const MAX_GAS = "300000000000000";
const ATTACHED_DEPOSIT = "0";

const args = {
  text: "Howdy!",
};

const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
  keyStore,
  networkId: "testnet",
  nodeUrl: "https://rpc.testnet.near.org",
};

calculateGas(CONTRACT_ID, METHOD_NAME, args, ATTACHED_DEPOSIT);

async function calculateGas(contractId, methodName, args, depositAmount) {
  const near = await connect(config);
  const account = await near.account(ACCOUNT_ID);
  const result = await account.functionCall({
    contractId,
    methodName,
    args,
    gas: MAX_GAS,
    attachedDeposit: utils.format.parseNearAmount(depositAmount),
  });
  const { totalGasBurned, totalTokensBurned } = result.receipts_outcome.reduce(
    (acc, receipt) => {
      acc.totalGasBurned += receipt.outcome.gas_burnt;
      acc.totalTokensBurned += utils.format.formatNearAmount(
        receipt.outcome.tokens_burnt
      );
      return acc;
    },
    {
      totalGasBurned: result.transaction_outcome.outcome.gas_burnt,
      totalTokensBurned: utils.format.formatNearAmount(
        result.transaction_outcome.outcome.tokens_burnt
      ),
    }
  );

  console.log(chalk`{white ------------------------------------------------------------------------ }`)
  console.log(chalk`{bold.green RESULTS} {white for: [ {bold.blue ${METHOD_NAME}} ] called on contract: [ {bold.blue ${CONTRACT_ID}} ]}` )
  console.log(chalk`{white ------------------------------------------------------------------------ }`)
  console.log(chalk`{bold.white Gas Burnt}     {white |}  {bold.yellow ${totalGasBurned}}`);
  console.log(chalk`{bold.white Tokens Burnt}  {white |}  {bold.yellow ${totalTokensBurned}}`);
  console.log(chalk`{white ------------------------------------------------------------------------ }`)

  return {
    totalTokensBurned,
    totalGasBurned,
  };
}

'''
'''--- examples/cookbook/utils/deploy-contract.js ---
const { keyStores, connect } = require("near-api-js");
const fs = require("fs");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
const ACCOUNT_ID = "near-example.testnet";
const WASM_PATH = path.join(__dirname, "/wasm-files/status_message.wasm");
const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
    keyStore,
    networkId: "testnet",
    nodeUrl: "https://rpc.testnet.near.org",
};

deployContract(ACCOUNT_ID, WASM_PATH);

async function deployContract(accountId, wasmPath) { 
    const near = await connect(config);
    const account = await near.account(accountId);
    const result = await account.deployContract(fs.readFileSync(wasmPath));
    console.log(result);
}

'''
'''--- examples/cookbook/utils/get-state.js ---
// demonstrates how to query the state without setting 
// up an account. (View methods only)
const { providers } = require("near-api-js");
//network config (replace testnet with mainnet or betanet)
const provider = new providers.JsonRpcProvider(
  "https://rpc.testnet.near.org"
);

getState();

async function getState() {
  const rawResult = await provider.query({
    request_type: "call_function",
    account_id: "guest-book.testnet",
    method_name: "getMessages",
    args_base64: "e30=",
    finality: "optimistic",
  });

  // format result
  const res = JSON.parse(Buffer.from(rawResult.result).toString());
  console.log(res);
}

'''
'''--- examples/cookbook/utils/unwrap-near.js ---
const { connect, keyStores, transactions, utils } = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();

const WRAP_NEAR_CONTRACT_ID = "wrap.near";

const credentialsPath = path.join(homedir, ".near-credentials");
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
  keyStore,
  networkId: "mainnet",
  nodeUrl: "https://rpc.mainnet.near.org",
};

// Unwrap 1 wNEAR to NEAR
unwrapNear("example.near", "1");

async function unwrapNear(accountId, unwrapAmount) {
    const near = await connect(config);
    const account = await near.account(accountId);
  
    return account.functionCall({
      contractId: WRAP_NEAR_CONTRACT_ID,
      methodName: "near_withdraw", // method to withdraw wNEAR for NEAR
      args: { amount: utils.format.parseNearAmount(unwrapAmount) },
      attachedDeposit: "1", // attach one yoctoNEAR
    });
  }
'''
'''--- examples/cookbook/utils/verify-signature.js ---
const { keyStores } = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();

const ACCOUNT_ID = "near-example.testnet";
const CREDENTIALS_DIR = ".near-credentials";

const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
    keyStore,
    networkId: "testnet",
    nodeUrl: "https://rpc.testnet.near.org",
};

verifySignature();

async function verifySignature() {
    const keyPair = await keyStore.getKey(config.networkId, ACCOUNT_ID);
    const msg = Buffer.from("hi");

    const { signature } = keyPair.sign(msg);

    const isValid = keyPair.verify(msg, signature);

    console.log("Signature Valid?:", isValid);

    return isValid;
}

'''
'''--- examples/cookbook/utils/wrap-near.js ---
const HELP = `To convert N $NEAR to wNEAR,  run this script in the following format:

    node wrap-near.js YOU.near N

Note: runs on mainnet!`;

const { connect, keyStores, transactions, utils } = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();

const WRAP_NEAR_CONTRACT_ID = "wrap.near";

const credentialsPath = path.join(homedir, ".near-credentials");
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
  keyStore,
  networkId: "mainnet",
  nodeUrl: "https://rpc.mainnet.near.org",
};

if (process.argv.length !== 4) {
  console.info(HELP);
  process.exit(1);
}

wrapNear(process.argv[2], process.argv[3]);

async function wrapNear(accountId, wrapAmount) {
  const near = await connect(config);
  const account = await near.account(accountId);

  const actions = [
    transactions.functionCall(
      "near_deposit", // contract method to deposit NEAR for wNEAR
      {},
      30000000000000, // attached gas
      utils.format.parseNearAmount(wrapAmount) // amount of NEAR to deposit and wrap
    ),
  ];

  // check if storage has been paid (the account has a wNEAR account)
  const storage = await account.viewFunction(
    WRAP_NEAR_CONTRACT_ID,
    "storage_balance_of",
    { account_id: accountId }
  );

  // if storage hasn't been paid, pay for storage (create an account)
  if (!storage) {
    actions.unshift(
      transactions.functionCall(
        "storage_deposit", // method to create an account
        {},
        30000000000000, // attached gas
        utils.format.parseNearAmount('0.00125') // account creation costs 0.00125 NEAR for storage
      )
    );
  }

  // send batched transaction
  return account.signAndSendTransaction({
    receiverId: WRAP_NEAR_CONTRACT_ID,
    actions,
  });
}

'''
'''--- examples/quick-reference.md ---
# Quick Reference / Cheat Sheet

> Here is a collection of the most commonly used methods within [`near-api-js`](https://github.com/near/near-api-js/). For more in-depth look into this library, please reference the [TypeDocs](https://near.github.io/near-api-js/).

## Setup

### Install

```bash
npm i near-api-js
```

### Import

Browser:

```js
import * as nearAPI from "near-api-js";
```

Node:

```js
const nearAPI = require("near-api-js");
```

### Key Store

Browser:

```js
// creates keyStore using private key in local storage
// *** REQUIRES SignIn using walletConnection.requestSignIn() ***

const { keyStores } = nearAPI;
const keyStore = new keyStores.BrowserLocalStorageKeyStore();
```

Using a File:

```js
// creates keyStore from a provided file
// you will need to pass the location of the .json key pair

const { keyStores } = nearAPI;
const KEY_PATH = "~./near-credentials/testnet/example-account.json";
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(KEY_PATH);
```

Using private key string:

```js
// creates keyStore from a private key string
// you can define your key here or use an environment variable

const { keyStores, KeyPair } = nearAPI;
const keyStore = new keyStores.InMemoryKeyStore();
const PRIVATE_KEY =
  "by8kdJoJHu7uUkKfoaLd2J2Dp1q1TigeWMG123pHdu9UREqPcshCM223kWadm";
// creates a public / private key pair using the provided private key
const keyPair = KeyPair.fromString(PRIVATE_KEY);
// adds the keyPair you created to keyStore
await keyStore.setKey("testnet", "example-account.testnet", keyPair);
```

**Note:** Key store is **_not required_** if you are not signing transactions _(using view call methods on a contract)_

### Connect

Testnet:

```js
const { connect } = nearAPI;

const config = {
  networkId: "testnet",
  keyStore, // optional if not signing transactions
  nodeUrl: "https://rpc.testnet.near.org",
  walletUrl: "https://wallet.testnet.near.org",
  helperUrl: "https://helper.testnet.near.org",
  explorerUrl: "https://explorer.testnet.near.org",
};
const near = await connect(config);
```

Mainnet:

```js
const { connect } = nearAPI;

const config = {
  networkId: "mainnet",
  keyStore, // optional if not signing transactions
  nodeUrl: "https://rpc.mainnet.near.org",
  walletUrl: "https://wallet.mainnet.near.org",
  helperUrl: "https://helper.mainnet.near.org",
  explorerUrl: "https://explorer.mainnet.near.org",
};
const near = await connect(config);
```

Betanet:

```js
const { connect } = nearAPI;

const config = {
  networkId: "betanet",
  keyStore, // optional if not signing transactions
  nodeUrl: "https://rpc.betanet.near.org",
  walletUrl: "https://wallet.betanet.near.org",
  helperUrl: "https://helper.betanet.near.org",
  explorerUrl: "https://explorer.betanet.near.org",
};
const near = await connect(config);
```

Localnet:

```js
const { connect } = nearAPI;
const config = {
  networkId: "local",
  nodeUrl: "http://localhost:3030",
  walletUrl: "http://localhost:4000/wallet",
};
const near = await connect(config);
```

[`keyStore setup`](#key-store)

## Wallet

### Connection

Testnet:

```js
const { connect, keyStores, WalletConnection } = nearAPI;

const config = {
  networkId: "testnet",
  keyStore: new keyStores.BrowserLocalStorageKeyStore(),
  nodeUrl: "https://rpc.testnet.near.org",
  walletUrl: "https://wallet.testnet.near.org",
  helperUrl: "https://helper.testnet.near.org",
  explorerUrl: "https://explorer.testnet.near.org",
};

// connect to NEAR
const near = await connect(config);

// create wallet connection
const wallet = new WalletConnection(near);
```

Mainnet:

```js
const { connect, keyStores, WalletConnection } = nearAPI;

const config = {
  networkId: "mainnet",
  keyStore: new keyStores.BrowserLocalStorageKeyStore(),
  nodeUrl: "https://rpc.mainnet.near.org",
  walletUrl: "https://wallet.mainnet.near.org",
  helperUrl: "https://helper.mainnet.near.org",
  explorerUrl: "https://explorer.mainnet.near.org",
};

// connect to NEAR
const near = await connect(config);

// create wallet connection
const wallet = new WalletConnection(near);
```

Betanet:

```js
const { connect, keyStores, WalletConnection } = nearAPI;

const config = {
  networkId: "betanet",
  keyStore: new keyStores.BrowserLocalStorageKeyStore(),
  nodeUrl: "https://rpc.betanet.near.org",
  walletUrl: "https://wallet.betanet.near.org",
  helperUrl: "https://helper.betanet.near.org",
  explorerUrl: "https://explorer.betanet.near.org",
};

// connect to NEAR
const near = await connect(config);

// create wallet connection
const wallet = new WalletConnection(near);
```

### Sign In

```js
// redirects user to wallet to authorize your dApp
// this creates an access key that will be stored in the browser's local storage
// access key can then be used to connect to NEAR and sign transactions via keyStore

const signIn = () => {
    wallet.requestSignIn({
        contractId: 'example-contract.testnet', // optional, contract requesting access
        methodNames: ['hello', 'goodbye'], // optional
        successUrl: 'http://YOUR-URL.com/success', // optional
        failureUrl: 'http://YOUR-URL.com/fail' // optional
    });
};
```

**Note:** Sign In is **_not required_** if you are using an alternative key store to local storage **_or_** you are not signing transactions _(using view call methods on a contract)_

### Sign Out

```js
const signOut = () => {
  wallet.signOut();
};
```

### Check if Signed In

```js
if(wallet.isSignedIn()) => doSomething();
```

### Get Authorized Account Id

```js
// returns account Id as string
const walletAccountId = wallet.getAccountId();
```

### Get Authorized Account Object

```js
// returns account object for transaction signing
const walletAccountObj = wallet.account();
```

## Account

### Load Account

```js
const near = await connect(config);
const account = await near.account("example-account.testnet");
```

[`config setup`](#connect)

### Create Account

```js
// creates a new account using funds from the account used to create it
const near = await connect(config);
const account = await near.account("example-account.testnet");
await account.createAccount(
  "example-account2.testnet", // new account name
  "8hSHprDq2StXwMtNd43wDTXQYsjXcD4MJTXQYsjXcc", // public key for new account
  "10000000000000000000" // initial balance for new account in yoctoNEAR
);
```

[`config setup`](#connect)

### Delete Account

```js
// deletes account found in the `account` object
// transfers remaining account balance to the accountId passed as an argument
const near = await connect(config);
const account = await near.account("example-account.testnet");
await account.deleteAccount("beneficiary-account.testnet");
```

[`config setup`](#connect)

### Get Account Balance

```js
// gets account balance
const near = await connect(config);
const account = await near.account("example-account.testnet");
await account.getAccountBalance();
```

[`config setup`](#connect)

### Get Account details

```js
// gets account details in terms of authorized apps and transactions
const near = await connect(config);
const account = await near.account("example-account.testnet");
await account.getAccountDetails();
```

[`config setup`](#connect)

### Send Tokens

```js
// sends NEAR tokens
const near = await connect(config);
const account = await near.account("sender-account.testnet");
await account.sendMoney(
  "receiver-account.testnet", // receiver account
  "1000000000000000000000000" // amount in yoctoNEAR
);
```

[`config setup`](#connect)

### State

```js
// gets the state of the account
const near = await connect(config);
const account = await near.account("example-account.testnet");
const response = await account.state();
console.log(response);
```

[`config setup`](#connect)

### Deploy Contract

```js
const near = await connect(config);
const account = await near.account("example-account.testnet");
const response = await account.deployContract(fs.readFileSync('./wasm_files/status_message.wasm'));
console.log(response);
```

[`config setup`](#connect)

## Contract

### Load Contract

Standard:

```js
const contract = new nearAPI.Contract(
  account, // the account object that is connecting
  "example-contract.testnet",
  {
    // name of contract you're connecting to
    viewMethods: ["getMessages"], // view methods do not change state but usually return a value
    changeMethods: ["addMessage"], // change methods modify state
    sender: account, // account object to initialize and sign transactions.
  }
);
```

[`config setup`](#connect)

Using Wallet:

```js
const contract = new nearAPI.Contract(
  wallet.account(), // the account object that is connecting
  "example-contract.testnet",
  {
    // name of contract you're connecting to
    viewMethods: ["getMessages"], // view methods do not change state but usually return a value
    changeMethods: ["addMessage"], // change methods modify state
    sender: wallet.Account(), // account object to initialize and sign transactions.
  }
);
```

[`config setup`](#connect)

### Call Contract

Change Method:

```js
await contract.method_name(
  {
    arg_name: "value", // argument name and value - pass empty object if no args required
  },
  300000000000000, // attached GAS (optional)
  1000000000000000000000000 // attached deposit in yoctoNEAR (optional)
);
```

View Method:

```js
const response = await contract.view_method_name();
console.log(response);
```

View Method w/ Args:

```js
const response = await contract.view_method_name({ arg_name: "arg_value" });
console.log(response);
```

## Access Keys

### Add Full Access Key

```js
// takes public key as string for argument
const near = await connect(config);
const account = await near.account("example-account.testnet");
await account.addKey("8hSHprDq2StXwMtNd43wDTXQYsjXcD4MJTXQYsjXcc");
```

[`config setup`](#connect)

### Add Function Access Key

```js
// adds function access key
const near = await connect(config);
const account = await near.account("example-account.testnet");
await account.addKey(
  "8hSHprDq2StXwMtNd43wDTXQYsjXcD4MJTXQYsjXcc", // public key for new account
  "example-account.testnet", // contract this key is allowed to call (optional)
  "example_method", // methods this key is allowed to call (optional)
  "2500000000000" // allowance key can use to call methods (optional)
);
```

[`config setup`](#connect)

### Get All Access Keys

```js
// returns all access keys associated with an account
const near = await connect(config);
const account = await near.account("example-account.testnet");
await account.getAccessKeys();
```

[`config setup`](#connect)

### Delete Access Key

```js
// takes public key as string for argument
const near = await connect(config);
const account = await near.account("example-account.testnet");
await account.deleteKey("8hSHprDq2StXwMtNd43wDTXQYsjXcD4MJTXQYsjXcc");
```

[`config setup`](#connect)

## Utils

### NEAR => yoctoNEAR

```js
// converts NEAR amount into yoctoNEAR (10^-24)

const { utils } = nearAPI;
const amountInYocto = utils.format.parseNearAmount("1");
```

### YoctoNEAR => NEAR

```js
// converts yoctoNEAR (10^-24) amount into NEAR

const { utils } = nearAPI;
const amountInNEAR = utils.format.formatNearAmount("1000000000000000000000000");
```

'''
'''--- fetch_error_schema.js ---
const https = require('https');
const fs = require('fs');
const {
    Project,
    Scope,
} = require('ts-morph');

const ERROR_SCHEMA_URL =
    'https://raw.githubusercontent.com/nearprotocol/nearcore/4c1149974ccf899dbcb2253a3e27cbab86dc47be/chain/jsonrpc/res/rpc_errors_schema.json';
const TARGET_DIR = process.argv[2] ||  process.cwd() + '/src/generated';
const TARGET_SCHEMA_FILE_PATH = TARGET_DIR + '/rpc_error_schema.json';

https
    .get(ERROR_SCHEMA_URL, resp => {
        let data = '';

        resp.on('data', chunk => {
            data += chunk;
        });

        resp.on('end', () => {
            fs.writeFileSync(TARGET_SCHEMA_FILE_PATH, data);
        });
    })
    .on('error', err => {
        console.log('Unable to fetch schema file: ' + err.message);
    });

'''
'''--- jest.config.js ---
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    collectCoverage: true
};

'''
'''--- lib/account.d.ts ---
/// <reference types="node" />
import BN from 'bn.js';
import { Action, SignedTransaction } from './transaction';
import { FinalExecutionOutcome } from './providers';
import { Finality, BlockId, AccountView, AccessKeyView, AccessKeyInfoView } from './providers/provider';
import { Connection } from './connection';
import { PublicKey } from './utils/key_pair';
export interface AccountBalance {
    total: string;
    stateStaked: string;
    staked: string;
    available: string;
}
export interface AccountAuthorizedApp {
    contractId: string;
    amount: string;
    publicKey: string;
}
/**
 * Options used to initiate sining and sending transactions
 */
export interface SignAndSendTransactionOptions {
    receiverId: string;
    actions: Action[];
    /**
     * Metadata to send the NEAR Wallet if using it to sign transactions.
     * @see {@link RequestSignTransactionsOptions}
     */
    walletMeta?: string;
    /**
     * Callback url to send the NEAR Wallet if using it to sign transactions.
     * @see {@link RequestSignTransactionsOptions}
     */
    walletCallbackUrl?: string;
    returnError?: boolean;
}
/**
 * Options used to initiate a function call (especially a change function call)
 * @see {@link viewFunction} to initiate a view function call
 */
export interface FunctionCallOptions {
    /** The NEAR account id where the contract is deployed */
    contractId: string;
    /** The name of the method to invoke */
    methodName: string;
    /**
     * named arguments to pass the method `{ messageText: 'my message' }`
     */
    args: object;
    /** max amount of gas that method call can use */
    gas?: BN;
    /** amount of NEAR (in yoctoNEAR) to send together with the call */
    attachedDeposit?: BN;
    /**
     * Metadata to send the NEAR Wallet if using it to sign transactions.
     * @see {@link RequestSignTransactionsOptions}
     */
    walletMeta?: string;
    /**
     * Callback url to send the NEAR Wallet if using it to sign transactions.
     * @see {@link RequestSignTransactionsOptions}
     */
    walletCallbackUrl?: string;
    /**
     * Convert input arguments into bytes array.
     */
    stringify?: (input: any) => Buffer;
}
declare function parseJsonFromRawResponse(response: Uint8Array): any;
declare function bytesJsonStringify(input: any): Buffer;
/**
 * This class provides common account related RPC calls including signing transactions with a {@link KeyPair}.
 *
 * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#account}
 * @hint Use {@link WalletConnection} in the browser to redirect to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for Account/key management using the {@link BrowserLocalStorageKeyStore}.
 * @see {@link https://nomicon.io/DataStructures/Account.html | Account Spec}
 */
export declare class Account {
    readonly connection: Connection;
    readonly accountId: string;
    /** @hidden */
    protected get ready(): Promise<void>;
    constructor(connection: Connection, accountId: string);
    fetchState(): Promise<void>;
    /**
     * Returns basic NEAR account information via the `view_account` RPC query method
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#view-account}
     */
    state(): Promise<AccountView>;
    /** @hidden */
    private printLogsAndFailures;
    /** @hidden */
    private printLogs;
    /**
     * Create a signed transaction which can be broadcast to the network
     * @param receiverId NEAR account receiving the transaction
     * @param actions list of actions to perform as part of the transaction
     * @see {@link JsonRpcProvider.sendTransaction}
     */
    protected signTransaction(receiverId: string, actions: Action[]): Promise<[Uint8Array, SignedTransaction]>;
    /**
     * Sign a transaction to preform a list of actions and broadcast it using the RPC API.
     * @see {@link JsonRpcProvider.sendTransaction}
     */
    protected signAndSendTransaction({ receiverId, actions }: SignAndSendTransactionOptions): Promise<FinalExecutionOutcome>;
    /**
     * @deprecated
     * Sign a transaction to preform a list of actions and broadcast it using the RPC API.
     * @see {@link JsonRpcProvider.sendTransaction}
     *
     * @param receiverId NEAR account receiving the transaction
     * @param actions list of actions to perform as part of the transaction
     */
    protected signAndSendTransaction(receiverId: string, actions: Action[]): Promise<FinalExecutionOutcome>;
    private signAndSendTransactionV1;
    private signAndSendTransactionV2;
    /** @hidden */
    accessKeyByPublicKeyCache: {
        [key: string]: AccessKeyView;
    };
    /**
     * Finds the {@link AccessKeyView} associated with the accounts {@link PublicKey} stored in the {@link KeyStore}.
     *
     * @todo Find matching access key based on transaction (i.e. receiverId and actions)
     *
     * @param receiverId currently unused (see todo)
     * @param actions currently unused (see todo)
     * @returns `{ publicKey PublicKey; accessKey: AccessKeyView }`
     */
    findAccessKey(receiverId: string, actions: Action[]): Promise<{
        publicKey: PublicKey;
        accessKey: AccessKeyView;
    }>;
    /**
     * Create a new account and deploy a contract to it
     *
     * @param contractId NEAR account where the contract is deployed
     * @param publicKey The public key to add to the created contract account
     * @param data The compiled contract code
     * @param amount of NEAR to transfer to the created contract account. Transfer enough to pay for storage https://docs.near.org/docs/concepts/storage-staking
     */
    createAndDeployContract(contractId: string, publicKey: string | PublicKey, data: Uint8Array, amount: BN): Promise<Account>;
    /**
     * @param receiverId NEAR account receiving 
     * @param amount Amount to send in yocto
     */
    sendMoney(receiverId: string, amount: BN): Promise<FinalExecutionOutcome>;
    /**
     * @param newAccountId NEAR account name to be created
     * @param publicKey A public key created from the masterAccount
     */
    createAccount(newAccountId: string, publicKey: string | PublicKey, amount: BN): Promise<FinalExecutionOutcome>;
    /**
     * @param beneficiaryId The NEAR account that will receive the remaining  balance from the account being deleted
     */
    deleteAccount(beneficiaryId: string): Promise<FinalExecutionOutcome>;
    /**
     * @param data The compiled contract code
     */
    deployContract(data: Uint8Array): Promise<FinalExecutionOutcome>;
    functionCall(props: FunctionCallOptions): Promise<FinalExecutionOutcome>;
    /**
     * @deprecated
     *
     * @param contractId NEAR account where the contract is deployed
     * @param methodName The method name on the contract as it is written in the contract code
     * @param args arguments to pass to method. Can be either plain JS object which gets serialized as JSON automatically
     *  or `Uint8Array` instance which represents bytes passed as is.
     * @param gas max amount of gas that method call can use
     * @param amount amount of NEAR (in yoctoNEAR) to send together with the call
     * @returns {Promise<FinalExecutionOutcome>}
     */
    functionCall(contractId: string, methodName: string, args: any, gas?: BN, amount?: BN): Promise<FinalExecutionOutcome>;
    private functionCallV1;
    private functionCallV2;
    /**
     * @see {@link https://docs.near.org/docs/concepts/account#access-keys}
     * @todo expand this API to support more options.
     * @param publicKey A public key to be associated with the contract
     * @param contractId NEAR account where the contract is deployed
     * @param methodNames The method names on the contract that should be allowed to be called. Pass null for no method names and '' or [] for any method names.
     * @param amount Payment in yocto that is sent to the contract during this function call
     */
    addKey(publicKey: string | PublicKey, contractId?: string, methodNames?: string | string[], amount?: BN): Promise<FinalExecutionOutcome>;
    /**
     * @param publicKey The public key to be deleted
     * @returns {Promise<FinalExecutionOutcome>}
     */
    deleteKey(publicKey: string | PublicKey): Promise<FinalExecutionOutcome>;
    /**
     * @see {@link https://docs.near.org/docs/validator/staking-overview}
     *
     * @param publicKey The public key for the account that's staking
     * @param amount The account to stake in yocto
     */
    stake(publicKey: string | PublicKey, amount: BN): Promise<FinalExecutionOutcome>;
    /** @hidden */
    private validateArgs;
    /**
     * Invoke a contract view function using the RPC API.
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#call-a-contract-function}
     *
     * @param contractId NEAR account where the contract is deployed
     * @param methodName The view-only method (no state mutations) name on the contract as it is written in the contract code
     * @param args Any arguments to the view contract method, wrapped in JSON
     * @param options.parse Parse the result of the call. Receives a Buffer (bytes array) and converts it to any object. By default result will be treated as json.
     * @param options.stringify Convert input arguments into a bytes array. By default the input is treated as a JSON.
     * @returns {Promise<any>}
     */
    viewFunction(contractId: string, methodName: string, args?: any, { parse, stringify }?: {
        parse?: typeof parseJsonFromRawResponse;
        stringify?: typeof bytesJsonStringify;
    }): Promise<any>;
    /**
     * Returns the state (key value pairs) of this account's contract based on the key prefix.
     * Pass an empty string for prefix if you would like to return the entire state.
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#view-contract-state}
     *
     * @param prefix allows to filter which keys should be returned. Empty prefix means all keys. String prefix is utf-8 encoded.
     * @param blockQuery specifies which block to query state at. By default returns last "optimistic" block (i.e. not necessarily finalized).
     */
    viewState(prefix: string | Uint8Array, blockQuery?: {
        blockId: BlockId;
    } | {
        finality: Finality;
    }): Promise<Array<{
        key: Buffer;
        value: Buffer;
    }>>;
    /**
     * Get all access keys for the account
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#view-access-key-list}
     */
    getAccessKeys(): Promise<AccessKeyInfoView[]>;
    /**
     * Returns a list of authorized apps
     * @todo update the response value to return all the different keys, not just app keys.
     */
    getAccountDetails(): Promise<{
        authorizedApps: AccountAuthorizedApp[];
    }>;
    /**
     * Returns calculated account balance
     */
    getAccountBalance(): Promise<AccountBalance>;
}
export {};

'''
'''--- lib/account.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Account = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const depd_1 = __importDefault(require("depd"));
const transaction_1 = require("./transaction");
const providers_1 = require("./providers");
const borsh_1 = require("borsh");
const key_pair_1 = require("./utils/key_pair");
const errors_1 = require("./utils/errors");
const rpc_errors_1 = require("./utils/rpc_errors");
const constants_1 = require("./constants");
const exponential_backoff_1 = __importDefault(require("./utils/exponential-backoff"));
// Default number of retries with different nonce before giving up on a transaction.
const TX_NONCE_RETRY_NUMBER = 12;
// Default wait until next retry in millis.
const TX_NONCE_RETRY_WAIT = 500;
// Exponential back off for waiting to retry.
const TX_NONCE_RETRY_WAIT_BACKOFF = 1.5;
function parseJsonFromRawResponse(response) {
    return JSON.parse(Buffer.from(response).toString());
}
function bytesJsonStringify(input) {
    return Buffer.from(JSON.stringify(input));
}
/**
 * This class provides common account related RPC calls including signing transactions with a {@link KeyPair}.
 *
 * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#account}
 * @hint Use {@link WalletConnection} in the browser to redirect to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for Account/key management using the {@link BrowserLocalStorageKeyStore}.
 * @see {@link https://nomicon.io/DataStructures/Account.html | Account Spec}
 */
class Account {
    constructor(connection, accountId) {
        /** @hidden */
        this.accessKeyByPublicKeyCache = {};
        this.connection = connection;
        this.accountId = accountId;
    }
    /** @hidden */
    get ready() {
        const deprecate = depd_1.default('Account.ready()');
        deprecate('not needed anymore, always ready');
        return Promise.resolve();
    }
    async fetchState() {
        const deprecate = depd_1.default('Account.fetchState()');
        deprecate('use `Account.state()` instead');
    }
    /**
     * Returns basic NEAR account information via the `view_account` RPC query method
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#view-account}
     */
    async state() {
        return this.connection.provider.query({
            request_type: 'view_account',
            account_id: this.accountId,
            finality: 'optimistic'
        });
    }
    /** @hidden */
    printLogsAndFailures(contractId, results) {
        if (!process.env["NEAR_NO_LOGS"]) {
            for (const result of results) {
                console.log(`Receipt${result.receiptIds.length > 1 ? 's' : ''}: ${result.receiptIds.join(', ')}`);
                this.printLogs(contractId, result.logs, '\t');
                if (result.failure) {
                    console.warn(`\tFailure [${contractId}]: ${result.failure}`);
                }
            }
        }
    }
    /** @hidden */
    printLogs(contractId, logs, prefix = '') {
        if (!process.env["NEAR_NO_LOGS"]) {
            for (const log of logs) {
                console.log(`${prefix}Log [${contractId}]: ${log}`);
            }
        }
    }
    /**
     * Create a signed transaction which can be broadcast to the network
     * @param receiverId NEAR account receiving the transaction
     * @param actions list of actions to perform as part of the transaction
     * @see {@link JsonRpcProvider.sendTransaction}
     */
    async signTransaction(receiverId, actions) {
        const accessKeyInfo = await this.findAccessKey(receiverId, actions);
        if (!accessKeyInfo) {
            throw new providers_1.TypedError(`Can not sign transactions for account ${this.accountId} on network ${this.connection.networkId}, no matching key pair found in ${this.connection.signer}.`, 'KeyNotFound');
        }
        const { accessKey } = accessKeyInfo;
        const block = await this.connection.provider.block({ finality: 'final' });
        const blockHash = block.header.hash;
        const nonce = ++accessKey.nonce;
        return await transaction_1.signTransaction(receiverId, nonce, actions, borsh_1.baseDecode(blockHash), this.connection.signer, this.accountId, this.connection.networkId);
    }
    signAndSendTransaction(...args) {
        if (typeof args[0] === 'string') {
            return this.signAndSendTransactionV1(args[0], args[1]);
        }
        else {
            return this.signAndSendTransactionV2(args[0]);
        }
    }
    signAndSendTransactionV1(receiverId, actions) {
        const deprecate = depd_1.default('Account.signAndSendTransaction(receiverId, actions');
        deprecate('use `Account.signAndSendTransaction(SignAndSendTransactionOptions)` instead');
        return this.signAndSendTransactionV2({ receiverId, actions });
    }
    async signAndSendTransactionV2({ receiverId, actions, returnError }) {
        let txHash, signedTx;
        // TODO: TX_NONCE (different constants for different uses of exponentialBackoff?)
        const result = await exponential_backoff_1.default(TX_NONCE_RETRY_WAIT, TX_NONCE_RETRY_NUMBER, TX_NONCE_RETRY_WAIT_BACKOFF, async () => {
            [txHash, signedTx] = await this.signTransaction(receiverId, actions);
            const publicKey = signedTx.transaction.publicKey;
            try {
                return await this.connection.provider.sendTransaction(signedTx);
            }
            catch (error) {
                if (error.type === 'InvalidNonce') {
                    errors_1.logWarning(`Retrying transaction ${receiverId}:${borsh_1.baseEncode(txHash)} with new nonce.`);
                    delete this.accessKeyByPublicKeyCache[publicKey.toString()];
                    return null;
                }
                if (error.type === 'Expired') {
                    errors_1.logWarning(`Retrying transaction ${receiverId}:${borsh_1.baseEncode(txHash)} due to expired block hash`);
                    return null;
                }
                error.context = new providers_1.ErrorContext(borsh_1.baseEncode(txHash));
                throw error;
            }
        });
        if (!result) {
            // TODO: This should have different code actually, as means "transaction not submitted for sure"
            throw new providers_1.TypedError('nonce retries exceeded for transaction. This usually means there are too many parallel requests with the same access key.', 'RetriesExceeded');
        }
        const flatLogs = [result.transaction_outcome, ...result.receipts_outcome].reduce((acc, it) => {
            if (it.outcome.logs.length ||
                (typeof it.outcome.status === 'object' && typeof it.outcome.status.Failure === 'object')) {
                return acc.concat({
                    'receiptIds': it.outcome.receipt_ids,
                    'logs': it.outcome.logs,
                    'failure': typeof it.outcome.status.Failure != 'undefined' ? rpc_errors_1.parseRpcError(it.outcome.status.Failure) : null
                });
            }
            else
                return acc;
        }, []);
        this.printLogsAndFailures(signedTx.transaction.receiverId, flatLogs);
        if (!returnError && typeof result.status === 'object' && typeof result.status.Failure === 'object') {
            // if error data has error_message and error_type properties, we consider that node returned an error in the old format
            if (result.status.Failure.error_message && result.status.Failure.error_type) {
                throw new providers_1.TypedError(`Transaction ${result.transaction_outcome.id} failed. ${result.status.Failure.error_message}`, result.status.Failure.error_type);
            }
            else {
                throw rpc_errors_1.parseResultError(result);
            }
        }
        // TODO: if Tx is Unknown or Started.
        return result;
    }
    /**
     * Finds the {@link AccessKeyView} associated with the accounts {@link PublicKey} stored in the {@link KeyStore}.
     *
     * @todo Find matching access key based on transaction (i.e. receiverId and actions)
     *
     * @param receiverId currently unused (see todo)
     * @param actions currently unused (see todo)
     * @returns `{ publicKey PublicKey; accessKey: AccessKeyView }`
     */
    async findAccessKey(receiverId, actions) {
        // TODO: Find matching access key based on transaction (i.e. receiverId and actions)
        const publicKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);
        if (!publicKey) {
            return null;
        }
        const cachedAccessKey = this.accessKeyByPublicKeyCache[publicKey.toString()];
        if (cachedAccessKey !== undefined) {
            return { publicKey, accessKey: cachedAccessKey };
        }
        try {
            const accessKey = await this.connection.provider.query({
                request_type: 'view_access_key',
                account_id: this.accountId,
                public_key: publicKey.toString(),
                finality: 'optimistic'
            });
            // this function can be called multiple times and retrieve the same access key
            // this checks to see if the access key was already retrieved and cached while
            // the above network call was in flight. To keep nonce values in line, we return
            // the cached access key.
            if (this.accessKeyByPublicKeyCache[publicKey.toString()]) {
                return { publicKey, accessKey: this.accessKeyByPublicKeyCache[publicKey.toString()] };
            }
            this.accessKeyByPublicKeyCache[publicKey.toString()] = accessKey;
            return { publicKey, accessKey };
        }
        catch (e) {
            if (e.type == 'AccessKeyDoesNotExist') {
                return null;
            }
            throw e;
        }
    }
    /**
     * Create a new account and deploy a contract to it
     *
     * @param contractId NEAR account where the contract is deployed
     * @param publicKey The public key to add to the created contract account
     * @param data The compiled contract code
     * @param amount of NEAR to transfer to the created contract account. Transfer enough to pay for storage https://docs.near.org/docs/concepts/storage-staking
     */
    async createAndDeployContract(contractId, publicKey, data, amount) {
        const accessKey = transaction_1.fullAccessKey();
        await this.signAndSendTransaction({
            receiverId: contractId,
            actions: [transaction_1.createAccount(), transaction_1.transfer(amount), transaction_1.addKey(key_pair_1.PublicKey.from(publicKey), accessKey), transaction_1.deployContract(data)]
        });
        const contractAccount = new Account(this.connection, contractId);
        return contractAccount;
    }
    /**
     * @param receiverId NEAR account receiving 
     * @param amount Amount to send in yocto
     */
    async sendMoney(receiverId, amount) {
        return this.signAndSendTransaction({
            receiverId,
            actions: [transaction_1.transfer(amount)]
        });
    }
    /**
     * @param newAccountId NEAR account name to be created
     * @param publicKey A public key created from the masterAccount
     */
    async createAccount(newAccountId, publicKey, amount) {
        const accessKey = transaction_1.fullAccessKey();
        return this.signAndSendTransaction({
            receiverId: newAccountId,
            actions: [transaction_1.createAccount(), transaction_1.transfer(amount), transaction_1.addKey(key_pair_1.PublicKey.from(publicKey), accessKey)]
        });
    }
    /**
     * @param beneficiaryId The NEAR account that will receive the remaining  balance from the account being deleted
     */
    async deleteAccount(beneficiaryId) {
        return this.signAndSendTransaction({
            receiverId: this.accountId,
            actions: [transaction_1.deleteAccount(beneficiaryId)]
        });
    }
    /**
     * @param data The compiled contract code
     */
    async deployContract(data) {
        return this.signAndSendTransaction({
            receiverId: this.accountId,
            actions: [transaction_1.deployContract(data)]
        });
    }
    async functionCall(...args) {
        if (typeof args[0] === 'string') {
            return this.functionCallV1(args[0], args[1], args[2], args[3], args[4]);
        }
        else {
            return this.functionCallV2(args[0]);
        }
    }
    functionCallV1(contractId, methodName, args, gas, amount) {
        const deprecate = depd_1.default('Account.functionCall(contractId, methodName, args, gas, amount)');
        deprecate('use `Account.functionCall(FunctionCallOptions)` instead');
        args = args || {};
        this.validateArgs(args);
        return this.signAndSendTransaction({
            receiverId: contractId,
            actions: [transaction_1.functionCall(methodName, args, gas || constants_1.DEFAULT_FUNCTION_CALL_GAS, amount)]
        });
    }
    functionCallV2({ contractId, methodName, args = {}, gas = constants_1.DEFAULT_FUNCTION_CALL_GAS, attachedDeposit, walletMeta, walletCallbackUrl, stringify }) {
        this.validateArgs(args);
        const stringifyArg = stringify === undefined ? transaction_1.stringifyJsonOrBytes : stringify;
        return this.signAndSendTransaction({
            receiverId: contractId,
            actions: [transaction_1.functionCall(methodName, args, gas, attachedDeposit, stringifyArg)],
            walletMeta,
            walletCallbackUrl
        });
    }
    /**
     * @see {@link https://docs.near.org/docs/concepts/account#access-keys}
     * @todo expand this API to support more options.
     * @param publicKey A public key to be associated with the contract
     * @param contractId NEAR account where the contract is deployed
     * @param methodNames The method names on the contract that should be allowed to be called. Pass null for no method names and '' or [] for any method names.
     * @param amount Payment in yocto that is sent to the contract during this function call
     */
    async addKey(publicKey, contractId, methodNames, amount) {
        if (!methodNames) {
            methodNames = [];
        }
        if (!Array.isArray(methodNames)) {
            methodNames = [methodNames];
        }
        let accessKey;
        if (!contractId) {
            accessKey = transaction_1.fullAccessKey();
        }
        else {
            accessKey = transaction_1.functionCallAccessKey(contractId, methodNames, amount);
        }
        return this.signAndSendTransaction({
            receiverId: this.accountId,
            actions: [transaction_1.addKey(key_pair_1.PublicKey.from(publicKey), accessKey)]
        });
    }
    /**
     * @param publicKey The public key to be deleted
     * @returns {Promise<FinalExecutionOutcome>}
     */
    async deleteKey(publicKey) {
        return this.signAndSendTransaction({
            receiverId: this.accountId,
            actions: [transaction_1.deleteKey(key_pair_1.PublicKey.from(publicKey))]
        });
    }
    /**
     * @see {@link https://docs.near.org/docs/validator/staking-overview}
     *
     * @param publicKey The public key for the account that's staking
     * @param amount The account to stake in yocto
     */
    async stake(publicKey, amount) {
        return this.signAndSendTransaction({
            receiverId: this.accountId,
            actions: [transaction_1.stake(amount, key_pair_1.PublicKey.from(publicKey))]
        });
    }
    /** @hidden */
    validateArgs(args) {
        const isUint8Array = args.byteLength !== undefined && args.byteLength === args.length;
        if (isUint8Array) {
            return;
        }
        if (Array.isArray(args) || typeof args !== 'object') {
            throw new errors_1.PositionalArgsError();
        }
    }
    /**
     * Invoke a contract view function using the RPC API.
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#call-a-contract-function}
     *
     * @param contractId NEAR account where the contract is deployed
     * @param methodName The view-only method (no state mutations) name on the contract as it is written in the contract code
     * @param args Any arguments to the view contract method, wrapped in JSON
     * @param options.parse Parse the result of the call. Receives a Buffer (bytes array) and converts it to any object. By default result will be treated as json.
     * @param options.stringify Convert input arguments into a bytes array. By default the input is treated as a JSON.
     * @returns {Promise<any>}
     */
    async viewFunction(contractId, methodName, args = {}, { parse = parseJsonFromRawResponse, stringify = bytesJsonStringify } = {}) {
        this.validateArgs(args);
        const serializedArgs = stringify(args).toString('base64');
        const result = await this.connection.provider.query({
            request_type: 'call_function',
            account_id: contractId,
            method_name: methodName,
            args_base64: serializedArgs,
            finality: 'optimistic'
        });
        if (result.logs) {
            this.printLogs(contractId, result.logs);
        }
        return result.result && result.result.length > 0 && parse(Buffer.from(result.result));
    }
    /**
     * Returns the state (key value pairs) of this account's contract based on the key prefix.
     * Pass an empty string for prefix if you would like to return the entire state.
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#view-contract-state}
     *
     * @param prefix allows to filter which keys should be returned. Empty prefix means all keys. String prefix is utf-8 encoded.
     * @param blockQuery specifies which block to query state at. By default returns last "optimistic" block (i.e. not necessarily finalized).
     */
    async viewState(prefix, blockQuery = { finality: 'optimistic' }) {
        const { values } = await this.connection.provider.query({
            request_type: 'view_state',
            ...blockQuery,
            account_id: this.accountId,
            prefix_base64: Buffer.from(prefix).toString('base64')
        });
        return values.map(({ key, value }) => ({
            key: Buffer.from(key, 'base64'),
            value: Buffer.from(value, 'base64')
        }));
    }
    /**
     * Get all access keys for the account
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#view-access-key-list}
     */
    async getAccessKeys() {
        const response = await this.connection.provider.query({
            request_type: 'view_access_key_list',
            account_id: this.accountId,
            finality: 'optimistic'
        });
        // A breaking API change introduced extra information into the
        // response, so it now returns an object with a `keys` field instead
        // of an array: https://github.com/nearprotocol/nearcore/pull/1789
        if (Array.isArray(response)) {
            return response;
        }
        return response.keys;
    }
    /**
     * Returns a list of authorized apps
     * @todo update the response value to return all the different keys, not just app keys.
     */
    async getAccountDetails() {
        // TODO: update the response value to return all the different keys, not just app keys.
        // Also if we need this function, or getAccessKeys is good enough.
        const accessKeys = await this.getAccessKeys();
        const authorizedApps = accessKeys
            .filter(item => item.access_key.permission !== 'FullAccess')
            .map(item => {
            const perm = item.access_key.permission;
            return {
                contractId: perm.FunctionCall.receiver_id,
                amount: perm.FunctionCall.allowance,
                publicKey: item.public_key,
            };
        });
        return { authorizedApps };
    }
    /**
     * Returns calculated account balance
     */
    async getAccountBalance() {
        const protocolConfig = await this.connection.provider.experimental_protocolConfig({ finality: 'final' });
        const state = await this.state();
        const costPerByte = new bn_js_1.default(protocolConfig.runtime_config.storage_amount_per_byte);
        const stateStaked = new bn_js_1.default(state.storage_usage).mul(costPerByte);
        const staked = new bn_js_1.default(state.locked);
        const totalBalance = new bn_js_1.default(state.amount).add(staked);
        const availableBalance = totalBalance.sub(bn_js_1.default.max(staked, stateStaked));
        return {
            total: totalBalance.toString(),
            stateStaked: stateStaked.toString(),
            staked: staked.toString(),
            available: availableBalance.toString()
        };
    }
}
exports.Account = Account;

'''
'''--- lib/account_creator.d.ts ---
import BN from 'bn.js';
import { Connection } from './connection';
import { Account } from './account';
import { PublicKey } from './utils/key_pair';
/**
 * Account creator provides an interface for implementations to actually create accounts
 */
export declare abstract class AccountCreator {
    abstract createAccount(newAccountId: string, publicKey: PublicKey): Promise<void>;
}
export declare class LocalAccountCreator extends AccountCreator {
    readonly masterAccount: Account;
    readonly initialBalance: BN;
    constructor(masterAccount: Account, initialBalance: BN);
    /**
     * Creates an account using a masterAccount, meaning the new account is created from an existing account
     * @param newAccountId The name of the NEAR account to be created
     * @param publicKey The public key from the masterAccount used to create this account
     * @returns {Promise<void>}
     */
    createAccount(newAccountId: string, publicKey: PublicKey): Promise<void>;
}
export declare class UrlAccountCreator extends AccountCreator {
    readonly connection: Connection;
    readonly helperUrl: string;
    constructor(connection: Connection, helperUrl: string);
    /**
     * Creates an account using a helperUrl
     * This is [hosted here](https://helper.nearprotocol.com) or set up locally with the [near-contract-helper](https://github.com/nearprotocol/near-contract-helper) repository
     * @param newAccountId The name of the NEAR account to be created
     * @param publicKey The public key from the masterAccount used to create this account
     * @returns {Promise<void>}
     */
    createAccount(newAccountId: string, publicKey: PublicKey): Promise<void>;
}

'''
'''--- lib/account_creator.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UrlAccountCreator = exports.LocalAccountCreator = exports.AccountCreator = void 0;
const web_1 = require("./utils/web");
/**
 * Account creator provides an interface for implementations to actually create accounts
 */
class AccountCreator {
}
exports.AccountCreator = AccountCreator;
class LocalAccountCreator extends AccountCreator {
    constructor(masterAccount, initialBalance) {
        super();
        this.masterAccount = masterAccount;
        this.initialBalance = initialBalance;
    }
    /**
     * Creates an account using a masterAccount, meaning the new account is created from an existing account
     * @param newAccountId The name of the NEAR account to be created
     * @param publicKey The public key from the masterAccount used to create this account
     * @returns {Promise<void>}
     */
    async createAccount(newAccountId, publicKey) {
        await this.masterAccount.createAccount(newAccountId, publicKey, this.initialBalance);
    }
}
exports.LocalAccountCreator = LocalAccountCreator;
class UrlAccountCreator extends AccountCreator {
    constructor(connection, helperUrl) {
        super();
        this.connection = connection;
        this.helperUrl = helperUrl;
    }
    /**
     * Creates an account using a helperUrl
     * This is [hosted here](https://helper.nearprotocol.com) or set up locally with the [near-contract-helper](https://github.com/nearprotocol/near-contract-helper) repository
     * @param newAccountId The name of the NEAR account to be created
     * @param publicKey The public key from the masterAccount used to create this account
     * @returns {Promise<void>}
     */
    async createAccount(newAccountId, publicKey) {
        await web_1.fetchJson(`${this.helperUrl}/account`, JSON.stringify({ newAccountId, newAccountPublicKey: publicKey.toString() }));
    }
}
exports.UrlAccountCreator = UrlAccountCreator;

'''
'''--- lib/account_multisig.d.ts ---
import BN from 'bn.js';
import { Account, SignAndSendTransactionOptions } from './account';
import { Connection } from './connection';
import { Action } from './transaction';
import { FinalExecutionOutcome } from './providers';
export declare const MULTISIG_STORAGE_KEY = "__multisigRequest";
export declare const MULTISIG_ALLOWANCE: BN;
export declare const MULTISIG_GAS: BN;
export declare const MULTISIG_DEPOSIT: BN;
export declare const MULTISIG_CHANGE_METHODS: string[];
export declare const MULTISIG_CONFIRM_METHODS: string[];
declare type sendCodeFunction = () => Promise<any>;
declare type getCodeFunction = (method: any) => Promise<string>;
declare type verifyCodeFunction = (securityCode: any) => Promise<any>;
export declare class AccountMultisig extends Account {
    storage: any;
    onAddRequestResult: Function;
    constructor(connection: Connection, accountId: string, options: any);
    signAndSendTransactionWithAccount(receiverId: string, actions: Action[]): Promise<FinalExecutionOutcome>;
    protected signAndSendTransaction(...args: any[]): Promise<FinalExecutionOutcome>;
    private _signAndSendTransaction;
    deleteUnconfirmedRequests(): Promise<void>;
    getRequestIds(): Promise<string>;
    getRequest(): any;
    setRequest(data: any): any;
}
export declare class Account2FA extends AccountMultisig {
    /********************************
    Account2FA has options object where you can provide callbacks for:
    - sendCode: how to send the 2FA code in case you don't use NEAR Contract Helper
    - getCode: how to get code from user (use this to provide custom UI/UX for prompt of 2FA code)
    - onResult: the tx result after it's been confirmed by NEAR Contract Helper
    ********************************/
    sendCode: sendCodeFunction;
    getCode: getCodeFunction;
    verifyCode: verifyCodeFunction;
    onConfirmResult: Function;
    helperUrl: string;
    constructor(connection: Connection, accountId: string, options: any);
    /**
     * Sign a transaction to preform a list of actions and broadcast it using the RPC API.
     * @see {@link JsonRpcProvider.sendTransaction}
     */
    signAndSendTransaction({ receiverId, actions }: SignAndSendTransactionOptions): Promise<FinalExecutionOutcome>;
    /**
     * @deprecated
     * Sign a transaction to preform a list of actions and broadcast it using the RPC API.
     * @see {@link JsonRpcProvider.sendTransaction}
     *
     * @param receiverId NEAR account receiving the transaction
     * @param actions list of actions to perform as part of the transaction
     */
    signAndSendTransaction(receiverId: string, actions: Action[]): Promise<FinalExecutionOutcome>;
    private __signAndSendTransaction;
    deployMultisig(contractBytes: Uint8Array): Promise<FinalExecutionOutcome>;
    disable(contractBytes: Uint8Array): Promise<FinalExecutionOutcome>;
    sendCodeDefault(): Promise<any>;
    getCodeDefault(method: any): Promise<string>;
    promptAndVerify(): any;
    verifyCodeDefault(securityCode: string): Promise<any>;
    getRecoveryMethods(): Promise<{
        accountId: string;
        data: any;
    }>;
    get2faMethod(): Promise<{
        kind: any;
        detail: any;
    }>;
    signatureFor(): Promise<{
        blockNumber: string;
        blockNumberSignature: string;
    }>;
    postSignedJson(path: any, body: any): Promise<any>;
}
export {};

'''
'''--- lib/account_multisig.js ---
'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Account2FA = exports.AccountMultisig = exports.MULTISIG_CONFIRM_METHODS = exports.MULTISIG_CHANGE_METHODS = exports.MULTISIG_DEPOSIT = exports.MULTISIG_GAS = exports.MULTISIG_ALLOWANCE = exports.MULTISIG_STORAGE_KEY = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const depd_1 = __importDefault(require("depd"));
const account_1 = require("./account");
const format_1 = require("./utils/format");
const key_pair_1 = require("./utils/key_pair");
const transaction_1 = require("./transaction");
const web_1 = require("./utils/web");
exports.MULTISIG_STORAGE_KEY = '__multisigRequest';
exports.MULTISIG_ALLOWANCE = new bn_js_1.default(format_1.parseNearAmount('1'));
// TODO: Different gas value for different requests (can reduce gas usage dramatically)
exports.MULTISIG_GAS = new bn_js_1.default('100000000000000');
exports.MULTISIG_DEPOSIT = new bn_js_1.default('0');
exports.MULTISIG_CHANGE_METHODS = ['add_request', 'add_request_and_confirm', 'delete_request', 'confirm'];
exports.MULTISIG_CONFIRM_METHODS = ['confirm'];
// in memory request cache for node w/o localStorage
const storageFallback = {
    [exports.MULTISIG_STORAGE_KEY]: null
};
class AccountMultisig extends account_1.Account {
    constructor(connection, accountId, options) {
        super(connection, accountId);
        this.storage = options.storage;
        this.onAddRequestResult = options.onAddRequestResult;
    }
    async signAndSendTransactionWithAccount(receiverId, actions) {
        return super.signAndSendTransaction({ receiverId, actions });
    }
    signAndSendTransaction(...args) {
        if (typeof args[0] === 'string') {
            return this._signAndSendTransaction({ receiverId: args[0], actions: args[1] });
        }
        return this._signAndSendTransaction(args[0]);
    }
    async _signAndSendTransaction({ receiverId, actions }) {
        const { accountId } = this;
        const args = Buffer.from(JSON.stringify({
            request: {
                receiver_id: receiverId,
                actions: convertActions(actions, accountId, receiverId)
            }
        }));
        let result;
        try {
            result = await super.signAndSendTransaction({
                receiverId: accountId,
                actions: [
                    transaction_1.functionCall('add_request_and_confirm', args, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT)
                ]
            });
        }
        catch (e) {
            if (e.toString().includes('Account has too many active requests. Confirm or delete some')) {
                await this.deleteUnconfirmedRequests();
                return await this.signAndSendTransaction(receiverId, actions);
            }
            throw e;
        }
        // TODO: Are following even needed? Seems like it throws on error already
        if (!result.status) {
            throw new Error('Request failed');
        }
        const status = { ...result.status };
        if (!status.SuccessValue || typeof status.SuccessValue !== 'string') {
            throw new Error('Request failed');
        }
        this.setRequest({
            accountId,
            actions,
            requestId: parseInt(Buffer.from(status.SuccessValue, 'base64').toString('ascii'), 10)
        });
        if (this.onAddRequestResult) {
            await this.onAddRequestResult(result);
        }
        // NOTE there is no await on purpose to avoid blocking for 2fa
        this.deleteUnconfirmedRequests();
        return result;
    }
    async deleteUnconfirmedRequests() {
        // TODO: Delete in batch, don't delete unexpired
        // TODO: Delete in batch, don't delete unexpired (can reduce gas usage dramatically)
        const request_ids = await this.getRequestIds();
        const { requestId } = this.getRequest();
        for (const requestIdToDelete of request_ids) {
            if (requestIdToDelete == requestId) {
                continue;
            }
            try {
                await super.signAndSendTransaction({
                    receiverId: this.accountId,
                    actions: [transaction_1.functionCall('delete_request', { request_id: requestIdToDelete }, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT)]
                });
            }
            catch (e) {
                console.warn('Attempt to delete an earlier request before 15 minutes failed. Will try again.');
            }
        }
    }
    // helpers
    async getRequestIds() {
        // TODO: Read requests from state to allow filtering by expiration time
        // TODO: https://github.com/near/core-contracts/blob/305d1db4f4f2cf5ce4c1ef3479f7544957381f11/multisig/src/lib.rs#L84
        return this.viewFunction(this.accountId, 'list_request_ids');
    }
    getRequest() {
        if (this.storage) {
            return JSON.parse(this.storage.getItem(exports.MULTISIG_STORAGE_KEY) || '{}');
        }
        return storageFallback[exports.MULTISIG_STORAGE_KEY];
    }
    setRequest(data) {
        if (this.storage) {
            return this.storage.setItem(exports.MULTISIG_STORAGE_KEY, JSON.stringify(data));
        }
        storageFallback[exports.MULTISIG_STORAGE_KEY] = data;
    }
}
exports.AccountMultisig = AccountMultisig;
class Account2FA extends AccountMultisig {
    constructor(connection, accountId, options) {
        super(connection, accountId, options);
        this.helperUrl = 'https://helper.testnet.near.org';
        this.helperUrl = options.helperUrl || this.helperUrl;
        this.storage = options.storage;
        this.sendCode = options.sendCode || this.sendCodeDefault;
        this.getCode = options.getCode || this.getCodeDefault;
        this.verifyCode = options.verifyCode || this.verifyCodeDefault;
        this.onConfirmResult = options.onConfirmResult;
    }
    async signAndSendTransaction(...args) {
        if (typeof args[0] === 'string') {
            const deprecate = depd_1.default('Account.signAndSendTransaction(receiverId, actions');
            deprecate('use `Account2FA.signAndSendTransaction(SignAndSendTransactionOptions)` instead');
            return this.__signAndSendTransaction({ receiverId: args[0], actions: args[1] });
        }
        else {
            return this.__signAndSendTransaction(args[0]);
        }
    }
    async __signAndSendTransaction({ receiverId, actions }) {
        await super.signAndSendTransaction({ receiverId, actions });
        // TODO: Should following override onRequestResult in superclass instead of doing custom signAndSendTransaction?
        await this.sendCode();
        const result = await this.promptAndVerify();
        if (this.onConfirmResult) {
            await this.onConfirmResult(result);
        }
        return result;
    }
    // default helpers for CH deployments of multisig
    async deployMultisig(contractBytes) {
        const { accountId } = this;
        const seedOrLedgerKey = (await this.getRecoveryMethods()).data
            .filter(({ kind, publicKey }) => (kind === 'phrase' || kind === 'ledger') && publicKey !== null)
            .map((rm) => rm.publicKey);
        const fak2lak = (await this.getAccessKeys())
            .filter(({ public_key, access_key: { permission } }) => permission === 'FullAccess' && !seedOrLedgerKey.includes(public_key))
            .map((ak) => ak.public_key)
            .map(toPK);
        const confirmOnlyKey = toPK((await this.postSignedJson('/2fa/getAccessKey', { accountId })).publicKey);
        const newArgs = Buffer.from(JSON.stringify({ 'num_confirmations': 2 }));
        const actions = [
            ...fak2lak.map((pk) => transaction_1.deleteKey(pk)),
            ...fak2lak.map((pk) => transaction_1.addKey(pk, transaction_1.functionCallAccessKey(accountId, exports.MULTISIG_CHANGE_METHODS, null))),
            transaction_1.addKey(confirmOnlyKey, transaction_1.functionCallAccessKey(accountId, exports.MULTISIG_CONFIRM_METHODS, null)),
            transaction_1.deployContract(contractBytes),
        ];
        if ((await this.state()).code_hash === '11111111111111111111111111111111') {
            actions.push(transaction_1.functionCall('new', newArgs, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT));
        }
        console.log('deploying multisig contract for', accountId);
        return await super.signAndSendTransactionWithAccount(accountId, actions);
    }
    async disable(contractBytes) {
        const { accountId } = this;
        const accessKeys = await this.getAccessKeys();
        const lak2fak = accessKeys
            .filter(({ access_key }) => access_key.permission !== 'FullAccess')
            .filter(({ access_key }) => {
            const perm = access_key.permission.FunctionCall;
            return perm.receiver_id === accountId &&
                perm.method_names.length === 4 &&
                perm.method_names.includes('add_request_and_confirm');
        });
        const confirmOnlyKey = key_pair_1.PublicKey.from((await this.postSignedJson('/2fa/getAccessKey', { accountId })).publicKey);
        const actions = [
            transaction_1.deleteKey(confirmOnlyKey),
            ...lak2fak.map(({ public_key }) => transaction_1.deleteKey(key_pair_1.PublicKey.from(public_key))),
            ...lak2fak.map(({ public_key }) => transaction_1.addKey(key_pair_1.PublicKey.from(public_key), null)),
            transaction_1.deployContract(contractBytes),
        ];
        console.log('disabling 2fa for', accountId);
        return await this.signAndSendTransaction({
            receiverId: accountId,
            actions
        });
    }
    async sendCodeDefault() {
        const { accountId } = this;
        const { requestId } = this.getRequest();
        const method = await this.get2faMethod();
        await this.postSignedJson('/2fa/send', {
            accountId,
            method,
            requestId,
        });
        return requestId;
    }
    async getCodeDefault(method) {
        throw new Error('There is no getCode callback provided. Please provide your own in AccountMultisig constructor options. It has a parameter method where method.kind is "email" or "phone".');
    }
    async promptAndVerify() {
        const method = await this.get2faMethod();
        const securityCode = await this.getCode(method);
        try {
            const result = await this.verifyCode(securityCode);
            // TODO: Parse error from result for real (like in normal account.signAndSendTransaction)
            return result;
        }
        catch (e) {
            console.warn('Error validating security code:', e);
            if (e.toString().includes('invalid 2fa code provided') || e.toString().includes('2fa code not valid')) {
                return await this.promptAndVerify();
            }
            throw e;
        }
    }
    async verifyCodeDefault(securityCode) {
        const { accountId } = this;
        const request = this.getRequest();
        if (!request) {
            throw new Error('no request pending');
        }
        const { requestId } = request;
        return await this.postSignedJson('/2fa/verify', {
            accountId,
            securityCode,
            requestId
        });
    }
    async getRecoveryMethods() {
        const { accountId } = this;
        return {
            accountId,
            data: await this.postSignedJson('/account/recoveryMethods', { accountId })
        };
    }
    async get2faMethod() {
        let { data } = await this.getRecoveryMethods();
        if (data && data.length) {
            data = data.find((m) => m.kind.indexOf('2fa-') === 0);
        }
        if (!data)
            return null;
        const { kind, detail } = data;
        return { kind, detail };
    }
    async signatureFor() {
        const { accountId } = this;
        const block = await this.connection.provider.block({ finality: 'final' });
        const blockNumber = block.header.height.toString();
        const signed = await this.connection.signer.signMessage(Buffer.from(blockNumber), accountId, this.connection.networkId);
        const blockNumberSignature = Buffer.from(signed.signature).toString('base64');
        return { blockNumber, blockNumberSignature };
    }
    async postSignedJson(path, body) {
        return await web_1.fetchJson(this.helperUrl + path, JSON.stringify({
            ...body,
            ...(await this.signatureFor())
        }));
    }
}
exports.Account2FA = Account2FA;
// helpers
const toPK = (pk) => key_pair_1.PublicKey.from(pk);
const convertPKForContract = (pk) => pk.toString().replace('ed25519:', '');
const convertActions = (actions, accountId, receiverId) => actions.map((a) => {
    const type = a.enum;
    const { gas, publicKey, methodName, args, deposit, accessKey, code } = a[type];
    const action = {
        type: type[0].toUpperCase() + type.substr(1),
        gas: (gas && gas.toString()) || undefined,
        public_key: (publicKey && convertPKForContract(publicKey)) || undefined,
        method_name: methodName,
        args: (args && Buffer.from(args).toString('base64')) || undefined,
        code: (code && Buffer.from(code).toString('base64')) || undefined,
        amount: (deposit && deposit.toString()) || undefined,
        deposit: (deposit && deposit.toString()) || '0',
        permission: undefined,
    };
    if (accessKey) {
        if (receiverId === accountId && accessKey.permission.enum !== 'fullAccess') {
            action.permission = {
                receiver_id: accountId,
                allowance: exports.MULTISIG_ALLOWANCE.toString(),
                method_names: exports.MULTISIG_CHANGE_METHODS,
            };
        }
        if (accessKey.permission.enum === 'functionCall') {
            const { receiverId: receiver_id, methodNames: method_names, allowance } = accessKey.permission.functionCall;
            action.permission = {
                receiver_id,
                allowance: (allowance && allowance.toString()) || undefined,
                method_names
            };
        }
    }
    return action;
});

'''
'''--- lib/browser-connect.d.ts ---
/**
 * Connect to NEAR using the provided configuration.
 *
 * {@link ConnectConfig.networkId} and {@link ConnectConfig.nodeUrl} are required.
 *
 * To sign transactions you can also pass: {@link ConnectConfig.keyStore}
 *
 * Both are passed they are prioritize in that order.
 *
 * @see {@link ConnectConfig}
 * @example
 * ```js
 * async function initNear() {
 *   const near = await connect({
 *      networkId: 'testnet',
 *      nodeUrl: 'https://rpc.testnet.near.org'
 *   })
 * }
 * ```
 *
 * @module browserConnect
 */
import { Near, NearConfig } from "./near";
export interface ConnectConfig extends NearConfig {
    /** @hidden */
    keyPath?: string;
}
/**
 * Initialize connection to Near network.
 */
export declare function connect(config: ConnectConfig): Promise<Near>;

'''
'''--- lib/browser-connect.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.connect = void 0;
/**
 * Connect to NEAR using the provided configuration.
 *
 * {@link ConnectConfig.networkId} and {@link ConnectConfig.nodeUrl} are required.
 *
 * To sign transactions you can also pass: {@link ConnectConfig.keyStore}
 *
 * Both are passed they are prioritize in that order.
 *
 * @see {@link ConnectConfig}
 * @example
 * ```js
 * async function initNear() {
 *   const near = await connect({
 *      networkId: 'testnet',
 *      nodeUrl: 'https://rpc.testnet.near.org'
 *   })
 * }
 * ```
 *
 * @module browserConnect
 */
const near_1 = require("./near");
/**
 * Initialize connection to Near network.
 */
async function connect(config) {
    return new near_1.Near(config);
}
exports.connect = connect;

'''
'''--- lib/browser-index.d.ts ---
/** @hidden @module */
export * as keyStores from './key_stores/browser-index';
export * from './common-index';
export * from './browser-connect';
import 'error-polyfill';

'''
'''--- lib/browser-index.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
/** @hidden @module */
exports.keyStores = __importStar(require("./key_stores/browser-index"));
__exportStar(require("./common-index"), exports);
__exportStar(require("./browser-connect"), exports);
require("error-polyfill");

'''
'''--- lib/common-index.d.ts ---
/** @hidden @module */
import * as providers from './providers';
import * as utils from './utils';
import * as transactions from './transaction';
import * as validators from './validators';
import { Account } from './account';
import * as multisig from './account_multisig';
import * as accountCreator from './account_creator';
import { Connection } from './connection';
import { Signer, InMemorySigner } from './signer';
import { Contract } from './contract';
import { KeyPair } from './utils/key_pair';
import { Near } from './near';
import { ConnectedWalletAccount, WalletAccount, WalletConnection } from './wallet-account';
export { accountCreator, providers, utils, transactions, validators, multisig, Account, Connection, Contract, InMemorySigner, Signer, KeyPair, Near, ConnectedWalletAccount, WalletAccount, WalletConnection };

'''
'''--- lib/common-index.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletConnection = exports.WalletAccount = exports.ConnectedWalletAccount = exports.Near = exports.KeyPair = exports.Signer = exports.InMemorySigner = exports.Contract = exports.Connection = exports.Account = exports.multisig = exports.validators = exports.transactions = exports.utils = exports.providers = exports.accountCreator = void 0;
/** @hidden @module */
const providers = __importStar(require("./providers"));
exports.providers = providers;
const utils = __importStar(require("./utils"));
exports.utils = utils;
const transactions = __importStar(require("./transaction"));
exports.transactions = transactions;
const validators = __importStar(require("./validators"));
exports.validators = validators;
const account_1 = require("./account");
Object.defineProperty(exports, "Account", { enumerable: true, get: function () { return account_1.Account; } });
const multisig = __importStar(require("./account_multisig"));
exports.multisig = multisig;
const accountCreator = __importStar(require("./account_creator"));
exports.accountCreator = accountCreator;
const connection_1 = require("./connection");
Object.defineProperty(exports, "Connection", { enumerable: true, get: function () { return connection_1.Connection; } });
const signer_1 = require("./signer");
Object.defineProperty(exports, "Signer", { enumerable: true, get: function () { return signer_1.Signer; } });
Object.defineProperty(exports, "InMemorySigner", { enumerable: true, get: function () { return signer_1.InMemorySigner; } });
const contract_1 = require("./contract");
Object.defineProperty(exports, "Contract", { enumerable: true, get: function () { return contract_1.Contract; } });
const key_pair_1 = require("./utils/key_pair");
Object.defineProperty(exports, "KeyPair", { enumerable: true, get: function () { return key_pair_1.KeyPair; } });
const near_1 = require("./near");
Object.defineProperty(exports, "Near", { enumerable: true, get: function () { return near_1.Near; } });
// TODO: Deprecate and remove WalletAccount
const wallet_account_1 = require("./wallet-account");
Object.defineProperty(exports, "ConnectedWalletAccount", { enumerable: true, get: function () { return wallet_account_1.ConnectedWalletAccount; } });
Object.defineProperty(exports, "WalletAccount", { enumerable: true, get: function () { return wallet_account_1.WalletAccount; } });
Object.defineProperty(exports, "WalletConnection", { enumerable: true, get: function () { return wallet_account_1.WalletConnection; } });

'''
'''--- lib/connect.d.ts ---
import { Near, NearConfig } from './near';
export interface ConnectConfig extends NearConfig {
    /**
     * Initialize an {@link InMemoryKeyStore} by reading the file at keyPath.
     */
    keyPath?: string;
}
/**
 * Initialize connection to Near network.
 */
export declare function connect(config: ConnectConfig): Promise<Near>;

'''
'''--- lib/connect.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.connect = void 0;
/**
 * Connect to NEAR using the provided configuration.
 *
 * {@link ConnectConfig.networkId} and {@link ConnectConfig.nodeUrl} are required.
 *
 * To sign transactions you can also pass:
 * 1. {@link ConnectConfig.keyStore}
 * 2. {@link ConnectConfig.keyPath}
 *
 * If all three are passed they are prioritize in that order.
 *
 * @see {@link ConnectConfig}
 * @example
 * ```js
 * async function initNear() {
 *   const near = await connect({
 *      networkId: 'testnet',
 *      nodeUrl: 'https://rpc.testnet.near.org'
 *   })
 * }
 * ```
 * @module connect
 */
const unencrypted_file_system_keystore_1 = require("./key_stores/unencrypted_file_system_keystore");
const key_stores_1 = require("./key_stores");
const near_1 = require("./near");
const setup_node_fetch_1 = __importDefault(require("./utils/setup-node-fetch"));
const utils_1 = require("./utils");
global.fetch = setup_node_fetch_1.default;
/**
 * Initialize connection to Near network.
 */
async function connect(config) {
    // Try to find extra key in `KeyPath` if provided.
    if (config.keyPath && (config.keyStore || config.deps && config.deps.keyStore)) {
        try {
            const accountKeyFile = await unencrypted_file_system_keystore_1.readKeyFile(config.keyPath);
            if (accountKeyFile[0]) {
                // TODO: Only load key if network ID matches
                const keyPair = accountKeyFile[1];
                const keyPathStore = new key_stores_1.InMemoryKeyStore();
                await keyPathStore.setKey(config.networkId, accountKeyFile[0], keyPair);
                if (!config.masterAccount) {
                    config.masterAccount = accountKeyFile[0];
                }
                config.keyStore = new key_stores_1.MergeKeyStore([
                    keyPathStore,
                    (config.keyStore || config.deps.keyStore)
                ], { writeKeyStoreIndex: 1 });
                if (!process.env["NEAR_NO_LOGS"]) {
                    console.log(`Loaded master account ${accountKeyFile[0]} key from ${config.keyPath} with public key = ${keyPair.getPublicKey()}`);
                }
            }
        }
        catch (error) {
            utils_1.logWarning(`Failed to load master account key from ${config.keyPath}: ${error}`);
        }
    }
    return new near_1.Near(config);
}
exports.connect = connect;

'''
'''--- lib/connection.d.ts ---
import { Provider } from './providers';
import { Signer } from './signer';
/**
 * Connects an account to a given network via a given provider
 */
export declare class Connection {
    readonly networkId: string;
    readonly provider: Provider;
    readonly signer: Signer;
    constructor(networkId: string, provider: Provider, signer: Signer);
    /**
     * @param config Contains connection info details
     */
    static fromConfig(config: any): Connection;
}

'''
'''--- lib/connection.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Connection = void 0;
const providers_1 = require("./providers");
const signer_1 = require("./signer");
/**
 * @param config Contains connection info details
 * @returns {Provider}
 */
function getProvider(config) {
    switch (config.type) {
        case undefined:
            return config;
        case 'JsonRpcProvider': return new providers_1.JsonRpcProvider(config.args.url);
        default: throw new Error(`Unknown provider type ${config.type}`);
    }
}
/**
 * @param config Contains connection info details
 * @returns {Signer}
 */
function getSigner(config) {
    switch (config.type) {
        case undefined:
            return config;
        case 'InMemorySigner': {
            return new signer_1.InMemorySigner(config.keyStore);
        }
        default: throw new Error(`Unknown signer type ${config.type}`);
    }
}
/**
 * Connects an account to a given network via a given provider
 */
class Connection {
    constructor(networkId, provider, signer) {
        this.networkId = networkId;
        this.provider = provider;
        this.signer = signer;
    }
    /**
     * @param config Contains connection info details
     */
    static fromConfig(config) {
        const provider = getProvider(config.provider);
        const signer = getSigner(config.signer);
        return new Connection(config.networkId, provider, signer);
    }
}
exports.Connection = Connection;

'''
'''--- lib/constants.d.ts ---
import BN from 'bn.js';
export declare const DEFAULT_FUNCTION_CALL_GAS: BN;

'''
'''--- lib/constants.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_FUNCTION_CALL_GAS = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
// Default amount of gas to be sent with the function calls. Used to pay for the fees
// incurred while running the contract execution. The unused amount will be refunded back to
// the originator.
// Due to protocol changes that charge upfront for the maximum possible gas price inflation due to
// full blocks, the price of max_prepaid_gas is decreased to `300 * 10**12`.
// For discussion see https://github.com/nearprotocol/NEPs/issues/67
exports.DEFAULT_FUNCTION_CALL_GAS = new bn_js_1.default('30000000000000');

'''
'''--- lib/contract.d.ts ---
import { Account } from './account';
export interface ContractMethods {
    /**
     * Methods that change state. These methods cost gas and require a signed transaction.
     *
     * @see {@link Account.functionCall}
     */
    changeMethods: string[];
    /**
     * View methods do not require a signed transaction.
     *
     * @@see {@link Account.viewFunction}
     */
    viewMethods: string[];
}
/**
 * Defines a smart contract on NEAR including the change (mutable) and view (non-mutable) methods
 *
 * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#contract}
 * @example
 * ```js
 * import { Contract } from 'near-api-js';
 *
 * async function contractExample() {
 *   const methodOptions = {
 *     viewMethods: ['getMessageByAccountId'],
 *     changeMethods: ['addMessage']
 *   };
 *   const contract = new Contract(
 *     wallet.account(),
 *     'contract-id.testnet',
 *     methodOptions
 *   );
 *
 *   // use a contract view method
 *   const messages = await contract.getMessages({
 *     accountId: 'example-account.testnet'
 *   });
 *
 *   // use a contract change method
 *   await contract.addMessage({
 *      meta: 'some info',
 *      callbackUrl: 'https://example.com/callback',
 *      args: { text: 'my message' },
 *      amount: 1
 *   })
 * }
 * ```
 */
export declare class Contract {
    readonly account: Account;
    readonly contractId: string;
    /**
     * @param account NEAR account to sign change method transactions
     * @param contractId NEAR account id where the contract is deployed
     * @param options NEAR smart contract methods that your application will use. These will be available as `contract.methodName`
     */
    constructor(account: Account, contractId: string, options: ContractMethods);
    private _changeMethod;
}

'''
'''--- lib/contract.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Contract = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const depd_1 = __importDefault(require("depd"));
const providers_1 = require("./providers");
const errors_1 = require("./utils/errors");
// Makes `function.name` return given name
function nameFunction(name, body) {
    return {
        [name](...args) {
            return body(...args);
        }
    }[name];
}
const isUint8Array = (x) => x && x.byteLength !== undefined && x.byteLength === x.length;
const isObject = (x) => Object.prototype.toString.call(x) === '[object Object]';
/**
 * Defines a smart contract on NEAR including the change (mutable) and view (non-mutable) methods
 *
 * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#contract}
 * @example
 * ```js
 * import { Contract } from 'near-api-js';
 *
 * async function contractExample() {
 *   const methodOptions = {
 *     viewMethods: ['getMessageByAccountId'],
 *     changeMethods: ['addMessage']
 *   };
 *   const contract = new Contract(
 *     wallet.account(),
 *     'contract-id.testnet',
 *     methodOptions
 *   );
 *
 *   // use a contract view method
 *   const messages = await contract.getMessages({
 *     accountId: 'example-account.testnet'
 *   });
 *
 *   // use a contract change method
 *   await contract.addMessage({
 *      meta: 'some info',
 *      callbackUrl: 'https://example.com/callback',
 *      args: { text: 'my message' },
 *      amount: 1
 *   })
 * }
 * ```
 */
class Contract {
    /**
     * @param account NEAR account to sign change method transactions
     * @param contractId NEAR account id where the contract is deployed
     * @param options NEAR smart contract methods that your application will use. These will be available as `contract.methodName`
     */
    constructor(account, contractId, options) {
        this.account = account;
        this.contractId = contractId;
        const { viewMethods = [], changeMethods = [] } = options;
        viewMethods.forEach((methodName) => {
            Object.defineProperty(this, methodName, {
                writable: false,
                enumerable: true,
                value: nameFunction(methodName, async (args = {}, options = {}, ...ignored) => {
                    if (ignored.length || !(isObject(args) || isUint8Array(args)) || !isObject(options)) {
                        throw new errors_1.PositionalArgsError();
                    }
                    return this.account.viewFunction(this.contractId, methodName, args, options);
                })
            });
        });
        changeMethods.forEach((methodName) => {
            Object.defineProperty(this, methodName, {
                writable: false,
                enumerable: true,
                value: nameFunction(methodName, async (...args) => {
                    if (args.length && (args.length > 3 || !(isObject(args[0]) || isUint8Array(args[0])))) {
                        throw new errors_1.PositionalArgsError();
                    }
                    if (args.length > 1 || !(args[0] && args[0].args)) {
                        const deprecate = depd_1.default('contract.methodName(args, gas, amount)');
                        deprecate('use `contract.methodName({ args, gas?, amount?, callbackUrl?, meta? })` instead');
                        return this._changeMethod({
                            methodName,
                            args: args[0],
                            gas: args[1],
                            amount: args[2]
                        });
                    }
                    return this._changeMethod({ methodName, ...args[0] });
                })
            });
        });
    }
    async _changeMethod({ args, methodName, gas, amount, meta, callbackUrl }) {
        validateBNLike({ gas, amount });
        const rawResult = await this.account.functionCall({
            contractId: this.contractId,
            methodName,
            args,
            gas,
            attachedDeposit: amount,
            walletMeta: meta,
            walletCallbackUrl: callbackUrl
        });
        return providers_1.getTransactionLastResult(rawResult);
    }
}
exports.Contract = Contract;
/**
 * Validation on arguments being a big number from bn.js
 * Throws if an argument is not in BN format or otherwise invalid
 * @param argMap
 */
function validateBNLike(argMap) {
    const bnLike = 'number, decimal string or BN';
    for (const argName of Object.keys(argMap)) {
        const argValue = argMap[argName];
        if (argValue && !bn_js_1.default.isBN(argValue) && isNaN(argValue)) {
            throw new errors_1.ArgumentTypeError(argName, bnLike, argValue);
        }
    }
}

'''
'''--- lib/generated/rpc_error_schema.json ---
{
    "schema": {
        "BadUTF16": {
            "name": "BadUTF16",
            "subtypes": [],
            "props": {}
        },
        "BadUTF8": {
            "name": "BadUTF8",
            "subtypes": [],
            "props": {}
        },
        "BalanceExceeded": {
            "name": "BalanceExceeded",
            "subtypes": [],
            "props": {}
        },
        "BreakpointTrap": {
            "name": "BreakpointTrap",
            "subtypes": [],
            "props": {}
        },
        "CacheError": {
            "name": "CacheError",
            "subtypes": [
                "ReadError",
                "WriteError",
                "DeserializationError",
                "SerializationError"
            ],
            "props": {}
        },
        "CallIndirectOOB": {
            "name": "CallIndirectOOB",
            "subtypes": [],
            "props": {}
        },
        "CannotAppendActionToJointPromise": {
            "name": "CannotAppendActionToJointPromise",
            "subtypes": [],
            "props": {}
        },
        "CannotReturnJointPromise": {
            "name": "CannotReturnJointPromise",
            "subtypes": [],
            "props": {}
        },
        "CodeDoesNotExist": {
            "name": "CodeDoesNotExist",
            "subtypes": [],
            "props": {
                "account_id": ""
            }
        },
        "CompilationError": {
            "name": "CompilationError",
            "subtypes": [
                "CodeDoesNotExist",
                "PrepareError",
                "WasmerCompileError"
            ],
            "props": {}
        },
        "ContractSizeExceeded": {
            "name": "ContractSizeExceeded",
            "subtypes": [],
            "props": {
                "limit": "",
                "size": ""
            }
        },
        "Deprecated": {
            "name": "Deprecated",
            "subtypes": [],
            "props": {
                "method_name": ""
            }
        },
        "Deserialization": {
            "name": "Deserialization",
            "subtypes": [],
            "props": {}
        },
        "DeserializationError": {
            "name": "DeserializationError",
            "subtypes": [],
            "props": {}
        },
        "EmptyMethodName": {
            "name": "EmptyMethodName",
            "subtypes": [],
            "props": {}
        },
        "FunctionCallError": {
            "name": "FunctionCallError",
            "subtypes": [
                "CompilationError",
                "LinkError",
                "MethodResolveError",
                "WasmTrap",
                "WasmUnknownError",
                "HostError",
                "EvmError"
            ],
            "props": {}
        },
        "GasExceeded": {
            "name": "GasExceeded",
            "subtypes": [],
            "props": {}
        },
        "GasInstrumentation": {
            "name": "GasInstrumentation",
            "subtypes": [],
            "props": {}
        },
        "GasLimitExceeded": {
            "name": "GasLimitExceeded",
            "subtypes": [],
            "props": {}
        },
        "GenericTrap": {
            "name": "GenericTrap",
            "subtypes": [],
            "props": {}
        },
        "GuestPanic": {
            "name": "GuestPanic",
            "subtypes": [],
            "props": {
                "panic_msg": ""
            }
        },
        "HostError": {
            "name": "HostError",
            "subtypes": [
                "BadUTF16",
                "BadUTF8",
                "GasExceeded",
                "GasLimitExceeded",
                "BalanceExceeded",
                "EmptyMethodName",
                "GuestPanic",
                "IntegerOverflow",
                "InvalidPromiseIndex",
                "CannotAppendActionToJointPromise",
                "CannotReturnJointPromise",
                "InvalidPromiseResultIndex",
                "InvalidRegisterId",
                "IteratorWasInvalidated",
                "MemoryAccessViolation",
                "InvalidReceiptIndex",
                "InvalidIteratorIndex",
                "InvalidAccountId",
                "InvalidMethodName",
                "InvalidPublicKey",
                "ProhibitedInView",
                "NumberOfLogsExceeded",
                "KeyLengthExceeded",
                "ValueLengthExceeded",
                "TotalLogLengthExceeded",
                "NumberPromisesExceeded",
                "NumberInputDataDependenciesExceeded",
                "ReturnedValueLengthExceeded",
                "ContractSizeExceeded",
                "Deprecated"
            ],
            "props": {}
        },
        "IllegalArithmetic": {
            "name": "IllegalArithmetic",
            "subtypes": [],
            "props": {}
        },
        "IncorrectCallIndirectSignature": {
            "name": "IncorrectCallIndirectSignature",
            "subtypes": [],
            "props": {}
        },
        "Instantiate": {
            "name": "Instantiate",
            "subtypes": [],
            "props": {}
        },
        "IntegerOverflow": {
            "name": "IntegerOverflow",
            "subtypes": [],
            "props": {}
        },
        "InternalMemoryDeclared": {
            "name": "InternalMemoryDeclared",
            "subtypes": [],
            "props": {}
        },
        "InvalidAccountId": {
            "name": "InvalidAccountId",
            "subtypes": [],
            "props": {
                "account_id": ""
            }
        },
        "InvalidIteratorIndex": {
            "name": "InvalidIteratorIndex",
            "subtypes": [],
            "props": {
                "iterator_index": ""
            }
        },
        "InvalidMethodName": {
            "name": "InvalidMethodName",
            "subtypes": [],
            "props": {}
        },
        "InvalidPromiseIndex": {
            "name": "InvalidPromiseIndex",
            "subtypes": [],
            "props": {
                "promise_idx": ""
            }
        },
        "InvalidPromiseResultIndex": {
            "name": "InvalidPromiseResultIndex",
            "subtypes": [],
            "props": {
                "result_idx": ""
            }
        },
        "InvalidPublicKey": {
            "name": "InvalidPublicKey",
            "subtypes": [],
            "props": {}
        },
        "InvalidReceiptIndex": {
            "name": "InvalidReceiptIndex",
            "subtypes": [],
            "props": {
                "receipt_index": ""
            }
        },
        "InvalidRegisterId": {
            "name": "InvalidRegisterId",
            "subtypes": [],
            "props": {
                "register_id": ""
            }
        },
        "IteratorWasInvalidated": {
            "name": "IteratorWasInvalidated",
            "subtypes": [],
            "props": {
                "iterator_index": ""
            }
        },
        "KeyLengthExceeded": {
            "name": "KeyLengthExceeded",
            "subtypes": [],
            "props": {
                "length": "",
                "limit": ""
            }
        },
        "LinkError": {
            "name": "LinkError",
            "subtypes": [],
            "props": {
                "msg": ""
            }
        },
        "Memory": {
            "name": "Memory",
            "subtypes": [],
            "props": {}
        },
        "MemoryAccessViolation": {
            "name": "MemoryAccessViolation",
            "subtypes": [],
            "props": {}
        },
        "MemoryOutOfBounds": {
            "name": "MemoryOutOfBounds",
            "subtypes": [],
            "props": {}
        },
        "MethodEmptyName": {
            "name": "MethodEmptyName",
            "subtypes": [],
            "props": {}
        },
        "MethodInvalidSignature": {
            "name": "MethodInvalidSignature",
            "subtypes": [],
            "props": {}
        },
        "MethodNotFound": {
            "name": "MethodNotFound",
            "subtypes": [],
            "props": {}
        },
        "MethodResolveError": {
            "name": "MethodResolveError",
            "subtypes": [
                "MethodEmptyName",
                "MethodUTF8Error",
                "MethodNotFound",
                "MethodInvalidSignature"
            ],
            "props": {}
        },
        "MethodUTF8Error": {
            "name": "MethodUTF8Error",
            "subtypes": [],
            "props": {}
        },
        "MisalignedAtomicAccess": {
            "name": "MisalignedAtomicAccess",
            "subtypes": [],
            "props": {}
        },
        "NumberInputDataDependenciesExceeded": {
            "name": "NumberInputDataDependenciesExceeded",
            "subtypes": [],
            "props": {
                "limit": "",
                "number_of_input_data_dependencies": ""
            }
        },
        "NumberOfLogsExceeded": {
            "name": "NumberOfLogsExceeded",
            "subtypes": [],
            "props": {
                "limit": ""
            }
        },
        "NumberPromisesExceeded": {
            "name": "NumberPromisesExceeded",
            "subtypes": [],
            "props": {
                "limit": "",
                "number_of_promises": ""
            }
        },
        "PrepareError": {
            "name": "PrepareError",
            "subtypes": [
                "Serialization",
                "Deserialization",
                "InternalMemoryDeclared",
                "GasInstrumentation",
                "StackHeightInstrumentation",
                "Instantiate",
                "Memory"
            ],
            "props": {}
        },
        "ProhibitedInView": {
            "name": "ProhibitedInView",
            "subtypes": [],
            "props": {
                "method_name": ""
            }
        },
        "ReadError": {
            "name": "ReadError",
            "subtypes": [],
            "props": {}
        },
        "ReturnedValueLengthExceeded": {
            "name": "ReturnedValueLengthExceeded",
            "subtypes": [],
            "props": {
                "length": "",
                "limit": ""
            }
        },
        "Serialization": {
            "name": "Serialization",
            "subtypes": [],
            "props": {}
        },
        "SerializationError": {
            "name": "SerializationError",
            "subtypes": [],
            "props": {
                "hash": ""
            }
        },
        "StackHeightInstrumentation": {
            "name": "StackHeightInstrumentation",
            "subtypes": [],
            "props": {}
        },
        "StackOverflow": {
            "name": "StackOverflow",
            "subtypes": [],
            "props": {}
        },
        "TotalLogLengthExceeded": {
            "name": "TotalLogLengthExceeded",
            "subtypes": [],
            "props": {
                "length": "",
                "limit": ""
            }
        },
        "Unreachable": {
            "name": "Unreachable",
            "subtypes": [],
            "props": {}
        },
        "ValueLengthExceeded": {
            "name": "ValueLengthExceeded",
            "subtypes": [],
            "props": {
                "length": "",
                "limit": ""
            }
        },
        "WasmTrap": {
            "name": "WasmTrap",
            "subtypes": [
                "Unreachable",
                "IncorrectCallIndirectSignature",
                "MemoryOutOfBounds",
                "CallIndirectOOB",
                "IllegalArithmetic",
                "MisalignedAtomicAccess",
                "BreakpointTrap",
                "StackOverflow",
                "GenericTrap"
            ],
            "props": {}
        },
        "WasmUnknownError": {
            "name": "WasmUnknownError",
            "subtypes": [],
            "props": {}
        },
        "WasmerCompileError": {
            "name": "WasmerCompileError",
            "subtypes": [],
            "props": {
                "msg": ""
            }
        },
        "WriteError": {
            "name": "WriteError",
            "subtypes": [],
            "props": {}
        },
        "AccessKeyNotFound": {
            "name": "AccessKeyNotFound",
            "subtypes": [],
            "props": {
                "account_id": "",
                "public_key": ""
            }
        },
        "AccountAlreadyExists": {
            "name": "AccountAlreadyExists",
            "subtypes": [],
            "props": {
                "account_id": ""
            }
        },
        "AccountDoesNotExist": {
            "name": "AccountDoesNotExist",
            "subtypes": [],
            "props": {
                "account_id": ""
            }
        },
        "ActionError": {
            "name": "ActionError",
            "subtypes": [
                "AccountAlreadyExists",
                "AccountDoesNotExist",
                "CreateAccountOnlyByRegistrar",
                "CreateAccountNotAllowed",
                "ActorNoPermission",
                "DeleteKeyDoesNotExist",
                "AddKeyAlreadyExists",
                "DeleteAccountStaking",
                "LackBalanceForState",
                "TriesToUnstake",
                "TriesToStake",
                "InsufficientStake",
                "FunctionCallError",
                "NewReceiptValidationError",
                "OnlyImplicitAccountCreationAllowed"
            ],
            "props": {
                "index": ""
            }
        },
        "ActionsValidationError": {
            "name": "ActionsValidationError",
            "subtypes": [
                "DeleteActionMustBeFinal",
                "TotalPrepaidGasExceeded",
                "TotalNumberOfActionsExceeded",
                "AddKeyMethodNamesNumberOfBytesExceeded",
                "AddKeyMethodNameLengthExceeded",
                "IntegerOverflow",
                "InvalidAccountId",
                "ContractSizeExceeded",
                "FunctionCallMethodNameLengthExceeded",
                "FunctionCallArgumentsLengthExceeded",
                "UnsuitableStakingKey",
                "FunctionCallZeroAttachedGas"
            ],
            "props": {}
        },
        "ActorNoPermission": {
            "name": "ActorNoPermission",
            "subtypes": [],
            "props": {
                "account_id": "",
                "actor_id": ""
            }
        },
        "AddKeyAlreadyExists": {
            "name": "AddKeyAlreadyExists",
            "subtypes": [],
            "props": {
                "account_id": "",
                "public_key": ""
            }
        },
        "AddKeyMethodNameLengthExceeded": {
            "name": "AddKeyMethodNameLengthExceeded",
            "subtypes": [],
            "props": {
                "length": "",
                "limit": ""
            }
        },
        "AddKeyMethodNamesNumberOfBytesExceeded": {
            "name": "AddKeyMethodNamesNumberOfBytesExceeded",
            "subtypes": [],
            "props": {
                "limit": "",
                "total_number_of_bytes": ""
            }
        },
        "BalanceMismatchError": {
            "name": "BalanceMismatchError",
            "subtypes": [],
            "props": {
                "final_accounts_balance": "",
                "final_postponed_receipts_balance": "",
                "incoming_receipts_balance": "",
                "incoming_validator_rewards": "",
                "initial_accounts_balance": "",
                "initial_postponed_receipts_balance": "",
                "new_delayed_receipts_balance": "",
                "other_burnt_amount": "",
                "outgoing_receipts_balance": "",
                "processed_delayed_receipts_balance": "",
                "slashed_burnt_amount": "",
                "tx_burnt_amount": ""
            }
        },
        "CostOverflow": {
            "name": "CostOverflow",
            "subtypes": [],
            "props": {}
        },
        "CreateAccountNotAllowed": {
            "name": "CreateAccountNotAllowed",
            "subtypes": [],
            "props": {
                "account_id": "",
                "predecessor_id": ""
            }
        },
        "CreateAccountOnlyByRegistrar": {
            "name": "CreateAccountOnlyByRegistrar",
            "subtypes": [],
            "props": {
                "account_id": "",
                "predecessor_id": "",
                "registrar_account_id": ""
            }
        },
        "DeleteAccountStaking": {
            "name": "DeleteAccountStaking",
            "subtypes": [],
            "props": {
                "account_id": ""
            }
        },
        "DeleteActionMustBeFinal": {
            "name": "DeleteActionMustBeFinal",
            "subtypes": [],
            "props": {}
        },
        "DeleteKeyDoesNotExist": {
            "name": "DeleteKeyDoesNotExist",
            "subtypes": [],
            "props": {
                "account_id": "",
                "public_key": ""
            }
        },
        "DepositWithFunctionCall": {
            "name": "DepositWithFunctionCall",
            "subtypes": [],
            "props": {}
        },
        "Expired": {
            "name": "Expired",
            "subtypes": [],
            "props": {}
        },
        "FunctionCallArgumentsLengthExceeded": {
            "name": "FunctionCallArgumentsLengthExceeded",
            "subtypes": [],
            "props": {
                "length": "",
                "limit": ""
            }
        },
        "FunctionCallMethodNameLengthExceeded": {
            "name": "FunctionCallMethodNameLengthExceeded",
            "subtypes": [],
            "props": {
                "length": "",
                "limit": ""
            }
        },
        "FunctionCallZeroAttachedGas": {
            "name": "FunctionCallZeroAttachedGas",
            "subtypes": [],
            "props": {}
        },
        "InsufficientStake": {
            "name": "InsufficientStake",
            "subtypes": [],
            "props": {
                "account_id": "",
                "minimum_stake": "",
                "stake": ""
            }
        },
        "InvalidAccessKeyError": {
            "name": "InvalidAccessKeyError",
            "subtypes": [
                "AccessKeyNotFound",
                "ReceiverMismatch",
                "MethodNameMismatch",
                "RequiresFullAccess",
                "NotEnoughAllowance",
                "DepositWithFunctionCall"
            ],
            "props": {}
        },
        "InvalidChain": {
            "name": "InvalidChain",
            "subtypes": [],
            "props": {}
        },
        "InvalidDataReceiverId": {
            "name": "InvalidDataReceiverId",
            "subtypes": [],
            "props": {
                "account_id": ""
            }
        },
        "InvalidNonce": {
            "name": "InvalidNonce",
            "subtypes": [],
            "props": {
                "ak_nonce": "",
                "tx_nonce": ""
            }
        },
        "InvalidPredecessorId": {
            "name": "InvalidPredecessorId",
            "subtypes": [],
            "props": {
                "account_id": ""
            }
        },
        "InvalidReceiverId": {
            "name": "InvalidReceiverId",
            "subtypes": [],
            "props": {
                "account_id": ""
            }
        },
        "InvalidSignature": {
            "name": "InvalidSignature",
            "subtypes": [],
            "props": {}
        },
        "InvalidSignerId": {
            "name": "InvalidSignerId",
            "subtypes": [],
            "props": {
                "account_id": ""
            }
        },
        "InvalidTxError": {
            "name": "InvalidTxError",
            "subtypes": [
                "InvalidAccessKeyError",
                "InvalidSignerId",
                "SignerDoesNotExist",
                "InvalidNonce",
                "InvalidReceiverId",
                "InvalidSignature",
                "NotEnoughBalance",
                "LackBalanceForState",
                "CostOverflow",
                "InvalidChain",
                "Expired",
                "ActionsValidation"
            ],
            "props": {}
        },
        "LackBalanceForState": {
            "name": "LackBalanceForState",
            "subtypes": [],
            "props": {
                "account_id": "",
                "amount": ""
            }
        },
        "MethodNameMismatch": {
            "name": "MethodNameMismatch",
            "subtypes": [],
            "props": {
                "method_name": ""
            }
        },
        "NotEnoughAllowance": {
            "name": "NotEnoughAllowance",
            "subtypes": [],
            "props": {
                "account_id": "",
                "allowance": "",
                "cost": "",
                "public_key": ""
            }
        },
        "NotEnoughBalance": {
            "name": "NotEnoughBalance",
            "subtypes": [],
            "props": {
                "balance": "",
                "cost": "",
                "signer_id": ""
            }
        },
        "OnlyImplicitAccountCreationAllowed": {
            "name": "OnlyImplicitAccountCreationAllowed",
            "subtypes": [],
            "props": {
                "account_id": ""
            }
        },
        "ReceiptValidationError": {
            "name": "ReceiptValidationError",
            "subtypes": [
                "InvalidPredecessorId",
                "InvalidReceiverId",
                "InvalidSignerId",
                "InvalidDataReceiverId",
                "ReturnedValueLengthExceeded",
                "NumberInputDataDependenciesExceeded",
                "ActionsValidation"
            ],
            "props": {}
        },
        "ReceiverMismatch": {
            "name": "ReceiverMismatch",
            "subtypes": [],
            "props": {
                "ak_receiver": "",
                "tx_receiver": ""
            }
        },
        "RequiresFullAccess": {
            "name": "RequiresFullAccess",
            "subtypes": [],
            "props": {}
        },
        "SignerDoesNotExist": {
            "name": "SignerDoesNotExist",
            "subtypes": [],
            "props": {
                "signer_id": ""
            }
        },
        "TotalNumberOfActionsExceeded": {
            "name": "TotalNumberOfActionsExceeded",
            "subtypes": [],
            "props": {
                "limit": "",
                "total_number_of_actions": ""
            }
        },
        "TotalPrepaidGasExceeded": {
            "name": "TotalPrepaidGasExceeded",
            "subtypes": [],
            "props": {
                "limit": "",
                "total_prepaid_gas": ""
            }
        },
        "TriesToStake": {
            "name": "TriesToStake",
            "subtypes": [],
            "props": {
                "account_id": "",
                "balance": "",
                "locked": "",
                "stake": ""
            }
        },
        "TriesToUnstake": {
            "name": "TriesToUnstake",
            "subtypes": [],
            "props": {
                "account_id": ""
            }
        },
        "TxExecutionError": {
            "name": "TxExecutionError",
            "subtypes": [
                "ActionError",
                "InvalidTxError"
            ],
            "props": {}
        },
        "UnsuitableStakingKey": {
            "name": "UnsuitableStakingKey",
            "subtypes": [],
            "props": {
                "public_key": ""
            }
        },
        "Closed": {
            "name": "Closed",
            "subtypes": [],
            "props": {}
        },
        "InternalError": {
            "name": "InternalError",
            "subtypes": [],
            "props": {}
        },
        "ServerError": {
            "name": "ServerError",
            "subtypes": [
                "TxExecutionError",
                "Timeout",
                "Closed",
                "InternalError"
            ],
            "props": {}
        },
        "Timeout": {
            "name": "Timeout",
            "subtypes": [],
            "props": {}
        }
    }
}

'''
'''--- lib/index.d.ts ---
/** @ignore @module */
export * as keyStores from './key_stores/index';
export * from './common-index';
export * from './connect';
export * from './constants';

'''
'''--- lib/index.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
/** @ignore @module */
exports.keyStores = __importStar(require("./key_stores/index"));
__exportStar(require("./common-index"), exports);
__exportStar(require("./connect"), exports);
__exportStar(require("./constants"), exports);

'''
'''--- lib/key_stores/browser-index.d.ts ---
/** @hidden @module */
import { KeyStore } from './keystore';
import { InMemoryKeyStore } from './in_memory_key_store';
import { BrowserLocalStorageKeyStore } from './browser_local_storage_key_store';
import { MergeKeyStore } from './merge_key_store';
export { KeyStore, InMemoryKeyStore, BrowserLocalStorageKeyStore, MergeKeyStore, };

'''
'''--- lib/key_stores/browser-index.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MergeKeyStore = exports.BrowserLocalStorageKeyStore = exports.InMemoryKeyStore = exports.KeyStore = void 0;
/** @hidden @module */
const keystore_1 = require("./keystore");
Object.defineProperty(exports, "KeyStore", { enumerable: true, get: function () { return keystore_1.KeyStore; } });
const in_memory_key_store_1 = require("./in_memory_key_store");
Object.defineProperty(exports, "InMemoryKeyStore", { enumerable: true, get: function () { return in_memory_key_store_1.InMemoryKeyStore; } });
const browser_local_storage_key_store_1 = require("./browser_local_storage_key_store");
Object.defineProperty(exports, "BrowserLocalStorageKeyStore", { enumerable: true, get: function () { return browser_local_storage_key_store_1.BrowserLocalStorageKeyStore; } });
const merge_key_store_1 = require("./merge_key_store");
Object.defineProperty(exports, "MergeKeyStore", { enumerable: true, get: function () { return merge_key_store_1.MergeKeyStore; } });

'''
'''--- lib/key_stores/browser_local_storage_key_store.d.ts ---
import { KeyStore } from './keystore';
import { KeyPair } from '../utils/key_pair';
/**
 * This class is used to store keys in the browsers local storage.
 *
 * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#key-store}
 * @example
 * ```js
 * import { connect, keyStores } from 'near-api-js';
 *
 * const keyStore = new keyStores.BrowserLocalStorageKeyStore();
 * const config = {
 *   keyStore, // instance of BrowserLocalStorageKeyStore
 *   networkId: 'testnet',
 *   nodeUrl: 'https://rpc.testnet.near.org',
 *   walletUrl: 'https://wallet.testnet.near.org',
 *   helperUrl: 'https://helper.testnet.near.org',
 *   explorerUrl: 'https://explorer.testnet.near.org'
 * };
 *
 * // inside an async function
 * const near = await connect(config)
 * ```
 */
export declare class BrowserLocalStorageKeyStore extends KeyStore {
    /** @hidden */
    private localStorage;
    /** @hidden */
    private prefix;
    /**
     * @param localStorage defaults to window.localStorage
     * @param prefix defaults to `near-api-js:keystore:`
     */
    constructor(localStorage?: any, prefix?: string);
    /**
     * Stores a {@link KeyPair} in local storage.
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     * @param keyPair The key pair to store in local storage
     */
    setKey(networkId: string, accountId: string, keyPair: KeyPair): Promise<void>;
    /**
     * Gets a {@link KeyPair} from local storage
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     * @returns {Promise<KeyPair>}
     */
    getKey(networkId: string, accountId: string): Promise<KeyPair>;
    /**
     * Removes a {@link KeyPair} from local storage
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     */
    removeKey(networkId: string, accountId: string): Promise<void>;
    /**
     * Removes all items that start with `prefix` from local storage
     */
    clear(): Promise<void>;
    /**
     * Get the network(s) from local storage
     * @returns {Promise<string[]>}
     */
    getNetworks(): Promise<string[]>;
    /**
     * Gets the account(s) from local storage
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @returns{Promise<string[]>}
     */
    getAccounts(networkId: string): Promise<string[]>;
    /**
     * @hidden
     * Helper function to retrieve a local storage key
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the storage keythat's sought
     * @returns {string} An example might be: `near-api-js:keystore:near-friend:default`
     */
    private storageKeyForSecretKey;
    /** @hidden */
    private storageKeys;
}

'''
'''--- lib/key_stores/browser_local_storage_key_store.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrowserLocalStorageKeyStore = void 0;
const keystore_1 = require("./keystore");
const key_pair_1 = require("../utils/key_pair");
const LOCAL_STORAGE_KEY_PREFIX = 'near-api-js:keystore:';
/**
 * This class is used to store keys in the browsers local storage.
 *
 * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#key-store}
 * @example
 * ```js
 * import { connect, keyStores } from 'near-api-js';
 *
 * const keyStore = new keyStores.BrowserLocalStorageKeyStore();
 * const config = {
 *   keyStore, // instance of BrowserLocalStorageKeyStore
 *   networkId: 'testnet',
 *   nodeUrl: 'https://rpc.testnet.near.org',
 *   walletUrl: 'https://wallet.testnet.near.org',
 *   helperUrl: 'https://helper.testnet.near.org',
 *   explorerUrl: 'https://explorer.testnet.near.org'
 * };
 *
 * // inside an async function
 * const near = await connect(config)
 * ```
 */
class BrowserLocalStorageKeyStore extends keystore_1.KeyStore {
    /**
     * @param localStorage defaults to window.localStorage
     * @param prefix defaults to `near-api-js:keystore:`
     */
    constructor(localStorage = window.localStorage, prefix = LOCAL_STORAGE_KEY_PREFIX) {
        super();
        this.localStorage = localStorage;
        this.prefix = prefix;
    }
    /**
     * Stores a {@link KeyPair} in local storage.
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     * @param keyPair The key pair to store in local storage
     */
    async setKey(networkId, accountId, keyPair) {
        this.localStorage.setItem(this.storageKeyForSecretKey(networkId, accountId), keyPair.toString());
    }
    /**
     * Gets a {@link KeyPair} from local storage
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     * @returns {Promise<KeyPair>}
     */
    async getKey(networkId, accountId) {
        const value = this.localStorage.getItem(this.storageKeyForSecretKey(networkId, accountId));
        if (!value) {
            return null;
        }
        return key_pair_1.KeyPair.fromString(value);
    }
    /**
     * Removes a {@link KeyPair} from local storage
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     */
    async removeKey(networkId, accountId) {
        this.localStorage.removeItem(this.storageKeyForSecretKey(networkId, accountId));
    }
    /**
     * Removes all items that start with `prefix` from local storage
     */
    async clear() {
        for (const key of this.storageKeys()) {
            if (key.startsWith(this.prefix)) {
                this.localStorage.removeItem(key);
            }
        }
    }
    /**
     * Get the network(s) from local storage
     * @returns {Promise<string[]>}
     */
    async getNetworks() {
        const result = new Set();
        for (const key of this.storageKeys()) {
            if (key.startsWith(this.prefix)) {
                const parts = key.substring(this.prefix.length).split(':');
                result.add(parts[1]);
            }
        }
        return Array.from(result.values());
    }
    /**
     * Gets the account(s) from local storage
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @returns{Promise<string[]>}
     */
    async getAccounts(networkId) {
        const result = new Array();
        for (const key of this.storageKeys()) {
            if (key.startsWith(this.prefix)) {
                const parts = key.substring(this.prefix.length).split(':');
                if (parts[1] === networkId) {
                    result.push(parts[0]);
                }
            }
        }
        return result;
    }
    /**
     * @hidden
     * Helper function to retrieve a local storage key
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the storage keythat's sought
     * @returns {string} An example might be: `near-api-js:keystore:near-friend:default`
     */
    storageKeyForSecretKey(networkId, accountId) {
        return `${this.prefix}${accountId}:${networkId}`;
    }
    /** @hidden */
    *storageKeys() {
        for (let i = 0; i < this.localStorage.length; i++) {
            yield this.localStorage.key(i);
        }
    }
}
exports.BrowserLocalStorageKeyStore = BrowserLocalStorageKeyStore;

'''
'''--- lib/key_stores/in_memory_key_store.d.ts ---
import { KeyStore } from './keystore';
import { KeyPair } from '../utils/key_pair';
/**
 * Simple in-memory keystore for mainly for testing purposes.
 *
 * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#key-store}
 * @example
 * ```js
 * import { connect, keyStores, utils } from 'near-api-js';
 *
 * const privateKey = '.......';
 * const keyPair = utils.KeyPair.fromString(privateKey);
 *
 * const keyStore = new keyStores.InMemoryKeyStore();
 * keyStore.setKey('testnet', 'example-account.testnet', keyPair);
 *
 * const config = {
 *   keyStore, // instance of InMemoryKeyStore
 *   networkId: 'testnet',
 *   nodeUrl: 'https://rpc.testnet.near.org',
 *   walletUrl: 'https://wallet.testnet.near.org',
 *   helperUrl: 'https://helper.testnet.near.org',
 *   explorerUrl: 'https://explorer.testnet.near.org'
 * };
 *
 * // inside an async function
 * const near = await connect(config)
 * ```
 */
export declare class InMemoryKeyStore extends KeyStore {
    /** @hidden */
    private keys;
    constructor();
    /**
     * Stores a {@KeyPair} in in-memory storage item
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     * @param keyPair The key pair to store in local storage
     */
    setKey(networkId: string, accountId: string, keyPair: KeyPair): Promise<void>;
    /**
     * Gets a {@link KeyPair} from in-memory storage
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     * @returns {Promise<KeyPair>}
     */
    getKey(networkId: string, accountId: string): Promise<KeyPair>;
    /**
     * Removes a {@link KeyPair} from in-memory storage
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     */
    removeKey(networkId: string, accountId: string): Promise<void>;
    /**
     * Removes all {@link KeyPairs} from in-memory storage
     */
    clear(): Promise<void>;
    /**
     * Get the network(s) from in-memory storage
     * @returns {Promise<string[]>}
     */
    getNetworks(): Promise<string[]>;
    /**
     * Gets the account(s) from in-memory storage
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @returns{Promise<string[]>}
     */
    getAccounts(networkId: string): Promise<string[]>;
    /** @hidden */
    toString(): string;
}

'''
'''--- lib/key_stores/in_memory_key_store.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InMemoryKeyStore = void 0;
const keystore_1 = require("./keystore");
const key_pair_1 = require("../utils/key_pair");
/**
 * Simple in-memory keystore for mainly for testing purposes.
 *
 * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#key-store}
 * @example
 * ```js
 * import { connect, keyStores, utils } from 'near-api-js';
 *
 * const privateKey = '.......';
 * const keyPair = utils.KeyPair.fromString(privateKey);
 *
 * const keyStore = new keyStores.InMemoryKeyStore();
 * keyStore.setKey('testnet', 'example-account.testnet', keyPair);
 *
 * const config = {
 *   keyStore, // instance of InMemoryKeyStore
 *   networkId: 'testnet',
 *   nodeUrl: 'https://rpc.testnet.near.org',
 *   walletUrl: 'https://wallet.testnet.near.org',
 *   helperUrl: 'https://helper.testnet.near.org',
 *   explorerUrl: 'https://explorer.testnet.near.org'
 * };
 *
 * // inside an async function
 * const near = await connect(config)
 * ```
 */
class InMemoryKeyStore extends keystore_1.KeyStore {
    constructor() {
        super();
        this.keys = {};
    }
    /**
     * Stores a {@KeyPair} in in-memory storage item
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     * @param keyPair The key pair to store in local storage
     */
    async setKey(networkId, accountId, keyPair) {
        this.keys[`${accountId}:${networkId}`] = keyPair.toString();
    }
    /**
     * Gets a {@link KeyPair} from in-memory storage
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     * @returns {Promise<KeyPair>}
     */
    async getKey(networkId, accountId) {
        const value = this.keys[`${accountId}:${networkId}`];
        if (!value) {
            return null;
        }
        return key_pair_1.KeyPair.fromString(value);
    }
    /**
     * Removes a {@link KeyPair} from in-memory storage
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     */
    async removeKey(networkId, accountId) {
        delete this.keys[`${accountId}:${networkId}`];
    }
    /**
     * Removes all {@link KeyPairs} from in-memory storage
     */
    async clear() {
        this.keys = {};
    }
    /**
     * Get the network(s) from in-memory storage
     * @returns {Promise<string[]>}
     */
    async getNetworks() {
        const result = new Set();
        Object.keys(this.keys).forEach((key) => {
            const parts = key.split(':');
            result.add(parts[1]);
        });
        return Array.from(result.values());
    }
    /**
     * Gets the account(s) from in-memory storage
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @returns{Promise<string[]>}
     */
    async getAccounts(networkId) {
        const result = new Array();
        Object.keys(this.keys).forEach((key) => {
            const parts = key.split(':');
            if (parts[parts.length - 1] === networkId) {
                result.push(parts.slice(0, parts.length - 1).join(':'));
            }
        });
        return result;
    }
    /** @hidden */
    toString() {
        return 'InMemoryKeyStore';
    }
}
exports.InMemoryKeyStore = InMemoryKeyStore;

'''
'''--- lib/key_stores/index.d.ts ---
/** @ignore @module */
import { KeyStore } from './keystore';
import { InMemoryKeyStore } from './in_memory_key_store';
import { BrowserLocalStorageKeyStore } from './browser_local_storage_key_store';
import { UnencryptedFileSystemKeyStore } from './unencrypted_file_system_keystore';
import { MergeKeyStore } from './merge_key_store';
export { KeyStore, InMemoryKeyStore, BrowserLocalStorageKeyStore, UnencryptedFileSystemKeyStore, MergeKeyStore, };

'''
'''--- lib/key_stores/index.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MergeKeyStore = exports.UnencryptedFileSystemKeyStore = exports.BrowserLocalStorageKeyStore = exports.InMemoryKeyStore = exports.KeyStore = void 0;
/** @ignore @module */
const keystore_1 = require("./keystore");
Object.defineProperty(exports, "KeyStore", { enumerable: true, get: function () { return keystore_1.KeyStore; } });
const in_memory_key_store_1 = require("./in_memory_key_store");
Object.defineProperty(exports, "InMemoryKeyStore", { enumerable: true, get: function () { return in_memory_key_store_1.InMemoryKeyStore; } });
const browser_local_storage_key_store_1 = require("./browser_local_storage_key_store");
Object.defineProperty(exports, "BrowserLocalStorageKeyStore", { enumerable: true, get: function () { return browser_local_storage_key_store_1.BrowserLocalStorageKeyStore; } });
const unencrypted_file_system_keystore_1 = require("./unencrypted_file_system_keystore");
Object.defineProperty(exports, "UnencryptedFileSystemKeyStore", { enumerable: true, get: function () { return unencrypted_file_system_keystore_1.UnencryptedFileSystemKeyStore; } });
const merge_key_store_1 = require("./merge_key_store");
Object.defineProperty(exports, "MergeKeyStore", { enumerable: true, get: function () { return merge_key_store_1.MergeKeyStore; } });

'''
'''--- lib/key_stores/keystore.d.ts ---
import { KeyPair } from '../utils/key_pair';
/**
 * KeyStores are passed to {@link Near} via {@link NearConfig}
 * and are used by the {@link InMemorySigner} to sign transactions.
 *
 * @example {@link connect}
 */
export declare abstract class KeyStore {
    abstract setKey(networkId: string, accountId: string, keyPair: KeyPair): Promise<void>;
    abstract getKey(networkId: string, accountId: string): Promise<KeyPair>;
    abstract removeKey(networkId: string, accountId: string): Promise<void>;
    abstract clear(): Promise<void>;
    abstract getNetworks(): Promise<string[]>;
    abstract getAccounts(networkId: string): Promise<string[]>;
}

'''
'''--- lib/key_stores/keystore.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyStore = void 0;
/**
 * KeyStores are passed to {@link Near} via {@link NearConfig}
 * and are used by the {@link InMemorySigner} to sign transactions.
 *
 * @example {@link connect}
 */
class KeyStore {
}
exports.KeyStore = KeyStore;

'''
'''--- lib/key_stores/merge_key_store.d.ts ---
import { KeyStore } from './keystore';
import { KeyPair } from '../utils/key_pair';
/**
 * Keystore which can be used to merge multiple key stores into one virtual key store.
 *
 * @example
 * ```js
 * const { homedir } = require('os');
 * import { connect, keyStores, utils } from 'near-api-js';
 *
 * const privateKey = '.......';
 * const keyPair = utils.KeyPair.fromString(privateKey);
 *
 * const inMemoryKeyStore = new keyStores.InMemoryKeyStore();
 * inMemoryKeyStore.setKey('testnet', 'example-account.testnet', keyPair);
 *
 * const fileSystemKeyStore = new keyStores.UnencryptedFileSystemKeyStore(`${homedir()}/.near-credentials`);
 *
 * const keyStore = new MergeKeyStore([
 *   inMemoryKeyStore,
 *   fileSystemKeyStore
 * ]);
 * const config = {
 *   keyStore, // instance of MergeKeyStore
 *   networkId: 'testnet',
 *   nodeUrl: 'https://rpc.testnet.near.org',
 *   walletUrl: 'https://wallet.testnet.near.org',
 *   helperUrl: 'https://helper.testnet.near.org',
 *   explorerUrl: 'https://explorer.testnet.near.org'
 * };
 *
 * // inside an async function
 * const near = await connect(config)
 * ```
 */
interface MergeKeyStoreOptions {
    writeKeyStoreIndex: number;
}
export declare class MergeKeyStore extends KeyStore {
    private options;
    keyStores: KeyStore[];
    /**
     * @param keyStores read calls are attempted from start to end of array
     * @param options.writeKeyStoreIndex the keystore index that will receive all write calls
     */
    constructor(keyStores: KeyStore[], options?: MergeKeyStoreOptions);
    /**
     * Store a {@link KeyPain} to the first index of a key store array
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     * @param keyPair The key pair to store in local storage
     */
    setKey(networkId: string, accountId: string, keyPair: KeyPair): Promise<void>;
    /**
     * Gets a {@link KeyPair} from the array of key stores
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     * @returns {Promise<KeyPair>}
     */
    getKey(networkId: string, accountId: string): Promise<KeyPair>;
    /**
     * Removes a {@link KeyPair} from the array of key stores
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     */
    removeKey(networkId: string, accountId: string): Promise<void>;
    /**
     * Removes all items from each key store
     */
    clear(): Promise<void>;
    /**
     * Get the network(s) from the array of key stores
     * @returns {Promise<string[]>}
     */
    getNetworks(): Promise<string[]>;
    /**
     * Gets the account(s) from the array of key stores
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @returns{Promise<string[]>}
     */
    getAccounts(networkId: string): Promise<string[]>;
    /** @hidden */
    toString(): string;
}
export {};

'''
'''--- lib/key_stores/merge_key_store.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MergeKeyStore = void 0;
const keystore_1 = require("./keystore");
class MergeKeyStore extends keystore_1.KeyStore {
    /**
     * @param keyStores read calls are attempted from start to end of array
     * @param options.writeKeyStoreIndex the keystore index that will receive all write calls
     */
    constructor(keyStores, options = { writeKeyStoreIndex: 0 }) {
        super();
        this.options = options;
        this.keyStores = keyStores;
    }
    /**
     * Store a {@link KeyPain} to the first index of a key store array
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     * @param keyPair The key pair to store in local storage
     */
    async setKey(networkId, accountId, keyPair) {
        await this.keyStores[this.options.writeKeyStoreIndex].setKey(networkId, accountId, keyPair);
    }
    /**
     * Gets a {@link KeyPair} from the array of key stores
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     * @returns {Promise<KeyPair>}
     */
    async getKey(networkId, accountId) {
        for (const keyStore of this.keyStores) {
            const keyPair = await keyStore.getKey(networkId, accountId);
            if (keyPair) {
                return keyPair;
            }
        }
        return null;
    }
    /**
     * Removes a {@link KeyPair} from the array of key stores
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     */
    async removeKey(networkId, accountId) {
        for (const keyStore of this.keyStores) {
            await keyStore.removeKey(networkId, accountId);
        }
    }
    /**
     * Removes all items from each key store
     */
    async clear() {
        for (const keyStore of this.keyStores) {
            await keyStore.clear();
        }
    }
    /**
     * Get the network(s) from the array of key stores
     * @returns {Promise<string[]>}
     */
    async getNetworks() {
        const result = new Set();
        for (const keyStore of this.keyStores) {
            for (const network of await keyStore.getNetworks()) {
                result.add(network);
            }
        }
        return Array.from(result);
    }
    /**
     * Gets the account(s) from the array of key stores
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @returns{Promise<string[]>}
     */
    async getAccounts(networkId) {
        const result = new Set();
        for (const keyStore of this.keyStores) {
            for (const account of await keyStore.getAccounts(networkId)) {
                result.add(account);
            }
        }
        return Array.from(result);
    }
    /** @hidden */
    toString() {
        return `MergeKeyStore(${this.keyStores.join(', ')})`;
    }
}
exports.MergeKeyStore = MergeKeyStore;

'''
'''--- lib/key_stores/unencrypted_file_system_keystore.d.ts ---
import { KeyPair } from '../utils/key_pair';
import { KeyStore } from './keystore';
/** @hidden */
export declare function loadJsonFile(filename: string): Promise<any>;
/** @hidden */
export declare function readKeyFile(filename: string): Promise<[string, KeyPair]>;
/**
 * This module contains the {@link UnencryptedFileSystemKeyStore} class which is used to store keys on the file system.
 *
 * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#key-store}
 * @example
 * ```js
 * const { homedir } = require('os');
 * const { connect, keyStores } = require('near-api-js');
 *
 * const keyStore = new keyStores.UnencryptedFileSystemKeyStore(`${homedir()}/.near-credentials`);
 * const config = {
 *   keyStore, // instance of UnencryptedFileSystemKeyStore
 *   networkId: 'testnet',
 *   nodeUrl: 'https://rpc.testnet.near.org',
 *   walletUrl: 'https://wallet.testnet.near.org',
 *   helperUrl: 'https://helper.testnet.near.org',
 *   explorerUrl: 'https://explorer.testnet.near.org'
 * };
 *
 * // inside an async function
 * const near = await connect(config)
 * ```
 */
export declare class UnencryptedFileSystemKeyStore extends KeyStore {
    /** @hidden */
    readonly keyDir: string;
    /**
     * @param keyDir base directory for key storage. Keys will be stored in `keyDir/networkId/accountId.json`
     */
    constructor(keyDir: string);
    /**
     * Store a {@link KeyPair} in an unencrypted file
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     * @param keyPair The key pair to store in local storage
     */
    setKey(networkId: string, accountId: string, keyPair: KeyPair): Promise<void>;
    /**
     * Gets a {@link KeyPair} from an unencrypted file
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     * @returns {Promise<KeyPair>}
     */
    getKey(networkId: string, accountId: string): Promise<KeyPair>;
    /**
     * Deletes an unencrypted file holding a {@link KeyPair}
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     */
    removeKey(networkId: string, accountId: string): Promise<void>;
    /**
     * Deletes all unencrypted files from the `keyDir` path.
     */
    clear(): Promise<void>;
    /** @hidden */
    private getKeyFilePath;
    /**
     * Get the network(s) from files in `keyDir`
     * @returns {Promise<string[]>}
     */
    getNetworks(): Promise<string[]>;
    /**
     * Gets the account(s) files in `keyDir/networkId`
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @returns{Promise<string[]>}
     */
    getAccounts(networkId: string): Promise<string[]>;
    /** @hidden */
    toString(): string;
}

'''
'''--- lib/key_stores/unencrypted_file_system_keystore.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnencryptedFileSystemKeyStore = exports.readKeyFile = exports.loadJsonFile = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
const key_pair_1 = require("../utils/key_pair");
const keystore_1 = require("./keystore");
const promisify = (fn) => {
    if (!fn) {
        return () => {
            throw new Error('Trying to use unimplemented function. `fs` module not available in web build?');
        };
    }
    return util_1.promisify(fn);
};
const exists = promisify(fs_1.default.exists);
const readFile = promisify(fs_1.default.readFile);
const writeFile = promisify(fs_1.default.writeFile);
const unlink = promisify(fs_1.default.unlink);
const readdir = promisify(fs_1.default.readdir);
const mkdir = promisify(fs_1.default.mkdir);
/** @hidden */
async function loadJsonFile(filename) {
    const content = await readFile(filename);
    return JSON.parse(content.toString());
}
exports.loadJsonFile = loadJsonFile;
async function ensureDir(dir) {
    try {
        await mkdir(dir, { recursive: true });
    }
    catch (err) {
        if (err.code !== 'EEXIST') {
            throw err;
        }
    }
}
/** @hidden */
async function readKeyFile(filename) {
    const accountInfo = await loadJsonFile(filename);
    // The private key might be in private_key or secret_key field.
    let privateKey = accountInfo.private_key;
    if (!privateKey && accountInfo.secret_key) {
        privateKey = accountInfo.secret_key;
    }
    return [accountInfo.account_id, key_pair_1.KeyPair.fromString(privateKey)];
}
exports.readKeyFile = readKeyFile;
/**
 * This module contains the {@link UnencryptedFileSystemKeyStore} class which is used to store keys on the file system.
 *
 * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#key-store}
 * @example
 * ```js
 * const { homedir } = require('os');
 * const { connect, keyStores } = require('near-api-js');
 *
 * const keyStore = new keyStores.UnencryptedFileSystemKeyStore(`${homedir()}/.near-credentials`);
 * const config = {
 *   keyStore, // instance of UnencryptedFileSystemKeyStore
 *   networkId: 'testnet',
 *   nodeUrl: 'https://rpc.testnet.near.org',
 *   walletUrl: 'https://wallet.testnet.near.org',
 *   helperUrl: 'https://helper.testnet.near.org',
 *   explorerUrl: 'https://explorer.testnet.near.org'
 * };
 *
 * // inside an async function
 * const near = await connect(config)
 * ```
 */
class UnencryptedFileSystemKeyStore extends keystore_1.KeyStore {
    /**
     * @param keyDir base directory for key storage. Keys will be stored in `keyDir/networkId/accountId.json`
     */
    constructor(keyDir) {
        super();
        this.keyDir = path_1.default.resolve(keyDir);
    }
    /**
     * Store a {@link KeyPair} in an unencrypted file
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     * @param keyPair The key pair to store in local storage
     */
    async setKey(networkId, accountId, keyPair) {
        await ensureDir(`${this.keyDir}/${networkId}`);
        const content = { account_id: accountId, public_key: keyPair.getPublicKey().toString(), private_key: keyPair.toString() };
        await writeFile(this.getKeyFilePath(networkId, accountId), JSON.stringify(content), { mode: 0o600 });
    }
    /**
     * Gets a {@link KeyPair} from an unencrypted file
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     * @returns {Promise<KeyPair>}
     */
    async getKey(networkId, accountId) {
        // Find key / account id.
        if (!await exists(this.getKeyFilePath(networkId, accountId))) {
            return null;
        }
        const accountKeyPair = await readKeyFile(this.getKeyFilePath(networkId, accountId));
        return accountKeyPair[1];
    }
    /**
     * Deletes an unencrypted file holding a {@link KeyPair}
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     */
    async removeKey(networkId, accountId) {
        if (await exists(this.getKeyFilePath(networkId, accountId))) {
            await unlink(this.getKeyFilePath(networkId, accountId));
        }
    }
    /**
     * Deletes all unencrypted files from the `keyDir` path.
     */
    async clear() {
        for (const network of await this.getNetworks()) {
            for (const account of await this.getAccounts(network)) {
                await this.removeKey(network, account);
            }
        }
    }
    /** @hidden */
    getKeyFilePath(networkId, accountId) {
        return `${this.keyDir}/${networkId}/${accountId}.json`;
    }
    /**
     * Get the network(s) from files in `keyDir`
     * @returns {Promise<string[]>}
     */
    async getNetworks() {
        const files = await readdir(this.keyDir);
        const result = new Array();
        files.forEach((item) => {
            result.push(item);
        });
        return result;
    }
    /**
     * Gets the account(s) files in `keyDir/networkId`
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @returns{Promise<string[]>}
     */
    async getAccounts(networkId) {
        if (!await exists(`${this.keyDir}/${networkId}`)) {
            return [];
        }
        const files = await readdir(`${this.keyDir}/${networkId}`);
        return files
            .filter(file => file.endsWith('.json'))
            .map(file => file.replace(/.json$/, ''));
    }
    /** @hidden */
    toString() {
        return `UnencryptedFileSystemKeyStore(${this.keyDir})`;
    }
}
exports.UnencryptedFileSystemKeyStore = UnencryptedFileSystemKeyStore;

'''
'''--- lib/near.d.ts ---
/**
 * This module contains the main class developers will use to interact with NEAR.
 * The {@link Near} class is used to interact with {@link Account | Accounts} through the {@link JsonRpcProvider.JsonRpcProvider | JsonRpcProvider}.
 * It is configured via the {@link NearConfig}.
 *
 * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#account}
 *
 * @module near
 */
import BN from 'bn.js';
import { Account } from './account';
import { Connection } from './connection';
import { Signer } from './signer';
import { Contract } from './contract';
import { PublicKey } from './utils/key_pair';
import { AccountCreator } from './account_creator';
import { KeyStore } from './key_stores';
export interface NearConfig {
    /** Holds {@link KeyPair | KeyPairs} for signing transactions */
    keyStore?: KeyStore;
    /** @hidden */
    signer?: Signer;
    /** @deprecated use {@link NearConfig.keyStore} */
    deps?: {
        keyStore: KeyStore;
    };
    /**
     * {@link https://github.com/near/near-contract-helper | NEAR Contract Helper} url used to create accounts if no master account is provided
     * @see {@link UrlAccountCreator}
     */
    helperUrl?: string;
    /**
     * The balance transferred from the {@link NearConfig.masterAccount | masterAccount} to a created account
     * @see {@link LocalAccountCreator}
     */
    initialBalance?: string;
    /**
     * The account to use when creating new accounts
     * @see {@link LocalAccountCreator}
     */
    masterAccount?: string;
    /**
     * {@link KeyPair | KeyPairs} are stored in a {@link KeyStore} under the `networkId` namespace.
     */
    networkId: string;
    /**
     * NEAR RPC API url. used to make JSON RPC calls to interact with NEAR.
     * @see {@link JsonRpcProvider.JsonRpcProvider | JsonRpcProvider}
     */
    nodeUrl: string;
    /**
     * NEAR wallet url used to redirect users to their wallet in browser applications.
     * @see {@link https://docs.near.org/docs/tools/near-wallet}
     */
    walletUrl?: string;
}
/**
 * This is the main class developers should use to interact with NEAR.
 * @example
 * ```js
 * const near = new Near(config);
 * ```
 */
export declare class Near {
    readonly config: any;
    readonly connection: Connection;
    readonly accountCreator: AccountCreator;
    constructor(config: NearConfig);
    /**
     * @param accountId near accountId used to interact with the network.
     */
    account(accountId: string): Promise<Account>;
    /**
     * Create an account using the {@link AccountCreator}. Either:
     * * using a masterAccount with {@link LocalAccountCreator}
     * * using the helperUrl with {@link UrlAccountCreator}
     * @see {@link NearConfig.masterAccount} and {@link NearConfig.helperUrl}-
     *
     * @param accountId
     * @param publicKey
     */
    createAccount(accountId: string, publicKey: PublicKey): Promise<Account>;
    /**
     * @deprecated Use {@link Contract} instead.
     * @param contractId
     * @param options
     */
    loadContract(contractId: string, options: {
        viewMethods: string[];
        changeMethods: string[];
        sender: string;
    }): Promise<Contract>;
    /**
     * @deprecated Use {@link Account.sendMoney} instead.
     * @param amount
     * @param originator
     * @param receiver
     */
    sendTokens(amount: BN, originator: string, receiver: string): Promise<string>;
}

'''
'''--- lib/near.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Near = void 0;
/**
 * This module contains the main class developers will use to interact with NEAR.
 * The {@link Near} class is used to interact with {@link Account | Accounts} through the {@link JsonRpcProvider.JsonRpcProvider | JsonRpcProvider}.
 * It is configured via the {@link NearConfig}.
 *
 * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#account}
 *
 * @module near
 */
const bn_js_1 = __importDefault(require("bn.js"));
const account_1 = require("./account");
const connection_1 = require("./connection");
const contract_1 = require("./contract");
const account_creator_1 = require("./account_creator");
/**
 * This is the main class developers should use to interact with NEAR.
 * @example
 * ```js
 * const near = new Near(config);
 * ```
 */
class Near {
    constructor(config) {
        this.config = config;
        this.connection = connection_1.Connection.fromConfig({
            networkId: config.networkId,
            provider: { type: 'JsonRpcProvider', args: { url: config.nodeUrl } },
            signer: config.signer || { type: 'InMemorySigner', keyStore: config.keyStore || config.deps.keyStore }
        });
        if (config.masterAccount) {
            // TODO: figure out better way of specifiying initial balance.
            // Hardcoded number below must be enough to pay the gas cost to dev-deploy with near-shell for multiple times
            const initialBalance = config.initialBalance ? new bn_js_1.default(config.initialBalance) : new bn_js_1.default('500000000000000000000000000');
            this.accountCreator = new account_creator_1.LocalAccountCreator(new account_1.Account(this.connection, config.masterAccount), initialBalance);
        }
        else if (config.helperUrl) {
            this.accountCreator = new account_creator_1.UrlAccountCreator(this.connection, config.helperUrl);
        }
        else {
            this.accountCreator = null;
        }
    }
    /**
     * @param accountId near accountId used to interact with the network.
     */
    async account(accountId) {
        const account = new account_1.Account(this.connection, accountId);
        return account;
    }
    /**
     * Create an account using the {@link AccountCreator}. Either:
     * * using a masterAccount with {@link LocalAccountCreator}
     * * using the helperUrl with {@link UrlAccountCreator}
     * @see {@link NearConfig.masterAccount} and {@link NearConfig.helperUrl}-
     *
     * @param accountId
     * @param publicKey
     */
    async createAccount(accountId, publicKey) {
        if (!this.accountCreator) {
            throw new Error('Must specify account creator, either via masterAccount or helperUrl configuration settings.');
        }
        await this.accountCreator.createAccount(accountId, publicKey);
        return new account_1.Account(this.connection, accountId);
    }
    /**
     * @deprecated Use {@link Contract} instead.
     * @param contractId
     * @param options
     */
    async loadContract(contractId, options) {
        const account = new account_1.Account(this.connection, options.sender);
        return new contract_1.Contract(account, contractId, options);
    }
    /**
     * @deprecated Use {@link Account.sendMoney} instead.
     * @param amount
     * @param originator
     * @param receiver
     */
    async sendTokens(amount, originator, receiver) {
        console.warn('near.sendTokens is deprecated. Use `yourAccount.sendMoney` instead.');
        const account = new account_1.Account(this.connection, originator);
        const result = await account.sendMoney(receiver, amount);
        return result.transaction_outcome.id;
    }
}
exports.Near = Near;

'''
'''--- lib/providers/index.d.ts ---
/** @hidden @module */
import { Provider, FinalExecutionOutcome, ExecutionOutcomeWithId, getTransactionLastResult, FinalExecutionStatus, FinalExecutionStatusBasic } from './provider';
import { JsonRpcProvider, TypedError, ErrorContext } from './json-rpc-provider';
export { Provider, FinalExecutionOutcome, JsonRpcProvider, ExecutionOutcomeWithId, FinalExecutionStatus, FinalExecutionStatusBasic, getTransactionLastResult, TypedError, ErrorContext };

'''
'''--- lib/providers/index.js ---
"use strict";
/** @hidden @module */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorContext = exports.TypedError = exports.getTransactionLastResult = exports.FinalExecutionStatusBasic = exports.JsonRpcProvider = exports.Provider = void 0;
const provider_1 = require("./provider");
Object.defineProperty(exports, "Provider", { enumerable: true, get: function () { return provider_1.Provider; } });
Object.defineProperty(exports, "getTransactionLastResult", { enumerable: true, get: function () { return provider_1.getTransactionLastResult; } });
Object.defineProperty(exports, "FinalExecutionStatusBasic", { enumerable: true, get: function () { return provider_1.FinalExecutionStatusBasic; } });
const json_rpc_provider_1 = require("./json-rpc-provider");
Object.defineProperty(exports, "JsonRpcProvider", { enumerable: true, get: function () { return json_rpc_provider_1.JsonRpcProvider; } });
Object.defineProperty(exports, "TypedError", { enumerable: true, get: function () { return json_rpc_provider_1.TypedError; } });
Object.defineProperty(exports, "ErrorContext", { enumerable: true, get: function () { return json_rpc_provider_1.ErrorContext; } });

'''
'''--- lib/providers/json-rpc-provider.d.ts ---
import { AccessKeyWithPublicKey, Provider, FinalExecutionOutcome, NodeStatusResult, BlockId, BlockReference, BlockResult, BlockChangeResult, ChangeResult, ChunkId, ChunkResult, EpochValidatorInfo, NearProtocolConfig, LightClientProof, LightClientProofRequest, GasPrice, QueryResponseKind } from './provider';
import { ConnectionInfo } from '../utils/web';
import { TypedError, ErrorContext } from '../utils/errors';
import { SignedTransaction } from '../transaction';
/** @hidden */
export { TypedError, ErrorContext };
/**
 * Client class to interact with the NEAR RPC API.
 * @see {@link https://github.com/near/nearcore/tree/master/chain/jsonrpc}
 */
export declare class JsonRpcProvider extends Provider {
    /** @hidden */
    readonly connection: ConnectionInfo;
    /**
     * @param url RPC API endpoint URL
     */
    constructor(url?: string);
    /**
     * Gets the RPC's status
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#general-validator-status}
     */
    status(): Promise<NodeStatusResult>;
    /**
     * Sends a signed transaction to the RPC and waits until transaction is fully complete
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#send-transaction-await}
     *
     * @param signedTransaction The signed transaction being sent
     */
    sendTransaction(signedTransaction: SignedTransaction): Promise<FinalExecutionOutcome>;
    /**
     * Sends a signed transaction to the RPC and immediately returns transaction hash
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#send-transaction-async)
     * @param signedTransaction The signed transaction being sent
     * @returns {Promise<FinalExecutionOutcome>}
     */
    sendTransactionAsync(signedTransaction: SignedTransaction): Promise<FinalExecutionOutcome>;
    /**
     * Gets a transaction's status from the RPC
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#transaction-status}
     *
     * @param txHash A transaction hash as either a Uint8Array or a base58 encoded string
     * @param accountId The NEAR account that signed the transaction
     */
    txStatus(txHash: Uint8Array | string, accountId: string): Promise<FinalExecutionOutcome>;
    private txStatusUint8Array;
    private txStatusString;
    /**
     * Gets a transaction's status from the RPC with receipts
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#transaction-status-with-receipts)
     * @param txHash The hash of the transaction
     * @param accountId The NEAR account that signed the transaction
     * @returns {Promise<FinalExecutionOutcome>}
     */
    txStatusReceipts(txHash: Uint8Array, accountId: string): Promise<FinalExecutionOutcome>;
    /**
     * Query the RPC as [shown in the docs](https://docs.near.org/docs/develop/front-end/rpc#accounts--contracts)
     * Query the RPC by passing an {@link RpcQueryRequest}
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#accounts--contracts}
     *
     * @typeParam T the shape of the returned query response
     */
    query<T extends QueryResponseKind>(...args: any[]): Promise<T>;
    /**
     * Query for block info from the RPC
     * pass block_id OR finality as blockQuery, not both
     * @see {@link https://docs.near.org/docs/interaction/rpc#block}
     *
     * @param blockQuery {@link BlockReference} (passing a {@link BlockId} is deprecated)
     */
    block(blockQuery: BlockId | BlockReference): Promise<BlockResult>;
    /**
     * Query changes in block from the RPC
     * pass block_id OR finality as blockQuery, not both
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#block-details)
     */
    blockChanges(blockQuery: BlockReference): Promise<BlockChangeResult>;
    /**
     * Queries for details about a specific chunk appending details of receipts and transactions to the same chunk data provided by a block
     * @see {@link https://docs.near.org/docs/interaction/rpc#chunk}
     *
     * @param chunkId Hash of a chunk ID or shard ID
     */
    chunk(chunkId: ChunkId): Promise<ChunkResult>;
    /**
     * Query validators of the epoch defined by the given block id.
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#detailed-validator-status}
     *
     * @param blockId Block hash or height, or null for latest.
     */
    validators(blockId: BlockId | null): Promise<EpochValidatorInfo>;
    /**
     * @deprecated
     * Gets the genesis config from RPC
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#genesis-config}
     */
    experimental_genesisConfig(): Promise<NearProtocolConfig>;
    /**
     * Gets the protocol config at a block from RPC
     * @see {@link }
     *
     * @param blockReference specifies the block to get the protocol config for
     */
    experimental_protocolConfig(blockReference: BlockReference | {
        sync_checkpoint: 'genesis';
    }): Promise<NearProtocolConfig>;
    /**
     * @deprecated Use {@link lightClientProof} instead
     */
    experimental_lightClientProof(request: LightClientProofRequest): Promise<LightClientProof>;
    /**
     * Gets a light client execution proof for verifying execution outcomes
     * @see {@link https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof}
     */
    lightClientProof(request: LightClientProofRequest): Promise<LightClientProof>;
    /**
     * Gets access key changes for a given array of accountIds
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-all)
     * @returns {Promise<ChangeResult>}
     */
    accessKeyChanges(accountIdArray: string[], blockQuery: BlockReference): Promise<ChangeResult>;
    /**
     * Gets single access key changes for a given array of access keys
     * pass block_id OR finality as blockQuery, not both
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-single)
     * @returns {Promise<ChangeResult>}
     */
    singleAccessKeyChanges(accessKeyArray: AccessKeyWithPublicKey[], blockQuery: BlockReference): Promise<ChangeResult>;
    /**
     * Gets account changes for a given array of accountIds
     * pass block_id OR finality as blockQuery, not both
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-account-changes)
     * @returns {Promise<ChangeResult>}
     */
    accountChanges(accountIdArray: string[], blockQuery: BlockReference): Promise<ChangeResult>;
    /**
     * Gets contract state changes for a given array of accountIds
     * pass block_id OR finality as blockQuery, not both
     * Note: If you pass a keyPrefix it must be base64 encoded
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-state-changes)
     * @returns {Promise<ChangeResult>}
     */
    contractStateChanges(accountIdArray: string[], blockQuery: BlockReference, keyPrefix?: string): Promise<ChangeResult>;
    /**
     * Gets contract code changes for a given array of accountIds
     * pass block_id OR finality as blockQuery, not both
     * Note: Change is returned in a base64 encoded WASM file
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-code-changes)
     * @returns {Promise<ChangeResult>}
     */
    contractCodeChanges(accountIdArray: string[], blockQuery: BlockReference): Promise<ChangeResult>;
    /**
     * Returns gas price for a specific block_height or block_hash.
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#gas-price}
     *
     * @param blockId Block hash or height, or null for latest.
     */
    gasPrice(blockId: BlockId | null): Promise<GasPrice>;
    /**
     * Directly call the RPC specifying the method and params
     *
     * @param method RPC method
     * @param params Parameters to the method
     */
    sendJsonRpc<T>(method: string, params: object): Promise<T>;
}

'''
'''--- lib/providers/json-rpc-provider.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonRpcProvider = exports.ErrorContext = exports.TypedError = void 0;
/**
 * This module contains the {@link JsonRpcProvider} client class
 * which can be used to interact with the NEAR RPC API.
 * @see {@link providers/provider} for a list of request and response types
 */
const depd_1 = __importDefault(require("depd"));
const provider_1 = require("./provider");
const web_1 = require("../utils/web");
const errors_1 = require("../utils/errors");
Object.defineProperty(exports, "TypedError", { enumerable: true, get: function () { return errors_1.TypedError; } });
Object.defineProperty(exports, "ErrorContext", { enumerable: true, get: function () { return errors_1.ErrorContext; } });
const borsh_1 = require("borsh");
const exponential_backoff_1 = __importDefault(require("../utils/exponential-backoff"));
const rpc_errors_1 = require("../utils/rpc_errors");
// Default number of retries before giving up on a request.
const REQUEST_RETRY_NUMBER = 12;
// Default wait until next retry in millis.
const REQUEST_RETRY_WAIT = 500;
// Exponential back off for waiting to retry.
const REQUEST_RETRY_WAIT_BACKOFF = 1.5;
/// Keep ids unique across all connections.
let _nextId = 123;
/**
 * Client class to interact with the NEAR RPC API.
 * @see {@link https://github.com/near/nearcore/tree/master/chain/jsonrpc}
 */
class JsonRpcProvider extends provider_1.Provider {
    /**
     * @param url RPC API endpoint URL
     */
    constructor(url) {
        super();
        this.connection = { url };
    }
    /**
     * Gets the RPC's status
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#general-validator-status}
     */
    async status() {
        return this.sendJsonRpc('status', []);
    }
    /**
     * Sends a signed transaction to the RPC and waits until transaction is fully complete
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#send-transaction-await}
     *
     * @param signedTransaction The signed transaction being sent
     */
    async sendTransaction(signedTransaction) {
        const bytes = signedTransaction.encode();
        return this.sendJsonRpc('broadcast_tx_commit', [Buffer.from(bytes).toString('base64')]);
    }
    /**
     * Sends a signed transaction to the RPC and immediately returns transaction hash
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#send-transaction-async)
     * @param signedTransaction The signed transaction being sent
     * @returns {Promise<FinalExecutionOutcome>}
     */
    async sendTransactionAsync(signedTransaction) {
        const bytes = signedTransaction.encode();
        return this.sendJsonRpc('broadcast_tx_async', [Buffer.from(bytes).toString('base64')]);
    }
    /**
     * Gets a transaction's status from the RPC
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#transaction-status}
     *
     * @param txHash A transaction hash as either a Uint8Array or a base58 encoded string
     * @param accountId The NEAR account that signed the transaction
     */
    async txStatus(txHash, accountId) {
        if (typeof txHash === 'string') {
            return this.txStatusString(txHash, accountId);
        }
        else {
            return this.txStatusUint8Array(txHash, accountId);
        }
    }
    async txStatusUint8Array(txHash, accountId) {
        return this.sendJsonRpc('tx', [borsh_1.baseEncode(txHash), accountId]);
    }
    async txStatusString(txHash, accountId) {
        return this.sendJsonRpc('tx', [txHash, accountId]);
    }
    /**
     * Gets a transaction's status from the RPC with receipts
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#transaction-status-with-receipts)
     * @param txHash The hash of the transaction
     * @param accountId The NEAR account that signed the transaction
     * @returns {Promise<FinalExecutionOutcome>}
     */
    async txStatusReceipts(txHash, accountId) {
        return this.sendJsonRpc('EXPERIMENTAL_tx_status', [borsh_1.baseEncode(txHash), accountId]);
    }
    /**
     * Query the RPC as [shown in the docs](https://docs.near.org/docs/develop/front-end/rpc#accounts--contracts)
     * Query the RPC by passing an {@link RpcQueryRequest}
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#accounts--contracts}
     *
     * @typeParam T the shape of the returned query response
     */
    async query(...args) {
        let result;
        if (args.length === 1) {
            result = await this.sendJsonRpc('query', args[0]);
        }
        else {
            const [path, data] = args;
            result = await this.sendJsonRpc('query', [path, data]);
        }
        if (result && result.error) {
            throw new errors_1.TypedError(`Querying ${args} failed: ${result.error}.\n${JSON.stringify(result, null, 2)}`, rpc_errors_1.getErrorTypeFromErrorMessage(result.error));
        }
        return result;
    }
    /**
     * Query for block info from the RPC
     * pass block_id OR finality as blockQuery, not both
     * @see {@link https://docs.near.org/docs/interaction/rpc#block}
     *
     * @param blockQuery {@link BlockReference} (passing a {@link BlockId} is deprecated)
     */
    async block(blockQuery) {
        const { finality } = blockQuery;
        let { blockId } = blockQuery;
        if (typeof blockQuery !== 'object') {
            const deprecate = depd_1.default('JsonRpcProvider.block(blockId)');
            deprecate('use `block({ blockId })` or `block({ finality })` instead');
            blockId = blockQuery;
        }
        return this.sendJsonRpc('block', { block_id: blockId, finality });
    }
    /**
     * Query changes in block from the RPC
     * pass block_id OR finality as blockQuery, not both
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#block-details)
     */
    async blockChanges(blockQuery) {
        const { finality } = blockQuery;
        const { blockId } = blockQuery;
        return this.sendJsonRpc('EXPERIMENTAL_changes_in_block', { block_id: blockId, finality });
    }
    /**
     * Queries for details about a specific chunk appending details of receipts and transactions to the same chunk data provided by a block
     * @see {@link https://docs.near.org/docs/interaction/rpc#chunk}
     *
     * @param chunkId Hash of a chunk ID or shard ID
     */
    async chunk(chunkId) {
        return this.sendJsonRpc('chunk', [chunkId]);
    }
    /**
     * Query validators of the epoch defined by the given block id.
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#detailed-validator-status}
     *
     * @param blockId Block hash or height, or null for latest.
     */
    async validators(blockId) {
        return this.sendJsonRpc('validators', [blockId]);
    }
    /**
     * @deprecated
     * Gets the genesis config from RPC
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#genesis-config}
     */
    async experimental_genesisConfig() {
        const deprecate = depd_1.default('JsonRpcProvider.experimental_protocolConfig()');
        deprecate('use `experimental_protocolConfig({ sync_checkpoint: \'genesis\' })` to fetch the up-to-date or genesis protocol config explicitly');
        return await this.sendJsonRpc('EXPERIMENTAL_protocol_config', { sync_checkpoint: 'genesis' });
    }
    /**
     * Gets the protocol config at a block from RPC
     * @see {@link }
     *
     * @param blockReference specifies the block to get the protocol config for
     */
    async experimental_protocolConfig(blockReference) {
        return await this.sendJsonRpc('EXPERIMENTAL_protocol_config', blockReference);
    }
    /**
     * @deprecated Use {@link lightClientProof} instead
     */
    async experimental_lightClientProof(request) {
        const deprecate = depd_1.default('JsonRpcProvider.experimental_lightClientProof(request)');
        deprecate('use `lightClientProof` instead');
        return await this.lightClientProof(request);
    }
    /**
     * Gets a light client execution proof for verifying execution outcomes
     * @see {@link https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof}
     */
    async lightClientProof(request) {
        return await this.sendJsonRpc('EXPERIMENTAL_light_client_proof', request);
    }
    /**
     * Gets access key changes for a given array of accountIds
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-all)
     * @returns {Promise<ChangeResult>}
     */
    async accessKeyChanges(accountIdArray, blockQuery) {
        const { finality } = blockQuery;
        const { blockId } = blockQuery;
        return this.sendJsonRpc('EXPERIMENTAL_changes', {
            changes_type: 'all_access_key_changes',
            account_ids: accountIdArray,
            block_id: blockId,
            finality
        });
    }
    /**
     * Gets single access key changes for a given array of access keys
     * pass block_id OR finality as blockQuery, not both
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-single)
     * @returns {Promise<ChangeResult>}
     */
    async singleAccessKeyChanges(accessKeyArray, blockQuery) {
        const { finality } = blockQuery;
        const { blockId } = blockQuery;
        return this.sendJsonRpc('EXPERIMENTAL_changes', {
            changes_type: 'single_access_key_changes',
            keys: accessKeyArray,
            block_id: blockId,
            finality
        });
    }
    /**
     * Gets account changes for a given array of accountIds
     * pass block_id OR finality as blockQuery, not both
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-account-changes)
     * @returns {Promise<ChangeResult>}
     */
    async accountChanges(accountIdArray, blockQuery) {
        const { finality } = blockQuery;
        const { blockId } = blockQuery;
        return this.sendJsonRpc('EXPERIMENTAL_changes', {
            changes_type: 'account_changes',
            account_ids: accountIdArray,
            block_id: blockId,
            finality
        });
    }
    /**
     * Gets contract state changes for a given array of accountIds
     * pass block_id OR finality as blockQuery, not both
     * Note: If you pass a keyPrefix it must be base64 encoded
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-state-changes)
     * @returns {Promise<ChangeResult>}
     */
    async contractStateChanges(accountIdArray, blockQuery, keyPrefix = '') {
        const { finality } = blockQuery;
        const { blockId } = blockQuery;
        return this.sendJsonRpc('EXPERIMENTAL_changes', {
            changes_type: 'data_changes',
            account_ids: accountIdArray,
            key_prefix_base64: keyPrefix,
            block_id: blockId,
            finality
        });
    }
    /**
     * Gets contract code changes for a given array of accountIds
     * pass block_id OR finality as blockQuery, not both
     * Note: Change is returned in a base64 encoded WASM file
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-code-changes)
     * @returns {Promise<ChangeResult>}
     */
    async contractCodeChanges(accountIdArray, blockQuery) {
        const { finality } = blockQuery;
        const { blockId } = blockQuery;
        return this.sendJsonRpc('EXPERIMENTAL_changes', {
            changes_type: 'contract_code_changes',
            account_ids: accountIdArray,
            block_id: blockId,
            finality
        });
    }
    /**
     * Returns gas price for a specific block_height or block_hash.
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#gas-price}
     *
     * @param blockId Block hash or height, or null for latest.
     */
    async gasPrice(blockId) {
        return await this.sendJsonRpc('gas_price', [blockId]);
    }
    /**
     * Directly call the RPC specifying the method and params
     *
     * @param method RPC method
     * @param params Parameters to the method
     */
    async sendJsonRpc(method, params) {
        const response = await exponential_backoff_1.default(REQUEST_RETRY_WAIT, REQUEST_RETRY_NUMBER, REQUEST_RETRY_WAIT_BACKOFF, async () => {
            try {
                const request = {
                    method,
                    params,
                    id: (_nextId++),
                    jsonrpc: '2.0'
                };
                const response = await web_1.fetchJson(this.connection, JSON.stringify(request));
                if (response.error) {
                    if (typeof response.error.data === 'object') {
                        if (typeof response.error.data.error_message === 'string' && typeof response.error.data.error_type === 'string') {
                            // if error data has error_message and error_type properties, we consider that node returned an error in the old format
                            throw new errors_1.TypedError(response.error.data.error_message, response.error.data.error_type);
                        }
                        throw rpc_errors_1.parseRpcError(response.error.data);
                    }
                    else {
                        const errorMessage = `[${response.error.code}] ${response.error.message}: ${response.error.data}`;
                        // NOTE: All this hackery is happening because structured errors not implemented
                        // TODO: Fix when https://github.com/nearprotocol/nearcore/issues/1839 gets resolved
                        if (response.error.data === 'Timeout' || errorMessage.includes('Timeout error')
                            || errorMessage.includes('query has timed out')) {
                            throw new errors_1.TypedError(errorMessage, 'TimeoutError');
                        }
                        throw new errors_1.TypedError(errorMessage, rpc_errors_1.getErrorTypeFromErrorMessage(response.error.data));
                    }
                }
                // Success when response.error is not exist
                return response;
            }
            catch (error) {
                if (error.type === 'TimeoutError') {
                    if (!process.env['NEAR_NO_LOGS']) {
                        console.warn(`Retrying request to ${method} as it has timed out`, params);
                    }
                    return null;
                }
                throw error;
            }
        });
        const { result } = response;
        // From jsonrpc spec:
        // result
        //   This member is REQUIRED on success.
        //   This member MUST NOT exist if there was an error invoking the method.
        if (typeof result === 'undefined') {
            throw new errors_1.TypedError(`Exceeded ${REQUEST_RETRY_NUMBER} attempts for request to ${method}.`, 'RetriesExceeded');
        }
        return result;
    }
}
exports.JsonRpcProvider = JsonRpcProvider;

'''
'''--- lib/providers/provider.d.ts ---
/**
 * NEAR RPC API request types and responses
 * @module
 */
import { SignedTransaction } from '../transaction';
export interface SyncInfo {
    latest_block_hash: string;
    latest_block_height: number;
    latest_block_time: string;
    latest_state_root: string;
    syncing: boolean;
}
interface Version {
    version: string;
    build: string;
}
export interface NodeStatusResult {
    chain_id: string;
    rpc_addr: string;
    sync_info: SyncInfo;
    validators: string[];
    version: Version;
}
declare type BlockHash = string;
declare type BlockHeight = number;
export declare type BlockId = BlockHash | BlockHeight;
export declare type Finality = 'optimistic' | 'near-final' | 'final';
export declare type BlockReference = {
    blockId: BlockId;
} | {
    finality: Finality;
} | {
    sync_checkpoint: 'genesis' | 'earliest_available';
};
export declare enum ExecutionStatusBasic {
    Unknown = "Unknown",
    Pending = "Pending",
    Failure = "Failure"
}
export interface ExecutionStatus {
    SuccessValue?: string;
    SuccessReceiptId?: string;
    Failure?: ExecutionError;
}
export declare enum FinalExecutionStatusBasic {
    NotStarted = "NotStarted",
    Started = "Started",
    Failure = "Failure"
}
export interface ExecutionError {
    error_message: string;
    error_type: string;
}
export interface FinalExecutionStatus {
    SuccessValue?: string;
    Failure?: ExecutionError;
}
export interface ExecutionOutcomeWithId {
    id: string;
    outcome: ExecutionOutcome;
}
export interface ExecutionOutcome {
    logs: string[];
    receipt_ids: string[];
    gas_burnt: number;
    status: ExecutionStatus | ExecutionStatusBasic;
}
export interface ExecutionOutcomeWithIdView {
    proof: MerklePath;
    block_hash: string;
    id: string;
    outcome: ExecutionOutcome;
}
export interface FinalExecutionOutcome {
    status: FinalExecutionStatus | FinalExecutionStatusBasic;
    transaction: any;
    transaction_outcome: ExecutionOutcomeWithId;
    receipts_outcome: ExecutionOutcomeWithId[];
}
export interface TotalWeight {
    num: number;
}
export interface BlockHeader {
    height: number;
    epoch_id: string;
    next_epoch_id: string;
    hash: string;
    prev_hash: string;
    prev_state_root: string;
    chunk_receipts_root: string;
    chunk_headers_root: string;
    chunk_tx_root: string;
    outcome_root: string;
    chunks_included: number;
    challenges_root: string;
    timestamp: number;
    timestamp_nanosec: string;
    random_value: string;
    validator_proposals: any[];
    chunk_mask: boolean[];
    gas_price: string;
    rent_paid: string;
    validator_reward: string;
    total_supply: string;
    challenges_result: any[];
    last_final_block: string;
    last_ds_final_block: string;
    next_bp_hash: string;
    block_merkle_root: string;
    approvals: string[];
    signature: string;
    latest_protocol_version: number;
}
export declare type ChunkHash = string;
export declare type ShardId = number;
export declare type BlockShardId = [BlockId, ShardId];
export declare type ChunkId = ChunkHash | BlockShardId;
export interface ChunkHeader {
    balance_burnt: string;
    chunk_hash: ChunkHash;
    encoded_length: number;
    encoded_merkle_root: string;
    gas_limit: number;
    gas_used: number;
    height_created: number;
    height_included: number;
    outgoing_receipts_root: string;
    prev_block_hash: string;
    prev_state_num_parts: number;
    prev_state_root_hash: string;
    rent_paid: string;
    shard_id: number;
    signature: string;
    tx_root: string;
    validator_proposals: any[];
    validator_reward: string;
}
export interface ChunkResult {
    header: ChunkHeader;
    receipts: any[];
    transactions: Transaction[];
}
export interface Chunk {
    chunk_hash: string;
    prev_block_hash: string;
    outcome_root: string;
    prev_state_root: string;
    encoded_merkle_root: string;
    encoded_length: number;
    height_created: number;
    height_included: number;
    shard_id: number;
    gas_used: number;
    gas_limit: number;
    rent_paid: string;
    validator_reward: string;
    balance_burnt: string;
    outgoing_receipts_root: string;
    tx_root: string;
    validator_proposals: any[];
    signature: string;
}
export interface Transaction {
    hash: string;
    public_key: string;
    signature: string;
    body: any;
}
export interface BlockResult {
    author: string;
    header: BlockHeader;
    chunks: Chunk[];
}
export interface BlockChange {
    type: string;
    account_id: string;
}
export interface BlockChangeResult {
    block_hash: string;
    changes: BlockChange[];
}
export interface ChangeResult {
    block_hash: string;
    changes: any[];
}
export interface CurrentEpochValidatorInfo {
    account_id: string;
    public_key: string;
    is_slashed: boolean;
    stake: string;
    shards: number[];
    num_produced_blocks: number;
    num_expected_blocks: number;
}
export interface NextEpochValidatorInfo {
    account_id: string;
    public_key: string;
    stake: string;
    shards: number[];
}
export interface ValidatorStakeView {
    account_id: string;
    public_key: string;
    stake: string;
}
export interface NearProtocolConfig {
    runtime_config: NearProtocolRuntimeConfig;
}
export interface NearProtocolRuntimeConfig {
    storage_amount_per_byte: string;
}
export interface EpochValidatorInfo {
    next_validators: NextEpochValidatorInfo[];
    current_validators: CurrentEpochValidatorInfo[];
    next_fisherman: ValidatorStakeView[];
    current_fisherman: ValidatorStakeView[];
    current_proposals: ValidatorStakeView[];
    prev_epoch_kickout: ValidatorStakeView[];
    epoch_start_height: number;
}
export interface MerkleNode {
    hash: string;
    direction: string;
}
export declare type MerklePath = MerkleNode[];
export interface BlockHeaderInnerLiteView {
    height: number;
    epoch_id: string;
    next_epoch_id: string;
    prev_state_root: string;
    outcome_root: string;
    timestamp: number;
    next_bp_hash: string;
    block_merkle_root: string;
}
export interface LightClientBlockLiteView {
    prev_block_hash: string;
    inner_rest_hash: string;
    inner_lite: BlockHeaderInnerLiteView;
}
export interface LightClientProof {
    outcome_proof: ExecutionOutcomeWithIdView;
    outcome_root_proof: MerklePath;
    block_header_lite: LightClientBlockLiteView;
    block_proof: MerklePath;
}
export declare enum IdType {
    Transaction = "transaction",
    Receipt = "receipt"
}
export interface LightClientProofRequest {
    type: IdType;
    light_client_head: string;
    transaction_hash?: string;
    sender_id?: string;
    receipt_id?: string;
    receiver_id?: string;
}
export interface GasPrice {
    gas_price: string;
}
export interface AccessKeyWithPublicKey {
    account_id: string;
    public_key: string;
}
export interface QueryResponseKind {
    block_height: BlockHeight;
    block_hash: BlockHash;
}
export interface AccountView extends QueryResponseKind {
    amount: string;
    locked: string;
    code_hash: string;
    storage_usage: number;
    storage_paid_at: BlockHeight;
}
interface StateItem {
    key: string;
    value: string;
    proof: string[];
}
export interface ViewStateResult extends QueryResponseKind {
    values: StateItem[];
    proof: string[];
}
export interface CodeResult extends QueryResponseKind {
    result: number[];
    logs: string[];
}
export interface ContractCodeView extends QueryResponseKind {
    code_base64: string;
    hash: string;
}
export interface FunctionCallPermissionView {
    FunctionCall: {
        allowance: string;
        receiver_id: string;
        method_names: string[];
    };
}
export interface AccessKeyView extends QueryResponseKind {
    nonce: number;
    permission: 'FullAccess' | FunctionCallPermissionView;
}
export interface AccessKeyInfoView {
    public_key: string;
    access_key: AccessKeyView;
}
export interface AccessKeyList extends QueryResponseKind {
    keys: AccessKeyInfoView[];
}
export interface ViewAccountRequest {
    request_type: 'view_account';
    account_id: string;
}
export interface ViewCodeRequest {
    request_type: 'view_code';
    account_id: string;
}
export interface ViewStateRequest {
    request_type: 'view_state';
    account_id: string;
    prefix_base64: string;
}
export interface ViewAccessKeyRequest {
    request_type: 'view_access_key';
    account_id: string;
    public_key: string;
}
export interface ViewAccessKeyListRequest {
    request_type: 'view_access_key_list';
    account_id: string;
}
export interface CallFunctionRequest {
    request_type: 'call_function';
    account_id: string;
    method_name: string;
    args_base64: string;
}
export declare type RpcQueryRequest = (ViewAccountRequest | ViewCodeRequest | ViewStateRequest | ViewAccountRequest | ViewAccessKeyRequest | ViewAccessKeyListRequest | CallFunctionRequest) & BlockReference;
/** @hidden */
export declare abstract class Provider {
    abstract status(): Promise<NodeStatusResult>;
    abstract sendTransaction(signedTransaction: SignedTransaction): Promise<FinalExecutionOutcome>;
    abstract sendTransactionAsync(signedTransaction: SignedTransaction): Promise<FinalExecutionOutcome>;
    abstract txStatus(txHash: Uint8Array | string, accountId: string): Promise<FinalExecutionOutcome>;
    abstract txStatusReceipts(txHash: Uint8Array, accountId: string): Promise<FinalExecutionOutcome>;
    abstract query<T extends QueryResponseKind>(params: RpcQueryRequest): Promise<T>;
    abstract query<T extends QueryResponseKind>(path: string, data: string): Promise<T>;
    abstract block(blockQuery: BlockId | BlockReference): Promise<BlockResult>;
    abstract blockChanges(blockQuery: BlockId | BlockReference): Promise<BlockChangeResult>;
    abstract chunk(chunkId: ChunkId): Promise<ChunkResult>;
    abstract validators(blockId: BlockId): Promise<EpochValidatorInfo>;
    abstract experimental_genesisConfig(): Promise<NearProtocolConfig>;
    abstract experimental_protocolConfig(blockReference: BlockReference): Promise<NearProtocolConfig>;
    abstract lightClientProof(request: LightClientProofRequest): Promise<LightClientProof>;
    abstract gasPrice(blockId: BlockId): Promise<GasPrice>;
    abstract accessKeyChanges(accountIdArray: string[], BlockQuery: BlockId | BlockReference): Promise<ChangeResult>;
    abstract singleAccessKeyChanges(accessKeyArray: AccessKeyWithPublicKey[], BlockQuery: BlockId | BlockReference): Promise<ChangeResult>;
    abstract accountChanges(accountIdArray: string[], BlockQuery: BlockId | BlockReference): Promise<ChangeResult>;
    abstract contractStateChanges(accountIdArray: string[], BlockQuery: BlockId | BlockReference, keyPrefix: string): Promise<ChangeResult>;
    abstract contractCodeChanges(accountIdArray: string[], BlockQuery: BlockId | BlockReference): Promise<ChangeResult>;
}
/** @hidden */
export declare function getTransactionLastResult(txResult: FinalExecutionOutcome): any;
export {};

'''
'''--- lib/providers/provider.js ---
"use strict";
/**
 * NEAR RPC API request types and responses
 * @module
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTransactionLastResult = exports.Provider = exports.IdType = exports.FinalExecutionStatusBasic = exports.ExecutionStatusBasic = void 0;
var ExecutionStatusBasic;
(function (ExecutionStatusBasic) {
    ExecutionStatusBasic["Unknown"] = "Unknown";
    ExecutionStatusBasic["Pending"] = "Pending";
    ExecutionStatusBasic["Failure"] = "Failure";
})(ExecutionStatusBasic = exports.ExecutionStatusBasic || (exports.ExecutionStatusBasic = {}));
var FinalExecutionStatusBasic;
(function (FinalExecutionStatusBasic) {
    FinalExecutionStatusBasic["NotStarted"] = "NotStarted";
    FinalExecutionStatusBasic["Started"] = "Started";
    FinalExecutionStatusBasic["Failure"] = "Failure";
})(FinalExecutionStatusBasic = exports.FinalExecutionStatusBasic || (exports.FinalExecutionStatusBasic = {}));
var IdType;
(function (IdType) {
    IdType["Transaction"] = "transaction";
    IdType["Receipt"] = "receipt";
})(IdType = exports.IdType || (exports.IdType = {}));
/** @hidden */
class Provider {
}
exports.Provider = Provider;
/** @hidden */
function getTransactionLastResult(txResult) {
    if (typeof txResult.status === 'object' && typeof txResult.status.SuccessValue === 'string') {
        const value = Buffer.from(txResult.status.SuccessValue, 'base64').toString();
        try {
            return JSON.parse(value);
        }
        catch (e) {
            return value;
        }
    }
    return null;
}
exports.getTransactionLastResult = getTransactionLastResult;

'''
'''--- lib/res/error_messages.d.ts ---
export declare const GasLimitExceeded: string;
export declare const MethodEmptyName: string;
export declare const WasmerCompileError: string;
export declare const GuestPanic: string;
export declare const Memory: string;
export declare const GasExceeded: string;
export declare const MethodUTF8Error: string;
export declare const BadUTF16: string;
export declare const WasmTrap: string;
export declare const GasInstrumentation: string;
export declare const InvalidPromiseIndex: string;
export declare const InvalidPromiseResultIndex: string;
export declare const Deserialization: string;
export declare const MethodNotFound: string;
export declare const InvalidRegisterId: string;
export declare const InvalidReceiptIndex: string;
export declare const EmptyMethodName: string;
export declare const CannotReturnJointPromise: string;
export declare const StackHeightInstrumentation: string;
export declare const CodeDoesNotExist: string;
export declare const MethodInvalidSignature: string;
export declare const IntegerOverflow: string;
export declare const MemoryAccessViolation: string;
export declare const InvalidIteratorIndex: string;
export declare const IteratorWasInvalidated: string;
export declare const InvalidAccountId: string;
export declare const Serialization: string;
export declare const CannotAppendActionToJointPromise: string;
export declare const InternalMemoryDeclared: string;
export declare const Instantiate: string;
export declare const ProhibitedInView: string;
export declare const InvalidMethodName: string;
export declare const BadUTF8: string;
export declare const BalanceExceeded: string;
export declare const LinkError: string;
export declare const InvalidPublicKey: string;
export declare const ActorNoPermission: string;
export declare const LackBalanceForState: string;
export declare const ReceiverMismatch: string;
export declare const CostOverflow: string;
export declare const InvalidSignature: string;
export declare const AccessKeyNotFound: string;
export declare const NotEnoughBalance: string;
export declare const NotEnoughAllowance: string;
export declare const Expired: string;
export declare const DeleteAccountStaking: string;
export declare const SignerDoesNotExist: string;
export declare const TriesToStake: string;
export declare const AddKeyAlreadyExists: string;
export declare const InvalidSigner: string;
export declare const CreateAccountNotAllowed: string;
export declare const RequiresFullAccess: string;
export declare const TriesToUnstake: string;
export declare const InvalidNonce: string;
export declare const AccountAlreadyExists: string;
export declare const InvalidChain: string;
export declare const AccountDoesNotExist: string;
export declare const MethodNameMismatch: string;
export declare const DeleteAccountHasRent: string;
export declare const DeleteAccountHasEnoughBalance: string;
export declare const InvalidReceiver: string;
export declare const DeleteKeyDoesNotExist: string;
export declare const Timeout: string;
export declare const Closed: string;

'''
'''--- lib/res/error_messages.json ---
{
    "GasLimitExceeded": "Exceeded the maximum amount of gas allowed to burn per contract",
    "MethodEmptyName": "Method name is empty",
    "WasmerCompileError": "Wasmer compilation error: {{msg}}",
    "GuestPanic": "Smart contract panicked: {{panic_msg}}",
    "Memory": "Error creating Wasm memory",
    "GasExceeded": "Exceeded the prepaid gas",
    "MethodUTF8Error": "Method name is not valid UTF8 string",
    "BadUTF16": "String encoding is bad UTF-16 sequence",
    "WasmTrap": "WebAssembly trap: {{msg}}",
    "GasInstrumentation": "Gas instrumentation failed or contract has denied instructions.",
    "InvalidPromiseIndex": "{{promise_idx}} does not correspond to existing promises",
    "InvalidPromiseResultIndex": "Accessed invalid promise result index: {{result_idx}}",
    "Deserialization": "Error happened while deserializing the module",
    "MethodNotFound": "Contract method is not found",
    "InvalidRegisterId": "Accessed invalid register id: {{register_id}}",
    "InvalidReceiptIndex": "VM Logic returned an invalid receipt index: {{receipt_index}}",
    "EmptyMethodName": "Method name is empty in contract call",
    "CannotReturnJointPromise": "Returning joint promise is currently prohibited",
    "StackHeightInstrumentation": "Stack instrumentation failed",
    "CodeDoesNotExist": "Cannot find contract code for account {{account_id}}",
    "MethodInvalidSignature": "Invalid method signature",
    "IntegerOverflow": "Integer overflow happened during contract execution",
    "MemoryAccessViolation": "MemoryAccessViolation",
    "InvalidIteratorIndex": "Iterator index {{iterator_index}} does not exist",
    "IteratorWasInvalidated": "Iterator {{iterator_index}} was invalidated after its creation by performing a mutable operation on trie",
    "InvalidAccountId": "VM Logic returned an invalid account id",
    "Serialization": "Error happened while serializing the module",
    "CannotAppendActionToJointPromise": "Actions can only be appended to non-joint promise.",
    "InternalMemoryDeclared": "Internal memory declaration has been found in the module",
    "Instantiate": "Error happened during instantiation",
    "ProhibitedInView": "{{method_name}} is not allowed in view calls",
    "InvalidMethodName": "VM Logic returned an invalid method name",
    "BadUTF8": "String encoding is bad UTF-8 sequence",
    "BalanceExceeded": "Exceeded the account balance",
    "LinkError": "Wasm contract link error: {{msg}}",
    "InvalidPublicKey": "VM Logic provided an invalid public key",
    "ActorNoPermission": "Actor {{actor_id}} doesn't have permission to account {{account_id}} to complete the action",
    "LackBalanceForState": "The account {{account_id}} wouldn't have enough balance to cover storage, required to have {{amount}} yoctoNEAR more",
    "ReceiverMismatch": "Wrong AccessKey used for transaction: transaction is sent to receiver_id={{tx_receiver}}, but is signed with function call access key that restricted to only use with receiver_id={{ak_receiver}}. Either change receiver_id in your transaction or switch to use a FullAccessKey.",
    "CostOverflow": "Transaction gas or balance cost is too high",
    "InvalidSignature": "Transaction is not signed with the given public key",
    "AccessKeyNotFound": "Signer \"{{account_id}}\" doesn't have access key with the given public_key {{public_key}}",
    "NotEnoughBalance": "Sender {{signer_id}} does not have enough balance {{#formatNear}}{{balance}}{{/formatNear}} for operation costing {{#formatNear}}{{cost}}{{/formatNear}}",
    "NotEnoughAllowance": "Access Key {account_id}:{public_key} does not have enough balance {{#formatNear}}{{allowance}}{{/formatNear}} for transaction costing {{#formatNear}}{{cost}}{{/formatNear}}",
    "Expired": "Transaction has expired",
    "DeleteAccountStaking": "Account {{account_id}} is staking and can not be deleted",
    "SignerDoesNotExist": "Signer {{signer_id}} does not exist",
    "TriesToStake": "Account {{account_id}} tried to stake {{#formatNear}}{{stake}}{{/formatNear}}, but has staked {{#formatNear}}{{locked}}{{/formatNear}} and only has {{#formatNear}}{{balance}}{{/formatNear}}",
    "AddKeyAlreadyExists": "The public key {{public_key}} is already used for an existing access key",
    "InvalidSigner": "Invalid signer account ID {{signer_id}} according to requirements",
    "CreateAccountNotAllowed": "The new account_id {{account_id}} can't be created by {{predecessor_id}}",
    "RequiresFullAccess": "The transaction contains more then one action, but it was signed with an access key which allows transaction to apply only one specific action. To apply more then one actions TX must be signed with a full access key",
    "TriesToUnstake": "Account {{account_id}} is not yet staked, but tried to unstake",
    "InvalidNonce": "Transaction nonce {{tx_nonce}} must be larger than nonce of the used access key {{ak_nonce}}",
    "AccountAlreadyExists": "Can't create a new account {{account_id}}, because it already exists",
    "InvalidChain": "Transaction parent block hash doesn't belong to the current chain",
    "AccountDoesNotExist": "Can't complete the action because account {{account_id}} doesn't exist",
    "MethodNameMismatch": "Transaction method name {{method_name}} isn't allowed by the access key",
    "DeleteAccountHasRent": "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover the rent",
    "DeleteAccountHasEnoughBalance": "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover it's storage",
    "InvalidReceiver": "Invalid receiver account ID {{receiver_id}} according to requirements",
    "DeleteKeyDoesNotExist": "Account {{account_id}} tries to remove an access key that doesn't exist",
    "Timeout": "Timeout exceeded",
    "Closed": "Connection closed"
}

'''
'''--- lib/signer.d.ts ---
import { Signature, KeyPair, PublicKey } from './utils/key_pair';
import { KeyStore } from './key_stores/keystore';
/**
 * General signing interface, can be used for in memory signing, RPC singing, external wallet, HSM, etc.
 */
export declare abstract class Signer {
    /**
     * Creates new key and returns public key.
     */
    abstract createKey(accountId: string, networkId?: string): Promise<PublicKey>;
    /**
     * Returns public key for given account / network.
     * @param accountId accountId to retrieve from.
     * @param networkId The targeted network. (ex. default, betanet, etc)
     */
    abstract getPublicKey(accountId?: string, networkId?: string): Promise<PublicKey>;
    /**
     * Signs given message, by first hashing with sha256.
     * @param message message to sign.
     * @param accountId accountId to use for signing.
     * @param networkId The targeted network. (ex. default, betanet, etc)
     */
    abstract signMessage(message: Uint8Array, accountId?: string, networkId?: string): Promise<Signature>;
}
/**
 * Signs using in memory key store.
 */
export declare class InMemorySigner extends Signer {
    readonly keyStore: KeyStore;
    constructor(keyStore: KeyStore);
    /**
     * Creates a single account Signer instance with account, network and keyPair provided.
     *
     * Intended to be useful for temporary keys (e.g. claiming a Linkdrop).
     *
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account to assign the key pair to
     * @param keyPair The keyPair to use for signing
     */
    static fromKeyPair(networkId: string, accountId: string, keyPair: KeyPair): Promise<Signer>;
    /**
     * Creates a public key for the account given
     * @param accountId The NEAR account to assign a public key to
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @returns {Promise<PublicKey>}
     */
    createKey(accountId: string, networkId: string): Promise<PublicKey>;
    /**
     * Gets the existing public key for a given account
     * @param accountId The NEAR account to assign a public key to
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @returns {Promise<PublicKey>} Returns the public key or null if not found
     */
    getPublicKey(accountId?: string, networkId?: string): Promise<PublicKey>;
    /**
     * @param message A message to be signed, typically a serialized transaction
     * @param accountId the NEAR account signing the message
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @returns {Promise<Signature>}
     */
    signMessage(message: Uint8Array, accountId?: string, networkId?: string): Promise<Signature>;
    toString(): string;
}

'''
'''--- lib/signer.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InMemorySigner = exports.Signer = void 0;
const js_sha256_1 = __importDefault(require("js-sha256"));
const key_pair_1 = require("./utils/key_pair");
const in_memory_key_store_1 = require("./key_stores/in_memory_key_store");
/**
 * General signing interface, can be used for in memory signing, RPC singing, external wallet, HSM, etc.
 */
class Signer {
}
exports.Signer = Signer;
/**
 * Signs using in memory key store.
 */
class InMemorySigner extends Signer {
    constructor(keyStore) {
        super();
        this.keyStore = keyStore;
    }
    /**
     * Creates a single account Signer instance with account, network and keyPair provided.
     *
     * Intended to be useful for temporary keys (e.g. claiming a Linkdrop).
     *
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account to assign the key pair to
     * @param keyPair The keyPair to use for signing
     */
    static async fromKeyPair(networkId, accountId, keyPair) {
        const keyStore = new in_memory_key_store_1.InMemoryKeyStore();
        await keyStore.setKey(networkId, accountId, keyPair);
        return new InMemorySigner(keyStore);
    }
    /**
     * Creates a public key for the account given
     * @param accountId The NEAR account to assign a public key to
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @returns {Promise<PublicKey>}
     */
    async createKey(accountId, networkId) {
        const keyPair = key_pair_1.KeyPair.fromRandom('ed25519');
        await this.keyStore.setKey(networkId, accountId, keyPair);
        return keyPair.getPublicKey();
    }
    /**
     * Gets the existing public key for a given account
     * @param accountId The NEAR account to assign a public key to
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @returns {Promise<PublicKey>} Returns the public key or null if not found
     */
    async getPublicKey(accountId, networkId) {
        const keyPair = await this.keyStore.getKey(networkId, accountId);
        if (keyPair === null) {
            return null;
        }
        return keyPair.getPublicKey();
    }
    /**
     * @param message A message to be signed, typically a serialized transaction
     * @param accountId the NEAR account signing the message
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @returns {Promise<Signature>}
     */
    async signMessage(message, accountId, networkId) {
        const hash = new Uint8Array(js_sha256_1.default.sha256.array(message));
        if (!accountId) {
            throw new Error('InMemorySigner requires provided account id');
        }
        const keyPair = await this.keyStore.getKey(networkId, accountId);
        if (keyPair === null) {
            throw new Error(`Key for ${accountId} not found in ${networkId}`);
        }
        return keyPair.sign(hash);
    }
    toString() {
        return `InMemorySigner(${this.keyStore})`;
    }
}
exports.InMemorySigner = InMemorySigner;

'''
'''--- lib/transaction.d.ts ---
/// <reference types="node" />
import BN from 'bn.js';
import { Enum, Assignable } from './utils/enums';
import { KeyType, PublicKey } from './utils/key_pair';
import { Signer } from './signer';
export declare class FunctionCallPermission extends Assignable {
    allowance?: BN;
    receiverId: string;
    methodNames: string[];
}
export declare class FullAccessPermission extends Assignable {
}
export declare class AccessKeyPermission extends Enum {
    functionCall: FunctionCallPermission;
    fullAccess: FullAccessPermission;
}
export declare class AccessKey extends Assignable {
    nonce: number;
    permission: AccessKeyPermission;
}
export declare function fullAccessKey(): AccessKey;
export declare function functionCallAccessKey(receiverId: string, methodNames: string[], allowance?: BN): AccessKey;
export declare class IAction extends Assignable {
}
export declare class CreateAccount extends IAction {
}
export declare class DeployContract extends IAction {
    code: Uint8Array;
}
export declare class FunctionCall extends IAction {
    methodName: string;
    args: Uint8Array;
    gas: BN;
    deposit: BN;
}
export declare class Transfer extends IAction {
    deposit: BN;
}
export declare class Stake extends IAction {
    stake: BN;
    publicKey: PublicKey;
}
export declare class AddKey extends IAction {
    publicKey: PublicKey;
    accessKey: AccessKey;
}
export declare class DeleteKey extends IAction {
    publicKey: PublicKey;
}
export declare class DeleteAccount extends IAction {
    beneficiaryId: string;
}
export declare function createAccount(): Action;
export declare function deployContract(code: Uint8Array): Action;
export declare function stringifyJsonOrBytes(args: any): Buffer;
/**
 * Constructs {@link Action} instance representing contract method call.
 *
 * @param methodName the name of the method to call
 * @param args arguments to pass to method. Can be either plain JS object which gets serialized as JSON automatically
 *  or `Uint8Array` instance which represents bytes passed as is.
 * @param gas max amount of gas that method call can use
 * @param deposit amount of NEAR (in yoctoNEAR) to send together with the call
 * @param stringify Convert input arguments into bytes array.
 */
export declare function functionCall(methodName: string, args: Uint8Array | object, gas: BN, deposit: BN, stringify?: typeof stringifyJsonOrBytes): Action;
export declare function transfer(deposit: BN): Action;
export declare function stake(stake: BN, publicKey: PublicKey): Action;
export declare function addKey(publicKey: PublicKey, accessKey: AccessKey): Action;
export declare function deleteKey(publicKey: PublicKey): Action;
export declare function deleteAccount(beneficiaryId: string): Action;
export declare class Signature extends Assignable {
    keyType: KeyType;
    data: Uint8Array;
}
export declare class Transaction extends Assignable {
    signerId: string;
    publicKey: PublicKey;
    nonce: number;
    receiverId: string;
    actions: Action[];
    blockHash: Uint8Array;
    encode(): Uint8Array;
    static decode(bytes: Buffer): Transaction;
}
export declare class SignedTransaction extends Assignable {
    transaction: Transaction;
    signature: Signature;
    encode(): Uint8Array;
    static decode(bytes: Buffer): SignedTransaction;
}
/**
 * Contains a list of the valid transaction Actions available with this API
 * @see {@link https://nomicon.io/RuntimeSpec/Actions.html | Actions Spec}
 */
export declare class Action extends Enum {
    createAccount: CreateAccount;
    deployContract: DeployContract;
    functionCall: FunctionCall;
    transfer: Transfer;
    stake: Stake;
    addKey: AddKey;
    deleteKey: DeleteKey;
    deleteAccount: DeleteAccount;
}
export declare const SCHEMA: Map<Function, any>;
export declare function createTransaction(signerId: string, publicKey: PublicKey, receiverId: string, nonce: number, actions: Action[], blockHash: Uint8Array): Transaction;
export declare function signTransaction(transaction: Transaction, signer: Signer, accountId?: string, networkId?: string): Promise<[Uint8Array, SignedTransaction]>;
export declare function signTransaction(receiverId: string, nonce: number, actions: Action[], blockHash: Uint8Array, signer: Signer, accountId?: string, networkId?: string): Promise<[Uint8Array, SignedTransaction]>;

'''
'''--- lib/transaction.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.signTransaction = exports.createTransaction = exports.SCHEMA = exports.Action = exports.SignedTransaction = exports.Transaction = exports.Signature = exports.deleteAccount = exports.deleteKey = exports.addKey = exports.stake = exports.transfer = exports.functionCall = exports.stringifyJsonOrBytes = exports.deployContract = exports.createAccount = exports.DeleteAccount = exports.DeleteKey = exports.AddKey = exports.Stake = exports.Transfer = exports.FunctionCall = exports.DeployContract = exports.CreateAccount = exports.IAction = exports.functionCallAccessKey = exports.fullAccessKey = exports.AccessKey = exports.AccessKeyPermission = exports.FullAccessPermission = exports.FunctionCallPermission = void 0;
const js_sha256_1 = __importDefault(require("js-sha256"));
const enums_1 = require("./utils/enums");
const borsh_1 = require("borsh");
const key_pair_1 = require("./utils/key_pair");
class FunctionCallPermission extends enums_1.Assignable {
}
exports.FunctionCallPermission = FunctionCallPermission;
class FullAccessPermission extends enums_1.Assignable {
}
exports.FullAccessPermission = FullAccessPermission;
class AccessKeyPermission extends enums_1.Enum {
}
exports.AccessKeyPermission = AccessKeyPermission;
class AccessKey extends enums_1.Assignable {
}
exports.AccessKey = AccessKey;
function fullAccessKey() {
    return new AccessKey({ nonce: 0, permission: new AccessKeyPermission({ fullAccess: new FullAccessPermission({}) }) });
}
exports.fullAccessKey = fullAccessKey;
function functionCallAccessKey(receiverId, methodNames, allowance) {
    return new AccessKey({ nonce: 0, permission: new AccessKeyPermission({ functionCall: new FunctionCallPermission({ receiverId, allowance, methodNames }) }) });
}
exports.functionCallAccessKey = functionCallAccessKey;
class IAction extends enums_1.Assignable {
}
exports.IAction = IAction;
class CreateAccount extends IAction {
}
exports.CreateAccount = CreateAccount;
class DeployContract extends IAction {
}
exports.DeployContract = DeployContract;
class FunctionCall extends IAction {
}
exports.FunctionCall = FunctionCall;
class Transfer extends IAction {
}
exports.Transfer = Transfer;
class Stake extends IAction {
}
exports.Stake = Stake;
class AddKey extends IAction {
}
exports.AddKey = AddKey;
class DeleteKey extends IAction {
}
exports.DeleteKey = DeleteKey;
class DeleteAccount extends IAction {
}
exports.DeleteAccount = DeleteAccount;
function createAccount() {
    return new Action({ createAccount: new CreateAccount({}) });
}
exports.createAccount = createAccount;
function deployContract(code) {
    return new Action({ deployContract: new DeployContract({ code }) });
}
exports.deployContract = deployContract;
function stringifyJsonOrBytes(args) {
    const isUint8Array = args.byteLength !== undefined && args.byteLength === args.length;
    const serializedArgs = isUint8Array ? args : Buffer.from(JSON.stringify(args));
    return serializedArgs;
}
exports.stringifyJsonOrBytes = stringifyJsonOrBytes;
/**
 * Constructs {@link Action} instance representing contract method call.
 *
 * @param methodName the name of the method to call
 * @param args arguments to pass to method. Can be either plain JS object which gets serialized as JSON automatically
 *  or `Uint8Array` instance which represents bytes passed as is.
 * @param gas max amount of gas that method call can use
 * @param deposit amount of NEAR (in yoctoNEAR) to send together with the call
 * @param stringify Convert input arguments into bytes array.
 */
function functionCall(methodName, args, gas, deposit, stringify = stringifyJsonOrBytes) {
    return new Action({ functionCall: new FunctionCall({ methodName, args: stringify(args), gas, deposit }) });
}
exports.functionCall = functionCall;
function transfer(deposit) {
    return new Action({ transfer: new Transfer({ deposit }) });
}
exports.transfer = transfer;
function stake(stake, publicKey) {
    return new Action({ stake: new Stake({ stake, publicKey }) });
}
exports.stake = stake;
function addKey(publicKey, accessKey) {
    return new Action({ addKey: new AddKey({ publicKey, accessKey }) });
}
exports.addKey = addKey;
function deleteKey(publicKey) {
    return new Action({ deleteKey: new DeleteKey({ publicKey }) });
}
exports.deleteKey = deleteKey;
function deleteAccount(beneficiaryId) {
    return new Action({ deleteAccount: new DeleteAccount({ beneficiaryId }) });
}
exports.deleteAccount = deleteAccount;
class Signature extends enums_1.Assignable {
}
exports.Signature = Signature;
class Transaction extends enums_1.Assignable {
    encode() {
        return borsh_1.serialize(exports.SCHEMA, this);
    }
    static decode(bytes) {
        return borsh_1.deserialize(exports.SCHEMA, Transaction, bytes);
    }
}
exports.Transaction = Transaction;
class SignedTransaction extends enums_1.Assignable {
    encode() {
        return borsh_1.serialize(exports.SCHEMA, this);
    }
    static decode(bytes) {
        return borsh_1.deserialize(exports.SCHEMA, SignedTransaction, bytes);
    }
}
exports.SignedTransaction = SignedTransaction;
/**
 * Contains a list of the valid transaction Actions available with this API
 * @see {@link https://nomicon.io/RuntimeSpec/Actions.html | Actions Spec}
 */
class Action extends enums_1.Enum {
}
exports.Action = Action;
exports.SCHEMA = new Map([
    [Signature, { kind: 'struct', fields: [
                ['keyType', 'u8'],
                ['data', [64]]
            ] }],
    [SignedTransaction, { kind: 'struct', fields: [
                ['transaction', Transaction],
                ['signature', Signature]
            ] }],
    [Transaction, { kind: 'struct', fields: [
                ['signerId', 'string'],
                ['publicKey', key_pair_1.PublicKey],
                ['nonce', 'u64'],
                ['receiverId', 'string'],
                ['blockHash', [32]],
                ['actions', [Action]]
            ] }],
    [key_pair_1.PublicKey, { kind: 'struct', fields: [
                ['keyType', 'u8'],
                ['data', [32]]
            ] }],
    [AccessKey, { kind: 'struct', fields: [
                ['nonce', 'u64'],
                ['permission', AccessKeyPermission],
            ] }],
    [AccessKeyPermission, { kind: 'enum', field: 'enum', values: [
                ['functionCall', FunctionCallPermission],
                ['fullAccess', FullAccessPermission],
            ] }],
    [FunctionCallPermission, { kind: 'struct', fields: [
                ['allowance', { kind: 'option', type: 'u128' }],
                ['receiverId', 'string'],
                ['methodNames', ['string']],
            ] }],
    [FullAccessPermission, { kind: 'struct', fields: [] }],
    [Action, { kind: 'enum', field: 'enum', values: [
                ['createAccount', CreateAccount],
                ['deployContract', DeployContract],
                ['functionCall', FunctionCall],
                ['transfer', Transfer],
                ['stake', Stake],
                ['addKey', AddKey],
                ['deleteKey', DeleteKey],
                ['deleteAccount', DeleteAccount],
            ] }],
    [CreateAccount, { kind: 'struct', fields: [] }],
    [DeployContract, { kind: 'struct', fields: [
                ['code', ['u8']]
            ] }],
    [FunctionCall, { kind: 'struct', fields: [
                ['methodName', 'string'],
                ['args', ['u8']],
                ['gas', 'u64'],
                ['deposit', 'u128']
            ] }],
    [Transfer, { kind: 'struct', fields: [
                ['deposit', 'u128']
            ] }],
    [Stake, { kind: 'struct', fields: [
                ['stake', 'u128'],
                ['publicKey', key_pair_1.PublicKey]
            ] }],
    [AddKey, { kind: 'struct', fields: [
                ['publicKey', key_pair_1.PublicKey],
                ['accessKey', AccessKey]
            ] }],
    [DeleteKey, { kind: 'struct', fields: [
                ['publicKey', key_pair_1.PublicKey]
            ] }],
    [DeleteAccount, { kind: 'struct', fields: [
                ['beneficiaryId', 'string']
            ] }],
]);
function createTransaction(signerId, publicKey, receiverId, nonce, actions, blockHash) {
    return new Transaction({ signerId, publicKey, nonce, receiverId, actions, blockHash });
}
exports.createTransaction = createTransaction;
/**
 * Signs a given transaction from an account with given keys, applied to the given network
 * @param transaction The Transaction object to sign
 * @param signer The {Signer} object that assists with signing keys
 * @param accountId The human-readable NEAR account name
 * @param networkId The targeted network. (ex. default, betanet, etc)
 */
async function signTransactionObject(transaction, signer, accountId, networkId) {
    const message = borsh_1.serialize(exports.SCHEMA, transaction);
    const hash = new Uint8Array(js_sha256_1.default.sha256.array(message));
    const signature = await signer.signMessage(message, accountId, networkId);
    const signedTx = new SignedTransaction({
        transaction,
        signature: new Signature({ keyType: transaction.publicKey.keyType, data: signature.signature })
    });
    return [hash, signedTx];
}
async function signTransaction(...args) {
    if (args[0].constructor === Transaction) {
        const [transaction, signer, accountId, networkId] = args;
        return signTransactionObject(transaction, signer, accountId, networkId);
    }
    else {
        const [receiverId, nonce, actions, blockHash, signer, accountId, networkId] = args;
        const publicKey = await signer.getPublicKey(accountId, networkId);
        const transaction = createTransaction(accountId, publicKey, receiverId, nonce, actions, blockHash);
        return signTransactionObject(transaction, signer, accountId, networkId);
    }
}
exports.signTransaction = signTransaction;

'''
'''--- lib/utils/enums.d.ts ---
/** @hidden @module */
export declare abstract class Enum {
    enum: string;
    constructor(properties: any);
}
export declare abstract class Assignable {
    constructor(properties: any);
}

'''
'''--- lib/utils/enums.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Assignable = exports.Enum = void 0;
/** @hidden @module */
class Enum {
    constructor(properties) {
        if (Object.keys(properties).length !== 1) {
            throw new Error('Enum can only take single value');
        }
        Object.keys(properties).map((key) => {
            this[key] = properties[key];
            this.enum = key;
        });
    }
}
exports.Enum = Enum;
class Assignable {
    constructor(properties) {
        Object.keys(properties).map((key) => {
            this[key] = properties[key];
        });
    }
}
exports.Assignable = Assignable;

'''
'''--- lib/utils/errors.d.ts ---
export declare class PositionalArgsError extends Error {
    constructor();
}
export declare class ArgumentTypeError extends Error {
    constructor(argName: string, argType: string, argValue: any);
}
export declare class TypedError extends Error {
    type: string;
    context?: ErrorContext;
    constructor(message?: string, type?: string, context?: ErrorContext);
}
export declare class ErrorContext {
    transactionHash?: string;
    constructor(transactionHash?: string);
}
export declare function logWarning(...args: any[]): void;

'''
'''--- lib/utils/errors.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.logWarning = exports.ErrorContext = exports.TypedError = exports.ArgumentTypeError = exports.PositionalArgsError = void 0;
class PositionalArgsError extends Error {
    constructor() {
        super('Contract method calls expect named arguments wrapped in object, e.g. { argName1: argValue1, argName2: argValue2 }');
    }
}
exports.PositionalArgsError = PositionalArgsError;
class ArgumentTypeError extends Error {
    constructor(argName, argType, argValue) {
        super(`Expected ${argType} for '${argName}' argument, but got '${JSON.stringify(argValue)}'`);
    }
}
exports.ArgumentTypeError = ArgumentTypeError;
class TypedError extends Error {
    constructor(message, type, context) {
        super(message);
        this.type = type || 'UntypedError';
        this.context = context;
    }
}
exports.TypedError = TypedError;
class ErrorContext {
    constructor(transactionHash) {
        this.transactionHash = transactionHash;
    }
}
exports.ErrorContext = ErrorContext;
function logWarning(...args) {
    if (!process.env['NEAR_NO_LOGS']) {
        console.warn(...args);
    }
}
exports.logWarning = logWarning;

'''
'''--- lib/utils/exponential-backoff.d.ts ---
export default function exponentialBackoff(startWaitTime: any, retryNumber: any, waitBackoff: any, getResult: any): Promise<any>;

'''
'''--- lib/utils/exponential-backoff.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
async function exponentialBackoff(startWaitTime, retryNumber, waitBackoff, getResult) {
    // TODO: jitter?
    let waitTime = startWaitTime;
    for (let i = 0; i < retryNumber; i++) {
        const result = await getResult();
        if (result) {
            return result;
        }
        await sleep(waitTime);
        waitTime *= waitBackoff;
    }
    return null;
}
exports.default = exponentialBackoff;
// Sleep given number of millis.
function sleep(millis) {
    return new Promise(resolve => setTimeout(resolve, millis));
}

'''
'''--- lib/utils/format.d.ts ---
import BN from 'bn.js';
/**
 * Exponent for calculating how many indivisible units are there in one NEAR. See {@link NEAR_NOMINATION}.
 */
export declare const NEAR_NOMINATION_EXP = 24;
/**
 * Number of indivisible units in one NEAR. Derived from {@link NEAR_NOMINATION_EXP}.
 */
export declare const NEAR_NOMINATION: BN;
/**
 * Convert account balance value from internal indivisible units to NEAR. 1 NEAR is defined by {@link NEAR_NOMINATION}.
 * Effectively this divides given amount by {@link NEAR_NOMINATION}.
 *
 * @param balance decimal string representing balance in smallest non-divisible NEAR units (as specified by {@link NEAR_NOMINATION})
 * @param fracDigits number of fractional digits to preserve in formatted string. Balance is rounded to match given number of digits.
 * @returns Value in 
 */
export declare function formatNearAmount(balance: string, fracDigits?: number): string;
/**
 * Convert human readable NEAR amount to internal indivisible units.
 * Effectively this multiplies given amount by {@link NEAR_NOMINATION}.
 *
 * @param amt decimal string (potentially fractional) denominated in NEAR.
 * @returns The parsed yocto amount or null if no amount was passed in
 */
export declare function parseNearAmount(amt?: string): string | null;

'''
'''--- lib/utils/format.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseNearAmount = exports.formatNearAmount = exports.NEAR_NOMINATION = exports.NEAR_NOMINATION_EXP = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
/**
 * Exponent for calculating how many indivisible units are there in one NEAR. See {@link NEAR_NOMINATION}.
 */
exports.NEAR_NOMINATION_EXP = 24;
/**
 * Number of indivisible units in one NEAR. Derived from {@link NEAR_NOMINATION_EXP}.
 */
exports.NEAR_NOMINATION = new bn_js_1.default('10', 10).pow(new bn_js_1.default(exports.NEAR_NOMINATION_EXP, 10));
// Pre-calculate offests used for rounding to different number of digits
const ROUNDING_OFFSETS = [];
const BN10 = new bn_js_1.default(10);
for (let i = 0, offset = new bn_js_1.default(5); i < exports.NEAR_NOMINATION_EXP; i++, offset = offset.mul(BN10)) {
    ROUNDING_OFFSETS[i] = offset;
}
/**
 * Convert account balance value from internal indivisible units to NEAR. 1 NEAR is defined by {@link NEAR_NOMINATION}.
 * Effectively this divides given amount by {@link NEAR_NOMINATION}.
 *
 * @param balance decimal string representing balance in smallest non-divisible NEAR units (as specified by {@link NEAR_NOMINATION})
 * @param fracDigits number of fractional digits to preserve in formatted string. Balance is rounded to match given number of digits.
 * @returns Value in 
 */
function formatNearAmount(balance, fracDigits = exports.NEAR_NOMINATION_EXP) {
    const balanceBN = new bn_js_1.default(balance, 10);
    if (fracDigits !== exports.NEAR_NOMINATION_EXP) {
        // Adjust balance for rounding at given number of digits
        const roundingExp = exports.NEAR_NOMINATION_EXP - fracDigits - 1;
        if (roundingExp > 0) {
            balanceBN.iadd(ROUNDING_OFFSETS[roundingExp]);
        }
    }
    balance = balanceBN.toString();
    const wholeStr = balance.substring(0, balance.length - exports.NEAR_NOMINATION_EXP) || '0';
    const fractionStr = balance.substring(balance.length - exports.NEAR_NOMINATION_EXP)
        .padStart(exports.NEAR_NOMINATION_EXP, '0').substring(0, fracDigits);
    return trimTrailingZeroes(`${formatWithCommas(wholeStr)}.${fractionStr}`);
}
exports.formatNearAmount = formatNearAmount;
/**
 * Convert human readable NEAR amount to internal indivisible units.
 * Effectively this multiplies given amount by {@link NEAR_NOMINATION}.
 *
 * @param amt decimal string (potentially fractional) denominated in NEAR.
 * @returns The parsed yocto amount or null if no amount was passed in
 */
function parseNearAmount(amt) {
    if (!amt) {
        return null;
    }
    amt = cleanupAmount(amt);
    const split = amt.split('.');
    const wholePart = split[0];
    const fracPart = split[1] || '';
    if (split.length > 2 || fracPart.length > exports.NEAR_NOMINATION_EXP) {
        throw new Error(`Cannot parse '${amt}' as NEAR amount`);
    }
    return trimLeadingZeroes(wholePart + fracPart.padEnd(exports.NEAR_NOMINATION_EXP, '0'));
}
exports.parseNearAmount = parseNearAmount;
/**
 * Removes commas from the input
 * @param amount A value or amount that may contain commas
 * @returns string The cleaned value
 */
function cleanupAmount(amount) {
    return amount.replace(/,/g, '').trim();
}
/**
 * Removes .000 from an input
 * @param value A value that may contain trailing zeroes in the decimals place
 * @returns string The value without the trailing zeros
 */
function trimTrailingZeroes(value) {
    return value.replace(/\.?0*$/, '');
}
/**
 * Removes leading zeroes from an input
 * @param value A value that may contain leading zeroes
 * @returns string The value without the leading zeroes
 */
function trimLeadingZeroes(value) {
    value = value.replace(/^0+/, '');
    if (value === '') {
        return '0';
    }
    return value;
}
/**
 * Returns a human-readable value with commas
 * @param value A value that may not contain commas
 * @returns string A value with commas
 */
function formatWithCommas(value) {
    const pattern = /(-?\d+)(\d{3})/;
    while (pattern.test(value)) {
        value = value.replace(pattern, '$1,$2');
    }
    return value;
}

'''
'''--- lib/utils/index.d.ts ---
import * as key_pair from './key_pair';
import * as serialize from './serialize';
import * as web from './web';
import * as enums from './enums';
import * as format from './format';
import * as rpc_errors from './rpc_errors';
import { PublicKey, KeyPair, KeyPairEd25519 } from './key_pair';
import { logWarning } from './errors';
export { key_pair, serialize, web, enums, format, PublicKey, KeyPair, KeyPairEd25519, rpc_errors, logWarning, };

'''
'''--- lib/utils/index.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.logWarning = exports.rpc_errors = exports.KeyPairEd25519 = exports.KeyPair = exports.PublicKey = exports.format = exports.enums = exports.web = exports.serialize = exports.key_pair = void 0;
const key_pair = __importStar(require("./key_pair"));
exports.key_pair = key_pair;
const serialize = __importStar(require("./serialize"));
exports.serialize = serialize;
const web = __importStar(require("./web"));
exports.web = web;
const enums = __importStar(require("./enums"));
exports.enums = enums;
const format = __importStar(require("./format"));
exports.format = format;
const rpc_errors = __importStar(require("./rpc_errors"));
exports.rpc_errors = rpc_errors;
const key_pair_1 = require("./key_pair");
Object.defineProperty(exports, "PublicKey", { enumerable: true, get: function () { return key_pair_1.PublicKey; } });
Object.defineProperty(exports, "KeyPair", { enumerable: true, get: function () { return key_pair_1.KeyPair; } });
Object.defineProperty(exports, "KeyPairEd25519", { enumerable: true, get: function () { return key_pair_1.KeyPairEd25519; } });
const errors_1 = require("./errors");
Object.defineProperty(exports, "logWarning", { enumerable: true, get: function () { return errors_1.logWarning; } });

'''
'''--- lib/utils/key_pair.d.ts ---
import { Assignable } from './enums';
export declare type Arrayish = string | ArrayLike<number>;
export interface Signature {
    signature: Uint8Array;
    publicKey: PublicKey;
}
/** All supported key types */
export declare enum KeyType {
    ED25519 = 0
}
/**
 * PublicKey representation that has type and bytes of the key.
 */
export declare class PublicKey extends Assignable {
    keyType: KeyType;
    data: Uint8Array;
    static from(value: string | PublicKey): PublicKey;
    static fromString(encodedKey: string): PublicKey;
    toString(): string;
    verify(message: Uint8Array, signature: Uint8Array): boolean;
}
export declare abstract class KeyPair {
    abstract sign(message: Uint8Array): Signature;
    abstract verify(message: Uint8Array, signature: Uint8Array): boolean;
    abstract toString(): string;
    abstract getPublicKey(): PublicKey;
    /**
     * @param curve Name of elliptical curve, case-insensitive
     * @returns Random KeyPair based on the curve
     */
    static fromRandom(curve: string): KeyPair;
    static fromString(encodedKey: string): KeyPair;
}
/**
 * This class provides key pair functionality for Ed25519 curve:
 * generating key pairs, encoding key pairs, signing and verifying.
 */
export declare class KeyPairEd25519 extends KeyPair {
    readonly publicKey: PublicKey;
    readonly secretKey: string;
    /**
     * Construct an instance of key pair given a secret key.
     * It's generally assumed that these are encoded in base58.
     * @param {string} secretKey
     */
    constructor(secretKey: string);
    /**
     * Generate a new random keypair.
     * @example
     * const keyRandom = KeyPair.fromRandom();
     * keyRandom.publicKey
     * // returns [PUBLIC_KEY]
     *
     * keyRandom.secretKey
     * // returns [SECRET_KEY]
     */
    static fromRandom(): KeyPairEd25519;
    sign(message: Uint8Array): Signature;
    verify(message: Uint8Array, signature: Uint8Array): boolean;
    toString(): string;
    getPublicKey(): PublicKey;
}

'''
'''--- lib/utils/key_pair.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyPairEd25519 = exports.KeyPair = exports.PublicKey = exports.KeyType = void 0;
const tweetnacl_1 = __importDefault(require("tweetnacl"));
const serialize_1 = require("./serialize");
const enums_1 = require("./enums");
/** All supported key types */
var KeyType;
(function (KeyType) {
    KeyType[KeyType["ED25519"] = 0] = "ED25519";
})(KeyType = exports.KeyType || (exports.KeyType = {}));
function key_type_to_str(keyType) {
    switch (keyType) {
        case KeyType.ED25519: return 'ed25519';
        default: throw new Error(`Unknown key type ${keyType}`);
    }
}
function str_to_key_type(keyType) {
    switch (keyType.toLowerCase()) {
        case 'ed25519': return KeyType.ED25519;
        default: throw new Error(`Unknown key type ${keyType}`);
    }
}
/**
 * PublicKey representation that has type and bytes of the key.
 */
class PublicKey extends enums_1.Assignable {
    static from(value) {
        if (typeof value === 'string') {
            return PublicKey.fromString(value);
        }
        return value;
    }
    static fromString(encodedKey) {
        const parts = encodedKey.split(':');
        if (parts.length === 1) {
            return new PublicKey({ keyType: KeyType.ED25519, data: serialize_1.base_decode(parts[0]) });
        }
        else if (parts.length === 2) {
            return new PublicKey({ keyType: str_to_key_type(parts[0]), data: serialize_1.base_decode(parts[1]) });
        }
        else {
            throw new Error('Invalid encoded key format, must be <curve>:<encoded key>');
        }
    }
    toString() {
        return `${key_type_to_str(this.keyType)}:${serialize_1.base_encode(this.data)}`;
    }
    verify(message, signature) {
        switch (this.keyType) {
            case KeyType.ED25519: return tweetnacl_1.default.sign.detached.verify(message, signature, this.data);
            default: throw new Error(`Unknown key type ${this.keyType}`);
        }
    }
}
exports.PublicKey = PublicKey;
class KeyPair {
    /**
     * @param curve Name of elliptical curve, case-insensitive
     * @returns Random KeyPair based on the curve
     */
    static fromRandom(curve) {
        switch (curve.toUpperCase()) {
            case 'ED25519': return KeyPairEd25519.fromRandom();
            default: throw new Error(`Unknown curve ${curve}`);
        }
    }
    static fromString(encodedKey) {
        const parts = encodedKey.split(':');
        if (parts.length === 1) {
            return new KeyPairEd25519(parts[0]);
        }
        else if (parts.length === 2) {
            switch (parts[0].toUpperCase()) {
                case 'ED25519': return new KeyPairEd25519(parts[1]);
                default: throw new Error(`Unknown curve: ${parts[0]}`);
            }
        }
        else {
            throw new Error('Invalid encoded key format, must be <curve>:<encoded key>');
        }
    }
}
exports.KeyPair = KeyPair;
/**
 * This class provides key pair functionality for Ed25519 curve:
 * generating key pairs, encoding key pairs, signing and verifying.
 */
class KeyPairEd25519 extends KeyPair {
    /**
     * Construct an instance of key pair given a secret key.
     * It's generally assumed that these are encoded in base58.
     * @param {string} secretKey
     */
    constructor(secretKey) {
        super();
        const keyPair = tweetnacl_1.default.sign.keyPair.fromSecretKey(serialize_1.base_decode(secretKey));
        this.publicKey = new PublicKey({ keyType: KeyType.ED25519, data: keyPair.publicKey });
        this.secretKey = secretKey;
    }
    /**
     * Generate a new random keypair.
     * @example
     * const keyRandom = KeyPair.fromRandom();
     * keyRandom.publicKey
     * // returns [PUBLIC_KEY]
     *
     * keyRandom.secretKey
     * // returns [SECRET_KEY]
     */
    static fromRandom() {
        const newKeyPair = tweetnacl_1.default.sign.keyPair();
        return new KeyPairEd25519(serialize_1.base_encode(newKeyPair.secretKey));
    }
    sign(message) {
        const signature = tweetnacl_1.default.sign.detached(message, serialize_1.base_decode(this.secretKey));
        return { signature, publicKey: this.publicKey };
    }
    verify(message, signature) {
        return this.publicKey.verify(message, signature);
    }
    toString() {
        return `ed25519:${this.secretKey}`;
    }
    getPublicKey() {
        return this.publicKey;
    }
}
exports.KeyPairEd25519 = KeyPairEd25519;

'''
'''--- lib/utils/network.d.ts ---
export interface Network {
    name: string;
    chainId: string;
    _defaultProvider?: (providers: any) => any;
}

'''
'''--- lib/utils/network.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

'''
'''--- lib/utils/rpc_errors.d.ts ---
import { TypedError } from '../utils/errors';
export declare class ServerError extends TypedError {
}
declare class ServerTransactionError extends ServerError {
    transaction_outcome: any;
}
export declare function parseRpcError(errorObj: Record<string, any>): ServerError;
export declare function parseResultError(result: any): ServerTransactionError;
export declare function formatError(errorClassName: string, errorData: any): string;
export declare function getErrorTypeFromErrorMessage(errorMessage: any): "UntypedError" | "CodeDoesNotExist" | "AccountDoesNotExist" | "InvalidNonce" | "AccessKeyDoesNotExist";
export {};

'''
'''--- lib/utils/rpc_errors.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getErrorTypeFromErrorMessage = exports.formatError = exports.parseResultError = exports.parseRpcError = exports.ServerError = void 0;
const mustache_1 = __importDefault(require("mustache"));
const rpc_error_schema_json_1 = __importDefault(require("../generated/rpc_error_schema.json"));
const error_messages_json_1 = __importDefault(require("../res/error_messages.json"));
const common_index_1 = require("../common-index");
const errors_1 = require("../utils/errors");
const mustacheHelpers = {
    formatNear: () => (n, render) => common_index_1.utils.format.formatNearAmount(render(n))
};
class ServerError extends errors_1.TypedError {
}
exports.ServerError = ServerError;
class ServerTransactionError extends ServerError {
}
function parseRpcError(errorObj) {
    const result = {};
    const errorClassName = walkSubtype(errorObj, rpc_error_schema_json_1.default.schema, result, '');
    // NOTE: This assumes that all errors extend TypedError
    const error = new ServerError(formatError(errorClassName, result), errorClassName);
    Object.assign(error, result);
    return error;
}
exports.parseRpcError = parseRpcError;
function parseResultError(result) {
    const server_error = parseRpcError(result.status.Failure);
    const server_tx_error = new ServerTransactionError();
    Object.assign(server_tx_error, server_error);
    server_tx_error.type = server_error.type;
    server_tx_error.message = server_error.message;
    server_tx_error.transaction_outcome = result.transaction_outcome;
    return server_tx_error;
}
exports.parseResultError = parseResultError;
function formatError(errorClassName, errorData) {
    if (typeof error_messages_json_1.default[errorClassName] === 'string') {
        return mustache_1.default.render(error_messages_json_1.default[errorClassName], {
            ...errorData,
            ...mustacheHelpers
        });
    }
    return JSON.stringify(errorData);
}
exports.formatError = formatError;
/**
 * Walks through defined schema returning error(s) recursively
 * @param errorObj The error to be parsed
 * @param schema A defined schema in JSON mapping to the RPC errors
 * @param result An object used in recursion or called directly
 * @param typeName The human-readable error type name as defined in the JSON mapping
 */
function walkSubtype(errorObj, schema, result, typeName) {
    let error;
    let type;
    let errorTypeName;
    for (const errorName in schema) {
        if (isString(errorObj[errorName])) {
            // Return early if error type is in a schema
            return errorObj[errorName];
        }
        if (isObject(errorObj[errorName])) {
            error = errorObj[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
        }
        else if (isObject(errorObj.kind) && isObject(errorObj.kind[errorName])) {
            error = errorObj.kind[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
        }
        else {
            continue;
        }
    }
    if (error && type) {
        for (const prop of Object.keys(type.props)) {
            result[prop] = error[prop];
        }
        return walkSubtype(error, schema, result, errorTypeName);
    }
    else {
        // TODO: is this the right thing to do?
        result.kind = errorObj;
        return typeName;
    }
}
function getErrorTypeFromErrorMessage(errorMessage) {
    // This function should be removed when JSON RPC starts returning typed errors.
    switch (true) {
        case /^account .*? does not exist while viewing$/.test(errorMessage):
            return 'AccountDoesNotExist';
        case /^Account .*? doesn't exist$/.test(errorMessage):
            return 'AccountDoesNotExist';
        case /^access key .*? does not exist while viewing$/.test(errorMessage):
            return 'AccessKeyDoesNotExist';
        case /wasm execution failed with error: FunctionCallError\(CompilationError\(CodeDoesNotExist/.test(errorMessage):
            return 'CodeDoesNotExist';
        case /Transaction nonce \d+ must be larger than nonce of the used access key \d+/.test(errorMessage):
            return 'InvalidNonce';
        default:
            return 'UntypedError';
    }
}
exports.getErrorTypeFromErrorMessage = getErrorTypeFromErrorMessage;
/**
 * Helper function determining if the argument is an object
 * @param n Value to check
 */
function isObject(n) {
    return Object.prototype.toString.call(n) === '[object Object]';
}
/**
 * Helper function determining if the argument is a string
 * @param n Value to check
 */
function isString(n) {
    return Object.prototype.toString.call(n) === '[object String]';
}

'''
'''--- lib/utils/serialize.d.ts ---
export { baseEncode as base_encode, baseDecode as base_decode, serialize, deserialize, Schema, BorshError, BinaryWriter, BinaryReader, } from 'borsh';

'''
'''--- lib/utils/serialize.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var borsh_1 = require("borsh");
Object.defineProperty(exports, "base_encode", { enumerable: true, get: function () { return borsh_1.baseEncode; } });
Object.defineProperty(exports, "base_decode", { enumerable: true, get: function () { return borsh_1.baseDecode; } });
Object.defineProperty(exports, "serialize", { enumerable: true, get: function () { return borsh_1.serialize; } });
Object.defineProperty(exports, "deserialize", { enumerable: true, get: function () { return borsh_1.deserialize; } });
Object.defineProperty(exports, "BorshError", { enumerable: true, get: function () { return borsh_1.BorshError; } });
Object.defineProperty(exports, "BinaryWriter", { enumerable: true, get: function () { return borsh_1.BinaryWriter; } });
Object.defineProperty(exports, "BinaryReader", { enumerable: true, get: function () { return borsh_1.BinaryReader; } });

'''
'''--- lib/utils/setup-node-fetch.d.ts ---
export default function (resource: any, init: any): any;

'''
'''--- lib/utils/setup-node-fetch.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_fetch_1 = __importDefault(require("node-fetch"));
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const httpAgent = new http_1.default.Agent({ keepAlive: true });
const httpsAgent = new https_1.default.Agent({ keepAlive: true });
function agent(_parsedURL) {
    if (_parsedURL.protocol === 'http:') {
        return httpAgent;
    }
    else {
        return httpsAgent;
    }
}
function default_1(resource, init) {
    return node_fetch_1.default(resource, {
        agent: agent(new URL(resource.toString())),
        ...init,
    });
}
exports.default = default_1;

'''
'''--- lib/utils/web.d.ts ---
export interface ConnectionInfo {
    url: string;
    user?: string;
    password?: string;
    allowInsecure?: boolean;
    timeout?: number;
    headers?: {
        [key: string]: string | number;
    };
}
export declare function fetchJson(connection: string | ConnectionInfo, json?: string): Promise<any>;

'''
'''--- lib/utils/web.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchJson = void 0;
const http_errors_1 = __importDefault(require("http-errors"));
const exponential_backoff_1 = __importDefault(require("./exponential-backoff"));
const providers_1 = require("../providers");
const errors_1 = require("./errors");
const START_WAIT_TIME_MS = 1000;
const BACKOFF_MULTIPLIER = 1.5;
const RETRY_NUMBER = 10;
async function fetchJson(connection, json) {
    let url = null;
    if (typeof (connection) === 'string') {
        url = connection;
    }
    else {
        url = connection.url;
    }
    const response = await exponential_backoff_1.default(START_WAIT_TIME_MS, RETRY_NUMBER, BACKOFF_MULTIPLIER, async () => {
        try {
            const response = await fetch(url, {
                method: json ? 'POST' : 'GET',
                body: json ? json : undefined,
                headers: { 'Content-Type': 'application/json; charset=utf-8' }
            });
            if (!response.ok) {
                if (response.status === 503) {
                    errors_1.logWarning(`Retrying HTTP request for ${url} as it's not available now`);
                    return null;
                }
                throw http_errors_1.default(response.status, await response.text());
            }
            return response;
        }
        catch (error) {
            if (error.toString().includes('FetchError') || error.toString().includes('Failed to fetch')) {
                errors_1.logWarning(`Retrying HTTP request for ${url} because of error: ${error}`);
                return null;
            }
            throw error;
        }
    });
    if (!response) {
        throw new providers_1.TypedError(`Exceeded ${RETRY_NUMBER} attempts for ${url}.`, 'RetriesExceeded');
    }
    return await response.json();
}
exports.fetchJson = fetchJson;

'''
'''--- lib/validators.d.ts ---
import BN from 'bn.js';
import { CurrentEpochValidatorInfo, NextEpochValidatorInfo } from './providers/provider';
/** Finds seat price given validators stakes and number of seats.
 *  Calculation follow the spec: https://nomicon.io/Economics/README.html#validator-selection
 * @params validators: current or next epoch validators.
 * @params numSeats: number of seats.
 */
export declare function findSeatPrice(validators: (CurrentEpochValidatorInfo | NextEpochValidatorInfo)[], numSeats: number): BN;
export interface ChangedValidatorInfo {
    current: CurrentEpochValidatorInfo;
    next: NextEpochValidatorInfo;
}
export interface EpochValidatorsDiff {
    newValidators: NextEpochValidatorInfo[];
    removedValidators: CurrentEpochValidatorInfo[];
    changedValidators: ChangedValidatorInfo[];
}
/** Diff validators between current and next epoch.
 * Returns additions, subtractions and changes to validator set.
 * @params currentValidators: list of current validators.
 * @params nextValidators: list of next validators.
 */
export declare function diffEpochValidators(currentValidators: CurrentEpochValidatorInfo[], nextValidators: NextEpochValidatorInfo[]): EpochValidatorsDiff;

'''
'''--- lib/validators.js ---
'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.diffEpochValidators = exports.findSeatPrice = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
/** Finds seat price given validators stakes and number of seats.
 *  Calculation follow the spec: https://nomicon.io/Economics/README.html#validator-selection
 * @params validators: current or next epoch validators.
 * @params numSeats: number of seats.
 */
function findSeatPrice(validators, numSeats) {
    const stakes = validators.map(v => new bn_js_1.default(v.stake, 10)).sort((a, b) => a.cmp(b));
    const num = new bn_js_1.default(numSeats);
    const stakesSum = stakes.reduce((a, b) => a.add(b));
    if (stakesSum.lt(num)) {
        throw new Error('Stakes are below seats');
    }
    // assert stakesSum >= numSeats
    let left = new bn_js_1.default(1), right = stakesSum.add(new bn_js_1.default(1));
    while (!left.eq(right.sub(new bn_js_1.default(1)))) {
        const mid = left.add(right).div(new bn_js_1.default(2));
        let found = false;
        let currentSum = new bn_js_1.default(0);
        for (let i = 0; i < stakes.length; ++i) {
            currentSum = currentSum.add(stakes[i].div(mid));
            if (currentSum.gte(num)) {
                left = mid;
                found = true;
                break;
            }
        }
        if (!found) {
            right = mid;
        }
    }
    return left;
}
exports.findSeatPrice = findSeatPrice;
/** Diff validators between current and next epoch.
 * Returns additions, subtractions and changes to validator set.
 * @params currentValidators: list of current validators.
 * @params nextValidators: list of next validators.
 */
function diffEpochValidators(currentValidators, nextValidators) {
    const validatorsMap = new Map();
    currentValidators.forEach(v => validatorsMap.set(v.account_id, v));
    const nextValidatorsSet = new Set(nextValidators.map(v => v.account_id));
    return {
        newValidators: nextValidators.filter(v => !validatorsMap.has(v.account_id)),
        removedValidators: currentValidators.filter(v => !nextValidatorsSet.has(v.account_id)),
        changedValidators: nextValidators.filter(v => (validatorsMap.has(v.account_id) && validatorsMap.get(v.account_id).stake != v.stake))
            .map(v => ({ current: validatorsMap.get(v.account_id), next: v }))
    };
}
exports.diffEpochValidators = diffEpochValidators;

'''
'''--- lib/wallet-account.d.ts ---
import { Account } from './account';
import { Near } from './near';
import { KeyStore } from './key_stores';
import { FinalExecutionOutcome } from './providers';
import { Transaction, Action } from './transaction';
import { PublicKey } from './utils';
import { Connection } from './connection';
interface SignInOptions {
    contractId?: string;
    methodNames?: string[];
    successUrl?: string;
    failureUrl?: string;
}
/**
 * Information to send NEAR wallet for signing transactions and redirecting the browser back to the calling application
 */
interface RequestSignTransactionsOptions {
    /** list of transactions to sign */
    transactions: Transaction[];
    /** url NEAR Wallet will redirect to after transaction signing is complete */
    callbackUrl?: string;
    /** meta information NEAR Wallet will send back to the application. `meta` will be attached to the `callbackUrl` as a url search param */
    meta?: string;
}
/**
 * This class is used in conjunction with the {@link BrowserLocalStorageKeyStore}.
 * It redirects users to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for key management.
 *
 * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#wallet}
 * @example
 * ```js
 * // create new WalletConnection instance
 * const wallet = new WalletConnection(near, 'my-app');
 *
 * // If not signed in redirect to the NEAR wallet to sign in
 * // keys will be stored in the BrowserLocalStorageKeyStore
 * if(!wallet.isSingnedIn()) return wallet.requestSignIn()
 * ```
 */
export declare class WalletConnection {
    /** @hidden */
    _walletBaseUrl: string;
    /** @hidden */
    _authDataKey: string;
    /** @hidden */
    _keyStore: KeyStore;
    /** @hidden */
    _authData: any;
    /** @hidden */
    _networkId: string;
    /** @hidden */
    _near: Near;
    /** @hidden */
    _connectedAccount: ConnectedWalletAccount;
    constructor(near: Near, appKeyPrefix: string | null);
    /**
     * Returns true, if this WalletAccount is authorized with the wallet.
     * @example
     * ```js
     * const wallet = new WalletConnection(near, 'my-app');
     * wallet.isSignedIn();
     * ```
     */
    isSignedIn(): boolean;
    /**
     * Returns authorized Account ID.
     * @example
     * ```js
     * const wallet = new WalletConnection(near, 'my-app');
     * wallet.getAccountId();
     * ```
     */
    getAccountId(): any;
    /**
     * Redirects current page to the wallet authentication page.
     * @param options An optional options object
     * @param options.contractId The NEAR account where the contract is deployed
     * @param options.successUrl URL to redirect upon success. Default: current url
     * @param options.failureUrl URL to redirect upon failure. Default: current url
     *
     * @example
     * ```js
     * const wallet = new WalletConnection(near, 'my-app');
     * // redirects to the NEAR Wallet
     * wallet.requestSignIn({ contractId: 'account-with-deploy-contract.near' });
     * ```
     */
    requestSignIn(contractIdOrOptions?: string | SignInOptions, title?: string, successUrl?: string, failureUrl?: string): Promise<void>;
    /**
     * Requests the user to quickly sign for a transaction or batch of transactions by redirecting to the NEAR wallet.
     */
    requestSignTransactions(options: RequestSignTransactionsOptions): Promise<void>;
    /**
     * @deprecated
     * Requests the user to quickly sign for a transaction or batch of transactions by redirecting to the NEAR wallet.
     * @param transactions Array of Transaction objects that will be requested to sign
     * @param callbackUrl The url to navigate to after the user is prompted to sign
     */
    requestSignTransactions(transactions: Transaction[], callbackUrl?: string, meta?: string): Promise<void>;
    private _requestSignTransactions;
    /**
     * @hidden
     * Complete sign in for a given account id and public key. To be invoked by the app when getting a callback from the wallet.
     */
    _completeSignInWithAccessKey(): Promise<void>;
    /**
     * @hidden
     * @param accountId The NEAR account owning the given public key
     * @param publicKey The public key being set to the key store
     */
    _moveKeyFromTempToPermanent(accountId: string, publicKey: string): Promise<void>;
    /**
     * Sign out from the current account
     * @example
     * walletAccount.signOut();
     */
    signOut(): void;
    /**
     * Returns the current connected wallet account
     */
    account(): ConnectedWalletAccount;
}
export declare const WalletAccount: typeof WalletConnection;
/**
 * {@link Account} implementation which redirects to wallet using {@link WalletConnection} when no local key is available.
 */
export declare class ConnectedWalletAccount extends Account {
    walletConnection: WalletConnection;
    constructor(walletConnection: WalletConnection, connection: Connection, accountId: string);
    /**
     * Sign a transaction by redirecting to the NEAR Wallet
     * @see {@link WalletConnection.requestSignTransactions}
     */
    protected signAndSendTransaction(...args: any[]): Promise<FinalExecutionOutcome>;
    private _signAndSendTransaction;
    /**
     * Check if given access key allows the function call or method attempted in transaction
     * @param accessKey Array of {access_key: AccessKey, public_key: PublicKey} items
     * @param receiverId The NEAR account attempting to have access
     * @param actions The action(s) needed to be checked for access
     */
    accessKeyMatchesTransaction(accessKey: any, receiverId: string, actions: Action[]): Promise<boolean>;
    /**
     * Helper function returning the access key (if it exists) to the receiver that grants the designated permission
     * @param receiverId The NEAR account seeking the access key for a transaction
     * @param actions The action(s) sought to gain access to
     * @param localKey A local public key provided to check for access
     * @returns Promise<any>
     */
    accessKeyForTransaction(receiverId: string, actions: Action[], localKey?: PublicKey): Promise<any>;
}
export {};

'''
'''--- lib/wallet-account.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectedWalletAccount = exports.WalletAccount = exports.WalletConnection = void 0;
/**
 * The classes in this module are used in conjunction with the {@link BrowserLocalStorageKeyStore}. This module exposes two classes:
 * * {@link WalletConnection} which redirects users to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for key management.
 * * {@link ConnectedWalletAccount} is an {@link Account} implementation that uses {@link WalletConnection} to get keys
 *
 * @module walletAccount
 */
const depd_1 = __importDefault(require("depd"));
const account_1 = require("./account");
const transaction_1 = require("./transaction");
const utils_1 = require("./utils");
const borsh_1 = require("borsh");
const borsh_2 = require("borsh");
const LOGIN_WALLET_URL_SUFFIX = '/login/';
const MULTISIG_HAS_METHOD = 'add_request_and_confirm';
const LOCAL_STORAGE_KEY_SUFFIX = '_wallet_auth_key';
const PENDING_ACCESS_KEY_PREFIX = 'pending_key'; // browser storage key for a pending access key (i.e. key has been generated but we are not sure it was added yet)
/**
 * This class is used in conjunction with the {@link BrowserLocalStorageKeyStore}.
 * It redirects users to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for key management.
 *
 * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#wallet}
 * @example
 * ```js
 * // create new WalletConnection instance
 * const wallet = new WalletConnection(near, 'my-app');
 *
 * // If not signed in redirect to the NEAR wallet to sign in
 * // keys will be stored in the BrowserLocalStorageKeyStore
 * if(!wallet.isSingnedIn()) return wallet.requestSignIn()
 * ```
 */
class WalletConnection {
    constructor(near, appKeyPrefix) {
        this._near = near;
        const authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;
        const authData = JSON.parse(window.localStorage.getItem(authDataKey));
        this._networkId = near.config.networkId;
        this._walletBaseUrl = near.config.walletUrl;
        appKeyPrefix = appKeyPrefix || near.config.contractName || 'default';
        this._keyStore = near.connection.signer.keyStore;
        this._authData = authData || { allKeys: [] };
        this._authDataKey = authDataKey;
        if (!this.isSignedIn()) {
            this._completeSignInWithAccessKey();
        }
    }
    /**
     * Returns true, if this WalletAccount is authorized with the wallet.
     * @example
     * ```js
     * const wallet = new WalletConnection(near, 'my-app');
     * wallet.isSignedIn();
     * ```
     */
    isSignedIn() {
        return !!this._authData.accountId;
    }
    /**
     * Returns authorized Account ID.
     * @example
     * ```js
     * const wallet = new WalletConnection(near, 'my-app');
     * wallet.getAccountId();
     * ```
     */
    getAccountId() {
        return this._authData.accountId || '';
    }
    /**
     * Redirects current page to the wallet authentication page.
     * @param options An optional options object
     * @param options.contractId The NEAR account where the contract is deployed
     * @param options.successUrl URL to redirect upon success. Default: current url
     * @param options.failureUrl URL to redirect upon failure. Default: current url
     *
     * @example
     * ```js
     * const wallet = new WalletConnection(near, 'my-app');
     * // redirects to the NEAR Wallet
     * wallet.requestSignIn({ contractId: 'account-with-deploy-contract.near' });
     * ```
     */
    async requestSignIn(contractIdOrOptions = {}, title, successUrl, failureUrl) {
        let options;
        if (typeof contractIdOrOptions === 'string') {
            const deprecate = depd_1.default('requestSignIn(contractId, title)');
            deprecate('`title` ignored; use `requestSignIn({ contractId, methodNames, successUrl, failureUrl })` instead');
            options = { contractId: contractIdOrOptions, successUrl, failureUrl };
        }
        else {
            options = contractIdOrOptions;
        }
        const currentUrl = new URL(window.location.href);
        const newUrl = new URL(this._walletBaseUrl + LOGIN_WALLET_URL_SUFFIX);
        newUrl.searchParams.set('success_url', options.successUrl || currentUrl.href);
        newUrl.searchParams.set('failure_url', options.failureUrl || currentUrl.href);
        if (options.contractId) {
            /* Throws exception if contract account does not exist */
            const contractAccount = await this._near.account(options.contractId);
            await contractAccount.state();
            newUrl.searchParams.set('contract_id', options.contractId);
            const accessKey = utils_1.KeyPair.fromRandom('ed25519');
            newUrl.searchParams.set('public_key', accessKey.getPublicKey().toString());
            await this._keyStore.setKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + accessKey.getPublicKey(), accessKey);
        }
        if (options.methodNames) {
            options.methodNames.forEach(methodName => {
                newUrl.searchParams.append('methodNames', methodName);
            });
        }
        window.location.assign(newUrl.toString());
    }
    async requestSignTransactions(...args) {
        if (Array.isArray(args[0])) {
            const deprecate = depd_1.default('WalletConnection.requestSignTransactions(transactions, callbackUrl, meta)');
            deprecate('use `WalletConnection.requestSignTransactions(RequestSignTransactionsOptions)` instead');
            return this._requestSignTransactions({
                transactions: args[0],
                callbackUrl: args[1],
                meta: args[2]
            });
        }
        return this._requestSignTransactions(args[0]);
    }
    async _requestSignTransactions({ transactions, meta, callbackUrl }) {
        const currentUrl = new URL(window.location.href);
        const newUrl = new URL('sign', this._walletBaseUrl);
        newUrl.searchParams.set('transactions', transactions
            .map(transaction => borsh_2.serialize(transaction_1.SCHEMA, transaction))
            .map(serialized => Buffer.from(serialized).toString('base64'))
            .join(','));
        newUrl.searchParams.set('callbackUrl', callbackUrl || currentUrl.href);
        if (meta)
            newUrl.searchParams.set('meta', meta);
        window.location.assign(newUrl.toString());
    }
    /**
     * @hidden
     * Complete sign in for a given account id and public key. To be invoked by the app when getting a callback from the wallet.
     */
    async _completeSignInWithAccessKey() {
        const currentUrl = new URL(window.location.href);
        const publicKey = currentUrl.searchParams.get('public_key') || '';
        const allKeys = (currentUrl.searchParams.get('all_keys') || '').split(',');
        const accountId = currentUrl.searchParams.get('account_id') || '';
        // TODO: Handle errors during login
        if (accountId) {
            this._authData = {
                accountId,
                allKeys
            };
            window.localStorage.setItem(this._authDataKey, JSON.stringify(this._authData));
            if (publicKey) {
                await this._moveKeyFromTempToPermanent(accountId, publicKey);
            }
        }
        currentUrl.searchParams.delete('public_key');
        currentUrl.searchParams.delete('all_keys');
        currentUrl.searchParams.delete('account_id');
        currentUrl.searchParams.delete('meta');
        currentUrl.searchParams.delete('transactionHashes');
        window.history.replaceState({}, document.title, currentUrl.toString());
    }
    /**
     * @hidden
     * @param accountId The NEAR account owning the given public key
     * @param publicKey The public key being set to the key store
     */
    async _moveKeyFromTempToPermanent(accountId, publicKey) {
        const keyPair = await this._keyStore.getKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);
        await this._keyStore.setKey(this._networkId, accountId, keyPair);
        await this._keyStore.removeKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);
    }
    /**
     * Sign out from the current account
     * @example
     * walletAccount.signOut();
     */
    signOut() {
        this._authData = {};
        window.localStorage.removeItem(this._authDataKey);
    }
    /**
     * Returns the current connected wallet account
     */
    account() {
        if (!this._connectedAccount) {
            this._connectedAccount = new ConnectedWalletAccount(this, this._near.connection, this._authData.accountId);
        }
        return this._connectedAccount;
    }
}
exports.WalletConnection = WalletConnection;
exports.WalletAccount = WalletConnection;
/**
 * {@link Account} implementation which redirects to wallet using {@link WalletConnection} when no local key is available.
 */
class ConnectedWalletAccount extends account_1.Account {
    constructor(walletConnection, connection, accountId) {
        super(connection, accountId);
        this.walletConnection = walletConnection;
    }
    // Overriding Account methods
    /**
     * Sign a transaction by redirecting to the NEAR Wallet
     * @see {@link WalletConnection.requestSignTransactions}
     */
    signAndSendTransaction(...args) {
        if (typeof args[0] === 'string') {
            return this._signAndSendTransaction({ receiverId: args[0], actions: args[1] });
        }
        return this._signAndSendTransaction(args[0]);
    }
    async _signAndSendTransaction({ receiverId, actions, walletMeta, walletCallbackUrl = window.location.href }) {
        const localKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);
        let accessKey = await this.accessKeyForTransaction(receiverId, actions, localKey);
        if (!accessKey) {
            throw new Error(`Cannot find matching key for transaction sent to ${receiverId}`);
        }
        if (localKey && localKey.toString() === accessKey.public_key) {
            try {
                return await super.signAndSendTransaction({ receiverId, actions });
            }
            catch (e) {
                if (e.type === 'NotEnoughAllowance') {
                    accessKey = await this.accessKeyForTransaction(receiverId, actions);
                }
                else {
                    throw e;
                }
            }
        }
        const block = await this.connection.provider.block({ finality: 'final' });
        const blockHash = borsh_1.baseDecode(block.header.hash);
        const publicKey = utils_1.PublicKey.from(accessKey.public_key);
        // TODO: Cache & listen for nonce updates for given access key
        const nonce = accessKey.access_key.nonce + 1;
        const transaction = transaction_1.createTransaction(this.accountId, publicKey, receiverId, nonce, actions, blockHash);
        await this.walletConnection.requestSignTransactions({
            transactions: [transaction],
            meta: walletMeta,
            callbackUrl: walletCallbackUrl
        });
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                reject(new Error('Failed to redirect to sign transaction'));
            }, 1000);
        });
        // TODO: Aggregate multiple transaction request with "debounce".
        // TODO: Introduce TrasactionQueue which also can be used to watch for status?
    }
    /**
     * Check if given access key allows the function call or method attempted in transaction
     * @param accessKey Array of {access_key: AccessKey, public_key: PublicKey} items
     * @param receiverId The NEAR account attempting to have access
     * @param actions The action(s) needed to be checked for access
     */
    async accessKeyMatchesTransaction(accessKey, receiverId, actions) {
        const { access_key: { permission } } = accessKey;
        if (permission === 'FullAccess') {
            return true;
        }
        if (permission.FunctionCall) {
            const { receiver_id: allowedReceiverId, method_names: allowedMethods } = permission.FunctionCall;
            /********************************
            Accept multisig access keys and let wallets attempt to signAndSendTransaction
            If an access key has itself as receiverId and method permission add_request_and_confirm, then it is being used in a wallet with multisig contract: https://github.com/near/core-contracts/blob/671c05f09abecabe7a7e58efe942550a35fc3292/multisig/src/lib.rs#L149-L153
            ********************************/
            if (allowedReceiverId === this.accountId && allowedMethods.includes(MULTISIG_HAS_METHOD)) {
                return true;
            }
            if (allowedReceiverId === receiverId) {
                if (actions.length !== 1) {
                    return false;
                }
                const [{ functionCall }] = actions;
                return functionCall &&
                    (!functionCall.deposit || functionCall.deposit.toString() === '0') && // TODO: Should support charging amount smaller than allowance?
                    (allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName));
                // TODO: Handle cases when allowance doesn't have enough to pay for gas
            }
        }
        // TODO: Support other permissions than FunctionCall
        return false;
    }
    /**
     * Helper function returning the access key (if it exists) to the receiver that grants the designated permission
     * @param receiverId The NEAR account seeking the access key for a transaction
     * @param actions The action(s) sought to gain access to
     * @param localKey A local public key provided to check for access
     * @returns Promise<any>
     */
    async accessKeyForTransaction(receiverId, actions, localKey) {
        const accessKeys = await this.getAccessKeys();
        if (localKey) {
            const accessKey = accessKeys.find(key => key.public_key.toString() === localKey.toString());
            if (accessKey && await this.accessKeyMatchesTransaction(accessKey, receiverId, actions)) {
                return accessKey;
            }
        }
        const walletKeys = this.walletConnection._authData.allKeys;
        for (const accessKey of accessKeys) {
            if (walletKeys.indexOf(accessKey.public_key) !== -1 && await this.accessKeyMatchesTransaction(accessKey, receiverId, actions)) {
                return accessKey;
            }
        }
        return null;
    }
}
exports.ConnectedWalletAccount = ConnectedWalletAccount;

'''
'''--- package.json ---
{
    "name": "near-api-js",
    "description": "JavaScript library to interact with NEAR Protocol via RPC API",
    "version": "0.43.1",
    "repository": {
        "type": "git",
        "url": "git+https://github.com/near/near-api-js.git"
    },
    "homepage": "https://github.com/near/near-api-js",
    "main": "lib/index.js",
    "browser": "lib/browser-index.js",
    "types": "lib/index.d.ts",
    "dependencies": {
        "bn.js": "5.2.0",
        "borsh": "^0.6.0",
        "bs58": "^4.0.0",
        "depd": "^2.0.0",
        "error-polyfill": "^0.1.3",
        "http-errors": "^1.7.2",
        "js-sha256": "^0.9.0",
        "mustache": "^4.0.0",
        "node-fetch": "^2.6.1",
        "text-encoding-utf-8": "^1.0.2",
        "tweetnacl": "^1.0.1"
    },
    "devDependencies": {
        "@types/bn.js": "^5.1.0",
        "@types/http-errors": "^1.6.1",
        "@typescript-eslint/eslint-plugin": "^2.18.0",
        "@typescript-eslint/parser": "^2.18.0",
        "browserify": "^16.2.3",
        "bundlewatch": "^0.3.1",
        "danger": "^10.6.6",
        "danger-plugin-yarn": "^1.3.2",
        "eslint": "^6.5.1",
        "in-publish": "^2.0.0",
        "jest": "^26.0.1",
        "localstorage-memory": "^1.0.3",
        "near-hello": "^0.5.1",
        "rimraf": "^3.0.0",
        "semver": "^7.1.1",
        "ts-jest": "^26.5.6",
        "ts-morph": "^11.0.3",
        "typedoc": "^0.20.36",
        "typedoc-neo-theme": "^1.1.1",
        "typescript": "^3.5.1",
        "uglifyify": "^5.0.1"
    },
    "keywords": [],
    "license": "(MIT AND Apache-2.0)",
    "scripts": {
        "dist": "yarn browserify && yarn doc",
        "browserify": "browserify browser-exports.js -i node-fetch -i http -i https -o dist/near-api-js.js && browserify browser-exports.js -i node-fetch -g uglifyify -o dist/near-api-js.min.js",
        "prebrowserify": "yarn build",
        "prepublish": "not-in-install && (yarn build && yarn browserify) || in-install",
        "compile": "tsc -p ./tsconfig.json",
        "dev": "yarn compile -w",
        "doc": "typedoc src && touch docs/.nojekyll",
        "build": "yarn compile",
        "test": "jest test",
        "lint": "eslint test && eslint src/**/*.ts",
        "fix": "eslint test --fix && eslint src/**/*.ts --fix",
        "prefuzz": "yarn build",
        "fuzz": "jsfuzz test/fuzz/borsh-roundtrip.js test/fuzz/corpus/"
    },
    "bundlewatch": {
        "files": [
            {
                "path": "dist/near-api-js.min.js",
                "maxSize": "105kB"
            }
        ]
    },
    "files": [
        "lib",
        "dist",
        "browser-exports.js"
    ],
    "author": "NEAR Inc"
}

'''
'''--- src/.eslintrc.yml ---
env:
  es6: true
  node: true
extends:
  - 'eslint:recommended'
  - 'plugin:@typescript-eslint/eslint-recommended'
  - 'plugin:@typescript-eslint/recommended'
parser: '@typescript-eslint/parser'
rules:
  no-inner-declarations: off
  '@typescript-eslint/no-explicit-any': off
  # TODO: Clean-up code and enable following rules
  '@typescript-eslint/camelcase': off
  '@typescript-eslint/explicit-function-return-type': off
  '@typescript-eslint/no-use-before-define': off

parserOptions:
  ecmaVersion: 2018
  sourceType: module
'''
'''--- src/account.ts ---
import BN from 'bn.js';
import depd from 'depd';
import {
    transfer,
    createAccount,
    signTransaction,
    deployContract,
    addKey,
    functionCall,
    fullAccessKey,
    functionCallAccessKey,
    deleteKey,
    stake,
    deleteAccount,
    Action,
    SignedTransaction,
    stringifyJsonOrBytes
} from './transaction';
import { FinalExecutionOutcome, TypedError, ErrorContext } from './providers';
import { Finality, BlockId, ViewStateResult, AccountView, AccessKeyView, CodeResult, AccessKeyList, AccessKeyInfoView, FunctionCallPermissionView } from './providers/provider';
import { Connection } from './connection';
import { baseDecode, baseEncode } from 'borsh';
import { PublicKey } from './utils/key_pair';
import { logWarning, PositionalArgsError } from './utils/errors';
import { parseRpcError, parseResultError } from './utils/rpc_errors';
import { ServerError } from './utils/rpc_errors';
import { DEFAULT_FUNCTION_CALL_GAS } from './constants';

import exponentialBackoff from './utils/exponential-backoff';

// Default number of retries with different nonce before giving up on a transaction.
const TX_NONCE_RETRY_NUMBER = 12;

// Default wait until next retry in millis.
const TX_NONCE_RETRY_WAIT = 500;

// Exponential back off for waiting to retry.
const TX_NONCE_RETRY_WAIT_BACKOFF = 1.5;

export interface AccountBalance {
    total: string;
    stateStaked: string;
    staked: string;
    available: string;
}

export interface AccountAuthorizedApp {
    contractId: string;
    amount: string;
    publicKey: string;
}

/**
 * Options used to initiate sining and sending transactions
 */
export interface SignAndSendTransactionOptions {
    receiverId: string;
    actions: Action[];
    /**
     * Metadata to send the NEAR Wallet if using it to sign transactions.
     * @see {@link RequestSignTransactionsOptions}
     */
    walletMeta?: string;
    /**
     * Callback url to send the NEAR Wallet if using it to sign transactions.
     * @see {@link RequestSignTransactionsOptions}
     */
    walletCallbackUrl?: string;
    returnError?: boolean;
}

/**
 * Options used to initiate a function call (especially a change function call)
 * @see {@link viewFunction} to initiate a view function call
 */
export interface FunctionCallOptions {
    /** The NEAR account id where the contract is deployed */
    contractId: string;
    /** The name of the method to invoke */
    methodName: string;
    /**
     * named arguments to pass the method `{ messageText: 'my message' }`
     */
    args: object;
    /** max amount of gas that method call can use */
    gas?: BN;
    /** amount of NEAR (in yoctoNEAR) to send together with the call */
    attachedDeposit?: BN;
    /**
     * Metadata to send the NEAR Wallet if using it to sign transactions.
     * @see {@link RequestSignTransactionsOptions}
     */
    walletMeta?: string;
    /**
     * Callback url to send the NEAR Wallet if using it to sign transactions.
     * @see {@link RequestSignTransactionsOptions}
     */
    walletCallbackUrl?: string;
    /**
     * Convert input arguments into bytes array.
     */
    stringify?: (input: any) => Buffer;
}

interface ReceiptLogWithFailure {
    receiptIds: [string];
    logs: [string];
    failure: ServerError;
}

function parseJsonFromRawResponse (response: Uint8Array): any {
    return JSON.parse(Buffer.from(response).toString());
}

function bytesJsonStringify(input: any): Buffer {
    return Buffer.from(JSON.stringify(input));
}

/**
 * This class provides common account related RPC calls including signing transactions with a {@link KeyPair}.
 *
 * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#account}
 * @hint Use {@link WalletConnection} in the browser to redirect to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for Account/key management using the {@link BrowserLocalStorageKeyStore}.
 * @see {@link https://nomicon.io/DataStructures/Account.html | Account Spec}
 */
export class Account {
    readonly connection: Connection;
    readonly accountId: string;

    /** @hidden */
    protected get ready(): Promise<void> {
        const deprecate = depd('Account.ready()');
        deprecate('not needed anymore, always ready');
        return Promise.resolve();
    }

    constructor(connection: Connection, accountId: string) {
        this.connection = connection;
        this.accountId = accountId;
    }

    async fetchState(): Promise<void> {
        const deprecate = depd('Account.fetchState()');
        deprecate('use `Account.state()` instead');
    }

    /**
     * Returns basic NEAR account information via the `view_account` RPC query method
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#view-account}
     */
    async state(): Promise<AccountView> {
        return this.connection.provider.query<AccountView>({
            request_type: 'view_account',
            account_id: this.accountId,
            finality: 'optimistic'
        });
    }

    /** @hidden */
    private printLogsAndFailures(contractId: string, results: [ReceiptLogWithFailure]) {
      if (!process.env["NEAR_NO_LOGS"]){
        for (const result of results) {
            console.log(`Receipt${result.receiptIds.length > 1 ? 's' : ''}: ${result.receiptIds.join(', ')}`);
            this.printLogs(contractId, result.logs, '\t');
            if (result.failure) {
                console.warn(`\tFailure [${contractId}]: ${result.failure}`);
            }
        }
      }
    }

    /** @hidden */
    private printLogs(contractId: string, logs: string[], prefix = '') {
      if (!process.env["NEAR_NO_LOGS"]){
        for (const log of logs) {
            console.log(`${prefix}Log [${contractId}]: ${log}`);
        }
      }
    }

    /**
     * Create a signed transaction which can be broadcast to the network
     * @param receiverId NEAR account receiving the transaction
     * @param actions list of actions to perform as part of the transaction
     * @see {@link JsonRpcProvider.sendTransaction}
     */
    protected async signTransaction(receiverId: string, actions: Action[]): Promise<[Uint8Array, SignedTransaction]> {
        const accessKeyInfo = await this.findAccessKey(receiverId, actions);
        if (!accessKeyInfo) {
            throw new TypedError(`Can not sign transactions for account ${this.accountId} on network ${this.connection.networkId}, no matching key pair found in ${this.connection.signer}.`, 'KeyNotFound');
        }
        const { accessKey } = accessKeyInfo;

        const block = await this.connection.provider.block({ finality: 'final' });
        const blockHash = block.header.hash;

        const nonce = ++accessKey.nonce;
        return await signTransaction(
            receiverId, nonce, actions, baseDecode(blockHash), this.connection.signer, this.accountId, this.connection.networkId
        );
    }

    /**
     * Sign a transaction to preform a list of actions and broadcast it using the RPC API.
     * @see {@link JsonRpcProvider.sendTransaction}
     */
    protected signAndSendTransaction({ receiverId, actions }: SignAndSendTransactionOptions): Promise<FinalExecutionOutcome>
    /**
     * @deprecated
     * Sign a transaction to preform a list of actions and broadcast it using the RPC API.
     * @see {@link JsonRpcProvider.sendTransaction}
     *
     * @param receiverId NEAR account receiving the transaction
     * @param actions list of actions to perform as part of the transaction
     */
    protected signAndSendTransaction(receiverId: string, actions: Action[]): Promise<FinalExecutionOutcome>
    protected signAndSendTransaction(...args: any): Promise<FinalExecutionOutcome> {
        if(typeof args[0] === 'string') {
            return this.signAndSendTransactionV1(args[0], args[1]);
        } else {
            return this.signAndSendTransactionV2(args[0]);
        }
    }

    private signAndSendTransactionV1(receiverId: string, actions: Action[]): Promise<FinalExecutionOutcome> {
        const deprecate = depd('Account.signAndSendTransaction(receiverId, actions');
        deprecate('use `Account.signAndSendTransaction(SignAndSendTransactionOptions)` instead');
        return this.signAndSendTransactionV2({ receiverId, actions });
    }

    private async signAndSendTransactionV2({ receiverId, actions, returnError }: SignAndSendTransactionOptions): Promise<FinalExecutionOutcome> {
        let txHash, signedTx;
        // TODO: TX_NONCE (different constants for different uses of exponentialBackoff?)
        const result = await exponentialBackoff(TX_NONCE_RETRY_WAIT, TX_NONCE_RETRY_NUMBER, TX_NONCE_RETRY_WAIT_BACKOFF, async () => {
            [txHash, signedTx] = await this.signTransaction(receiverId, actions);
            const publicKey = signedTx.transaction.publicKey;

            try {
                return await this.connection.provider.sendTransaction(signedTx);
            } catch (error) {
                if (error.type === 'InvalidNonce') {
                    logWarning(`Retrying transaction ${receiverId}:${baseEncode(txHash)} with new nonce.`);
                    delete this.accessKeyByPublicKeyCache[publicKey.toString()];
                    return null;
                }
                if (error.type === 'Expired') {
                    logWarning(`Retrying transaction ${receiverId}:${baseEncode(txHash)} due to expired block hash`);
                    return null;
                }

                error.context = new ErrorContext(baseEncode(txHash));
                throw error;
            }
        });
        if (!result) {
            // TODO: This should have different code actually, as means "transaction not submitted for sure"
            throw new TypedError('nonce retries exceeded for transaction. This usually means there are too many parallel requests with the same access key.', 'RetriesExceeded');
        }

        const flatLogs = [result.transaction_outcome, ...result.receipts_outcome].reduce((acc, it) => {
            if (it.outcome.logs.length ||
                (typeof it.outcome.status === 'object' && typeof it.outcome.status.Failure === 'object')) {
                return acc.concat({
                    'receiptIds': it.outcome.receipt_ids,
                    'logs': it.outcome.logs,
                    'failure': typeof it.outcome.status.Failure != 'undefined' ? parseRpcError(it.outcome.status.Failure) : null
                });
            } else return acc;
        }, []);
        this.printLogsAndFailures(signedTx.transaction.receiverId, flatLogs);

        if (!returnError && typeof result.status === 'object' && typeof result.status.Failure === 'object') {
            // if error data has error_message and error_type properties, we consider that node returned an error in the old format
            if (result.status.Failure.error_message && result.status.Failure.error_type) {
                throw new TypedError(
                    `Transaction ${result.transaction_outcome.id} failed. ${result.status.Failure.error_message}`,
                    result.status.Failure.error_type);
            } else {
                throw parseResultError(result);
            }
        }
        // TODO: if Tx is Unknown or Started.
        return result;
    }

    /** @hidden */
    accessKeyByPublicKeyCache: { [key: string]: AccessKeyView } = {}

    /**
     * Finds the {@link AccessKeyView} associated with the accounts {@link PublicKey} stored in the {@link KeyStore}.
     *
     * @todo Find matching access key based on transaction (i.e. receiverId and actions)
     *
     * @param receiverId currently unused (see todo)
     * @param actions currently unused (see todo)
     * @returns `{ publicKey PublicKey; accessKey: AccessKeyView }`
     */
    async findAccessKey(receiverId: string, actions: Action[]): Promise<{publicKey: PublicKey; accessKey: AccessKeyView}> {
        // TODO: Find matching access key based on transaction (i.e. receiverId and actions)
        const publicKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);
        if (!publicKey) {
            return null;
        }

        const cachedAccessKey = this.accessKeyByPublicKeyCache[publicKey.toString()];
        if (cachedAccessKey !== undefined) {
            return { publicKey, accessKey: cachedAccessKey };
        }

        try {
            const accessKey = await this.connection.provider.query<AccessKeyView>({
                request_type: 'view_access_key',
                account_id: this.accountId,
                public_key: publicKey.toString(),
                finality: 'optimistic'
            });

            // this function can be called multiple times and retrieve the same access key
            // this checks to see if the access key was already retrieved and cached while
            // the above network call was in flight. To keep nonce values in line, we return
            // the cached access key.
            if(this.accessKeyByPublicKeyCache[publicKey.toString()]) {
                return { publicKey, accessKey: this.accessKeyByPublicKeyCache[publicKey.toString()] };
            }

            this.accessKeyByPublicKeyCache[publicKey.toString()] = accessKey;
            return { publicKey, accessKey };
        } catch (e) {
            if (e.type == 'AccessKeyDoesNotExist') {
                return null;
            }

            throw e;
        }
    }

    /**
     * Create a new account and deploy a contract to it
     *
     * @param contractId NEAR account where the contract is deployed
     * @param publicKey The public key to add to the created contract account
     * @param data The compiled contract code
     * @param amount of NEAR to transfer to the created contract account. Transfer enough to pay for storage https://docs.near.org/docs/concepts/storage-staking
     */
    async createAndDeployContract(contractId: string, publicKey: string | PublicKey, data: Uint8Array, amount: BN): Promise<Account> {
        const accessKey = fullAccessKey();
        await this.signAndSendTransaction({
            receiverId: contractId,
            actions: [createAccount(), transfer(amount), addKey(PublicKey.from(publicKey), accessKey), deployContract(data)]
        });
        const contractAccount = new Account(this.connection, contractId);
        return contractAccount;
    }

    /**
     * @param receiverId NEAR account receiving 
     * @param amount Amount to send in yocto
     */
    async sendMoney(receiverId: string, amount: BN): Promise<FinalExecutionOutcome> {
        return this.signAndSendTransaction({
            receiverId,
            actions: [transfer(amount)]
        });
    }

    /**
     * @param newAccountId NEAR account name to be created
     * @param publicKey A public key created from the masterAccount
     */
    async createAccount(newAccountId: string, publicKey: string | PublicKey, amount: BN): Promise<FinalExecutionOutcome> {
        const accessKey = fullAccessKey();
        return this.signAndSendTransaction({
            receiverId: newAccountId,
            actions: [createAccount(), transfer(amount), addKey(PublicKey.from(publicKey), accessKey)]
        });
    }

    /**
     * @param beneficiaryId The NEAR account that will receive the remaining  balance from the account being deleted
     */
    async deleteAccount(beneficiaryId: string) {
        return this.signAndSendTransaction({
            receiverId: this.accountId,
            actions: [deleteAccount(beneficiaryId)]
        });
    }

    /**
     * @param data The compiled contract code
     */
    async deployContract(data: Uint8Array): Promise<FinalExecutionOutcome> {
        return this.signAndSendTransaction({
            receiverId: this.accountId,
            actions: [deployContract(data)]
        });
    }

    async functionCall(props: FunctionCallOptions): Promise<FinalExecutionOutcome>;
    /**
     * @deprecated
     *
     * @param contractId NEAR account where the contract is deployed
     * @param methodName The method name on the contract as it is written in the contract code
     * @param args arguments to pass to method. Can be either plain JS object which gets serialized as JSON automatically
     *  or `Uint8Array` instance which represents bytes passed as is.
     * @param gas max amount of gas that method call can use
     * @param amount amount of NEAR (in yoctoNEAR) to send together with the call
     * @returns {Promise<FinalExecutionOutcome>}
     */
    async functionCall(contractId: string, methodName: string, args: any, gas?: BN, amount?: BN): Promise<FinalExecutionOutcome>
    async functionCall(...args: any[]): Promise<FinalExecutionOutcome> {
        if(typeof args[0] === 'string') {
            return this.functionCallV1(args[0], args[1], args[2], args[3], args[4]);
        } else {
            return this.functionCallV2(args[0]);
        }
    }

    private functionCallV1(contractId: string, methodName: string, args: any, gas?: BN, amount?: BN): Promise<FinalExecutionOutcome> {
        const deprecate = depd('Account.functionCall(contractId, methodName, args, gas, amount)');
        deprecate('use `Account.functionCall(FunctionCallOptions)` instead');

        args = args || {};
        this.validateArgs(args);
        return this.signAndSendTransaction({
            receiverId: contractId,
            actions: [functionCall(methodName, args, gas || DEFAULT_FUNCTION_CALL_GAS, amount)]
        });
    }

    private functionCallV2({ contractId, methodName, args = {}, gas = DEFAULT_FUNCTION_CALL_GAS, attachedDeposit, walletMeta, walletCallbackUrl, stringify }: FunctionCallOptions): Promise<FinalExecutionOutcome> {
        this.validateArgs(args);
        const stringifyArg = stringify === undefined ? stringifyJsonOrBytes : stringify;
        return this.signAndSendTransaction({
            receiverId: contractId,
            actions: [functionCall(methodName, args, gas, attachedDeposit, stringifyArg)],
            walletMeta,
            walletCallbackUrl
        });
    }

    /**
     * @see {@link https://docs.near.org/docs/concepts/account#access-keys}
     * @todo expand this API to support more options.
     * @param publicKey A public key to be associated with the contract
     * @param contractId NEAR account where the contract is deployed
     * @param methodNames The method names on the contract that should be allowed to be called. Pass null for no method names and '' or [] for any method names.
     * @param amount Payment in yocto that is sent to the contract during this function call
     */
    async addKey(publicKey: string | PublicKey, contractId?: string, methodNames?: string|string[], amount?: BN): Promise<FinalExecutionOutcome> {
        if (!methodNames) {
            methodNames = [];
        }
        if (!Array.isArray(methodNames)) {
            methodNames = [methodNames];
        }
        let accessKey;
        if (!contractId) {
            accessKey = fullAccessKey();
        } else {
            accessKey = functionCallAccessKey(contractId, methodNames, amount);
        }
        return this.signAndSendTransaction({
            receiverId: this.accountId,
            actions: [addKey(PublicKey.from(publicKey), accessKey)]
        });
    }

    /**
     * @param publicKey The public key to be deleted
     * @returns {Promise<FinalExecutionOutcome>}
     */
    async deleteKey(publicKey: string | PublicKey): Promise<FinalExecutionOutcome> {
        return this.signAndSendTransaction({
            receiverId: this.accountId,
            actions: [deleteKey(PublicKey.from(publicKey))]
        });
    }

    /**
     * @see {@link https://docs.near.org/docs/validator/staking-overview}
     *
     * @param publicKey The public key for the account that's staking
     * @param amount The account to stake in yocto
     */
    async stake(publicKey: string | PublicKey, amount: BN): Promise<FinalExecutionOutcome> {
        return this.signAndSendTransaction({
            receiverId: this.accountId,
            actions: [stake(amount, PublicKey.from(publicKey))]
        });
    }

    /** @hidden */
    private validateArgs(args: any) {
        const isUint8Array = args.byteLength !== undefined && args.byteLength === args.length;
        if (isUint8Array) {
            return;
        }

        if (Array.isArray(args) || typeof args !== 'object') {
            throw new PositionalArgsError();
        }
    }

    /**
     * Invoke a contract view function using the RPC API.
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#call-a-contract-function}
     *
     * @param contractId NEAR account where the contract is deployed
     * @param methodName The view-only method (no state mutations) name on the contract as it is written in the contract code
     * @param args Any arguments to the view contract method, wrapped in JSON
     * @param options.parse Parse the result of the call. Receives a Buffer (bytes array) and converts it to any object. By default result will be treated as json.
     * @param options.stringify Convert input arguments into a bytes array. By default the input is treated as a JSON.
     * @returns {Promise<any>}
     */
    async viewFunction(
        contractId: string,
        methodName: string,
        args: any = {},
        { parse = parseJsonFromRawResponse, stringify = bytesJsonStringify } = {}
    ): Promise<any> {
        this.validateArgs(args);
        const serializedArgs = stringify(args).toString('base64');

        const result = await this.connection.provider.query<CodeResult>({
            request_type: 'call_function',
            account_id: contractId,
            method_name: methodName,
            args_base64: serializedArgs,
            finality: 'optimistic'
        });

        if (result.logs) {
            this.printLogs(contractId, result.logs);
        }

        return result.result && result.result.length > 0 && parse(Buffer.from(result.result));
    }

    /**
     * Returns the state (key value pairs) of this account's contract based on the key prefix.
     * Pass an empty string for prefix if you would like to return the entire state.
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#view-contract-state}
     *
     * @param prefix allows to filter which keys should be returned. Empty prefix means all keys. String prefix is utf-8 encoded.
     * @param blockQuery specifies which block to query state at. By default returns last "optimistic" block (i.e. not necessarily finalized).
     */
    async viewState(prefix: string | Uint8Array, blockQuery: { blockId: BlockId } | { finality: Finality } = { finality: 'optimistic' } ): Promise<Array<{ key: Buffer; value: Buffer}>> {
        const { values } = await this.connection.provider.query<ViewStateResult>({
            request_type: 'view_state',
            ...blockQuery,
            account_id: this.accountId,
            prefix_base64: Buffer.from(prefix).toString('base64')
        });

        return values.map(({key, value}) => ({
            key: Buffer.from(key, 'base64'),
            value: Buffer.from(value, 'base64')
        }));
    }

    /**
     * Get all access keys for the account
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#view-access-key-list}
     */
    async getAccessKeys(): Promise<AccessKeyInfoView[]> {
        const response = await this.connection.provider.query<AccessKeyList>({
            request_type: 'view_access_key_list',
            account_id: this.accountId,
            finality: 'optimistic'
        });
        // A breaking API change introduced extra information into the
        // response, so it now returns an object with a `keys` field instead
        // of an array: https://github.com/nearprotocol/nearcore/pull/1789
        if (Array.isArray(response)) {
            return response;
        }
        return response.keys;
    }

    /**
     * Returns a list of authorized apps
     * @todo update the response value to return all the different keys, not just app keys.
     */
    async getAccountDetails(): Promise<{ authorizedApps: AccountAuthorizedApp[] }> {
        // TODO: update the response value to return all the different keys, not just app keys.
        // Also if we need this function, or getAccessKeys is good enough.
        const accessKeys = await this.getAccessKeys();
        const authorizedApps = accessKeys
            .filter(item => item.access_key.permission !== 'FullAccess')
            .map(item => {
                const perm = (item.access_key.permission as FunctionCallPermissionView);
                return {
                    contractId: perm.FunctionCall.receiver_id,
                    amount: perm.FunctionCall.allowance,
                    publicKey: item.public_key,
                };
            });
        return { authorizedApps };
    }

    /**
     * Returns calculated account balance
     */
    async getAccountBalance(): Promise<AccountBalance> {
        const protocolConfig = await this.connection.provider.experimental_protocolConfig({ finality: 'final' });
        const state = await this.state();

        const costPerByte = new BN(protocolConfig.runtime_config.storage_amount_per_byte);
        const stateStaked = new BN(state.storage_usage).mul(costPerByte);
        const staked = new BN(state.locked);
        const totalBalance = new BN(state.amount).add(staked);
        const availableBalance = totalBalance.sub(BN.max(staked, stateStaked));

        return {
            total: totalBalance.toString(),
            stateStaked: stateStaked.toString(),
            staked: staked.toString(),
            available: availableBalance.toString()
        };
    }
}

'''
'''--- src/account_creator.ts ---
import BN from 'bn.js';
import { Connection } from './connection';
import { Account } from './account';
import { fetchJson } from './utils/web';
import { PublicKey } from './utils/key_pair';

/**
 * Account creator provides an interface for implementations to actually create accounts
 */
export abstract class AccountCreator {
    abstract async createAccount(newAccountId: string, publicKey: PublicKey): Promise<void>;
}

export class LocalAccountCreator extends AccountCreator {
    readonly masterAccount: Account;
    readonly initialBalance: BN;

    constructor(masterAccount: Account, initialBalance: BN) {
        super();
        this.masterAccount = masterAccount;
        this.initialBalance = initialBalance;
    }

    /**
     * Creates an account using a masterAccount, meaning the new account is created from an existing account
     * @param newAccountId The name of the NEAR account to be created
     * @param publicKey The public key from the masterAccount used to create this account
     * @returns {Promise<void>}
     */
    async createAccount(newAccountId: string, publicKey: PublicKey): Promise<void> {
        await this.masterAccount.createAccount(newAccountId, publicKey, this.initialBalance);
    }
}

export class UrlAccountCreator extends AccountCreator {
    readonly connection: Connection;
    readonly helperUrl: string;

    constructor(connection: Connection, helperUrl: string) {
        super();
        this.connection = connection;
        this.helperUrl = helperUrl;
    }

    /**
     * Creates an account using a helperUrl
     * This is [hosted here](https://helper.nearprotocol.com) or set up locally with the [near-contract-helper](https://github.com/nearprotocol/near-contract-helper) repository
     * @param newAccountId The name of the NEAR account to be created
     * @param publicKey The public key from the masterAccount used to create this account
     * @returns {Promise<void>}
     */
    async createAccount(newAccountId: string, publicKey: PublicKey): Promise<void> {
        await fetchJson(`${this.helperUrl}/account`, JSON.stringify({ newAccountId, newAccountPublicKey: publicKey.toString() }));
    }
}

'''
'''--- src/account_multisig.ts ---
'use strict';

import BN from 'bn.js';
import depd from 'depd';
import { Account, SignAndSendTransactionOptions } from './account';
import { Connection } from './connection';
import { parseNearAmount } from './utils/format';
import { PublicKey } from './utils/key_pair';
import { Action, addKey, deleteKey, deployContract, functionCall, functionCallAccessKey } from './transaction';
import { FinalExecutionOutcome } from './providers';
import { fetchJson } from './utils/web';
import { FunctionCallPermissionView } from './providers/provider';

export const MULTISIG_STORAGE_KEY = '__multisigRequest';
export const MULTISIG_ALLOWANCE = new BN(parseNearAmount('1'));
// TODO: Different gas value for different requests (can reduce gas usage dramatically)
export const MULTISIG_GAS = new BN('100000000000000');
export const MULTISIG_DEPOSIT = new BN('0');
export const MULTISIG_CHANGE_METHODS = ['add_request', 'add_request_and_confirm', 'delete_request', 'confirm'];
export const MULTISIG_CONFIRM_METHODS = ['confirm'];

type sendCodeFunction = () => Promise<any>;
type getCodeFunction = (method: any) => Promise<string>;
type verifyCodeFunction = (securityCode: any) => Promise<any>;

// in memory request cache for node w/o localStorage
const storageFallback = {
    [MULTISIG_STORAGE_KEY]: null
};

export class AccountMultisig extends Account {
    public storage: any;
    public onAddRequestResult: Function;

    constructor(connection: Connection, accountId: string, options: any) {
        super(connection, accountId);
        this.storage = options.storage;
        this.onAddRequestResult = options.onAddRequestResult;
    }

    async signAndSendTransactionWithAccount(receiverId: string, actions: Action[]): Promise<FinalExecutionOutcome> {
        return super.signAndSendTransaction({ receiverId, actions });
    }

    protected signAndSendTransaction(...args: any[]): Promise<FinalExecutionOutcome> {
        if(typeof args[0] === 'string') {
            return this._signAndSendTransaction({ receiverId: args[0], actions: args[1] });
        }

        return this._signAndSendTransaction(args[0]);
    }

    private async _signAndSendTransaction({ receiverId, actions }: SignAndSendTransactionOptions): Promise<FinalExecutionOutcome> {
        const { accountId } = this;

        const args = Buffer.from(JSON.stringify({
            request: {
                receiver_id: receiverId,
                actions: convertActions(actions, accountId, receiverId)
            }
        }));

        let result;
        try {
            result = await super.signAndSendTransaction({
                receiverId: accountId,
                actions: [
                    functionCall('add_request_and_confirm', args, MULTISIG_GAS, MULTISIG_DEPOSIT)
                ]
            });
        } catch(e) {
            if (e.toString().includes('Account has too many active requests. Confirm or delete some')) {
                await this.deleteUnconfirmedRequests();
                return await this.signAndSendTransaction(receiverId, actions);
            }
            throw e;
        }

        // TODO: Are following even needed? Seems like it throws on error already
        if (!result.status) {
            throw new Error('Request failed');
        }
        const status: any = { ...result.status };
        if (!status.SuccessValue || typeof status.SuccessValue !== 'string') {
            throw new Error('Request failed');
        }

        this.setRequest({
            accountId,
            actions,
            requestId: parseInt(Buffer.from(status.SuccessValue, 'base64').toString('ascii'), 10)
        });

        if (this.onAddRequestResult) {
            await this.onAddRequestResult(result);
        }

        // NOTE there is no await on purpose to avoid blocking for 2fa
        this.deleteUnconfirmedRequests();

        return result;
    }

    async deleteUnconfirmedRequests () {
        // TODO: Delete in batch, don't delete unexpired
        // TODO: Delete in batch, don't delete unexpired (can reduce gas usage dramatically)
        const request_ids = await this.getRequestIds();
        const { requestId } = this.getRequest();
        for (const requestIdToDelete of request_ids) {
            if (requestIdToDelete == requestId) {
                continue;
            }
            try {
                await super.signAndSendTransaction({
                    receiverId: this.accountId, 
                    actions: [functionCall('delete_request', { request_id: requestIdToDelete }, MULTISIG_GAS, MULTISIG_DEPOSIT)]
                });
            } catch(e) {
                console.warn('Attempt to delete an earlier request before 15 minutes failed. Will try again.');
            }
        }
    }

    // helpers

    async getRequestIds(): Promise<string> {
        // TODO: Read requests from state to allow filtering by expiration time
        // TODO: https://github.com/near/core-contracts/blob/305d1db4f4f2cf5ce4c1ef3479f7544957381f11/multisig/src/lib.rs#L84
        return this.viewFunction(this.accountId, 'list_request_ids');
    }

    getRequest() {
        if (this.storage) {
            return JSON.parse(this.storage.getItem(MULTISIG_STORAGE_KEY) || '{}');
        }
        return storageFallback[MULTISIG_STORAGE_KEY];
    }
    
    setRequest(data) {
        if (this.storage) {
            return this.storage.setItem(MULTISIG_STORAGE_KEY, JSON.stringify(data));
        }
        storageFallback[MULTISIG_STORAGE_KEY] = data;
    }
}

export class Account2FA extends AccountMultisig {
    /********************************
    Account2FA has options object where you can provide callbacks for:
    - sendCode: how to send the 2FA code in case you don't use NEAR Contract Helper
    - getCode: how to get code from user (use this to provide custom UI/UX for prompt of 2FA code)
    - onResult: the tx result after it's been confirmed by NEAR Contract Helper
    ********************************/   
    public sendCode: sendCodeFunction;
    public getCode: getCodeFunction;
    public verifyCode: verifyCodeFunction;
    public onConfirmResult: Function;
    public helperUrl = 'https://helper.testnet.near.org';

    constructor(connection: Connection, accountId: string, options: any) {
        super(connection, accountId, options);
        this.helperUrl = options.helperUrl || this.helperUrl;
        this.storage = options.storage;
        this.sendCode = options.sendCode || this.sendCodeDefault;
        this.getCode = options.getCode || this.getCodeDefault;
        this.verifyCode = options.verifyCode || this.verifyCodeDefault;
        this.onConfirmResult = options.onConfirmResult;
    }

    /**
     * Sign a transaction to preform a list of actions and broadcast it using the RPC API.
     * @see {@link JsonRpcProvider.sendTransaction}
     */
    signAndSendTransaction({ receiverId, actions }: SignAndSendTransactionOptions): Promise<FinalExecutionOutcome>
    /**
     * @deprecated
     * Sign a transaction to preform a list of actions and broadcast it using the RPC API.
     * @see {@link JsonRpcProvider.sendTransaction}
     * 
     * @param receiverId NEAR account receiving the transaction
     * @param actions list of actions to perform as part of the transaction
     */
    signAndSendTransaction(receiverId: string, actions: Action[]): Promise<FinalExecutionOutcome>
    async signAndSendTransaction(...args: any): Promise<FinalExecutionOutcome> {
        if(typeof args[0] === 'string') {
            const deprecate = depd('Account.signAndSendTransaction(receiverId, actions');
            deprecate('use `Account2FA.signAndSendTransaction(SignAndSendTransactionOptions)` instead');
            return this.__signAndSendTransaction({ receiverId: args[0], actions: args[1] });
        } else {
            return this.__signAndSendTransaction(args[0]);
        }
    }

    private async __signAndSendTransaction({ receiverId, actions }: SignAndSendTransactionOptions) {
        await super.signAndSendTransaction({ receiverId, actions });
        // TODO: Should following override onRequestResult in superclass instead of doing custom signAndSendTransaction?
        await this.sendCode();
        const result = await this.promptAndVerify();
        if (this.onConfirmResult) {
            await this.onConfirmResult(result);
        }
        return result;
    }

    // default helpers for CH deployments of multisig

    async deployMultisig(contractBytes: Uint8Array) {
        const { accountId } = this;

        const seedOrLedgerKey = (await this.getRecoveryMethods()).data
            .filter(({ kind, publicKey }) => (kind === 'phrase' || kind === 'ledger') && publicKey !== null)
            .map((rm) => rm.publicKey);

        const fak2lak = (await this.getAccessKeys())
            .filter(({ public_key, access_key: { permission } }) => permission === 'FullAccess' && !seedOrLedgerKey.includes(public_key))
            .map((ak) => ak.public_key)
            .map(toPK);

        const confirmOnlyKey = toPK((await this.postSignedJson('/2fa/getAccessKey', { accountId })).publicKey);

        const newArgs = Buffer.from(JSON.stringify({ 'num_confirmations': 2 }));

        const actions = [
            ...fak2lak.map((pk) => deleteKey(pk)),
            ...fak2lak.map((pk) => addKey(pk, functionCallAccessKey(accountId, MULTISIG_CHANGE_METHODS, null))),
            addKey(confirmOnlyKey, functionCallAccessKey(accountId, MULTISIG_CONFIRM_METHODS, null)),
            deployContract(contractBytes),
        ];
        if ((await this.state()).code_hash === '11111111111111111111111111111111') {
            actions.push(functionCall('new', newArgs, MULTISIG_GAS, MULTISIG_DEPOSIT),);
        }
        console.log('deploying multisig contract for', accountId);
        return await super.signAndSendTransactionWithAccount(accountId, actions);
    }

    async disable(contractBytes: Uint8Array) {
        const { accountId } = this;
        const accessKeys = await this.getAccessKeys();
        const lak2fak = accessKeys
            .filter(({ access_key }) => access_key.permission !== 'FullAccess')
            .filter(({ access_key }) => {
                const perm = (access_key.permission as FunctionCallPermissionView).FunctionCall;
                return  perm.receiver_id === accountId &&
                    perm.method_names.length === 4 &&
                    perm.method_names.includes('add_request_and_confirm');
            });
        const confirmOnlyKey = PublicKey.from((await this.postSignedJson('/2fa/getAccessKey', { accountId })).publicKey);
        const actions = [
            deleteKey(confirmOnlyKey),
            ...lak2fak.map(({ public_key }) => deleteKey(PublicKey.from(public_key))),
            ...lak2fak.map(({ public_key }) => addKey(PublicKey.from(public_key), null)),
            deployContract(contractBytes),
        ];
        console.log('disabling 2fa for', accountId);
        return await this.signAndSendTransaction({
            receiverId: accountId,
            actions
        });
    }

    async sendCodeDefault() {
        const { accountId } = this;
        const { requestId } = this.getRequest();
        const method = await this.get2faMethod();
        await this.postSignedJson('/2fa/send', {
            accountId,
            method,
            requestId,
        });
        return requestId;
    }

    async getCodeDefault(method: any): Promise<string> {
        throw new Error('There is no getCode callback provided. Please provide your own in AccountMultisig constructor options. It has a parameter method where method.kind is "email" or "phone".');
    }

    async promptAndVerify() {
        const method = await this.get2faMethod();
        const securityCode = await this.getCode(method);
        try {
            const result = await this.verifyCode(securityCode);

            // TODO: Parse error from result for real (like in normal account.signAndSendTransaction)
            return result;
        } catch (e) {
            console.warn('Error validating security code:', e);
            if (e.toString().includes('invalid 2fa code provided') || e.toString().includes('2fa code not valid')) {
                return await this.promptAndVerify();
            }

            throw e;
        }
    }

    async verifyCodeDefault(securityCode: string) {
        const { accountId } = this;
        const request = this.getRequest();
        if (!request) {
            throw new Error('no request pending');
        }
        const { requestId } = request;
        return await this.postSignedJson('/2fa/verify', {
            accountId,
            securityCode,
            requestId
        });
    }

    async getRecoveryMethods() {
        const { accountId } = this;
        return {
            accountId,
            data: await this.postSignedJson('/account/recoveryMethods', { accountId })
        };
    }

    async get2faMethod() {
        let { data } = await this.getRecoveryMethods();
        if (data && data.length) {
            data = data.find((m) => m.kind.indexOf('2fa-') === 0);
        }
        if (!data) return null;
        const { kind, detail } = data;
        return { kind, detail };
    }

    async signatureFor() {
        const { accountId } = this;
        const block = await this.connection.provider.block({ finality: 'final' });
        const blockNumber = block.header.height.toString();
        const signed = await this.connection.signer.signMessage(Buffer.from(blockNumber), accountId, this.connection.networkId);
        const blockNumberSignature = Buffer.from(signed.signature).toString('base64');
        return { blockNumber, blockNumberSignature };
    }

    async postSignedJson(path, body) {
        return await fetchJson(this.helperUrl + path, JSON.stringify({
            ...body,
            ...(await this.signatureFor())
        }));
    }
}

// helpers
const toPK = (pk) => PublicKey.from(pk);
const convertPKForContract = (pk) => pk.toString().replace('ed25519:', '');

const convertActions = (actions, accountId, receiverId) => actions.map((a) => {
    const type = a.enum;
    const { gas, publicKey, methodName, args, deposit, accessKey, code } = a[type];
    const action = {
        type: type[0].toUpperCase() + type.substr(1),
        gas: (gas && gas.toString()) || undefined,
        public_key: (publicKey && convertPKForContract(publicKey)) || undefined,
        method_name: methodName,
        args: (args && Buffer.from(args).toString('base64')) || undefined,
        code: (code && Buffer.from(code).toString('base64')) || undefined,
        amount: (deposit && deposit.toString()) || undefined,
        deposit: (deposit && deposit.toString()) || '0',
        permission: undefined,
    };
    if (accessKey) {
        if (receiverId === accountId && accessKey.permission.enum !== 'fullAccess') {
            action.permission = {
                receiver_id: accountId,
                allowance: MULTISIG_ALLOWANCE.toString(),
                method_names: MULTISIG_CHANGE_METHODS,
            };
        }
        if (accessKey.permission.enum === 'functionCall') {
            const { receiverId: receiver_id, methodNames: method_names, allowance } = accessKey.permission.functionCall;
            action.permission = {
                receiver_id,
                allowance: (allowance && allowance.toString()) || undefined,
                method_names
            };
        }
    }
    return action;
});

'''
'''--- src/browser-connect.ts ---
/**
 * Connect to NEAR using the provided configuration.
 *
 * {@link ConnectConfig.networkId} and {@link ConnectConfig.nodeUrl} are required.
 *
 * To sign transactions you can also pass: {@link ConnectConfig.keyStore}
 *
 * Both are passed they are prioritize in that order.
 *
 * @see {@link ConnectConfig}
 * @example
 * ```js
 * async function initNear() {
 *   const near = await connect({
 *      networkId: 'testnet',
 *      nodeUrl: 'https://rpc.testnet.near.org'
 *   })
 * }
 * ```
 *
 * @module browserConnect
 */
import { Near, NearConfig } from "./near";

export interface ConnectConfig extends NearConfig {
    /** @hidden */
    keyPath?: string;
}

/**
 * Initialize connection to Near network.
 */
export async function connect(config: ConnectConfig): Promise<Near> {
    return new Near(config);
}

'''
'''--- src/browser-index.ts ---
/** @hidden @module */
export * as keyStores from './key_stores/browser-index';
export * from './common-index';
export * from './browser-connect';

import 'error-polyfill';

'''
'''--- src/common-index.ts ---
/** @hidden @module */
import * as providers from './providers';
import * as utils from './utils';
import * as transactions from './transaction';
import * as validators from './validators';

import { Account } from './account';
import * as multisig from './account_multisig';
import * as accountCreator from './account_creator';
import { Connection } from './connection';
import { Signer, InMemorySigner } from './signer';
import { Contract } from './contract';
import { KeyPair } from './utils/key_pair';
import { Near } from './near';

// TODO: Deprecate and remove WalletAccount
import {
    ConnectedWalletAccount,
    WalletAccount,
    WalletConnection
} from './wallet-account';

export {
    accountCreator,
    providers,
    utils,
    transactions,
    validators,

    multisig,
    Account,
    Connection,
    Contract,
    InMemorySigner,
    Signer,
    KeyPair,

    Near,

    ConnectedWalletAccount,
    WalletAccount,
    WalletConnection
};

'''
'''--- src/connect.ts ---
/**
 * Connect to NEAR using the provided configuration.
 *
 * {@link ConnectConfig.networkId} and {@link ConnectConfig.nodeUrl} are required.
 *
 * To sign transactions you can also pass:
 * 1. {@link ConnectConfig.keyStore}
 * 2. {@link ConnectConfig.keyPath}
 *
 * If all three are passed they are prioritize in that order.
 *
 * @see {@link ConnectConfig}
 * @example
 * ```js
 * async function initNear() {
 *   const near = await connect({
 *      networkId: 'testnet',
 *      nodeUrl: 'https://rpc.testnet.near.org'
 *   })
 * }
 * ```
 * @module connect
 */
import { readKeyFile } from './key_stores/unencrypted_file_system_keystore';
import { InMemoryKeyStore, MergeKeyStore } from './key_stores';
import { Near, NearConfig } from './near';
import fetch from './utils/setup-node-fetch';
import { logWarning } from './utils';

global.fetch = fetch;

export interface ConnectConfig extends NearConfig {
    /**
     * Initialize an {@link InMemoryKeyStore} by reading the file at keyPath.
     */
    keyPath?: string;
}

/**
 * Initialize connection to Near network.
 */
export async function connect(config: ConnectConfig): Promise<Near> {
    // Try to find extra key in `KeyPath` if provided.
    if (config.keyPath && (config.keyStore || config.deps && config.deps.keyStore)) {
        try {
            const accountKeyFile = await readKeyFile(config.keyPath);
            if (accountKeyFile[0]) {
                // TODO: Only load key if network ID matches
                const keyPair = accountKeyFile[1];
                const keyPathStore = new InMemoryKeyStore();
                await keyPathStore.setKey(config.networkId, accountKeyFile[0], keyPair);
                if (!config.masterAccount) {
                    config.masterAccount = accountKeyFile[0];
                }
                config.keyStore = new MergeKeyStore([
                    keyPathStore,
                    (config.keyStore || config.deps.keyStore)
                ], { writeKeyStoreIndex: 1 });
                if (!process.env["NEAR_NO_LOGS"]){
                    console.log(`Loaded master account ${accountKeyFile[0]} key from ${config.keyPath} with public key = ${keyPair.getPublicKey()}`);
                }
            }
        } catch (error) {
            logWarning(`Failed to load master account key from ${config.keyPath}: ${error}`);
        }
    }
    return new Near(config);
}

'''
'''--- src/connection.ts ---
import { Provider, JsonRpcProvider } from './providers';
import { Signer, InMemorySigner } from './signer';

/**
 * @param config Contains connection info details
 * @returns {Provider}
 */
function getProvider(config: any): Provider {
    switch (config.type) {
        case undefined:
            return config;
        case 'JsonRpcProvider': return new JsonRpcProvider(config.args.url);
        default: throw new Error(`Unknown provider type ${config.type}`);
    }
}

/**
 * @param config Contains connection info details
 * @returns {Signer}
 */
function getSigner(config: any): Signer {
    switch (config.type) {
        case undefined:
            return config;
        case 'InMemorySigner': {
            return new InMemorySigner(config.keyStore);
        }
        default: throw new Error(`Unknown signer type ${config.type}`);
    }
}

/**
 * Connects an account to a given network via a given provider
 */
export class Connection {
    readonly networkId: string;
    readonly provider: Provider;
    readonly signer: Signer;

    constructor(networkId: string, provider: Provider, signer: Signer) {
        this.networkId = networkId;
        this.provider = provider;
        this.signer = signer;
    }

    /**
     * @param config Contains connection info details
     */
    static fromConfig(config: any): Connection {
        const provider = getProvider(config.provider);
        const signer = getSigner(config.signer);
        return new Connection(config.networkId, provider, signer);
    }
}

'''
'''--- src/constants.ts ---
import BN from 'bn.js';

// Default amount of gas to be sent with the function calls. Used to pay for the fees
// incurred while running the contract execution. The unused amount will be refunded back to
// the originator.
// Due to protocol changes that charge upfront for the maximum possible gas price inflation due to
// full blocks, the price of max_prepaid_gas is decreased to `300 * 10**12`.
// For discussion see https://github.com/nearprotocol/NEPs/issues/67
export const DEFAULT_FUNCTION_CALL_GAS = new BN('30000000000000');
'''
'''--- src/contract.ts ---
import BN from 'bn.js';
import depd from 'depd';
import { Account } from './account';
import { getTransactionLastResult } from './providers';
import { PositionalArgsError, ArgumentTypeError } from './utils/errors';

// Makes `function.name` return given name
function nameFunction(name: string, body: (args?: any[]) => {}) {
    return {
        [name](...args: any[]) {
            return body(...args);
        }
    }[name];
}

const isUint8Array = (x: any) =>
    x && x.byteLength !== undefined && x.byteLength === x.length;

const isObject = (x: any) =>
    Object.prototype.toString.call(x) === '[object Object]';

interface ChangeMethodOptions {
    args: object;
    methodName: string;
    gas?: BN;
    amount?: BN;
    meta?: string;
    callbackUrl?: string;
}

export interface ContractMethods {
    /**
     * Methods that change state. These methods cost gas and require a signed transaction.
     * 
     * @see {@link Account.functionCall}
     */
    changeMethods: string[];

    /**
     * View methods do not require a signed transaction.
     * 
     * @@see {@link Account.viewFunction}
     */
    viewMethods: string[];
}

/**
 * Defines a smart contract on NEAR including the change (mutable) and view (non-mutable) methods
 * 
 * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#contract}
 * @example
 * ```js
 * import { Contract } from 'near-api-js';
 * 
 * async function contractExample() {
 *   const methodOptions = {
 *     viewMethods: ['getMessageByAccountId'],
 *     changeMethods: ['addMessage']
 *   };
 *   const contract = new Contract(
 *     wallet.account(),
 *     'contract-id.testnet',
 *     methodOptions
 *   );
 * 
 *   // use a contract view method
 *   const messages = await contract.getMessages({
 *     accountId: 'example-account.testnet'
 *   });
 * 
 *   // use a contract change method
 *   await contract.addMessage({
 *      meta: 'some info',
 *      callbackUrl: 'https://example.com/callback',
 *      args: { text: 'my message' },
 *      amount: 1
 *   })
 * }
 * ```
 */
export class Contract {
    readonly account: Account;
    readonly contractId: string;

    /**
     * @param account NEAR account to sign change method transactions
     * @param contractId NEAR account id where the contract is deployed
     * @param options NEAR smart contract methods that your application will use. These will be available as `contract.methodName`
     */
    constructor(account: Account, contractId: string, options: ContractMethods) {
        this.account = account;
        this.contractId = contractId;
        const { viewMethods = [], changeMethods = [] } = options;
        viewMethods.forEach((methodName) => {
            Object.defineProperty(this, methodName, {
                writable: false,
                enumerable: true,
                value: nameFunction(methodName, async (args: object = {}, options = {}, ...ignored) => {
                    if (ignored.length || !(isObject(args) || isUint8Array(args)) || !isObject(options)) {
                        throw new PositionalArgsError();
                    }
                    return this.account.viewFunction(this.contractId, methodName, args, options);
                })
            });
        });
        changeMethods.forEach((methodName) => {
            Object.defineProperty(this, methodName, {
                writable: false,
                enumerable: true,
                value: nameFunction(methodName, async (...args: any[]) => {
                    if (args.length && (args.length > 3 || !(isObject(args[0]) || isUint8Array(args[0])))) {
                        throw new PositionalArgsError();
                    }

                    if(args.length > 1 || !(args[0] && args[0].args)) {
                        const deprecate = depd('contract.methodName(args, gas, amount)');
                        deprecate('use `contract.methodName({ args, gas?, amount?, callbackUrl?, meta? })` instead');
                        return this._changeMethod({
                            methodName,
                            args: args[0],
                            gas: args[1],
                            amount: args[2]
                        });
                    }

                    return this._changeMethod({ methodName, ...args[0] });
                })
            });
        });
    }

    private async _changeMethod({ args, methodName, gas, amount, meta, callbackUrl }: ChangeMethodOptions) {
        validateBNLike({ gas, amount });

        const rawResult = await this.account.functionCall({
            contractId: this.contractId,
            methodName,
            args,
            gas,
            attachedDeposit: amount,
            walletMeta: meta,
            walletCallbackUrl: callbackUrl
        });

        return getTransactionLastResult(rawResult);
    }
}

/**
 * Validation on arguments being a big number from bn.js
 * Throws if an argument is not in BN format or otherwise invalid
 * @param argMap
 */
function validateBNLike(argMap: { [name: string]: any }) {
    const bnLike = 'number, decimal string or BN';
    for (const argName of Object.keys(argMap)) {
        const argValue = argMap[argName];
        if (argValue && !BN.isBN(argValue) && isNaN(argValue)) {
            throw new ArgumentTypeError(argName, bnLike, argValue);
        }
    }
}

'''
'''--- src/generated/rpc_error_schema.json ---
{
  "schema": {
    "BadUTF16": {
      "name": "BadUTF16",
      "subtypes": [],
      "props": {}
    },
    "BadUTF8": {
      "name": "BadUTF8",
      "subtypes": [],
      "props": {}
    },
    "BalanceExceeded": {
      "name": "BalanceExceeded",
      "subtypes": [],
      "props": {}
    },
    "BreakpointTrap": {
      "name": "BreakpointTrap",
      "subtypes": [],
      "props": {}
    },
    "CacheError": {
      "name": "CacheError",
      "subtypes": [
        "ReadError",
        "WriteError",
        "DeserializationError",
        "SerializationError"
      ],
      "props": {}
    },
    "CallIndirectOOB": {
      "name": "CallIndirectOOB",
      "subtypes": [],
      "props": {}
    },
    "CannotAppendActionToJointPromise": {
      "name": "CannotAppendActionToJointPromise",
      "subtypes": [],
      "props": {}
    },
    "CannotReturnJointPromise": {
      "name": "CannotReturnJointPromise",
      "subtypes": [],
      "props": {}
    },
    "CodeDoesNotExist": {
      "name": "CodeDoesNotExist",
      "subtypes": [],
      "props": {
        "account_id": ""
      }
    },
    "CompilationError": {
      "name": "CompilationError",
      "subtypes": [
        "CodeDoesNotExist",
        "PrepareError",
        "WasmerCompileError"
      ],
      "props": {}
    },
    "ContractSizeExceeded": {
      "name": "ContractSizeExceeded",
      "subtypes": [],
      "props": {
        "limit": "",
        "size": ""
      }
    },
    "Deprecated": {
      "name": "Deprecated",
      "subtypes": [],
      "props": {
        "method_name": ""
      }
    },
    "Deserialization": {
      "name": "Deserialization",
      "subtypes": [],
      "props": {}
    },
    "DeserializationError": {
      "name": "DeserializationError",
      "subtypes": [],
      "props": {}
    },
    "EmptyMethodName": {
      "name": "EmptyMethodName",
      "subtypes": [],
      "props": {}
    },
    "FunctionCallError": {
      "name": "FunctionCallError",
      "subtypes": [
        "CompilationError",
        "LinkError",
        "MethodResolveError",
        "WasmTrap",
        "WasmUnknownError",
        "HostError",
        "EvmError"
      ],
      "props": {}
    },
    "GasExceeded": {
      "name": "GasExceeded",
      "subtypes": [],
      "props": {}
    },
    "GasInstrumentation": {
      "name": "GasInstrumentation",
      "subtypes": [],
      "props": {}
    },
    "GasLimitExceeded": {
      "name": "GasLimitExceeded",
      "subtypes": [],
      "props": {}
    },
    "GenericTrap": {
      "name": "GenericTrap",
      "subtypes": [],
      "props": {}
    },
    "GuestPanic": {
      "name": "GuestPanic",
      "subtypes": [],
      "props": {
        "panic_msg": ""
      }
    },
    "HostError": {
      "name": "HostError",
      "subtypes": [
        "BadUTF16",
        "BadUTF8",
        "GasExceeded",
        "GasLimitExceeded",
        "BalanceExceeded",
        "EmptyMethodName",
        "GuestPanic",
        "IntegerOverflow",
        "InvalidPromiseIndex",
        "CannotAppendActionToJointPromise",
        "CannotReturnJointPromise",
        "InvalidPromiseResultIndex",
        "InvalidRegisterId",
        "IteratorWasInvalidated",
        "MemoryAccessViolation",
        "InvalidReceiptIndex",
        "InvalidIteratorIndex",
        "InvalidAccountId",
        "InvalidMethodName",
        "InvalidPublicKey",
        "ProhibitedInView",
        "NumberOfLogsExceeded",
        "KeyLengthExceeded",
        "ValueLengthExceeded",
        "TotalLogLengthExceeded",
        "NumberPromisesExceeded",
        "NumberInputDataDependenciesExceeded",
        "ReturnedValueLengthExceeded",
        "ContractSizeExceeded",
        "Deprecated"
      ],
      "props": {}
    },
    "IllegalArithmetic": {
      "name": "IllegalArithmetic",
      "subtypes": [],
      "props": {}
    },
    "IncorrectCallIndirectSignature": {
      "name": "IncorrectCallIndirectSignature",
      "subtypes": [],
      "props": {}
    },
    "Instantiate": {
      "name": "Instantiate",
      "subtypes": [],
      "props": {}
    },
    "IntegerOverflow": {
      "name": "IntegerOverflow",
      "subtypes": [],
      "props": {}
    },
    "InternalMemoryDeclared": {
      "name": "InternalMemoryDeclared",
      "subtypes": [],
      "props": {}
    },
    "InvalidAccountId": {
      "name": "InvalidAccountId",
      "subtypes": [],
      "props": {
        "account_id": ""
      }
    },
    "InvalidIteratorIndex": {
      "name": "InvalidIteratorIndex",
      "subtypes": [],
      "props": {
        "iterator_index": ""
      }
    },
    "InvalidMethodName": {
      "name": "InvalidMethodName",
      "subtypes": [],
      "props": {}
    },
    "InvalidPromiseIndex": {
      "name": "InvalidPromiseIndex",
      "subtypes": [],
      "props": {
        "promise_idx": ""
      }
    },
    "InvalidPromiseResultIndex": {
      "name": "InvalidPromiseResultIndex",
      "subtypes": [],
      "props": {
        "result_idx": ""
      }
    },
    "InvalidPublicKey": {
      "name": "InvalidPublicKey",
      "subtypes": [],
      "props": {}
    },
    "InvalidReceiptIndex": {
      "name": "InvalidReceiptIndex",
      "subtypes": [],
      "props": {
        "receipt_index": ""
      }
    },
    "InvalidRegisterId": {
      "name": "InvalidRegisterId",
      "subtypes": [],
      "props": {
        "register_id": ""
      }
    },
    "IteratorWasInvalidated": {
      "name": "IteratorWasInvalidated",
      "subtypes": [],
      "props": {
        "iterator_index": ""
      }
    },
    "KeyLengthExceeded": {
      "name": "KeyLengthExceeded",
      "subtypes": [],
      "props": {
        "length": "",
        "limit": ""
      }
    },
    "LinkError": {
      "name": "LinkError",
      "subtypes": [],
      "props": {
        "msg": ""
      }
    },
    "Memory": {
      "name": "Memory",
      "subtypes": [],
      "props": {}
    },
    "MemoryAccessViolation": {
      "name": "MemoryAccessViolation",
      "subtypes": [],
      "props": {}
    },
    "MemoryOutOfBounds": {
      "name": "MemoryOutOfBounds",
      "subtypes": [],
      "props": {}
    },
    "MethodEmptyName": {
      "name": "MethodEmptyName",
      "subtypes": [],
      "props": {}
    },
    "MethodInvalidSignature": {
      "name": "MethodInvalidSignature",
      "subtypes": [],
      "props": {}
    },
    "MethodNotFound": {
      "name": "MethodNotFound",
      "subtypes": [],
      "props": {}
    },
    "MethodResolveError": {
      "name": "MethodResolveError",
      "subtypes": [
        "MethodEmptyName",
        "MethodUTF8Error",
        "MethodNotFound",
        "MethodInvalidSignature"
      ],
      "props": {}
    },
    "MethodUTF8Error": {
      "name": "MethodUTF8Error",
      "subtypes": [],
      "props": {}
    },
    "MisalignedAtomicAccess": {
      "name": "MisalignedAtomicAccess",
      "subtypes": [],
      "props": {}
    },
    "NumberInputDataDependenciesExceeded": {
      "name": "NumberInputDataDependenciesExceeded",
      "subtypes": [],
      "props": {
        "limit": "",
        "number_of_input_data_dependencies": ""
      }
    },
    "NumberOfLogsExceeded": {
      "name": "NumberOfLogsExceeded",
      "subtypes": [],
      "props": {
        "limit": ""
      }
    },
    "NumberPromisesExceeded": {
      "name": "NumberPromisesExceeded",
      "subtypes": [],
      "props": {
        "limit": "",
        "number_of_promises": ""
      }
    },
    "PrepareError": {
      "name": "PrepareError",
      "subtypes": [
        "Serialization",
        "Deserialization",
        "InternalMemoryDeclared",
        "GasInstrumentation",
        "StackHeightInstrumentation",
        "Instantiate",
        "Memory"
      ],
      "props": {}
    },
    "ProhibitedInView": {
      "name": "ProhibitedInView",
      "subtypes": [],
      "props": {
        "method_name": ""
      }
    },
    "ReadError": {
      "name": "ReadError",
      "subtypes": [],
      "props": {}
    },
    "ReturnedValueLengthExceeded": {
      "name": "ReturnedValueLengthExceeded",
      "subtypes": [],
      "props": {
        "length": "",
        "limit": ""
      }
    },
    "Serialization": {
      "name": "Serialization",
      "subtypes": [],
      "props": {}
    },
    "SerializationError": {
      "name": "SerializationError",
      "subtypes": [],
      "props": {
        "hash": ""
      }
    },
    "StackHeightInstrumentation": {
      "name": "StackHeightInstrumentation",
      "subtypes": [],
      "props": {}
    },
    "StackOverflow": {
      "name": "StackOverflow",
      "subtypes": [],
      "props": {}
    },
    "TotalLogLengthExceeded": {
      "name": "TotalLogLengthExceeded",
      "subtypes": [],
      "props": {
        "length": "",
        "limit": ""
      }
    },
    "Unreachable": {
      "name": "Unreachable",
      "subtypes": [],
      "props": {}
    },
    "ValueLengthExceeded": {
      "name": "ValueLengthExceeded",
      "subtypes": [],
      "props": {
        "length": "",
        "limit": ""
      }
    },
    "WasmTrap": {
      "name": "WasmTrap",
      "subtypes": [
        "Unreachable",
        "IncorrectCallIndirectSignature",
        "MemoryOutOfBounds",
        "CallIndirectOOB",
        "IllegalArithmetic",
        "MisalignedAtomicAccess",
        "BreakpointTrap",
        "StackOverflow",
        "GenericTrap"
      ],
      "props": {}
    },
    "WasmUnknownError": {
      "name": "WasmUnknownError",
      "subtypes": [],
      "props": {}
    },
    "WasmerCompileError": {
      "name": "WasmerCompileError",
      "subtypes": [],
      "props": {
        "msg": ""
      }
    },
    "WriteError": {
      "name": "WriteError",
      "subtypes": [],
      "props": {}
    },
    "AccessKeyNotFound": {
      "name": "AccessKeyNotFound",
      "subtypes": [],
      "props": {
        "account_id": "",
        "public_key": ""
      }
    },
    "AccountAlreadyExists": {
      "name": "AccountAlreadyExists",
      "subtypes": [],
      "props": {
        "account_id": ""
      }
    },
    "AccountDoesNotExist": {
      "name": "AccountDoesNotExist",
      "subtypes": [],
      "props": {
        "account_id": ""
      }
    },
    "ActionError": {
      "name": "ActionError",
      "subtypes": [
        "AccountAlreadyExists",
        "AccountDoesNotExist",
        "CreateAccountOnlyByRegistrar",
        "CreateAccountNotAllowed",
        "ActorNoPermission",
        "DeleteKeyDoesNotExist",
        "AddKeyAlreadyExists",
        "DeleteAccountStaking",
        "LackBalanceForState",
        "TriesToUnstake",
        "TriesToStake",
        "InsufficientStake",
        "FunctionCallError",
        "NewReceiptValidationError",
        "OnlyImplicitAccountCreationAllowed"
      ],
      "props": {
        "index": ""
      }
    },
    "ActionsValidationError": {
      "name": "ActionsValidationError",
      "subtypes": [
        "DeleteActionMustBeFinal",
        "TotalPrepaidGasExceeded",
        "TotalNumberOfActionsExceeded",
        "AddKeyMethodNamesNumberOfBytesExceeded",
        "AddKeyMethodNameLengthExceeded",
        "IntegerOverflow",
        "InvalidAccountId",
        "ContractSizeExceeded",
        "FunctionCallMethodNameLengthExceeded",
        "FunctionCallArgumentsLengthExceeded",
        "UnsuitableStakingKey",
        "FunctionCallZeroAttachedGas"
      ],
      "props": {}
    },
    "ActorNoPermission": {
      "name": "ActorNoPermission",
      "subtypes": [],
      "props": {
        "account_id": "",
        "actor_id": ""
      }
    },
    "AddKeyAlreadyExists": {
      "name": "AddKeyAlreadyExists",
      "subtypes": [],
      "props": {
        "account_id": "",
        "public_key": ""
      }
    },
    "AddKeyMethodNameLengthExceeded": {
      "name": "AddKeyMethodNameLengthExceeded",
      "subtypes": [],
      "props": {
        "length": "",
        "limit": ""
      }
    },
    "AddKeyMethodNamesNumberOfBytesExceeded": {
      "name": "AddKeyMethodNamesNumberOfBytesExceeded",
      "subtypes": [],
      "props": {
        "limit": "",
        "total_number_of_bytes": ""
      }
    },
    "BalanceMismatchError": {
      "name": "BalanceMismatchError",
      "subtypes": [],
      "props": {
        "final_accounts_balance": "",
        "final_postponed_receipts_balance": "",
        "incoming_receipts_balance": "",
        "incoming_validator_rewards": "",
        "initial_accounts_balance": "",
        "initial_postponed_receipts_balance": "",
        "new_delayed_receipts_balance": "",
        "other_burnt_amount": "",
        "outgoing_receipts_balance": "",
        "processed_delayed_receipts_balance": "",
        "slashed_burnt_amount": "",
        "tx_burnt_amount": ""
      }
    },
    "CostOverflow": {
      "name": "CostOverflow",
      "subtypes": [],
      "props": {}
    },
    "CreateAccountNotAllowed": {
      "name": "CreateAccountNotAllowed",
      "subtypes": [],
      "props": {
        "account_id": "",
        "predecessor_id": ""
      }
    },
    "CreateAccountOnlyByRegistrar": {
      "name": "CreateAccountOnlyByRegistrar",
      "subtypes": [],
      "props": {
        "account_id": "",
        "predecessor_id": "",
        "registrar_account_id": ""
      }
    },
    "DeleteAccountStaking": {
      "name": "DeleteAccountStaking",
      "subtypes": [],
      "props": {
        "account_id": ""
      }
    },
    "DeleteActionMustBeFinal": {
      "name": "DeleteActionMustBeFinal",
      "subtypes": [],
      "props": {}
    },
    "DeleteKeyDoesNotExist": {
      "name": "DeleteKeyDoesNotExist",
      "subtypes": [],
      "props": {
        "account_id": "",
        "public_key": ""
      }
    },
    "DepositWithFunctionCall": {
      "name": "DepositWithFunctionCall",
      "subtypes": [],
      "props": {}
    },
    "Expired": {
      "name": "Expired",
      "subtypes": [],
      "props": {}
    },
    "FunctionCallArgumentsLengthExceeded": {
      "name": "FunctionCallArgumentsLengthExceeded",
      "subtypes": [],
      "props": {
        "length": "",
        "limit": ""
      }
    },
    "FunctionCallMethodNameLengthExceeded": {
      "name": "FunctionCallMethodNameLengthExceeded",
      "subtypes": [],
      "props": {
        "length": "",
        "limit": ""
      }
    },
    "FunctionCallZeroAttachedGas": {
      "name": "FunctionCallZeroAttachedGas",
      "subtypes": [],
      "props": {}
    },
    "InsufficientStake": {
      "name": "InsufficientStake",
      "subtypes": [],
      "props": {
        "account_id": "",
        "minimum_stake": "",
        "stake": ""
      }
    },
    "InvalidAccessKeyError": {
      "name": "InvalidAccessKeyError",
      "subtypes": [
        "AccessKeyNotFound",
        "ReceiverMismatch",
        "MethodNameMismatch",
        "RequiresFullAccess",
        "NotEnoughAllowance",
        "DepositWithFunctionCall"
      ],
      "props": {}
    },
    "InvalidChain": {
      "name": "InvalidChain",
      "subtypes": [],
      "props": {}
    },
    "InvalidDataReceiverId": {
      "name": "InvalidDataReceiverId",
      "subtypes": [],
      "props": {
        "account_id": ""
      }
    },
    "InvalidNonce": {
      "name": "InvalidNonce",
      "subtypes": [],
      "props": {
        "ak_nonce": "",
        "tx_nonce": ""
      }
    },
    "InvalidPredecessorId": {
      "name": "InvalidPredecessorId",
      "subtypes": [],
      "props": {
        "account_id": ""
      }
    },
    "InvalidReceiverId": {
      "name": "InvalidReceiverId",
      "subtypes": [],
      "props": {
        "account_id": ""
      }
    },
    "InvalidSignature": {
      "name": "InvalidSignature",
      "subtypes": [],
      "props": {}
    },
    "InvalidSignerId": {
      "name": "InvalidSignerId",
      "subtypes": [],
      "props": {
        "account_id": ""
      }
    },
    "InvalidTxError": {
      "name": "InvalidTxError",
      "subtypes": [
        "InvalidAccessKeyError",
        "InvalidSignerId",
        "SignerDoesNotExist",
        "InvalidNonce",
        "InvalidReceiverId",
        "InvalidSignature",
        "NotEnoughBalance",
        "LackBalanceForState",
        "CostOverflow",
        "InvalidChain",
        "Expired",
        "ActionsValidation"
      ],
      "props": {}
    },
    "LackBalanceForState": {
      "name": "LackBalanceForState",
      "subtypes": [],
      "props": {
        "account_id": "",
        "amount": ""
      }
    },
    "MethodNameMismatch": {
      "name": "MethodNameMismatch",
      "subtypes": [],
      "props": {
        "method_name": ""
      }
    },
    "NotEnoughAllowance": {
      "name": "NotEnoughAllowance",
      "subtypes": [],
      "props": {
        "account_id": "",
        "allowance": "",
        "cost": "",
        "public_key": ""
      }
    },
    "NotEnoughBalance": {
      "name": "NotEnoughBalance",
      "subtypes": [],
      "props": {
        "balance": "",
        "cost": "",
        "signer_id": ""
      }
    },
    "OnlyImplicitAccountCreationAllowed": {
      "name": "OnlyImplicitAccountCreationAllowed",
      "subtypes": [],
      "props": {
        "account_id": ""
      }
    },
    "ReceiptValidationError": {
      "name": "ReceiptValidationError",
      "subtypes": [
        "InvalidPredecessorId",
        "InvalidReceiverId",
        "InvalidSignerId",
        "InvalidDataReceiverId",
        "ReturnedValueLengthExceeded",
        "NumberInputDataDependenciesExceeded",
        "ActionsValidation"
      ],
      "props": {}
    },
    "ReceiverMismatch": {
      "name": "ReceiverMismatch",
      "subtypes": [],
      "props": {
        "ak_receiver": "",
        "tx_receiver": ""
      }
    },
    "RequiresFullAccess": {
      "name": "RequiresFullAccess",
      "subtypes": [],
      "props": {}
    },
    "SignerDoesNotExist": {
      "name": "SignerDoesNotExist",
      "subtypes": [],
      "props": {
        "signer_id": ""
      }
    },
    "TotalNumberOfActionsExceeded": {
      "name": "TotalNumberOfActionsExceeded",
      "subtypes": [],
      "props": {
        "limit": "",
        "total_number_of_actions": ""
      }
    },
    "TotalPrepaidGasExceeded": {
      "name": "TotalPrepaidGasExceeded",
      "subtypes": [],
      "props": {
        "limit": "",
        "total_prepaid_gas": ""
      }
    },
    "TriesToStake": {
      "name": "TriesToStake",
      "subtypes": [],
      "props": {
        "account_id": "",
        "balance": "",
        "locked": "",
        "stake": ""
      }
    },
    "TriesToUnstake": {
      "name": "TriesToUnstake",
      "subtypes": [],
      "props": {
        "account_id": ""
      }
    },
    "TxExecutionError": {
      "name": "TxExecutionError",
      "subtypes": [
        "ActionError",
        "InvalidTxError"
      ],
      "props": {}
    },
    "UnsuitableStakingKey": {
      "name": "UnsuitableStakingKey",
      "subtypes": [],
      "props": {
        "public_key": ""
      }
    },
    "Closed": {
      "name": "Closed",
      "subtypes": [],
      "props": {}
    },
    "InternalError": {
      "name": "InternalError",
      "subtypes": [],
      "props": {}
    },
    "ServerError": {
      "name": "ServerError",
      "subtypes": [
        "TxExecutionError",
        "Timeout",
        "Closed",
        "InternalError"
      ],
      "props": {}
    },
    "Timeout": {
      "name": "Timeout",
      "subtypes": [],
      "props": {}
    }
  }
}
'''
'''--- src/index.ts ---
/** @ignore @module */
export * as keyStores from './key_stores/index';
export * from './common-index';
export * from './connect';
export * from './constants';
'''
'''--- src/key_stores/browser-index.ts ---
/** @hidden @module */
import { KeyStore } from './keystore';
import { InMemoryKeyStore } from './in_memory_key_store';
import { BrowserLocalStorageKeyStore } from './browser_local_storage_key_store';
import { MergeKeyStore } from './merge_key_store';

export {
    KeyStore,
    InMemoryKeyStore,
    BrowserLocalStorageKeyStore,
    MergeKeyStore,
};

'''
'''--- src/key_stores/browser_local_storage_key_store.ts ---
import { KeyStore } from './keystore';
import { KeyPair } from '../utils/key_pair';

const LOCAL_STORAGE_KEY_PREFIX = 'near-api-js:keystore:';

/**
 * This class is used to store keys in the browsers local storage.
 * 
 * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#key-store}
 * @example
 * ```js
 * import { connect, keyStores } from 'near-api-js';
 * 
 * const keyStore = new keyStores.BrowserLocalStorageKeyStore();
 * const config = { 
 *   keyStore, // instance of BrowserLocalStorageKeyStore
 *   networkId: 'testnet',
 *   nodeUrl: 'https://rpc.testnet.near.org',
 *   walletUrl: 'https://wallet.testnet.near.org',
 *   helperUrl: 'https://helper.testnet.near.org',
 *   explorerUrl: 'https://explorer.testnet.near.org'
 * };
 * 
 * // inside an async function
 * const near = await connect(config)
 * ```
 */
export class BrowserLocalStorageKeyStore extends KeyStore {
    /** @hidden */
    private localStorage: any;
    /** @hidden */
    private prefix: string;

    /**
     * @param localStorage defaults to window.localStorage
     * @param prefix defaults to `near-api-js:keystore:`
     */
    constructor(localStorage: any = window.localStorage, prefix = LOCAL_STORAGE_KEY_PREFIX) {
        super();
        this.localStorage = localStorage;
        this.prefix = prefix;
    }

    /**
     * Stores a {@link KeyPair} in local storage.
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     * @param keyPair The key pair to store in local storage
     */
    async setKey(networkId: string, accountId: string, keyPair: KeyPair): Promise<void> {
        this.localStorage.setItem(this.storageKeyForSecretKey(networkId, accountId), keyPair.toString());
    }

    /**
     * Gets a {@link KeyPair} from local storage
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     * @returns {Promise<KeyPair>}
     */
    async getKey(networkId: string, accountId: string): Promise<KeyPair> {
        const value = this.localStorage.getItem(this.storageKeyForSecretKey(networkId, accountId));
        if (!value) {
            return null;
        }
        return KeyPair.fromString(value);
    }

    /**
     * Removes a {@link KeyPair} from local storage
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     */
    async removeKey(networkId: string, accountId: string): Promise<void> {
        this.localStorage.removeItem(this.storageKeyForSecretKey(networkId, accountId));
    }

    /**
     * Removes all items that start with `prefix` from local storage
     */
    async clear(): Promise<void> {
        for (const key of this.storageKeys()) {
            if (key.startsWith(this.prefix)) {
                this.localStorage.removeItem(key);
            }
        }
    }

    /**
     * Get the network(s) from local storage
     * @returns {Promise<string[]>}
     */
    async getNetworks(): Promise<string[]> {
        const result = new Set<string>();
        for (const key of this.storageKeys()) {
            if (key.startsWith(this.prefix)) {
                const parts = key.substring(this.prefix.length).split(':');
                result.add(parts[1]);
            }
        }
        return Array.from(result.values());
    }

    /**
     * Gets the account(s) from local storage
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @returns{Promise<string[]>}
     */
    async getAccounts(networkId: string): Promise<string[]> {
        const result = new Array<string>();
        for (const key of this.storageKeys()) {
            if (key.startsWith(this.prefix)) {
                const parts = key.substring(this.prefix.length).split(':');
                if (parts[1] === networkId) {
                    result.push(parts[0]);
                }
            }
        }
        return result;
    }

    /**
     * @hidden
     * Helper function to retrieve a local storage key
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the storage keythat's sought
     * @returns {string} An example might be: `near-api-js:keystore:near-friend:default`
     */
    private storageKeyForSecretKey(networkId: string, accountId: string): string {
        return `${this.prefix}${accountId}:${networkId}`;
    }

    /** @hidden */
    private *storageKeys(): IterableIterator<string> {
        for (let i = 0; i < this.localStorage.length; i++) {
            yield this.localStorage.key(i);
        }
    }
}

'''
'''--- src/key_stores/in_memory_key_store.ts ---
import { KeyStore } from './keystore';
import { KeyPair } from '../utils/key_pair';

/**
 * Simple in-memory keystore for mainly for testing purposes.
 * 
 * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#key-store}
 * @example
 * ```js
 * import { connect, keyStores, utils } from 'near-api-js';
 * 
 * const privateKey = '.......';
 * const keyPair = utils.KeyPair.fromString(privateKey);
 * 
 * const keyStore = new keyStores.InMemoryKeyStore();
 * keyStore.setKey('testnet', 'example-account.testnet', keyPair);
 * 
 * const config = { 
 *   keyStore, // instance of InMemoryKeyStore
 *   networkId: 'testnet',
 *   nodeUrl: 'https://rpc.testnet.near.org',
 *   walletUrl: 'https://wallet.testnet.near.org',
 *   helperUrl: 'https://helper.testnet.near.org',
 *   explorerUrl: 'https://explorer.testnet.near.org'
 * };
 * 
 * // inside an async function
 * const near = await connect(config)
 * ```
 */
export class InMemoryKeyStore extends KeyStore {
    /** @hidden */
    private keys: { [key: string]: string };

    constructor() {
        super();
        this.keys = {};
    }

    /**
     * Stores a {@KeyPair} in in-memory storage item
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     * @param keyPair The key pair to store in local storage
     */    
    async setKey(networkId: string, accountId: string, keyPair: KeyPair): Promise<void> {
        this.keys[`${accountId}:${networkId}`] = keyPair.toString();
    }

    /**
     * Gets a {@link KeyPair} from in-memory storage
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     * @returns {Promise<KeyPair>}
     */
    async getKey(networkId: string, accountId: string): Promise<KeyPair> {
        const value = this.keys[`${accountId}:${networkId}`];
        if (!value) {
            return null;
        }
        return KeyPair.fromString(value);
    }

    /**
     * Removes a {@link KeyPair} from in-memory storage
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     */
    async removeKey(networkId: string, accountId: string): Promise<void> {
        delete this.keys[`${accountId}:${networkId}`];
    }

    /**
     * Removes all {@link KeyPairs} from in-memory storage
     */
    async clear(): Promise<void> {
        this.keys = {};
    }

    /**
     * Get the network(s) from in-memory storage
     * @returns {Promise<string[]>}
     */
    async getNetworks(): Promise<string[]> {
        const result = new Set<string>();
        Object.keys(this.keys).forEach((key) => {
            const parts = key.split(':');
            result.add(parts[1]);
        });
        return Array.from(result.values());
    }

    /**
     * Gets the account(s) from in-memory storage
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @returns{Promise<string[]>}
     */
    async getAccounts(networkId: string): Promise<string[]> {
        const result = new Array<string>();
        Object.keys(this.keys).forEach((key) => {
            const parts = key.split(':');
            if (parts[parts.length - 1] === networkId) {
                result.push(parts.slice(0, parts.length - 1).join(':'));
            }
        });
        return result;
    }

    /** @hidden */
    toString(): string {
        return 'InMemoryKeyStore';
    }
}

'''
'''--- src/key_stores/index.ts ---
/** @ignore @module */
import { KeyStore } from './keystore';
import { InMemoryKeyStore } from './in_memory_key_store';
import { BrowserLocalStorageKeyStore } from './browser_local_storage_key_store';
import { UnencryptedFileSystemKeyStore } from './unencrypted_file_system_keystore';
import { MergeKeyStore } from './merge_key_store';

export {
    KeyStore,
    InMemoryKeyStore,
    BrowserLocalStorageKeyStore,
    UnencryptedFileSystemKeyStore,
    MergeKeyStore,
};

'''
'''--- src/key_stores/keystore.ts ---
import { KeyPair } from '../utils/key_pair';

/**
 * KeyStores are passed to {@link Near} via {@link NearConfig}
 * and are used by the {@link InMemorySigner} to sign transactions.
 * 
 * @example {@link connect}
 */
export abstract class KeyStore {
    abstract async setKey(networkId: string, accountId: string, keyPair: KeyPair): Promise<void>;
    abstract async getKey(networkId: string, accountId: string): Promise<KeyPair>;
    abstract async removeKey(networkId: string, accountId: string): Promise<void>;
    abstract async clear(): Promise<void>;
    abstract async getNetworks(): Promise<string[]>;
    abstract async getAccounts(networkId: string): Promise<string[]>;
}

'''
'''--- src/key_stores/merge_key_store.ts ---
import { KeyStore } from './keystore';
import { KeyPair } from '../utils/key_pair';

/**
 * Keystore which can be used to merge multiple key stores into one virtual key store.
 * 
 * @example
 * ```js
 * const { homedir } = require('os');
 * import { connect, keyStores, utils } from 'near-api-js';
 * 
 * const privateKey = '.......';
 * const keyPair = utils.KeyPair.fromString(privateKey);
 * 
 * const inMemoryKeyStore = new keyStores.InMemoryKeyStore();
 * inMemoryKeyStore.setKey('testnet', 'example-account.testnet', keyPair);
 * 
 * const fileSystemKeyStore = new keyStores.UnencryptedFileSystemKeyStore(`${homedir()}/.near-credentials`);
 * 
 * const keyStore = new MergeKeyStore([
 *   inMemoryKeyStore,
 *   fileSystemKeyStore
 * ]);
 * const config = { 
 *   keyStore, // instance of MergeKeyStore
 *   networkId: 'testnet',
 *   nodeUrl: 'https://rpc.testnet.near.org',
 *   walletUrl: 'https://wallet.testnet.near.org',
 *   helperUrl: 'https://helper.testnet.near.org',
 *   explorerUrl: 'https://explorer.testnet.near.org'
 * };
 * 
 * // inside an async function
 * const near = await connect(config)
 * ```
 */

interface MergeKeyStoreOptions {
    writeKeyStoreIndex: number;
}

export class MergeKeyStore extends KeyStore {
    private options: MergeKeyStoreOptions;
    keyStores: KeyStore[];

    /**
     * @param keyStores read calls are attempted from start to end of array
     * @param options.writeKeyStoreIndex the keystore index that will receive all write calls
     */
    constructor(keyStores: KeyStore[], options: MergeKeyStoreOptions = { writeKeyStoreIndex: 0 }) {
        super();
        this.options = options;
        this.keyStores = keyStores;
    }

    /**
     * Store a {@link KeyPain} to the first index of a key store array
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     * @param keyPair The key pair to store in local storage
     */
    async setKey(networkId: string, accountId: string, keyPair: KeyPair): Promise<void> {
        await this.keyStores[this.options.writeKeyStoreIndex].setKey(networkId, accountId, keyPair);
    }

    /**
     * Gets a {@link KeyPair} from the array of key stores
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     * @returns {Promise<KeyPair>}
     */
    async getKey(networkId: string, accountId: string): Promise<KeyPair> {
        for (const keyStore of this.keyStores) {
            const keyPair = await keyStore.getKey(networkId, accountId);
            if (keyPair) {
                return keyPair;
            }
        }
        return null;
    }
    
    /**
     * Removes a {@link KeyPair} from the array of key stores
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     */
    async removeKey(networkId: string, accountId: string): Promise<void> {
        for (const keyStore of this.keyStores) {
            await keyStore.removeKey(networkId, accountId);
        }
    }
    
    /**
     * Removes all items from each key store
     */
    async clear(): Promise<void> {
        for (const keyStore of this.keyStores) {
            await keyStore.clear();
        }
    }
    
    /**
     * Get the network(s) from the array of key stores
     * @returns {Promise<string[]>}
     */    
    async getNetworks(): Promise<string[]> {
        const result = new Set<string>();
        for (const keyStore of this.keyStores) {
            for (const network of await keyStore.getNetworks()) {
                result.add(network);
            }
        }
        return Array.from(result);
    }
    
    /**
     * Gets the account(s) from the array of key stores
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @returns{Promise<string[]>}
     */    
    async getAccounts(networkId: string): Promise<string[]> {
        const result = new Set<string>();
        for (const keyStore of this.keyStores) {
            for (const account of await keyStore.getAccounts(networkId)) {
                result.add(account);
            }
        }
        return Array.from(result);
    }

    /** @hidden */
    toString(): string {
        return `MergeKeyStore(${this.keyStores.join(', ')})`;
    }
}
'''
'''--- src/key_stores/unencrypted_file_system_keystore.ts ---
import fs from 'fs';
import path from 'path';
import { promisify as _promisify } from 'util';

import { KeyPair } from '../utils/key_pair';
import { KeyStore } from './keystore';

const promisify = (fn: any) => {
    if (!fn) {
        return () => {
            throw new Error('Trying to use unimplemented function. `fs` module not available in web build?');
        };
    }
    return _promisify(fn);
};

const exists = promisify(fs.exists);
const readFile = promisify(fs.readFile);
const writeFile = promisify(fs.writeFile);
const unlink = promisify(fs.unlink);
const readdir = promisify(fs.readdir);
const mkdir = promisify(fs.mkdir);

/**
 * Format of the account stored on disk.
 */
interface AccountInfo {
    account_id: string;
    public_key: string;
    private_key: string;
}

/** @hidden */
export async function loadJsonFile(filename: string): Promise<any> {
    const content = await readFile(filename);
    return JSON.parse(content.toString());
}

async function ensureDir(dir: string): Promise<void> {
    try {
        await mkdir(dir, { recursive: true });
    } catch (err) {
        if (err.code !== 'EEXIST') { throw err; }
    }
}

/** @hidden */
export async function readKeyFile(filename: string): Promise<[string, KeyPair]> {
    const accountInfo = await loadJsonFile(filename);
    // The private key might be in private_key or secret_key field.
    let privateKey = accountInfo.private_key;
    if (!privateKey && accountInfo.secret_key) {
        privateKey = accountInfo.secret_key;
    }
    return [accountInfo.account_id, KeyPair.fromString(privateKey)];
}

/**
 * This module contains the {@link UnencryptedFileSystemKeyStore} class which is used to store keys on the file system.
 * 
 * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#key-store}
 * @example
 * ```js
 * const { homedir } = require('os');
 * const { connect, keyStores } = require('near-api-js');
 * 
 * const keyStore = new keyStores.UnencryptedFileSystemKeyStore(`${homedir()}/.near-credentials`);
 * const config = { 
 *   keyStore, // instance of UnencryptedFileSystemKeyStore
 *   networkId: 'testnet',
 *   nodeUrl: 'https://rpc.testnet.near.org',
 *   walletUrl: 'https://wallet.testnet.near.org',
 *   helperUrl: 'https://helper.testnet.near.org',
 *   explorerUrl: 'https://explorer.testnet.near.org'
 * };
 * 
 * // inside an async function
 * const near = await connect(config)
 * ```
 */
export class UnencryptedFileSystemKeyStore extends KeyStore {
    /** @hidden */
    readonly keyDir: string;

    /**
     * @param keyDir base directory for key storage. Keys will be stored in `keyDir/networkId/accountId.json`
     */
    constructor(keyDir: string) {
        super();
        this.keyDir = path.resolve(keyDir);
    }

    /**
     * Store a {@link KeyPair} in an unencrypted file
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     * @param keyPair The key pair to store in local storage
     */
    async setKey(networkId: string, accountId: string, keyPair: KeyPair): Promise<void> {
        await ensureDir(`${this.keyDir}/${networkId}`);
        const content: AccountInfo = { account_id: accountId, public_key: keyPair.getPublicKey().toString(), private_key: keyPair.toString() };
        await writeFile(this.getKeyFilePath(networkId, accountId), JSON.stringify(content), { mode: 0o600 });
    }

    /**
     * Gets a {@link KeyPair} from an unencrypted file
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     * @returns {Promise<KeyPair>}
     */
    async getKey(networkId: string, accountId: string): Promise<KeyPair> {
        // Find key / account id.
        if (!await exists(this.getKeyFilePath(networkId, accountId))) {
            return null;
        }
        const accountKeyPair = await readKeyFile(this.getKeyFilePath(networkId, accountId));
        return accountKeyPair[1];
    }

    /**
     * Deletes an unencrypted file holding a {@link KeyPair}
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account tied to the key pair
     */
    async removeKey(networkId: string, accountId: string): Promise<void> {
        if (await exists(this.getKeyFilePath(networkId, accountId))) {
            await unlink(this.getKeyFilePath(networkId, accountId));
        }
    }

    /**
     * Deletes all unencrypted files from the `keyDir` path.
     */
    async clear(): Promise<void> {
        for (const network of await this.getNetworks()) {
            for (const account of await this.getAccounts(network)) {
                await this.removeKey(network, account);
            }
        }
    }

    /** @hidden */
    private getKeyFilePath(networkId: string, accountId: string): string {
        return `${this.keyDir}/${networkId}/${accountId}.json`;
    }

    /**
     * Get the network(s) from files in `keyDir`
     * @returns {Promise<string[]>}
     */
    async getNetworks(): Promise<string[]> {
        const files: string[] = await readdir(this.keyDir);
        const result = new Array<string>();
        files.forEach((item) => {
            result.push(item);
        });
        return result;
    }

    /**
     * Gets the account(s) files in `keyDir/networkId`
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @returns{Promise<string[]>}
     */
    async getAccounts(networkId: string): Promise<string[]> {
        if (!await exists(`${this.keyDir}/${networkId}`)) {
            return [];
        }
        const files: string[] = await readdir(`${this.keyDir}/${networkId}`);
        return files
            .filter(file => file.endsWith('.json'))
            .map(file => file.replace(/.json$/, ''));
    }

    /** @hidden */
    toString(): string {
        return `UnencryptedFileSystemKeyStore(${this.keyDir})`;
    }
}

'''
'''--- src/near.ts ---
/**
 * This module contains the main class developers will use to interact with NEAR.
 * The {@link Near} class is used to interact with {@link Account | Accounts} through the {@link JsonRpcProvider.JsonRpcProvider | JsonRpcProvider}.
 * It is configured via the {@link NearConfig}.
 * 
 * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#account}
 * 
 * @module near
 */
import BN from 'bn.js';
import { Account } from './account';
import { Connection } from './connection';
import { Signer } from './signer';
import { Contract } from './contract';
import { PublicKey } from './utils/key_pair';
import { AccountCreator, LocalAccountCreator, UrlAccountCreator } from './account_creator';
import { KeyStore } from './key_stores';

export interface NearConfig {
    /** Holds {@link KeyPair | KeyPairs} for signing transactions */
    keyStore?: KeyStore;

    /** @hidden */
    signer?: Signer;

    /** @deprecated use {@link NearConfig.keyStore} */
    deps?: { keyStore: KeyStore };

    /**
     * {@link https://github.com/near/near-contract-helper | NEAR Contract Helper} url used to create accounts if no master account is provided
     * @see {@link UrlAccountCreator}
     */
    helperUrl?: string;

    /**
     * The balance transferred from the {@link NearConfig.masterAccount | masterAccount} to a created account
     * @see {@link LocalAccountCreator}
     */
    initialBalance?: string;

    /**
     * The account to use when creating new accounts
     * @see {@link LocalAccountCreator}
     */
    masterAccount?: string;

    /**
     * {@link KeyPair | KeyPairs} are stored in a {@link KeyStore} under the `networkId` namespace.
     */
    networkId: string;

    /**
     * NEAR RPC API url. used to make JSON RPC calls to interact with NEAR.
     * @see {@link JsonRpcProvider.JsonRpcProvider | JsonRpcProvider}
     */
    nodeUrl: string;

    /**
     * NEAR wallet url used to redirect users to their wallet in browser applications.
     * @see {@link https://docs.near.org/docs/tools/near-wallet}
     */
    walletUrl?: string;
}

/**
 * This is the main class developers should use to interact with NEAR.
 * @example
 * ```js
 * const near = new Near(config);
 * ```
 */
export class Near {
    readonly config: any;
    readonly connection: Connection;
    readonly accountCreator: AccountCreator;

    constructor(config: NearConfig) {
        this.config = config;
        this.connection = Connection.fromConfig({
            networkId: config.networkId,
            provider: { type: 'JsonRpcProvider', args: { url: config.nodeUrl } },
            signer: config.signer || { type: 'InMemorySigner', keyStore: config.keyStore || config.deps.keyStore }
        });
        if (config.masterAccount) {
            // TODO: figure out better way of specifiying initial balance.
            // Hardcoded number below must be enough to pay the gas cost to dev-deploy with near-shell for multiple times
            const initialBalance = config.initialBalance ? new BN(config.initialBalance) : new BN('500000000000000000000000000');
            this.accountCreator = new LocalAccountCreator(new Account(this.connection, config.masterAccount), initialBalance);
        } else if (config.helperUrl) {
            this.accountCreator = new UrlAccountCreator(this.connection, config.helperUrl);
        } else {
            this.accountCreator = null;
        }
    }

    /**
     * @param accountId near accountId used to interact with the network.
     */
    async account(accountId: string): Promise<Account> {
        const account = new Account(this.connection, accountId);
        return account;
    }

    /**
     * Create an account using the {@link AccountCreator}. Either:
     * * using a masterAccount with {@link LocalAccountCreator}
     * * using the helperUrl with {@link UrlAccountCreator}
     * @see {@link NearConfig.masterAccount} and {@link NearConfig.helperUrl}-
     * 
     * @param accountId
     * @param publicKey
     */
    async createAccount(accountId: string, publicKey: PublicKey): Promise<Account> {
        if (!this.accountCreator) {
            throw new Error('Must specify account creator, either via masterAccount or helperUrl configuration settings.');
        }
        await this.accountCreator.createAccount(accountId, publicKey);
        return new Account(this.connection, accountId);
    }

    /**
     * @deprecated Use {@link Contract} instead.
     * @param contractId
     * @param options
     */
    async loadContract(contractId: string, options: { viewMethods: string[]; changeMethods: string[]; sender: string }): Promise<Contract> {
        const account = new Account(this.connection, options.sender);
        return new Contract(account, contractId, options);
    }

    /**
     * @deprecated Use {@link Account.sendMoney} instead.
     * @param amount
     * @param originator
     * @param receiver
     */
    async sendTokens(amount: BN, originator: string, receiver: string): Promise<string> {
        console.warn('near.sendTokens is deprecated. Use `yourAccount.sendMoney` instead.');
        const account = new Account(this.connection, originator);
        const result = await account.sendMoney(receiver, amount);
        return result.transaction_outcome.id;
    }
}

'''
'''--- src/providers/index.ts ---
/** @hidden @module */

import { Provider, FinalExecutionOutcome, ExecutionOutcomeWithId, getTransactionLastResult, FinalExecutionStatus, FinalExecutionStatusBasic } from './provider';
import { JsonRpcProvider, TypedError, ErrorContext } from './json-rpc-provider';

export {
    Provider,
    FinalExecutionOutcome,
    JsonRpcProvider,
    ExecutionOutcomeWithId,
    FinalExecutionStatus,
    FinalExecutionStatusBasic,
    getTransactionLastResult,
    TypedError,
    ErrorContext
};

'''
'''--- src/providers/json-rpc-provider.ts ---
/**
 * This module contains the {@link JsonRpcProvider} client class
 * which can be used to interact with the NEAR RPC API.
 * @see {@link providers/provider} for a list of request and response types
 */
import depd from 'depd';
import {
    AccessKeyWithPublicKey,
    Provider,
    FinalExecutionOutcome,
    NodeStatusResult,
    BlockId,
    BlockReference,
    BlockResult,
    BlockChangeResult,
    ChangeResult,
    ChunkId,
    ChunkResult,
    EpochValidatorInfo,
    NearProtocolConfig,
    LightClientProof,
    LightClientProofRequest,
    GasPrice,
    QueryResponseKind
} from './provider';
import { ConnectionInfo, fetchJson } from '../utils/web';
import { TypedError, ErrorContext } from '../utils/errors';
import { baseEncode } from 'borsh';
import exponentialBackoff from '../utils/exponential-backoff';
import { parseRpcError, getErrorTypeFromErrorMessage } from '../utils/rpc_errors';
import { SignedTransaction } from '../transaction';

/** @hidden */
export { TypedError, ErrorContext };

// Default number of retries before giving up on a request.
const REQUEST_RETRY_NUMBER = 12;

// Default wait until next retry in millis.
const REQUEST_RETRY_WAIT = 500;

// Exponential back off for waiting to retry.
const REQUEST_RETRY_WAIT_BACKOFF = 1.5;

/// Keep ids unique across all connections.
let _nextId = 123;

/**
 * Client class to interact with the NEAR RPC API.
 * @see {@link https://github.com/near/nearcore/tree/master/chain/jsonrpc}
 */
export class JsonRpcProvider extends Provider {
    /** @hidden */
    readonly connection: ConnectionInfo;

    /**
     * @param url RPC API endpoint URL
     */
    constructor(url?: string) {
        super();
        this.connection = { url };
    }

    /**
     * Gets the RPC's status
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#general-validator-status}
     */
    async status(): Promise<NodeStatusResult> {
        return this.sendJsonRpc('status', []);
    }

    /**
     * Sends a signed transaction to the RPC and waits until transaction is fully complete
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#send-transaction-await}
     *
     * @param signedTransaction The signed transaction being sent
     */
    async sendTransaction(signedTransaction: SignedTransaction): Promise<FinalExecutionOutcome> {
        const bytes = signedTransaction.encode();
        return this.sendJsonRpc('broadcast_tx_commit', [Buffer.from(bytes).toString('base64')]);
    }

    /**
     * Sends a signed transaction to the RPC and immediately returns transaction hash
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#send-transaction-async)
     * @param signedTransaction The signed transaction being sent
     * @returns {Promise<FinalExecutionOutcome>}
     */
    async sendTransactionAsync(signedTransaction: SignedTransaction): Promise<FinalExecutionOutcome> {
        const bytes = signedTransaction.encode();
        return this.sendJsonRpc('broadcast_tx_async', [Buffer.from(bytes).toString('base64')]);
    }

    /**
     * Gets a transaction's status from the RPC
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#transaction-status}
     *
     * @param txHash A transaction hash as either a Uint8Array or a base58 encoded string
     * @param accountId The NEAR account that signed the transaction
     */
    async txStatus(txHash: Uint8Array | string, accountId: string): Promise<FinalExecutionOutcome> {
        if(typeof txHash === 'string') {
            return this.txStatusString(txHash, accountId);
        } else {
            return this.txStatusUint8Array(txHash, accountId);
        }
    }

    private async txStatusUint8Array(txHash: Uint8Array, accountId: string): Promise<FinalExecutionOutcome> {
        return this.sendJsonRpc('tx', [baseEncode(txHash), accountId]);
    }

    private async txStatusString(txHash: string, accountId: string): Promise<FinalExecutionOutcome> {
        return this.sendJsonRpc('tx', [txHash, accountId]);
    }

    /**
     * Gets a transaction's status from the RPC with receipts
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#transaction-status-with-receipts)
     * @param txHash The hash of the transaction
     * @param accountId The NEAR account that signed the transaction
     * @returns {Promise<FinalExecutionOutcome>}
     */
    async txStatusReceipts(txHash: Uint8Array, accountId: string): Promise<FinalExecutionOutcome> {
        return this.sendJsonRpc('EXPERIMENTAL_tx_status', [baseEncode(txHash), accountId]);
    }

    /**
     * Query the RPC as [shown in the docs](https://docs.near.org/docs/develop/front-end/rpc#accounts--contracts)
     * Query the RPC by passing an {@link RpcQueryRequest}
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#accounts--contracts}
     *
     * @typeParam T the shape of the returned query response
     */
    async query<T extends QueryResponseKind>(...args: any[]): Promise<T> {
        let result;
        if (args.length === 1) {
            result = await this.sendJsonRpc<T>('query', args[0]);
        } else {
            const [path, data] = args;
            result = await this.sendJsonRpc<T>('query', [path, data]);
        }
        if (result && result.error) {
            throw new TypedError(
                `Querying ${args} failed: ${result.error}.\n${JSON.stringify(result, null, 2)}`,
                getErrorTypeFromErrorMessage(result.error));
        }
        return result;
    }

    /**
     * Query for block info from the RPC
     * pass block_id OR finality as blockQuery, not both
     * @see {@link https://docs.near.org/docs/interaction/rpc#block}
     *
     * @param blockQuery {@link BlockReference} (passing a {@link BlockId} is deprecated)
     */
    async block(blockQuery: BlockId | BlockReference): Promise<BlockResult> {
        const { finality } = blockQuery as any;
        let { blockId } = blockQuery as any;

        if (typeof blockQuery !== 'object') {
            const deprecate = depd('JsonRpcProvider.block(blockId)');
            deprecate('use `block({ blockId })` or `block({ finality })` instead');
            blockId = blockQuery;
        }
        return this.sendJsonRpc('block', { block_id: blockId, finality });
    }

    /**
     * Query changes in block from the RPC
     * pass block_id OR finality as blockQuery, not both
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#block-details)
     */
    async blockChanges(blockQuery: BlockReference): Promise<BlockChangeResult> {
        const { finality } = blockQuery as any;
        const { blockId } = blockQuery as any;
        return this.sendJsonRpc('EXPERIMENTAL_changes_in_block', { block_id: blockId, finality });
    }

    /**
     * Queries for details about a specific chunk appending details of receipts and transactions to the same chunk data provided by a block
     * @see {@link https://docs.near.org/docs/interaction/rpc#chunk}
     *
     * @param chunkId Hash of a chunk ID or shard ID
     */
    async chunk(chunkId: ChunkId): Promise<ChunkResult> {
        return this.sendJsonRpc('chunk', [chunkId]);
    }

    /**
     * Query validators of the epoch defined by the given block id.
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#detailed-validator-status}
     *
     * @param blockId Block hash or height, or null for latest.
     */
    async validators(blockId: BlockId | null): Promise<EpochValidatorInfo> {
        return this.sendJsonRpc('validators', [blockId]);
    }

    /**
     * @deprecated
     * Gets the genesis config from RPC
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#genesis-config}
     */
    async experimental_genesisConfig(): Promise<NearProtocolConfig> {
        const deprecate = depd('JsonRpcProvider.experimental_protocolConfig()');
        deprecate('use `experimental_protocolConfig({ sync_checkpoint: \'genesis\' })` to fetch the up-to-date or genesis protocol config explicitly');
        return await this.sendJsonRpc('EXPERIMENTAL_protocol_config', { sync_checkpoint: 'genesis' });
    }

    /**
     * Gets the protocol config at a block from RPC
     * @see {@link }
     *
     * @param blockReference specifies the block to get the protocol config for
     */
    async experimental_protocolConfig(blockReference: BlockReference | { sync_checkpoint: 'genesis' }): Promise<NearProtocolConfig> {
        return await this.sendJsonRpc('EXPERIMENTAL_protocol_config', blockReference);
    }

    /**
     * @deprecated Use {@link lightClientProof} instead
     */
    async experimental_lightClientProof(request: LightClientProofRequest): Promise<LightClientProof> {
        const deprecate = depd('JsonRpcProvider.experimental_lightClientProof(request)');
        deprecate('use `lightClientProof` instead');
        return await this.lightClientProof(request);
    }

    /**
     * Gets a light client execution proof for verifying execution outcomes
     * @see {@link https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof}
     */
    async lightClientProof(request: LightClientProofRequest): Promise<LightClientProof> {
        return await this.sendJsonRpc('EXPERIMENTAL_light_client_proof', request);
    }

    /**
     * Gets access key changes for a given array of accountIds
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-all)
     * @returns {Promise<ChangeResult>}
     */
    async accessKeyChanges(accountIdArray: string[], blockQuery: BlockReference): Promise<ChangeResult> {
        const { finality } = blockQuery as any;
        const { blockId } = blockQuery as any;
        return this.sendJsonRpc('EXPERIMENTAL_changes', {
            changes_type: 'all_access_key_changes',
            account_ids: accountIdArray,
            block_id: blockId,
            finality
        });
    }

    /**
     * Gets single access key changes for a given array of access keys
     * pass block_id OR finality as blockQuery, not both
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-single)
     * @returns {Promise<ChangeResult>}
     */
    async singleAccessKeyChanges(accessKeyArray: AccessKeyWithPublicKey[], blockQuery: BlockReference): Promise<ChangeResult> {
        const { finality } = blockQuery as any;
        const { blockId } = blockQuery as any;
        return this.sendJsonRpc('EXPERIMENTAL_changes', {
            changes_type: 'single_access_key_changes',
            keys: accessKeyArray,
            block_id: blockId,
            finality
        });
    }

    /**
     * Gets account changes for a given array of accountIds
     * pass block_id OR finality as blockQuery, not both
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-account-changes)
     * @returns {Promise<ChangeResult>}
     */
    async accountChanges(accountIdArray: string[], blockQuery: BlockReference): Promise<ChangeResult> {
        const { finality } = blockQuery as any;
        const { blockId } = blockQuery as any;
        return this.sendJsonRpc('EXPERIMENTAL_changes', {
            changes_type: 'account_changes',
            account_ids: accountIdArray,
            block_id: blockId,
            finality
        });
    }

    /**
     * Gets contract state changes for a given array of accountIds
     * pass block_id OR finality as blockQuery, not both
     * Note: If you pass a keyPrefix it must be base64 encoded
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-state-changes)
     * @returns {Promise<ChangeResult>}
     */
    async contractStateChanges(accountIdArray: string[], blockQuery: BlockReference, keyPrefix = ''): Promise<ChangeResult> {
        const { finality } = blockQuery as any;
        const { blockId } = blockQuery as any;
        return this.sendJsonRpc('EXPERIMENTAL_changes', {
            changes_type: 'data_changes',
            account_ids: accountIdArray,
            key_prefix_base64: keyPrefix,
            block_id: blockId,
            finality
        });
    }

    /**
     * Gets contract code changes for a given array of accountIds
     * pass block_id OR finality as blockQuery, not both
     * Note: Change is returned in a base64 encoded WASM file
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-code-changes)
     * @returns {Promise<ChangeResult>}
     */
    async contractCodeChanges(accountIdArray: string[], blockQuery: BlockReference): Promise<ChangeResult> {
        const {finality} = blockQuery as any;
        const {blockId} = blockQuery as any;
        return this.sendJsonRpc('EXPERIMENTAL_changes', {
            changes_type: 'contract_code_changes',
            account_ids: accountIdArray,
            block_id: blockId,
            finality
        });
    }

    /**
     * Returns gas price for a specific block_height or block_hash.
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#gas-price}
     *
     * @param blockId Block hash or height, or null for latest.
     */
    async gasPrice(blockId: BlockId | null): Promise<GasPrice> {
        return await this.sendJsonRpc('gas_price', [blockId]);
    }

    /**
     * Directly call the RPC specifying the method and params
     *
     * @param method RPC method
     * @param params Parameters to the method
     */
    async sendJsonRpc<T>(method: string, params: object): Promise<T> {
        const response = await exponentialBackoff(REQUEST_RETRY_WAIT, REQUEST_RETRY_NUMBER, REQUEST_RETRY_WAIT_BACKOFF, async () => {
            try {
                const request = {
                    method,
                    params,
                    id: (_nextId++),
                    jsonrpc: '2.0'
                };
                const response = await fetchJson(this.connection, JSON.stringify(request));
                if (response.error) {
                    if (typeof response.error.data === 'object') {
                        if (typeof response.error.data.error_message === 'string' && typeof response.error.data.error_type === 'string') {
                            // if error data has error_message and error_type properties, we consider that node returned an error in the old format
                            throw new TypedError(response.error.data.error_message, response.error.data.error_type);
                        }

                        throw parseRpcError(response.error.data);
                    } else {
                        const errorMessage = `[${response.error.code}] ${response.error.message}: ${response.error.data}`;
                        // NOTE: All this hackery is happening because structured errors not implemented
                        // TODO: Fix when https://github.com/nearprotocol/nearcore/issues/1839 gets resolved
                        if (response.error.data === 'Timeout' || errorMessage.includes('Timeout error')
                                || errorMessage.includes('query has timed out')) {
                            throw new TypedError(errorMessage, 'TimeoutError');
                        }

                        throw new TypedError(errorMessage, getErrorTypeFromErrorMessage(response.error.data));
                    }
                }
                // Success when response.error is not exist
                return response;
            } catch (error) {
                if (error.type === 'TimeoutError') {
                    if (!process.env['NEAR_NO_LOGS']){
                        console.warn(`Retrying request to ${method} as it has timed out`, params);
                    }
                    return null;
                }

                throw error;
            }
        });
        const { result } = response;
        // From jsonrpc spec:
        // result
        //   This member is REQUIRED on success.
        //   This member MUST NOT exist if there was an error invoking the method.
        if (typeof result === 'undefined') {
            throw new TypedError(
                `Exceeded ${REQUEST_RETRY_NUMBER} attempts for request to ${method}.`, 'RetriesExceeded');
        }
        return result;
    }
}

'''
'''--- src/providers/provider.ts ---
/**
 * NEAR RPC API request types and responses
 * @module
 */

import { SignedTransaction } from '../transaction';

export interface SyncInfo {
    latest_block_hash: string;
    latest_block_height: number;
    latest_block_time: string;
    latest_state_root: string;
    syncing: boolean;
}

interface Version {
    version: string;
    build: string;
}

export interface NodeStatusResult {
    chain_id: string;
    rpc_addr: string;
    sync_info: SyncInfo;
    validators: string[];
    version: Version;
}

type BlockHash = string;
type BlockHeight = number;
export type BlockId = BlockHash | BlockHeight;

export type Finality = 'optimistic' | 'near-final' | 'final'

export type BlockReference = { blockId: BlockId } | { finality: Finality } | { sync_checkpoint: 'genesis' | 'earliest_available' }

export enum ExecutionStatusBasic {
    Unknown = 'Unknown',
    Pending = 'Pending',
    Failure = 'Failure',
}

export interface ExecutionStatus {
    SuccessValue?: string;
    SuccessReceiptId?: string;
    Failure?: ExecutionError;
}

export enum FinalExecutionStatusBasic {
    NotStarted = 'NotStarted',
    Started = 'Started',
    Failure = 'Failure',
}

export interface ExecutionError {
    error_message: string;
    error_type: string;
}

export interface FinalExecutionStatus {
    SuccessValue?: string;
    Failure?: ExecutionError;
}

export interface ExecutionOutcomeWithId {
    id: string;
    outcome: ExecutionOutcome;
}

export interface ExecutionOutcome {
    logs: string[];
    receipt_ids: string[];
    gas_burnt: number;
    status: ExecutionStatus | ExecutionStatusBasic;
}

export interface ExecutionOutcomeWithIdView {
    proof: MerklePath;
    block_hash: string;
    id: string;
    outcome: ExecutionOutcome;
}

export interface FinalExecutionOutcome {
    status: FinalExecutionStatus | FinalExecutionStatusBasic;
    transaction: any;
    transaction_outcome: ExecutionOutcomeWithId;
    receipts_outcome: ExecutionOutcomeWithId[];
}

export interface TotalWeight {
    num: number;
}

export interface BlockHeader {
    height: number;
    epoch_id: string;
    next_epoch_id: string;
    hash: string;
    prev_hash: string;
    prev_state_root: string;
    chunk_receipts_root: string;
    chunk_headers_root: string;
    chunk_tx_root: string;
    outcome_root: string;
    chunks_included: number;
    challenges_root: string;
    timestamp: number;
    timestamp_nanosec: string;
    random_value: string;
    validator_proposals: any[];
    chunk_mask: boolean[];
    gas_price: string;
    rent_paid: string;
    validator_reward: string;
    total_supply: string;
    challenges_result: any[];
    last_final_block: string;
    last_ds_final_block: string;
    next_bp_hash: string;
    block_merkle_root: string;
    approvals: string[];
    signature: string;
    latest_protocol_version: number;
}

export type ChunkHash = string;
export type ShardId = number;
export type BlockShardId = [BlockId, ShardId];
export type ChunkId = ChunkHash | BlockShardId;

export interface ChunkHeader {
    balance_burnt: string;
    chunk_hash: ChunkHash;
    encoded_length: number;
    encoded_merkle_root: string;
    gas_limit: number;
    gas_used: number;
    height_created: number;
    height_included: number;
    outgoing_receipts_root: string;
    prev_block_hash: string;
    prev_state_num_parts: number;
    prev_state_root_hash: string;
    rent_paid: string;
    shard_id: number;
    signature: string;
    tx_root: string;
    validator_proposals: any[];
    validator_reward: string;
}

export interface ChunkResult {
    header: ChunkHeader;
    receipts: any[];
    transactions: Transaction[];
}

export interface Chunk {
    chunk_hash: string;
    prev_block_hash: string;
    outcome_root: string;
    prev_state_root: string;
    encoded_merkle_root: string;
    encoded_length: number;
    height_created: number;
    height_included: number;
    shard_id: number;
    gas_used: number;
    gas_limit: number;
    rent_paid: string;
    validator_reward: string;
    balance_burnt: string;
    outgoing_receipts_root: string;
    tx_root: string;
    validator_proposals: any[];
    signature: string;
}

export interface Transaction {
    hash: string;
    public_key: string;
    signature: string;
    body: any;
}

export interface BlockResult {
    author: string;
    header: BlockHeader;
    chunks: Chunk[];
}

export interface BlockChange {
    type: string;
    account_id: string;
}

export interface BlockChangeResult {
    block_hash: string;
    changes: BlockChange[];
}

export interface ChangeResult {
    block_hash: string;
    changes: any[];
}

export interface CurrentEpochValidatorInfo {
    account_id: string;
    public_key: string;
    is_slashed: boolean;
    stake: string;
    shards: number[];
    num_produced_blocks: number;
    num_expected_blocks: number;
}

export interface NextEpochValidatorInfo {
    account_id: string;
    public_key: string;
    stake: string;
    shards: number[];
}

export interface ValidatorStakeView {
    account_id: string;
    public_key: string;
    stake: string;
}

export interface NearProtocolConfig {
    runtime_config: NearProtocolRuntimeConfig;
}

export interface NearProtocolRuntimeConfig {
    storage_amount_per_byte: string;
}

export interface EpochValidatorInfo {
    // Validators for the current epoch.
    next_validators: NextEpochValidatorInfo[];
    // Validators for the next epoch.
    current_validators: CurrentEpochValidatorInfo[];
    // Fishermen for the current epoch.
    next_fisherman: ValidatorStakeView[];
    // Fishermen for the next epoch.
    current_fisherman: ValidatorStakeView[];
    // Proposals in the current epoch.
    current_proposals: ValidatorStakeView[];
    // Kickout in the previous epoch.
    prev_epoch_kickout: ValidatorStakeView[];
    // Epoch start height.
    epoch_start_height: number;
}

export interface MerkleNode {
    hash: string;
    direction: string;
}

export type MerklePath = MerkleNode[];

export interface BlockHeaderInnerLiteView {
    height: number;
    epoch_id: string;
    next_epoch_id: string;
    prev_state_root: string;
    outcome_root: string;
    timestamp: number;
    next_bp_hash: string;
    block_merkle_root: string;
}

export interface LightClientBlockLiteView {
    prev_block_hash: string;
    inner_rest_hash: string;
    inner_lite: BlockHeaderInnerLiteView;
}

export interface LightClientProof {
    outcome_proof: ExecutionOutcomeWithIdView;
    outcome_root_proof: MerklePath;
    block_header_lite: LightClientBlockLiteView;
    block_proof: MerklePath;
}

export enum IdType {
    Transaction = 'transaction',
    Receipt = 'receipt',
}

export interface LightClientProofRequest {
    type: IdType;
    light_client_head: string;
    transaction_hash?: string;
    sender_id?: string;
    receipt_id?: string;
    receiver_id?: string;
}

export interface GasPrice {
    gas_price: string;
}

export interface AccessKeyWithPublicKey {
    account_id: string;
    public_key: string;
}

export interface QueryResponseKind {
    block_height: BlockHeight;
    block_hash: BlockHash;
}

export interface AccountView extends QueryResponseKind {
    amount: string;
    locked: string;
    code_hash: string;
    storage_usage: number;
    storage_paid_at: BlockHeight;
}

interface StateItem {
    key: string;
    value: string;
    proof: string[];
}

export interface ViewStateResult extends QueryResponseKind {
    values: StateItem[];
    proof: string[];
}

export interface CodeResult extends QueryResponseKind {
    result: number[];
    logs: string[];
}

export interface ContractCodeView extends QueryResponseKind {
    code_base64: string;
    hash: string;
}

export interface FunctionCallPermissionView {
    FunctionCall: {
        allowance: string;
        receiver_id: string;
        method_names: string[];
    };
}
export interface AccessKeyView extends QueryResponseKind {
    nonce: number;
    permission: 'FullAccess' | FunctionCallPermissionView;
}

export interface AccessKeyInfoView {
    public_key: string;
    access_key: AccessKeyView;
}

export interface AccessKeyList extends QueryResponseKind {
    keys: AccessKeyInfoView[];
}

export interface ViewAccountRequest {
    request_type: 'view_account';
    account_id: string;
}

export interface ViewCodeRequest {
    request_type: 'view_code';
    account_id: string;
}

export interface ViewStateRequest {
    request_type: 'view_state';
    account_id: string;
    prefix_base64: string;
}

export interface ViewAccessKeyRequest {
    request_type: 'view_access_key';
    account_id: string;
    public_key: string;
}

export interface ViewAccessKeyListRequest {
    request_type: 'view_access_key_list';
    account_id: string;
}

export interface CallFunctionRequest {
    request_type: 'call_function';
    account_id: string;
    method_name: string;
    args_base64: string;
}

export type RpcQueryRequest = (ViewAccountRequest |
    ViewCodeRequest |
    ViewStateRequest |
    ViewAccountRequest |
    ViewAccessKeyRequest |
    ViewAccessKeyListRequest |
    CallFunctionRequest) & BlockReference

/** @hidden */
export abstract class Provider {
    abstract status(): Promise<NodeStatusResult>;

    abstract sendTransaction(signedTransaction: SignedTransaction): Promise<FinalExecutionOutcome>;
    abstract sendTransactionAsync(signedTransaction: SignedTransaction): Promise<FinalExecutionOutcome>;
    abstract txStatus(txHash: Uint8Array | string, accountId: string): Promise<FinalExecutionOutcome>;
    abstract txStatusReceipts(txHash: Uint8Array, accountId: string): Promise<FinalExecutionOutcome>;
    abstract query<T extends QueryResponseKind>(params: RpcQueryRequest): Promise<T>;
    abstract query<T extends QueryResponseKind>(path: string, data: string): Promise<T>;
    // TODO: BlockQuery type?
    abstract block(blockQuery: BlockId | BlockReference): Promise<BlockResult>;
    abstract blockChanges(blockQuery: BlockId | BlockReference): Promise<BlockChangeResult>;
    abstract chunk(chunkId: ChunkId): Promise<ChunkResult>;
    // TODO: Use BlockQuery?
    abstract validators(blockId: BlockId): Promise<EpochValidatorInfo>;
    abstract experimental_genesisConfig(): Promise<NearProtocolConfig>;
    abstract experimental_protocolConfig(blockReference: BlockReference): Promise<NearProtocolConfig>;
    abstract lightClientProof(request: LightClientProofRequest): Promise<LightClientProof>;
    abstract gasPrice(blockId: BlockId): Promise<GasPrice>;
    abstract accessKeyChanges(accountIdArray: string[], BlockQuery: BlockId | BlockReference): Promise<ChangeResult>;
    abstract singleAccessKeyChanges(accessKeyArray: AccessKeyWithPublicKey[], BlockQuery: BlockId | BlockReference): Promise<ChangeResult>;
    abstract accountChanges(accountIdArray: string[], BlockQuery: BlockId | BlockReference): Promise<ChangeResult>;
    abstract contractStateChanges(accountIdArray: string[], BlockQuery: BlockId | BlockReference, keyPrefix: string): Promise<ChangeResult>;
    abstract contractCodeChanges(accountIdArray: string[], BlockQuery: BlockId | BlockReference): Promise<ChangeResult>;
}

/** @hidden */
export function getTransactionLastResult(txResult: FinalExecutionOutcome): any {
    if (typeof txResult.status === 'object' && typeof txResult.status.SuccessValue === 'string') {
        const value = Buffer.from(txResult.status.SuccessValue, 'base64').toString();
        try {
            return JSON.parse(value);
        } catch (e) {
            return value;
        }
    }
    return null;
}

'''
'''--- src/res/error_messages.json ---
{
    "GasLimitExceeded": "Exceeded the maximum amount of gas allowed to burn per contract",
    "MethodEmptyName": "Method name is empty",
    "WasmerCompileError": "Wasmer compilation error: {{msg}}",
    "GuestPanic": "Smart contract panicked: {{panic_msg}}",
    "Memory": "Error creating Wasm memory",
    "GasExceeded": "Exceeded the prepaid gas",
    "MethodUTF8Error": "Method name is not valid UTF8 string",
    "BadUTF16": "String encoding is bad UTF-16 sequence",
    "WasmTrap": "WebAssembly trap: {{msg}}",
    "GasInstrumentation": "Gas instrumentation failed or contract has denied instructions.",
    "InvalidPromiseIndex": "{{promise_idx}} does not correspond to existing promises",
    "InvalidPromiseResultIndex": "Accessed invalid promise result index: {{result_idx}}",
    "Deserialization": "Error happened while deserializing the module",
    "MethodNotFound": "Contract method is not found",
    "InvalidRegisterId": "Accessed invalid register id: {{register_id}}",
    "InvalidReceiptIndex": "VM Logic returned an invalid receipt index: {{receipt_index}}",
    "EmptyMethodName": "Method name is empty in contract call",
    "CannotReturnJointPromise": "Returning joint promise is currently prohibited",
    "StackHeightInstrumentation": "Stack instrumentation failed",
    "CodeDoesNotExist": "Cannot find contract code for account {{account_id}}",
    "MethodInvalidSignature": "Invalid method signature",
    "IntegerOverflow": "Integer overflow happened during contract execution",
    "MemoryAccessViolation": "MemoryAccessViolation",
    "InvalidIteratorIndex": "Iterator index {{iterator_index}} does not exist",
    "IteratorWasInvalidated": "Iterator {{iterator_index}} was invalidated after its creation by performing a mutable operation on trie",
    "InvalidAccountId": "VM Logic returned an invalid account id",
    "Serialization": "Error happened while serializing the module",
    "CannotAppendActionToJointPromise": "Actions can only be appended to non-joint promise.",
    "InternalMemoryDeclared": "Internal memory declaration has been found in the module",
    "Instantiate": "Error happened during instantiation",
    "ProhibitedInView": "{{method_name}} is not allowed in view calls",
    "InvalidMethodName": "VM Logic returned an invalid method name",
    "BadUTF8": "String encoding is bad UTF-8 sequence",
    "BalanceExceeded": "Exceeded the account balance",
    "LinkError": "Wasm contract link error: {{msg}}",
    "InvalidPublicKey": "VM Logic provided an invalid public key",
    "ActorNoPermission": "Actor {{actor_id}} doesn't have permission to account {{account_id}} to complete the action",
    "LackBalanceForState": "The account {{account_id}} wouldn't have enough balance to cover storage, required to have {{amount}} yoctoNEAR more",
    "ReceiverMismatch": "Wrong AccessKey used for transaction: transaction is sent to receiver_id={{tx_receiver}}, but is signed with function call access key that restricted to only use with receiver_id={{ak_receiver}}. Either change receiver_id in your transaction or switch to use a FullAccessKey.",
    "CostOverflow": "Transaction gas or balance cost is too high",
    "InvalidSignature": "Transaction is not signed with the given public key",
    "AccessKeyNotFound": "Signer \"{{account_id}}\" doesn't have access key with the given public_key {{public_key}}",
    "NotEnoughBalance": "Sender {{signer_id}} does not have enough balance {{#formatNear}}{{balance}}{{/formatNear}} for operation costing {{#formatNear}}{{cost}}{{/formatNear}}",
    "NotEnoughAllowance": "Access Key {account_id}:{public_key} does not have enough balance {{#formatNear}}{{allowance}}{{/formatNear}} for transaction costing {{#formatNear}}{{cost}}{{/formatNear}}",
    "Expired": "Transaction has expired",
    "DeleteAccountStaking": "Account {{account_id}} is staking and can not be deleted",
    "SignerDoesNotExist": "Signer {{signer_id}} does not exist",
    "TriesToStake": "Account {{account_id}} tried to stake {{#formatNear}}{{stake}}{{/formatNear}}, but has staked {{#formatNear}}{{locked}}{{/formatNear}} and only has {{#formatNear}}{{balance}}{{/formatNear}}",
    "AddKeyAlreadyExists": "The public key {{public_key}} is already used for an existing access key",
    "InvalidSigner": "Invalid signer account ID {{signer_id}} according to requirements",
    "CreateAccountNotAllowed": "The new account_id {{account_id}} can't be created by {{predecessor_id}}",
    "RequiresFullAccess": "The transaction contains more then one action, but it was signed with an access key which allows transaction to apply only one specific action. To apply more then one actions TX must be signed with a full access key",
    "TriesToUnstake": "Account {{account_id}} is not yet staked, but tried to unstake",
    "InvalidNonce": "Transaction nonce {{tx_nonce}} must be larger than nonce of the used access key {{ak_nonce}}",
    "AccountAlreadyExists": "Can't create a new account {{account_id}}, because it already exists",
    "InvalidChain": "Transaction parent block hash doesn't belong to the current chain",
    "AccountDoesNotExist": "Can't complete the action because account {{account_id}} doesn't exist",
    "MethodNameMismatch": "Transaction method name {{method_name}} isn't allowed by the access key",
    "DeleteAccountHasRent": "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover the rent",
    "DeleteAccountHasEnoughBalance": "Account {{account_id}} can't be deleted. It has {{#formatNear}}{{balance}}{{/formatNear}}, which is enough to cover it's storage",
    "InvalidReceiver": "Invalid receiver account ID {{receiver_id}} according to requirements",
    "DeleteKeyDoesNotExist": "Account {{account_id}} tries to remove an access key that doesn't exist",
    "Timeout": "Timeout exceeded",
    "Closed": "Connection closed"
}

'''
'''--- src/signer.ts ---
import sha256 from 'js-sha256';
import { Signature, KeyPair, PublicKey } from './utils/key_pair';
import { KeyStore } from './key_stores/keystore';
import { InMemoryKeyStore } from './key_stores/in_memory_key_store';

/**
 * General signing interface, can be used for in memory signing, RPC singing, external wallet, HSM, etc.
 */
export abstract class Signer {

    /**
     * Creates new key and returns public key.
     */
    abstract async createKey(accountId: string, networkId?: string): Promise<PublicKey>;

    /**
     * Returns public key for given account / network.
     * @param accountId accountId to retrieve from.
     * @param networkId The targeted network. (ex. default, betanet, etc)
     */
    abstract async getPublicKey(accountId?: string, networkId?: string): Promise<PublicKey>;

    /**
     * Signs given message, by first hashing with sha256.
     * @param message message to sign.
     * @param accountId accountId to use for signing.
     * @param networkId The targeted network. (ex. default, betanet, etc)
     */
    abstract async signMessage(message: Uint8Array, accountId?: string, networkId?: string): Promise<Signature>;
}

/**
 * Signs using in memory key store.
 */
export class InMemorySigner extends Signer {
    readonly keyStore: KeyStore;

    constructor(keyStore: KeyStore) {
        super();
        this.keyStore = keyStore;
    }

    /**
     * Creates a single account Signer instance with account, network and keyPair provided.
     *
     * Intended to be useful for temporary keys (e.g. claiming a Linkdrop).
     *
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @param accountId The NEAR account to assign the key pair to
     * @param keyPair The keyPair to use for signing
     */
    static async fromKeyPair(networkId: string, accountId: string, keyPair: KeyPair): Promise<Signer> {
        const keyStore = new InMemoryKeyStore()
        await keyStore.setKey(networkId, accountId, keyPair);
        return new InMemorySigner(keyStore);
    }

    /**
     * Creates a public key for the account given
     * @param accountId The NEAR account to assign a public key to
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @returns {Promise<PublicKey>}
     */
    async createKey(accountId: string, networkId: string): Promise<PublicKey> {
        const keyPair = KeyPair.fromRandom('ed25519');
        await this.keyStore.setKey(networkId, accountId, keyPair);
        return keyPair.getPublicKey();
    }

    /**
     * Gets the existing public key for a given account
     * @param accountId The NEAR account to assign a public key to
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @returns {Promise<PublicKey>} Returns the public key or null if not found
     */
    async getPublicKey(accountId?: string, networkId?: string): Promise<PublicKey> {
        const keyPair = await this.keyStore.getKey(networkId, accountId);
        if (keyPair === null) {
            return null;
        }
        return keyPair.getPublicKey();
    }

    /**
     * @param message A message to be signed, typically a serialized transaction
     * @param accountId the NEAR account signing the message
     * @param networkId The targeted network. (ex. default, betanet, etc)
     * @returns {Promise<Signature>}
     */
    async signMessage(message: Uint8Array, accountId?: string, networkId?: string): Promise<Signature> {
        const hash = new Uint8Array(sha256.sha256.array(message));
        if (!accountId) {
            throw new Error('InMemorySigner requires provided account id');
        }
        const keyPair = await this.keyStore.getKey(networkId, accountId);
        if (keyPair === null) {
            throw new Error(`Key for ${accountId} not found in ${networkId}`);
        }
        return keyPair.sign(hash);
    }

    toString(): string {
        return `InMemorySigner(${this.keyStore})`;
    }
}

'''
'''--- src/transaction.ts ---
import sha256 from 'js-sha256';
import BN from 'bn.js';

import { Enum, Assignable } from './utils/enums';
import { serialize, deserialize } from 'borsh';
import { KeyType, PublicKey } from './utils/key_pair';
import { Signer } from './signer';

export class FunctionCallPermission extends Assignable {
    allowance?: BN;
    receiverId: string;
    methodNames: string[];
}

export class FullAccessPermission extends Assignable {}

export class AccessKeyPermission extends Enum {
    functionCall: FunctionCallPermission;
    fullAccess: FullAccessPermission;
}

export class AccessKey extends Assignable {
    nonce: number;
    permission: AccessKeyPermission;
}

export function fullAccessKey(): AccessKey {
    return new AccessKey({ nonce: 0, permission: new AccessKeyPermission({fullAccess: new FullAccessPermission({})}) });
}

export function functionCallAccessKey(receiverId: string, methodNames: string[], allowance?: BN): AccessKey {
    return new AccessKey({ nonce: 0, permission: new AccessKeyPermission({functionCall: new FunctionCallPermission({receiverId, allowance, methodNames})})});
}

export class IAction extends Assignable {}

export class CreateAccount extends IAction {}
export class DeployContract extends IAction { code: Uint8Array; }
export class FunctionCall extends IAction { methodName: string; args: Uint8Array; gas: BN; deposit: BN; }
export class Transfer extends IAction { deposit: BN; }
export class Stake extends IAction { stake: BN; publicKey: PublicKey; }
export class AddKey extends IAction { publicKey: PublicKey; accessKey: AccessKey; }
export class DeleteKey extends IAction { publicKey: PublicKey; }
export class DeleteAccount extends IAction { beneficiaryId: string; }

export function createAccount(): Action {
    return new Action({createAccount: new CreateAccount({}) });
}

export function deployContract(code: Uint8Array): Action {
    return new Action({ deployContract: new DeployContract({code}) });
}

export function stringifyJsonOrBytes(args: any): Buffer {
    const isUint8Array = args.byteLength !== undefined && args.byteLength === args.length;
    const serializedArgs = isUint8Array ? args : Buffer.from(JSON.stringify(args));
    return serializedArgs;
}

/**
 * Constructs {@link Action} instance representing contract method call.
 *
 * @param methodName the name of the method to call
 * @param args arguments to pass to method. Can be either plain JS object which gets serialized as JSON automatically
 *  or `Uint8Array` instance which represents bytes passed as is.
 * @param gas max amount of gas that method call can use
 * @param deposit amount of NEAR (in yoctoNEAR) to send together with the call
 * @param stringify Convert input arguments into bytes array.
 */
export function functionCall(methodName: string, args: Uint8Array | object, gas: BN, deposit: BN, stringify = stringifyJsonOrBytes): Action {
    return new Action({functionCall: new FunctionCall({methodName, args: stringify(args), gas, deposit }) });
}

export function transfer(deposit: BN): Action {
    return new Action({transfer: new Transfer({ deposit }) });
}

export function stake(stake: BN, publicKey: PublicKey): Action {
    return new Action({stake: new Stake({ stake, publicKey }) });
}

export function addKey(publicKey: PublicKey, accessKey: AccessKey): Action {
    return new Action({addKey: new AddKey({ publicKey, accessKey}) });
}

export function deleteKey(publicKey: PublicKey): Action {
    return new Action({deleteKey: new DeleteKey({ publicKey }) });
}

export function deleteAccount(beneficiaryId: string): Action {
    return new Action({deleteAccount: new DeleteAccount({ beneficiaryId }) });
}

export class Signature extends Assignable {
    keyType: KeyType;
    data: Uint8Array;
}

export class Transaction extends Assignable {
    signerId: string;
    publicKey: PublicKey;
    nonce: number;
    receiverId: string;
    actions: Action[];
    blockHash: Uint8Array;

    encode(): Uint8Array {
        return serialize(SCHEMA, this);
    }

    static decode(bytes: Buffer): Transaction {
        return deserialize(SCHEMA, Transaction, bytes);
    }
}

export class SignedTransaction extends Assignable {
    transaction: Transaction;
    signature: Signature;

    encode(): Uint8Array {
        return serialize(SCHEMA, this);
    }

    static decode(bytes: Buffer): SignedTransaction {
        return deserialize(SCHEMA, SignedTransaction, bytes);
    }
}

/**
 * Contains a list of the valid transaction Actions available with this API
 * @see {@link https://nomicon.io/RuntimeSpec/Actions.html | Actions Spec}
 */
export class Action extends Enum {
    createAccount: CreateAccount;
    deployContract: DeployContract;
    functionCall: FunctionCall;
    transfer: Transfer;
    stake: Stake;
    addKey: AddKey;
    deleteKey: DeleteKey;
    deleteAccount: DeleteAccount;
}

export const SCHEMA = new Map<Function, any>([
    [Signature, {kind: 'struct', fields: [
        ['keyType', 'u8'],
        ['data', [64]]
    ]}],
    [SignedTransaction, {kind: 'struct', fields: [
        ['transaction', Transaction],
        ['signature', Signature]
    ]}],
    [Transaction, { kind: 'struct', fields: [
        ['signerId', 'string'],
        ['publicKey', PublicKey],
        ['nonce', 'u64'],
        ['receiverId', 'string'],
        ['blockHash', [32]],
        ['actions', [Action]]
    ]}],
    [PublicKey, { kind: 'struct', fields: [
        ['keyType', 'u8'],
        ['data', [32]]
    ]}],
    [AccessKey, { kind: 'struct', fields: [
        ['nonce', 'u64'],
        ['permission', AccessKeyPermission],
    ]}],
    [AccessKeyPermission, {kind: 'enum', field: 'enum', values: [
        ['functionCall', FunctionCallPermission],
        ['fullAccess', FullAccessPermission],
    ]}],
    [FunctionCallPermission, {kind: 'struct', fields: [
        ['allowance', {kind: 'option', type: 'u128'}],
        ['receiverId', 'string'],
        ['methodNames', ['string']],
    ]}],
    [FullAccessPermission, {kind: 'struct', fields: []}],
    [Action, {kind: 'enum', field: 'enum', values: [
        ['createAccount', CreateAccount],
        ['deployContract', DeployContract],
        ['functionCall', FunctionCall],
        ['transfer', Transfer],
        ['stake', Stake],
        ['addKey', AddKey],
        ['deleteKey', DeleteKey],
        ['deleteAccount', DeleteAccount],
    ]}],
    [CreateAccount, { kind: 'struct', fields: [] }],
    [DeployContract, { kind: 'struct', fields: [
        ['code', ['u8']]
    ]}],
    [FunctionCall, { kind: 'struct', fields: [
        ['methodName', 'string'],
        ['args', ['u8']],
        ['gas', 'u64'],
        ['deposit', 'u128']
    ]}],
    [Transfer, { kind: 'struct', fields: [
        ['deposit', 'u128']
    ]}],
    [Stake, { kind: 'struct', fields: [
        ['stake', 'u128'],
        ['publicKey', PublicKey]
    ]}],
    [AddKey, { kind: 'struct', fields: [
        ['publicKey', PublicKey],
        ['accessKey', AccessKey]
    ]}],
    [DeleteKey, { kind: 'struct', fields: [
        ['publicKey', PublicKey]
    ]}],
    [DeleteAccount, { kind: 'struct', fields: [
        ['beneficiaryId', 'string']
    ]}],
]);

export function createTransaction(signerId: string, publicKey: PublicKey, receiverId: string, nonce: number, actions: Action[], blockHash: Uint8Array): Transaction {
    return new Transaction({ signerId, publicKey, nonce, receiverId, actions, blockHash });
}

/**
 * Signs a given transaction from an account with given keys, applied to the given network
 * @param transaction The Transaction object to sign
 * @param signer The {Signer} object that assists with signing keys
 * @param accountId The human-readable NEAR account name
 * @param networkId The targeted network. (ex. default, betanet, etc)
 */
async function signTransactionObject(transaction: Transaction, signer: Signer, accountId?: string, networkId?: string): Promise<[Uint8Array, SignedTransaction]> {
    const message = serialize(SCHEMA, transaction);
    const hash = new Uint8Array(sha256.sha256.array(message));
    const signature = await signer.signMessage(message, accountId, networkId);
    const signedTx = new SignedTransaction({
        transaction,
        signature: new Signature({ keyType: transaction.publicKey.keyType, data: signature.signature })
    });
    return [hash, signedTx];
}

export async function signTransaction(transaction: Transaction, signer: Signer, accountId?: string, networkId?: string): Promise<[Uint8Array, SignedTransaction]>;
export async function signTransaction(receiverId: string, nonce: number, actions: Action[], blockHash: Uint8Array, signer: Signer, accountId?: string, networkId?: string): Promise<[Uint8Array, SignedTransaction]>;
export async function signTransaction(...args): Promise<[Uint8Array, SignedTransaction]> {
    if (args[0].constructor === Transaction) {
        const [ transaction, signer, accountId, networkId ] = args;
        return signTransactionObject(transaction, signer, accountId, networkId);
    } else {
        const [ receiverId, nonce, actions, blockHash, signer, accountId, networkId ] = args;
        const publicKey = await signer.getPublicKey(accountId, networkId);
        const transaction = createTransaction(accountId, publicKey, receiverId, nonce, actions, blockHash);
        return signTransactionObject(transaction, signer, accountId, networkId);
    }
}

'''
'''--- src/utils/enums.ts ---
/** @hidden @module */
export abstract class Enum {
  enum: string;

  constructor(properties: any) {
      if (Object.keys(properties).length !== 1) {
          throw new Error('Enum can only take single value');
      }
      Object.keys(properties).map((key: string) => {
          (this as any)[key] = properties[key];
          this.enum = key;
      });
  }
}

export abstract class Assignable {
    constructor(properties: any) {
        Object.keys(properties).map((key: any) => {
            (this as any)[key] = properties[key];
        });
    }
}

'''
'''--- src/utils/errors.ts ---
export class PositionalArgsError extends Error {
    constructor() {
        super('Contract method calls expect named arguments wrapped in object, e.g. { argName1: argValue1, argName2: argValue2 }');
    }
}

export class ArgumentTypeError extends Error {
    constructor(argName: string, argType: string, argValue: any) {
        super(`Expected ${argType} for '${argName}' argument, but got '${JSON.stringify(argValue)}'`);
    }
}

export class TypedError extends Error {
    type: string;
    context?: ErrorContext;
    constructor(message?: string, type?: string, context?: ErrorContext) {
        super(message);
        this.type = type || 'UntypedError';
        this.context = context;
    }
}

export class ErrorContext {
    transactionHash?: string;
    constructor(transactionHash?: string) {
        this.transactionHash = transactionHash;
    }
}

export function logWarning(...args: any[]): void {
    if (!process.env['NEAR_NO_LOGS']){
        console.warn(...args);
    }
}
'''
'''--- src/utils/exponential-backoff.ts ---
export default async function exponentialBackoff(startWaitTime, retryNumber, waitBackoff, getResult) {
    // TODO: jitter?

    let waitTime = startWaitTime;
    for (let i = 0; i < retryNumber; i++) {
        const result = await getResult();
        if (result) {
            return result;
        }

        await sleep(waitTime);
        waitTime *= waitBackoff;
    }

    return null;
}

// Sleep given number of millis.
function sleep(millis: number): Promise<any> {
    return new Promise(resolve => setTimeout(resolve, millis));
}

'''
'''--- src/utils/format.ts ---
import BN from 'bn.js';

/**
 * Exponent for calculating how many indivisible units are there in one NEAR. See {@link NEAR_NOMINATION}.
 */
export const NEAR_NOMINATION_EXP = 24;

/**
 * Number of indivisible units in one NEAR. Derived from {@link NEAR_NOMINATION_EXP}.
 */
export const NEAR_NOMINATION = new BN('10', 10).pow(new BN(NEAR_NOMINATION_EXP, 10));

// Pre-calculate offests used for rounding to different number of digits
const ROUNDING_OFFSETS: BN[] = [];
const BN10 = new BN(10);
for (let i = 0, offset = new BN(5); i < NEAR_NOMINATION_EXP; i++, offset = offset.mul(BN10)) {
    ROUNDING_OFFSETS[i] = offset;
}

/**
 * Convert account balance value from internal indivisible units to NEAR. 1 NEAR is defined by {@link NEAR_NOMINATION}.
 * Effectively this divides given amount by {@link NEAR_NOMINATION}.
 *
 * @param balance decimal string representing balance in smallest non-divisible NEAR units (as specified by {@link NEAR_NOMINATION})
 * @param fracDigits number of fractional digits to preserve in formatted string. Balance is rounded to match given number of digits.
 * @returns Value in 
 */
export function formatNearAmount(balance: string, fracDigits: number = NEAR_NOMINATION_EXP): string {
    const balanceBN = new BN(balance, 10);
    if (fracDigits !== NEAR_NOMINATION_EXP) {
        // Adjust balance for rounding at given number of digits
        const roundingExp = NEAR_NOMINATION_EXP - fracDigits - 1;
        if (roundingExp > 0) {
            balanceBN.iadd(ROUNDING_OFFSETS[roundingExp]);
        }
    }

    balance = balanceBN.toString();
    const wholeStr = balance.substring(0, balance.length - NEAR_NOMINATION_EXP) || '0';
    const fractionStr = balance.substring(balance.length - NEAR_NOMINATION_EXP)
        .padStart(NEAR_NOMINATION_EXP, '0').substring(0, fracDigits);

    return trimTrailingZeroes(`${formatWithCommas(wholeStr)}.${fractionStr}`);
}

/**
 * Convert human readable NEAR amount to internal indivisible units.
 * Effectively this multiplies given amount by {@link NEAR_NOMINATION}.
 *
 * @param amt decimal string (potentially fractional) denominated in NEAR.
 * @returns The parsed yocto amount or null if no amount was passed in
 */
export function parseNearAmount(amt?: string): string | null {
    if (!amt) { return null; }
    amt = cleanupAmount(amt);
    const split = amt.split('.');
    const wholePart = split[0];
    const fracPart = split[1] || '';
    if (split.length > 2 || fracPart.length > NEAR_NOMINATION_EXP) {
        throw new Error(`Cannot parse '${amt}' as NEAR amount`);
    }
    return trimLeadingZeroes(wholePart + fracPart.padEnd(NEAR_NOMINATION_EXP, '0'));
}

/**
 * Removes commas from the input
 * @param amount A value or amount that may contain commas
 * @returns string The cleaned value
 */
function cleanupAmount(amount: string): string {
    return amount.replace(/,/g, '').trim();
}

/**
 * Removes .000 from an input
 * @param value A value that may contain trailing zeroes in the decimals place
 * @returns string The value without the trailing zeros
 */
function trimTrailingZeroes(value: string): string {
    return value.replace(/\.?0*$/, '');
}

/**
 * Removes leading zeroes from an input
 * @param value A value that may contain leading zeroes
 * @returns string The value without the leading zeroes
 */
function trimLeadingZeroes(value: string): string {
    value = value.replace(/^0+/, '');
    if (value === '') {
        return '0';
    }
    return value;
}

/**
 * Returns a human-readable value with commas
 * @param value A value that may not contain commas
 * @returns string A value with commas
 */
function formatWithCommas(value: string): string {
    const pattern = /(-?\d+)(\d{3})/;
    while (pattern.test(value)) {
        value = value.replace(pattern, '$1,$2');
    }
    return value;
}

'''
'''--- src/utils/index.ts ---

import * as key_pair from './key_pair';
import * as serialize from './serialize';
import * as web from './web';
import * as enums from './enums';
import * as format from './format';
import * as rpc_errors from './rpc_errors';

import { PublicKey, KeyPair, KeyPairEd25519 } from './key_pair';
import { logWarning } from './errors';

export {
    key_pair,
    serialize,
    web,
    enums,
    format,
    PublicKey,
    KeyPair,
    KeyPairEd25519,
    rpc_errors,
    logWarning,
};

'''
'''--- src/utils/key_pair.ts ---
import nacl from 'tweetnacl';
import { base_encode, base_decode } from './serialize';
import { Assignable } from './enums';

export type Arrayish = string | ArrayLike<number>;

export interface Signature {
    signature: Uint8Array;
    publicKey: PublicKey;
}

/** All supported key types */
export enum KeyType {
    ED25519 = 0,
}

function key_type_to_str(keyType: KeyType): string {
    switch (keyType) {
    case KeyType.ED25519: return 'ed25519';
    default: throw new Error(`Unknown key type ${keyType}`);
    }
}

function str_to_key_type(keyType: string): KeyType {
    switch (keyType.toLowerCase()) {
    case 'ed25519': return KeyType.ED25519;
    default: throw new Error(`Unknown key type ${keyType}`);
    }
}

/**
 * PublicKey representation that has type and bytes of the key.
 */
export class PublicKey extends Assignable {
    keyType: KeyType;
    data: Uint8Array;

    static from(value: string | PublicKey): PublicKey {
        if (typeof value === 'string') {
            return PublicKey.fromString(value);
        }
        return value;
    }

    static fromString(encodedKey: string): PublicKey {
        const parts = encodedKey.split(':');
        if (parts.length === 1) {
            return new PublicKey({ keyType: KeyType.ED25519, data: base_decode(parts[0]) });
        } else if (parts.length === 2) {
            return new PublicKey({ keyType: str_to_key_type(parts[0]), data: base_decode(parts[1]) });
        } else {
            throw new Error('Invalid encoded key format, must be <curve>:<encoded key>');
        }
    }

    toString(): string {
        return `${key_type_to_str(this.keyType)}:${base_encode(this.data)}`;
    }

    verify(message: Uint8Array, signature: Uint8Array): boolean {
        switch (this.keyType) {
        case KeyType.ED25519: return nacl.sign.detached.verify(message, signature, this.data);
        default: throw new Error(`Unknown key type ${this.keyType}`);
        }
    }
}

export abstract class KeyPair {
    abstract sign(message: Uint8Array): Signature;
    abstract verify(message: Uint8Array, signature: Uint8Array): boolean;
    abstract toString(): string;
    abstract getPublicKey(): PublicKey;

    /**
     * @param curve Name of elliptical curve, case-insensitive
     * @returns Random KeyPair based on the curve
     */
    static fromRandom(curve: string): KeyPair {
        switch (curve.toUpperCase()) {
        case 'ED25519': return KeyPairEd25519.fromRandom();
        default: throw new Error(`Unknown curve ${curve}`);
        }
    }

    static fromString(encodedKey: string): KeyPair {
        const parts = encodedKey.split(':');
        if (parts.length === 1) {
            return new KeyPairEd25519(parts[0]);
        } else if (parts.length === 2) {
            switch (parts[0].toUpperCase()) {
            case 'ED25519': return new KeyPairEd25519(parts[1]);
            default: throw new Error(`Unknown curve: ${parts[0]}`);
            }
        } else {
            throw new Error('Invalid encoded key format, must be <curve>:<encoded key>');
        }
    }
}

/**
 * This class provides key pair functionality for Ed25519 curve:
 * generating key pairs, encoding key pairs, signing and verifying.
 */
export class KeyPairEd25519 extends KeyPair {
    readonly publicKey: PublicKey;
    readonly secretKey: string;

    /**
     * Construct an instance of key pair given a secret key.
     * It's generally assumed that these are encoded in base58.
     * @param {string} secretKey
     */
    constructor(secretKey: string) {
        super();
        const keyPair = nacl.sign.keyPair.fromSecretKey(base_decode(secretKey));
        this.publicKey = new PublicKey({ keyType: KeyType.ED25519, data: keyPair.publicKey });
        this.secretKey = secretKey;
    }

    /**
     * Generate a new random keypair.
     * @example
     * const keyRandom = KeyPair.fromRandom();
     * keyRandom.publicKey
     * // returns [PUBLIC_KEY]
     *
     * keyRandom.secretKey
     * // returns [SECRET_KEY]
     */
    static fromRandom() {
        const newKeyPair = nacl.sign.keyPair();
        return new KeyPairEd25519(base_encode(newKeyPair.secretKey));
    }

    sign(message: Uint8Array): Signature {
        const signature = nacl.sign.detached(message, base_decode(this.secretKey));
        return { signature, publicKey: this.publicKey };
    }

    verify(message: Uint8Array, signature: Uint8Array): boolean {
        return this.publicKey.verify(message, signature);
    }

    toString(): string {
        return `ed25519:${this.secretKey}`;
    }

    getPublicKey(): PublicKey {
        return this.publicKey;
    }
}

'''
'''--- src/utils/rpc_errors.ts ---

import Mustache from 'mustache';
import schema from '../generated/rpc_error_schema.json';
import messages from '../res/error_messages.json';
import { utils } from '../common-index';
import { TypedError } from '../utils/errors';

const mustacheHelpers = {
    formatNear: () => (n, render) => utils.format.formatNearAmount(render(n))
};

export class ServerError extends TypedError {
}

class ServerTransactionError extends ServerError {
    public transaction_outcome: any;
}

export function parseRpcError(errorObj: Record<string, any>): ServerError {
    const result = {};
    const errorClassName = walkSubtype(errorObj, schema.schema, result, '');
    // NOTE: This assumes that all errors extend TypedError
    const error = new ServerError(formatError(errorClassName, result), errorClassName);
    Object.assign(error, result);
    return error;
}

export function parseResultError(result: any): ServerTransactionError {
    const server_error = parseRpcError(result.status.Failure);
    const server_tx_error = new ServerTransactionError();
    Object.assign(server_tx_error, server_error);
    server_tx_error.type = server_error.type;
    server_tx_error.message = server_error.message;
    server_tx_error.transaction_outcome = result.transaction_outcome;
    return server_tx_error;
}

export function formatError(errorClassName: string, errorData): string {
    if (typeof messages[errorClassName] === 'string') {
        return Mustache.render(messages[errorClassName], {
            ...errorData,
            ...mustacheHelpers
        });
    }
    return JSON.stringify(errorData);
}

/**
 * Walks through defined schema returning error(s) recursively
 * @param errorObj The error to be parsed
 * @param schema A defined schema in JSON mapping to the RPC errors
 * @param result An object used in recursion or called directly
 * @param typeName The human-readable error type name as defined in the JSON mapping
 */
function walkSubtype(errorObj, schema, result, typeName) {
    let error;
    let type;
    let errorTypeName;
    for (const errorName in schema) {
        if (isString(errorObj[errorName])) {
            // Return early if error type is in a schema
            return errorObj[errorName];
        }
        if (isObject(errorObj[errorName])) {
            error = errorObj[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
        } else if (isObject(errorObj.kind) && isObject(errorObj.kind[errorName])) {
            error = errorObj.kind[errorName];
            type = schema[errorName];
            errorTypeName = errorName;
        } else {
            continue;
        }
    }
    if (error && type) {
        for (const prop of Object.keys(type.props)) {
            result[prop] = error[prop];
        }
        return walkSubtype(error, schema, result, errorTypeName);
    } else {
        // TODO: is this the right thing to do?
        result.kind = errorObj;
        return typeName;
    }
}

export function getErrorTypeFromErrorMessage(errorMessage) {
    // This function should be removed when JSON RPC starts returning typed errors.
    switch (true) {
    case /^account .*? does not exist while viewing$/.test(errorMessage):
        return 'AccountDoesNotExist';
    case /^Account .*? doesn't exist$/.test(errorMessage):
        return 'AccountDoesNotExist';
    case /^access key .*? does not exist while viewing$/.test(errorMessage):
        return 'AccessKeyDoesNotExist';
    case /wasm execution failed with error: FunctionCallError\(CompilationError\(CodeDoesNotExist/.test(errorMessage):
        return 'CodeDoesNotExist';
    case /Transaction nonce \d+ must be larger than nonce of the used access key \d+/.test(errorMessage):
        return 'InvalidNonce';
    default:
        return 'UntypedError';
    }
}

/**
 * Helper function determining if the argument is an object
 * @param n Value to check
 */
function isObject(n) {
    return Object.prototype.toString.call(n) === '[object Object]';
}

/**
 * Helper function determining if the argument is a string
 * @param n Value to check
 */
function isString(n) {
    return Object.prototype.toString.call(n) === '[object String]';
}

'''
'''--- src/utils/serialize.ts ---
export {
    baseEncode as base_encode,
    baseDecode as base_decode,
    serialize,
    deserialize,
    Schema,
    BorshError,
    BinaryWriter,
    BinaryReader,
} from 'borsh';
'''
'''--- src/utils/setup-node-fetch.ts ---
import fetch from 'node-fetch';
import http from 'http';
import https from 'https';

const httpAgent = new http.Agent({ keepAlive: true });
const httpsAgent = new https.Agent({ keepAlive: true });

function agent(_parsedURL) {
    if (_parsedURL.protocol === 'http:') {
        return httpAgent;
    } else {
        return httpsAgent;
    }
}

export default function (resource, init) {
    return fetch(resource, {
        agent: agent(new URL(resource.toString())),
        ...init,
    });
}

'''
'''--- src/utils/web.ts ---
import createError from 'http-errors';

import exponentialBackoff from './exponential-backoff';
import { TypedError } from '../providers';
import { logWarning } from './errors';

const START_WAIT_TIME_MS = 1000;
const BACKOFF_MULTIPLIER = 1.5;
const RETRY_NUMBER = 10;

export interface ConnectionInfo {
    url: string;
    user?: string;
    password?: string;
    allowInsecure?: boolean;
    timeout?: number;
    headers?: { [key: string]: string | number };
}

export async function fetchJson(connection: string | ConnectionInfo, json?: string): Promise<any> {
    let url: string = null;
    if (typeof(connection) === 'string') {
        url = connection;
    } else {
        url = connection.url;
    }

    const response = await exponentialBackoff(START_WAIT_TIME_MS, RETRY_NUMBER, BACKOFF_MULTIPLIER, async () => {
        try {
            const response = await fetch(url, {
                method: json ? 'POST' : 'GET',
                body: json ? json : undefined,
                headers: { 'Content-Type': 'application/json; charset=utf-8' }
            });
            if (!response.ok) {
                if (response.status === 503) {
                    logWarning(`Retrying HTTP request for ${url} as it's not available now`);
                    return null;
                }
                throw createError(response.status, await response.text());
            }
            return response;
        } catch (error) {
            if (error.toString().includes('FetchError') || error.toString().includes('Failed to fetch')) {
                logWarning(`Retrying HTTP request for ${url} because of error: ${error}`);
                return null;
            }
            throw error;
        }
    });
    if (!response) {
        throw new TypedError(`Exceeded ${RETRY_NUMBER} attempts for ${url}.`, 'RetriesExceeded');
    }
    return await response.json();
}

'''
'''--- src/validators.ts ---
'use strict';

import BN from 'bn.js';
import { CurrentEpochValidatorInfo, NextEpochValidatorInfo } from './providers/provider';

/** Finds seat price given validators stakes and number of seats.
 *  Calculation follow the spec: https://nomicon.io/Economics/README.html#validator-selection
 * @params validators: current or next epoch validators.
 * @params numSeats: number of seats.
 */
export function findSeatPrice(validators: (CurrentEpochValidatorInfo | NextEpochValidatorInfo)[], numSeats: number): BN {
    const stakes = validators.map(v => new BN(v.stake, 10)).sort((a, b) => a.cmp(b));
    const num = new BN(numSeats);
    const stakesSum = stakes.reduce((a, b) => a.add(b));
    if (stakesSum.lt(num)) {
        throw new Error('Stakes are below seats');
    }
    // assert stakesSum >= numSeats
    let left = new BN(1), right = stakesSum.add(new BN(1));
    while (!left.eq(right.sub(new BN(1)))) {
        const mid = left.add(right).div(new BN(2));
        let found = false;
        let currentSum = new BN(0);
        for (let i = 0; i < stakes.length; ++i) {
            currentSum = currentSum.add(stakes[i].div(mid));
            if (currentSum.gte(num)) {
                left = mid;
                found = true;
                break;
            }
        }
        if (!found) {
            right = mid;
        }
    }
    return left;
}

export interface ChangedValidatorInfo {
    current: CurrentEpochValidatorInfo;
    next: NextEpochValidatorInfo;
}

export interface EpochValidatorsDiff {
    newValidators: NextEpochValidatorInfo[];
    removedValidators: CurrentEpochValidatorInfo[];
    changedValidators: ChangedValidatorInfo[];
}

/** Diff validators between current and next epoch.
 * Returns additions, subtractions and changes to validator set.
 * @params currentValidators: list of current validators.
 * @params nextValidators: list of next validators.
 */
export function diffEpochValidators(currentValidators: CurrentEpochValidatorInfo[], nextValidators: NextEpochValidatorInfo[]): EpochValidatorsDiff {
    const validatorsMap = new Map<string, CurrentEpochValidatorInfo>();
    currentValidators.forEach(v => validatorsMap.set(v.account_id, v));
    const nextValidatorsSet = new Set(nextValidators.map(v => v.account_id));
    return { 
        newValidators: nextValidators.filter(v => !validatorsMap.has(v.account_id)),
        removedValidators: currentValidators.filter(v => !nextValidatorsSet.has(v.account_id)), 
        changedValidators: nextValidators.filter(v => (validatorsMap.has(v.account_id) && validatorsMap.get(v.account_id).stake != v.stake))
            .map(v => ({ current: validatorsMap.get(v.account_id), next: v }))
    };
}

'''
'''--- src/wallet-account.ts ---
/**
 * The classes in this module are used in conjunction with the {@link BrowserLocalStorageKeyStore}. This module exposes two classes:
 * * {@link WalletConnection} which redirects users to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for key management.
 * * {@link ConnectedWalletAccount} is an {@link Account} implementation that uses {@link WalletConnection} to get keys
 * 
 * @module walletAccount
 */
import depd from 'depd';
import { Account, SignAndSendTransactionOptions } from './account';
import { Near } from './near';
import { KeyStore } from './key_stores';
import { FinalExecutionOutcome } from './providers';
import { InMemorySigner } from './signer';
import { Transaction, Action, SCHEMA, createTransaction } from './transaction';
import { KeyPair, PublicKey } from './utils';
import { baseDecode } from 'borsh';
import { Connection } from './connection';
import { serialize } from 'borsh';

const LOGIN_WALLET_URL_SUFFIX = '/login/';
const MULTISIG_HAS_METHOD = 'add_request_and_confirm';
const LOCAL_STORAGE_KEY_SUFFIX = '_wallet_auth_key';
const PENDING_ACCESS_KEY_PREFIX = 'pending_key'; // browser storage key for a pending access key (i.e. key has been generated but we are not sure it was added yet)

interface SignInOptions {
    contractId?: string;
    methodNames?: string[];
    // TODO: Replace following with single callbackUrl
    successUrl?: string;
    failureUrl?: string;
}

/**
 * Information to send NEAR wallet for signing transactions and redirecting the browser back to the calling application
 */
interface RequestSignTransactionsOptions {
    /** list of transactions to sign */
    transactions: Transaction[];
    /** url NEAR Wallet will redirect to after transaction signing is complete */
    callbackUrl?: string;
    /** meta information NEAR Wallet will send back to the application. `meta` will be attached to the `callbackUrl` as a url search param */
    meta?: string;
}

/**
 * This class is used in conjunction with the {@link BrowserLocalStorageKeyStore}.
 * It redirects users to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for key management.
 * 
 * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#wallet}
 * @example
 * ```js
 * // create new WalletConnection instance
 * const wallet = new WalletConnection(near, 'my-app');
 * 
 * // If not signed in redirect to the NEAR wallet to sign in
 * // keys will be stored in the BrowserLocalStorageKeyStore
 * if(!wallet.isSingnedIn()) return wallet.requestSignIn()
 * ```
 */
export class WalletConnection {
    /** @hidden */
    _walletBaseUrl: string;

    /** @hidden */
    _authDataKey: string;

    /** @hidden */
    _keyStore: KeyStore;

    /** @hidden */
    _authData: any;

    /** @hidden */
    _networkId: string;

    /** @hidden */
    _near: Near;

    /** @hidden */
    _connectedAccount: ConnectedWalletAccount;

    constructor(near: Near, appKeyPrefix: string | null) {
        this._near = near;
        const authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;
        const authData = JSON.parse(window.localStorage.getItem(authDataKey));
        this._networkId = near.config.networkId;
        this._walletBaseUrl = near.config.walletUrl;
        appKeyPrefix = appKeyPrefix || near.config.contractName || 'default';
        this._keyStore = (near.connection.signer as InMemorySigner).keyStore;
        this._authData = authData || { allKeys: [] };
        this._authDataKey = authDataKey;
        if (!this.isSignedIn()) {
            this._completeSignInWithAccessKey();
        }
    }

    /**
     * Returns true, if this WalletAccount is authorized with the wallet.
     * @example
     * ```js
     * const wallet = new WalletConnection(near, 'my-app');
     * wallet.isSignedIn();
     * ```
     */
    isSignedIn() {
        return !!this._authData.accountId;
    }

    /**
     * Returns authorized Account ID.
     * @example
     * ```js
     * const wallet = new WalletConnection(near, 'my-app');
     * wallet.getAccountId();
     * ```
     */
    getAccountId() {
        return this._authData.accountId || '';
    }

    /**
     * Redirects current page to the wallet authentication page.
     * @param options An optional options object
     * @param options.contractId The NEAR account where the contract is deployed
     * @param options.successUrl URL to redirect upon success. Default: current url
     * @param options.failureUrl URL to redirect upon failure. Default: current url
     *
     * @example
     * ```js
     * const wallet = new WalletConnection(near, 'my-app');
     * // redirects to the NEAR Wallet
     * wallet.requestSignIn({ contractId: 'account-with-deploy-contract.near' });
     * ```
     */
    async requestSignIn(
        contractIdOrOptions: string | SignInOptions = {},
        title?: string,
        successUrl?: string,
        failureUrl?: string
    ) {
        let options: SignInOptions;
        if (typeof contractIdOrOptions === 'string') {
            const deprecate = depd('requestSignIn(contractId, title)');
            deprecate('`title` ignored; use `requestSignIn({ contractId, methodNames, successUrl, failureUrl })` instead');
            options = { contractId: contractIdOrOptions, successUrl, failureUrl };
        } else {
            options = contractIdOrOptions as SignInOptions;
        }

        const currentUrl = new URL(window.location.href);
        const newUrl = new URL(this._walletBaseUrl + LOGIN_WALLET_URL_SUFFIX);
        newUrl.searchParams.set('success_url', options.successUrl || currentUrl.href);
        newUrl.searchParams.set('failure_url', options.failureUrl || currentUrl.href);
        if (options.contractId) {            
            /* Throws exception if contract account does not exist */
            const contractAccount = await this._near.account(options.contractId);
            await contractAccount.state();

            newUrl.searchParams.set('contract_id', options.contractId);
            const accessKey = KeyPair.fromRandom('ed25519');
            newUrl.searchParams.set('public_key', accessKey.getPublicKey().toString());
            await this._keyStore.setKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + accessKey.getPublicKey(), accessKey);
        }

        if (options.methodNames) {
            options.methodNames.forEach(methodName => {
                newUrl.searchParams.append('methodNames', methodName);
            });
        }

        window.location.assign(newUrl.toString());
    }

    /**
     * Requests the user to quickly sign for a transaction or batch of transactions by redirecting to the NEAR wallet.
     */
    requestSignTransactions(options: RequestSignTransactionsOptions): Promise<void>
    /**
     * @deprecated
     * Requests the user to quickly sign for a transaction or batch of transactions by redirecting to the NEAR wallet.
     * @param transactions Array of Transaction objects that will be requested to sign
     * @param callbackUrl The url to navigate to after the user is prompted to sign
     */
    requestSignTransactions(transactions: Transaction[], callbackUrl?: string, meta?: string): Promise<void>

    async requestSignTransactions(...args: any[]) {
        if(Array.isArray(args[0])) {
            const deprecate = depd('WalletConnection.requestSignTransactions(transactions, callbackUrl, meta)');
            deprecate('use `WalletConnection.requestSignTransactions(RequestSignTransactionsOptions)` instead');
            return this._requestSignTransactions({
                transactions: args[0],
                callbackUrl: args[1],
                meta: args[2]
            });
        }

        return this._requestSignTransactions(args[0]);
    }

    private async _requestSignTransactions({ transactions, meta, callbackUrl }: RequestSignTransactionsOptions): Promise<void> {
        const currentUrl = new URL(window.location.href);
        const newUrl = new URL('sign', this._walletBaseUrl);

        newUrl.searchParams.set('transactions', transactions
            .map(transaction => serialize(SCHEMA, transaction))
            .map(serialized => Buffer.from(serialized).toString('base64'))
            .join(','));
        newUrl.searchParams.set('callbackUrl', callbackUrl || currentUrl.href);
        if(meta) newUrl.searchParams.set('meta', meta);

        window.location.assign(newUrl.toString());
    }

    /**
     * @hidden
     * Complete sign in for a given account id and public key. To be invoked by the app when getting a callback from the wallet.
     */
    async _completeSignInWithAccessKey() {
        const currentUrl = new URL(window.location.href);
        const publicKey = currentUrl.searchParams.get('public_key') || '';
        const allKeys = (currentUrl.searchParams.get('all_keys') || '').split(',');
        const accountId = currentUrl.searchParams.get('account_id') || '';
        // TODO: Handle errors during login
        if (accountId) {
            this._authData = {
                accountId,
                allKeys
            };
            window.localStorage.setItem(this._authDataKey, JSON.stringify(this._authData));
            if (publicKey) {
                await this._moveKeyFromTempToPermanent(accountId, publicKey);
            }
        }
        currentUrl.searchParams.delete('public_key');
        currentUrl.searchParams.delete('all_keys');
        currentUrl.searchParams.delete('account_id');
        currentUrl.searchParams.delete('meta');
        currentUrl.searchParams.delete('transactionHashes');

        window.history.replaceState({}, document.title, currentUrl.toString());
    }

    /**
     * @hidden
     * @param accountId The NEAR account owning the given public key
     * @param publicKey The public key being set to the key store
     */
    async _moveKeyFromTempToPermanent(accountId: string, publicKey: string) {
        const keyPair = await this._keyStore.getKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);
        await this._keyStore.setKey(this._networkId, accountId, keyPair);
        await this._keyStore.removeKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);
    }

    /**
     * Sign out from the current account
     * @example
     * walletAccount.signOut();
     */
    signOut() {
        this._authData = {};
        window.localStorage.removeItem(this._authDataKey);
    }

    /**
     * Returns the current connected wallet account
     */
    account() {
        if (!this._connectedAccount) {
            this._connectedAccount = new ConnectedWalletAccount(this, this._near.connection, this._authData.accountId);
        }
        return this._connectedAccount;
    }
}

export const WalletAccount = WalletConnection;

/**
 * {@link Account} implementation which redirects to wallet using {@link WalletConnection} when no local key is available.
 */
export class ConnectedWalletAccount extends Account {
    walletConnection: WalletConnection;

    constructor(walletConnection: WalletConnection, connection: Connection, accountId: string) {
        super(connection, accountId);
        this.walletConnection = walletConnection;
    }

    // Overriding Account methods

    /**
     * Sign a transaction by redirecting to the NEAR Wallet
     * @see {@link WalletConnection.requestSignTransactions}
     */
    protected signAndSendTransaction(...args: any[]): Promise<FinalExecutionOutcome> {
        if(typeof args[0] === 'string') {
            return this._signAndSendTransaction({ receiverId: args[0], actions: args[1] });
        }

        return this._signAndSendTransaction(args[0]);
    }

    private async _signAndSendTransaction({ receiverId, actions, walletMeta, walletCallbackUrl = window.location.href }: SignAndSendTransactionOptions): Promise<FinalExecutionOutcome> {
        const localKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);
        let accessKey = await this.accessKeyForTransaction(receiverId, actions, localKey);
        if (!accessKey) {
            throw new Error(`Cannot find matching key for transaction sent to ${receiverId}`);
        }

        if (localKey && localKey.toString() === accessKey.public_key) {
            try {
                return await super.signAndSendTransaction({ receiverId, actions });
            } catch (e) {
                if (e.type === 'NotEnoughAllowance') {
                    accessKey = await this.accessKeyForTransaction(receiverId, actions);
                } else {
                    throw e;
                }
            }
        }

        const block = await this.connection.provider.block({ finality: 'final' });
        const blockHash = baseDecode(block.header.hash);

        const publicKey = PublicKey.from(accessKey.public_key);
        // TODO: Cache & listen for nonce updates for given access key
        const nonce = accessKey.access_key.nonce + 1;
        const transaction = createTransaction(this.accountId, publicKey, receiverId, nonce, actions, blockHash);
        await this.walletConnection.requestSignTransactions({
            transactions: [transaction],
            meta: walletMeta,
            callbackUrl: walletCallbackUrl
        });

        return new Promise((resolve, reject) => {
            setTimeout(() => {
                reject(new Error('Failed to redirect to sign transaction'));
            }, 1000);
        });

        // TODO: Aggregate multiple transaction request with "debounce".
        // TODO: Introduce TrasactionQueue which also can be used to watch for status?
    }

    /**
     * Check if given access key allows the function call or method attempted in transaction
     * @param accessKey Array of {access_key: AccessKey, public_key: PublicKey} items
     * @param receiverId The NEAR account attempting to have access
     * @param actions The action(s) needed to be checked for access
     */
    async accessKeyMatchesTransaction(accessKey, receiverId: string, actions: Action[]): Promise<boolean> {
        const { access_key: { permission } } = accessKey;
        if (permission === 'FullAccess') {
            return true;
        }

        if (permission.FunctionCall) {
            const { receiver_id: allowedReceiverId, method_names: allowedMethods } = permission.FunctionCall;
            /********************************
            Accept multisig access keys and let wallets attempt to signAndSendTransaction
            If an access key has itself as receiverId and method permission add_request_and_confirm, then it is being used in a wallet with multisig contract: https://github.com/near/core-contracts/blob/671c05f09abecabe7a7e58efe942550a35fc3292/multisig/src/lib.rs#L149-L153
            ********************************/
            if (allowedReceiverId === this.accountId && allowedMethods.includes(MULTISIG_HAS_METHOD)) {
                return true;
            }
            if (allowedReceiverId === receiverId) {
                if (actions.length !== 1) {
                    return false;
                }
                const [{ functionCall }] = actions;
                return functionCall &&
                    (!functionCall.deposit || functionCall.deposit.toString() === '0') && // TODO: Should support charging amount smaller than allowance?
                    (allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName));
                // TODO: Handle cases when allowance doesn't have enough to pay for gas
            }
        }
        // TODO: Support other permissions than FunctionCall

        return false;
    }

    /**
     * Helper function returning the access key (if it exists) to the receiver that grants the designated permission
     * @param receiverId The NEAR account seeking the access key for a transaction
     * @param actions The action(s) sought to gain access to
     * @param localKey A local public key provided to check for access
     * @returns Promise<any>
     */
    async accessKeyForTransaction(receiverId: string, actions: Action[], localKey?: PublicKey): Promise<any> {
        const accessKeys = await this.getAccessKeys();

        if (localKey) {
            const accessKey = accessKeys.find(key => key.public_key.toString() === localKey.toString());
            if (accessKey && await this.accessKeyMatchesTransaction(accessKey, receiverId, actions)) {
                return accessKey;
            }
        }

        const walletKeys = this.walletConnection._authData.allKeys;
        for (const accessKey of accessKeys) {
            if (walletKeys.indexOf(accessKey.public_key) !== -1 && await this.accessKeyMatchesTransaction(accessKey, receiverId, actions)) {
                return accessKey;
            }
        }

        return null;
    }
}

'''
'''--- test/.eslintrc.yml ---
extends: '../.eslintrc.yml'
env:
  jest: true
globals:
  jasmine: true
  window: false
  fail: true

'''
'''--- test/account.access_key.test.js ---
const nearApi = require('../src/index');
const testUtils = require('./test-utils');

let nearjs;
let workingAccount;
let contractId;
let contract;

jasmine.DEFAULT_TIMEOUT_INTERVAL = 50000;

beforeAll(async () => {
    nearjs = await testUtils.setUpTestConnection();
});

beforeEach(async () => {
    contractId = testUtils.generateUniqueString('test');
    workingAccount = await testUtils.createAccount(nearjs);
    contract = await testUtils.deployContract(workingAccount, contractId);
});

test('make function call using access key', async() => {
    const keyPair = nearApi.utils.KeyPair.fromRandom('ed25519');
    await workingAccount.addKey(keyPair.getPublicKey(), contractId, '', '2000000000000000000000000');

    // Override in the key store the workingAccount key to the given access key.
    await nearjs.connection.signer.keyStore.setKey(testUtils.networkId, workingAccount.accountId, keyPair);
    const setCallValue = testUtils.generateUniqueString('setCallPrefix');
    await contract.setValue({ args: { value: setCallValue } });
    expect(await contract.getValue()).toEqual(setCallValue);
});

test('remove access key no longer works', async() => {
    const keyPair = nearApi.utils.KeyPair.fromRandom('ed25519');
    let publicKey = keyPair.getPublicKey();
    await workingAccount.addKey(publicKey, contractId, '', 400000);
    await workingAccount.deleteKey(publicKey);
    // Override in the key store the workingAccount key to the given access key.
    await nearjs.connection.signer.keyStore.setKey(testUtils.networkId, workingAccount.accountId, keyPair);
    try {
        await contract.setValue({ args: { value: 'test' } });
        fail('should throw an error');
    } catch (e) {
        if (process.env.NODE_ENV == 'local') {
            expect(e.message).toEqual(`Can not sign transactions for account ${workingAccount.accountId} on network unittest, no matching key pair found in InMemorySigner(MergeKeyStore(InMemoryKeyStore, InMemoryKeyStore)).`);
        } else {
            expect(e.message).toEqual(`Can not sign transactions for account ${workingAccount.accountId} on network unittest, no matching key pair found in InMemorySigner(InMemoryKeyStore).`);
        }
        expect(e.type).toEqual('KeyNotFound');
    }
});

test('view account details after adding access keys', async() => {
    const keyPair = nearApi.utils.KeyPair.fromRandom('ed25519');
    await workingAccount.addKey(keyPair.getPublicKey(), contractId, '', 1000000000);

    const contract2 = await testUtils.deployContract(workingAccount, testUtils.generateUniqueString('test_contract2'));
    const keyPair2 = nearApi.utils.KeyPair.fromRandom('ed25519');
    await workingAccount.addKey(keyPair2.getPublicKey(), contract2.contractId, '', 2000000000);

    const details = await workingAccount.getAccountDetails();
    const expectedResult = {
        authorizedApps: [{
            contractId: contractId,
            amount: '1000000000',
            publicKey: keyPair.getPublicKey().toString(),
        },
        {
            contractId: contract2.contractId,
            amount: '2000000000',
            publicKey: keyPair2.getPublicKey().toString(),
        }],
        transactions: []
    };
    expect(details.authorizedApps).toEqual(jasmine.arrayContaining(expectedResult.authorizedApps));
});

test('loading account after adding a full key', async() => {
    const keyPair = nearApi.utils.KeyPair.fromRandom('ed25519');
    // wallet calls this with an empty string for contract id and method
    await workingAccount.addKey(keyPair.getPublicKey(), '', '');

    let accessKeys = await workingAccount.getAccessKeys();

    expect(accessKeys.length).toBe(2);
    const addedKey = accessKeys.find(item => item.public_key == keyPair.getPublicKey().toString());
    expect(addedKey).toBeTruthy();
    expect(addedKey.access_key.permission).toEqual('FullAccess');
});

'''
'''--- test/account.test.js ---

const { Account, Contract, providers } = require('../src/index');
const testUtils  = require('./test-utils');
const fs = require('fs');
const BN = require('bn.js');

let nearjs;
let workingAccount;

const { HELLO_WASM_PATH, HELLO_WASM_BALANCE } = testUtils;

jasmine.DEFAULT_TIMEOUT_INTERVAL = 50000;

beforeAll(async () => {
    nearjs = await testUtils.setUpTestConnection();
    workingAccount = await testUtils.createAccount(nearjs);
});

afterAll(async () => {
    await workingAccount.deleteAccount(workingAccount.accountId);
});

test('view pre-defined account works and returns correct name', async () => {
    let status = await workingAccount.state();
    expect(status.code_hash).toEqual('11111111111111111111111111111111');
});

test('create account and then view account returns the created account', async () => {
    const newAccountName = testUtils.generateUniqueString('test');
    const newAccountPublicKey = '9AhWenZ3JddamBoyMqnTbp7yVbRuvqAv3zwfrWgfVRJE';
    const { amount } = await workingAccount.state();
    const newAmount = new BN(amount).div(new BN(10));
    await workingAccount.createAccount(newAccountName, newAccountPublicKey, newAmount);
    const newAccount = new Account(nearjs.connection, newAccountName);
    const state = await newAccount.state();
    expect(state.amount).toEqual(newAmount.toString());
});

test('send money', async() => {
    const sender = await testUtils.createAccount(nearjs);
    const receiver = await testUtils.createAccount(nearjs);
    const { amount: receiverAmount } = await receiver.state();
    await sender.sendMoney(receiver.accountId, new BN(10000));
    const state = await receiver.state();
    expect(state.amount).toEqual(new BN(receiverAmount).add(new BN(10000)).toString());
});

test('delete account', async() => {
    const sender = await testUtils.createAccount(nearjs);
    const receiver = await testUtils.createAccount(nearjs);
    await sender.deleteAccount(receiver.accountId);
    const reloaded = new Account(sender.connection, sender);
    await expect(reloaded.state()).rejects.toThrow();
});

test('multiple parallel transactions', async () => {
    const PARALLEL_NUMBER = 5;
    await Promise.all([...Array(PARALLEL_NUMBER).keys()].map(async (_, i) => {
        const account = new Account(workingAccount.connection, workingAccount.accountId);
        // NOTE: Need to have different transactions outside of nonce, or they all succeed by being identical
        // TODO: Check if randomization of exponential back off helps to do more transactions without exceeding retries
        await account.sendMoney(account.accountId, new BN(i));
    }));
});

test('findAccessKey returns the same access key when fetched simultaneously', async() => {
    const account = await testUtils.createAccount(nearjs);

    const [key1, key2] = await Promise.all([
        account.findAccessKey(),
        account.findAccessKey()
    ]);

    expect(key1.accessKey).toBe(key2.accessKey);
});

describe('errors', () => {
    let oldLog;
    let logs;

    beforeEach(async () => {
        oldLog = console.log;
        logs = [];
        console.log = function () {
            logs.push(Array.from(arguments).join(' '));
        };
    });

    afterEach(async () => {
        console.log = oldLog;
    });

    test('create existing account', async() => {
        await expect(workingAccount.createAccount(workingAccount.accountId, '9AhWenZ3JddamBoyMqnTbp7yVbRuvqAv3zwfrWgfVRJE', 100))
            .rejects.toThrow(/Can't create a new account .+, because it already exists/);
    });
});

describe('with deploy contract', () => {
    let oldLog;
    let logs;
    let contractId = testUtils.generateUniqueString('test_contract');
    let contract;

    beforeAll(async () => {
        const newPublicKey = await nearjs.connection.signer.createKey(contractId, testUtils.networkId);
        const data = [...fs.readFileSync(HELLO_WASM_PATH)];
        await workingAccount.createAndDeployContract(contractId, newPublicKey, data, HELLO_WASM_BALANCE);
        contract = new Contract(workingAccount, contractId, {
            viewMethods: ['hello', 'getValue', 'returnHiWithLogs'],
            changeMethods: ['setValue', 'generateLogs', 'triggerAssert', 'testSetRemove', 'crossContract']
        });
    });

    beforeEach(async () => {
        oldLog = console.log;
        logs = [];
        console.log = function () {
            logs.push(Array.from(arguments).join(' '));
        };
    });

    afterEach(async () => {
        console.log = oldLog;
    });

    test('cross-contact assertion and panic', async () => {
        await expect(contract.crossContract({
            args: {},
            gas: 300000000000000
        })).rejects.toThrow(/Smart contract panicked: expected to fail./);
        expect(logs.length).toEqual(7);
        expect(logs[0]).toMatch(new RegExp('^Receipts: \\w+, \\w+, \\w+$'));
        //  Log [test_contract1591458385248117]: test_contract1591458385248117
        expect(logs[1]).toMatch(new RegExp(`^\\s+Log \\[${contractId}\\]: ${contractId}$`));
        expect(logs[2]).toMatch(new RegExp('^Receipt: \\w+$'));
        //   Log [test_contract1591459677449181]: log before planned panic
        expect(logs[3]).toMatch(new RegExp(`^\\s+Log \\[${contractId}\\]: log before planned panic$`));
        expect(logs[4]).toMatch(new RegExp('^Receipt: \\w+$'));
        expect(logs[5]).toMatch(new RegExp(`^\\s+Log \\[${contractId}\\]: log before assert$`));
        expect(logs[6]).toMatch(new RegExp(`^\\s+Log \\[${contractId}\\]: ABORT: expected to fail, filename: \\"assembly/index.ts" line: \\d+ col: \\d+$`));
    });

    test('make function calls via account', async() => {
        const result = await workingAccount.viewFunction(
            contractId,
            'hello', // this is the function defined in hello.wasm file that we are calling
            {name: 'trex'});
        expect(result).toEqual('hello trex');

        const setCallValue = testUtils.generateUniqueString('setCallPrefix');
        const result2 = await workingAccount.functionCall({
            contractId,
            methodName: 'setValue',
            args: { value: setCallValue }
        });
        expect(providers.getTransactionLastResult(result2)).toEqual(setCallValue);
        expect(await workingAccount.viewFunction(contractId, 'getValue', {})).toEqual(setCallValue);
    });

    test('view contract state', async() => {
        const setCallValue = testUtils.generateUniqueString('setCallPrefix');
        await workingAccount.functionCall({
            contractId,
            methodName: 'setValue',
            args: { value: setCallValue }
        });

        const contractAccount = await nearjs.account(contractId);
        const state = (await contractAccount.viewState('')).map(({ key, value }) => [key.toString('utf-8'), value.toString('utf-8')]);
        expect(state).toEqual([['name', setCallValue]]);
    });

    test('make function calls via account with custom parser', async() => {
        const result = await workingAccount.viewFunction(
            contractId,
            'hello', // this is the function defined in hello.wasm file that we are calling
            {name: 'trex'},
            { parse: x => JSON.parse(x.toString()).replace('trex', 'friend') }
        );
        expect(result).toEqual('hello friend');
    });

    test('make function calls via contract', async() => {
        const result = await contract.hello({ name: 'trex' });
        expect(result).toEqual('hello trex');

        const setCallValue = testUtils.generateUniqueString('setCallPrefix');
        const result2 = await contract.setValue({ args: { value: setCallValue } });
        expect(result2).toEqual(setCallValue);
        expect(await contract.getValue()).toEqual(setCallValue);
    });

    test('make function calls via contract with gas', async() => {
        const setCallValue = testUtils.generateUniqueString('setCallPrefix');
        const result2 = await contract.setValue({
            args: { value: setCallValue },
            gas: 1000000 * 1000000
        });
        expect(result2).toEqual(setCallValue);
        expect(await contract.getValue()).toEqual(setCallValue);
    });

    test('can get logs from method result', async () => {
        await contract.generateLogs();
        expect(logs.length).toEqual(3);
        expect(logs[0].substr(0, 8)).toEqual('Receipt:');
        expect(logs.slice(1)).toEqual([`\tLog [${contractId}]: log1`, `\tLog [${contractId}]: log2`]);
    });

    test('can get logs from view call', async () => {
        let result = await contract.returnHiWithLogs();
        expect(result).toEqual('Hi');
        expect(logs).toEqual([`Log [${contractId}]: loooog1`, `Log [${contractId}]: loooog2`]);
    });

    test('can get assert message from method result', async () => {
        await expect(contract.triggerAssert()).rejects.toThrow(/Smart contract panicked: expected to fail.+/);
        expect(logs[1]).toEqual(`\tLog [${contractId}]: log before assert`);
        expect(logs[2]).toMatch(new RegExp(`^\\s+Log \\[${contractId}\\]: ABORT: expected to fail, filename: \\"assembly/index.ts" line: \\d+ col: \\d+$`));
    });

    test('test set/remove', async () => {
        await contract.testSetRemove({
            args: { value: '123' }
        });
    });

    test('can have view methods only', async () => {
        const contract = new Contract(workingAccount, contractId, {
            viewMethods: ['hello'],
        });
        expect(await contract.hello({ name: 'world' })).toEqual('hello world');
    });

    test('can have change methods only', async () => {
        const contract = new Contract(workingAccount, contractId, {
            changeMethods: ['hello'],
        });
        expect(await contract.hello({
            args: { name: 'world' }
        })).toEqual('hello world');
    });
});

'''
'''--- test/account_multisig.test.js ---
/* global BigInt */
const nearApi = require('../src/index');
const fs = require('fs');
const BN = require('bn.js');
const testUtils  = require('./test-utils');
const semver = require('semver');

let nearjs;
let startFromVersion;

const {
    KeyPair,
    transactions: { functionCall },
    InMemorySigner,
    multisig: { Account2FA, MULTISIG_GAS, MULTISIG_DEPOSIT },
    utils: { format: { parseNearAmount } }
} = nearApi;

jasmine.DEFAULT_TIMEOUT_INTERVAL = 50000;

const getAccount2FA = async (account, keyMapping = ({ public_key: publicKey }) => ({ publicKey, kind: 'phone' })) => {
    // modifiers to functions replaces contract helper (CH)
    const { accountId } = account;
    const keys = await account.getAccessKeys();
    const account2fa = new Account2FA(nearjs.connection, accountId, {
        // skip this (not using CH)
        getCode: () => {},
        sendCode: () => {},
        // auto accept "code"
        verifyCode: () => ({  }), // TODO: Is there any content needed in result?
        onAddRequestResult: async () => {
            const { requestId } = account2fa.getRequest();
            // set confirmKey as signer
            const originalSigner = nearjs.connection.signer;
            nearjs.connection.signer = await InMemorySigner.fromKeyPair(nearjs.connection.networkId, accountId, account2fa.confirmKey);
            // 2nd confirmation signing with confirmKey from Account instance
            await account.signAndSendTransaction({
                receiverId: accountId,
                actions: [
                    functionCall('confirm', { request_id: requestId }, MULTISIG_GAS, MULTISIG_DEPOSIT)
                ]
            });
            nearjs.connection.signer = originalSigner;
        }
    });
    account2fa.confirmKey = KeyPair.fromRandom('ed25519');
    account2fa.postSignedJson = () => ({ publicKey: account2fa.confirmKey.getPublicKey() });
    account2fa.getRecoveryMethods = () => ({
        data: keys.map(keyMapping)
    });
    await account2fa.deployMultisig([...fs.readFileSync('./test/data/multisig.wasm')]);
    return account2fa;
};

beforeAll(async () => {
    nearjs = await testUtils.setUpTestConnection();
    let nodeStatus = await nearjs.connection.provider.status();
    startFromVersion = (version) => semver.gte(nodeStatus.version.version, version);
    console.log(startFromVersion);
});

describe('deployMultisig key rotations', () => {

    test('full access key if recovery method is "ledger" or "phrase", limited access key if "phone"', async () => {
        const account = await testUtils.createAccount(nearjs);
        await account.addKey(KeyPair.fromRandom('ed25519').getPublicKey());
        await account.addKey(KeyPair.fromRandom('ed25519').getPublicKey());
        const keys = await account.getAccessKeys();
        const kinds = ['ledger', 'phrase', 'phone'];
        const account2fa = await getAccount2FA(
            account,
            ({ public_key: publicKey }, i) => ({ publicKey, kind: kinds[i] })
        );
        const currentKeys = await account2fa.getAccessKeys();
        expect(currentKeys.find(({ public_key }) => keys[0].public_key === public_key).access_key.permission).toEqual('FullAccess');
        expect(currentKeys.find(({ public_key }) => keys[1].public_key === public_key).access_key.permission).toEqual('FullAccess');
        expect(currentKeys.find(({ public_key }) => keys[2].public_key === public_key).access_key.permission).not.toEqual('FullAccess');
    });
    
});

describe('account2fa transactions', () => {

    test('add app key before deployMultisig', async() => {
        let account = await testUtils.createAccount(nearjs);
        const appPublicKey = KeyPair.fromRandom('ed25519').getPublicKey();
        const appAccountId = 'foobar';
        const appMethodNames = ['some_app_stuff','some_more_app_stuff'];
        await account.addKey(appPublicKey.toString(), appAccountId, appMethodNames, new BN(parseNearAmount('0.25')));
        account = await getAccount2FA(account);
        const keys = await account.getAccessKeys();
        expect(keys.find(({ public_key }) => appPublicKey.toString() === public_key)
            .access_key.permission.FunctionCall.method_names).toEqual(appMethodNames);
        expect(keys.find(({ public_key }) => appPublicKey.toString() === public_key)
            .access_key.permission.FunctionCall.receiver_id).toEqual(appAccountId);
    });

    test('add app key', async() => {
        let account = await testUtils.createAccount(nearjs);
        account = await getAccount2FA(account);
        const appPublicKey = KeyPair.fromRandom('ed25519').getPublicKey();
        const appAccountId = 'foobar';
        const appMethodNames = ['some_app_stuff', 'some_more_app_stuff'];
        await account.addKey(appPublicKey.toString(), appAccountId, appMethodNames, new BN(parseNearAmount('0.25')));
        const keys = await account.getAccessKeys();
        expect(keys.find(({ public_key }) => appPublicKey.toString() === public_key)
            .access_key.permission.FunctionCall.method_names).toEqual(appMethodNames);
        expect(keys.find(({ public_key }) => appPublicKey.toString() === public_key)
            .access_key.permission.FunctionCall.receiver_id).toEqual(appAccountId);
    });

    test('send money', async() => {
        let sender = await testUtils.createAccount(nearjs);
        let receiver = await testUtils.createAccount(nearjs);
        sender = await getAccount2FA(sender);
        receiver = await getAccount2FA(receiver);
        const { amount: receiverAmount } = await receiver.state();
        await sender.sendMoney(receiver.accountId, new BN(parseNearAmount('1')));
        const state = await receiver.state();
        expect(BigInt(state.amount)).toBeGreaterThanOrEqual(BigInt(new BN(receiverAmount).add(new BN(parseNearAmount('0.9'))).toString()));
    });
    
});

'''
'''--- test/config.js ---
module.exports = function getConfig(env) {
    switch (env) {
    case 'production':
    case 'mainnet':
        return {
            networkId: 'mainnet',
            nodeUrl: 'https://rpc.mainnet.near.org',
            walletUrl: 'https://wallet.near.org',
            helperUrl: 'https://helper.mainnet.near.org',
        };
    case 'development':
    case 'testnet':
        return {
            networkId: 'default',
            nodeUrl: 'https://rpc.testnet.near.org',
            walletUrl: 'https://wallet.testnet.near.org',
            helperUrl: 'https://helper.testnet.near.org',
            masterAccount: 'test.near',
        };
    case 'betanet':
        return {
            networkId: 'betanet',
            nodeUrl: 'https://rpc.betanet.near.org',
            walletUrl: 'https://wallet.betanet.near.org',
            helperUrl: 'https://helper.betanet.near.org',
        };
    case 'local':
        return {
            networkId: 'local',
            nodeUrl: 'http://localhost:3030',
            keyPath: `${process.env.HOME}/.near/validator_key.json`,
            walletUrl: 'http://localhost:4000/wallet',
        };
    case 'test':
    case 'ci':
        return {
            networkId: 'shared-test',
            nodeUrl: 'https://rpc.ci-testnet.near.org',
            masterAccount: 'test.near',
        };
    case 'ci-betanet':
        return {
            networkId: 'shared-test-staging',
            nodeUrl: 'https://rpc.ci-betanet.near.org',
            masterAccount: 'test.near',
        };
    default:
        throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`);
    }
};

'''
'''--- test/contract.test.js ---
const { Contract } = require('../src/contract');
const { PositionalArgsError } = require('../src/utils/errors');

const account = {
    viewFunction(contractId, methodName, args, options) {
        return { this: this, contractId, methodName, args, options };
    },
    functionCall() {
        return this;
    }
};

const contract = new Contract(account, 'contractId', {
    viewMethods: ['viewMethod'],
    changeMethods: ['changeMethod'],
});

['viewMethod', 'changeMethod'].forEach(method => {
    describe(method, () => {
        test('returns what you expect for .name', () => {
            expect(contract[method].name).toBe(method);
        });

        test('maintains correct reference to `this` when passed around an application', async () => {
            function callFuncInNewContext(fn) {
                return fn();
            }
            expect(await callFuncInNewContext(contract[method]));
        });

        test('throws PositionalArgsError if first argument is not an object', async() => {
            await expect(contract[method](1)).rejects.toBeInstanceOf(PositionalArgsError);
            await expect(contract[method]('lol')).rejects.toBeInstanceOf(PositionalArgsError);
            await expect(contract[method]([])).rejects.toBeInstanceOf(PositionalArgsError);
            await expect(contract[method](new Date())).rejects.toBeInstanceOf(PositionalArgsError);
            await expect(contract[method](null)).rejects.toBeInstanceOf(PositionalArgsError);
            await expect(contract[method](new Set())).rejects.toBeInstanceOf(PositionalArgsError);
        });

        test('throws PositionalArgsError if given too many arguments', () => {
            return expect(contract[method]({}, 1, 0, 'oops')).rejects.toBeInstanceOf(PositionalArgsError);
        });

        test('allows args encoded as Uint8Array (for borsh)', async () => {
            expect(await contract[method](new Uint8Array()));
        });
    });
});

describe('viewMethod', () => {
    test('passes options through to account viewFunction', async () => {
        function customParser () {}
        const stubbedReturnValue = await contract.viewMethod({}, { parse: customParser });
        expect(stubbedReturnValue.options.parse).toBe(customParser);
    });

    describe.each([
        1,
        'lol',
        [],
        new Date(),
        null,
        new Set(),
    ])('throws PositionalArgsError if 2nd arg is not an object', badArg => {
        test(String(badArg), async () => {
            try {
                await contract.viewMethod({ a: 1 }, badArg);
                throw new Error(`Calling \`contract.viewMethod({ a: 1 }, ${badArg})\` worked. It shouldn't have worked.`);
            } catch (e) {
                if (!(e instanceof PositionalArgsError)) throw e;
            }
        });
    });
});

describe('changeMethod', () => {
    test('throws error message for invalid gas argument', () => {
        return expect(contract.changeMethod({ a: 1}, 'whatever')).rejects.toThrow(/Expected number, decimal string or BN for 'gas' argument, but got.+/);
    });

    test('gives error message for invalid amount argument', () => {
        return expect(contract.changeMethod({ a: 1}, 1000, 'whatever')).rejects.toThrow(/Expected number, decimal string or BN for 'amount' argument, but got.+/);
    });

    test('makes a functionCall and passes along walletCallbackUrl and walletMeta', async() => {
        account.functionCall = jest.fn(() => Promise.resolve(account));
        await contract.changeMethod({
            args: {},
            meta: 'someMeta',
            callbackUrl: 'http://neartest.test/somepath?and=query',
        });

        expect(account.functionCall).toHaveBeenCalledWith({
            args: {},
            contractId: 'contractId',
            methodName: 'changeMethod',
            walletMeta: 'someMeta',
            walletCallbackUrl: 'http://neartest.test/somepath?and=query'
        });
    });
});

'''
'''--- test/data/signed_transaction1.json ---
{
    "type": "SignedTransaction",
    "data": "09000000746573742e6e65617200917b3d268d4b58f7fec1b150bd68d69be3ee5d4cc39855e341538465bb77860d01000000000000000d00000077686174657665722e6e6561720fa473fd26901df296be6adc4cc4df34d040efa2435224b6986910e630c2fef601000000030100000000000000000000000000000000969a83332186ee9755e4839325525806e189a3d2d2bb4b4760e94443e97e1c4f22deeef0059a8e9713100eda6e19144da7e8a0ef7e539b20708ba1d8d021bd01"
}

'''
'''--- test/data/transaction1.json ---
{
    "type": "Transaction",
    "data": "0000000000795cb7b5f57222e742d1759092f0e20071a0cd2bf30e1f681d800e67935e168801000000000000001000000073747564696f2d76776375396534316d4def837b838543990f3380af8e2a3817ddf70fe9960135b2add25a679b2a01ed01000000020a0000006164644d6573736167650b0000007b2274657874223a22227d80841e000000000000000000000000000000000000000000"
}

'''
'''--- test/key_pair.test.js ---

const nearApi = require('../src/index');
const { sha256 } = require('js-sha256');

test('test sign and verify', async () => {
    const keyPair = new nearApi.utils.key_pair.KeyPairEd25519('26x56YPzPDro5t2smQfGcYAPy3j7R2jB2NUb7xKbAGK23B6x4WNQPh3twb6oDksFov5X8ts5CtntUNbpQpAKFdbR');
    expect(keyPair.publicKey.toString()).toEqual('ed25519:AYWv9RAN1hpSQA4p1DLhCNnpnNXwxhfH9qeHN8B4nJ59');
    const message = new Uint8Array(sha256.array('message'));
    const signature = keyPair.sign(message);
    expect(nearApi.utils.serialize.base_encode(signature.signature)).toEqual('26gFr4xth7W9K7HPWAxq3BLsua8oTy378mC1MYFiEXHBBpeBjP8WmJEJo8XTBowetvqbRshcQEtBUdwQcAqDyP8T');
});

test('test sign and verify with random', async () => {
    const keyPair = nearApi.utils.key_pair.KeyPairEd25519.fromRandom();
    const message = new Uint8Array(sha256.array('message'));
    const signature = keyPair.sign(message);
    expect(keyPair.verify(message, signature.signature)).toBeTruthy();
});

test('test sign and verify with public key', async () => {
    const keyPair = new nearApi.utils.key_pair.KeyPairEd25519('5JueXZhEEVqGVT5powZ5twyPP8wrap2K7RdAYGGdjBwiBdd7Hh6aQxMP1u3Ma9Yanq1nEv32EW7u8kUJsZ6f315C');
    const message = new Uint8Array(sha256.array('message'));
    const signature = keyPair.sign(message);
    const publicKey = nearApi.utils.key_pair.PublicKey.from('ed25519:EWrekY1deMND7N3Q7Dixxj12wD7AVjFRt2H9q21QHUSW');
    expect(publicKey.verify(message, signature.signature)).toBeTruthy();
});

test('test from secret', async () => {
    const keyPair = new nearApi.utils.key_pair.KeyPairEd25519('5JueXZhEEVqGVT5powZ5twyPP8wrap2K7RdAYGGdjBwiBdd7Hh6aQxMP1u3Ma9Yanq1nEv32EW7u8kUJsZ6f315C');
    expect(keyPair.publicKey.toString()).toEqual('ed25519:EWrekY1deMND7N3Q7Dixxj12wD7AVjFRt2H9q21QHUSW');
});

test('convert to string', async () => {
    const keyPair = nearApi.utils.key_pair.KeyPairEd25519.fromRandom();
    const newKeyPair = nearApi.utils.key_pair.KeyPair.fromString(keyPair.toString());
    expect(newKeyPair.secretKey).toEqual(keyPair.secretKey);

    const keyString = 'ed25519:2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw';
    const keyPair2 = nearApi.utils.key_pair.KeyPair.fromString(keyString);
    expect(keyPair2.toString()).toEqual(keyString);
});

'''
'''--- test/key_stores/browser_keystore.test.js ---
const nearApi = require('../../src/index');

const BrowserLocalStorageKeyStore = nearApi.keyStores.BrowserLocalStorageKeyStore;

describe('Browser keystore', () => {
    let ctx = {};

    beforeAll(async () => {
        ctx.keyStore = new BrowserLocalStorageKeyStore(require('localstorage-memory'));
    });

    require('./keystore_common').shouldStoreAndRetriveKeys(ctx);
});

'''
'''--- test/key_stores/in_memory_keystore.test.js ---
const nearApi = require('../../src/index');

const InMemoryKeyStore = nearApi.keyStores.InMemoryKeyStore;

describe('In-memory keystore', () => {
    let ctx = {};

    beforeAll(async () => {
        ctx.keyStore = new InMemoryKeyStore();
    });

    require('./keystore_common').shouldStoreAndRetriveKeys(ctx);
});

'''
'''--- test/key_stores/keystore_common.js ---

const nearApi = require('../../src/index');

const KeyPair = nearApi.utils.KeyPairEd25519;

const NETWORK_ID_SINGLE_KEY = 'singlekeynetworkid';
const ACCOUNT_ID_SINGLE_KEY = 'singlekey_accountid';
const KEYPAIR_SINGLE_KEY = new KeyPair('2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw');

module.exports.shouldStoreAndRetriveKeys = ctx => {
    beforeEach(async () => {
        await ctx.keyStore.clear();
        await ctx.keyStore.setKey(NETWORK_ID_SINGLE_KEY, ACCOUNT_ID_SINGLE_KEY, KEYPAIR_SINGLE_KEY);
    });

    test('Get all keys with empty network returns empty list', async () => {
        const emptyList = await ctx.keyStore.getAccounts('emptynetwork');
        expect(emptyList).toEqual([]);
    });  
    
    test('Get all keys with single key in keystore', async () => {
        const accountIds = await ctx.keyStore.getAccounts(NETWORK_ID_SINGLE_KEY);
        expect(accountIds).toEqual([ACCOUNT_ID_SINGLE_KEY]);
    });

    test('Get not-existing account', async () => {
        expect(await ctx.keyStore.getKey('somenetwork', 'someaccount')).toBeNull();
    });

    test('Get account id from a network with single key', async () => {
        const key = await ctx.keyStore.getKey(NETWORK_ID_SINGLE_KEY, ACCOUNT_ID_SINGLE_KEY);
        expect(key).toEqual(KEYPAIR_SINGLE_KEY);
    });

    test('Get networks', async () => {
        const networks = await ctx.keyStore.getNetworks();
        expect(networks).toEqual([NETWORK_ID_SINGLE_KEY]);
    });

    test('Add two keys to network and retrieve them', async () => {
        const networkId = 'twoKeyNetwork';
        const accountId1 = 'acc1';
        const accountId2 = 'acc2';
        const key1Expected = KeyPair.fromRandom();
        const key2Expected = KeyPair.fromRandom();
        await ctx.keyStore.setKey(networkId, accountId1, key1Expected);
        await ctx.keyStore.setKey(networkId, accountId2, key2Expected);
        const key1 = await ctx.keyStore.getKey(networkId, accountId1);
        const key2 = await ctx.keyStore.getKey(networkId, accountId2);
        expect(key1).toEqual(key1Expected);
        expect(key2).toEqual(key2Expected);
        const accountIds = await ctx.keyStore.getAccounts(networkId);
        expect(accountIds).toEqual([accountId1, accountId2]);
        const networks = await ctx.keyStore.getNetworks();
        expect(networks).toEqual([NETWORK_ID_SINGLE_KEY, networkId]);
    });
};

'''
'''--- test/key_stores/merge_keystore.test.js ---
const nearApi = require('../../src/index');

const KeyPair = nearApi.utils.KeyPairEd25519;

const MergeKeyStore = nearApi.keyStores.MergeKeyStore;
const InMemoryKeyStore = nearApi.keyStores.InMemoryKeyStore;

describe('Merge keystore', () => {
    let ctx = {};

    beforeAll(async () => {
        ctx.stores = [new InMemoryKeyStore(), new InMemoryKeyStore()];
        ctx.keyStore = new MergeKeyStore(ctx.stores);
    });

    it('looks up key from fallback key store if needed', async () => {
        const key1 = KeyPair.fromRandom();
        await ctx.stores[1].setKey('network', 'account', key1);
        expect(await ctx.keyStore.getKey('network', 'account')).toEqual(key1);
    });

    it('looks up key in proper order', async () => {
        const key1 = KeyPair.fromRandom();
        const key2 = KeyPair.fromRandom();
        await ctx.stores[0].setKey('network', 'account', key1);
        await ctx.stores[1].setKey('network', 'account', key2);
        expect(await ctx.keyStore.getKey('network', 'account')).toEqual(key1);
    });

    it('sets keys only in first key store', async () => {
        const key1 = KeyPair.fromRandom();
        await ctx.keyStore.setKey('network', 'account', key1);
        expect(await ctx.stores[0].getAccounts('network')).toHaveLength(1);
        expect(await ctx.stores[1].getAccounts('network')).toHaveLength(0);
    });

    require('./keystore_common').shouldStoreAndRetriveKeys(ctx);
});

'''
'''--- test/key_stores/unencrypted_file_system_keystore.test.js ---

const rimraf  = require('util').promisify(require('rimraf'));

const nearApi = require('../../src/index');
const UnencryptedFileSystemKeyStore = nearApi.keyStores.UnencryptedFileSystemKeyStore;
const KeyPair = nearApi.utils.KeyPairEd25519;
const { ensureDir } = require('../test-utils');
const fs = require('fs');
const path = require('path');

const KEYSTORE_PATH = '../test-keys';

describe('Unencrypted file system keystore', () => {
    let ctx = {};

    beforeAll(async () => {
        await rimraf(KEYSTORE_PATH);
        await ensureDir(KEYSTORE_PATH);
        ctx.keyStore = new UnencryptedFileSystemKeyStore(KEYSTORE_PATH);
    });

    require('./keystore_common').shouldStoreAndRetriveKeys(ctx);

    it('test path resolve', async() => {
        expect(ctx.keyStore.keyDir).toEqual(path.join(process.cwd(), KEYSTORE_PATH));
    });

    it('test public key exists', async () => {
        const key1 = KeyPair.fromRandom();
        await ctx.keyStore.setKey('network', 'account', key1);
        const keyFilePath = ctx.keyStore.getKeyFilePath('network', 'account');
        const content = fs.readFileSync(keyFilePath);
        const accountInfo = JSON.parse(content.toString());
        expect(accountInfo.public_key).toEqual(key1.getPublicKey().toString());
    });
});

'''
'''--- test/promise.test.js ---
const BN = require('bn.js');
const testUtils = require('./test-utils');

let nearjs;
let workingAccount;

jasmine.DEFAULT_TIMEOUT_INTERVAL = 120000;

const CONTRACT_CALL_GAS = new BN(300000000000000);

beforeAll(async () => {
    nearjs = await testUtils.setUpTestConnection();
    workingAccount = await testUtils.createAccount(nearjs);
});

describe('with promises', () => {
    let contract, contract1, contract2;
    let oldLog;
    let logs;
    let contractName = testUtils.generateUniqueString('cnt');
    let contractName1 = testUtils.generateUniqueString('cnt');
    let contractName2 = testUtils.generateUniqueString('cnt');

    beforeAll(async () => {
        contract = await testUtils.deployContract(workingAccount, contractName);
        contract1 = await testUtils.deployContract(workingAccount, contractName1);
        contract2 = await testUtils.deployContract(workingAccount, contractName2);
    });

    beforeEach(async () => {
        oldLog = console.log;
        logs = [];
        console.log = function() {
            logs.push(Array.from(arguments).join(' '));
        };
    });

    afterEach(async () => {
        console.log = oldLog;
    });

    // -> means async call
    // => means callback

    test('single promise, no callback (A->B)', async () => {
        const realResult = await contract.callPromise({
            args: {
                args: {
                    receiver: contractName1,
                    methodName: 'callbackWithName',
                    args: null,
                    gas: '3000000000000',
                    balance: '0',
                    callback: null,
                    callbackArgs: null,
                    callbackBalance: '0',
                    callbackGas: '0',
                }
            },
            gas: CONTRACT_CALL_GAS
        });
        const lastResult = await contract1.getLastResult();
        expect(lastResult).toEqual({
            rs: [],
            n: contractName1,
        });
        expect(realResult).toEqual(lastResult);
    });

    test('single promise with callback (A->B=>A)', async () => {
        const realResult = await contract.callPromise({
            args: {
                args: {
                    receiver: contractName1,
                    methodName: 'callbackWithName',
                    args: null,
                    gas: '3000000000000',
                    balance: '0',
                    callback: 'callbackWithName',
                    callbackArgs: null,
                    callbackBalance: '0',
                    callbackGas: '2000000000000', 
                }
            },
            gas: CONTRACT_CALL_GAS
        });
        const lastResult1 = await contract1.getLastResult();
        expect(lastResult1).toEqual({
            rs: [],
            n: contractName1,
        });
        const lastResult = await contract.getLastResult();
        expect(lastResult).toEqual({
            rs: [{
                ok: true,
                r: lastResult1,
            }],
            n: contractName,
        });
        expect(realResult).toEqual(lastResult);
    });

    test('two promises, no callbacks (A->B->C)', async () => {
        const realResult = await contract.callPromise({
            args: {
                args: {
                    receiver: contractName1,
                    methodName: 'callPromise',
                    args: {
                        receiver: contractName2,
                        methodName: 'callbackWithName',
                        args: null,
                        gas: '40000000000000',
                        balance: '0',
                        callback: null,
                        callbackArgs: null,
                        callbackBalance: '0',
                        callbackGas: '20000000000000',
                    },
                    gas: '60000000000000',
                    balance: '0',
                    callback: null,
                    callbackArgs: null,
                    callbackBalance: '0',
                    callbackGas: '60000000000000',
                }
            },
            gas: CONTRACT_CALL_GAS
        });
        const lastResult2 = await contract2.getLastResult();
        expect(lastResult2).toEqual({
            rs: [],
            n: contractName2,
        });
        expect(realResult).toEqual(lastResult2);
    });

    test('two promises, with two callbacks (A->B->C=>B=>A)', async () => {
        const realResult = await contract.callPromise({
            args: {
                args: {
                    receiver: contractName1,
                    methodName: 'callPromise',
                    args: {
                        receiver: contractName2,
                        methodName: 'callbackWithName',
                        args: null,
                        gas: '40000000000000',
                        balance: '0',
                        callback: 'callbackWithName',
                        callbackArgs: null,
                        callbackBalance: '0',
                        callbackGas: '20000000000000',
                    },
                    gas: '100000000000000',
                    balance: '0',
                    callback: 'callbackWithName',
                    callbackArgs: null,
                    callbackBalance: '0',
                    callbackGas: '30000000000000',
                }
            },
            gas: CONTRACT_CALL_GAS
        });
        const lastResult2 = await contract2.getLastResult();
        expect(lastResult2).toEqual({
            rs: [],
            n: contractName2,
        });
        const lastResult1 = await contract1.getLastResult();
        expect(lastResult1).toEqual({
            rs: [{
                ok: true,
                r: lastResult2,
            }],
            n: contractName1,
        });
        const lastResult = await contract.getLastResult();
        expect(lastResult).toEqual({
            rs: [{
                ok: true,
                r: lastResult1,
            }],
            n: contractName,
        });
        expect(realResult).toEqual(lastResult);
    });

    test('cross contract call with callbacks (A->B->A=>B=>A)', async () => {
        const realResult = await contract.callPromise({
            args: {
                args: {
                    receiver: contractName1,
                    methodName: 'callPromise',
                    args: {
                        receiver: contractName,
                        methodName: 'callbackWithName',
                        args: null,
                        gas: '40000000000000',
                        balance: '0',
                        callback: 'callbackWithName',
                        callbackArgs: null,
                        callbackBalance: '0',
                        callbackGas: '40000000000000',
                    },
                    gas: '100000000000000',
                    balance: '0',
                    callback: 'callbackWithName',
                    callbackArgs: null,
                    callbackBalance: '0',
                    callbackGas: '30000000000000',
                }
            },
            gas: CONTRACT_CALL_GAS
        });
        const lastResult1 = await contract1.getLastResult();
        expect(lastResult1).toEqual({
            rs: [{
                ok: true,
                r: {
                    rs: [],
                    n: contractName,
                },
            }],
            n: contractName1,
        });
        const lastResult = await contract.getLastResult();
        expect(lastResult).toEqual({
            rs: [{
                ok: true,
                r: lastResult1,
            }],
            n: contractName,
        });
        expect(realResult).toEqual(lastResult);
    });

    test('2 promises with 1 skipped callbacks (A->B->C=>A)', async () => {
        const realResult = await contract.callPromise({
            args: {
                args: {
                    receiver: contractName1,
                    methodName: 'callPromise',
                    args: {
                        receiver: contractName2,
                        methodName: 'callbackWithName',
                        args: null,
                        gas: '20000000000000',
                        balance: '0',
                        callback: null,
                        callbackArgs: null,
                        callbackBalance: '0',
                        callbackGas: '20000000000000',
                    },
                    gas: '50000000000000',
                    balance: '0',
                    callback: 'callbackWithName',
                    callbackArgs: null,
                    callbackBalance: '0',
                    callbackGas: '30000000000000'
                }
            },
            gas: CONTRACT_CALL_GAS
        });
        const lastResult2 = await contract2.getLastResult();
        expect(lastResult2).toEqual({
            rs: [],
            n: contractName2,
        });
        const lastResult = await contract.getLastResult();
        expect(lastResult).toEqual({
            rs: [{
                ok: true,
                r: lastResult2,
            }],
            n: contractName,
        });
        expect(realResult).toEqual(lastResult);
    });

    test('two promises, with one callbacks to B only (A->B->C=>B)', async () => {
        const realResult = await contract.callPromise({
            args: {
                args: {
                    receiver: contractName1,
                    methodName: 'callPromise',
                    args: {
                        receiver: contractName2,
                        methodName: 'callbackWithName',
                        args: null,
                        gas: '40000000000000',
                        balance: '0',
                        callback: 'callbackWithName',
                        callbackArgs: null,
                        callbackBalance: '0',
                        callbackGas: '40000000000000',
                    },
                    gas: '100000000000000',
                    balance: '0',
                    callback: null,
                    callbackArgs: null,
                    callbackBalance: '0',
                    callbackGas: '0',
                }
            },
            gas: CONTRACT_CALL_GAS
        });
        const lastResult2 = await contract2.getLastResult();
        expect(lastResult2).toEqual({
            rs: [],
            n: contractName2,
        });
        const lastResult1 = await contract1.getLastResult();
        expect(lastResult1).toEqual({
            rs: [{
                ok: true,
                r: lastResult2,
            }],
            n: contractName1,
        });
        expect(realResult).toEqual(lastResult1);
    });

});

'''
'''--- test/providers.test.js ---
const nearApi = require('../src/index');
const testUtils  = require('./test-utils');
const BN = require('bn.js');
const base58 = require('bs58');

jest.setTimeout(20000);

const withProvider = (fn) => {
    const config = Object.assign(require('./config')(process.env.NODE_ENV || 'test'));
    const provider = new nearApi.providers.JsonRpcProvider(config.nodeUrl);
    return () => fn(provider);
};

test('json rpc fetch node status', withProvider(async (provider) => {
    let response = await provider.status();
    expect(response.chain_id).toBeTruthy();
}));

test('json rpc fetch block info', withProvider(async (provider) => {
    let stat = await provider.status();
    let height = stat.sync_info.latest_block_height - 1;
    let response = await provider.block({ blockId: height });
    expect(response.header.height).toEqual(height);

    let sameBlock = await provider.block({ blockId: response.header.hash });
    expect(sameBlock.header.height).toEqual(height);

    let optimisticBlock = await provider.block({ finality: 'optimistic' });
    expect(optimisticBlock.header.height - height).toBeLessThan(5);

    let nearFinalBlock = await provider.block({ finality: 'near-final' });
    expect(nearFinalBlock.header.height - height).toBeLessThan(5);

    let finalBlock = await provider.block({ finality: 'final' });
    expect(finalBlock.header.height - height).toBeLessThan(5);

    let deprecatedStyle = await provider.block(height);
    expect(deprecatedStyle.header.height).toEqual(height);
}));

test('json rpc fetch block changes', withProvider(async (provider) => {
    let stat = await provider.status();
    let height = stat.sync_info.latest_block_height - 1;
    let response = await provider.blockChanges({ blockId: height });

    expect(response).toMatchObject({
        block_hash: expect.any(String),
        changes: expect.any(Array)
    });
}));

test('json rpc fetch chunk info', withProvider(async (provider) => {
    let stat = await provider.status();
    let height = stat.sync_info.latest_block_height - 1;
    let response = await provider.chunk([height, 0]);
    expect(response.header.shard_id).toEqual(0);
    let sameChunk = await provider.chunk(response.header.chunk_hash);
    expect(sameChunk.header.chunk_hash).toEqual(response.header.chunk_hash);
    expect(sameChunk.header.shard_id).toEqual(0);
}));

test('json rpc fetch validators info', withProvider(async (provider) => {
    let validators = await provider.validators(null);
    expect(validators.current_validators.length).toBeGreaterThanOrEqual(1);
}));

test('txStatus with string hash and buffer hash', withProvider(async(provider) => {
    const near = await testUtils.setUpTestConnection();
    const sender = await testUtils.createAccount(near);
    const receiver = await testUtils.createAccount(near);
    const outcome = await sender.sendMoney(receiver.accountId, new BN('1'));

    const responseWithString = await provider.txStatus(outcome.transaction.hash, sender.accountId);
    const responseWithUint8Array = await provider.txStatus(base58.decode(outcome.transaction.hash), sender.accountId);
    expect(responseWithString).toMatchObject(outcome);
    expect(responseWithUint8Array).toMatchObject(outcome);
}));

test('json rpc query with block_id', withProvider(async(provider) => {
    const stat = await provider.status();
    let block_id = stat.sync_info.latest_block_height - 1;

    const response = await provider.query({
        block_id,
        request_type: 'view_account',
        account_id: 'test.near'
    });

    expect(response).toEqual({
        block_height: expect.any(Number),
        block_hash: expect.any(String),
        amount: expect.any(String),
        locked: expect.any(String),
        code_hash: '11111111111111111111111111111111',
        storage_usage: 182,
        storage_paid_at: 0,
    });
}));

test('json rpc query account', withProvider(async (provider) => {
    const near = await testUtils.setUpTestConnection();
    const account = await testUtils.createAccount(near);
    let response = await provider.query(`account/${account.accountId}`, '');
    expect(response.code_hash).toEqual('11111111111111111111111111111111');
}));

test('json rpc query view_state', withProvider(async (provider) => {
    const near = await testUtils.setUpTestConnection();
    const account = await testUtils.createAccount(near);
    const contract = await testUtils.deployContract(account, testUtils.generateUniqueString('test'));

    await contract.setValue({ args: { value: 'hello' } });

    return testUtils.waitFor(async() => {
        const response = await provider.query({
            request_type: 'view_state',
            finality: 'final',
            account_id: contract.contractId,
            prefix_base64: ''
        });
        expect(response).toEqual({
            block_height: expect.any(Number),
            block_hash: expect.any(String),
            values: [
                { key: 'bmFtZQ==', value: 'aGVsbG8=', proof: [] }
            ],
            proof: []
        });
    });
}));

test('json rpc query view_account', withProvider(async (provider) => {
    const response = await provider.query({
        request_type: 'view_account',
        finality: 'final',
        account_id: 'test.near'
    });

    expect(response).toEqual({
        block_height: expect.any(Number),
        block_hash: expect.any(String),
        amount: expect.any(String),
        locked: expect.any(String),
        code_hash: '11111111111111111111111111111111',
        storage_usage: 182,
        storage_paid_at: 0,
    });
}));

test('json rpc query view_code', withProvider(async (provider) => {
    const near = await testUtils.setUpTestConnection();
    const account = await testUtils.createAccount(near);
    const contract = await testUtils.deployContract(account, testUtils.generateUniqueString('test'));

    return testUtils.waitFor(async() => {
        const response = await provider.query({
            request_type: 'view_code',
            finality: 'final',
            account_id: contract.contractId
        });

        expect(response).toEqual({
            block_height: expect.any(Number),
            block_hash: expect.any(String),
            code_base64: expect.any(String),
            hash: expect.any(String)
        });
    });
}));

test('json rpc query call_function', withProvider(async (provider) => {
    const near = await testUtils.setUpTestConnection();
    const account = await testUtils.createAccount(near);
    const contract = await testUtils.deployContract(account, testUtils.generateUniqueString('test'));

    await contract.setValue({ args: { value: 'hello' } });

    return testUtils.waitFor(async() => {
        const response = await provider.query({
            request_type: 'call_function',
            finality: 'final',
            account_id: contract.contractId,
            method_name: 'getValue',
            args_base64: ''
        });
        expect(response).toEqual({
            block_height: expect.any(Number),
            block_hash: expect.any(String),
            logs: [],
            result: [
                34,
                104,
                101,
                108,
                108,
                111,
                34
            ]
        });
    });
}));

test('final tx result', async() => {
    const result = {
        status: { SuccessValue: 'e30=' },
        transaction: { id: '11111', outcome: { status: { SuccessReceiptId: '11112' }, logs: [], receipt_ids: ['11112'], gas_burnt: 1 } },
        receipts: [
            { id: '11112', outcome: { status: { SuccessValue: 'e30=' }, logs: [], receipt_ids: ['11112'], gas_burnt: 9001 } },
            { id: '11113', outcome: { status: { SuccessValue: '' }, logs: [], receipt_ids: [], gas_burnt: 0 } }
        ]
    };
    expect(nearApi.providers.getTransactionLastResult(result)).toEqual({});
});

test('final tx result with null', async() => {
    const result = {
        status: 'Failure',
        transaction: { id: '11111', outcome: { status: { SuccessReceiptId: '11112' }, logs: [], receipt_ids: ['11112'], gas_burnt: 1 } },
        receipts: [
            { id: '11112', outcome: { status: 'Failure', logs: [], receipt_ids: ['11112'], gas_burnt: 9001 } },
            { id: '11113', outcome: { status: { SuccessValue: '' }, logs: [], receipt_ids: [], gas_burnt: 0 } }
        ]
    };
    expect(nearApi.providers.getTransactionLastResult(result)).toEqual(null);
});

test('json rpc light client proof', async() => {
    const near = await testUtils.setUpTestConnection();
    const workingAccount = await testUtils.createAccount(near);
    const executionOutcome = await workingAccount.sendMoney(workingAccount.accountId, new BN(10000));
    const provider = near.connection.provider;

    async function waitForStatusMatching(isMatching) {
        const MAX_ATTEMPTS = 10;
        for (let i = 0; i < MAX_ATTEMPTS; i++) {
            await testUtils.sleep(500);
            const nodeStatus = await provider.status();
            if (isMatching(nodeStatus)) {
                return nodeStatus;
            }
        }
        throw new Error(`Exceeded ${MAX_ATTEMPTS} attempts waiting for matching node status.`);
    }

    const comittedStatus = await waitForStatusMatching(status =>
        status.sync_info.latest_block_hash !== executionOutcome.transaction_outcome.block_hash);
    const BLOCKS_UNTIL_FINAL = 2;
    const finalizedStatus = await waitForStatusMatching(status =>
        status.sync_info.latest_block_height > comittedStatus.sync_info.latest_block_height + BLOCKS_UNTIL_FINAL);

    const block = await provider.block({ blockId: finalizedStatus.sync_info.latest_block_hash });
    const lightClientHead = block.header.last_final_block;
    let lightClientRequest = {
        type: 'transaction',
        light_client_head: lightClientHead,
        transaction_hash: executionOutcome.transaction.hash,
        sender_id: workingAccount.accountId,
    };
    const lightClientProof = await provider.lightClientProof(lightClientRequest);
    expect('prev_block_hash' in lightClientProof.block_header_lite).toBe(true);
    expect('inner_rest_hash' in lightClientProof.block_header_lite).toBe(true);
    expect('inner_lite' in lightClientProof.block_header_lite).toBe(true);
    expect(lightClientProof.outcome_proof.id).toEqual(executionOutcome.transaction_outcome.id);
    expect('block_hash' in lightClientProof.outcome_proof).toBe(true);
    expect(lightClientProof.outcome_root_proof).toEqual([]);
    expect(lightClientProof.block_proof.length).toBeGreaterThan(0);

    // pass nonexistent hash for light client head will fail
    lightClientRequest = {
        type: 'transaction',
        light_client_head: '11111111111111111111111111111111',
        transaction_hash: executionOutcome.transaction.hash,
        sender_id: workingAccount.accountId,
    };
    await expect(provider.lightClientProof(lightClientRequest)).rejects.toThrow('DB Not Found Error');

    // Use old block hash as light client head should fail
    lightClientRequest = {
        type: 'transaction',
        light_client_head: executionOutcome.transaction_outcome.block_hash,
        transaction_hash: executionOutcome.transaction.hash,
        sender_id: workingAccount.accountId,
    };

    await expect(provider.lightClientProof(lightClientRequest)).rejects.toThrow(/.+ block .+ is ahead of head block .+/);
});

test('json rpc fetch genesis protocol config', withProvider(async (provider) => {
    const response = await provider.experimental_genesisConfig();
    expect('chain_id' in response).toBe(true);
    expect('genesis_height' in response).toBe(true);
    expect('runtime_config' in response).toBe(true);
    expect('storage_amount_per_byte' in response.runtime_config).toBe(true);
}));

test('json rpc fetch protocol config', withProvider(async (provider) => {
    const status = await provider.status();
    const blockHeight = status.sync_info.latest_block_height;
    const blockHash = status.sync_info.latest_block_hash;
    for (const blockReference of [{ sync_checkpoint: 'genesis' }, { block_id: blockHeight }, { block_id: blockHash }, { finality: 'final' }, { finality: 'optimistic' }]) {
        const response = await provider.experimental_protocolConfig(blockReference);
        expect('chain_id' in response).toBe(true);
        expect('genesis_height' in response).toBe(true);
        expect('runtime_config' in response).toBe(true);
        expect('storage_amount_per_byte' in response.runtime_config).toBe(true);
    }
}));

test('json rpc gas price', withProvider(async (provider) => {
    let status = await provider.status();
    let positiveIntegerRegex = /^[+]?\d+([.]\d+)?$/;

    let response1 = await provider.gasPrice(status.sync_info.latest_block_height);
    expect(response1.gas_price).toMatch(positiveIntegerRegex);

    let response2 = await provider.gasPrice(status.sync_info.latest_block_hash);
    expect(response2.gas_price).toMatch(positiveIntegerRegex);

    let response3 = await provider.gasPrice();
    expect(response3.gas_price).toMatch(positiveIntegerRegex);
}));

'''
'''--- test/serialize.test.js ---

const fs = require('fs');
const nearApi = require('../src/index');

class Test extends nearApi.utils.enums.Assignable {
}

test('serialize object', async () => {
    const value = new Test({ x: 255, y: 20, z: '123', q: [1, 2, 3]});
    const schema = new Map([[Test, {kind: 'struct', fields: [['x', 'u8'], ['y', 'u64'], ['z', 'string'], ['q', [3]]] }]]);
    let buf = nearApi.utils.serialize.serialize(schema, value);
    let new_value = nearApi.utils.serialize.deserialize(schema, Test, buf);
    expect(new_value.x).toEqual(255);
    expect(new_value.y.toString()).toEqual('20');
    expect(new_value.z).toEqual('123');
    expect(new_value.q).toEqual(new Uint8Array([1, 2, 3]));
});

test('serialize and sign multi-action tx', async() => {
    const keyStore = new nearApi.keyStores.InMemoryKeyStore();
    const keyPair = nearApi.utils.KeyPair.fromString('ed25519:2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw');
    await keyStore.setKey('test', 'test.near', keyPair);
    const publicKey = keyPair.publicKey;
    const actions = [
        nearApi.transactions.createAccount(),
        nearApi.transactions.deployContract(new Uint8Array([1, 2, 3])),
        nearApi.transactions.functionCall('qqq', new Uint8Array([1, 2, 3]), 1000, 1000000),
        nearApi.transactions.transfer(123),
        nearApi.transactions.stake(1000000, publicKey),
        nearApi.transactions.addKey(publicKey, nearApi.transactions.functionCallAccessKey('zzz', ['www'], null)),
        nearApi.transactions.deleteKey(publicKey),
        nearApi.transactions.deleteAccount('123')
    ];
    const blockHash = nearApi.utils.serialize.base_decode('244ZQ9cgj3CQ6bWBdytfrJMuMQ1jdXLFGnr4HhvtCTnM');
    let [hash, { transaction }] = await nearApi.transactions.signTransaction('123', 1, actions, blockHash, new nearApi.InMemorySigner(keyStore), 'test.near', 'test');
    expect(nearApi.utils.serialize.base_encode(hash)).toEqual('Fo3MJ9XzKjnKuDuQKhDAC6fra5H2UWawRejFSEpPNk3Y');
    const serialized = nearApi.utils.serialize.serialize(nearApi.transactions.SCHEMA, transaction);
    expect(serialized.toString('hex')).toEqual('09000000746573742e6e656172000f56a5f028dfc089ec7c39c1183b321b4d8f89ba5bec9e1762803cc2491f6ef80100000000000000030000003132330fa473fd26901df296be6adc4cc4df34d040efa2435224b6986910e630c2fef608000000000103000000010203020300000071717103000000010203e80300000000000040420f00000000000000000000000000037b0000000000000000000000000000000440420f00000000000000000000000000000f56a5f028dfc089ec7c39c1183b321b4d8f89ba5bec9e1762803cc2491f6ef805000f56a5f028dfc089ec7c39c1183b321b4d8f89ba5bec9e1762803cc2491f6ef800000000000000000000030000007a7a7a010000000300000077777706000f56a5f028dfc089ec7c39c1183b321b4d8f89ba5bec9e1762803cc2491f6ef80703000000313233');
});

function createTransferTx() {
    const actions = [
        nearApi.transactions.transfer(1),
    ];
    const blockHash = nearApi.utils.serialize.base_decode('244ZQ9cgj3CQ6bWBdytfrJMuMQ1jdXLFGnr4HhvtCTnM');
    return nearApi.transactions.createTransaction(
        'test.near',
        nearApi.utils.PublicKey.fromString('Anu7LYDfpLtkP7E16LT9imXF694BdQaa9ufVkQiwTQxC'),
        'whatever.near',
        1,
        actions,
        blockHash);
}

test('serialize transfer tx', async() => {
    const transaction = createTransferTx();

    const serialized = transaction.encode();
    expect(serialized.toString('hex')).toEqual('09000000746573742e6e65617200917b3d268d4b58f7fec1b150bd68d69be3ee5d4cc39855e341538465bb77860d01000000000000000d00000077686174657665722e6e6561720fa473fd26901df296be6adc4cc4df34d040efa2435224b6986910e630c2fef6010000000301000000000000000000000000000000');

    const deserialized = nearApi.transactions.Transaction.decode(serialized);
    expect(deserialized.encode()).toEqual(serialized);
});

async function createKeyStore() {
    const keyStore = new nearApi.keyStores.InMemoryKeyStore();
    const keyPair = nearApi.utils.KeyPair.fromString('ed25519:3hoMW1HvnRLSFCLZnvPzWeoGwtdHzke34B2cTHM8rhcbG3TbuLKtShTv3DvyejnXKXKBiV7YPkLeqUHN1ghnqpFv');
    await keyStore.setKey('test', 'test.near', keyPair);
    return keyStore;
}

async function verifySignedTransferTx(signedTx) {
    expect(Buffer.from(signedTx.signature.data).toString('base64')).toEqual('lpqDMyGG7pdV5IOTJVJYBuGJo9LSu0tHYOlEQ+l+HE8i3u7wBZqOlxMQDtpuGRRNp+ig735TmyBwi6HY0CG9AQ==');
    const serialized = signedTx.encode();
    expect(serialized.toString('hex')).toEqual('09000000746573742e6e65617200917b3d268d4b58f7fec1b150bd68d69be3ee5d4cc39855e341538465bb77860d01000000000000000d00000077686174657665722e6e6561720fa473fd26901df296be6adc4cc4df34d040efa2435224b6986910e630c2fef601000000030100000000000000000000000000000000969a83332186ee9755e4839325525806e189a3d2d2bb4b4760e94443e97e1c4f22deeef0059a8e9713100eda6e19144da7e8a0ef7e539b20708ba1d8d021bd01');
    
    const deserialized = nearApi.transactions.SignedTransaction.decode(serialized);
    expect(deserialized.encode()).toEqual(serialized);
}

test('serialize and sign transfer tx', async() => {
    const transaction = createTransferTx();
    const keyStore = await createKeyStore();

    let [, signedTx] = await nearApi.transactions.signTransaction(transaction.receiverId, transaction.nonce, transaction.actions, transaction.blockHash, new nearApi.InMemorySigner(keyStore), 'test.near', 'test');

    verifySignedTransferTx(signedTx);
});

test('serialize and sign transfer tx object', async() => {
    const transaction = createTransferTx();
    const keyStore = await createKeyStore();

    let [, signedTx] = await nearApi.transactions.signTransaction(transaction, new nearApi.InMemorySigner(keyStore), 'test.near', 'test');

    verifySignedTransferTx(signedTx);
});

describe('roundtrip test', () => {
    const dataDir = './test/data';
    const testFiles = fs.readdirSync(dataDir);
    for (const testFile of testFiles) {
        if (/.+\.json$/.test(testFile)) {
            const testDefinition = JSON.parse(fs.readFileSync(dataDir + '/'  + testFile));
            test(testFile, () => {
                const data = Buffer.from(testDefinition.data, 'hex');
                const type = Array.from(nearApi.transactions.SCHEMA.keys()).find(key => key.name === testDefinition.type);
                const deserialized = nearApi.utils.serialize.deserialize(nearApi.transactions.SCHEMA, type, data);
                const serialized = nearApi.utils.serialize.serialize(nearApi.transactions.SCHEMA, deserialized);
                expect(serialized).toEqual(data);
            });
        }
    }
});
'''
'''--- test/signer.test.js ---

const nearApi = require('../src/index');

test('test no key', async() => {
    const signer = new nearApi.InMemorySigner(new nearApi.keyStores.InMemoryKeyStore());
    await expect(signer.signMessage('message', 'user', 'network')).rejects.toThrow(/Key for user not found in network/);
});

'''
'''--- test/test-utils.js ---
const fs = require('fs').promises;
const BN = require('bn.js');

const nearApi = require('../src/index');

const networkId = 'unittest';

const HELLO_WASM_PATH = process.env.HELLO_WASM_PATH || 'node_modules/near-hello/dist/main.wasm';
const HELLO_WASM_BALANCE = new BN('10000000000000000000000000');
const HELLO_WASM_METHODS = {
    viewMethods: ['getValue', 'getLastResult'],
    changeMethods: ['setValue', 'callPromise']
};
const MULTISIG_WASM_PATH = process.env.MULTISIG_WASM_PATH || './test/wasm/multisig.wasm';
// Length of a random account. Set to 40 because in the protocol minimal allowed top-level account length should be at
// least 32.
const RANDOM_ACCOUNT_LENGTH = 40;

async function setUpTestConnection() {
    const keyStore = new nearApi.keyStores.InMemoryKeyStore();
    const config = Object.assign(require('./config')(process.env.NODE_ENV || 'test'), {
        networkId: networkId,
        deps: { keyStore },
    });

    if (config.masterAccount) {
        await keyStore.setKey(networkId, config.masterAccount, nearApi.utils.KeyPair.fromString('ed25519:2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw'));
    }

    return nearApi.connect(config);
}

// Generate some unique string of length at least RANDOM_ACCOUNT_LENGTH with a given prefix using the alice nonce.
function generateUniqueString(prefix) {
    let result = `${prefix}-${Date.now()}-${Math.round(Math.random() * 1000000)}`;
    let add_symbols = Math.max(RANDOM_ACCOUNT_LENGTH - result.length, 1);
    for (let i = add_symbols; i > 0; --i) result += '0';
    return result;
}

async function createAccount(near) {
    const newAccountName = generateUniqueString('test');
    const newPublicKey = await near.connection.signer.createKey(newAccountName, networkId);
    await near.createAccount(newAccountName, newPublicKey);
    const account = new nearApi.Account(near.connection, newAccountName);
    return account;
}

async function createAccountMultisig(near, options) {
    const newAccountName = generateUniqueString('test');
    const newPublicKey = await near.connection.signer.createKey(newAccountName, networkId);
    await near.createAccount(newAccountName, newPublicKey);
    // add a confirm key for multisig (contract helper sim)
    
    try {
        const confirmKeyPair = nearApi.utils.KeyPair.fromRandom('ed25519');
        const { publicKey } = confirmKeyPair;
        // const account = new nearApi.Account(near.connection, newAccountName);
        // await account.addKey(publicKey, account.accountId, nearApi.multisig.MULTISIG_CONFIRM_METHODS, '0')
        // create multisig account instance and deploy contract
        const accountMultisig = new nearApi.multisig.AccountMultisig(near.connection, newAccountName, options);
        accountMultisig.useConfirmKey = async () => {
            await near.connection.signer.setKey(networkId, options.masterAccount, confirmKeyPair);
        };
        accountMultisig.getRecoveryMethods = () => ({ data: [] });
        accountMultisig.postSignedJson = async (path) => {
            switch (path) {
            case '/2fa/getAccessKey': return { publicKey };
            }
        };
        await accountMultisig.deployMultisig(new Uint8Array([...(await fs.readFile(MULTISIG_WASM_PATH))]));
        return accountMultisig;
    } catch(e) {
        console.log(e);
    }
}

async function deployContract(workingAccount, contractId) {
    const newPublicKey = await workingAccount.connection.signer.createKey(contractId, networkId);
    const data = [...(await fs.readFile(HELLO_WASM_PATH))];
    await workingAccount.createAndDeployContract(contractId, newPublicKey, data, HELLO_WASM_BALANCE);
    return new nearApi.Contract(workingAccount, contractId, HELLO_WASM_METHODS);
}

function sleep(time) {
    return new Promise(function (resolve) {
        setTimeout(resolve, time);
    });
}

function waitFor(fn) {
    const _waitFor = async (count = 10) => {
        try {
            return await fn();
        } catch(e) {
            if(count > 0) {
                await sleep(500);
                return _waitFor(count - 1);
            }
            else throw e;
        }
    };

    return _waitFor();
}

async function ensureDir(dirpath) {
    try {
        await fs.mkdir(dirpath, { recursive: true });
    } catch (err) {
        if (err.code !== 'EEXIST') throw err;
    }
}

module.exports = {
    setUpTestConnection,
    networkId,
    generateUniqueString,
    createAccount,
    createAccountMultisig,
    deployContract,
    sleep,
    waitFor,
    ensureDir,
    HELLO_WASM_PATH,
    HELLO_WASM_BALANCE,
};

'''
'''--- test/transaction.test.js ---
const { functionCall } = require('../src/transaction');
const BN = require('bn.js');

test('functionCall with already serialized args', () => {
    const serializedArgs = Buffer.from('{}');
    const action = functionCall('methodName', serializedArgs, new BN(1), new BN(2));    
    expect(action).toMatchObject({ 
        functionCall: {
            methodName: 'methodName',
            args: serializedArgs,
            gas: new BN(1),
            deposit: new BN(2)
        }
    });
});

test('functionCall with non-serialized args', () => {
    const serializedArgs = Buffer.from('{}');
    const action = functionCall('methodName', {}, new BN(1), new BN(2));    
    expect(action).toMatchObject({ 
        functionCall: {
            methodName: 'methodName',
            args: serializedArgs,
            gas: new BN(1),
            deposit: new BN(2)
        }
    });
});
'''
'''--- test/utils/format.test.js ---
// Unit tests for simple util code

const nearApi = require('../../src/index');

jasmine.DEFAULT_TIMEOUT_INTERVAL = 50000;

test.each`
    balance                              | fracDigits   | expected
    ${'8999999999837087887'}             | ${undefined} | ${'0.000008999999999837087887'}
    ${'8099099999837087887'}             | ${undefined} | ${'0.000008099099999837087887'}
    ${'999998999999999837087887000'}     | ${undefined} | ${'999.998999999999837087887'}
    ${'1'+'0'.repeat(13)}                | ${undefined} | ${'0.00000000001'}
    ${'9999989999999998370878870000000'} | ${undefined} | ${'9,999,989.99999999837087887'}
    ${'000000000000000000000000'}        | ${undefined} | ${'0'}
    ${'1000000000000000000000000'}       | ${undefined} | ${'1'}
    ${'999999999999999999000000'}        | ${undefined} | ${'0.999999999999999999'}
    ${'999999999999999999000000'}        | ${10}        | ${'1'}
    ${'1003000000000000000000000'}       | ${3}         | ${'1.003'}
    ${'3000000000000000000000'}          | ${3}         | ${'0.003'}
    ${'3000000000000000000000'}          | ${4}         | ${'0.003'}
    ${'3500000000000000000000'}          | ${3}         | ${'0.004'}
    ${'03500000000000000000000'}         | ${3}         | ${'0.004'}
    ${'10000000999999997410000000'}      | ${undefined} | ${'10.00000099999999741'}
    ${'10100000999999997410000000'}      | ${undefined} | ${'10.10000099999999741'}
    ${'10040000999999997410000000'}      | ${2}         | ${'10.04'}
    ${'10999000999999997410000000'}      | ${2}         | ${'11'}
    ${'1000000100000000000000000000000'} | ${undefined} | ${'1,000,000.1'}
    ${'1000100000000000000000000000000'} | ${undefined} | ${'1,000,100'}
    ${'910000000000000000000000'}        | ${0}         | ${'1'}
`('formatNearAmount($balance, $fracDigits) returns $expected', ({ balance, fracDigits, expected }) => {
    expect(nearApi.utils.format.formatNearAmount(balance, fracDigits)).toEqual(expected);
});

test.each`
    amt                               | expected
    ${null}                           | ${null}
    ${'5.3'}                          | ${'5300000000000000000000000'}
    ${'5'}                            | ${'5000000000000000000000000'}
    ${'1'}                            | ${'1000000000000000000000000'}
    ${'10'}                           | ${'10000000000000000000000000'}
    ${'0.000008999999999837087887'}   | ${'8999999999837087887'}
    ${'0.000008099099999837087887'}   | ${'8099099999837087887'}
    ${'999.998999999999837087887000'} | ${'999998999999999837087887000'}
    ${'0.000000000000001'}            | ${'1000000000'}
    ${'0'}                            | ${'0'}
    ${'0.000'}                        | ${'0'}
    ${'0.000001'}                     | ${'1000000000000000000'}
    ${'.000001'}                      | ${'1000000000000000000'}
    ${'000000.000001'}                | ${'1000000000000000000'}
    ${'1,000,000.1'}                  | ${'1000000100000000000000000000000'}
`('parseNearAmount($amt) returns $expected', ({ amt, expected }) => {
    expect(nearApi.utils.format.parseNearAmount(amt)).toStrictEqual(expected);
});

test('parseNearAmount fails when parsing values with 25 decimal places', () => {
    expect(() => {
        nearApi.utils.format.parseNearAmount('0.0000080990999998370878871');
    }).toThrowError(
        'Cannot parse \'0.0000080990999998370878871\' as NEAR amount'
    );
});

'''
'''--- test/utils/rpc-errors.test.js ---
const nearApi = require('../../src/index');
const { ServerError } = require('../../src/utils/rpc_errors');
const {
    parseRpcError,
    formatError,
    getErrorTypeFromErrorMessage,
} = nearApi.utils.rpc_errors;
describe('rpc-errors', () => {
    test('test AccountAlreadyExists error', async () => {
        let rpc_error = {
            TxExecutionError: {
                ActionError: {
                    index: 1,
                    kind: {AccountAlreadyExists: {account_id: 'bob.near'}}
                }
            }
        };
        let error = parseRpcError(rpc_error);
        expect(error.type === 'AccountAlreadyExists').toBe(true);
        expect(error.index).toBe(1);
        expect(error.account_id).toBe('bob.near');
        expect(formatError(error.type, error)).toBe('Can\'t create a new account bob.near, because it already exists');
    });

    test('test ReceiverMismatch error', async () => {
        let rpc_error = {
            TxExecutionError: {
                InvalidTxError: {
                    InvalidAccessKeyError: {
                        ReceiverMismatch: {
                            ak_receiver: 'test.near',
                            tx_receiver: 'bob.near'
                        }
                    }
                }
            }
        };
        let error = parseRpcError(rpc_error);
        expect(error.type === 'ReceiverMismatch').toBe(true);
        expect(error.ak_receiver).toBe('test.near');
        expect(error.tx_receiver).toBe('bob.near');
        expect(formatError(error.type, error)).toBe(
            'Wrong AccessKey used for transaction: transaction is sent to receiver_id=bob.near, but is signed with function call access key that restricted to only use with receiver_id=test.near. Either change receiver_id in your transaction or switch to use a FullAccessKey.'
        );
    });

    test('test InvalidIteratorIndex error', async () => {
        let rpc_error = {
            TxExecutionError: {
                ActionError: {
                    FunctionCallError: {
                        HostError: {
                            InvalidIteratorIndex: {iterator_index: 42}
                        }
                    }
                }
            }
        };
        let error = parseRpcError(rpc_error);
        expect(error.type === 'InvalidIteratorIndex').toBe(true);
        expect(error.iterator_index).toBe(42);
        expect(formatError(error.type, error)).toBe('Iterator index 42 does not exist');
    });

    test('test ActionError::FunctionCallError::GasLimitExceeded error', async () => {
        let rpc_error = {
            ActionError: {
                'index': 0,
                'kind': {
                    FunctionCallError: {
                        'HostError': 'GasLimitExceeded'
                    }
                }
            }
        };
        let error = parseRpcError(rpc_error);
        expect(error.type === 'GasLimitExceeded').toBe(true);

        expect(formatError(error.type, error)).toBe('Exceeded the maximum amount of gas allowed to burn per contract');
    });

    test('test parse error object', async () => {
        const errorStr = '{"status":{"Failure":{"ActionError":{"index":0,"kind":{"FunctionCallError":{"EvmError":"ArgumentParseError"}}}}},"transaction":{"signer_id":"test.near","public_key":"ed25519:D5HVgBE8KgXkSirDE4UQ8qwieaLAR4wDDEgrPRtbbNep","nonce":110,"receiver_id":"evm","actions":[{"FunctionCall":{"method_name":"transfer","args":"888ZO7SvECKvfSCJ832LrnFXuF/QKrSGztwAAA==","gas":300000000000000,"deposit":"0"}}],"signature":"ed25519:7JtWQ2Ux63ixaKy7bTDJuRTWnv6XtgE84ejFMMjYGKdv2mLqPiCfkMqbAPt5xwLWwFdKjJniTcxWZe7FdiRWpWv","hash":"E1QorKKEh1WLJwRQSQ1pdzQN3f8yeFsQQ8CbJjnz1ZQe"},"transaction_outcome":{"proof":[],"block_hash":"HXXBPjGp65KaFtam7Xr67B8pZVGujZMZvTmVW6Fy9tXf","id":"E1QorKKEh1WLJwRQSQ1pdzQN3f8yeFsQQ8CbJjnz1ZQe","outcome":{"logs":[],"receipt_ids":["ZsKetkrZQGVTtmXr2jALgNjzcRqpoQQsk9HdLmFafeL"],"gas_burnt":2428001493624,"tokens_burnt":"2428001493624000000000","executor_id":"test.near","status":{"SuccessReceiptId":"ZsKetkrZQGVTtmXr2jALgNjzcRqpoQQsk9HdLmFafeL"}}},"receipts_outcome":[{"proof":[],"block_hash":"H6fQCVpxBDv9y2QtmTVHoxHibJvamVsHau7fDi7AmFa2","id":"ZsKetkrZQGVTtmXr2jALgNjzcRqpoQQsk9HdLmFafeL","outcome":{"logs":[],"receipt_ids":["DgRyf1Wv3ZYLFvM8b67k2yZjdmnyUUJtRkTxAwoFi3qD"],"gas_burnt":2428001493624,"tokens_burnt":"2428001493624000000000","executor_id":"evm","status":{"Failure":{"ActionError":{"index":0,"kind":{"FunctionCallError":{"EvmError":"ArgumentParseError"}}}}}}},{"proof":[],"block_hash":"9qNVA235L9XdZ8rZLBAPRNBbiGPyNnMUfpbi9WxbRdbB","id":"DgRyf1Wv3ZYLFvM8b67k2yZjdmnyUUJtRkTxAwoFi3qD","outcome":{"logs":[],"receipt_ids":[],"gas_burnt":0,"tokens_burnt":"0","executor_id":"test.near","status":{"SuccessValue":""}}}]}';
        const error = parseRpcError(JSON.parse(errorStr).status.Failure);
        expect(error).toEqual(new ServerError('{"index":0,"kind":{"EvmError":"ArgumentParseError"}}'));
    });

    test('test getErrorTypeFromErrorMessage', () => {
        const err1 = 'account random.near does not exist while viewing';
        const err2 = 'Account random2.testnet doesn\'t exist';
        const err3 = 'access key ed25519:DvXowCpBHKdbD2qutgfhG6jvBMaXyUh7DxrDSjkLxMHp does not exist while viewing';
        const err4 = 'wasm execution failed with error: FunctionCallError(CompilationError(CodeDoesNotExist { account_id: "random.testnet" }))';
        const err5 = '[-32000] Server error: Invalid transaction: Transaction nonce 1 must be larger than nonce of the used access key 1';
        expect(getErrorTypeFromErrorMessage(err1)).toEqual('AccountDoesNotExist');
        expect(getErrorTypeFromErrorMessage(err2)).toEqual('AccountDoesNotExist');
        expect(getErrorTypeFromErrorMessage(err3)).toEqual('AccessKeyDoesNotExist');
        expect(getErrorTypeFromErrorMessage(err4)).toEqual('CodeDoesNotExist');
        expect(getErrorTypeFromErrorMessage(err5)).toEqual('InvalidNonce');
        expect(getErrorTypeFromErrorMessage('random string')).toEqual('UntypedError');
        expect(getErrorTypeFromErrorMessage(undefined)).toEqual('UntypedError');
        expect(getErrorTypeFromErrorMessage('')).toEqual('UntypedError');
    });

    test('test NotEnoughBalance message uses human readable values', () => {
        const error = parseRpcError({
            NotEnoughBalance: {
                balance: '1000000000000000000000000',
                cost: '10000000000000000000000000',
                signer_id: 'test.near'
            }
        });

        expect(error.message).toEqual('Sender test.near does not have enough balance 1 for operation costing 10');
    });

    test('test TriesToStake message uses human readable values', () => {
        const error = parseRpcError({
            TriesToStake: {
                account_id: 'test.near',
                balance: '9000000000000000000000000',
                locked: '1000000000000000000000000',
                stake: '10000000000000000000000000',
            }
        });

        expect(error.message).toEqual('Account test.near tried to stake 10, but has staked 1 and only has 9');
    });
});

'''
'''--- test/validator.test.js ---

const nearApi = require('../src/index');
const BN = require('bn.js');

test('find seat price', async () => {
    expect(nearApi.validators.findSeatPrice(
        [{stake: '1000000'}, {stake: '1000000'}, {stake: '10'}], 10)).toEqual(new BN('200000'));
    expect(nearApi.validators.findSeatPrice(
        [{ stake: '1000000000' }, { stake: '10' }], 10)).toEqual(new BN('100000000'));
    expect(nearApi.validators.findSeatPrice(
        [{ stake: '1000000000' }], 1000000000)).toEqual(new BN('1'));
    expect(nearApi.validators.findSeatPrice(
        [{ stake: '1000' }, { stake: '1' }, { stake: '1' }, { stake: '1' }, { stake: '1' }, { stake: '1' }, { stake: '1' }, { stake: '1' }, { stake: '1' }], 1)).toEqual(new BN('1000'));
    expect(() => { nearApi.validators.findSeatPrice(
        [{ stake: '1' }, { stake: '1' }, { stake: '2' }], 100); }).toThrow();
});

test('diff validators', async () => {
    expect(nearApi.validators.diffEpochValidators(
        [{account_id: 'x', stake: '10'}],
        [{ account_id: 'x', stake: '10' }]
    )).toEqual({newValidators: [], removedValidators: [], changedValidators: []});
    expect(nearApi.validators.diffEpochValidators(
        [{ account_id: 'x', stake: '10' }, { account_id: 'y', stake: '10' }],
        [{ account_id: 'x', stake: '11' }, { account_id: 'z', stake: '11' }]
    )).toEqual({
        newValidators: [{ account_id: 'z', stake: '11' }],
        removedValidators: [{ account_id: 'y', stake: '10' }],
        changedValidators: [{ 
            current: { account_id: 'x', stake: '10' },
            next: { account_id: 'x', stake: '11' }
        }]
    });
});
'''
'''--- test/wallet-account.test.js ---
const url = require('url');
const localStorage = require('localstorage-memory');
const BN = require('bn.js');

// If an access key has itself as receiverId and method permission add_request_and_confirm, then it is being used in a wallet with multisig contract: https://github.com/near/core-contracts/blob/671c05f09abecabe7a7e58efe942550a35fc3292/multisig/src/lib.rs#L149-L153
const MULTISIG_HAS_METHOD = 'add_request_and_confirm';

let lastRedirectUrl;
let lastTransaction;
global.window = {
    localStorage
};
global.document = {
    title: 'documentTitle'
};
const nearApi = require('../src/index');

let history;
let nearFake;
let walletConnection;
let keyStore = new nearApi.keyStores.InMemoryKeyStore();
beforeEach(() => {
    keyStore.clear();
    nearFake = {
        config: {
            networkId: 'networkId',
            contractName: 'contractId',
            walletUrl: 'http://example.com/wallet',
        },
        connection: {
            networkId: 'networkId',
            signer: new nearApi.InMemorySigner(keyStore)
        },
        account() {
            return {
                state() {}
            };
        }
    };
    lastRedirectUrl = null;
    history = [];
    Object.assign(global.window, {
        location: {
            href: 'http://example.com/location',
            assign(url) {
                lastRedirectUrl = url;
            }
        },
        history: {
            replaceState: (state, title, url) => history.push([state, title, url])
        }
    });
    walletConnection = new nearApi.WalletConnection(nearFake);
});

it('not signed in by default', () => {
    expect(walletConnection.isSignedIn()).not.toBeTruthy();
});

describe('can request sign in', () => {
    beforeEach(() => keyStore.clear());

    it('V1', () => {
        return walletConnection.requestSignIn('signInContract', 'signInTitle', 'http://example.com/success',  'http://example.com/fail');
    });
    
    it('V2', () => {
        return walletConnection.requestSignIn({
            contractId: 'signInContract',
            successUrl: 'http://example.com/success', 
            failureUrl: 'http://example.com/fail'
        });
    });

    afterEach(async () => {
        let accounts = await keyStore.getAccounts('networkId');
        expect(accounts).toHaveLength(1);
        expect(accounts[0]).toMatch(/^pending_key.+/);
        expect(url.parse(lastRedirectUrl, true)).toMatchObject({
            protocol: 'http:',
            host: 'example.com',
            query: {
                contract_id: 'signInContract',
                success_url: 'http://example.com/success',
                failure_url: 'http://example.com/fail',
                public_key: (await keyStore.getKey('networkId', accounts[0])).publicKey.toString()
            }
        });
    });
});

it('can request sign in with methodNames', async () => {
    await walletConnection.requestSignIn({
        contractId: 'signInContract',
        methodNames: ['hello', 'goodbye'],
        successUrl: 'http://example.com/success', 
        failureUrl: 'http://example.com/fail'
    });

    let accounts = await keyStore.getAccounts('networkId');
    expect(accounts).toHaveLength(1);
    expect(accounts[0]).toMatch(/^pending_key.+/);
    expect(url.parse(lastRedirectUrl, true)).toMatchObject({
        protocol: 'http:',
        host: 'example.com',
        query: {
            contract_id: 'signInContract',
            methodNames: ['hello', 'goodbye'],
            success_url: 'http://example.com/success',
            failure_url: 'http://example.com/fail',
            public_key: (await keyStore.getKey('networkId', accounts[0])).publicKey.toString()
        }
    });
});

it('can complete sign in', async () => {
    const keyPair = nearApi.KeyPair.fromRandom('ed25519');
    global.window.location.href = `http://example.com/location?account_id=near.account&public_key=${keyPair.publicKey}`;
    await keyStore.setKey('networkId', 'pending_key' + keyPair.publicKey, keyPair);

    await walletConnection._completeSignInWithAccessKey();

    expect(await keyStore.getKey('networkId', 'near.account')).toEqual(keyPair);
    expect(localStorage.getItem('contractId_wallet_auth_key'));
    expect(history.slice(1)).toEqual([
        [{}, 'documentTitle', 'http://example.com/location']
    ]);
});

const BLOCK_HASH = '244ZQ9cgj3CQ6bWBdytfrJMuMQ1jdXLFGnr4HhvtCTnM';
const blockHash = nearApi.utils.serialize.base_decode(BLOCK_HASH);
function createTransferTx() {
    const actions = [
        nearApi.transactions.transfer(1),
    ];
    return nearApi.transactions.createTransaction(
        'test.near',
        nearApi.utils.PublicKey.fromString('Anu7LYDfpLtkP7E16LT9imXF694BdQaa9ufVkQiwTQxC'),
        'whatever.near',
        1,
        actions,
        blockHash);
}

describe('can request transaction signing', () => {
    it('V1', async () => {
        await walletConnection.requestSignTransactions({
            transactions: [createTransferTx()],
            callbackUrl: 'http://example.com/callback'
        });

        expect(url.parse(lastRedirectUrl, true)).toMatchObject({
            protocol: 'http:',
            host: 'example.com',
            query: {
                callbackUrl: 'http://example.com/callback',
                transactions: 'CQAAAHRlc3QubmVhcgCRez0mjUtY9/7BsVC9aNab4+5dTMOYVeNBU4Rlu3eGDQEAAAAAAAAADQAAAHdoYXRldmVyLm5lYXIPpHP9JpAd8pa+atxMxN800EDvokNSJLaYaRDmMML+9gEAAAADAQAAAAAAAAAAAAAAAAAAAA=='
            }
        });
    });

    it('V2', async () => {
        await walletConnection.requestSignTransactions({
            transactions: [createTransferTx()],
            meta: 'something',
            callbackUrl: 'http://example.com/after'
        });

        expect(url.parse(lastRedirectUrl, true)).toMatchObject({
            protocol: 'http:',
            host: 'example.com',
            query: {
                meta: 'something',
                callbackUrl: 'http://example.com/after',
                transactions: 'CQAAAHRlc3QubmVhcgCRez0mjUtY9/7BsVC9aNab4+5dTMOYVeNBU4Rlu3eGDQEAAAAAAAAADQAAAHdoYXRldmVyLm5lYXIPpHP9JpAd8pa+atxMxN800EDvokNSJLaYaRDmMML+9gEAAAADAQAAAAAAAAAAAAAAAAAAAA=='
            }
        });
    });
});

function parseTransactionsFromUrl(urlToParse, callbackUrl = 'http://example.com/location') {
    const parsedUrl = url.parse(urlToParse, true);
    expect(parsedUrl).toMatchObject({
        protocol: 'http:',
        host: 'example.com',
        query: {
            callbackUrl
        }
    });
    const transactions = parsedUrl.query.transactions.split(',')
        .map(txBase64 => nearApi.utils.serialize.deserialize(
            nearApi.transactions.SCHEMA,
            nearApi.transactions.Transaction,
            Buffer.from(txBase64, 'base64')));
    return transactions;
}

function setupWalletConnectionForSigning({ allKeys, accountAccessKeys }) {
    walletConnection._authData = {
        allKeys: allKeys,
        accountId: 'signer.near'
    };
    nearFake.connection.provider = {
        query(params) {
            if (params.request_type === 'view_account' && params.account_id === 'signer.near') {
                return { };
            }
            if (params.request_type === 'view_access_key_list' && params.account_id === 'signer.near') {
                return { keys: accountAccessKeys };
            }
            if (params.request_type === 'view_access_key' && params.account_id === 'signer.near') {
                for (let accessKey of accountAccessKeys) {
                    if (accessKey.public_key === params.public_key) {
                        return accessKey;
                    }
                }
            }
            fail(`Unexpected query: ${JSON.stringify(params)}`);
        },
        sendTransaction(signedTransaction) {
            lastTransaction = signedTransaction;
            return {
                transaction_outcome: { outcome: { logs: [] } },
                receipts_outcome: []
            };
        },
        block() {
            return {
                header: {
                    hash: BLOCK_HASH
                }
            };
        }
    };
}

describe('requests transaction signing automatically when there is no local key', () => {
    const keyPair = nearApi.KeyPair.fromRandom('ed25519');
    let transactions;
    beforeEach(() => {
        setupWalletConnectionForSigning({
            allKeys: [ 'no_such_access_key', keyPair.publicKey.toString() ],
            accountAccessKeys: [{
                access_key: {
                    nonce: 1,
                    permission: 'FullAccess'
                },
                public_key: keyPair.publicKey.toString()
            }]
        });
    });

    it('V1', async () => {
        try {
            await walletConnection.account().signAndSendTransaction(
                'receiver.near',
                [nearApi.transactions.transfer(1)]
            );
            fail('expected to throw');
        } catch (e) {
            expect(e.message).toEqual('Failed to redirect to sign transaction');
        }
        transactions = parseTransactionsFromUrl(lastRedirectUrl);
    });

    it('V2', async() => {
        try {
            await walletConnection.account().signAndSendTransaction({
                receiverId: 'receiver.near',
                actions: [nearApi.transactions.transfer(1)],
                walletCallbackUrl: 'http://callback.com/callback'
            });
            fail('expected to throw');
        } catch (e) {
            expect(e.message).toEqual('Failed to redirect to sign transaction');
        }
        transactions = parseTransactionsFromUrl(lastRedirectUrl, 'http://callback.com/callback');
    });

    afterEach(() => {
        expect(transactions).toHaveLength(1);
        expect(transactions[0]).toMatchObject({
            signerId: 'signer.near',
            // nonce: new BN(2)
            receiverId: 'receiver.near',
            actions: [{
                transfer: {
                    // deposit: new BN(1)
                }
            }]
        });
        expect(transactions[0].nonce.toString()).toEqual('2');
        expect(transactions[0].actions[0].transfer.deposit.toString()).toEqual('1');
        expect(Buffer.from(transactions[0].publicKey.data)).toEqual(Buffer.from(keyPair.publicKey.data));
    });
});

describe('requests transaction signing automatically when function call has attached deposit', () => {
    beforeEach(async() => {
        const localKeyPair = nearApi.KeyPair.fromRandom('ed25519');
        const walletKeyPair = nearApi.KeyPair.fromRandom('ed25519');
        setupWalletConnectionForSigning({
            allKeys: [ walletKeyPair.publicKey.toString() ],
            accountAccessKeys: [{
                access_key: {
                    nonce: 1,
                    permission: {
                        FunctionCall: {
                            allowance: '1000000000',
                            receiver_id: 'receiver.near',
                            method_names: []
                        }
                    }
                },
                public_key: localKeyPair.publicKey.toString()
            }, {
                access_key: {
                    nonce: 1,
                    permission: 'FullAccess'
                },
                public_key: walletKeyPair.publicKey.toString()
            }]
        });
        await keyStore.setKey('networkId', 'signer.near', localKeyPair);
    });

    it('V1', async () => {
        try {
            await walletConnection.account().signAndSendTransaction('receiver.near', [
                nearApi.transactions.functionCall('someMethod', new Uint8Array(), new BN('1'), new BN('1'))
            ]);
            fail('expected to throw');
        } catch (e) {
            expect(e.message).toEqual('Failed to redirect to sign transaction');
        }
    
        const transactions = parseTransactionsFromUrl(lastRedirectUrl);
        expect(transactions).toHaveLength(1);
    });

    it('V2', async() => {
        try {
            await walletConnection.account().signAndSendTransaction({
                receiverId: 'receiver.near',
                actions: [nearApi.transactions.functionCall('someMethod', new Uint8Array(), new BN('1'), new BN('1'))],
                walletCallbackUrl: 'http://example.com/after',
                walletMeta: 'someStuff'
            });
            fail('expected to throw');
        } catch (e) {
            expect(e.message).toEqual('Failed to redirect to sign transaction');
        }
    
        const transactions = parseTransactionsFromUrl(lastRedirectUrl, 'http://example.com/after');
        expect(transactions).toHaveLength(1);
    });
});

describe('requests transaction signing with 2fa access key', () => {
    beforeEach(async () => {
        let localKeyPair = nearApi.KeyPair.fromRandom('ed25519');
        let walletKeyPair = nearApi.KeyPair.fromRandom('ed25519');
        setupWalletConnectionForSigning({
            allKeys: [ walletKeyPair.publicKey.toString() ],
            accountAccessKeys: [{
                access_key: {
                    nonce: 1,
                    permission: {
                        FunctionCall: {
                            allowance: '1000000000',
                            receiver_id: 'signer.near',
                            method_names: [MULTISIG_HAS_METHOD]
                        }
                    }
                },
                public_key: localKeyPair.publicKey.toString()
            }]
        });
        await keyStore.setKey('networkId', 'signer.near', localKeyPair);
    });

    it('V1', async () => {
        try {
            const res = await walletConnection.account().signAndSendTransaction('receiver.near', [
                nearApi.transactions.functionCall('someMethod', new Uint8Array(), new BN('1'), new BN('1'))
            ]);

            // multisig access key is accepted res is object representing transaction, populated upon wallet redirect to app
            expect(res).toHaveProperty('transaction_outcome');
            expect(res).toHaveProperty('receipts_outcome');
        } catch (e) {
            fail('expected transaction outcome');
        }
    });

    it('V2', async () => {
        try {
            const res = await walletConnection.account().signAndSendTransaction({
                receiverId: 'receiver.near',
                actions: [nearApi.transactions.functionCall('someMethod', new Uint8Array(), new BN('1'), new BN('1'))]
            });

            // multisig access key is accepted res is object representing transaction, populated upon wallet redirect to app
            expect(res).toHaveProperty('transaction_outcome');
            expect(res).toHaveProperty('receipts_outcome');
        } catch (e) {
            fail('expected transaction outcome');
        }
    });
});

describe('fails requests transaction signing without 2fa access key', () => {
    beforeEach(async () => {
        const localKeyPair = nearApi.KeyPair.fromRandom('ed25519');
        const walletKeyPair = nearApi.KeyPair.fromRandom('ed25519');
        setupWalletConnectionForSigning({
            allKeys: [ walletKeyPair.publicKey.toString() ],
            accountAccessKeys: [{
                access_key: {
                    nonce: 1,
                    permission: {
                        FunctionCall: {
                            allowance: '1000000000',
                            receiver_id: 'signer.near',
                            method_names: ['not_a_valid_2fa_method']
                        }
                    }
                },
                public_key: localKeyPair.publicKey.toString()
            }]
        });
        await keyStore.setKey('networkId', 'signer.near', localKeyPair);
    });

    it('V1', () => {
        return expect(
            walletConnection.account().signAndSendTransaction(
                'receiver.near',
                [nearApi.transactions.functionCall('someMethod', new Uint8Array(), new BN('1'), new BN('1'))]
            )
        ).rejects.toThrow('Cannot find matching key for transaction sent to receiver.near');
    });

    it('V2', () => {
        return expect(
            walletConnection.account().signAndSendTransaction({
                receiverId: 'receiver.near',
                actions: [nearApi.transactions.functionCall('someMethod', new Uint8Array(), new BN('1'), new BN('1'))]
            })
        ).rejects.toThrow('Cannot find matching key for transaction sent to receiver.near');
    });
});

describe('can sign transaction locally when function call has no attached deposit', () => {
    beforeEach(async () => {
        const localKeyPair = nearApi.KeyPair.fromRandom('ed25519');
        setupWalletConnectionForSigning({
            allKeys: [ /* no keys in wallet needed */ ],
            accountAccessKeys: [{
                access_key: {
                    nonce: 1,
                    permission: {
                        FunctionCall: {
                            allowance: '1000000000',
                            receiver_id: 'receiver.near',
                            method_names: []
                        }
                    }
                },
                public_key: localKeyPair.publicKey.toString()
            }]
        });
        await keyStore.setKey('networkId', 'signer.near', localKeyPair);
    });

    it.each([
        nearApi.transactions.functionCall('someMethod', new Uint8Array(), new BN('1'), new BN('0')),
        nearApi.transactions.functionCall('someMethod', new Uint8Array(), new BN('1')),
        nearApi.transactions.functionCall('someMethod', new Uint8Array())
    ])('V1', async (functionCall) => {
        await walletConnection.account().signAndSendTransaction('receiver.near', [ functionCall ]);
        // NOTE: Transaction gets signed without wallet in this test
        expect(lastTransaction).toMatchObject({
            transaction: {
                receiverId: 'receiver.near',
                signerId: 'signer.near',
                actions: [{
                    functionCall: {
                        methodName: 'someMethod',
                    }
                }]
            }
        });
    });

    it.each([
        nearApi.transactions.functionCall('someMethod', new Uint8Array(), new BN('1'), new BN('0')),
        nearApi.transactions.functionCall('someMethod', new Uint8Array(), new BN('1')),
        nearApi.transactions.functionCall('someMethod', new Uint8Array())
    ])('V1', async (functionCall) => {
        await walletConnection.account().signAndSendTransaction({
            receiverId: 'receiver.near',
            actions: [ functionCall ]
        });
        // NOTE: Transaction gets signed without wallet in this test
        expect(lastTransaction).toMatchObject({
            transaction: {
                receiverId: 'receiver.near',
                signerId: 'signer.near',
                actions: [{
                    functionCall: {
                        methodName: 'someMethod',
                    }
                }]
            }
        });
    });
});

'''
'''--- tsconfig.json ---
{
    "compilerOptions": {
        "esModuleInterop": true,
        "lib": [
            "es2015",
            "esnext",
            "dom"
        ],
        "module": "commonjs",
        "target": "esnext",
        "moduleResolution": "node",
        "alwaysStrict": true,
        "outDir": "./lib",
        "declaration": true,
        "preserveSymlinks": true,
        "preserveWatchOutput": true,
        "pretty": false,
        "forceConsistentCasingInFileNames": true,
        "noFallthroughCasesInSwitch": true,
        "noImplicitAny": false,
        "noImplicitReturns": true,
        "noUnusedLocals": true,
        "experimentalDecorators": true,
        "resolveJsonModule": true,
    },
    "files": [
        "src/index.ts",
        "src/browser-index.ts",
    ],
}

'''
'''--- typedoc.json ---
{
  "theme": "./node_modules/typedoc-neo-theme/bin/default",
  "plugin": "./node_modules/typedoc-neo-theme",
  "exclude": "**/*index.ts",
  "links": [
    { "label": "NEAR Docs", "url": "https://docs.near.org" },
    { "label": "API JS Quick Reference", "url": "https://docs.near.org/docs/develop/front-end/naj-quick-reference" },
    { "label": "RPC Endpoints", "url": "https://docs.near.org/docs/develop/front-end/rpc" }
  ],
  "outline": [
    {
      "Connect to NEAR": {
        "browser": "browserconnect",
        "node.js": "connect"
      },
      "Managing Accounts": {
        "Account": "classes/account.account-1",
        "Wallet Account": "classes/walletaccount.walletconnection",
        "Smart Contracts": "classes/contract.contract-1"
      },
      "Managing Keys": {
        "KeyPair": "utils_key_pair",
        "BrowserLocalStorageKeyStore": "classes/key_stores_browser_local_storage_key_store.browserlocalstoragekeystore",
        "InMemoryKeyStore": "classes/key_stores_in_memory_key_store.inmemorykeystore",
        "UnencryptedFileSystemKeyStore": "classes/key_stores_unencrypted_file_system_keystore.unencryptedfilesystemkeystore",
        "MergeKeyStore": "classes/key_stores_merge_key_store.mergekeystore"
      },
      "RPC": {
        "Request and Response Types": "providers_provider",
        "Client": "classes/providers_json_rpc_provider.jsonrpcprovider"
      },
      "utils": {
        "Formatting": "utils_format"
      }
    }
  ]
}

'''