*GitHub Repository "amgando/10-min-tutorial"*

'''--- .vscode/settings.json ---
{
  "editor.defaultFormatter": "esbenp.prettier-vscode"
}
'''
'''--- README.md ---
## 10-min Teaser: Tokens

Slides are here:
https://docs.google.com/presentation/d/13gjojRbZmPg5RexTzXUBMP8mfc26mOmijx1H54mOOxM

![Screen Shot 2020-04-13 at 12 38 59 PM](https://user-images.githubusercontent.com/709100/79149079-cfe06980-7d83-11ea-8e73-f30170e8ceb7.png)

## Getting Started

1. clone this repo
2. run `yarn` to install dependencies (read how to install `yarn`)
3. run `yarn run test:contract` to run tests for smart contract code
4. run `yarn develop` to launch the working project

## Commands

```
- build
   gatsby build
- build:contract
   mkdir -p static/ && near/scripts/compile-contract.js
- clean
   gatsby clean
- deploy:contract
   near dev-deploy
- dev:contract
   npx nodemon --config ./near/config/nodemon.contract.json --exec 'yarn run build:contract'
- develop
   gatsby develop
- format
   prettier --write "**/*.{js,jsx,json,md}"
- serve
   gatsby serve
- start
   npm run develop; npm run dev:contract
- test
   echo "Write tests! -> https://gatsby.dev/unit-testing" && exit 1
- test:contract
   asp --config near/config/as-pect.js --verbose
```
'''
'''--- contract/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />

'''
'''--- contract/__tests__/erc20.spec.ts ---
import { u128, VM, Context as VMContext } from "near-sdk-as";
import {
  name, symbol, decimals,
  totalSupply, balanceOf, transfer,
  allowance, approve, transferFrom,
  customize, initialize
} from "../erc20";
import { getNewestTransferEvent, getNewestApprovalEvent } from "../events"

// accounts
const zero = "0x0";                 // the "zero-account" as specified by ERC-20
const contract = "example-token";   // account that owns the contract
const bank = "_bank";               // initialized with totalSupply()
const alice = "alice";              // valid account
const bob = "bob";                  // valid account
const carol = "carol";              // valid account
const derek = "derek";              // invalid account

// token metadata
const _name = "Solidus Wonder Token";
const _symbol = "SWT";
const _decimals: u8 = 2;
const _supply = 100_000_000;

// wallet sizes
const small = u128.from(111)
const medium = u128.from(222)
const large = u128.from(333)

function showLogs(): void {
  log(VM.outcome().logs)
}

function showOutcome(): void {
  log("balance: [" + toReadable(VM.outcome().balance) + "]")
  log("burnt gas: [" + VM.outcome().burnt_gas.toString() + "]")
  log(VM.outcome().return_data)
  log("storage usage: [" + VM.outcome().storage_usage.toString() + "] ")
  log("used gas: [" + VM.outcome().used_gas.toString() + "]")
}

function toReadable(number: u128): string {
  const exponent = number.toString().length
  const lhs = number.toString().slice(0, 1)
  const rhs = number.toString().slice(1, 3)
  return lhs + "." + rhs + " x 10^" + exponent.toString()
}

describe("ERC-20 Token (extensions)", () => {
  beforeEach(() => {
    VM.saveState()
  })

  afterEach(() => {
    VM.restoreState()
  })

  throws("should not allow initialization unless called by contract account", () => {
    VMContext.setCurrent_account_id(contract);
    VMContext.setSigner_account_id("anything.but.the.contract");
    customize()
    initialize()
  })

  throws("should not allow customization unless called by contract account", () => {
    VMContext.setCurrent_account_id(contract);
    VMContext.setSigner_account_id("anything.but.the.contract");
    customize()
  })

  it("can be initialized", () => {
    VMContext.setCurrent_account_id(contract);
    VMContext.setSigner_account_id(contract);
    customize()
    initialize()
    // showLogs()
  })

})

describe("ERC-20 Token (optional)", () => {
  beforeAll(() => {
    VM.saveState()
    VMContext.setCurrent_account_id(contract);
    VMContext.setSigner_account_id(contract);
    customize()
    initialize()
  })

  afterAll(() => {
    VM.restoreState()
  })

  it("should have a name", () => {
    expect(name()).toBe(_name)
  })

  it("should have a symbol", () => {
    expect(symbol()).toBe(_symbol)
  })

  it("should have decimals", () => {
    expect(decimals()).toBe(_decimals)
  })
})

describe("ERC-20 Token (startup)", () => {
  beforeAll(() => {
    customize()
    initialize()
  })

  it("should respond to totalSupply()", () => {
    // the total supply should be available
    expect(totalSupply()).toBe(u128.from(_supply))
  })

  it("should initially assign entire token supply to a single account", () => {
    // the balance of the initial owner should match the total supply
    expect(balanceOf(contract)).toBe(totalSupply())
  })

  it("should record an initial transfer event", () => {
    // and event lots should include a record of the TransferEvent
    const event = getNewestTransferEvent();
    // log(event)
    // log(logs())
    expect(event.spender).toBe(zero);
    expect(event.from).toBe(zero);
    expect(event.to).toBe(contract);
    expect(event.value).toBe(totalSupply());

  })
})

describe("ERC-20 Token (steady state) ", () => {
  beforeEach(() => {
    // prepare the reset balances after each test
    VM.saveState()

    // prepare to send a transaction as if coming from the contract account
    VMContext.setCurrent_account_id(contract);
    VMContext.setSigner_account_id(contract);
    customize()
    initialize()

    // spread the wealth around
    transfer(alice, small)
    transfer(bob, medium)
    transfer(carol, large)
    // derek gets no love here
  })

  afterEach(() => {
    VM.restoreState()     // reset balances after each test
    // log(logs())
  })

  describe("Transfers", () => {
    it("should allow transfers between accounts", () => {
      // record starting balances
      const aliceStart = balanceOf(alice);
      const bobStart = balanceOf(bob);

      // assume alice signs a transfer transaction
      VMContext.setSigner_account_id(alice);

      // alice transfers amount to bob
      const amount = u128.from(10);
      transfer(bob, amount);

      // respective balances should reflect the change
      expect(balanceOf(alice)).toBe(u128.sub(aliceStart, amount));
      expect(balanceOf(bob)).toBe(u128.add(bobStart, amount));

      // test that a transfer event was recorded
      const event = getNewestTransferEvent();
      // log(event)
      expect(event.spender).toBe(alice);
      expect(event.from).toBe(alice);
      expect(event.to).toBe(bob);
      expect(event.value).toBe(amount);
    })

    throws("should not allow transfers if balance is too low", () => {
      // assume alice signs a transfer transaction
      VMContext.setSigner_account_id(alice);

      // alice transfers amt to bob
      let amount = u128.from(10);
      transfer(bob, amount);

      // assume bob signs a transfer transaction
      VMContext.setSigner_account_id(bob);

      // record starting balances
      const bobStartBalance = balanceOf(bob);

      // bob attempts to transfer amount to carol but fails
      amount = u128.from(999);
      transfer(carol, amount);     // expect this line to throw an exception
    })

    throws("should not allow transfers from unfunded accounts", () => {
      // assume derek signs a transfer transaction
      VMContext.setSigner_account_id(derek);

      // derek attempts to transfer amount to alice even though he has no tokens
      const amount = u128.from(1);
      transfer(alice, amount)
    })

  })

  describe("Transfer Delegation ", () => {
    it("should gracefully default to zero allowance", () => {
      expect(allowance(alice, bob)).toBe(u128.Zero);
    })

    it("should support approved allowances", () => {
      const approvedAmount = u128.from(10)

      // assume alice signs a transfer transaction
      VMContext.setSigner_account_id(alice);

      // alice approves bob to spend 10 tokens on her behalf
      approve(bob, approvedAmount)

      expect(allowance(alice, bob)).toBe(u128.from(10));

      // test that a approve event was recorded
      const event = getNewestApprovalEvent();
      // log(event)
      expect(event.owner).toBe(alice);
      expect(event.spender).toBe(bob);
      expect(event.oldValue).toBe(u128.Zero);
      expect(event.value).toBe(approvedAmount);
    })

    it("should support updating allowances", () => {
      const limit1 = u128.from(10)
      const limit2 = u128.from(20)

      // assume alice signs a transfer transaction
      VMContext.setSigner_account_id(alice);

      // alice approves bob to spend some limit of tokens on her behalf
      approve(bob, limit1)
      expect(allowance(alice, bob)).toBe(limit1);

      // test that a approve event was recorded
      const event1 = getNewestApprovalEvent();
      // log(event1
      expect(event1.owner).toBe(alice);
      expect(event1.spender).toBe(bob);
      expect(event1.oldValue).toBe(u128.Zero);
      expect(event1.value).toBe(limit1);

      // alice approves bob to spend a different limit of tokens on her behalf
      approve(bob, limit2)
      expect(allowance(alice, bob)).toBe(limit2);

      // test that a approve event was recorded
      const event2 = getNewestApprovalEvent();
      // log(event2
      expect(event2.owner).toBe(alice);
      expect(event2.spender).toBe(bob);
      expect(event2.oldValue).toBe(limit1);
      expect(event2.value).toBe(limit2);
    })

    throws("should avoid approving allowances when owner has insufficient funds", () => {
      const approvedAmount = u128.from(10)

      // assume derek signs a transfer transaction
      VMContext.setSigner_account_id(derek);

      // derek approves bob to spend 10 tokens on his behalf
      approve(bob, approvedAmount)
    })

    it("should allow approved transfers", () => {
      const approvedAmount = u128.from(10)
      const transferredAmount = u128.from(9)

      // assume alice signs a transfer transaction
      VMContext.setSigner_account_id(alice);

      // alice approves bob to spend 10 tokens on her behalf
      approve(bob, approvedAmount)

      // test that a approve event was recorded
      const approvalEvent = getNewestApprovalEvent();
      // log(approvalEvent)
      expect(approvalEvent.owner).toBe(alice);
      expect(approvalEvent.spender).toBe(bob);
      expect(approvalEvent.oldValue).toBe(u128.Zero);
      expect(approvalEvent.value).toBe(approvedAmount);

      // assume bob signs a transfer transaction
      VMContext.setSigner_account_id(bob);

      const aliceBefore = balanceOf(alice);
      const carolBefore = balanceOf(carol);

      transferFrom(alice, carol, transferredAmount);

      expect(balanceOf(alice)).toBe(u128.sub(aliceBefore, transferredAmount))
      expect(balanceOf(carol)).toBe(u128.add(carolBefore, transferredAmount))

      // test that a transfer event was recorded
      const transferEvent = getNewestTransferEvent();
      // log(transferEvent)
      expect(transferEvent.spender).toBe(bob);
      expect(transferEvent.from).toBe(alice);
      expect(transferEvent.to).toBe(carol);
      expect(transferEvent.value).toBe(transferredAmount);
    })

    // should not allow excessive transfers
    describe("", () => {
      beforeEach(() => {
        // assume alice signs a transfer transaction
        VMContext.setSigner_account_id(alice);

        // alice approves bob to spend 10 tokens on her behalf
        approve(bob, u128.from(10))

        // assume bob signs a transfer transaction
        VMContext.setSigner_account_id(bob);
      })

      throws("should disallow transfers that exceed allowance limit", () => {
        transferFrom(alice, carol, u128.from(11));
      })

      throws("should disallow transfers that incrementally rise above allowance limit", () => {
        transferFrom(alice, carol, u128.from(9));
        transferFrom(alice, carol, u128.from(2));
      })

    })
  })

})
'''
'''--- contract/__tests__/events.spec.ts ---
import { u128, VM } from "near-sdk-as";
import {
  TransferEvent, recordTransferEvent, getNewestTransferEvent,
  ApprovalEvent, recordApprovalEvent, getNewestApprovalEvent
} from "../events"

function logs(): string[] {
  return VM.outcome().logs;
}

const spender = "spender";
const owner = "owner";
const from = "from";
const to = "to";
const oldValue = u128.from(0);
const value = u128.from(0);

const transferEvent = new TransferEvent(spender, from, to, value);
const approvalEvent = new ApprovalEvent(owner, spender, oldValue, value);

describe("TransferEvent", () => {
  it("should allow instantiation", () => {
    expect(transferEvent instanceof TransferEvent).toBeTruthy()
  })

  it("should surface all parameters as attributes", () => {
    expect(transferEvent.spender).toBe(spender)
    expect(transferEvent.from).toBe(from)
    expect(transferEvent.to).toBe(to)
    expect(transferEvent.value).toBe(value)
  })

  it("should be recordable and retrievable", () => {
    recordTransferEvent(spender, from, to, value)
    const event = getNewestTransferEvent()

    expect(event instanceof TransferEvent).toBeTruthy()

    expect(event.spender).toBe(spender)
    expect(event.from).toBe(from)
    expect(event.to).toBe(to)
    expect(event.value).toBe(value)
  })
})

describe("ApprovalEvent", () => {
  it("should allow instantiation", () => {
    expect(approvalEvent instanceof ApprovalEvent).toBeTruthy()
  })

  it("should surface all parameters as attributes", () => {
    const approvalEvent = new ApprovalEvent(owner, spender, oldValue, value);
    expect(approvalEvent.owner).toBe(owner)
    expect(approvalEvent.spender).toBe(spender)
    expect(approvalEvent.oldValue).toBe(oldValue)
    expect(approvalEvent.value).toBe(value)
  })

  it("should be recordable and retrievable", () => {
    recordApprovalEvent(owner, spender, oldValue, value)
    const event = getNewestApprovalEvent()

    expect(event instanceof ApprovalEvent).toBeTruthy()

    expect(event.owner).toBe(owner)
    expect(event.spender).toBe(spender)
    expect(event.oldValue).toBe(oldValue)
    expect(event.value).toBe(value)
  })
})

'''
'''--- contract/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- contract/erc20.ts ---
//@nearfile

const DEBUG = true;    // set to `true` to surface debug log msgs throughout

/**
 * EIP 20: ERC-20 Token Standard
 *
 * ERC-20 is a standard interface for tokens which allows for the implementation
 * of a standard API for tokens within smart contracts. This standard provides
 * basic functionality to transfer tokens, as well as allow tokens to be approved
 * so they can be spent by another on-chain third party.
 *
 * A standard interface allows any tokens to be re-used by other applications,
 * from wallets to decentralized exchanges.
 *
 * quoting  https://eips.ethereum.org/EIPS/eip-20
 * see more @ https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC20
 * see more @ https://github.com/ConsenSys/Tokens/blob/master/contracts/eip20/EIP20Interface.sol
 */
import {
  u128,                 // extended number type for working with large numbers
  logging,              // append log messages to VM logging, exposed via `logging.log()` to JS Dev console and via `logs()` in mock VM
  context,              // access to contract context for sender, attachedDeposit and others. see https://github.com/near/near-sdk-as/blob/master/assembly/runtime/contract.ts
  storage,              // key-value store representing contract state on the blockchain
  PersistentMap         // convenience wrapper around storage that mimics a strongly typed map
} from "near-sdk-as";

import {
  recordTransferEvent,  // record mock "event" when transfers are made by the contract
  recordApprovalEvent   // record mock "event" when approvals are made by the contract
} from "./events";      // NEAR doesn't currently provide an event model (as of 2020.03)

// ----------------------------------------------------------------------------
// OPTIONAL
// ----------------------------------------------------------------------------

/**
 * Returns the name of the token - ie. "Solidus Wonder Token"
 *
 * OPTIONAL - This method can be used to improve usability, but interfaces and
 *            other contracts MUST NOT expect these values to be present.
 *
 * @returns The name of the token
 */
export function name(): string {
  // if name has been customized, use it.  otherwise use default
  const name = storage.getSome<string>("_name");
  DEBUG ? logging.log("[status] Token.name: " + name) : false;
  return name;
}

/**
 * Returns the symbol of the token. ie. "SWT"
 *
 * OPTIONAL - This method can be used to improve usability, but interfaces and
 *            other contracts MUST NOT expect these values to be present.
 *
 * @returns The symbol of the token
 */
export function symbol(): string {
  // if symbol has been customized, use it.  otherwise use default
  const symbol = storage.getSome<string>("_symbol");
  DEBUG ? logging.log("[status] Token.symbol: " + symbol) : false;
  return symbol;
}

/**
 * Returns the number of decimals the token uses - ie. 8 - means to divide the
 * token amount by 100000000 (10^8) to get its user representation.
 *
 * OPTIONAL - This method can be used to improve usability, but interfaces and
 *            other contracts MUST NOT expect these values to be present.
 *
 * @returns The number of decimals the token uses
*/
export function decimals(): u8 {
  // if decimals has been customized, use it.  otherwise use default
  const decimals: u8 = storage.getSome<u8>("_decimals");
  DEBUG ? logging.log("[status] Token.decimals: " + decimals.toString()) : false;
  return decimals;
}

// ----------------------------------------------------------------------------
// REQUIRED
// ----------------------------------------------------------------------------

/**
 * Returns the total token supply.
 *
 * @returns The total token supply
 */
export function totalSupply(): u128 {
  // if totalSupply has been customized, use it.  otherwise use default
  const totalSupply: u128 = storage.getSome<u128>("_totalSupply");
  DEBUG ? logging.log("[status] Token.supply: " + totalSupply.toString()) : false;
  return totalSupply;
}

/**
 * Returns the account balance of another account with address `owner`.
 *
 * @param owner The address from which the balance will be retrieved
 * @returns The balance for a given account
 */
export function balanceOf(owner: string): u128 {
  DEBUG ? logging.log("[call] balanceOf(" + owner + ")") : false;

  // let balance: u128 = balances.getSome(owner);
  // let balance: u128 = <u128>balances.get(owner, u128.fromI32(0))!;
  // let balance: u128 = <u128>balances.get(owner, u128.from(0))!;
  // let balance: u128 = balances.get(owner, u128.Zero)!;
  let balance: u128 = <u128>balances.get(owner, u128.Zero);
  DEBUG ? logging.log("[status] " + owner + " has balance " + balance.toString()) : false;

  return balance
}

/**
 * Transfers `value` amount of tokens to address `to`, and MUST fire the Transfer
 * event. The function SHOULD throw if the message caller's account balance
 * does not have enough tokens to spend.
 *
 * Note Transfers of 0 values MUST be treated as normal transfers and fire the
 * Transfer event.
 *
 * @param to The address of the recipient
 * @param value The amount of token to be transferred
 * @returns Whether the transfer was successful or not
 */
export function transfer(to: string, value: u128): boolean {
  DEBUG ? logging.log("[call] transfer(" + to + ", " + value.toString() + ")") : false;

  const sender = context.sender;
  const recipient = to;

  // sender account must exist and have tokens
  assert(sender, "Sender can not be blank")
  assert(balances.contains(sender), "Sender balance cannot be zero")

  // fetch balances for sender and recipient
  const senderBalance = <u128>balances.get(sender, u128.Zero);
  const recipientBalance = <u128>balances.get(to, u128.Zero);

  // sender tokens must be greater than or equal to value being transferred
  assert(senderBalance >= value, "Sender has insufficient funds for transfer");

  // move tokens among accounts
  balances.set(sender, u128.sub(senderBalance, value));
  balances.set(recipient, u128.add(recipientBalance, value));

  // record the transfer event
  let spender = sender;
  recordTransferEvent(spender, spender, to, value);

  return true;
}

/**
 * Transfers `value` amount of tokens from address `from` to address `to`, and
 * MUST fire the `Transfer` event.
 *
 * The transferFrom method is used for a withdraw workflow, allowing contracts
 * to transfer tokens on your behalf. This can be used for example to allow a
 * contract to transfer tokens on your behalf and/or to charge fees in
 * sub-currencies. The function SHOULD throw unless the _from account has
 * deliberately authorized the sender of the message via some mechanism.
 *
 * Note Transfers of 0 values MUST be treated as normal transfers and fire the
 * Transfer event.
 *
 * @param from The address of the sender
 * @param to The address of the recipient
 * @param value The amount of token to be transferred
 * @returns Whether the transfer was successful or not
 */
export function transferFrom(from: string, to: string, value: u128): boolean {
  DEBUG ? logging.log("[call] transferFrom(" + from + ", " + to + ", " + value.toString() + ")") : false;

  const owner = from;
  const spender = context.sender;

  // spender account must exist and be authorized to transfer funds
  assert(spender, "Spender can not be blank")

  // spender must be allowed to transfer this amount
  assert(allowance(owner, spender) >= value, "Spender is not authorized to transfer amount")

  // fetch balances for sender and recipient
  const fromBalance = <u128>balances.get(from, u128.Zero);
  const recipientBalance = <u128>balances.get(to, u128.Zero);

  // sender tokens must be greater than or equal to value being transferred
  assert(fromBalance >= value, "From account has insufficient funds for transfer");

  // move tokens among accounts
  balances.set(from, u128.sub(fromBalance, value));
  balances.set(to, u128.add(recipientBalance, value));

  // decrement allowance by transferred amount as well
  decrementAllowance(owner, spender, value)

  // record the transfer event
  recordTransferEvent(spender, from, to, value);

  return true;
}

/**
 * Allows `spender` to withdraw from your account multiple times, up to the
 * `value` amount. If this function is called again it overwrites the current
 * allowance with `value`.
 *
 * NOTE: To prevent attack vectors like the ones described in the original spec,
 * clients SHOULD make sure to create user interfaces in such a way that
 * they set the allowance first to 0 before setting it to another value for the
 * same spender. THOUGH The contract itself shouldnâ€™t enforce it, to allow
 * backwards compatibility with contracts deployed before
 *
 * @param address The address of the account able to transfer the tokens
 * @param value The amount of tokens to be approved for transfer
 * @returns Whether the approval was successful or not
 */
export function approve(spender: string, value: u128): boolean {
  DEBUG ? logging.log("[call] approve(" + spender + ", " + value.toString() + ")") : false;

  // get owner balance
  const owner = context.sender;
  const balance = <u128>balances.get(owner, u128.Zero);

  // owner must have enough balance to approve this value
  assert(balance >= value, "Owner has insufficient funds for approval")

  // construct key in collection of allowances and fetch old allowance
  const allowancesKey = getAllowancesKey(owner, spender);
  const oldValue = <u128>allowances.get(allowancesKey, u128.Zero);

  // save or update allowance
  allowances.set(allowancesKey, value)

  // record the approval event
  recordApprovalEvent(owner, spender, oldValue, value);

  return true;
}

/**
 * Returns the amount which `spender` is still allowed to withdraw from `owner`.
 *
 * @param owner The address of the account owning tokens
 * @param spender The address of the account able to transfer the tokens
 * @returns Amount of remaining tokens allowed to spent
*/
export function allowance(owner: string, spender: string): u128 {
  DEBUG ? logging.log("[call] allowance(" + owner + ", " + spender + ")") : false;

  // construct key in collection of allowances and return allowance
  const allowancesKey = getAllowancesKey(owner, spender);
  return <u128>allowances.get(allowancesKey, u128.Zero)
}

/**
 * Helper function to decrement allowance
 *
 * @param owner The address of the account owning tokens
 * @param spender The address of the account able to transfer the tokens
 * @param value Amount
 */
function decrementAllowance(owner: string, spender: string, spent: u128): void {
  const allowancesKey = getAllowancesKey(owner, spender);
  const allowance = allowances.getSome(allowancesKey);
  const remaining = u128.sub(allowance, spent);
  allowances.set(allowancesKey, remaining);
}

/**
 * Helper function to standardize the mapping
 *
 * This function would not be needed if we could embed a PersistentMap as
 * the value of another PersistentMap
 *
 * @param owner of the account from which tokens will be spent
 * @param spender of the tokens in the owners account
 */
function getAllowancesKey(owner: string, spender: string): string {
  const separator: string = ":"
  return owner + separator + spender
}

// ----------------------------------------------------------------------------
// BOOK KEEPING
// ----------------------------------------------------------------------------

/**
 * balances of all accounts in the system.  this is the single source of truth for balances
 */
const balances = new PersistentMap<string, u128>("bal");  //  map[owner] = balance

/**
 * allowances of all accounts in the system.  this is the source of truth for allowed spending
 */
// const allowances = new PersistentMap<string, PersistentMap<string, u128>>("a"); // map[owner][spender] = allowance
const allowances = new PersistentMap<string, u128>("alw"); // map[owner:spender] = allowance

// ----------------------------------------------------------------------------
// EXTENDED FUNCTIONALITY
// ----------------------------------------------------------------------------

/**
 * This function supports the customization of this ERC-20 token before initialization
 * It may or may not be called.  If not called, the contract uses sensible defaults
 * If called, it can only be called once (!) and prevents repeat calls
 *
 * NOTE: this function uses storage keys with _underscore prefix since these are guaranteed not
 * to conflict with accounts on the NEAR platform. see https://nomicon.io/DataStructures/Account.html#examples
 *
 * THIS IS NOT part of the ERC-20 spec
 *
 * @param name The name of the token
 * @param symbol The symbol for the token
 * @param decimals The number of decimal places used when rendering the token
 * @param supply The total supply of the tokens
 * @param exchangeRate The exchange rate of tokens
 */

function _customize(
  name: string = "Solidus Wonder Token",        // awesome name for a token
  symbol: string = "SWT",                       // pronounced "sweet", rhymes with "treat"
  decimals: u8 = 2,                             // number of decimal places to assume for rendering,
  supply: u128 = u128.from(100_000_000),        // <raised pinky> one meeeeellion coins ... divisible in 100ths,
  exchangeRate: u8 = 100                        // of these ERC-20 tokens per NEAR token
  ) : void {

  DEBUG ? logging.log("[call] customize('" + name + "', '" + symbol + "', " + decimals.toString() + ", " + supply.toString() + ", " + exchangeRate.toString() + ")") : false;

  const owner = assertTrueOwner()

  // only set values that are provided, otherwise ignore
  storage.setString("_bank", owner);
  storage.setString("_name", name);
  storage.setString("_symbol", symbol);
  storage.set<u8>("_decimals", decimals);
  storage.set<u128>("_totalSupply", supply);
  storage.set<u8>("_exchangeRate", exchangeRate);

}

/**
 * functions with default values can not be exported at this time
 */
export function customize(): void {
  _customize()
}

/**
 * This function initializes the token and assigns the configured total supply to a single account
 * This function may only be called once and prevents subsequent calls
 *
 * THIS IS NOT part of the ERC-20 spec
 */
export function initialize(): void {
  DEBUG ? logging.log("[call] initialize()") : false;

  // make sure the caller is the account that owns the contract
  const owner = assertTrueOwner()
  storage.set("_bank", owner)

  // transfer initial supply to initial owner
  const initialSupply: u128 = storage.getSome<u128>("_totalSupply");
  balances.set(owner, initialSupply);

  DEBUG ? logging.log("[status] Initial owner: " + owner) : false;

  // record the transfer event
  recordTransferEvent("0x0", "0x0", owner, initialSupply);
}

/**
 * A guard clause to prevent any account but the token contract itself from
 * invoking some methods
 *
 * THIS IS NOT part of the ERC-20 spec
 *
 * @returns The string representation of the contract `owner`
 */
function assertTrueOwner(): string {
  // only allow the contract account to invoke this guard clause
  const owner = context.sender

  // the contract name must be available
  assert(context.contractName, "Permission denied: ERR001")
  // the sender of this transaction must be the same account
  assert(owner == context.contractName, "Permission denied: ERR002")

  return owner
}

'''
'''--- contract/events.ts ---
//@nearfile

const DEBUG = false;

import { u128, PersistentDeque, logging } from "near-sdk-as";

// ----------------------------------------------------------------------------
// this file contains models representing events emitted by the contract
// ----------------------------------------------------------------------------

/**
 * originally defined in https://eips.ethereum.org/EIPS/eip-20 as
 *  event Transfer(address indexed _from, address indexed _to, uint256 _value);
 *
 * modifications (additional field `spender`) applied after reading
 *  https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit
 *
 *
 * Transfer
 * MUST trigger when tokens are transferred, including zero value transfers.
 *
 * A token contract which creates new tokens SHOULD trigger a Transfer event
 *    with the _from address set to 0x0 when tokens are created.
 *
 * event Transfer(address indexed _from, address indexed _to, uint256 _value)
 *
 */
export class TransferEvent {
  constructor(
    public spender: string,
    public from: string,
    public to: string,
    public value: u128) {}
}

/**
 * originall defined in https://eips.ethereum.org/EIPS/eip-20 as
 *  event Approval(address indexed _owner, address indexed _spender, uint256 _value);
 *
 * modifications (additional field `oldValue`) applied after reading
 *  https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit
 *
 * Approval
 *
 * MUST trigger on any successful call to approve(address _spender, uint256 _value).
 *
 * event Approval(address indexed _owner, address indexed _spender, uint256 _value)
 *
 */
export class ApprovalEvent {
  constructor(
    public owner: string,
    public spender: string,
    public oldValue: u128,
    public value: u128) {}
}

// setup a queue for transfer events
const transferEvents = new PersistentDeque<TransferEvent>("xfr");

// setup a queue for approval events
const approvalEvents = new PersistentDeque<ApprovalEvent>("apr");

/**
 * This function records transfer events since NEAR doesn't currently support
 * an event model on-chain
 *
 * @param spender
 * @param from
 * @param to
 * @param value
 */
export function recordTransferEvent(spender: string, from: string, to: string, value: u128): void {
  DEBUG ? logging.log("[call] recordTransferEvent(" + spender + ", " + from + ", " + to + ", " + value.toString() + ")") : false;
  const transfer = new TransferEvent(spender, from, to, value);
  transferEvents.pushFront(transfer)
}

/**
 * this function returns the very first recorded transfer event
 *
 * mutates the list of transfer events permanently by removing the earliest
 * event from storage
 */
export function getOldestTransferEvent(): TransferEvent {
  DEBUG ? logging.log("[call] getOldestTransferEvent()") : false;
  return transferEvents.popBack();
}

/**
 * this function returns the most recently recorded transfer event
 *
 * mutates the list of transfer events permanently by removing the most recent
 * event from storage
 */
export function getNewestTransferEvent(): TransferEvent {
  DEBUG ? logging.log("[call] getNewestTransferEvent()") : false;
  return transferEvents.popFront();
}

/**
 * This function records approval events since NEAR doesn't currently support
 * an event model on-chain
 *
 * @param owner
 * @param spender
 * @param oldValue
 * @param value
 */
export function recordApprovalEvent(owner: string, spender: string, oldValue: u128, value: u128): void {
  DEBUG ? logging.log("[call] recordApprovalEvent(" + owner + ", " + spender + ", " + oldValue.toString() + ", " + value.toString() + ")") : false;
  const approval = new ApprovalEvent(owner, spender, oldValue, value);
  approvalEvents.pushFront(approval)
}

/**
 * this function returns the very first recorded approval event
 *
 * mutates the list of approval events permanently by removing the earliest
 * event from storage
 */
export function getOldestApprovalEvent(): ApprovalEvent {
  DEBUG ? logging.log("[call] getOldestApprovalEvent()") : false;
  return approvalEvents.popBack();
}

/**
 * this function returns the most recently recorded approval event
 *
 * mutates the list of approval events permanently by removing the most recent
 * event from storage
 */
export function getNewestApprovalEvent(): ApprovalEvent {
  DEBUG ? logging.log("[call] getNewestApprovalEvent()") : false;
  return approvalEvents.popFront();
}

'''
'''--- contract/tsconfig.json ---
{
  "extends": "assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- gatsby-browser.js ---
/**
 * Implement Gatsby's Browser APIs in this file.
 *
 * See: https://www.gatsbyjs.org/docs/browser-apis/
 */

// You can delete this file if you're not using it
import "semantic-ui-css/semantic.min.css"

'''
'''--- gatsby-config.js ---
module.exports = {
  siteMetadata: {
    title: `10-minute Titles`,
    description: `Self-contained lessons for NEAR Protocol`,
    author: `@nearprotocol`,
  },
  plugins: [
    `gatsby-plugin-react-helmet`,
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        name: `images`,
        path: `${__dirname}/src/images`,
      },
    },
    `gatsby-transformer-sharp`,
    `gatsby-plugin-sharp`,
    {
      resolve: `gatsby-plugin-manifest`,
      options: {
        name: `10-minute-near-tutorials`,
        short_name: `tutorials`,
        start_url: `/`,
        background_color: `#663399`,
        theme_color: `#663399`,
        display: `minimal-ui`,
        icon: `src/images/near_logo_stack.svg`, // This path is relative to the root of the site.
      },
    },
    // this (optional) plugin enables Progressive Web App + Offline functionality
    // To learn more, visit: https://gatsby.dev/offline
    // `gatsby-plugin-offline`,
  ],
}

'''
'''--- gatsby-node.js ---
/**
 * Implement Gatsby's Node APIs in this file.
 *
 * See: https://www.gatsbyjs.org/docs/node-apis/
 */

// You can delete this file if you're not using it
exports.onCreateWebpackConfig = ({ actions }) => {
  actions.setWebpackConfig({
    node: {
      fs: 'empty'
    },
    module: {
      rules: [
        {
          test: /\.wasm$/,
          loaders: ["base64-loader"],
          type: "javascript/auto",
        },
      ],
    },
  })
}

'''
'''--- gatsby-ssr.js ---
/**
 * Implement Gatsby's SSR (Server Side Rendering) APIs in this file.
 *
 * See: https://www.gatsbyjs.org/docs/ssr-apis/
 */

// You can delete this file if you're not using it

'''
'''--- near/config/as-pect.js ---
module.exports = require('wasm-mock-vm/imports');
module.exports.include = ["contract/__tests__/**/*.spec.ts"];
'''
'''--- near/config/context.json ---
{
    "current_account_id": "alice",
    "signer_account_id": "bob",
    "signer_account_pk": "15T",
    "predecessor_account_id": "carol",
    "input": "{\"name\":\"Alice\"}",
    "block_index": 0,
    "account_balance": 0,
    "account_locked_balance": 0,
    "attached_deposit": 0,
    "prepaid_gas": 100000000000000,
    "random_seed": "15T",
    "free_of_charge": false,
    "storage_usage": 0,
    "output_data_receivers": [],
    "block_timestamp": 1,
    "is_view": false
}

'''
'''--- near/config/nodemon.contract.json ---
{
  "restartable": "rs",
  "ignore": [
    "docs/*",
    ".git",
    "node_modules/**/node_modules"
  ],
  "verbose": false,
  "events": {
    "restart": "osascript -e 'display notification \"CONTRACT restarted\"'"
  },
  "watch": [
    "contract",
    "near"
  ],
  "env": {
    "NODE_ENV": "development"
  },
  "ext": "json, ts, js"
}
'''
'''--- near/config/nodemon.web.json ---
{
  "restartable": "rs",
  "ignore": [
    "docs/*",
    ".git",
    "node_modules/**/node_modules"
  ],
  "verbose": false,
  "events": {
    "restart": "osascript -e 'display notification \"WEB restarted\"'"
  },
  "watch": [
    "src",
    "near"
  ],
  "env": {
    "NODE_ENV": "development"
  },
  "ext": "html, js, json"
}
'''
'''--- near/keys/shared-test-staging/test.near.json ---
{"account_id":"test.near","private_key":"ed25519:2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw"}

'''
'''--- near/keys/shared-test/test.near.json ---
{"account_id":"test.near","private_key":"ed25519:2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw"}

'''
'''--- near/scripts/compile-contract.js ---
#!/usr/bin/env node

const compile = require("near-sdk-as/compiler").compile

compile("contract/erc20.ts", // input file
  "static/erc20.wasm", // output file
  [
    //   "-O1",               // Optional arguments
    // "--log-level 3", // Optional arguments
    // "--debug",
    "--measure", // Shows compiler runtime
    "--validate" // Validate the generated wasm module
  ], {
    verbose: true // Output the cli args passed to asc
  });
'''
'''--- package.json ---
{
  "name": "tokens",
  "version": "0.0.1",
  "description": "One of a series of small tutorials under the label 10-min Treats",
  "scripts": {
    "build": "gatsby build",
    "develop": "gatsby develop",
    "format": "prettier --write \"**/*.{js,jsx,json,md}\"",
    "serve": "gatsby serve",
    "clean": "gatsby clean",
    "test": "echo \"Write tests! -> https://gatsby.dev/unit-testing\" && exit 1",
    "test:contract": "asp --config near/config/as-pect.js --verbose",
    "build:contract": "mkdir -p static/ && near/scripts/compile-contract.js",
    "deploy:contract": "near dev-deploy",
    "dev:contract": "npx nodemon --config ./near/config/nodemon.contract.json --exec 'yarn run build:contract'",
    "start": "npm run develop; npm run dev:contract"
  },
  "dependencies": {
    "base64-loader": "^1.0.0",
    "gatsby": "^2.19.45",
    "gatsby-image": "^2.2.44",
    "gatsby-plugin-manifest": "^2.2.48",
    "gatsby-plugin-offline": "^3.0.41",
    "gatsby-plugin-react-helmet": "^3.1.24",
    "gatsby-plugin-sharp": "^2.4.13",
    "gatsby-source-filesystem": "^2.1.56",
    "gatsby-transformer-sharp": "^2.3.19",
    "nearlib": "^0.22.0",
    "prop-types": "^15.7.2",
    "react": "^16.12.0",
    "react-dom": "^16.12.0",
    "react-helmet": "^5.2.1",
    "semantic-ui-css": "^2.4.1",
    "semantic-ui-react": "^0.88.2"
  },
  "devDependencies": {
    "assemblyscript": "^0.9.4",
    "near-sdk-as": "^0.1.3",
    "near-shell": "^0.20.2",
    "node-static": "^0.7.11",
    "nodemon": "^2.0.2",
    "prettier": "^1.19.1"
  },
  "license": "MIT"
}

'''
'''--- src/components/account-card.js ---
import React, { useEffect, useState } from "react"
import { Card, Icon, Transition } from "semantic-ui-react"

const iconForType = type =>
  ({
    bank: "university",
    person: "user circle outline",
  }[type])

const AccountCard = ({ id, name, balance, type, toDecimal }) => {
  const [toggled, setToggled] = useState(true)
  const toggle = () => setToggled(!toggled)

  useEffect(toggle, [balance])

  return (
    <Card>
      <Card.Content>
        <Transition animation="glow" visible={toggled}>
          <Card.Header>
            <Icon name="dot circle outline" />
            {toDecimal(balance)}
          </Card.Header>
        </Transition>
        <Card.Meta>{name}<br />@{id}</Card.Meta>
      </Card.Content>
      <Card.Content extra>
        <Icon name={iconForType(type)} />
        {type === "person" ? "User" : "Bank"} Account
      </Card.Content>
    </Card>
  )
}

export default AccountCard

'''
'''--- src/components/demo-list-item.js ---
import React from "react"
import { Link } from "gatsby"
import {
  Segment,
  Grid,
  Header,
  List,
  ListItem,
  Image,
} from "semantic-ui-react"

import Icon from "./icon"
import bridgeImg from "../images/bridge.jpeg"
import promiseImg from "../images/promise.jpeg"
import tokensImg from "../images/tokens.jpeg"

const imgForDemo = demoId => ({
  token: tokensImg,
  bridge: bridgeImg,
  dapp: promiseImg,
}[demoId])

const Status = ({ ready }) =>
  ready ? (
    <div className="ui positive message">
      <div className="header">Ready</div>
      <p>This lesson is ready for use by a wide audience.</p>
    </div>
  ) : (
    <div className="ui negative message">
      <div className="header">In Progress</div>
      <p>This lesson is still under heavy development.</p>
    </div>
  )

const DemoListItem = (props) => (
  <Segment vertical padded>
    <Grid columns="equal" stackable>
      <Grid.Row>
        <Grid.Column width={8}>
          <Header as="h3">
            {props.title}
          </Header>
          <Status ready={props.ready} />
          <p>{props.shortDesc}</p>
          <p>{props.longDesc}</p>

          <List horizontal>
            {props.icons.map(({ icon, text }, index) => (
              <ListItem key={index}>
                <Icon icon={icon} text={text} />
              </ListItem>
            ))}
          </List>
        </Grid.Column>
        <Grid.Column floated="right" width={6}>
          <Image src={imgForDemo(props.id)} />
        </Grid.Column>
      </Grid.Row>
      <Grid.Row>
        <Grid.Column textAlign="right">
          <a href={props.links.slides} target="_new" className="ui huge button"><i className="tv icon"></i>Slides</a>
          <Link to={"/" + props.links.demo} className={`ui huge blue button ${!props.ready ? 'disabled' : ''}`}>Demo</Link>
          <a href={props.links.code} target="_new" className="ui huge github button"><i className="github icon"></i>Code</a>
        </Grid.Column>
      </Grid.Row>
    </Grid>
  </Segment>
)

export default DemoListItem
'''
'''--- src/components/demo-sidebar.js ---
import React from "react"
import { Step, Icon } from "semantic-ui-react"

const DemoSidebar = ({ steps }) => {
  return (
    <Step.Group vertical size="large">
      {steps.map(step => (
        <Step key={step.title} active={step.active} completed={step.complete}>
          {step.icon && <Icon name={step.icon} />}
          <Step.Content>
            <Step.Title>{step.title}</Step.Title>
            <Step.Description>{step.description}</Step.Description>
          </Step.Content>
        </Step>
      ))}
    </Step.Group>
  )
}

export default DemoSidebar

'''
'''--- src/components/head.js ---
/**
 * Head component that queries for data with
 *  Gatsby's useStaticQuery React hook
 *
 * See: https://www.gatsbyjs.org/docs/use-static-query/
 */

import React from "react"
import PropTypes from "prop-types"
import Helmet from "react-helmet"
import { useStaticQuery, graphql } from "gatsby"

function Head({ description, lang, meta, title, children }) {
  const { site } = useStaticQuery(
    graphql`
      query {
        site {
          siteMetadata {
            title
            description
            author
          }
        }
      }
    `
  )

  const metaDescription = description || site.siteMetadata.description

  return (
    <Helmet
      htmlAttributes={{
        lang,
      }}
      title={title}
      titleTemplate={`%s | ${site.siteMetadata.title}`}
      meta={[
        {
          name: `description`,
          content: metaDescription,
        },
        {
          property: `og:title`,
          content: title,
        },
        {
          property: `og:description`,
          content: metaDescription,
        },
        {
          property: `og:type`,
          content: `website`,
        },
        {
          name: `twitter:card`,
          content: `summary`,
        },
        {
          name: `twitter:creator`,
          content: site.siteMetadata.author,
        },
        {
          name: `twitter:title`,
          content: title,
        },
        {
          name: `twitter:description`,
          content: metaDescription,
        },
      ].concat(meta)}
    >
      {children}
    </Helmet>
  )
}

Head.defaultProps = {
  lang: `en`,
  meta: [],
  description: ``,
  children: ''
}

Head.propTypes = {
  description: PropTypes.string,
  lang: PropTypes.string,
  meta: PropTypes.arrayOf(PropTypes.object),
  title: PropTypes.string.isRequired,
  children: PropTypes.node,
}

export default Head

'''
'''--- src/components/icon.js ---
import React from "react"

import css3 from "../images/icon/css3.svg"
import ethereum from "../images/icon/ethereum.svg"
import html5 from "../images/icon/html5.svg"
import javascript from "../images/icon/javascript.svg"
import node from "../images/icon/node-dot-js.svg"
import rust from "../images/icon/rust.svg"
import typescript from "../images/icon/typescript.svg"
import webassembly from "../images/icon/webassembly.svg"

const iconMap = {
  css3,
  ethereum,
  html5,
  javascript,
  node,
  rust,
  typescript,
  webassembly,
}

export default function Icon({ icon, text }) {
  const iconImg = iconMap[icon]

  return (
    <div className="ui large image label">
      <img src={iconImg} alt={`${icon} icon`} />
      {text}
    </div>
  )
}
'''
'''--- src/components/layout.js ---
import React from "react"
import PropTypes from "prop-types"

import "../styles/main.css"

const Layout = ({ children }) => {
  return (
    <>
      <main>{children}</main>
    </>
  )
}

Layout.propTypes = {
  children: PropTypes.node.isRequired,
}

export default Layout

'''
'''--- src/components/near-login.js ---
import React from "react"
import { Button, Icon } from "semantic-ui-react"

export default class NearLogin extends React.Component {
  constructor(props) {
    super(props)

    this.state = { isSignedIn: props.wallet.isSignedIn() }

    this.signIn = this.signIn.bind(this)
    this.signOut = this.signOut.bind(this)
  }

  signIn() {
    const signIn = {
      account: null,
      title: "10 min Titles by NEAR",
      successUrl: "",
      failureUrl: "",
    }
    this.props.wallet.requestSignIn(
      signIn.account,
      signIn.title,
      signIn.successUrl,
      signIn.failureUrl
    )
  }

  signOut() {
    this.props.wallet.signOut()

    this.setState({ isSignedIn: false })
  }

  render() {
    const signInButton = (
      <Button onClick={this.signIn} size="huge" color="blue" id="login">
        Sign in with NEAR
        <Icon className="right" name="sign-in"></Icon>
      </Button>
    )

    const signOutButton = (
      <Button onClick={this.signOut} size="huge" color="orange" id="login">
        Sign out
        <Icon className="right" name="sign-out"></Icon>
      </Button>
    )

    return this.state.isSignedIn ? signOutButton : signInButton
  }
}

'''
'''--- src/components/near.js ---
import React from "react"
import * as nearlib from "nearlib";

export default class Near extends React.Component {
  async componentDidMount() {
    // configure network settings and key storage
    const config = {
      networkId: 'default', // this can be any label to namespace user accounts
      nodeUrl: "https://rpc.nearprotocol.com", // this endpoint must point to the network you want to reach
      walletUrl: "https://wallet.nearprotocol.com", // this endpoint must exist for the wallet to work
      helperUrl: 'https://near-contract-helper.onrender.com',
      deps: {
        keyStore: new nearlib.keyStores.BrowserLocalStorageKeyStore() // keys are stored as plaintext in LocalStorage
      }
    };

    window.near = await nearlib.connect(config); // connect to the NEAR platform
    window.wallet = new nearlib.WalletAccount(window.near) // instantiate a new wallet

    if (window.wallet.getAccountId() !== '') {
      window.near.config.masterAccount = window.wallet.getAccountId()
    }

    console.info(`connected to near with masterAccount = [${window.near.config.masterAccount}]`)

    if (this.props.onLoaded) this.props.onLoaded({ near: window.near, wallet: window.wallet })
  }

  render() {
    return null
  }
}

'''
'''--- src/components/token/allocate-tokens.js ---
import React, { useState } from "react"
import { Grid, Header, Form, Input, Button, Icon } from "semantic-ui-react"

import AccountCard from "../account-card"

const AllocateTokens = ({
  token,
  accounts,
  toDecimal,
  onTransfer,
  onContinue,
}) => {
  const { bank, alice } = accounts
  const [amount, setAmount] = useState(Math.round(token.supply / 4))
  const [canContinue, setCanContinue] = useState(false)

  const handleAllocate = () => {
    onTransfer({
      from: "bank",
      to: "alice",
      amount: Number(amount),
    })

    setCanContinue(true)
  }

  return (
    <Grid>
      <Grid.Row>
        <Grid.Column>
          <Header color="grey" as="h3">
            <Header.Content>
              Accounts
              <Header.Subheader>
                Move {token.symbol} to {alice.name}
              </Header.Subheader>
            </Header.Content>
          </Header>
        </Grid.Column>
      </Grid.Row>
      <Grid.Row>
        <Grid.Column width={6}>
          <AccountCard {...bank} toDecimal={toDecimal} />
        </Grid.Column>
        <Grid.Column width={4}>
          <Form onSubmit={handleAllocate}>
            <Form.Field>
              <label>
                Amount ({token.symbol})
                <Input
                  type="number"
                  value={amount}
                  onChange={(_, { value }) => setAmount(value)}
                />
              </label>
            </Form.Field>
            <Button primary type="submit">
              Allocate
              <Icon name="arrow circle right" />
            </Button>
          </Form>
        </Grid.Column>
        <Grid.Column width={6}>
          <AccountCard {...alice} toDecimal={toDecimal} />
        </Grid.Column>
      </Grid.Row>
      <Grid.Row>
        <Grid.Column>
          <hr />
          <Button onClick={onContinue} disabled={!canContinue}>
            Continue
          </Button>
        </Grid.Column>
      </Grid.Row>
    </Grid>
  )
}

export default AllocateTokens

'''
'''--- src/components/token/allowance-transfers.js ---
import React, { useState, useEffect } from "react"
import {
  Grid,
  Header,
  Button,
  Icon,
  List,
  Form,
  Input,
} from "semantic-ui-react"

import AccountCard from "../account-card"

const AllowanceTransfers = ({
  token,
  accounts,
  toDecimal,
  onApproval,
  onSpend,
}) => {
  const { alice: owner, bob: spender, carol: receiver } = accounts
  const [allowance, setAllowance] = useState(null)
  const [allowanceChangeEvents, setAllowanceChangeEvents] = useState([])
  const [allowanceAmount, setAllowanceAmount] = useState(100)
  const [transferAmount, setTransferAmount] = useState(100)
  const [canAllow, setCanAllow] = useState(true)
  const [canSpend, setCanSpend] = useState(false)

  const registerAllowanceChange = () => {
    if (allowance === null) return
    const { spender, owner, amount } = allowance
    setAllowanceChangeEvents([
      ...allowanceChangeEvents,
      `@${spender} is approved by @${owner} to xfer ${amount}`,
    ])
  }

  const listError = error => {
    setAllowanceChangeEvents([...allowanceChangeEvents, error.message])
  }

  useEffect(registerAllowanceChange, [allowance])

  const handleApproval = () => {
    const allowance = {
      owner: owner.id,
      spender: spender.id,
      amount: Number(allowanceAmount),
    }

    try {
      onApproval(allowance)
      setAllowance(allowance)
      setCanAllow(false)
      setCanSpend(true)
    } catch (error) {
      listError(error)
    }
  }

  const handleSpend = () => {
    // TODO: make the allowance amount reflect actual state

    try {
      if (transferAmount > allowance.amount) {
        throw new Error("Cannot transfer more than allowed.")
      }

      onSpend({
        spender: spender.id,
        from: owner.id,
        to: receiver.id,
        amount: Number(transferAmount),
      })
      setAllowanceChangeEvents([
        ...allowanceChangeEvents,
        `@${spender.id} transferred ${transferAmount} from @${owner.id} to ${receiver.id}`,
      ])
      setAllowance({
        ...allowance,
        amount: allowance.amount - Number(transferAmount),
      })
    } catch (error) {
      listError(error)
    }
  }

  return (
    <Grid>
      <Grid.Row>
        <Grid.Column>
          <Header color="grey" as="h3">
            <Header.Content>
              Accounts
              <Header.Subheader>
                Allow {spender.name} to transfer on behalf of {owner.name}
              </Header.Subheader>
            </Header.Content>
          </Header>
        </Grid.Column>
      </Grid.Row>
      <Grid.Row>
        <Grid.Column width={8}>
          <Grid>
            <Grid.Row>
              <Grid.Column width={8}>
                <AccountCard {...owner} toDecimal={toDecimal} />
              </Grid.Column>
              <Grid.Column width={8}>
                <AccountCard {...spender} toDecimal={toDecimal} />
              </Grid.Column>
            </Grid.Row>
          </Grid>
        </Grid.Column>
        <Grid.Column width={8}>
          <AccountCard {...receiver} toDecimal={toDecimal} />
        </Grid.Column>
      </Grid.Row>
      <Grid.Row>
        <Grid.Column width={8}>
          <Grid>
            <Grid.Row>
              <Grid.Column>
                <Header as="h4">Approvals</Header>
                <List>
                  {allowanceChangeEvents.map((message, index) => (
                    <List.Item key={index}>{message}</List.Item>
                  ))}
                </List>
              </Grid.Column>
            </Grid.Row>
            <Grid.Row>
              <Grid.Column>
                <Form onSubmit={handleApproval}>
                  <Form.Group inline>
                    <Form.Field>
                      <label htmlFor="amount">
                        <Input
                          type="number"
                          name="amount"
                          value={allowanceAmount}
                          onChange={(_, { value }) => setAllowanceAmount(value)}
                        />
                      </label>
                    </Form.Field>
                    <Button primary type="submit" disabled={!canAllow}>
                      Approve Allowance
                    </Button>
                  </Form.Group>
                </Form>
              </Grid.Column>
            </Grid.Row>
          </Grid>
        </Grid.Column>
        <Grid.Column width={8}>
          <Grid>
            <Grid.Row>
              <Grid.Column width={8}>
                <Form onSubmit={handleSpend}>
                  <Form.Group>
                    <Form.Field>
                      <label>
                        Amount ({token.symbol})
                        <Input
                          type="number"
                          value={transferAmount}
                          onChange={(_, { value }) => setTransferAmount(value)}
                        />
                      </label>
                    </Form.Field>
                    <Button primary type="submit" disabled={!canSpend}>
                      Transfer
                      <Icon name="arrow circle right" />
                    </Button>
                  </Form.Group>
                </Form>
              </Grid.Column>
            </Grid.Row>
          </Grid>
        </Grid.Column>
      </Grid.Row>
    </Grid>
  )
}

export default AllowanceTransfers

'''
'''--- src/components/token/configure-token.js ---
import React from "react"
import { Form, Header, Input, Button } from "semantic-ui-react"

const ConfigureToken = ({ token, onSave }) => {
  const handleChange = (e, { name, value }) => (token[name] = value)

  const handleSubmit = () => onSave(token)

  return (
    <Form size="large" onSubmit={handleSubmit}>
      <Header dividing>ERC-20 Token Configuration</Header>
      <Form.Group>
        <Form.Field width={7}>
          <label htmlFor="name">
            Token Name
            <Input
              type="text"
              placeholder={token.name}
              name="name"
              onChange={handleChange}
            />
          </label>
        </Form.Field>
        <Form.Field width={2}>
          <label htmlFor="symbol">
            Symbol
            <Input
              type="text"
              placeholder={token.symbol}
              name="symbol"
              onChange={handleChange}
            />
          </label>
        </Form.Field>
        <Form.Field width={2}>
          <label htmlFor="decimals">
            Decimals
            <Input
              type="number"
              placeholder={token.decimals}
              name="decimals"
              onChange={handleChange}
            />
          </label>
        </Form.Field>
        <Form.Field width={4}>
          <label htmlFor="supply">
            Total Supply
            <Input
              type="number"
              placeholder={token.supply}
              name="supply"
              onChange={handleChange}
            />
          </label>
        </Form.Field>
      </Form.Group>
      <Button primary type="submit">
        Save
      </Button>
    </Form>
  )
}

export default ConfigureToken

'''
'''--- src/components/token/deploy-token.js ---
import React from "react"
import { Button } from "semantic-ui-react"

const DeployToken = ({ token, onDeploy, isDeploying = false }) => (
  <Button size="huge" primary loading={isDeploying} onClick={onDeploy}>Deploy "{token.name}"!</Button>
)

export default DeployToken

'''
'''--- src/components/token/saved-token-header.js ---
import React from "react"
import {
  Icon,
  Header,
  Label,
  Segment,
} from "semantic-ui-react"

const SavedTokenHeader = ({ token, toDecimal }) => (
  <Segment inverted>
    <Header as="h2" inverted color="grey">
      {token.deployed && (
        <Label attached="top right" color="green" size="large" horizontal>
          DEPLOYED
        </Label>
      )}
      <Icon name="dot circle outline" />
      <Header.Content>
        {token.name}
        <Header.Subheader>
          [{token.symbol}]: {toDecimal(token.supply)}
        </Header.Subheader>
      </Header.Content>
    </Header>
  </Segment>
)

export default SavedTokenHeader

'''
'''--- src/components/token/transfer-tokens.js ---
import React, { useState } from "react"
import { Grid, Header, Form, Input, Button, Icon } from "semantic-ui-react"

import AccountCard from "../account-card"

const TransferTokens = ({
  token,
  accounts,
  toDecimal,
  onTransfer,
  onContinue,
}) => {
  const { alice, bob } = accounts
  const [amount, setAmount] = useState(100)
  const [canContinue, setCanContinue] = useState(false)

  const handleTransfer = () => {
    onTransfer({
      from: alice.id,
      to: bob.id,
      amount: Number(amount),
    })
    setCanContinue(true)
  }

  return (
    <Grid>
      <Grid.Row>
        <Grid.Column>
          <Header color="grey" as="h3">
            <Header.Content>
              Accounts
              <Header.Subheader>
                Move {token.symbol} from {alice.name} to {bob.name}
              </Header.Subheader>
            </Header.Content>
          </Header>
        </Grid.Column>
      </Grid.Row>
      <Grid.Row>
        <Grid.Column width={6}>
          <AccountCard {...alice} toDecimal={toDecimal} />
        </Grid.Column>
        <Grid.Column width={4}>
          <Form onSubmit={handleTransfer}>
            <Form.Field>
              <label>
                Amount ({token.symbol})
                <Input
                  type="number"
                  value={amount}
                  onChange={(_, { value }) => setAmount(value)}
                />
              </label>
            </Form.Field>
            <Button primary type="submit">
              Transfer
              <Icon name="arrow circle right" />
            </Button>
          </Form>
        </Grid.Column>
        <Grid.Column width={6}>
          <AccountCard {...bob} toDecimal={toDecimal} />
        </Grid.Column>
      </Grid.Row>
      <Grid.Row>
        <Grid.Column>
          <hr />
          <Button onClick={onContinue} disabled={!canContinue}>
            Continue
          </Button>
        </Grid.Column>
      </Grid.Row>
    </Grid>
  )
}

export default TransferTokens

'''
'''--- src/contract.js ---
import * as nearlib from "nearlib"
import _ from "lodash"

const TOKEN_CONTRACT = "/erc20.wasm"
const CONTRACT_ID = "example-erc20"
const DEFAULT_GAS = "10000000000000"

const log = message => console.info(message)

const logExplorerLink = (message, hash) => {
  const explorer = "https://explorer.nearprotocol.com"
  const tx = "transactions"
  log(message)
  log(`${explorer}/${tx}/${hash}`)
}

const makeUniqueId = id => `${id}-${+new Date()}`

// Steps:
// 1. create new account (to own contract)
// 2. deploy contract to account
// 3. call `customize` (must happen _before_ calling `initialize`)
// 4. call `initialize`
// 5. store contract
// 6. create user accounts (alice, bob, carol)
let baseContract

// Exports
// (with mocks)
// TODO: replace mocks w/ real functions

export function mockDeployAndSetupContract(config) {
  log("IN mockDeployAndSetupContract():")
  log(`- Calling makeAccount(makeUniqueId(${CONTRACT_ID}))`)
  log("- Calling deployContract(account)")
  log("- Calling customizeContract(account, config)")
  log("- Calling initializeContract(account)")
  log("- Returning new mock contract")
  return {
    contractId: "FAKE_CONTRACT",
    totalSupply: () => Promise.resolve(config.supply),
  }
}
export async function deployAndSetupContract(config) {
  // FIXME: creating new accounts fails on TESTNET when Funnel account "test"
  // doesn't have enough NEAR tokens :(
  // API returns 400 `Error: Sender "test" does not have enough balance`
  const account = await makeAccount(makeUniqueId(CONTRACT_ID))

  await deployContract(account)
  await customizeContract(account, config)
  await initializeContract(account)

  baseContract = await getContract(account.accountId)
  return baseContract
}

export function mockMakeAccountWithContract(id, contractId) {
  log("IN mockMakeAccountWithContract():")
  log(`- Calling makeAccount(makeUniqueId(${id}))`)
  log("- Calling getContract(contractId, account.accountId)")
  log("- Returning mock { account, contract }")
  return {
    account: {
      accountId: id,
    },
    contract: {
      contractId: `${id}-${contractId}`,
    },
  }
}
export async function makeAccountWithContract(id, contractId) {
  const account = await makeAccount(makeUniqueId(id))
  const contract = await getContract(contractId, account.accountId)

  return { account, contract }
}

export function mockTransfer(contract, { to, amount }) {
  log("IN mockTransfer():")
  log(`- Calling transfer({ to: "${to}", value: "${amount}" })`)
  log(`  Using sender: "${contract.contractId}"`)
}
export async function transfer(contract, { to, amount }) {
  const transferParams = { to, value: _.toString(amount) }
  return await contract.transfer(transferParams)
}

export function mockTransferFrom(contract, { from, to, value }) {
  log("IN mockTransferFrom():")
  log(`- Calling transferFrom({ from: "${from}", to: "${to}", value: "${value}" })`)
  log(`  Using sender: "${contract.contractId}"`)
}
export async function transferFrom(contract, { from, to, value }) {}

export function mockApprove(contract, { spender, value }) {
  log("IN mockApprove():")
  log(`- Approving "${spender}" to with allowance "${value}"`)
  log(`  Using sender: "${contract.contractId}"`)
}
export async function approve(contract, { spender, value }) {}

export async function allowance(contract, { owner, spender }) {}

export async function makeAccount(accountId) {
  log(`Making account with id: ${accountId}...`)
  const keyPair = nearlib.utils.KeyPair.fromRandom("ed25519")

  /**
   * https://github.com/near/near-api-js/blob/master/src.ts/near.ts#L41
   */
  const account = await window.near.createAccount(
    accountId,
    keyPair.getPublicKey()
  )

  await window.near.connection.signer.keyStore.setKey(
    window.near.config.networkId,
    account.accountId,
    keyPair
  )

  log(`Account created! [${accountId}]`)
  return account
}

async function loadCompiledContract() {
  // taken from:
  // https://github.com/metanear/metanear-web/blob/master/src/Home.js#L89
  const data = await fetch(TOKEN_CONTRACT)
  const buf = await data.arrayBuffer()
  return new Uint8Array(buf)
}

async function deployContract(account) {
  const compiledContract = await loadCompiledContract()
  const response = await account.deployContract(compiledContract)
  logExplorerLink("contract deployed", response.transaction.hash)
}

async function customizeContract(account, config) {
  const customizeResponse = await account.functionCall(
    account.accountId,
    "customize",
    {}, // TODO: pass args to customize to set name, symbol, etc.
    DEFAULT_GAS
  )
  logExplorerLink(
    "function [customize] called",
    customizeResponse.transaction.hash
  )
}

async function initializeContract(account) {
  const initializeResponse = await account.functionCall(
    account.accountId,
    "initialize",
    {},
    DEFAULT_GAS
  )
  logExplorerLink(
    "function [initialize] called",
    initializeResponse.transaction.hash
  )
}

export async function getContract(contractAccountId, senderAccountId) {
  return await window.near.loadContract(contractAccountId, {
    viewMethods: [
      "name",
      "symbol",
      "decimals",
      "totalSupply",
      "balanceOf",
      "allowance",
    ],
    changeMethods: ["transfer", "transferFrom", "approve"],
    sender: senderAccountId || window.wallet.getAccountId(),
  })
}

'''
'''--- src/data/accounts.json ---
{
  "bank": {
    "id": "bank",
    "name": "Central Bank",
    "balance": 0,
    "type": "bank",
    "color": "black"
  },
  "alice": {
    "id": "alice",
    "name": "Alice",
    "balance": 0,
    "type": "person",
    "color": "red"
  },
  "bob": {
    "id": "bob",
    "name": "Bob",
    "balance": 0,
    "type": "person",
    "color": "blue"
  },
  "carol": {
    "id": "carol",
    "name": "Carol",
    "balance": 0,
    "type": "person",
    "color": "orange"
  }
}
'''
'''--- src/data/demos.json ---
{
  "token": {
    "id": "token",
    "ready": true,
    "title": "Exploring ERC-20 Tokens",
    "shortDesc": "Learn to build a fungible token using NEAR Protocol.",
    "longDesc": "We briefly touch on both ERC-20 and ERC-721 before implementing a demo application that lets you issue and interact with your own ERC-20 token.",
    "links": {
      "slides": "https://docs.google.com/presentation/d/13gjojRbZmPg5RexTzXUBMP8mfc26mOmijx1H54mOOxM",
      "demo": "token",
      "code": "github.com/near-examples/10-min-token"
    },
    "icons": [
      { "icon": "html5", "text": "HTML" },
      { "icon": "css3", "text": "CSS" },
      { "icon": "javascript", "text": "JavaScript" },
      { "icon": "webassembly", "text": "AssemblyScript" }
    ],
    "steps": [
      {
        "icon": "puzzle piece",
        "title": "Design the Token",
        "description": "Configure token parameters"
      },
      {
        "icon": "upload",
        "title": "Deploy the Token",
        "description": "Publish to the blockchain"
      },
      {
        "icon": "money bill alternate",
        "title": "Allocate Tokens",
        "description": "Distribute to user accounts"
      },
      {
        "icon": "exchange",
        "title": "Transfer Tokens",
        "description": "Move between accounts"
      },
      {
        "icon": "unlock alternate",
        "title": "Transfer Allowances",
        "description": "Authorize third party for transfer"
      }
    ]
  },
  "dapp": {
    "id": "dapp",
    "ready": false,
    "title": "Exploring a Simple Web-based dApp",
    "shortDesc": "Learn to build a simple distributed application using NEAR Protocol.",
    "longDesc": "We explore a simple dApp modeled after one of hackathon submissions. This dApp let's you make a public promise (a statement or commitment) to someone which they later mark as fulfilled.",
    "links": {
      "slides": "https://docs.google.com/presentation/d/1KOJwtOJRn4cFHuTVIcj4vlH-i-htqaw3A-RTgw38WRo",
      "demo": "dapp",
      "code": "github.com/near-examples/10-min-dapp"
    },
    "icons": [
      { "icon": "html5", "text": "HTML" },
      { "icon": "css3", "text": "CSS" },
      { "icon": "javascript", "text": "JavaScript" },
      { "icon": "rust", "text": "Rust" }
    ]
  },
  "bridge": {
    "id": "bridge",
    "ready": false,
    "title": "Exploring The NEAR-Ethereum Bridge",
    "shortDesc": "Learn to work with the NEAR-Ethereum bridge.",
    "longDesc": "We review the architecture of the bridge and discuss specific use cases and extension points that you can leverage for your own requirements.",
    "links": {
      "slides": "https://docs.google.com/presentation/d/1bZFeyJx1JzfGsh8RH9gFnbdB2RRy--5Z6Af5gNIUuIs",
      "demo": "bridge",
      "code": "github.com/near-examples/10-min-bridge"
    },
    "icons": [
      { "icon": "node", "text": "Node" },
      { "icon": "rust", "text": "Rust" },
      { "icon": "ethereum", "text": "Solidity" }
    ]
  }
}
'''
'''--- src/images/icon/css3.svg ---
<svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>CSS3 icon</title><path d="M1.5 0h21l-1.91 21.563L11.977 24l-8.565-2.438L1.5 0zm17.09 4.413L5.41 4.41l.213 2.622 10.125.002-.255 2.716h-6.64l.24 2.573h6.182l-.366 3.523-2.91.804-2.956-.81-.188-2.11h-2.61l.29 3.855L12 19.288l5.373-1.53L18.59 4.414z"/></svg>
'''
'''--- src/images/icon/ethereum.svg ---
<svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Ethereum icon</title><path d="M11.944 17.97L4.58 13.62 11.943 24l7.37-10.38-7.372 4.35h.003zM12.056 0L4.69 12.223l7.365 4.354 7.365-4.35L12.056 0z"/></svg>
'''
'''--- src/images/icon/html5.svg ---
<svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>HTML5 icon</title><path d="M1.5 0h21l-1.91 21.563L11.977 24l-8.564-2.438L1.5 0zm7.031 9.75l-.232-2.718 10.059.003.23-2.622L5.412 4.41l.698 8.01h9.126l-.326 3.426-2.91.804-2.955-.81-.188-2.11H6.248l.33 4.171L12 19.351l5.379-1.443.744-8.157H8.531z"/></svg>
'''
'''--- src/images/icon/javascript.svg ---
<svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>JavaScript icon</title><path d="M0 0h24v24H0V0zm22.034 18.276c-.175-1.095-.888-2.015-3.003-2.873-.736-.345-1.554-.585-1.797-1.14-.091-.33-.105-.51-.046-.705.15-.646.915-.84 1.515-.66.39.12.75.42.976.9 1.034-.676 1.034-.676 1.755-1.125-.27-.42-.404-.601-.586-.78-.63-.705-1.469-1.065-2.834-1.034l-.705.089c-.676.165-1.32.525-1.71 1.005-1.14 1.291-.811 3.541.569 4.471 1.365 1.02 3.361 1.244 3.616 2.205.24 1.17-.87 1.545-1.966 1.41-.811-.18-1.26-.586-1.755-1.336l-1.83 1.051c.21.48.45.689.81 1.109 1.74 1.756 6.09 1.666 6.871-1.004.029-.09.24-.705.074-1.65l.046.067zm-8.983-7.245h-2.248c0 1.938-.009 3.864-.009 5.805 0 1.232.063 2.363-.138 2.711-.33.689-1.18.601-1.566.48-.396-.196-.597-.466-.83-.855-.063-.105-.11-.196-.127-.196l-1.825 1.125c.305.63.75 1.172 1.324 1.517.855.51 2.004.675 3.207.405.783-.226 1.458-.691 1.811-1.411.51-.93.402-2.07.397-3.346.012-2.054 0-4.109 0-6.179l.004-.056z"/></svg>
'''
'''--- src/images/icon/node-dot-js.svg ---
<svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Node.js icon</title><path d="M11.998,24c-0.321,0-0.641-0.084-0.922-0.247l-2.936-1.737c-0.438-0.245-0.224-0.332-0.08-0.383 c0.585-0.203,0.703-0.25,1.328-0.604c0.065-0.037,0.151-0.023,0.218,0.017l2.256,1.339c0.082,0.045,0.197,0.045,0.272,0l8.795-5.076 c0.082-0.047,0.134-0.141,0.134-0.238V6.921c0-0.099-0.053-0.192-0.137-0.242l-8.791-5.072c-0.081-0.047-0.189-0.047-0.271,0 L3.075,6.68C2.99,6.729,2.936,6.825,2.936,6.921v10.15c0,0.097,0.054,0.189,0.139,0.235l2.409,1.392 c1.307,0.654,2.108-0.116,2.108-0.89V7.787c0-0.142,0.114-0.253,0.256-0.253h1.115c0.139,0,0.255,0.112,0.255,0.253v10.021 c0,1.745-0.95,2.745-2.604,2.745c-0.508,0-0.909,0-2.026-0.551L2.28,18.675c-0.57-0.329-0.922-0.945-0.922-1.604V6.921 c0-0.659,0.353-1.275,0.922-1.603l8.795-5.082c0.557-0.315,1.296-0.315,1.848,0l8.794,5.082c0.57,0.329,0.924,0.944,0.924,1.603 v10.15c0,0.659-0.354,1.273-0.924,1.604l-8.794,5.078C12.643,23.916,12.324,24,11.998,24z M19.099,13.993 c0-1.9-1.284-2.406-3.987-2.763c-2.731-0.361-3.009-0.548-3.009-1.187c0-0.528,0.235-1.233,2.258-1.233 c1.807,0,2.473,0.389,2.747,1.607c0.024,0.115,0.129,0.199,0.247,0.199h1.141c0.071,0,0.138-0.031,0.186-0.081 c0.048-0.054,0.074-0.123,0.067-0.196c-0.177-2.098-1.571-3.076-4.388-3.076c-2.508,0-4.004,1.058-4.004,2.833 c0,1.925,1.488,2.457,3.895,2.695c2.88,0.282,3.103,0.703,3.103,1.269c0,0.983-0.789,1.402-2.642,1.402 c-2.327,0-2.839-0.584-3.011-1.742c-0.02-0.124-0.126-0.215-0.253-0.215h-1.137c-0.141,0-0.254,0.112-0.254,0.253 c0,1.482,0.806,3.248,4.655,3.248C17.501,17.007,19.099,15.91,19.099,13.993z"/></svg>
'''
'''--- src/images/icon/rust.svg ---
<svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Rust icon</title><path d="M23.687 11.709l-.995-.616a13.559 13.559 0 0 0-.028-.29l.855-.797a.344.344 0 0 0-.114-.571l-1.093-.409a8.392 8.392 0 0 0-.086-.282l.682-.947a.342.342 0 0 0-.223-.538l-1.152-.187a9.243 9.243 0 0 0-.139-.259l.484-1.063c.05-.108.039-.234-.027-.332s-.178-.156-.297-.152l-1.17.041a6.662 6.662 0 0 0-.185-.224l.269-1.139a.343.343 0 0 0-.412-.412l-1.139.269a13.847 13.847 0 0 0-.225-.185l.041-1.17a.34.34 0 0 0-.484-.324l-1.063.485c-.086-.047-.172-.094-.259-.139l-.188-1.153a.344.344 0 0 0-.538-.223l-.948.682a8.383 8.383 0 0 0-.282-.085L14.562.596a.344.344 0 0 0-.571-.114l-.797.856a9.18 9.18 0 0 0-.29-.028l-.616-.995a.342.342 0 0 0-.582 0l-.616.995c-.097.008-.194.018-.29.028l-.798-.856a.342.342 0 0 0-.571.114l-.409 1.093c-.095.027-.188.056-.282.085l-.947-.682a.344.344 0 0 0-.538.223l-.188 1.153a9.243 9.243 0 0 0-.259.139l-1.063-.485a.342.342 0 0 0-.484.324l.041 1.17c-.076.06-.151.122-.225.185l-1.139-.269a.343.343 0 0 0-.412.412l.268 1.139c-.062.074-.124.149-.184.224l-1.17-.041a.342.342 0 0 0-.324.484l.485 1.063a9.055 9.055 0 0 0-.139.259l-1.152.187a.344.344 0 0 0-.223.538l.682.947c-.03.094-.058.187-.086.282L.59 9.435a.344.344 0 0 0-.114.571l.855.797a9.18 9.18 0 0 0-.028.29l-.995.616a.34.34 0 0 0 0 .582l.995.616c.008.097.018.194.028.29l-.855.798a.342.342 0 0 0 .114.571l1.093.409c.027.095.056.189.086.282l-.682.947a.341.341 0 0 0 .224.538l1.152.187c.045.087.091.173.139.259l-.485 1.063a.342.342 0 0 0 .324.484l1.169-.041c.061.076.122.151.185.225l-.268 1.14a.342.342 0 0 0 .412.411l1.139-.268c.074.063.149.124.225.184l-.041 1.17a.34.34 0 0 0 .484.323l1.063-.484c.086.048.172.094.259.139l.188 1.152a.344.344 0 0 0 .538.224l.947-.682c.094.03.187.059.282.086l.409 1.093a.341.341 0 0 0 .571.114l.798-.855c.096.011.193.02.29.029l.616.995a.343.343 0 0 0 .582 0l.616-.995c.097-.009.194-.018.29-.029l.797.855a.344.344 0 0 0 .571-.114l.409-1.093c.095-.027.189-.056.282-.086l.947.682a.341.341 0 0 0 .538-.224l.188-1.152c.087-.045.173-.092.259-.139l1.063.484a.343.343 0 0 0 .484-.323l-.041-1.17c.076-.06.151-.121.224-.184l1.139.268a.343.343 0 0 0 .412-.411l-.268-1.14c.062-.074.124-.149.184-.225l1.17.041a.34.34 0 0 0 .324-.484l-.484-1.063c.047-.086.094-.172.139-.259l1.152-.187a.344.344 0 0 0 .223-.538l-.682-.947.086-.282 1.093-.409a.342.342 0 0 0 .114-.571l-.855-.798c.01-.096.02-.193.028-.29l.995-.616a.34.34 0 0 0 0-.582zm-6.659 8.253a.705.705 0 0 1 .295-1.379.705.705 0 1 1-.296 1.379zm-.338-2.286a.641.641 0 0 0-.762.494l-.353 1.648c-1.09.495-2.3.77-3.575.77a8.63 8.63 0 0 1-3.65-.804l-.353-1.648a.64.64 0 0 0-.762-.493l-1.455.312a8.615 8.615 0 0 1-.752-.887h7.08c.08 0 .134-.014.134-.087v-2.505c0-.073-.053-.087-.134-.087h-2.071v-1.588h2.24c.204 0 1.093.058 1.377 1.194.089.349.284 1.486.418 1.85.133.408.675 1.223 1.253 1.223h3.528a.74.74 0 0 0 .128-.013 8.68 8.68 0 0 1-.802.941l-1.489-.32zm-9.793 2.252a.705.705 0 1 1-.296-1.379.705.705 0 0 1 .296 1.379zM4.211 9.036a.705.705 0 1 1-1.288.572.705.705 0 0 1 1.288-.572zm-.825 1.957l1.516-.674a.642.642 0 0 0 .326-.848l-.312-.706h1.228v5.534H3.667a8.668 8.668 0 0 1-.28-3.307zm6.652-.537V8.825h2.924c.151 0 1.066.175 1.066.859 0 .568-.702.772-1.279.772h-2.711zm10.626 1.468c0 .216-.008.431-.024.643h-.889c-.089 0-.125.058-.125.146v.408c0 .961-.542 1.17-1.017 1.223-.452.051-.953-.189-1.015-.466-.267-1.5-.711-1.821-1.413-2.374.871-.553 1.777-1.369 1.777-2.461 0-1.179-.809-1.922-1.36-2.287-.773-.51-1.629-.612-1.86-.612H5.545a8.658 8.658 0 0 1 4.847-2.736l1.084 1.137a.64.64 0 0 0 .907.021l1.212-1.16a8.668 8.668 0 0 1 5.931 4.224l-.83 1.875a.644.644 0 0 0 .326.848l1.598.71c.028.284.042.57.042.861zm-9.187-9.482a.703.703 0 1 1 .972 1.019.705.705 0 0 1-.972-1.019zm8.237 6.628c.157-.356.573-.516.928-.358a.705.705 0 1 1-.929.359z"/></svg>
'''
'''--- src/images/icon/typescript.svg ---
<svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>TypeScript icon</title><path d="M0 12v12h24V0H0zm19.341-.956c.61.152 1.074.423 1.501.865.221.236.549.666.575.77.008.03-1.036.73-1.668 1.123-.023.015-.115-.084-.217-.236-.31-.45-.633-.644-1.128-.678-.728-.05-1.196.331-1.192.967a.88.88 0 0 0 .102.45c.16.331.458.53 1.39.933 1.719.74 2.454 1.227 2.911 1.92.51.773.625 2.008.278 2.926-.38.998-1.325 1.676-2.655 1.9-.411.073-1.386.062-1.828-.018-.964-.172-1.878-.648-2.442-1.273-.221-.243-.652-.88-.625-.925.011-.016.11-.077.22-.141.108-.061.511-.294.892-.515l.69-.4.145.214c.202.308.643.731.91.872.766.404 1.817.347 2.335-.118a.883.883 0 0 0 .313-.72c0-.278-.035-.4-.18-.61-.186-.266-.567-.49-1.649-.96-1.238-.533-1.771-.864-2.259-1.39a3.165 3.165 0 0 1-.659-1.2c-.091-.339-.114-1.189-.042-1.531.255-1.197 1.158-2.03 2.461-2.278.423-.08 1.406-.05 1.821.053zm-5.634 1.002l.008.983H10.59v8.876H8.38v-8.876H5.258v-.964c0-.534.011-.98.026-.99.012-.016 1.913-.024 4.217-.02l4.195.012z"/></svg>
'''
'''--- src/images/icon/webassembly.svg ---
<svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>WebAssembly icon</title><path d="M14.745,0c0,0.042,0,0.085,0,0.129c0,1.52-1.232,2.752-2.752,2.752c-1.52,0-2.752-1.232-2.752-2.752 c0-0.045,0-0.087,0-0.129H0v24h24V0H14.745z M11.454,21.431l-1.169-5.783h-0.02l-1.264,5.783H7.39l-1.824-8.497h1.59l1.088,5.783 h0.02l1.311-5.783h1.487l1.177,5.854h0.02l1.242-5.854h1.561l-2.027,8.497H11.454z M20.209,21.431l-0.542-1.891h-2.861l-0.417,1.891 h-1.59l2.056-8.497h2.509l2.5,8.497H20.209z M17.812,15.028l-0.694,3.118h2.159l-0.796-3.118H17.812z"/></svg>
'''
'''--- src/images/near_logo_stack.svg ---
<svg viewBox="0 0 180 225" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="39.61" x2="140.37" y1="140.37" y2="39.61"><stop offset=".21" stop-color="#24272a"/><stop offset=".42" stop-color="#24272a" stop-opacity="0"/><stop offset=".59" stop-color="#24272a" stop-opacity="0"/><stop offset=".81" stop-color="#24272a"/></linearGradient><g fill="#24272a"><path d="m58.6 162.38v26.24a.38.38 0 0 1 -.37.38h-2.76a3.73 3.73 0 0 1 -3.14-1.71l-12.4-19.16.43 9.57v10.92a.38.38 0 0 1 -.36.38h-3.6a.38.38 0 0 1 -.38-.38v-26.24a.38.38 0 0 1 .38-.38h2.71a3.75 3.75 0 0 1 3.15 1.71l12.39 19.12-.39-9.53v-10.92a.38.38 0 0 1 .38-.38h3.61a.38.38 0 0 1 .35.38z"/><path d="m95.51 189h-3.83a.37.37 0 0 1 -.34-.51l10.11-26.13a.56.56 0 0 1 .55-.36h4.78a.55.55 0 0 1 .52.36l10.12 26.13a.37.37 0 0 1 -.35.51h-3.82a.37.37 0 0 1 -.35-.24l-8.16-21.52a.38.38 0 0 0 -.7 0l-8.16 21.52a.39.39 0 0 1 -.37.24z"/><path d="m143.92 188.39-7.59-9.69c4.28-.81 6.79-3.7 6.79-8.14 0-5.09-3.32-8.56-9.18-8.56h-10.58a.57.57 0 0 0 -.57.56 3.61 3.61 0 0 0 3.61 3.61h7.08c3.55 0 5.24 1.81 5.24 4.43s-1.65 4.48-5.24 4.48h-10.12a.57.57 0 0 0 -.57.56v13a.38.38 0 0 0 .38.38h3.61a.38.38 0 0 0 .37-.38v-9.69h4.17l6.59 8.6a3.74 3.74 0 0 0 3 1.47h2.74a.38.38 0 0 0 .27-.63z"/><path d="m84.09 162h-16.76a.5.5 0 0 0 -.5.5 3.67 3.67 0 0 0 3.67 3.67h13.59a.38.38 0 0 0 .37-.38v-3.41a.38.38 0 0 0 -.37-.38zm0 22.83h-12.52a.37.37 0 0 1 -.38-.37v-6.77a.38.38 0 0 1 .38-.38h11.55a.37.37 0 0 0 .38-.37v-3.42a.37.37 0 0 0 -.38-.37h-15.72a.57.57 0 0 0 -.57.56v14.73a.57.57 0 0 0 .57.56h16.69a.38.38 0 0 0 .37-.38v-3.41a.38.38 0 0 0 -.37-.38z"/></g><path d="m48.34 144a12.32 12.32 0 0 0 9.35-4.28l84.42-97.93a12.32 12.32 0 0 0 -10.45-5.79 12.31 12.31 0 0 0 -9.31 4.24l-84.83 97.35a12.34 12.34 0 0 0 10.82 6.41z" fill="url(#a)"/><path d="m48.34 144a12.38 12.38 0 0 0 5.66-1.37v-81.77l65.58 78.7a12.37 12.37 0 0 0 9.49 4.44h2.59a12.35 12.35 0 0 0 12.34-12.34v-83.32a12.35 12.35 0 0 0 -12.34-12.34 12.45 12.45 0 0 0 -5.66 1.35v81.79l-65.58-78.7a12.37 12.37 0 0 0 -9.49-4.44h-2.59a12.35 12.35 0 0 0 -12.34 12.34v83.32a12.35 12.35 0 0 0 12.34 12.34z" fill="#24272a"/></svg>
'''
'''--- src/pages/404.js ---
import React from "react"

import Layout from "../components/layout"
import Head from "../components/head"

const NotFoundPage = () => (
  <Layout>
    <Head title="404: Not found" />
    <h1>NOT FOUND</h1>
    <p>You just hit a route that doesn&#39;t exist... the sadness.</p>
  </Layout>
)

export default NotFoundPage

'''
'''--- src/pages/index.js ---
import React, { useState } from "react"
import { Segment, Container, Header, Image } from "semantic-ui-react"

import Layout from "../components/layout"
import Head from "../components/head"
import Near from "../components/near"
import NearLogin from "../components/near-login"
import DemoListItem from "../components/demo-list-item"

import nearLogoStack from "../images/near_logo_stack.svg"
import demos from "../data/demos"

const IndexPage = () => {
  const [wallet, setWallet] = useState(null)

  const onNearLibLoad = ({ wallet }) => setWallet(wallet)

  return (
    <Layout>
      <Near onLoaded={onNearLibLoad} />
      <Head title="10-minute Titles" />
      <Segment inverted vertical className="masthead center aligned">
        <Container text>
          <Header as="h1" inverted size="huge">
            10-minute Titles
          </Header>
          <h2>Self-contained lessons for NEAR Protocol</h2>
          {wallet && <NearLogin wallet={wallet} />}
          <Image src={nearLogoStack} size="large" rounded centered />
        </Container>
      </Segment>

      <Container>
        {Object.values(demos).map((demo, index) => (
          <DemoListItem key={index} {...demo} />
        ))}
      </Container>
    </Layout>
  )
}

export default IndexPage

'''
'''--- src/pages/token.js ---
import React from "react"
import { Grid, Container, Header, Transition, Segment } from "semantic-ui-react"

import Layout from "../components/layout"
import Head from "../components/head"
import Near from "../components/near"
import DemoSidebar from "../components/demo-sidebar"
import ConfigureToken from "../components/token/configure-token"
import DeployToken from "../components/token/deploy-token"
import AllocateTokens from "../components/token/allocate-tokens"
import TransferTokens from "../components/token/transfer-tokens"
import AllowanceTransfers from "../components/token/allowance-transfers"
import SavedTokenHeader from "../components/token/saved-token-header"

import { decimalize } from "../utils"
import {
  mockDeployAndSetupContract,
  // deployAndSetupContract,
  mockMakeAccountWithContract,
  // makeAccountWithContract,
  mockTransfer,
  // transfer,
  mockTransferFrom,
  // transferFrom,
  mockApprove,
  // approve,
} from "../contract"

import { token as demo } from "../data/demos"
import accounts from "../data/accounts"

const STEP_TRANSITION_DURATION = 1000

const defaultToken = {
  name: "My Amazing Token",
  symbol: "MAT",
  decimals: 0,
  supply: 1000000,
  saved: false,
  deployed: false,
}
export default class TokenDemo extends React.Component {
  constructor(props) {
    super(props)

    const steps = demo.steps.map((step, index) => ({
      ...step,
      active: index === 0,
      complete: false,
    }))

    // TODO: refactor to use useState React hook
    this.state = {
      steps,
      token: defaultToken,
      accounts,
      isDeploying: false,
    }
    this.nextStep = this.nextStep.bind(this)
    this.tokenDecimalizer = this.tokenDecimalizer.bind(this)
    this.saveToken = this.saveToken.bind(this)
    this.deployToken = this.deployToken.bind(this)
    this.transfer = this.transfer.bind(this)
    this.approve = this.approve.bind(this)
    this.spendAllowance = this.spendAllowance.bind(this)
  }

  get activeStepIndex() {
    const activeIndex = this.state.steps.findIndex(s => s.active)
    return activeIndex
  }

  tokenDecimalizer(amt) {
    const { token } = this.state
    return decimalize(amt, token.decimals)
  }

  nextStep(delay = STEP_TRANSITION_DURATION) {
    const currentActive = this.activeStepIndex
    let nextActive

    const steps = this.state.steps.map((step, index) => {
      if (step.active) {
        step.active = false
        nextActive = index + 1
      }
      return step
    })

    this.setState({ steps })

    const activateNext = () => {
      steps[currentActive].complete = true
      steps[nextActive].active = true
      this.setState({ steps })
    }

    if (delay > 0) setTimeout(activateNext, delay)
    else activateNext()
  }

  saveToken(token) {
    token.saved = true
    this.setState({ token })

    this.nextStep()
  }

  async deployToken() {
    this.setState({ isDeploying: true })
    try {
      // TODO: re-enable actual deploy/setup contract
      // const contract = await deployAndSetupContract(this.state.token)
      const contract = mockDeployAndSetupContract(this.state.token)

      const { token, accounts } = this.state
      token.deployed = true
      token.contractId = contract.contractId
      accounts.bank.nearContract = contract
      accounts.bank.balance = await contract.totalSupply()
      this.setState({ token, accounts })

      this.createUserAccountsInBackground({ contractId: contract.contractId })

      this.nextStep()
    } catch (error) {
      console.error("TokenDemo -> deployToken -> error", error)
    }
    this.setState({ isDeploying: false })
  }

  createUserAccountsInBackground({ contractId }) {
    const { accounts } = this.state
    Object.values(accounts).forEach(async ({ id, type }) => {
      if (type === "person") {
        try {
          // TODO: re-enable actual acct creation
          // const { account, contract } = await makeAccountWithContract(id, contractId)
          const { account, contract } = mockMakeAccountWithContract(id, contractId)
          accounts[id].nearAccount = account
          accounts[id].nearContract = contract
          this.setState({ accounts })
        } catch (error) {
          console.error(error)
          alert("Oops. Something went wrong. Please refresh and start over.")
        }
      }
    })
  }

  async transfer({ from, to, amount }) {
    const { accounts } = this.state
    const contract = accounts[from].nearContract
    const fromBalance = accounts[from].balance

    if (amount > fromBalance) {
      return alert(`Insufficient balance. Cannot transfer ${amount} from ${from}.`)
    }

    // TODO: re-enable actual transfer
    mockTransfer(contract, { to, amount })
    // await transfer(contract, { to, amount })

    // TODO: reflect actual state change from NEAR RPC call
    accounts[from].balance = accounts[from].balance - amount
    accounts[to].balance = accounts[to].balance + amount
    this.setState({ accounts })
  }

  approve({ owner, spender, amount }) {
    const { accounts } = this.state
    const contract = accounts[owner].nearContract
    const ownerBalance = accounts[owner].balance

    if (amount > ownerBalance) {
      throw new Error(`Cannot approve allowance (${amount}) greater than balance (${ownerBalance})`)
    }

    // TODO: use NEAR RPC call and reflect actual state change
    mockApprove(contract, { spender, value: amount })
  }

  spendAllowance({ spender, from, to, amount }) {
    const { accounts } = this.state
    const contract = accounts[spender].nearContract

    // TODO: use NEAR RPC call and reflect actual state change
    mockTransferFrom(contract, { from, to, value: amount })

    accounts[from].balance = accounts[from].balance - amount
    accounts[to].balance = accounts[to].balance + amount
    this.setState({ accounts })
  }

  get stepComponent() {
    return [
      // Step 1: configure token
      <ConfigureToken token={this.state.token} onSave={this.saveToken} />,
      // Step 2: deploy token
      <DeployToken
        token={this.state.token}
        isDeploying={this.state.isDeploying}
        onDeploy={this.deployToken}
      />,
      // Step 3.1: use token: allocate tokens to user
      <AllocateTokens
        token={this.state.token}
        accounts={this.state.accounts}
        toDecimal={this.tokenDecimalizer}
        onTransfer={this.transfer}
        onContinue={this.nextStep}
      />,
      // Step 3.2: use token: transfer tokens between users
      <TransferTokens
        token={this.state.token}
        accounts={this.state.accounts}
        toDecimal={this.tokenDecimalizer}
        onTransfer={this.transfer}
        onContinue={this.nextStep}
      />,
      // Step 3.3: use token: mediate transfer between users
      <AllowanceTransfers
        token={this.state.token}
        accounts={this.state.accounts}
        toDecimal={this.tokenDecimalizer}
        onApproval={this.approve}
        onSpend={this.spendAllowance}
      />,
    ]
  }

  render() {
    return (
      <Layout>
        <Near onLoaded={() => console.info("NEAR library loaded.")} />
        <Head title={demo.title} />
        <Container>
          <Grid padded>
            <Grid.Row>
              <Grid.Column>
                <Segment vertical stacked>
                  <Header as="h1">{demo.title}</Header>
                </Segment>
              </Grid.Column>
            </Grid.Row>
            <Grid.Row>
              <Grid.Column width={5}>
                <DemoSidebar steps={this.state.steps} />
              </Grid.Column>
              <Grid.Column width={11}>
                <Transition
                  visible={!!this.state.token.saved}
                  animation="scale"
                  duration={500}
                >
                  <SavedTokenHeader token={this.state.token} toDecimal={this.tokenDecimalizer} />
                </Transition>
                <Transition.Group
                  animation="fade"
                  duration={STEP_TRANSITION_DURATION}
                >
                  {this.activeStepIndex >= 0 && (
                    <Segment vertical>
                      {this.stepComponent[this.activeStepIndex]}
                    </Segment>
                  )}
                </Transition.Group>
              </Grid.Column>
            </Grid.Row>
          </Grid>
        </Container>
      </Layout>
    )
  }
}

'''
'''--- src/styles/main.css ---
:root {
  --h1-font-size: 32px;
  --h2-font-size: 28px;
  --h6-font-size: 20px;
  --nav-font-size: 14px;
  --footer-font-size: 18px;
  --cls-4-font-size: 72px;
  --near-color-black: #1a1c1f;
  --near-color-slate: #4b4f54;
  --near-color-red: #ff585d;
  --near-color-blue: #6ad1e3;
  --near-color-yellow-light: #fcfbe5;
  --near-color-yellow: #f0ec74;
  --near-color-yellow-dark: #c5c25f;
  --near-color-royal: #0072ce;
  --color-error: red;
  --color-footer: #23262a;
  --near-font-headlines: 'BwSeidoRound-Medium', sans-serif;
  --near-font-body: 'Benton-Sans', sans-serif;
}

body {
  font-family: var(--near-font-body);
}

.hidden.menu {
  display: none;
}

.masthead .logo.item img {
  margin-right: 1em;
}

.masthead .ui.menu .ui.button {
  margin-left: 0.5em;
}

.masthead h1.ui.header {
  margin-top: 2.5em;
  margin-bottom: 0em;
  font-size: 4em;
  font-weight: normal;
}

.masthead h2 {
  font-size: 1.7em;
  font-weight: normal;
}

.ui.vertical.stripe {
  padding: 8em 0em;
}

.ui.vertical.stripe h3 {
  font-size: 2em;
}

.ui.vertical.stripe .button+h3,
.ui.vertical.stripe p+h3 {
  margin-top: 3em;
}

.ui.vertical.stripe .floated.image {
  clear: both;
}

.ui.vertical.stripe p {
  font-size: 1.33em;
}

.ui.vertical.stripe .horizontal.divider {
  margin: 3em 0em;
}

.quote.stripe.segment {
  padding: 0em;
}

.quote.stripe.segment .grid .column {
  padding-top: 5em;
  padding-bottom: 5em;
}

.footer.segment {
  padding: 5em 0em;
}

.secondary.pointing.menu .toc.item {
  display: none;
}

@media only screen and (max-width: 700px) {
  .ui.fixed.menu {
    display: none !important;
  }
  .secondary.pointing.menu .item,
  .secondary.pointing.menu .menu {
    display: none;
  }
  .secondary.pointing.menu .toc.item {
    display: block;
  }
  .masthead.segment {
    min-height: 350px;
  }
  .masthead h1.ui.header {
    font-size: 2em;
    margin-top: 1.5em;
  }
  .masthead h2 {
    margin-top: 0.5em;
    font-size: 1.5em;
  }
}
'''
'''--- src/utils.js ---
export function decimalize(int, numDecimals) {
  return (int / 10 ** numDecimals).toFixed(numDecimals)
}
'''