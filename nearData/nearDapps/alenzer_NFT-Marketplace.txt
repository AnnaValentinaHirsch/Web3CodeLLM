*GitHub Repository "alenzer/NFT-Marketplace"*

'''--- .eslintrc.js ---
module.exports = {
	parserOptions: {
		ecmaVersion: 2020,
        sourceType: 'module',
        ecmaFeatures: {
            jsx: true,
        }
    },
	rules: {
        semi: [2, 'always'],
        indent: [2, 'tab'],
	}
};

'''
'''--- jest.config.js ---
module.exports = {
    testEnvironment: "node",
	testTimeout: 30000,
	globals: {
		Uint8Array: Uint8Array,
	},
};
'''
'''--- server/app.js ---
const express = require('express');
const cors = require('cors');
const nearAPI = require('near-api-js');
const getConfig = require('../src/config');
const { withNear } = require('./middleware/near');
const { near, contractAccount } = require('./utils/near-utils');
const { contractName, networkId, GAS, contractMethods, GUESTS_ACCOUNT_SECRET } = getConfig();
const {
	Account,
	KeyPair,
	utils: {
		format: {
			parseNearAmount
		}
	}
} = nearAPI;

const app = express();
const port = 3000;

app.use(cors());
app.use(express.json());
app.use(withNear());

app.get('/', (req, res) => {
	res.send('Hello World!');
});

/// WARNING NO RESTRICTION ON THIS ENDPOINT
app.post('/add-guest', async (req, res) => {
	const { account_id, public_key } = req.body;
	const contractId = account_id.substr(account_id.indexOf('.') + 1);
	/// setup signer for guestAccount txs
	const guestId = 'guests.' + contractId;
	const guestKeyPair = KeyPair.fromString(GUESTS_ACCOUNT_SECRET);
	near.connection.signer.keyStore.setKey(networkId, guestId, guestKeyPair);
	const guestsAccount = new Account(near.connection, guestId);
	/// try adding key to guestAccount and guest record to contract
	console.log('\nAdding guest account:', account_id);
	try {
		const addKey = await guestsAccount.addKey(public_key, contractId, contractMethods.changeMethods, parseNearAmount('0.1'));
		const add_guest = await contractAccount.functionCall(contractId, 'add_guest', { account_id, public_key }, GAS);
		res.json({ success: true, result: { addKey, add_guest } });
	} catch(e) {
		console.log(e);
		return res.status(403).send({ error: `error adding guest`, e});
	}
});

app.listen(port, () => {
	console.log(`\nContract Account ID:\n${contractName}\nListening at http://localhost:${port}`);
});
'''
'''--- server/middleware/near.js ---

const nacl = require('tweetnacl');
const crypto = require('crypto');
const bs58 = require('bs58');
const { near, connection, contractAccount } = require('../utils/near-utils');

const withNear = () => (req, res, next) => {
	req.near = near;
	next();
};

const VALID_BLOCK_AGE = 100;

const validBlock = async (blockNumber) => {
	const currentBlock = (await connection.provider.status()).sync_info.latest_block_height;
	const givenBlock = Number(blockNumber);
	if (givenBlock <= currentBlock - VALID_BLOCK_AGE || givenBlock > currentBlock) {
		return false;
	}
	return true;
};

const verifySignature = async (accountId, data, signature, contractName = '') => {
	const nearAccount = await near.account(accountId);
	try {
		const hash = crypto.createHash('sha256').update(data).digest();
		let accessKeys = await nearAccount.getAccessKeys();
		if (contractName.length) {
			accessKeys = accessKeys.filter(({ access_key: { permission }}) => permission && permission.FunctionCall && permission.FunctionCall.receiver_id === contractName);
		} else {
			accessKeys = accessKeys.filter(({ access_key: { permission }}) => permission === 'FullAccess');
		}
		return accessKeys.some(({ public_key }) => {
			const publicKey = public_key.replace('ed25519:', '');
			return nacl.sign.detached.verify(hash, Buffer.from(signature, 'base64'), bs58.decode(publicKey));
		});
	} catch (e) {
		console.error(e);
		return false;
	}
};

const hasAccessKey = async (req, res, next) => {
	const { accountId, contractName, blockNumber, blockNumberSignature } = req.body;
    
	if (!accountId || !contractName || !blockNumber || !blockNumberSignature) {
		return res.status(403).send({ error: 'You must provide an accountId, contractName, blockNumber, and blockNumberSignature' });
	}

	if (!(await validBlock(blockNumber))) {
		return res.status(403).send({ error: `You must provide a blockNumber within ${VALID_BLOCK_AGE} of the most recent block; provided: ${blockNumber}, current: ${currentBlock}`});
	}

	if (!(await verifySignature(accountId, blockNumber, blockNumberSignature, contractName))) {
		return res.status(403).send({ error: `blockNumberSignature did not match a signature of blockNumber=${blockNumber} from accountId=${accountId}`});
	}

	return await next();
};

module.exports = {
	contractAccount,
	withNear,
	hasAccessKey,
};
'''
'''--- server/utils/near-utils.js ---
const fs = require('fs');
const nearAPI = require('near-api-js');
const getConfig = require('../../src/config');
const { nodeUrl, networkId, contractName, contractMethods, accessKeyMethods } = getConfig();
const {
	keyStores: { InMemoryKeyStore },
	Near, Account, Contract, KeyPair,
} = nearAPI;

const credentials = JSON.parse(fs.readFileSync(process.env.HOME + '/.near-credentials/default/' + contractName + '.json'));
const keyStore = new InMemoryKeyStore();
keyStore.setKey(networkId, contractName, KeyPair.fromString(credentials.private_key));
const near = new Near({
	networkId, nodeUrl,
	deps: { keyStore },
});
const { connection } = near;
const contractAccount = new Account(connection, contractName);
const contract = new Contract(contractAccount, contractName, contractMethods);

module.exports = {
	near,
	keyStore,
	connection,
	contract,
	contractName,
	contractAccount,
	accessKeyMethods,
};
'''
'''--- src/App.js ---
import React, { useContext, useEffect, useState } from 'react';

import { appStore, onAppMount } from './state/app';

import { Wallet } from './components/Wallet';
import { Contract } from './components/Contract';
import { Gallery } from './components/Gallery';

import Avatar from 'url:./img/avatar.jpg';
import NearLogo from 'url:./img/near_icon.svg';

import './App.scss';

const App = () => {
	const { state, dispatch, update } = useContext(appStore);

	const { app, app: {tab}, near, wallet, contractAccount, account, loading } = state;

	const [profile, setProfile] = useState(false);

	const onMount = () => {
		dispatch(onAppMount());
	};
	useEffect(onMount, []);

	const signedIn = ((wallet && wallet.signedIn));

	if (profile && !signedIn) {
		setProfile(false);
	}

	return <>
		{ loading && <div className="loading">
			<img src={NearLogo} />
		</div>
		}

		<div className="background"></div>

		<div id="menu">
			<div>
				<img style={{ opacity: signedIn ? 1 : 0.25 }} src={Avatar}
					onClick={() => setProfile(!profile)}
				/>
			</div>
			<div>
				{!signedIn ? <Wallet {...{ wallet }} /> : account.accountId}
			</div>
			{
				profile && signedIn && <div id="profile">
					<div>
						{
							wallet && wallet.signedIn && <Wallet {...{ wallet, account, update, dispatch, handleClose: () => setProfile(false) }} />
						}
					</div>
				</div>
			}
		</div>

		{
			signedIn && <div id="tabs">
				<div onClick={() => update('app.tab', 1)} style={{ background: tab === 1 ? '#fed' : '' }}>Market</div>
				<div onClick={() => update('app.tab', 2)} style={{ background: tab === 2 ? '#fed' : '' }}>My NFTs</div>
				<div onClick={() => update('app.tab', 3)} style={{ background: tab === 3 ? '#fed' : '' }}>Mint</div>
			</div>
		}

		{ signedIn && tab === 3 &&
			<div id="contract">
				{
					signedIn &&
					<Contract {...{ near, update, wallet, account }} />
				}
			</div>
		}
		<div id="gallery">
			<Gallery {...{ app, update, loading, contractAccount, account }} />
		</div>
	</>;
};

export default App;

'''
'''--- src/components/Contract.js ---
import React, {useEffect, useState} from 'react';
import * as nearAPI from 'near-api-js';
import { GAS, parseNearAmount } from '../state/near';
import { 
	contractId,
	isAccountTaken,
	networkId,
} from '../utils/near-utils';

const {
	KeyPair,
} = nearAPI;

export const Contract = ({ near, update, account }) => {
	if (!account) return <p>Please connect your NEAR Wallet</p>;

	const [media, setMedia] = useState('');
	const [validMedia, setValidMedia] = useState('');
	const [royalties, setRoyalties] = useState({});
	const [royalty, setRoyalty] = useState([]);
	const [receiver, setReceiver] = useState([]);

	const handleMint = async () => {
		if (!media.length || !validMedia) {
			alert('Please enter a valid Image Link. You should see a preview below!');
			return;
		}

		// shape royalties data for minting and check max is < 20%
		let perpetual_royalties = Object.entries(royalties).map(([receiver, royalty]) => ({
			[receiver]: royalty * 100
		})).reduce((acc, cur) => Object.assign(acc, cur), {});
		if (Object.values(perpetual_royalties).reduce((a, c) => a + c, 0) > 2000) {
			return alert('Cannot add more than 20% in perpetual NFT royalties when minting');
		}
		
		update('loading', true);
		const metadata = { 
			media,
			issued_at: Date.now().toString()
		};
		const deposit = parseNearAmount('0.1');
		await account.functionCall(contractId, 'nft_mint', {
			token_id: 'token-' + Date.now(),
			metadata,
			perpetual_royalties
		}, GAS, deposit);
		checkFreebies();
		update('loading', false);
		setMetadata('');
	};

	return <>
		<h4>Mint Something</h4>
		<input className="full-width" placeholder="Image Link" value={media} onChange={(e) => setMedia(e.target.value)} />
		<img src={media} onLoad={() => setValidMedia(true)} onError={() => setValidMedia(false)} />
		
		{ !validMedia && <p>Image link is invalid.</p> }
		
		<h4>Royalties</h4>
		{
			Object.keys(royalties).length > 0 ? 
				Object.entries(royalties).map(([receiver, royalty]) => <div key={receiver}>
					{receiver} - {royalty} % <button onClick={() => {
						delete royalties[receiver];
						setRoyalties(Object.assign({}, royalties));
					}}>❌</button>
				</div>)
				:
				<p>No royalties added yet.</p>
		}
		<input className="full-width" placeholder="Account ID" value={receiver} onChange={(e) => setReceiver(e.target.value)} />
		<input type="number" className="full-width" placeholder="Percentage" value={royalty} onChange={(e) => setRoyalty(e.target.value)} />
		<button onClick={async () => {
			const exists = await isAccountTaken(receiver);
			if (!exists) return alert(`Account: ${receiver} does not exist on ${networkId ==='default' ? 'testnet' : 'mainnet'}.`);
			setRoyalties(Object.assign({}, royalties, {
				[receiver]: royalty
			}));
		}}>Add Royalty</button>

		<div className="line"></div>

		<button onClick={() => handleMint()}>Mint</button>
	</>;
};

'''
'''--- src/components/Gallery.js ---
import React, { useEffect, useState } from 'react';
import * as nearAPI from 'near-api-js';
import { GAS, parseNearAmount } from '../state/near';
import {
	marketId,
	contractId,
	formatAccountId,
} from '../utils/near-utils';

const ADD_SALE = '__ADD_SALE';

const {
	KeyPair,
	utils: { format: { formatNearAmount } }
} = nearAPI;

const token2symbol = {
	"near": "NEAR",
	// "dai": "DAI",
	// "usdc": "USDC",
	// "usdt": "USDT",
};

const n2f = (amount) => parseFloat(parseNearAmount(amount, 8));

const sortFunctions = {
	1: (a, b) => parseInt(a.metadata.issued_at || '0') - parseInt(b.metadata.issued_at || '0'),
	2: (b, a) => parseInt(a.metadata.issued_at || '0') - parseInt(b.metadata.issued_at || '0'),
	3: (a, b) => n2f((a.conditions || {near: '0'}).near) - n2f((b.conditions || {near: '0'}).near),
	4: (b, a) => n2f((a.conditions || {near: '0'}).near) - n2f((b.conditions || {near: '0'}).near),
};
const allTokens = Object.keys(token2symbol);

const getTokenOptions = (value, setter, accepted = allTokens) => (
	<select value={value} onChange={(e) => setter(e.target.value)}>
		{
			accepted.map((value) => <option key={value} value={value}>{token2symbol[value]}</option>)
		}
	</select>);

export const Gallery = ({ app, update, contractAccount, account, loading }) => {
	if (!contractAccount) return null;

	const { tab, sort, filter } = app;

	let accountId = '';
	if (account) accountId = account.accountId;

	/// market
	const [sales, setSales] = useState([]);
	const [allTokens, setAllTokens] = useState([]);
	const [offerPrice, setOfferPrice] = useState('');
	const [offerToken, setOfferToken] = useState('near');

	/// updating user tokens
	const [tokens, setTokens] = useState([]);
	const [storage, setStorage] = useState(false);
	const [price, setPrice] = useState('');
	const [token, setToken] = useState('near');
	const [saleConditions, setSaleConditions] = useState([]);

	useEffect(() => {
		if (!loading) loadItems();
	}, [loading]);

	const loadItems = async () => {
		if (accountId.length) {
			setStorage(await contractAccount.viewFunction(marketId, 'storage_paid', { account_id: account.accountId }));
		}
		/// users tokens
		if (account) {
			const tokens = await contractAccount.viewFunction(contractId, 'nft_tokens_for_owner', {
				account_id: account.accountId,
				from_index: '0',
				limit: '50'
			});
			const sales = await contractAccount.viewFunction(marketId, 'get_sales_by_owner_id', {
				account_id: account.accountId,
				from_index: '0',
				limit: '50'
			});
			// merge tokens with sale data if it's on sale
			for (let i = 0; i < tokens.length; i++) {
				const { token_id } = tokens[i];
				let sale = sales.find(({ token_id: t }) => t === token_id);
				// don't have it in state, go find sale data
				if (!sale) {
					sale = await contractAccount.viewFunction(marketId, 'get_sale', { nft_contract_token: contractId + ":" + token_id }).catch(() => { });
				}
				tokens[i] = Object.assign(tokens[i], sale || {});
			}
			setTokens(tokens);
		}

		/// all sales
		const sales = await contractAccount.viewFunction(marketId, 'get_sales_by_nft_contract_id', {
			nft_contract_id: contractId,
			from_index: '0',
			limit: '100'
		});
		const tokens = await contractAccount.viewFunction(contractId, 'nft_tokens_batch', {
			token_ids: sales.filter(({ nft_contract_id }) => nft_contract_id === contractId).map(({ token_id }) => token_id)
		});
		// merge sale listing with nft token data
		for (let i = 0; i < sales.length; i++) {
			const { token_id } = sales[i];
			let token = tokens.find(({ token_id: t }) => t === token_id);
			// don't have it in batch, go find token data
			if (!token) {
				token = await contractAccount.viewFunction(contractId, 'nft_token', { token_id });
			}
			sales[i] = Object.assign(sales[i], token);
		}
		setSales(sales);

		// all tokens
		const allTokens = await contractAccount.viewFunction(contractId, 'nft_tokens', {
			from_index: '0',
			limit: '100'
		});
		console.log(allTokens);
		setAllTokens(allTokens);
	};

	/// setters

	const handleOffer = async (token_id) => {
		if (offerToken !== 'near') {
			return alert('currently only accepting NEAR offers');
		}
		if (offerToken === 'near') {
			await account.functionCall(marketId, 'offer', {
				nft_contract_id: contractId,
				token_id,
			}, GAS, parseNearAmount(offerPrice));
		} else {
			///todo ft_transfer_call

		}
	};

	const handleAcceptOffer = async (token_id, ft_token_id) => {
		if (ft_token_id !== 'near') {
			return alert('currently only accepting NEAR offers');
		}
		await account.functionCall(marketId, 'accept_offer', {
			nft_contract_id: contractId,
			token_id,
			ft_token_id,
		}, GAS);
	};

	const handleRegisterStorage = async () => {
		const storageMarket = await account.viewFunction(marketId, 'storage_amount', {}, GAS);
		await account.functionCall(marketId, 'storage_deposit', {}, GAS, storageMarket).catch(() => { });
	};

	const handleSaleUpdate = async (token_id, newSaleConditions) => {
		const sale = await contractAccount.viewFunction(marketId, 'get_sale', { nft_contract_token: contractId + ":" + token_id }).catch(() => { });
		if (sale) {
			await account.functionCall(marketId, 'update_price', {
				nft_contract_id: contractId,
				token_id,
				ft_token_id: newSaleConditions[0].ft_token_id,
				price: newSaleConditions[0].price
			}, GAS);
		} else {
			await account.functionCall(contractId, 'nft_approve', {
				token_id,
				account_id: marketId,
				msg: JSON.stringify({ sale_conditions: newSaleConditions })
			}, GAS, parseNearAmount('0.01'));
		}
	};

	let market = sales;
	if (tab !== 2 && filter === 1) {
		market = market.concat(allTokens.filter(({ token_id }) => !market.some(({ token_id: t}) => t === token_id)));
	}
	market.sort(sortFunctions[sort]);
	tokens.sort(sortFunctions[sort]);

	return <>
		{
			tab < 3 && 
			<center>
				{
					tab !== 2 && <button onClick={() => update('app.filter', filter === 2 ? 1 : 2)} style={{background: '#fed'}}>{filter === 1 ? 'All' : 'Sales'}</button>
				}
				<button onClick={() => update('app.sort', sort === 2 ? 1 : 2)} style={{ background: sort === 1 || sort === 2 ? '#fed' : ''}}>Date {sort === 1 && '⬆️'}{sort === 2 && '⬇️'}</button>
				{
					tab !== 2 && <button onClick={() => update('app.sort', sort === 4 ? 3 : 4)} style={{ background: sort === 3 || sort === 4 ? '#fed' : ''}}>Price {sort === 3 && '⬆️'}{sort === 4 && '⬇️'}</button>
				}
			</center>
		}
		{
			tab === 1 && market.map(({
				metadata: { media },
				owner_id,
				token_id,
				conditions = {},
				bids = {},
				royalty = {}
			}) =>
				<div key={token_id} className="item">
					<img src={media} />
					<p>{accountId !== owner_id ? `Owned by ${formatAccountId(owner_id)}` : `You own this!`}</p>
					{ Object.keys(conditions).length > 0 && <>
						<h4>Royalties</h4>
						{
							Object.keys(royalty).length > 0 ?
								Object.entries(royalty).map(([receiver, amount]) => <div key={receiver}>
									{receiver} - {amount / 100}%
								</div>)
								:
								<p>This token has no royalties.</p>
						}
					</>
					}
					{
						Object.keys(conditions).length > 0 && <>
							<h4>Sale Conditions</h4>
							{
								Object.entries(conditions).map(([ft_token_id, price]) => <div className="margin-bottom" key={ft_token_id}>
									{price === '0' ? 'open' : formatNearAmount(price, 4)} - {token2symbol[ft_token_id]}
								</div>)
							}
							{
								accountId.length && accountId !== owner_id && <>
									<input type="number" placeholder="Price" value={offerPrice} onChange={(e) => setOfferPrice(e.target.value)} />
									{
										getTokenOptions(offerToken, setOfferToken, Object.keys(conditions))
									}
									<button onClick={() => handleOffer(token_id)}>Offer</button>
								</>
							}
						</>
					}
					{
						Object.keys(bids).length > 0 && <>
							<h4>Offers</h4>
							{
								Object.entries(bids).map(([ft_token_id, { owner_id: bid_owner_id, price }]) => <div className="offers" key={ft_token_id}>
									<div>
										{price === '0' ? 'open' : formatNearAmount(price, 4)} - {token2symbol[ft_token_id]} by {bid_owner_id}
									</div>
									{
										accountId === owner_id &&
										<button onClick={() => handleAcceptOffer(token_id, ft_token_id)}>Accept</button>
									}
								</div>)
							}
						</>
					}
				</div>)
		}

		{
			tab === 2 && <>
				{!tokens.length && <p className="margin">No NFTs. Try minting something!</p>}
				{
					tokens.map(({
						metadata: { media },
						owner_id,
						token_id,
						conditions = {},
						bids = {},
						royalty = {}
					}) => <div key={token_id} className="item">
						<img src={media} />
						{
							storage ? <>
								<h4>Royalties</h4>
								{
									Object.keys(royalty).length > 0 ?
										Object.entries(royalty).map(([receiver, amount]) => <div key={receiver}>
											{receiver} - {amount / 100}%
										</div>)
										:
										<p>This token has no royalties.</p>
								}
								{
									Object.keys(conditions).length > 0 && <>
										<h4>Current Sale Conditions</h4>
										{
											Object.entries(conditions).map(([ft_token_id, price]) => <div className="margin-bottom" key={ft_token_id}>
												{price === '0' ? 'open' : formatNearAmount(price, 4)} - {token2symbol[ft_token_id]}
											</div>)
										}
									</>
								}
								{
									saleConditions.length > 0 &&
										<div>
											<h4>Pending Sale Updates</h4>
											{
												saleConditions.map(({ price, ft_token_id }) => <div className="margin-bottom" key={ft_token_id}>
													{price === '0' ? 'open' : formatNearAmount(price, 4)} - {token2symbol[ft_token_id]}
												</div>)
											}
											<button className="pulse-button" onClick={() => handleSaleUpdate(token_id)}>Update Sale Conditions</button>
										</div>
								}
								{
									accountId === owner_id && <>
										<div>
											<h4>Add Sale Conditions</h4>
											<input type="number" placeholder="Price" value={price} onChange={(e) => setPrice(e.target.value)} />
											{
												getTokenOptions(token, setToken)
											}
											<button onClick={() => {
												if (!price.length) {
													return alert('Enter a price');
												}
												const newSaleConditions = saleConditions
													.filter(({ ft_token_id }) => ft_token_id !== token)
													.concat([{
														price: parseNearAmount(price),
														ft_token_id: token,
													}]);
												setSaleConditions(newSaleConditions);
												setPrice('');
												setToken('near');
												handleSaleUpdate(token_id, newSaleConditions);
											}}>Add</button>
										</div>
										<div>
											<i style={{ fontSize: '0.75rem' }}>Note: price 0 means open offers</i>
										</div>
									</>
								}
								{
									Object.keys(bids).length > 0 && <>
										<h4>Offers</h4>
										{
											Object.entries(bids).map(([ft_token_id, { owner_id, price }]) => <div className="offers" key={ft_token_id}>
												<div>
													{price === '0' ? 'open' : formatNearAmount(price, 4)} - {token2symbol[ft_token_id]}
												</div>
												<button onClick={() => handleAcceptOffer(token_id, ft_token_id)}>Accept</button>
											</div>)
										}
									</>
								}
							</>
								:
								<div className="center">
									<button onClick={() => handleRegisterStorage()}>Register with Market to Sell</button>
								</div>
						}
					</div>)
				}
			</>
		}

	</>;
};

'''
'''--- src/components/Wallet.js ---
import React, { useEffect, useState } from 'react';

import * as nearAPI from 'near-api-js';
import { updateWallet } from '../state/near';
import {
	getContract,
	contractMethods,
	GAS
} from '../utils/near-utils';
const {
	KeyPair,
	utils: { PublicKey,
		format: {
			formatNearAmount
		} }
} = nearAPI;

export const Wallet = ({ wallet, account, update, dispatch, handleClose }) => {

	const [accountId, setAccountId] = useState('');
	const [proceeds, setProceeds] = useState('0');

	if (wallet && wallet.signedIn) {
		return <>
			<h3>Wallet</h3>
			<p>Balance: { wallet.balance } N</p>
			<br />
			<button onClick={handleClose}>Close</button>
			<br />
			<button onClick={() => wallet.signOut()}>Sign Out</button>
		</>;
	}

	return <>
		<button onClick={() => wallet.signIn()}>Connect Wallet</button>
	</>;
};

'''
'''--- src/config.js ---
const contractName = 'dev-1618702493101-2158436';

module.exports = function getConfig() {
	let config = {
		networkId: 'default',
		nodeUrl: 'https://rpc.testnet.near.org',
		// walletUrl: 'http://localhost:1234',
		walletUrl: 'https://wallet.testnet.near.org',
		helperUrl: 'https://helper.testnet.near.org',
		contractName,
	};
    
	if (process.env.REACT_APP_ENV !== undefined) {
		config = {
			...config,
			GAS: '200000000000000',
			DEFAULT_NEW_ACCOUNT_AMOUNT: '5',
			DEFAULT_NEW_CONTRACT_AMOUNT: '5',
			GUESTS_ACCOUNT_SECRET: '7UVfzoKZL4WZGF98C3Ue7tmmA6QamHCiB1Wd5pkxVPAc7j6jf3HXz5Y9cR93Y68BfGDtMLQ9Q29Njw5ZtzGhPxv',
			contractMethods: {
				changeMethods: [
					'new', 'nft_mint', 'nft_transfer', 'add_guest', 'remove_guest',
					'nft_approve_account_id', 
					'nft_mint_guest', 'nft_add_sale_guest', 'nft_remove_sale_guest', 'upgrade_guest'
				],
				viewMethods: ['get_guest', 'get_token_ids', 'nft_token', 'get_sale'],
			},
			marketDeposit: '100000000000000000000000',
			marketId: 'market.' + contractName
		};
	}
    
	if (process.env.REACT_APP_ENV === 'prod') {
		config = {
			...config,
			networkId: 'mainnet',
			nodeUrl: 'https://rpc.mainnet.near.org',
			walletUrl: 'https://wallet.near.org',
			helperUrl: 'https://helper.mainnet.near.org',
			contractName: 'near',
		};
	}

	return config;
};

'''
'''--- src/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>DEMO NEAR NFT Market</title>
    <link rel="preconnect" href="https://fonts.gstatic.com">
<link href="https://fonts.googleapis.com/css2?family=Inter&display=swap" rel="stylesheet">
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <script src="./index.js"></script>
  </body>
</html>

'''
'''--- src/index.js ---
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import { AppProvider } from './state/app.js';

ReactDOM.render(
	<AppProvider>
		<App />
	</AppProvider>,
	document.getElementById('root')
);

'''
'''--- src/state/app.js ---
import { State } from '../utils/state';

import { initNear } from './near';

const initialState = {
	app: {
		mounted: false,
		tab: 1,
		sort: 2,
		filter: 1,
	},
	near: {
		initialized: false,
	},
};

export const { appStore, AppProvider } = State(initialState, 'app');

export const onAppMount = () => async ({ update, getState, dispatch }) => {
	update('app', { mounted: true });
	dispatch(initNear());
};

'''
'''--- src/state/near.js ---
import getConfig from '../config';
import * as nearAPI from 'near-api-js';
import { getWallet, postSignedJson } from '../utils/near-utils';

export const {
	GAS,
	networkId, nodeUrl, walletUrl, nameSuffix,
	contractName,
} = getConfig();

export const {
	utils: {
		format: {
			formatNearAmount, parseNearAmount
		}
	}
} = nearAPI;

export const initNear = () => async ({ update, getState, dispatch }) => {
	const { near, wallet, contractAccount } = await getWallet();

	console.log(near);

	wallet.signIn = () => {
		wallet.requestSignIn(contractName, 'Blah Blah');
	};
	const signOut = wallet.signOut;
	wallet.signOut = () => {
		signOut.call(wallet);
		update('wallet.signedIn', false);
		update('', { account: null });
		update('app.tab', 1);
	};

	wallet.signedIn = wallet.isSignedIn();
    
	let account;
	if (wallet.signedIn) {
		account = wallet.account();
		wallet.balance = formatNearAmount((await wallet.account().getAccountBalance()).available, 4);
		await update('', { near, wallet, contractAccount, account });
	}

	await update('', { near, wallet, contractAccount, account });
};

export const updateWallet = () => async ({ update, getState }) => {
	const { wallet } = await getState();
	wallet.balance = formatNearAmount((await wallet.account().getAccountBalance()).available, 2);
	await update('', { wallet });
};

'''
'''--- src/utils/near-utils.js ---
import getConfig from '../config';
import * as nearAPI from 'near-api-js';

export const {
	GAS,
	networkId, nodeUrl, walletUrl, nameSuffix,
	contractName, contractMethods,
	accessKeyMethods,
} = getConfig();

const {
	Account,
	Contract,
	InMemorySigner,
} = nearAPI;

let near;

// alias
export const contractId = contractName;
export const marketId = 'market.' + contractName;

export const setSignerFromSeed = async (accountId, seedPhrase) => {
	const { secretKey } = parseSeedPhrase(seedPhrase);
	const keyPair = KeyPair.fromString(secretKey);
	near.connection.signer.keyStore.setKey(networkId, accountId, keyPair);
};
export function formatAccountId (accountId, len = 48) {
	if (accountId.length > len) {
		return accountId.substr(0, len - 3) + '...';
	}
	return accountId;
}

export function getContract(account, methods = contractMethods) {
	return new Contract(account, contractName, { ...methods });
}

export const getWallet = async () => {
	near = await nearAPI.connect({
		networkId, nodeUrl, walletUrl, deps: { keyStore: new nearAPI.keyStores.BrowserLocalStorageKeyStore() },
	});
	const wallet = new nearAPI.WalletAccount(near);
	const contractAccount = new Account(near.connection, contractName);
	return { near, wallet, contractAccount };
};

export const getSignature = async (account, key) => {
	const { accountId } = account;
	const block = await account.connection.provider.block({ finality: 'final' });
	const blockNumber = block.header.height.toString();
	const signer = account.inMemorySigner || account.connection.signer;
	const signed = await signer.signMessage(Buffer.from(blockNumber), accountId, networkId);
	const blockNumberSignature = Buffer.from(signed.signature).toString('base64');
	return { blockNumber, blockNumberSignature };
};

export const postSignedJson = async ({ account, contractName, url, data = {} }) => {
	return await fetch(url, {
		method: 'POST',
		headers: new Headers({ 'content-type': 'application/json' }),
		body: JSON.stringify({
			...data,
			accountId: account.accountId,
			contractName,
			...(await getSignature(account))
		})
	}).then((res) => res.json());
};

export const postJson = async ({ url, data = {} }) => {
	return await fetch(url, {
		method: 'POST',
		headers: new Headers({ 'content-type': 'application/json' }),
		body: JSON.stringify({ ...data })
	}).then((res) => res.json());
};

export const createGuestAccount = (near, key) => {
	key.toString = () => key.secretKey;
	near.connection.signer.keyStore.setKey(networkId, 'guests.' + contractName, key);
	const account = new Account(near.connection, 'guests.' + contractName);
	return account;
};

export const createAccessKeyAccount = (near, key) => {
	key.toString = () => key.secretKey;
	near.connection.signer.keyStore.setKey(networkId, contractName, key);
	const account = new Account(near.connection, contractName);
	return account;
};

/********************************
Not used
********************************/

export const hasKey = async (near, accountId, publicKey) => {
	const pubKeyStr = publicKey.toString();
	const account = new nearAPI.Account(near.connection, accountId);
	try {
		const accessKeys = await account.getAccessKeys();
		if (accessKeys.length > 0 && accessKeys.find(({ public_key }) => public_key === pubKeyStr)) {
			return true;
		}
	} catch (e) {
		console.warn(e);
	}
	return false;
};

export const isAccountTaken = async (accountId) => {
	const account = new nearAPI.Account(near.connection, accountId);
	try {
		await account.state();
		return true;
	} catch (e) {
		if (!/does not exist/.test(e.toString())) {
			throw e;
		}
	}
	return false;
};

export const getContractSigner = async ({ keyPair }) => {
	const signer = await InMemorySigner.fromKeyPair(networkId, contractName, keyPair);
	const near = await nearAPI.connect({
		networkId, nodeUrl, walletUrl, deps: { keyStore: signer.keyStore },
	});
	const account = new nearAPI.Account(near.connection, contractName);
	const contract = await new nearAPI.Contract(account, contractName, {
		changeMethods: ['send', 'claim', 'create_account_and_claim'],
		sender: account
	});
	return { contract };
};
'''
'''--- src/utils/state.js ---
import React, { createContext, useReducer } from 'react';

export const State = (initialState, prefix) => {
	let updatedState;
	const getState = () => updatedState;
	const store = createContext(initialState);
	const { Provider: InnerProvider } = store;

	const updateState = (state, newState, path = '') => {
		// console.log('updateState', state, path, newState) // debugging
		if (path.length === 0) {
			return { ...state, ...newState };
		}
		const pathArr = path.split('.');
		const first = pathArr[0];
		state = { ...state };
		if (!state[first]) {
			state[first] = {};
		}
		if (pathArr.length === 1) {
			state[first] = !!newState && typeof newState === 'object' && !Array.isArray(newState) ? {
				...state[first],
				...newState
			} : newState;
		} else {
			state[first] = {
				...state[first],
				...updateState(state[first], newState, pathArr.slice(1).join('.'))
			};
		}

		return state;
	};

	const Provider = ({ children }) => {
		const [state, dispatch] = useReducer((state, payload) => {
			const { path, newState } = payload;
			if (path === undefined) {
				return state;
			}
			updatedState = updateState(state, newState, path);
			return updatedState;
		}, initialState);

		const update = (path, newState) => {
			dispatch({ path, newState });
		};
		const wrappedDispatch = (fn) => fn({ update, getState, dispatch: wrappedDispatch });

		return <InnerProvider value={{ update, state, dispatch: wrappedDispatch }}>{children}</InnerProvider>;
	};

	if (prefix) {
		return {
			[prefix + 'Store']: store,
			[prefix.substr(0, 1).toUpperCase() + prefix.substr(1) + 'Provider']: Provider,
		};
	}
    
	return { store, Provider };
};

'''
'''--- src/utils/storage.js ---
export const get = (k, d = {}) => {
	let v = localStorage.getItem(k);
	if (typeof d !== 'object') {
		return v;
	}
	try {
		return JSON.parse(v || JSON.stringify(d));
	} catch (e) {
		return v;
	}
};
export const set = (k, v) => localStorage.setItem(k, typeof v === 'string' ? v : JSON.stringify(v));
export const del = (k) => localStorage.removeItem(k);
'''
'''--- test/app.test.js ---
const fs = require('fs');
const BN = require('bn.js');
const nearAPI = require('near-api-js');
const testUtils = require('./test-utils');
const getConfig = require('../src/config');

const { 
	Contract, KeyPair, Account,
	utils: { format: { parseNearAmount }},
	transactions: { deployContract, functionCall },
} = nearAPI;
const { 
	connection, initContract, getAccount, getAccountBalance,
	contract, contractAccount, contractName, contractMethods, createAccessKeyAccount,
	createOrInitAccount,
	getContract,
} = testUtils;
const { 
	networkId, GAS, GUESTS_ACCOUNT_SECRET
} = getConfig();

jasmine.DEFAULT_TIMEOUT_INTERVAL = 100000;

describe('deploy contract ' + contractName, () => {
	let alice, aliceId, bob, bobId,
		stableAccount, marketAccount,
		storageMinimum, storageMarket;

	const metadata = {
		media: 'https://media1.tenor.com/images/4c1d96a989150e7019bfbabbebd2ff36/tenor.gif?itemid=20269144',
	};
	const metadata2 = {
		media: 'https://media1.tenor.com/images/818161c07948bac34aa7c5f5712ec3d7/tenor.gif?itemid=15065455',
	};
	const t = Date.now();
	const tokenIds = [
		'token' + t,
		'token' + (t + 1),
		'token' + (t + 2)
	];
	const tokenTypes = [
		'type' + t,
		'type' + (t + 1),
		'type' + (t + 2)
	];
	const contract_royalty = 500;

	/// contractAccount.accountId is the NFT contract and contractAccount is the owner
	/// see initContract in ./test-utils.js for details
	const contractId = contractAccount.accountId;
	console.log('\n\n contractId:', contractId, '\n\n');
	/// the fungible token "stablecoin" contract
	const stableId = 'stable.' + contractId;
	/// the market contract
	const marketId = 'market.' + contractId;

	beforeAll(async () => {
	    await initContract();

		alice = await getAccount();
		aliceId = alice.accountId;
		console.log('\n\n Alice accountId:', aliceId, '\n\n');

		bob = await getAccount();
		bobId = bob.accountId;
		console.log('\n\n Bob accountId:', bobId, '\n\n');

		await contractAccount.functionCall(contractName, 'set_contract_royalty', { contract_royalty }, GAS);
		await contractAccount.functionCall(contractName, 'add_token_type', { token_type: tokenTypes[0], hard_cap: '1' }, GAS);
		
		/// create or get stableAccount and deploy ft.wasm (if not already deployed)
		stableAccount = await createOrInitAccount(stableId, GUESTS_ACCOUNT_SECRET);
		const stableAccountState = await stableAccount.state();
		console.log('\n\nstate:', stableAccountState, '\n\n');
		if (stableAccountState.code_hash === '11111111111111111111111111111111') {
			const fungibleContractByes = fs.readFileSync('./out/ft.wasm');
			console.log('\n\n deploying stableAccount contractBytes:', fungibleContractByes.length, '\n\n');
			const newFungibleArgs = {
				/// will have totalSupply minted to them
				owner_id: contractName,
				total_supply: parseNearAmount('1000000'),
				name: 'Test Stable Coin',
				symbol: 'TSC',
				// not set by user request
				version: '1',
				reference: 'https://github.com/near/core-contracts/tree/master/w-near-141',
				reference_hash: '7c879fa7b49901d0ecc6ff5d64d7f673da5e4a5eb52a8d50a214175760d8919a',
				decimals: 24,
			};
			const actions = [
				deployContract(fungibleContractByes),
				functionCall('new', newFungibleArgs, GAS)
			];
			await stableAccount.signAndSendTransaction(stableId, actions);
			/// find out how much needed to store for FTs
			storageMinimum = await contractAccount.viewFunction(stableId, 'storage_minimum_balance');
			console.log('\n\n storageMinimum:', storageMinimum, '\n\n');
			/// pay storageMinimum for all the royalty receiving accounts
			const promises = [];
			for (let i = 1; i < 6; i++) {
				promises.push(stableAccount.functionCall(stableId, 'storage_deposit', { account_id: `a${i}.testnet` }, GAS, storageMinimum));
			}
			await Promise.all(promises);
		} else {
			/// find out how much needed to store for FTs
			storageMinimum = await contractAccount.viewFunction(stableId, 'storage_minimum_balance');
			console.log('\n\n storageMinimum:', storageMinimum, '\n\n');
		}

		/// create or get market account and deploy market.wasm (if not already deployed)
		marketAccount = await createOrInitAccount(marketId, GUESTS_ACCOUNT_SECRET);
		const marketAccountState = await marketAccount.state();
		console.log('\n\nstate:', marketAccountState, '\n\n');
		if (marketAccountState.code_hash === '11111111111111111111111111111111') {
			const marketContractBytes = fs.readFileSync('./out/market.wasm');
			console.log('\n\n deploying marketAccount contractBytes:', marketContractBytes.length, '\n\n');
			const newMarketArgs = {
				owner_id: contractId
			};
			const actions = [
				deployContract(marketContractBytes),
				functionCall('new', newMarketArgs, GAS)
			];
			await marketAccount.signAndSendTransaction(marketId, actions);
		}
		const supported = await marketAccount.viewFunction(marketId, "supports_token", { ft_token_id: stableId });
		console.log('\n\n market supports token:', stableId, supported, '\n\n');
		if (!supported) {
			await marketAccount.functionCall(stableId, 'storage_deposit', {}, GAS, storageMinimum);
			const added = await contractAccount.functionCall(marketId, "add_token", { ft_token_id: stableId }, GAS);
			console.log('\n\n added token:', stableId, '\n\n');
		}

		/// find out how much needed for market storage
		storageMarket = await contractAccount.viewFunction(marketId, 'storage_amount');
		console.log('\n\n storageMarket:', storageMarket, '\n\n');
	});

	test('enumerable tests (no tokens)', async () => {
		const nft_supply_for_owner = await bob.viewFunction(contractName, 'nft_supply_for_owner', { account_id: bobId });
		console.log('\n\n nft_supply_for_owner', nft_supply_for_owner, '\n\n');
		expect(nft_supply_for_owner).toEqual('0');
		// messing around with index and limit
		const bobTokens = await bob.viewFunction(contractName, 'nft_tokens_for_owner', { account_id: bobId, from_index: '1001', limit: '1000' });
		console.log('\n\n bobTokens', bobTokens, '\n\n');
		expect(bobTokens.length).toEqual(0);
	});

	test('NFT contract owner mints nft and approves fixed price near sale', async () => {
		const token_id = tokenIds[0];
		await contractAccount.functionCall(marketId, 'storage_deposit', {}, GAS, storageMarket).catch(() => {});
		await contractAccount.functionCall(contractId, 'nft_mint', {
			token_id,
			metadata,
			token_type: tokenTypes[0],
			perpetual_royalties: {
				'a1.testnet': 500,
				'a2.testnet': 250,
				'a3.testnet': 250,
				'a4.testnet': 250,
				'a5.testnet': 250,
			},
		}, GAS, parseNearAmount('1'));

		let sale_conditions = [
			{
				ft_token_id: 'near',
				price: parseNearAmount('1')
			}
		];

		await contractAccount.functionCall(contractId, 'nft_approve', {
			token_id,
			account_id: marketId,
			msg: JSON.stringify({ sale_conditions })
		}, GAS, parseNearAmount('0.01'));

		const sale = await contractAccount.viewFunction(marketId, 'get_sale', { nft_contract_token: contractId + ':' + token_id });
		console.log('\n\n', sale, '\n\n');
		expect(sale.conditions.near).toEqual(parseNearAmount('1'));
	});

	test('token transfer locked - owner unlocks token transfer token type', async () => {
		const token_id = tokenIds[0];
		try {
			await contractAccount.functionCall(contractId, 'nft_transfer', {
				receiver_id: bobId,
				token_id
			}, 1);
			expect(false);
		} catch(e) {
			expect(true);
		}
		await contractAccount.functionCall(contractName, 'unlock_token_type', { token_type: tokenTypes[0] }, GAS);
		const tokenLocked = await contractAccount.viewFunction(contractName, 'is_token_locked', { token_id });
		expect(tokenLocked).toEqual(false);
		const tokenTypeLocked = await contractAccount.viewFunction(contractName, 'is_token_type_locked', { token_type: tokenTypes[0] });
		expect(tokenTypeLocked).toEqual(false);
	});

	test('get sales by owner id', async () => {
		const sales_by_owner_id = await contractAccount.viewFunction(marketId, 'get_sales_by_owner_id', {
			account_id: contractId,
			from_index: '0',
			limit: '50'
		});
		console.log('\n\n', sales_by_owner_id, '\n\n');
		expect(sales_by_owner_id.length).toEqual(1);
	});

	test('get sales by nft contract id', async () => {
		const sales_by_nft_contract_id = await contractAccount.viewFunction(marketId, 'get_sales_by_nft_contract_id', {
			nft_contract_id: contractId,
			from_index: '0',
			limit: '50'
		});
		console.log('\n\n', sales_by_nft_contract_id, '\n\n');
		expect(sales_by_nft_contract_id.length > 0).toEqual(true);
	});

	test('bob purchase nft with NEAR', async () => {
		const token_id = tokenIds[0];
		const contractBalanceBefore = await getAccountBalance(contractId);
		/// purchase = near deposit = sale.price -> nft_transfer -> royalties transfer near
		await bob.functionCall(marketId, 'offer', {
			nft_contract_id: contractName,
			token_id,
		}, GAS, parseNearAmount('1'));
		/// check owner
		const token = await contract.nft_token({ token_id });
		expect(token.owner_id).toEqual(bobId);
		// check contract balance went up by over 80% of 1 N
		const contractBalanceAfter = await getAccountBalance(contractId);
		expect(new BN(contractBalanceAfter.total).sub(new BN(contractBalanceBefore.total)).gt(new BN(parseNearAmount('0.79')))).toEqual(true);
	});

	test('contract account registers bob with market contract', async () => {
		await contractAccount.functionCall(marketId, 'storage_deposit', { account_id: bobId }, GAS, storageMarket).catch(() => {});
		const result = await contractAccount.viewFunction(marketId, 'storage_paid', { account_id: bobId });
		expect(result).toEqual(true);
	});

	test('bob approves sale with FT and NEAR (fixed prices)', async () => {
		const token_id = tokenIds[0];
		await bob.functionCall(stableId, 'storage_deposit', {}, GAS, storageMinimum).catch(() => {});
		const token = await contract.nft_token({ token_id });
		let sale_conditions = [
			{
				ft_token_id: stableId,
				price: parseNearAmount('25')
			},
			{
				ft_token_id: 'near',
				price: parseNearAmount('5')
			}
		];

		console.log('\n\n sale_conditions.length', sale_conditions.length, '\n\n');
		console.log('\n\n token.royalty.length', token.royalty.length, '\n\n');

		if (sale_conditions.length + token.royalty.length > 8) {
			throw new Error("Cannot have more than 8 royalties + sale collateral at the same time");
		}

		await bob.functionCall(contractId, 'nft_approve', {
			token_id,
			account_id: marketId,
			msg: JSON.stringify({ sale_conditions })
		}, GAS, parseNearAmount('0.01'));
		const sale = await bob.viewFunction(marketId, 'get_sale', { nft_contract_token: contractId + ':' + token_id });
		console.log('\n\n', sale, '\n\n');
		expect(sale.conditions[stableId]).toEqual(parseNearAmount('25'));
	});

	test('enumerable tests', async () => {
		const total_supply = await bob.viewFunction(contractName, 'nft_total_supply', {});
		console.log('\n\n total_supply', total_supply, '\n\n');
		// could be several tests in, with many tokens minted
		const nft_supply_for_owner = await bob.viewFunction(contractName, 'nft_supply_for_owner', { account_id: bobId });
		console.log('\n\n nft_supply_for_owner', nft_supply_for_owner, '\n\n');
		expect(nft_supply_for_owner).toEqual('1');
		const tokens = await bob.viewFunction(contractName, 'nft_tokens', { from_index: '0', limit: '1000' });
		console.log('\n\n tokens', tokens, '\n\n');
		// proxy for total supply with low limits, could be several tests in, with many tokens minted
		expect(tokens.length > 0).toEqual(true);
		const bobTokens = await bob.viewFunction(contractName, 'nft_tokens_for_owner', { account_id: bobId, from_index: '0', limit: '1000' });
		console.log('\n\n bobTokens', bobTokens, '\n\n');
		expect(bobTokens.length).toEqual(1);
	});
    
	test('bob changes price of FTs', async () => {
		const token_id = tokenIds[0];
		await bob.functionCall(marketId, 'update_price', {
			nft_contract_id: contractId,
			token_id,
			ft_token_id: stableId,
			price: parseNearAmount('20')
		}, GAS);
		const sale = await bob.viewFunction(marketId, 'get_sale', { nft_contract_token: contractId + ':' + token_id });
		console.log('\n\n', sale, '\n\n');
		expect(sale.conditions[stableId]).toEqual(parseNearAmount('20'));
	});

	test('contract owner makes low bid', async () => {
		const token_id = tokenIds[0];
		/// purchase = ft_transfer_call -> market: ft_on_transfer -> nft_transfer
		await contractAccount.functionCall(marketId, 'offer', {
			nft_contract_id: contractName,
			token_id,            
		}, GAS, parseNearAmount('1'));
		
		/// check sale should have 2 N bid for near from contract owner
		const sale = await bob.viewFunction(marketId, 'get_sale', { nft_contract_token: contractId + ':' + token_id });
		expect(sale.bids['near'].owner_id).toEqual(contractId);
		expect(sale.bids['near'].price).toEqual(parseNearAmount('1'));
	});

	test('alice outbids contract owner', async () => {
		const token_id = tokenIds[0];

		const contractBalanceBefore = await getAccountBalance(contractId);
		/// purchase = ft_transfer_call -> market: ft_on_transfer -> nft_transfer
		await alice.functionCall(marketId, 'offer', {
			nft_contract_id: contractName,
			token_id,
		}, GAS, parseNearAmount('1.1'));
		
		/// check sale should have 1.1 N bid for near from alice
		const sale = await bob.viewFunction(marketId, 'get_sale', { nft_contract_token: contractId + ':' + token_id });
		expect(sale.bids['near'].owner_id).toEqual(aliceId);
		expect(sale.bids['near'].price).toEqual(parseNearAmount('1.1'));

		// contract owner gets back 1 N - gas > 0.9
		const contractBalanceAfter = await getAccountBalance(contractId);

		expect(new BN(contractBalanceAfter.total).sub(new BN(contractBalanceBefore.total)).gt(new BN(parseNearAmount('0.9')))).toEqual(true);
	});

	test('alice gets 100 FTs', async () => {
		await alice.functionCall(stableId, 'storage_deposit', {}, GAS, storageMinimum);
		let amount = parseNearAmount('100');
		await contractAccount.functionCall(stableId, 'ft_transfer', {
			receiver_id: aliceId,
			amount
		}, GAS, 1);
		/// check balance
		const balance = await contractAccount.viewFunction(stableId, 'ft_balance_of', { account_id: aliceId });
		expect(balance).toEqual(amount);
	});

	test('alice purchase NFT with FT', async () => {
		const token_id = tokenIds[0];

		const aliceBalanceBefore = await getAccountBalance(aliceId);
		/// purchase = ft_transfer_call -> market: ft_on_transfer -> nft_transfer
		await alice.functionCall(stableId, 'ft_transfer_call', {
			receiver_id: marketId,
			amount: parseNearAmount('20'),
			msg: JSON.stringify({
				nft_contract_id: contractName,
				token_id,
			})
		}, GAS, 1);
		/// check owner
		const token = await contract.nft_token({ token_id });
		expect(token.owner_id).toEqual(aliceId);
		/// check token balances
		const aliceBalance = await alice.viewFunction(stableId, 'ft_balance_of', { account_id: aliceId });
		expect(aliceBalance).toEqual(parseNearAmount('80'));
		const marketBalance = await marketAccount.viewFunction(stableId, 'ft_balance_of', { account_id: marketId });
		console.log('\n\n marketBalance', marketBalance, '\n\n');
		/// bob gets 80% of the FTs
		const bobBalance = await bob.viewFunction(stableId, 'ft_balance_of', { account_id: bobId });
		expect(bobBalance).toEqual(parseNearAmount('16'));
		// alice's bid of 1.1 NEAR was returned (check N diff > than 1.1 - gas)
		const aliceBalanceAfter = await getAccountBalance(aliceId);
		expect(new BN(aliceBalanceAfter.total).sub(new BN(aliceBalanceBefore.total)).gt(new BN(parseNearAmount('1')))).toEqual(true);
	});

	/// near bid

	test('bob fails to mint past hard cap for token type', async () => {
		const token_id = tokenIds[1];
		try {
			await bob.functionCall(contractId, 'nft_mint', {
				token_id,
				metadata,
				token_type: tokenTypes[0]
			}, GAS, parseNearAmount('1'));
			expect(false);
		} catch (e) {
			expect(true);
		}
		const hardCap = await bob.viewFunction(contractId, 'nft_supply_for_type', { token_type: tokenTypes[0] });
		expect(hardCap).toEqual('1');
	});

	test('bob: nft mint (no type), approve sale with NEAR open for bids', async () => {
		const token_id = tokenIds[1];
		await bob.functionCall(marketId, 'storage_deposit', {}, GAS, storageMarket).catch(() => {});
		await bob.functionCall(contractId, 'nft_mint', {
			token_id,
			metadata: metadata2,
			perpetual_royalties: {
				[bobId]: 500,
			},
		}, GAS, parseNearAmount('1'));
		await bob.functionCall(contractId, 'nft_approve', {
			token_id,
			account_id: marketId,
			msg: JSON.stringify({
				sale_conditions: [{
					ft_token_id: 'near',
				}]
			})
		}, GAS, parseNearAmount('0.01'));
		const sale = await bob.viewFunction(marketId, 'get_sale', { nft_contract_token: contractId + ':' + token_id });
		console.log('\n\n', sale, '\n\n');
		expect(sale.conditions["near"]).toEqual(parseNearAmount('0'));
	});

	test('alice bid with NEAR', async () => {
		const token_id = tokenIds[1];
		await alice.functionCall(marketId, 'offer', {
			nft_contract_id: contractName,
			token_id,
		}, GAS, parseNearAmount('0.2'));
		const sale = await bob.viewFunction(marketId, 'get_sale', { nft_contract_token: contractId + ':' + token_id });
		expect(sale.bids['near'].owner_id).toEqual(aliceId);
		expect(sale.bids['near'].price).toEqual(parseNearAmount('0.2'));
	});

	test('bob accept bid', async () => {
		const token_id = tokenIds[1];
		const bobBalanceBefore = await getAccountBalance(bobId);
		/// purchase = near deposit = sale.price -> nft_transfer -> royalties transfer near
		await bob.functionCall(marketId, 'accept_offer', {
			nft_contract_id: contractName,
			token_id,
			ft_token_id: 'near',
		}, GAS);
		/// check owner
		const token = await contract.nft_token({ token_id });
		expect(token.owner_id).toEqual(aliceId);
		const bobBalanceAfter = await getAccountBalance(bobId);
		/// bob got close to 0.18 N (95% - gas) from this sale
		expect(new BN(bobBalanceAfter.total).sub(new BN(bobBalanceBefore.total)).gt(new BN(parseNearAmount('0.17')))).toEqual(true);
	});

	/// for testing frontend

	test('alice lingering sale in marketplace', async () => {
		const token_id = tokenIds[1];
		await alice.functionCall(marketId, 'storage_deposit', {}, GAS, storageMarket).catch(() => {});
		await alice.functionCall(contractId, 'nft_approve', {
			token_id,
			account_id: marketId,
			perpetual_royalties: {
				[aliceId]: 500,
			},
			msg: JSON.stringify({
				sale_conditions: [{
					ft_token_id: 'near',
				}]
			})
		}, GAS, parseNearAmount('0.01'));
	});

});
'''
'''--- test/near-utils.js ---
const fs = require('fs');
const nearAPI = require('near-api-js');
const getConfig = require('../src/config');
const { nodeUrl, networkId, contractName, contractMethods } = getConfig(true);
const {
	keyStores: { InMemoryKeyStore },
	Near, Account, Contract, KeyPair,
	utils: {
		format: {
			parseNearAmount
		}
	}
} = nearAPI;

const credentials = JSON.parse(fs.readFileSync(process.env.HOME + '/.near-credentials/default/' + contractName + '.json'));
const keyStore = new InMemoryKeyStore();
keyStore.setKey(networkId, contractName, KeyPair.fromString(credentials.private_key));
const near = new Near({
	networkId, nodeUrl,
	deps: { keyStore },
});
const { connection } = near;
const contractAccount = new Account(connection, contractName);
contractAccount.addAccessKey = (publicKey) => contractAccount.addKey(publicKey, contractName, contractMethods.changeMethods, parseNearAmount('0.1'));
const contract = new Contract(contractAccount, contractName, contractMethods);

module.exports = {
	near,
	keyStore,
	connection,
	contract,
	contractName,
	contractAccount,
	contractMethods,
};
'''
'''--- test/server.test.js ---
const nearAPI = require('near-api-js');
const testUtils = require('./test-utils');
const getConfig = require('../src/config');

const { Account, KeyPair, utils: { format: { parseNearAmount }} } = nearAPI;
const { near, TEST_HOST, initContract, getAccount, contractAccount: ownerAccount, postJson } = testUtils;
const { GAS, contractName: ownerId, networkId } = getConfig();

jasmine.DEFAULT_TIMEOUT_INTERVAL = 50000;

describe('deploy API owned by: ' + ownerId, () => {
	let alice, contractAlice, bob, bobId, bobAccount;
	const name = `token-${Date.now()}`;
	const tokenId = `${name}.${ownerId}`;
	const guestId = 'guests.' + ownerId;

	beforeAll(async () => {
		alice = await getAccount();
		await initContract();
	});

	/// API
	test('deploy token', async () => {
		const { success, result } = await postJson({
			url: TEST_HOST + '/launch-token',
			data: {
				name,
				symbol: 'TEST',
				totalSupply: parseNearAmount('1000000'),
			}
		});
		expect(success).toEqual(true);
	});

	/// API
	test('add guest user', async () => {
		bobId = 'bob.' + tokenId;
		const keyPair = KeyPair.fromRandom('ed25519');
		/// bob's key signs tx from guest account (sponsored)
		near.connection.signer.keyStore.setKey(networkId, guestId, keyPair);
		bobAccount = new Account(near.connection, guestId);

		const { success, result } = await postJson({
			url: TEST_HOST + '/add-guest',
			data: {
				account_id: bobId,
				public_key: keyPair.publicKey.toString(),
			}
		});
		expect(success).toEqual(true);
	});

	/// CLIENT
	test('bob guest claim drop self', async () => {
		await bobAccount.functionCall(tokenId, 'claim_drop', {}, GAS);
		const balance = await bobAccount.viewFunction(tokenId, 'ft_balance_of', { account_id: bobId }, GAS);
		expect(balance).toEqual(parseNearAmount('100'));
	});

	/// CLIENT
	test('owner transfer tokens to guest (client)', async () => {
		await ownerAccount.functionCall(tokenId, 'ft_transfer', {
			receiver_id: bobId,
			amount: parseNearAmount('50'),
		}, GAS, 1);
		const balance = await bobAccount.viewFunction(tokenId, 'ft_balance_of', { account_id: bobId }, GAS);
		expect(balance).toEqual(parseNearAmount('150'));
	});

	/// API
	test('owner transfer tokens to guest (api)', async () => {
		const { success, result } = await postJson({
			url: TEST_HOST + '/transfer-tokens',
			data: {
				tokenId,
				receiver_id: bobId,
				amount: parseNearAmount('50'),
			}
		});
		expect(success).toEqual(true);
		const balance = await bobAccount.viewFunction(tokenId, 'ft_balance_of', { account_id: bobId }, GAS);
		expect(balance).toEqual(parseNearAmount('200'));
	});

	/// CLIENT
	test('bob guest transfer to alice', async () => {
		/// send tokens to alice who needs to register her storage
		const storageMinimum = await alice.viewFunction(tokenId, 'storage_minimum_balance', {});
		await alice.functionCall(tokenId, 'storage_deposit', {}, GAS, storageMinimum);
		const amount = parseNearAmount('100');
		await bobAccount.functionCall(tokenId, 'ft_transfer_guest', { receiver_id: alice.accountId, amount }, GAS);
		const balance = await bobAccount.viewFunction(tokenId, 'ft_balance_of', { account_id: bobId }, GAS);
		expect(balance).toEqual(amount);
		const balance2 = await bobAccount.viewFunction(tokenId, 'ft_balance_of', { account_id: alice.accountId }, GAS);
		expect(balance2).toEqual(amount);
	});

	/// CLIENT
	test('bob upgrades to full account', async () => {
		const keyPair = KeyPair.fromRandom('ed25519');
		const keyPair2 = KeyPair.fromRandom('ed25519');
		const public_key = keyPair.publicKey.toString();
		const public_key2 = keyPair2.publicKey.toString();
		near.connection.signer.keyStore.setKey(networkId, bobId, keyPair);
		await bobAccount.functionCall(tokenId, 'upgrade_guest', {
			public_key,
			access_key: public_key2,
			method_names: '',
		}, GAS);
		/// update account and contract for bob (bob now pays gas)
		const balance = await testUtils.getAccountBalance(bobId);
		/// creating account only moves 0.5 NEAR and the rest is still wNEAR
		expect(balance.total).toEqual(parseNearAmount('0.5'));
	});

});
'''
'''--- test/test-utils.js ---
const BN = require('bn.js');
const fetch = require('node-fetch');
const nearAPI = require('near-api-js');
const { KeyPair, Account, Contract, utils: { format: { parseNearAmount } } } = nearAPI;
const { near, connection, keyStore, contract, contractAccount } = require('./near-utils');
const getConfig = require('../src/config');
const {
	networkId, contractName, contractMethods,
	DEFAULT_NEW_ACCOUNT_AMOUNT, 
	DEFAULT_NEW_CONTRACT_AMOUNT,
} = getConfig();

const TEST_HOST = 'http://localhost:3000';
/// exports
async function initContract() {
	/// try to call new on contract, swallow e if already initialized
	try {
		const newArgs = {
			owner_id: contractAccount.accountId,
			metadata: {
				spec: 'nft-1',
				name: 'Test NFT',
				symbol: 'TNFT',
			},
			supply_cap_by_type: {
				test: '1000000',
			}
		};
		await contract.new(newArgs);
	} catch (e) {
		if (!/initialized/.test(e.toString())) {
			throw e;
		}
	}
	return { contract, contractName };
}
const getAccountBalance = async (accountId) => (new nearAPI.Account(connection, accountId)).getAccountBalance();

const createOrInitAccount = async(accountId, secret) => {
	let account;
	try {
		account = await createAccount(accountId, DEFAULT_NEW_CONTRACT_AMOUNT, secret);
	} catch (e) {
		if (!/because it already exists/.test(e.toString())) {
			throw e;
		}
		account = new nearAPI.Account(connection, accountId);

		console.log(await getAccountBalance(accountId));

		const newKeyPair = KeyPair.fromString(secret);
		keyStore.setKey(networkId, accountId, newKeyPair);
	}
	return account;
};

async function getAccount(accountId, fundingAmount = DEFAULT_NEW_ACCOUNT_AMOUNT) {
	accountId = accountId || generateUniqueSubAccount();
	const account = new nearAPI.Account(connection, accountId);
	try {
		await account.state();
		return account;
	} catch(e) {
		if (!/does not exist/.test(e.toString())) {
			throw e;
		}
	}
	return await createAccount(accountId, fundingAmount);
};

async function getContract(account) {
	return new Contract(account || contractAccount, contractName, {
		...contractMethods,
		signer: account || undefined
	});
}

const createAccessKeyAccount = (key) => {
	connection.signer.keyStore.setKey(networkId, contractName, key);
	return new Account(connection, contractName);
};

const postSignedJson = async ({ account, contractName, url, data = {} }) => {
	return await fetch(url, {
		method: 'POST',
		headers: { 'content-type': 'application/json' },
		body: JSON.stringify({
			...data,
			accountId: account.accountId,
			contractName,
			...(await getSignature(account))
		})
	}).then((res) => {
		// console.log(res)
		return res.json();
	});
};

const postJson = async ({ url, data = {} }) => {
	return await fetch(url, {
		method: 'POST',
		headers: { 'content-type': 'application/json' },
		body: JSON.stringify({ ...data })
	}).then((res) => {
		console.log(res);
		return res.json();
	});
};

function generateUniqueSubAccount() {
	return `t${Date.now()}.${contractName}`;
}

/// internal
async function createAccount(accountId, fundingAmount = DEFAULT_NEW_ACCOUNT_AMOUNT, secret) {
	const contractAccount = new Account(connection, contractName);
	const newKeyPair = secret ? KeyPair.fromString(secret) : KeyPair.fromRandom('ed25519');
	await contractAccount.createAccount(accountId, newKeyPair.publicKey, new BN(parseNearAmount(fundingAmount)));
	keyStore.setKey(networkId, accountId, newKeyPair);
	return new nearAPI.Account(connection, accountId);
}

const getSignature = async (account) => {
	const { accountId } = account;
	const block = await account.connection.provider.block({ finality: 'final' });
	const blockNumber = block.header.height.toString();
	const signer = account.inMemorySigner || account.connection.signer;
	const signed = await signer.signMessage(Buffer.from(blockNumber), accountId, networkId);
	const blockNumberSignature = Buffer.from(signed.signature).toString('base64');
	return { blockNumber, blockNumberSignature };
};

module.exports = { 
	TEST_HOST,
	near,
	connection,
	keyStore,
	getContract,
	getAccountBalance,
	contract,
	contractName,
	contractMethods,
	contractAccount,
	createOrInitAccount,
	createAccessKeyAccount,
	initContract, getAccount, postSignedJson, postJson,
};
'''
'''--- utils/patch-config.js ---
const fs = require('fs');
const contractName = fs.readFileSync('./neardev/dev-account').toString()
const path = './src/config.js'
 
fs.readFile(path, 'utf-8', function(err, data) {
    if (err) throw err;
 
    data = data.replace(/.*const contractName.*/gim, `const contractName = '${contractName}';`);
 
    fs.writeFile(path, data, 'utf-8', function(err) {
        if (err) throw err;
        console.log('Done!');
    })
})

'''