*GitHub Repository "NEARFoundation/near-kyc-onfido"*

'''--- .eslintrc.js ---
module.exports = {
  extends: ['eslint-config-airbnb-typescript-prettier', 'plugin:@next/next/recommended'], // https://github.com/toshi-toma/eslint-config-airbnb-typescript-prettier https://github.com/airbnb/javascript
  plugins: ['simple-import-sort'],
  rules: {
    // REMEMBER TO RESTART `yarn dev` or `npm run watch` WHENEVER EDITING THESE RULES!
    'react/jsx-filename-extension': ['warn', { extensions: ['.js', '.jsx', '.ts', '.tsx'] }],
    // ------------------------------
    // Add rules that allow Prettier and ESLint to work together without conflicts (https://stackoverflow.com/a/64166241/):
    indent: ['error', 2, { SwitchCase: 1 }],
    'no-tabs': ['error', { allowIndentationTabs: true }],
    'max-len': [
      'warn',
      {
        code: 180,
        tabWidth: 2,
        comments: 180,
        ignoreComments: false,
        ignoreTrailingComments: true,
        ignoreUrls: true,
        ignoreStrings: true,
        ignoreTemplateLiterals: true,
        ignoreRegExpLiterals: true,
      },
    ],
    // ------------------------------
    'no-use-before-define': 'off', // We must disable the base rule (since it can report incorrect errors) and replace it (https://stackoverflow.com/a/64024916/)
    '@typescript-eslint/no-use-before-define': ['error'],
    'max-lines-per-function': ['error', { max: 70, skipBlankLines: true, skipComments: true }], // https://eslint.org/docs/rules/max-lines-per-function
    'max-lines': ['error', { max: 300, skipBlankLines: true, skipComments: true }], // https://eslint.org/docs/rules/max-lines
    'no-console': 'off', // Console logging is super helpful for development, and we can have our build process strip out all of those statements for production.
    'no-else-return': 'off',
    'react/react-in-jsx-scope': 'off',
    'react/function-component-definition': 'off',
    'react/jsx-props-no-spreading': 'off',
    'simple-import-sort/imports': 'error',
    'simple-import-sort/exports': 'error',
    '@typescript-eslint/prefer-nullish-coalescing': 'error',
    'no-magic-numbers': 'error',
    'react/require-default-props': 'off',
  },
  reportUnusedDisableDirectives: true, // https://eslint.org/docs/user-guide/configuring#report-unused-eslint-disable-comments
  settings: {
    'import/resolver': {
      alias: {
        extensions: ['.js', '.jsx', '.ts', '.tsx'],
        map: [['@', '.']],
      },
    },
  },
  overrides: [
    {
      files: ['./**/*.js', './**/*.jsx', './**/*.ts', './**/*.tsx'],
      rules: {
        'simple-import-sort/imports': [
          'error',
          {
            groups: [
              // Packages `react` related packages come first.
              ['^react', '^@?\\w'],
              // Internal packages.
              ['^(@|components)(/.*|$)'],
              // Side effect imports.
              ['^\\u0000'],
              // Parent imports. Put `..` last.
              ['^\\.\\.(?!/?$)', '^\\.\\./?$'],
              // Other relative imports. Put same-folder imports and `.` last.
              ['^\\./(?=.*/)(?!/?$)', '^\\.(?!/?$)', '^\\./?$'],
              // Style imports.
              ['^.+\\.?(css)$'],
            ],
          },
        ],
      },
    },
  ],
  parserOptions: {
    ecmaVersion: 'latest',
    project: './tsconfig.eslint.json',
  },
};

'''
'''--- .github/workflows/all-tests.yml ---
name: All Tests - Lint, Unit, E2E

on:
  schedule:
    - cron: '0 * * * *'

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install modules
        run: yarn
      - name: Install Playwright Browsers
        run: npx playwright install --with-deps
      - name: Run tests
        run: yarn test
        env:
          SDK_TOKEN_FACTORY_SECRET: ${{secrets.SDK_TOKEN_FACTORY_SECRET}}
          NEXT_PUBLIC_BASE_URL: ${{secrets.NEXT_PUBLIC_BASE_URL}}
          NEXT_PUBLIC_TOKEN_FACTORY_URL: ${{secrets.NEXT_PUBLIC_TOKEN_FACTORY_URL}}
          KYC_ENDPOINT_KEY: ${{secrets.KYC_ENDPOINT_KEY}}
          BUILD_AND_SERVE_WEBSITE_BEFORE_RUNNING_TEST: ${{secrets.BUILD_AND_SERVE_WEBSITE_BEFORE_RUNNING_TEST}}
      - uses: actions/upload-artifact@v3
        if: always()
        with:
          name: playwright-report
          path: tests/e2e/reports/
          retention-days: 30
      - uses: actions/upload-artifact@v3
        if: always()
        with:
          name: screenshots
          path: tests/e2e/screenshots/
          retention-days: 30
      - uses: actions/upload-artifact@v3
        if: always()
        with:
          name: jest-report
          path: tests/unit/reports/
          retention-days: 30

'''
'''--- .github/workflows/jest.yml ---
name: Tests - Jest Unit

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install modules
        run: yarn
      - name: Run tests
        run: yarn test:unit:coverage
      - uses: actions/upload-artifact@v3
        if: always()
        with:
          name: jest-report
          path: tests/unit/reports/
          retention-days: 30

'''
'''--- .github/workflows/nuclei.yml ---
name: Vulnerability Scan - Nuclei

on:
  schedule:
    - cron: '0 0 * * *'

jobs:
  nuclei-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Nuclei - Vulnerability Scan
        uses: projectdiscovery/nuclei-action@main
        with:
          target: ${{secrets.SANDBOX_DEVELOP_URL}}
      - name: GitHub Workflow artifacts
        uses: actions/upload-artifact@v2
        with:
          name: nuclei.log
          path: nuclei.log

'''
'''--- .github/workflows/owasp-zap.yml ---
name: Vulnerability Scan - OWASP ZAP

on:
  schedule:
    - cron: '0 0 * * *'

jobs:
  zap_scan:
    timeout-minutes: 60
    runs-on: ubuntu-latest
    name: Scan the webapplication
    steps:
      - uses: actions/checkout@v3
      - name: ZAP Scan
        uses: zaproxy/action-full-scan@v0.4.0
        with:
          target: ${{secrets.SANDBOX_DEVELOP_URL}}

'''
'''--- .github/workflows/playwright.yml ---
name: Tests - Playwright e2e

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  test:
    timeout-minutes: 60
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 16
      - name: Install dependencies
        run: yarn
      - name: Install Playwright Browsers
        run: npx playwright install --with-deps
      - name: Run Playwright tests
        run: yarn playwright test
        env:
          SDK_TOKEN_FACTORY_SECRET: ${{secrets.SDK_TOKEN_FACTORY_SECRET}}
          NEXT_PUBLIC_BASE_URL: ${{secrets.NEXT_PUBLIC_BASE_URL}}
          NEXT_PUBLIC_TOKEN_FACTORY_URL: ${{secrets.NEXT_PUBLIC_TOKEN_FACTORY_URL}}
          KYC_ENDPOINT_KEY: ${{secrets.KYC_ENDPOINT_KEY}}
          BUILD_AND_SERVE_WEBSITE_BEFORE_RUNNING_TEST: ${{secrets.BUILD_AND_SERVE_WEBSITE_BEFORE_RUNNING_TEST}}
      - uses: actions/upload-artifact@v3
        if: always()
        with:
          name: playwright-report
          path: tests/e2e/reports/
          retention-days: 30
      - uses: actions/upload-artifact@v3
        if: always()
        with:
          name: screenshots
          path: tests/e2e/screenshots/
          retention-days: 30

'''
'''--- README.md ---
# NEAR KYC Onfido [![NEAR](https://img.shields.io/badge/NEAR-%E2%8B%88-111111.svg)](https://near.org/) [![License: GPL v3](https://img.shields.io/badge/License-GPLv3-blue.svg)](LICENSE)

> A KYC flow integrating Onfido's API used by NEAR Foundation for legal purpose

## Technology stack

- [React](https://reactjs.org/)
- [Next.js](https://nextjs.org/)
- [Bootstrap](https://getbootstrap.com/)
- [Onfido](https://documentation.onfido.com/)
- [Yarn](https://yarnpkg.com/)
- [Playwright](https://playwright.dev/)

## Guides

### Configuration

```bash
cp .env.development.local.example .env
# edit variables on .env
```

### Installation

```bash
yarn install
```

### Development

```bash
yarn dev
```

### Deployment

```bash
yarn install
yarn build
yarn start
```

### Tests

#### Unit

```bash
# run all unit tests
yarn test:unit

# run with coverage
yarn test:unit:coverage

# run in verbose mode
yarn test:unit:verbose
```

Once the tests are done, you can find the coverage report in [tests/unit/reports](tests/unit/reports).

#### End to end

If `BUILD_AND_SERVE_WEBSITE_BEFORE_RUNNING_TEST=true` is set in `.env` the website will be built and served every time you run the test command. It is recommended with CI/CD tools.

If you want instead to run the test locally many times for development purpose you may want to set `BUILD_AND_SERVE_WEBSITE_BEFORE_RUNNING_TEST=false` and run `yarn dev` or `yarn build && yarn start` in a separate terminal before running any test. It will run the tests a lot faster by skipping the build step.

```bash
# install testing dependencies (once only)
npx playwright install --with-deps

# headless test
yarn test:e2e

# headed test
yarn test:e2e:headed

# test with debug mode
yarn test:e2e:debug

# serve test reports
yarn test:e2e:report
```

Once the tests are done you can find screenshots of the results page in [/tests/e2e/screenshots](/tests/e2e/screenshots) and the test report in [/tests/e2e/reports](/tests/e2e/reports).

## Authors

- [Ryan](https://github.com/ryancwalsh)
- [Sandoche](https://github.com/sandoche)

## License

[GPLv3](LICENSE)

'''
'''--- components/common/CenteredCardContent.module.css ---
.contentCentered {
  min-height: 37.5em;
  height: 100%;
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
}

'''
'''--- helpers/onfido.ts ---
import { Onfido, Region } from '@onfido/api';

const apiToken = process.env.SDK_TOKEN_FACTORY_SECRET ?? '';
const region = Region.EU; // Supports Region.EU, Region.US and Region.CA

export default function getOnfido() {
  const onfido = new Onfido({
    apiToken,
    region,
  });
  return onfido;
}

'''
'''--- jest.config.js ---
// eslint-disable-next-line @typescript-eslint/no-var-requires
const nextJest = require('next/jest');

const createJestConfig = nextJest({
  // Provide the path to your Next.js app to load next.config.js and .env files in your test environment
  dir: './',
});

// Add any custom config to be passed to Jest
/** @type {import('jest').Config} */
const customJestConfig = {
  // Add more setup options before each test is run
  // setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  // if using TypeScript with a baseUrl set to the root directory then you need the below for alias' to work
  moduleDirectories: ['node_modules', '<rootDir>/'],
  testEnvironment: 'jest-environment-jsdom',
  testMatch: ['**/unit/*.spec.ts'],
  reporters: [
    'default',
    [
      './node_modules/jest-html-reporter',
      {
        pageTitle: 'Jest Test Suite Report',
        outputPath: './tests/unit/reports/test-report.html',
        includeFailureMsg: true,
        includeConsoleLog: true,
        sort: 'titleAsc',
      },
    ],
  ],
};

// createJestConfig is exported this way to ensure that next/jest can load the Next.js config which is async
module.exports = createJestConfig(customJestConfig);

'''
'''--- middleware.ts ---
import csrf from 'edge-csrf';
import type { NextRequest } from 'next/server';
import { NextResponse } from 'next/server';

// initalize protection function
const csrfProtect = csrf();

// eslint-disable-next-line import/prefer-default-export
export async function middleware(request: NextRequest) {
  const response = NextResponse.next();

  // csrf protection
  const csrfError = await csrfProtect(request, response);

  // check result
  if (csrfError) {
    const url = request.nextUrl.clone();
    url.pathname = '/api/csrf-invalid';
    return NextResponse.rewrite(url);
  }

  return response;
}

'''
'''--- next-env.d.ts ---
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.

'''
'''--- next.config.js ---
// woopra and sentry are used by onfido
const contentSecurityPolicy = `
  default-src 'self';
  script-src 'self' 'unsafe-eval' www.woopra.com;
  child-src 'self';
  connect-src 'self' api.onfido.com www.woopra.com sentry.io ws://sync.onfido.com wss://sync.onfido.com;
  img-src 'self' assets.onfido.com blob: data:;
  style-src 'self' cdn.jsdelivr.net maxcdn.bootstrapcdn.com 'unsafe-inline';
  font-src 'self' maxcdn.bootstrapcdn.com;  
`;

// https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Headers_Cheat_Sheet.html
const securityHeaders = [
  {
    key: 'X-DNS-Prefetch-Control',
    value: 'on',
  },
  {
    key: 'Strict-Transport-Security',
    value: 'max-age=63072000; includeSubDomains; preload',
  },
  {
    key: 'X-XSS-Protection',
    value: '1; mode=block',
  },
  {
    key: 'X-Frame-Options',
    value: 'SAMEORIGIN',
  },
  {
    key: 'X-Content-Type-Options',
    value: 'nosniff',
  },
  {
    key: 'Referrer-Policy',
    value: 'origin-when-cross-origin',
  },
  {
    key: 'Content-Security-Policy',
    value: contentSecurityPolicy.replace(/\s{2,}/g, ' ').trim(),
  },
  {
    key: 'Access-Control-Expose-Headers',
    value: '*',
  },
  {
    key: 'Access-Control-Max-Age',
    value: '30',
  },
  {
    key: 'Access-Control-Allow-Headers',
    value: '*',
  },
  {
    key: 'Permissions-Policy',
    value: 'camera=(), microphone=(), geolocation=()',
  },
  {
    key: 'Cross-Origin-Embedder-Policy',
    value: 'unsafe-none',
  },
  {
    key: 'Access-Control-Allow-Methods',
    value: 'POST, GET, OPTIONS',
  },
  {
    key: 'Cross-Origin-Opener-Policy',
    value: 'same-origin',
  },
  {
    key: 'Cross-Origin-Resource-Policy',
    value: 'same-site',
  },
  {
    key: 'Access-Control-Allow-Origin',
    value: process.env.NEXT_PUBLIC_BASE_URL,
  },
  {
    key: 'Access-Control-Allow-Credentials',
    value: 'false',
  },
];

/** @type {import('next').NextConfig} */
module.exports = {
  reactStrictMode: true,
  async headers() {
    return [
      {
        // Apply these headers to all routes in your application.
        source: '/:path*',
        headers: securityHeaders,
      },
    ];
  },
};

'''
'''--- package.json ---
{
  "name": "near-kyc-onfido",
  "version": "1.1.7",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "yarn lint && yarn test:unit && yarn test:e2e",
    "test:unit": "jest",
    "test:unit:verbose": "jest --verbose",
    "test:unit:coverage": "jest --coverage --collectCoverage --coverageDirectory=tests/unit/reports",
    "test:e2e": "playwright test",
    "test:e2e:debug": "playwright test --debug",
    "test:e2e:headed": "playwright test --headed",
    "test:e2e:report": "playwright show-report"
  },
  "dependencies": {
    "@onfido/api": "^2.1.1",
    "@tanstack/react-query": "^4.10.1",
    "add": "^2.0.6",
    "edge-csrf": "^0.2.1",
    "next": "^12.2.0",
    "next-swagger-doc": "^0.3.6",
    "onfido-sdk-ui": "^6.16.0",
    "react": "^18.1.0",
    "react-bootstrap": "^2.5.0",
    "react-dom": "^18.1.0",
    "react-error-boundary": "^3.1.4",
    "react-hook-form": "^7.39.1",
    "react-select": "^5.7.0",
    "yarn": "^1.22.19"
  },
  "devDependencies": {
    "@faker-js/faker": "^7.6.0",
    "@playwright/test": "^1.27.1",
    "@testing-library/jest-dom": "^5.16.5",
    "@testing-library/react": "^13.4.0",
    "@types/node": "^18.8.2",
    "@types/react": "18.0.21",
    "dotenv": "^16.0.3",
    "eslint": "^8.24.0",
    "eslint-config-airbnb-typescript-prettier": "^5.0.0",
    "eslint-config-next": "^12.3.1",
    "eslint-import-resolver-alias": "^1.1.2",
    "eslint-plugin-simple-import-sort": "^8.0.0",
    "jest": "^29.3.1",
    "jest-environment-jsdom": "^29.3.1",
    "jest-html-reporter": "^3.7.0",
    "prettier": "^2.7.1",
    "sass": "^1.43.5",
    "typescript": "4.9.3"
  }
}

'''
'''--- pages/api/check-results.ts ---
// Next.js API route support: https://nextjs.org/docs/api-routes/introduction
import type { NextApiRequest, NextApiResponse } from 'next';

import { COOKIE_CHECK_ID_NAME } from '../../constants';
import getOnfido from '../../helpers/onfido';
import type { CheckResults } from '../../types/CheckResults';
import { CheckResultsStatus } from '../../types/CheckResults';
import getDocumentValidationFailureDetails from '../../utils/getDocumentValidationFailureDetails';
import getFacialValidationFailureDetails from '../../utils/getFacialValidationFailureDetails';
import getStatusFromCheck from '../../utils/getStatusFromCheck';
import { NOT_FOUND, SERVER_ERROR, SUCCESS } from '../../utils/statusCodes';

const endpointName = 'check-results';

const onfido = getOnfido();
/**
 * @swagger
 * /api/check-results:
 *   get:
 *     description: Get check check status
 *     responses:
 *       200:
 *        description: Success
 *        content:
 *          application/json:
 *            schema:
 *              type: object
 *              properties:
 *               isClear:
 *                 type: boolean
 *                 example: true
 *               status:
 *                 type: string
 *                 example: finished
 *               validationFailureDetails:
 *                 type: array
 *                 items:
 *                   type: string
 *
 */
export default async function handler(req: NextApiRequest, res: NextApiResponse<CheckResults | unknown>) {
  try {
    console.log(`[${endpointName}] Request received`);

    const checkId = req.cookies[COOKIE_CHECK_ID_NAME];

    if (!checkId) {
      res.status(NOT_FOUND).json({ isClear: null, status: CheckResultsStatus.notFound, validationFailureDetails: [] });
      return;
    }

    const check = await onfido.check.find(checkId);

    if (!check) {
      res.status(NOT_FOUND).json({ isClear: null, status: CheckResultsStatus.notFound, validationFailureDetails: [] });
      return;
    }

    const reports = await onfido.report.list(checkId);
    const documentReport = reports.find((report) => report.name === 'document');
    const facialReport = reports.find((report) => report.name === 'facial_similarity_photo');

    if (!documentReport || !facialReport) {
      res.status(NOT_FOUND).json({ isClear: null, status: CheckResultsStatus.notFound, validationFailureDetails: [] });
      return;
    }

    const { breakdown: breakdownDocumentReport } = documentReport;
    const documentReportValidationFailureDetails = getDocumentValidationFailureDetails(breakdownDocumentReport);

    const { breakdown: breakdownFacialReport } = facialReport;
    const facialReportValidationFailureDetails = getFacialValidationFailureDetails(breakdownFacialReport);

    const resultStatus = getStatusFromCheck(check);

    res.status(SUCCESS).json({
      ...resultStatus,
      validationFailureDetails: [...documentReportValidationFailureDetails, ...facialReportValidationFailureDetails],
    });
  } catch (error: unknown) {
    console.error({ error });
    res.status(SERVER_ERROR).json(error);
  }
}

'''
'''--- pages/api/create-check.ts ---
// Next.js API route support: https://nextjs.org/docs/api-routes/introduction
import { OnfidoApiError } from '@onfido/api';
import type { NextApiRequest, NextApiResponse } from 'next';

import { COOKIE_CHECK_ID_NAME, COOKIES_EXPIRATION_TIME } from '../../constants';
import getOnfido from '../../helpers/onfido';
import { SERVER_ERROR, SUCCESS } from '../../utils/statusCodes';

const reportNames = [
  'document',
  // 'document_with_address_information',
  // 'document_with_driving_licence_information',
  'facial_similarity_photo',
  // 'facial_similarity_video',
  // 'known_faces',
  // 'identity_enhanced',
  // 'watchlist_enhanced',
  'watchlist_standard',
  // 'watchlist_peps_only',
  // 'watchlist_sanctions_only',
  // 'proof_of_address',
  // 'right_to_work'
];

const endpointName = 'create-check';

const onfido = getOnfido();

/**
 * @swagger
 * /api/create-check:
 *   post:
 *     description: Create check and return success or error code
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *            type: object
 *            properties:
 *              applicantId:
 *                type: string
 *              csrf_token:
 *                type: string
 *     responses:
 *       200:
 *        description: Success
 *        content:
 *          application/json:
 *            schema:
 *              type: object
 *              properties:
 *                code:
 *                  type: number
 *                  example: 200
 */
export default async function handler(req: NextApiRequest, res: NextApiResponse<{ code: number } | unknown>) {
  const { applicantId } = req.body;
  console.log('Starting', endpointName);
  try {
    const check = await onfido.check.create({
      // https://documentation.onfido.com/#check-object
      applicantId,
      reportNames,
    });

    console.log('Storing check id in cookies');
    res.setHeader('Set-Cookie', `${COOKIE_CHECK_ID_NAME}=${check.id}; Max-Age=${COOKIES_EXPIRATION_TIME}; Path=/`);

    console.log('Returning result', endpointName);
    res.status(SUCCESS).json({ code: SUCCESS });
  } catch (error: unknown | OnfidoApiError) {
    if (error instanceof OnfidoApiError) {
      // An error response was received from the Onfido API, extra info is available.
      console.error(error.message);
      console.error(error.type);
      console.error(error.isClientError());
    } else {
      // No response was received for some reason e.g. a network error.
      console.error({ error });
    }
    res.status(SERVER_ERROR).json(error);
  }
}

'''
'''--- pages/api/csrf-invalid.ts ---
import type { NextApiRequest, NextApiResponse } from 'next';

import { FORBIDDEN } from '../../utils/statusCodes';

type Data = {
  status: string;
  code: number;
};

export default function handler(req: NextApiRequest, res: NextApiResponse<Data>) {
  res.status(FORBIDDEN).send({ status: 'Invalid csrf token', code: FORBIDDEN });
}

'''
'''--- pages/api/doc.ts ---
import type { NextApiRequest, NextApiResponse } from 'next';
import { withSwagger } from 'next-swagger-doc';

import packageJson from '../../package.json';
import { NOT_FOUND } from '../../utils/statusCodes';

const { version } = packageJson;

const productionHandler = (req: NextApiRequest, res: NextApiResponse<{ status: string; code: number }>) => {
  res.status(NOT_FOUND).send({ status: 'Endpoint not found', code: NOT_FOUND });
};

const swaggerHandler = withSwagger({
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'NEAR Onfido API',
      version,
    },
  },
  apiFolder: 'pages/api',
});

export default process.env.NODE_ENV === 'production' ? productionHandler : swaggerHandler();

'''
'''--- pages/api/generate-token.ts ---
// Next.js API route support: https://nextjs.org/docs/api-routes/introduction
import { OnfidoApiError } from '@onfido/api';
import type { NextApiRequest, NextApiResponse } from 'next';

import { COOKIE_NUMBER_OF_TRIES_NAME, COOKIES_EXPIRATION_TIME, MAX_NUMBER_OF_TRIES } from '../../constants';
import getOnfido from '../../helpers/onfido';
import type ApplicantProperties from '../../types/ApplicantProperties';
import type ApplicantTokenPair from '../../types/ApplicantTokenPair';
import { FORBIDDEN, SERVER_ERROR, SUCCESS } from '../../utils/statusCodes';

const endpointName = 'generate-token';

const onfido = getOnfido();

/**
 * @swagger
 * /api/generate-token:
 *   post:
 *     description: Create and return an applicant and sdk token
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *            type: object
 *            properties:
 *              firstName:
 *                type: string
 *              lastName:
 *                type: string
 *              email:
 *                type: string
 *              dob:
 *                type: string
 *              csrf_token:
 *                type: string
 *              countryOfResidence:
 *                type: string
 *     responses:
 *       200:
 *        description: Success
 *        content:
 *          application/json:
 *            schema:
 *              type: object
 *              properties:
 *                applicantId:
 *                  type: string
 *                sdkToken:
 *                  type: string
 */
export default async function handler(req: NextApiRequest, res: NextApiResponse<ApplicantTokenPair | unknown>) {
  try {
    const ipAddress = req.headers['x-real-ip'] ?? req.connection.remoteAddress;

    const applicantProperties: ApplicantProperties = {
      ...req.body,
      location: {
        ipAddress,
        countryOfResidence: req.body.countryOfResidence,
      },
      consents: [
        {
          name: 'privacy_notices_read',
          granted: true,
        },
      ],
    }; // https://documentation.onfido.com/#applicant-object

    console.log('Starting', endpointName);
    const applicant = await onfido.applicant.create(applicantProperties);

    console.log('Applicant created', endpointName);
    const ZERO = '0';
    const ONE = 1;
    const numberOfTriesString = req.cookies[COOKIE_NUMBER_OF_TRIES_NAME] ?? ZERO;
    const numberOfTries = parseInt(numberOfTriesString, 10);

    if (numberOfTries >= MAX_NUMBER_OF_TRIES) {
      res.status(FORBIDDEN).json({ status: 'Maximum number of tries reached', code: FORBIDDEN });
      return;
    }

    const sdkToken = await onfido.sdkToken.generate({
      applicantId: applicant.id,
      // referrer: 'http://localhost/**'
      // crossDeviceUrl: "https://example.com"
    });
    const result = { applicantId: applicant.id, sdkToken };
    const newNumberOfTries = numberOfTries + ONE;

    res.setHeader('Set-Cookie', [`${COOKIE_NUMBER_OF_TRIES_NAME}=${newNumberOfTries}; Path=/; Max-Age=${COOKIES_EXPIRATION_TIME}`]);

    console.log('Returning result', endpointName);
    res.status(SUCCESS).json(result);
  } catch (error: unknown | OnfidoApiError) {
    if (error instanceof OnfidoApiError) {
      // An error response was received from the Onfido API, extra info is available.
      console.error(error.message);
      console.error(error.type);
      console.error(error.isClientError());
    } else {
      // No response was received for some reason e.g. a network error.
      console.error({ error });
    }
    res.status(SERVER_ERROR).json(error);
  }
}

'''
'''--- pages/api/version.ts ---
import type { NextApiRequest, NextApiResponse } from 'next';

import packageJson from '../../package.json';
import { SUCCESS } from '../../utils/statusCodes';

/**
 * @swagger
 * /api/version:
 *   get:
 *     description: Returns the app version number
 *     responses:
 *       200:
 *         description: Success
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 version:
 *                   type: string
 *                   example: 1.0.0
 */
export default function handler(req: NextApiRequest, res: NextApiResponse<{ version: string }>) {
  const { version } = packageJson;
  res.status(SUCCESS).send({ version });
}

'''
'''--- playwright.config.ts ---
import type { PlaywrightTestConfig } from '@playwright/test';
// eslint-disable-next-line import/no-extraneous-dependencies
import { devices } from '@playwright/test';
// eslint-disable-next-line import/no-extraneous-dependencies
import * as dotenv from 'dotenv';

/**
 * Read environment variables from file.
 * https://github.com/motdotla/dotenv
 */
dotenv.config();

const MAXIMUM_TIME_PER_TEST_IN_MILLISECONDS = 120_000;
const MAXIMUM_TIME_TO_WAIT_FOR_CONDITION_IN_MILLISECONDS = 10_000;

/**
 * See https://playwright.dev/docs/test-configuration.
 */
const config: PlaywrightTestConfig = {
  testDir: './tests/e2e',
  /* Maximum time one test can run for. */
  timeout: MAXIMUM_TIME_PER_TEST_IN_MILLISECONDS,
  expect: {
    /**
     * Maximum time expect() should wait for the condition to be met.
     * For example in `await expect(locator).toHaveText();`
     */
    timeout: MAXIMUM_TIME_TO_WAIT_FOR_CONDITION_IN_MILLISECONDS,
  },
  /* Run tests in files in parallel */
  fullyParallel: true,
  /* Fail the build on CI if you accidentally left test.only in the source code. */
  forbidOnly: !!process.env.CI,
  /* Retry on CI only */
  retries: process.env.CI ? 2 : 0,
  /* Opt out of parallel tests on CI. */
  workers: 1, // I defaulted workers to 1 beacause of the rate limit of Onfido
  /* Reporter to use. See https://playwright.dev/docs/test-reporters */
  reporter: [['html', { outputFolder: 'tests/e2e/reports' }]],
  /* Shared settings for all the projects below. See https://playwright.dev/docs/api/class-testoptions. */
  use: {
    /* Maximum time each action such as `click()` can take. Defaults to 0 (no limit). */
    actionTimeout: 0,
    /* Base URL to use in actions like `await page.goto('/')`. */
    // baseURL: 'http://localhost:3000',

    /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */
    trace: 'on-first-retry',
  },

  /* Configure projects for major browsers */
  projects: [
    {
      name: 'chromium',
      use: {
        ...devices['Desktop Chrome'],
      },
    },

    // {
    //   name: 'firefox',
    //   use: {
    //     ...devices['Desktop Firefox'],
    //   },
    // },

    // {
    //   name: 'webkit',
    //   use: {
    //     ...devices['Desktop Safari'],
    //   },
    // },

    /* Test against mobile viewports. */
    // {
    //   name: 'Mobile Chrome',
    //   use: {
    //     ...devices['Pixel 5'],
    //   },
    // },
    // {
    //   name: 'Mobile Safari',
    //   use: {
    //     ...devices['iPhone 12'],
    //   },
    // },

    /* Test against branded browsers. */
    // {
    //   name: 'Microsoft Edge',
    //   use: {
    //     channel: 'msedge',
    //   },
    // },
    // {
    //   name: 'Google Chrome',
    //   use: {
    //     channel: 'chrome',
    //   },
    // },
  ],

  /* Folder for test artifacts such as screenshots, videos, traces, etc. */
  // outputDir: 'test-results/',

  /* Run your local dev server before starting the tests */
  webServer:
    process.env.BUILD_AND_SERVE_WEBSITE_BEFORE_RUNNING_TEST === 'true'
      ? {
          command: 'yarn build && yarn start',
          port: 3000,
        }
      : undefined,
};

export default config;

'''
'''--- prettier.config.js ---
module.exports = {
  trailingComma: 'all',
  endOfLine: 'auto',
  printWidth: 180,
  bracketSpacing: true,
  useTabs: false,
  tabWidth: 2,
  semi: true,
  singleQuote: true,
  arrowParens: 'always',
  overrides: [
    {
      files: 'Routes.js',
      options: {
        printWidth: 200,
      },
    },
  ],
};

'''
'''--- public/img/logo_nm.svg ---
<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 342 90"><path d="M171.21,18.75v52.5a.76.76,0,0,1-.75.75H165a7.49,7.49,0,0,1-6.3-3.43l-24.78-38.3.85,19.13V71.25A.76.76,0,0,1,134,72h-7.22a.76.76,0,0,1-.75-.75V18.75a.76.76,0,0,1,.75-.75h5.43a7.52,7.52,0,0,1,6.3,3.42l24.78,38.24-.77-19.06V18.75a.75.75,0,0,1,.75-.75h7.22A.76.76,0,0,1,171.21,18.75Z"/><path d="M245,72h-7.64a.75.75,0,0,1-.7-1L256.9,18.72A1.14,1.14,0,0,1,258,18h9.57a1.14,1.14,0,0,1,1.05.72L288.8,71a.75.75,0,0,1-.7,1h-7.64a.76.76,0,0,1-.71-.48l-16.31-43a.75.75,0,0,0-1.41,0l-16.31,43A.76.76,0,0,1,245,72Z"/><path d="M341.84,70.79,326.66,51.4c8.57-1.62,13.58-7.4,13.58-16.27,0-10.19-6.63-17.13-18.36-17.13H300.71a1.12,1.12,0,0,0-1.12,1.13h0a7.2,7.2,0,0,0,7.2,7.2H321c7.09,0,10.49,3.63,10.49,8.87s-3.32,8.95-10.49,8.95H300.71a1.13,1.13,0,0,0-1.12,1.13v26a.75.75,0,0,0,.75.75h7.22a.76.76,0,0,0,.75-.75V51.87h8.33l13.17,17.19a7.51,7.51,0,0,0,6,2.94h5.48A.75.75,0,0,0,341.84,70.79Z"/><path d="M222.17,18h-33.5a1,1,0,0,0-1,1h0A7.33,7.33,0,0,0,195,26.33h27.17a.74.74,0,0,0,.75-.75V18.75A.75.75,0,0,0,222.17,18Zm0,45.67h-25a.76.76,0,0,1-.75-.75V49.38a.75.75,0,0,1,.75-.75h23.11a.75.75,0,0,0,.75-.75V41a.75.75,0,0,0-.75-.75H188.79a1.13,1.13,0,0,0-1.12,1.13V70.88A1.12,1.12,0,0,0,188.79,72h33.38a.75.75,0,0,0,.75-.75V64.42A.74.74,0,0,0,222.17,63.67Z"/><path d="M72.24,4.57,53.42,32.5a2,2,0,0,0,3,2.63L74.91,19.08a.74.74,0,0,1,1.24.56V69.93a.75.75,0,0,1-1.32.48l-56-67A9.59,9.59,0,0,0,11.54,0H9.59A9.59,9.59,0,0,0,0,9.59V80.41A9.59,9.59,0,0,0,9.59,90h0a9.59,9.59,0,0,0,8.17-4.57L36.58,57.5a2,2,0,0,0-3-2.63L15.09,70.92a.74.74,0,0,1-1.24-.56V20.07a.75.75,0,0,1,1.32-.48l56,67A9.59,9.59,0,0,0,78.46,90h2A9.59,9.59,0,0,0,90,80.41V9.59A9.59,9.59,0,0,0,80.41,0h0A9.59,9.59,0,0,0,72.24,4.57Z"/></svg>
'''
'''--- services/apiService.ts ---
import type ApplicantProperties from '../types/ApplicantProperties';
import type ApplicantTokenPair from '../types/ApplicantTokenPair';
import type { CheckResults } from '../types/CheckResults';

const tokenFactoryUrl = process.env.NEXT_PUBLIC_TOKEN_FACTORY_URL ?? '';

export const fetchCheckResults = async (): Promise<CheckResults> => {
  return fetch('/api/check-results').then((res) => res.json());
};

export const initCheck = async (data: { applicantId: string; csrf_token: string }): Promise<unknown> => {
  const options = {
    method: 'POST',
    body: JSON.stringify(data),
    headers: {
      'Content-Type': 'application/json',
    },
  };

  return fetch('/api/create-check', options).then((res) => res.json());
};

export const getToken = async (applicantProperties: ApplicantProperties): Promise<ApplicantTokenPair> => {
  const tokenOptions = {
    method: 'POST',
    body: JSON.stringify({ ...applicantProperties }),
    headers: {
      'Content-Type': 'application/json',
    },
  };

  return fetch(tokenFactoryUrl, tokenOptions).then((res) => res.json());
};

'''
'''--- tests/e2e/api-generate-tokens.spec.ts ---
/* eslint-disable no-await-in-loop */
import { faker } from '@faker-js/faker';
import { BrowserContext, expect, test } from '@playwright/test';

import { MAX_NUMBER_OF_TRIES } from '../../constants';
import type ApplicantProperties from '../../types/ApplicantProperties';
import listOfCountries from '../../utils/listOfCountries';
import { FORBIDDEN, SUCCESS } from '../../utils/statusCodes';

import { API_URL, FLOW_URL } from './utils/constants';

let desktop: BrowserContext;
let applicant: ApplicantProperties;
let countryOfResidence: string;

const ZERO = 0;

test.beforeEach(async ({ browser }) => {
  desktop = await browser.newContext({
    permissions: ['clipboard-write', 'clipboard-read'],
  });

  countryOfResidence = listOfCountries[Math.floor(Math.random() * listOfCountries.length)].value;

  applicant = {
    firstName: faker.name.firstName(),
    lastName: faker.name.lastName(),
    email: faker.internet.email(),
    dob: faker.date.birthdate({ min: 18, max: 65, mode: 'age' }).toISOString().split('T')[0],
    countryOfResidence,
  };
});

test('/api/generate-token should return 403 if the applicant has reached the retry limit', async () => {
  const desktopPage = await desktop.newPage();
  await desktopPage.goto(FLOW_URL);
  // eslint-disable-next-line no-underscore-dangle
  const csrfToken = await desktopPage.evaluate(() => window.__NEXT_DATA__.props.pageProps.csrfToken);

  // eslint-disable-next-line no-plusplus
  for (let i = ZERO; i < MAX_NUMBER_OF_TRIES; i++) {
    const response = await desktopPage.request.post(`${API_URL}/generate-token`, {
      data: {
        ...applicant,
        csrf_token: csrfToken,
      },
    });

    await expect(response.status()).toEqual(SUCCESS);
    await expect(await response.json()).toHaveProperty('applicantId');
    await expect(await response.json()).toHaveProperty('sdkToken');
  }

  const errorResponse = await desktopPage.request.post(`${API_URL}/generate-token`, {
    data: {
      ...applicant,
      csrf_token: csrfToken,
    },
  });

  await expect(errorResponse.status()).toEqual(FORBIDDEN);
  const { code, status } = await errorResponse.json();

  expect(code).toBe(FORBIDDEN);
  expect(status).toBe('Maximum number of tries reached');
});

'''
'''--- tests/e2e/flows.spec.ts ---
import { faker } from '@faker-js/faker';
import { Browser, BrowserContext, chromium, expect, test } from '@playwright/test';

import type ApplicantProperties from '../../types/ApplicantProperties';

import { MOCK_VIDEO_PATH } from './utils/constants';
import { continueOnfidoFlowThenGetAndTestLink, fillStartForm, openKycLinkAndTestDocumentAndPhotoScan, submittingDocuments } from './utils/helpers';

let browserWithMockedWebcam: Browser;
let desktop: BrowserContext;
let mobile: BrowserContext;
let applicant: ApplicantProperties;

test.beforeEach(async ({ browser }) => {
  browserWithMockedWebcam = await chromium.launch({
    args: ['--use-fake-ui-for-media-stream', '--use-fake-device-for-media-stream', `--use-file-for-fake-video-capture=${MOCK_VIDEO_PATH}`],
  });

  desktop = await browser.newContext({
    permissions: ['clipboard-write', 'clipboard-read'],
  });

  mobile = await browserWithMockedWebcam.newContext({
    userAgent: 'Mozilla/5.0 (Linux; Android 13) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.5249.126 Mobile Safari/537.36',
    permissions: ['camera'],
  });

  applicant = {
    firstName: faker.name.firstName(),
    lastName: faker.name.lastName(),
    email: faker.internet.email(),
    dob: faker.date.birthdate({ min: 18, max: 65, mode: 'age' }).toISOString().split('T')[0],
  };
});

test('Applicant should be able to fill the form with a browser, submit documents and photo with a phone and see a Verification validated message', async () => {
  const desktopPage = await desktop.newPage();

  await fillStartForm(desktopPage, applicant);
  const url = await continueOnfidoFlowThenGetAndTestLink(desktopPage, expect);

  const mobilePage = await mobile.newPage();
  await openKycLinkAndTestDocumentAndPhotoScan(url, mobilePage, expect);

  await submittingDocuments(desktopPage);
  await expect(desktopPage.getByRole('heading', { name: /Verification/i })).toHaveText('Verification validated');
  await desktopPage.screenshot({ path: 'tests/e2e/screenshots/validated.png', fullPage: true });
});

test('Applicant should be able to fill the form with a browser, submit documents and photo with a phone and see a Verification failed message and be able to retry', async () => {
  const desktopPage = await desktop.newPage();

  await fillStartForm(desktopPage, { ...applicant, lastName: 'consider' });
  const url = await continueOnfidoFlowThenGetAndTestLink(desktopPage, expect);

  const mobilePage = await mobile.newPage();
  await openKycLinkAndTestDocumentAndPhotoScan(url, mobilePage, expect);

  await submittingDocuments(desktopPage);
  await expect(desktopPage.getByRole('heading', { name: /Verification/i })).toHaveText('Verification failed');
  await desktopPage.screenshot({ path: 'tests/e2e/screenshots/failed.png', fullPage: true });

  await desktopPage.getByRole('link', { name: 'Try again' }).click();
  await expect(desktopPage.getByText(/Verify your identity/i)).toHaveText('Verify your identity');
});

test('Upon submitting an unsupported document, applicant should see an error message about the document not being supported', async () => {
  const desktopPage = await desktop.newPage();

  await fillStartForm(desktopPage, { ...applicant, firstName: 'Image Integrity - Supported Document' });
  const url = await continueOnfidoFlowThenGetAndTestLink(desktopPage, expect);

  const mobilePage = await mobile.newPage();
  await openKycLinkAndTestDocumentAndPhotoScan(url, mobilePage, expect);

  await submittingDocuments(desktopPage);

  await expect(await desktopPage.getByRole('list', { name: 'error list' })).toHaveText(/There are issues with the images provided/);
  await expect(await desktopPage.getByRole('list', { name: 'error list' })).toHaveText(/The document provided is not supported/);
  await expect(desktopPage.getByText(/We could not verify your identity/)).toHaveText('We could not verify your identity. We invite you to read the reasons below and try again.');
  await desktopPage.screenshot({ path: 'tests/e2e/screenshots/failed_image_integrity_supported_docs.png', fullPage: true });
});

test('Upon submitting picture with quality issues, applicant should see an error message about the pictures having quality issues', async () => {
  const desktopPage = await desktop.newPage();

  await fillStartForm(desktopPage, { ...applicant, firstName: 'Image Integrity - Image Quality' });
  const url = await continueOnfidoFlowThenGetAndTestLink(desktopPage, expect);

  const mobilePage = await mobile.newPage();
  await openKycLinkAndTestDocumentAndPhotoScan(url, mobilePage, expect);

  await submittingDocuments(desktopPage);

  await expect(await desktopPage.getByRole('list', { name: 'error list' })).toHaveText(/There are issues with the images provided/);
  await expect(await desktopPage.getByRole('list', { name: 'error list' })).toHaveText(
    /The picture\(s\) you provided have quality issues, which may include: blurriness, darkness, glare, obstruction, etc./,
  );
  await expect(desktopPage.getByText(/We could not verify your identity/)).toHaveText('We could not verify your identity. We invite you to read the reasons below and try again.');
  await desktopPage.screenshot({ path: 'tests/e2e/screenshots/failed_image_integrity_image_quality.png', fullPage: true });
});

test('Upon submitting an non-readable document, applicant should see an error message about the document not being readable', async () => {
  const desktopPage = await desktop.newPage();

  await fillStartForm(desktopPage, { ...applicant, firstName: 'Visual Authenticity - Fonts' });
  const url = await continueOnfidoFlowThenGetAndTestLink(desktopPage, expect);

  const mobilePage = await mobile.newPage();
  await openKycLinkAndTestDocumentAndPhotoScan(url, mobilePage, expect);

  await submittingDocuments(desktopPage);
  await expect(await desktopPage.getByRole('list', { name: 'error list' })).toHaveText(/There are issues with the pictures you provided/);
  await expect(await desktopPage.getByRole('list', { name: 'error list' })).toHaveText(/The document provided is not readable/);
  await expect(desktopPage.getByText(/We could not verify your identity/)).toHaveText('We could not verify your identity. We invite you to read the reasons below and try again.');
  await desktopPage.screenshot({ path: 'tests/e2e/screenshots/failed_visual_authenticity_fonts.png', fullPage: true });
});

test('Upon submitting an non authentic document, applicant should see an error message about the document not being authentic', async () => {
  const desktopPage = await desktop.newPage();

  await fillStartForm(desktopPage, { ...applicant, firstName: 'Visual Authenticity - Security Features' });
  const url = await continueOnfidoFlowThenGetAndTestLink(desktopPage, expect);

  const mobilePage = await mobile.newPage();
  await openKycLinkAndTestDocumentAndPhotoScan(url, mobilePage, expect);

  await submittingDocuments(desktopPage);
  await expect(await desktopPage.getByRole('list', { name: 'error list' })).toHaveText(/There are issues with the pictures you provided/);
  await expect(await desktopPage.getByRole('list', { name: 'error list' })).toHaveText(/The documents provided are not valid/);
  await expect(desktopPage.getByText(/We could not verify your identity/)).toHaveText('We could not verify your identity. We invite you to read the reasons below and try again.');
  await desktopPage.screenshot({ path: 'tests/e2e/screenshots/failed_visual_authenticity_security_features.png', fullPage: true });
});

test('Upon submitting an document without a clear face, applicant should see an error message about the document not having an identifiable face', async () => {
  const desktopPage = await desktop.newPage();

  await fillStartForm(desktopPage, { ...applicant, firstName: 'Visual Authenticity - Face Detection' });
  const url = await continueOnfidoFlowThenGetAndTestLink(desktopPage, expect);

  const mobilePage = await mobile.newPage();
  await openKycLinkAndTestDocumentAndPhotoScan(url, mobilePage, expect);

  await submittingDocuments(desktopPage);
  await expect(await desktopPage.getByRole('list', { name: 'error list' })).toHaveText(/There are issues with the pictures you provided/);
  await expect(await desktopPage.getByRole('list', { name: 'error list' })).toHaveText(/The face could not be detected/);
  await expect(desktopPage.getByText(/We could not verify your identity/)).toHaveText('We could not verify your identity. We invite you to read the reasons below and try again.');
  await desktopPage.screenshot({ path: 'tests/e2e/screenshots/failed_visual_authenticity_face_detection.png', fullPage: true });
});

test('Upon submitting a document with wrong numbers, applicant should see an error message about the document having invalid numbers', async () => {
  const desktopPage = await desktop.newPage();

  await fillStartForm(desktopPage, { ...applicant, firstName: 'Data Validation - Document Numbers' });
  const url = await continueOnfidoFlowThenGetAndTestLink(desktopPage, expect);

  const mobilePage = await mobile.newPage();
  await openKycLinkAndTestDocumentAndPhotoScan(url, mobilePage, expect);

  await submittingDocuments(desktopPage);
  await expect(await desktopPage.getByRole('list', { name: 'error list' })).toHaveText(/The data from your documents contains some errors/);
  await expect(await desktopPage.getByRole('list', { name: 'error list' })).toHaveText(/The document numbers you provided are invalid/);
  await expect(desktopPage.getByText(/We could not verify your identity/)).toHaveText('We could not verify your identity. We invite you to read the reasons below and try again.');
  await desktopPage.screenshot({ path: 'tests/e2e/screenshots/failed_data_validation_document_numbers.png', fullPage: true });
});

test('Upon submitting an invalid document type, applicant should see an error message about the document having an invalid type', async () => {
  const desktopPage = await desktop.newPage();

  await fillStartForm(desktopPage, { ...applicant, firstName: 'Data Consistency - Document Type' });
  const url = await continueOnfidoFlowThenGetAndTestLink(desktopPage, expect);

  const mobilePage = await mobile.newPage();
  await openKycLinkAndTestDocumentAndPhotoScan(url, mobilePage, expect);

  await submittingDocuments(desktopPage);
  await expect(await desktopPage.getByRole('list', { name: 'error list' })).toHaveText(/The document provided does not match the information provided/);
  await expect(await desktopPage.getByRole('list', { name: 'error list' })).toHaveText(/The document type you provided is invalid/);
  await expect(desktopPage.getByText(/We could not verify your identity/)).toHaveText('We could not verify your identity. We invite you to read the reasons below and try again.');
  await desktopPage.screenshot({ path: 'tests/e2e/screenshots/failed_data_consistency_document_type.png', fullPage: true });
});

test('Upon submitting a fake document, applicant should see an error message about the document not being authentic', async () => {
  const desktopPage = await desktop.newPage();

  await fillStartForm(desktopPage, { ...applicant, firstName: 'Visual Authenticity - Spoofing Detection' });
  const url = await continueOnfidoFlowThenGetAndTestLink(desktopPage, expect);

  const mobilePage = await mobile.newPage();
  await openKycLinkAndTestDocumentAndPhotoScan(url, mobilePage, expect);

  await submittingDocuments(desktopPage);
  await expect(await desktopPage.getByRole('list', { name: 'error list' })).toHaveText('The picture provided does not seem authentic');
  await expect(desktopPage.getByText(/We could not verify your identity/)).toHaveText('We could not verify your identity. We invite you to read the reasons below and try again.');
  await desktopPage.screenshot({ path: 'tests/e2e/screenshots/failed_visual_authenticity_spoofing_detection.png', fullPage: true });
});

test('Upon submitting a photo different from the documents, applicant should see an error message about the photo not matching the document', async () => {
  const desktopPage = await desktop.newPage();

  await fillStartForm(desktopPage, { ...applicant, firstName: 'Face Comparison - Face Match' });
  const url = await continueOnfidoFlowThenGetAndTestLink(desktopPage, expect);

  const mobilePage = await mobile.newPage();
  await openKycLinkAndTestDocumentAndPhotoScan(url, mobilePage, expect);

  await submittingDocuments(desktopPage);
  await expect(await desktopPage.getByRole('list', { name: 'error list' })).toHaveText('The picture does not match the document provided');
  await expect(desktopPage.getByText(/We could not verify your identity/)).toHaveText('We could not verify your identity. We invite you to read the reasons below and try again.');
  await desktopPage.screenshot({ path: 'tests/e2e/screenshots/failed_face_comparison_face_match.png', fullPage: true });
});

test('Upon submitting an invalid photo, applicant should see an error message about the photo being invalid', async () => {
  const desktopPage = await desktop.newPage();

  await fillStartForm(desktopPage, { ...applicant, firstName: 'Image Integrity - Source Integrity' });
  const url = await continueOnfidoFlowThenGetAndTestLink(desktopPage, expect);

  const mobilePage = await mobile.newPage();
  await openKycLinkAndTestDocumentAndPhotoScan(url, mobilePage, expect);

  await submittingDocuments(desktopPage);
  await expect(await desktopPage.getByRole('list', { name: 'error list' })).toHaveText('The photo provided is not valid');
  await expect(desktopPage.getByText(/We could not verify your identity/)).toHaveText('We could not verify your identity. We invite you to read the reasons below and try again.');
  await desktopPage.screenshot({ path: 'tests/e2e/screenshots/failed_image_integrity_source_integrity.png', fullPage: true });
});

test('Upon submitting a photo with another face, applicant should see an error message about the many faces detected in the photo', async () => {
  const desktopPage = await desktop.newPage();

  await fillStartForm(desktopPage, { ...applicant, firstName: 'Image Integrity - Face Detected' });
  const url = await continueOnfidoFlowThenGetAndTestLink(desktopPage, expect);

  const mobilePage = await mobile.newPage();
  await openKycLinkAndTestDocumentAndPhotoScan(url, mobilePage, expect);

  await submittingDocuments(desktopPage);
  await expect(await desktopPage.getByRole('list', { name: 'error list' })).toHaveText('Another face has been detected in the picture');
  await expect(desktopPage.getByText(/We could not verify your identity/)).toHaveText('We could not verify your identity. We invite you to read the reasons below and try again.');
  await desktopPage.screenshot({ path: 'tests/e2e/screenshots/failed_image_integrity_face_detected.png', fullPage: true });
});

'''
'''--- tests/e2e/form-validation.spec.ts ---
/* eslint-disable no-restricted-syntax */
/* eslint-disable no-await-in-loop */
import { faker } from '@faker-js/faker';
import { BrowserContext, expect, test } from '@playwright/test';

import { FORBIDDEN_CHARACTERS } from '../../constants';
import type ApplicantProperties from '../../types/ApplicantProperties';

import { FLOW_URL } from './utils/constants';
import { fillStartForm } from './utils/helpers';

let desktop: BrowserContext;
let applicant: ApplicantProperties;

test.beforeEach(async ({ browser }) => {
  desktop = await browser.newContext({
    permissions: ['clipboard-write', 'clipboard-read'],
  });
  applicant = {
    firstName: faker.name.firstName(),
    lastName: faker.name.lastName(),
    email: faker.internet.email(),
    dob: faker.date.birthdate({ min: 10, max: 17, mode: 'age' }).toISOString().split('T')[0],
  };
});

test('Form should display error messages when fields are left empty or with invalid data', async () => {
  const desktopPage = await desktop.newPage();

  await desktopPage.goto(FLOW_URL);

  await desktopPage.getByRole('textbox', { name: /First Name/ }).click();
  await desktopPage.getByRole('textbox', { name: /Last Name/ }).click();
  await expect(desktopPage.getByText(/First name is required/)).toHaveText(/First name is required/);

  await desktopPage.getByRole('textbox', { name: /email/ }).click();
  await expect(desktopPage.getByText(/Last name is required/)).toHaveText(/Last name is required/);

  await desktopPage.getByRole('textbox', { name: /Date of birth/ }).fill('');
  await desktopPage.getByRole('textbox', { name: /First Name/ }).click();
  await desktopPage.getByRole('textbox', { name: /First Name/ }).fill('     ');
  await desktopPage.getByRole('textbox', { name: /Last Name/ }).click();
  await desktopPage.getByRole('textbox', { name: /Last Name/ }).fill('     ');
  await expect(desktopPage.getByText(/A valid email address is required/)).toHaveText(/A valid email address is required/);
  await expect(desktopPage.getByText(/Sorry, we can only verify people who are at least 18 years old/)).toHaveText(
    /Sorry, we can only verify people who are at least 18 years old/,
  );

  await desktopPage.getByRole('textbox', { name: /email/ }).click();
  await desktopPage.getByRole('textbox', { name: /email/ }).fill('a@a.a');
  await desktopPage.getByRole('textbox', { name: /Date of birth/ }).fill('5000-01-01');

  await desktopPage.getByText(/I have read and agree to the privacy policy/).click();
  await desktopPage.getByText(/I have read and agree to the privacy policy/).click();
  await expect(desktopPage.getByText(/You must agree to the privacy policy before submitting/)).toHaveText(/You must agree to the privacy policy before submitting/);
  await desktopPage.screenshot({ path: 'tests/e2e/screenshots/form_validation.png', fullPage: true });

  await desktopPage.getByText(/I have read and agree to the privacy policy/).click();
  await desktopPage.getByRole('button', { name: /Start/ }).click();

  await expect(desktopPage.getByText(/First name is required/)).toHaveText(/First name is required/);
  await expect(desktopPage.getByText(/Last name is required/)).toHaveText(/Last name is required/);
  await expect(desktopPage.getByText(/A valid email address is required/)).toHaveText(/A valid email address is required/);
  await expect(desktopPage.getByText(/Sorry, we can only verify people who are at least 18 years old/)).toHaveText(
    /Sorry, we can only verify people who are at least 18 years old/,
  );
  await expect(desktopPage.getByText(/The country of residence is required/)).toHaveText(/The country of residence is required/);

  await desktopPage.screenshot({ path: 'tests/e2e/screenshots/form_validation_submit_pressed.png', fullPage: true });
});

test('Form should not let anyone under 18 submit the form', async () => {
  const desktopPage = await desktop.newPage();
  await fillStartForm(desktopPage, applicant);
  await expect(desktopPage.getByText(/Sorry, we can only verify people who are at least 18 years old/)).toHaveText(
    /Sorry, we can only verify people who are at least 18 years old/,
  );
});

test('Form should not let anyone with invalid firstname submit the form', async () => {
  const desktopPage = await desktop.newPage();
  const dob = faker.date.birthdate({ min: 18, max: 60, mode: 'age' }).toISOString().split('T')[0];

  for (const character of FORBIDDEN_CHARACTERS) {
    const firstName = `${applicant.firstName}${character}`;
    await fillStartForm(desktopPage, { ...applicant, firstName, dob });
    await expect(desktopPage.getByText(`First name cannot contain special characters such as ${FORBIDDEN_CHARACTERS}`)).toHaveText(
      `First name cannot contain special characters such as ${FORBIDDEN_CHARACTERS}`,
    );
  }
});

test('Form should not let anyone with spaces as firstname', async () => {
  const desktopPage = await desktop.newPage();
  await fillStartForm(desktopPage, { ...applicant, firstName: '     ' });
  await expect(desktopPage.getByText(/First name is required/)).toHaveText(/First name is required/);
});

test('Form should not let anyone with invalid lastname submit the form', async () => {
  const desktopPage = await desktop.newPage();
  const dob = faker.date.birthdate({ min: 18, max: 60, mode: 'age' }).toISOString().split('T')[0];

  for (const character of FORBIDDEN_CHARACTERS) {
    const lastName = `${applicant.lastName}${character}`;
    await fillStartForm(desktopPage, { ...applicant, lastName, dob });
    await expect(desktopPage.getByText(`Last name cannot contain special characters such as ${FORBIDDEN_CHARACTERS}`)).toHaveText(
      `Last name cannot contain special characters such as ${FORBIDDEN_CHARACTERS}`,
    );
  }
});

test('Form should not let anyone with spaces as lastname', async () => {
  const desktopPage = await desktop.newPage();
  await fillStartForm(desktopPage, { ...applicant, lastName: '     ' });
  await expect(desktopPage.getByText(/Last name is required/)).toHaveText(/Last name is required/);
});

'''
'''--- tests/e2e/homepage.spec.ts ---
import { BrowserContext, expect, test } from '@playwright/test';

import { HOME_URL } from './utils/constants';

let desktop: BrowserContext;

test.beforeEach(async ({ browser }) => {
  desktop = await browser.newContext({
    permissions: ['clipboard-write', 'clipboard-read'],
  });
});

test('User should not be able to access the form in the homepage', async () => {
  const desktopPage = await desktop.newPage();

  await desktopPage.goto(HOME_URL);

  const NOT_EXISTING_ELEMENT_COUNT = 0;
  await expect(desktopPage.getByRole('textbox', { name: /First Name/i })).toHaveCount(NOT_EXISTING_ELEMENT_COUNT);
});

'''
'''--- tests/e2e/privacy-policy.spec.ts ---
import { BrowserContext, expect, test } from '@playwright/test';

import { FLOW_URL } from './utils/constants';

let desktop: BrowserContext;

test.beforeEach(async ({ browser }) => {
  desktop = await browser.newContext({
    permissions: ['clipboard-write', 'clipboard-read'],
  });
});

test('Applicant should be able to read privacy policy', async () => {
  const desktopPage = await desktop.newPage();

  await desktopPage.goto(FLOW_URL);

  await desktopPage.locator('[data-test=privacy-modal-link]').click();

  await expect(desktopPage.locator('.modal-title').first()).toHaveText('Privacy Policy');

  await desktopPage.getByText(/Close/).click();

  const NOT_EXISTING_ELEMENT_COUNT = 0;
  await expect(desktopPage.locator('.modal-title').first()).toHaveCount(NOT_EXISTING_ELEMENT_COUNT);
});

'''
'''--- tests/e2e/retries-limitations.spec.ts ---
import { faker } from '@faker-js/faker';
import { Browser, BrowserContext, chromium, expect, test } from '@playwright/test';

import { CONTACT_EMAIL } from '../../constants';
import type ApplicantProperties from '../../types/ApplicantProperties';

import { FLOW_URL, MOCK_VIDEO_PATH } from './utils/constants';
import { continueOnfidoFlowThenGetAndTestLink, fillStartForm, openKycLinkAndTestDocumentAndPhotoScan, submittingDocuments } from './utils/helpers';

const ZERO = 0;

let browserWithMockedWebcam: Browser;
let desktop: BrowserContext;
let mobile: BrowserContext;
let applicant: ApplicantProperties;

test.beforeEach(async ({ browser }) => {
  browserWithMockedWebcam = await chromium.launch({
    args: ['--use-fake-ui-for-media-stream', '--use-fake-device-for-media-stream', `--use-file-for-fake-video-capture=${MOCK_VIDEO_PATH}`],
  });

  desktop = await browser.newContext({
    permissions: ['clipboard-write', 'clipboard-read'],
  });

  mobile = await browserWithMockedWebcam.newContext({
    userAgent: 'Mozilla/5.0 (Linux; Android 13) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.5249.126 Mobile Safari/537.36',
    permissions: ['camera'],
  });

  applicant = {
    firstName: faker.name.firstName(),
    lastName: faker.name.lastName(),
    email: faker.internet.email(),
    dob: faker.date.birthdate({ min: 18, max: 65, mode: 'age' }).toISOString().split('T')[0],
  };
});

test('Applicant should not be able to retry more than the maximum set up', async () => {
  const desktopPage = await desktop.newPage();

  // First try
  await fillStartForm(desktopPage, { ...applicant, lastName: 'consider' });
  const url = await continueOnfidoFlowThenGetAndTestLink(desktopPage, expect);

  const mobilePage = await mobile.newPage();
  await openKycLinkAndTestDocumentAndPhotoScan(url, mobilePage, expect);

  await submittingDocuments(desktopPage);
  await expect(desktopPage.getByRole('heading', { name: /Verification/i })).toHaveText('Verification failed');

  await desktopPage.getByRole('link', { name: 'Try again' }).click();
  await expect(desktopPage.getByText(/Verify your identity/i)).toHaveText('Verify your identity');

  // Second try
  const urlSecondTry = await continueOnfidoFlowThenGetAndTestLink(desktopPage, expect);

  const mobilePageSecondTry = await mobile.newPage();
  await openKycLinkAndTestDocumentAndPhotoScan(urlSecondTry, mobilePageSecondTry, expect);

  await submittingDocuments(desktopPage);
  await expect(desktopPage.getByRole('heading', { name: /Verification/i })).toHaveText('Verification failed');

  await desktopPage.getByRole('link', { name: 'Try again' }).click();
  await expect(desktopPage.getByText(/Verify your identity/i)).toHaveText('Verify your identity');

  // Third and last try
  const urlThirdTry = await continueOnfidoFlowThenGetAndTestLink(desktopPage, expect);

  const mobilePageThirdTry = await mobile.newPage();
  await openKycLinkAndTestDocumentAndPhotoScan(urlThirdTry, mobilePageThirdTry, expect);

  await submittingDocuments(desktopPage);
  await expect(desktopPage.getByRole('heading', { name: /Verification/i })).toHaveText('Verification failed');
  await expect(desktopPage.getByText(/We could not verify your identity. Please contact support at /)).toHaveText(
    `We could not verify your identity. Please contact support at ${CONTACT_EMAIL}`,
  );
  await expect(await desktopPage.locator('.btn-retry').count()).toEqual(ZERO);
  await expect(await desktopPage.locator('.error-list').count()).toEqual(ZERO);

  await desktopPage.screenshot({ path: 'tests/e2e/screenshots/failed_third_time.png', fullPage: true });

  // Going to homepage and checking that there is an error message
  await desktopPage.goto(FLOW_URL);
  await expect(desktopPage.getByText(/We could not verify your identity. Please contact support at /)).toHaveText(
    `We could not verify your identity. Please contact support at ${CONTACT_EMAIL}`,
  );

  await desktopPage.screenshot({ path: 'tests/e2e/screenshots/homepage_after_failing.png', fullPage: true });
});

'''
'''--- tests/e2e/utils/constants.ts ---
import path from 'path';

export const MOCK_VIDEO_PATH = path.join(__dirname, '../assets/camera.mjpeg');
export const MOCK_IMAGE = 'tests/e2e/assets/id-card.jpg';
export const FLOW_URL = `${process.env.NEXT_PUBLIC_BASE_URL}/${process.env.KYC_ENDPOINT_KEY}`;
export const HOME_URL = process.env.NEXT_PUBLIC_BASE_URL ?? 'http://localhost:3000';
export const API_URL = `${process.env.NEXT_PUBLIC_BASE_URL}/api`;

'''
'''--- tests/e2e/utils/helpers.ts ---
import { Expect, FileChooser, Page } from '@playwright/test';

import type ApplicantProperties from '../../../types/ApplicantProperties';

import { FLOW_URL, MOCK_IMAGE } from './constants';

export const fillStartForm = async (page: Page, applicant: ApplicantProperties): Promise<void> => {
  await page.goto(FLOW_URL);
  await page.getByRole('textbox', { name: /First Name/i }).click();
  await page.getByRole('textbox', { name: /First Name/i }).fill(applicant.firstName);
  await page.getByRole('textbox', { name: /Last Name/i }).click();
  await page.getByRole('textbox', { name: /Last Name/i }).fill(applicant.lastName);
  await page.getByRole('textbox', { name: /Email/i }).click();
  await page.getByRole('textbox', { name: /Email/i }).fill(applicant.email);
  await page.getByRole('textbox', { name: /Date of birth/i }).click();
  await page.getByRole('textbox', { name: /Date of birth/i }).fill(applicant.dob);
  await page.getByText(/I have read and agree to the privacy policy/).click();
  await page.locator('.addl-class__input-container').click();
  await page.locator('.addl-class__input').fill('fra');
  await page.locator('.addl-class__menu').click();
  await page.getByRole('button', { name: /Start/i }).click();
};

export const continueOnfidoFlowThenGetAndTestLink = async (page: Page, expect: Expect): Promise<string> => {
  await page.getByRole('button', { name: /Choose document/i }).click();
  await page.getByRole('button', { name: /Identity card Front and back/i }).click();
  await page.getByPlaceholder(/e.g. United States/i).click();
  await page.getByPlaceholder(/e.g. United States/i).fill('fra');
  await page.getByRole('option', { name: /France/i }).click();
  await page.getByRole('button', { name: /Submit document/i }).click();
  await page.getByRole('button', { name: /Get secure link/i }).click();
  await page.getByRole('link', { name: /Copy link/i }).click();
  await page.getByRole('button', { name: /Copy/i }).click();

  const url = await page.evaluate(async () => navigator.clipboard.readText());
  expect(url).toContain('https://id.onfido.com');

  return url;
};

export const openKycLinkAndTestDocumentAndPhotoScan = async (url: string, page: Page, expect: Expect): Promise<void> => {
  await page.goto(url);

  // Mocking file upload
  page.on('filechooser', (fileChooser: FileChooser) => {
    fileChooser.setFiles([MOCK_IMAGE]);
  });

  await page.getByRole('button', { name: /Continue/i }).click();
  await page.getByText(/Submit identity card \(front\)/i).click();
  page.getByRole('button', { name: /Take photo/i }).click();
  await page.getByRole('button', { name: /Upload/i }).click();
  page.getByRole('button', { name: /Take photo/i }).click();
  await page.getByRole('button', { name: /Upload/i }).click();
  await page.getByRole('button', { name: /Continue/i }).click();
  await page.getByRole('button', { name: /Take a photo/i }).click();
  await page.getByRole('button', { name: /Upload/i }).click();
  await expect(page.getByText(/Uploads successful/i)).toHaveText(['Uploads successful']);
};

export const submittingDocuments = async (page: Page): Promise<void> => {
  await page.getByRole('button', { name: /Submit verification/i }).click();
};

'''
'''--- tests/unit/getDocumentValidationFailureDetails.spec.ts ---
/* eslint-disable no-magic-numbers */
/* eslint-disable max-lines */
// eslint-disable-next-line import/no-extraneous-dependencies
import { describe, expect, test } from '@jest/globals';

import OnfidoDocumentReportBreakdown from '../../types/OnfidoDocumentReportBreakdown';
import ValidationFailure from '../../types/ValidationFailure';
import type ValidationResult from '../../types/ValidationResult';
import getDocumentValidationFailureDetails from '../../utils/getDocumentValidationFailureDetails';

// eslint-disable-next-line max-lines-per-function
const createDocumentValidationResultPayload = ({
  imageIntegrityResult = 'clear',
  supportedDocumentResult = 'clear',
  imageQualityResult = 'clear',
  visualAuthenticityResult = 'clear',
  faceDetectionResult = 'clear',
  fontsResult = 'clear',
  securityFeaturesResult = 'clear',
  dataValidationResult = 'clear',
  documentNumbersResult = 'clear',
  dataConsistencyResult = 'clear',
  documentTypeResult = 'clear',
}: {
  imageIntegrityResult?: ValidationResult;
  supportedDocumentResult?: ValidationResult;
  imageQualityResult?: ValidationResult;
  visualAuthenticityResult?: ValidationResult;
  faceDetectionResult?: ValidationResult;
  fontsResult?: ValidationResult;
  securityFeaturesResult?: ValidationResult;
  dataValidationResult?: ValidationResult;
  documentNumbersResult?: ValidationResult;
  dataConsistencyResult?: ValidationResult;
  documentTypeResult?: ValidationResult;
}): OnfidoDocumentReportBreakdown => ({
  ageValidation: {
    result: 'clear',
    breakdown: { minimumAcceptedAge: { result: 'clear', properties: {} } },
  },
  policeRecord: { result: 'clear' },
  imageIntegrity: {
    result: imageIntegrityResult,
    breakdown: {
      colourPicture: { result: 'clear', properties: {} },
      supportedDocument: { result: supportedDocumentResult, properties: {} },
      conclusiveDocumentQuality: { result: 'clear', properties: {} },
      imageQuality: { result: imageQualityResult, properties: {} },
    },
  },
  dataComparison: {
    result: 'clear',
    breakdown: {
      dateOfBirth: { result: 'clear', properties: {} },
      firstName: { result: 'clear', properties: {} },
      documentNumbers: { result: 'clear', properties: {} },
      documentType: { result: 'clear', properties: {} },
      lastName: { result: 'clear', properties: {} },
      dateOfExpiry: { result: 'clear', properties: {} },
      gender: { result: 'clear', properties: {} },
      issuingCountry: { result: 'clear', properties: {} },
    },
  },
  dataConsistency: {
    result: dataConsistencyResult,
    breakdown: {
      nationality: { result: 'clear', properties: {} },
      lastName: { result: 'clear', properties: {} },
      firstName: { result: 'clear', properties: {} },
      multipleDataSourcesPresent: { result: 'clear', properties: {} },
      gender: { result: 'clear', properties: {} },
      dateOfBirth: { result: 'clear', properties: {} },
      documentType: { result: documentTypeResult, properties: {} },
      issuingCountry: { result: 'clear', properties: {} },
      documentNumbers: { result: 'clear', properties: {} },
      dateOfExpiry: { result: 'clear', properties: {} },
    },
  },
  compromisedDocument: { result: 'clear' },
  visualAuthenticity: {
    result: visualAuthenticityResult,
    breakdown: {
      faceDetection: { result: faceDetectionResult, properties: {} },
      other: { result: 'clear', properties: {} },
      digitalTampering: { result: 'clear', properties: {} },
      originalDocumentPresent: { result: 'clear', properties: {} },
      securityFeatures: { result: securityFeaturesResult, properties: {} },
      template: { result: 'clear', properties: {} },
      pictureFaceIntegrity: { result: 'clear', properties: {} },
      fonts: { result: fontsResult, properties: {} },
    },
  },
  dataValidation: {
    result: dataValidationResult,
    breakdown: {
      mrz: { result: 'clear', properties: {} },
      expiryDate: { result: 'clear', properties: {} },
      documentExpiration: { result: 'clear', properties: {} },
      documentNumbers: { result: documentNumbersResult, properties: {} },
      dateOfBirth: { result: 'clear', properties: {} },
      gender: { result: 'clear', properties: {} },
    },
  },
});

const successDocumentValidationResultPayload = createDocumentValidationResultPayload({});

const failureImageIntegrityPayload = createDocumentValidationResultPayload({
  imageIntegrityResult: 'consider',
});

const failureImageIntegritySupportedDocumentPayloadWithBreakdown = createDocumentValidationResultPayload({
  imageIntegrityResult: 'consider',
  supportedDocumentResult: 'consider',
});

const failureImageIntegrityImageQualityPayloadWithBreakdown = createDocumentValidationResultPayload({
  imageIntegrityResult: 'consider',
  imageQualityResult: 'consider',
});

const failureVisualAuthenticityPayload = createDocumentValidationResultPayload({
  visualAuthenticityResult: 'consider',
});

const failureVisualAuthenticityFontsPayloadWithBreakdown = createDocumentValidationResultPayload({
  visualAuthenticityResult: 'consider',
  fontsResult: 'consider',
});

const failureVisualAuthenticitySecurityFeaturesPayloadWithBreakdown = createDocumentValidationResultPayload({
  visualAuthenticityResult: 'consider',
  securityFeaturesResult: 'consider',
});

const failureVisualAuthenticityFaceDetectionPayloadWithBreakdown = createDocumentValidationResultPayload({
  visualAuthenticityResult: 'consider',
  faceDetectionResult: 'consider',
});

const failureDataValidationPayload = createDocumentValidationResultPayload({
  dataValidationResult: 'consider',
});

const failureDataValidationDocumentNumbersPayloadWithBreakdown = createDocumentValidationResultPayload({
  dataValidationResult: 'consider',
  documentNumbersResult: 'consider',
});

const failureDataConsistencyPayload = createDocumentValidationResultPayload({
  dataConsistencyResult: 'consider',
});

const failureDataConsistencyDocumentTypePayloadWithBreakdown = createDocumentValidationResultPayload({
  dataConsistencyResult: 'consider',
  documentTypeResult: 'consider',
});

const fullyFailingDocumentValidationResultPayload = createDocumentValidationResultPayload({
  imageIntegrityResult: 'consider',
  supportedDocumentResult: 'consider',
  imageQualityResult: 'consider',
  visualAuthenticityResult: 'consider',
  faceDetectionResult: 'consider',
  fontsResult: 'consider',
  securityFeaturesResult: 'consider',
  dataValidationResult: 'consider',
  documentNumbersResult: 'consider',
  dataConsistencyResult: 'consider',
  documentTypeResult: 'consider',
});

const fullyFailingDocumentValidationResultPayloadUnidentified = createDocumentValidationResultPayload({
  imageIntegrityResult: 'unidentified',
  supportedDocumentResult: 'unidentified',
  imageQualityResult: 'unidentified',
  visualAuthenticityResult: 'unidentified',
  faceDetectionResult: 'unidentified',
  fontsResult: 'unidentified',
  securityFeaturesResult: 'unidentified',
  dataValidationResult: 'unidentified',
  documentNumbersResult: 'unidentified',
  dataConsistencyResult: 'unidentified',
  documentTypeResult: 'unidentified',
});

const fullyFailingDocumentValidationResultPayloadRejected = createDocumentValidationResultPayload({
  imageIntegrityResult: 'rejected',
  supportedDocumentResult: 'rejected',
  imageQualityResult: 'rejected',
  visualAuthenticityResult: 'rejected',
  faceDetectionResult: 'rejected',
  fontsResult: 'rejected',
  securityFeaturesResult: 'rejected',
  dataValidationResult: 'rejected',
  documentNumbersResult: 'rejected',
  dataConsistencyResult: 'rejected',
  documentTypeResult: 'rejected',
});

const fullyFailingDocumentValidationResultPayloadCaution = createDocumentValidationResultPayload({
  imageIntegrityResult: 'caution',
  supportedDocumentResult: 'caution',
  imageQualityResult: 'caution',
  visualAuthenticityResult: 'caution',
  faceDetectionResult: 'caution',
  fontsResult: 'caution',
  securityFeaturesResult: 'caution',
  dataValidationResult: 'caution',
  documentNumbersResult: 'caution',
  dataConsistencyResult: 'caution',
  documentTypeResult: 'caution',
});

// eslint-disable-next-line max-lines-per-function
describe('getDocumentValidationFailureDetails', () => {
  test('getDocumentValidationFailureDetails(successDocumentValidationResultPayload) should return an empty array', () => {
    expect(getDocumentValidationFailureDetails(successDocumentValidationResultPayload)).toEqual([]);
  });

  test('getDocumentValidationFailureDetails(failureImageIntegrityPayload) should return an array with ValidationFailure.InvalidImageIntegrity', () => {
    expect(getDocumentValidationFailureDetails(failureImageIntegrityPayload)).toEqual([ValidationFailure.InvalidImageIntegrity]);
  });

  test('getDocumentValidationFailureDetails(failureImageIntegritySupportedDocumentPayloadWithBreakdown) should return an array with ValidationFailure.InvalidImageIntegrity and ValidationFailure.InvalidImageIntegritySupportedDocument', () => {
    const result = getDocumentValidationFailureDetails(failureImageIntegritySupportedDocumentPayloadWithBreakdown);
    expect(result).toContain(ValidationFailure.InvalidImageIntegrity);
    expect(result).toContain(ValidationFailure.InvalidImageIntegritySupportedDocument);
    expect(result).toHaveLength(2);
  });

  test('getDocumentValidationFailureDetails(failureImageIntegrityImageQualityPayloadWithBreakdown) should return an array with ValidationFailure.InvalidImageIntegrity and ValidationFailure.InvalidImageIntegrityImageQuality', () => {
    const result = getDocumentValidationFailureDetails(failureImageIntegrityImageQualityPayloadWithBreakdown);
    expect(result).toContain(ValidationFailure.InvalidImageIntegrity);
    expect(result).toContain(ValidationFailure.InvalidImageIntegrityImageQuality);
    expect(result).toHaveLength(2);
  });

  test('getDocumentValidationFailureDetails(failureVisualAuthenticityPayload) should return an array with ValidationFailure.InvalidVisualAuthenticity', () => {
    expect(getDocumentValidationFailureDetails(failureVisualAuthenticityPayload)).toEqual([ValidationFailure.InvalidVisualAuthenticity]);
  });

  test('getDocumentValidationFailureDetails(failureVisualAuthenticityFontsPayloadWithBreakdown) should return an array with ValidationFailure.InvalidVisualAuthenticity and ValidationFailure.InvalidVisualAuthenticityFonts', () => {
    const result = getDocumentValidationFailureDetails(failureVisualAuthenticityFontsPayloadWithBreakdown);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticity);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticityFonts);
    expect(result).toHaveLength(2);
  });

  test('getDocumentValidationFailureDetails(failureVisualAuthenticitySecurityFeaturesPayloadWithBreakdown) should return an array with ValidationFailure.InvalidVisualAuthenticity and ValidationFailure.InvalidVisualAuthenticitySecurityFeatures', () => {
    const result = getDocumentValidationFailureDetails(failureVisualAuthenticitySecurityFeaturesPayloadWithBreakdown);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticity);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticitySecurityFeatures);
    expect(result).toHaveLength(2);
  });

  test('getDocumentValidationFailureDetails(failureVisualAuthenticityFaceDetectionPayloadWithBreakdown) should return an array with ValidationFailure.InvalidVisualAuthenticity and ValidationFailure.InvalidVisualAuthenticityFaceDetection', () => {
    const result = getDocumentValidationFailureDetails(failureVisualAuthenticityFaceDetectionPayloadWithBreakdown);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticity);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticityFaceDetection);
    expect(result).toHaveLength(2);
  });

  test('getDocumentValidationFailureDetails(failureDataValidationPayload) should return an array with ValidationFailure.InvalidDataValidation', () => {
    expect(getDocumentValidationFailureDetails(failureDataValidationPayload)).toEqual([ValidationFailure.InvalidDataValidation]);
  });

  test('getDocumentValidationFailureDetails(failureDataValidationDocumentNumbersPayloadWithBreakdown) should return an array with ValidationFailure.InvalidDataValidation and ValidationFailure.InvalidDataValidationDocumentNumbers', () => {
    const result = getDocumentValidationFailureDetails(failureDataValidationDocumentNumbersPayloadWithBreakdown);
    expect(result).toContain(ValidationFailure.InvalidDataValidation);
    expect(result).toContain(ValidationFailure.InvalidDataValidationDocumentNumbers);
    expect(result).toHaveLength(2);
  });

  test('getDocumentValidationFailureDetails(failureDataConsistencyPayload) should return an array with ValidationFailure.InvalidDataConsistency', () => {
    expect(getDocumentValidationFailureDetails(failureDataConsistencyPayload)).toEqual([ValidationFailure.InvalidDataConsistency]);
  });

  test('getDocumentValidationFailureDetails(failureDataConsistencyDocumentTypePayloadWithBreakdown) should return an array with ValidationFailure.InvalidDataConsistency and ValidationFailure.InvalidDataConsistencyDocumentType', () => {
    const result = getDocumentValidationFailureDetails(failureDataConsistencyDocumentTypePayloadWithBreakdown);
    expect(result).toContain(ValidationFailure.InvalidDataConsistency);
    expect(result).toContain(ValidationFailure.InvalidDataConsistencyDocumentType);
    expect(result).toHaveLength(2);
  });

  test('getDocumentValidationFailureDetails(fullyFailingDocumentValidationResultPayload) should return an array with all ValidationFailure values', () => {
    const result = getDocumentValidationFailureDetails(fullyFailingDocumentValidationResultPayload);
    expect(result).toContain(ValidationFailure.InvalidImageIntegrity);
    expect(result).toContain(ValidationFailure.InvalidImageIntegritySupportedDocument);
    expect(result).toContain(ValidationFailure.InvalidImageIntegrityImageQuality);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticity);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticityFonts);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticitySecurityFeatures);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticityFaceDetection);
    expect(result).toContain(ValidationFailure.InvalidDataValidation);
    expect(result).toContain(ValidationFailure.InvalidDataValidationDocumentNumbers);
    expect(result).toContain(ValidationFailure.InvalidDataConsistency);
    expect(result).toContain(ValidationFailure.InvalidDataConsistencyDocumentType);
    expect(result).toHaveLength(11);
  });

  test('getDocumentValidationFailureDetails(fullyFailingDocumentValidationResultPayloadUnidentified) should return an array with all ValidationFailure values', () => {
    const result = getDocumentValidationFailureDetails(fullyFailingDocumentValidationResultPayloadUnidentified);
    expect(result).toContain(ValidationFailure.InvalidImageIntegrity);
    expect(result).toContain(ValidationFailure.InvalidImageIntegritySupportedDocument);
    expect(result).toContain(ValidationFailure.InvalidImageIntegrityImageQuality);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticity);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticityFonts);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticitySecurityFeatures);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticityFaceDetection);
    expect(result).toContain(ValidationFailure.InvalidDataValidation);
    expect(result).toContain(ValidationFailure.InvalidDataValidationDocumentNumbers);
    expect(result).toContain(ValidationFailure.InvalidDataConsistency);
    expect(result).toContain(ValidationFailure.InvalidDataConsistencyDocumentType);
    expect(result).toHaveLength(11);
  });

  test('getDocumentValidationFailureDetails(fullyFailingDocumentValidationResultPayloadRejected) should return an array with all ValidationFailure values', () => {
    const result = getDocumentValidationFailureDetails(fullyFailingDocumentValidationResultPayloadRejected);
    expect(result).toContain(ValidationFailure.InvalidImageIntegrity);
    expect(result).toContain(ValidationFailure.InvalidImageIntegritySupportedDocument);
    expect(result).toContain(ValidationFailure.InvalidImageIntegrityImageQuality);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticity);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticityFonts);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticitySecurityFeatures);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticityFaceDetection);
    expect(result).toContain(ValidationFailure.InvalidDataValidation);
    expect(result).toContain(ValidationFailure.InvalidDataValidationDocumentNumbers);
    expect(result).toContain(ValidationFailure.InvalidDataConsistency);
    expect(result).toContain(ValidationFailure.InvalidDataConsistencyDocumentType);
    expect(result).toHaveLength(11);
  });

  test('getDocumentValidationFailureDetails(fullyFailingDocumentValidationResultPayloadCaution) should return an array with all ValidationFailure values', () => {
    const result = getDocumentValidationFailureDetails(fullyFailingDocumentValidationResultPayloadCaution);
    expect(result).toContain(ValidationFailure.InvalidImageIntegrity);
    expect(result).toContain(ValidationFailure.InvalidImageIntegritySupportedDocument);
    expect(result).toContain(ValidationFailure.InvalidImageIntegrityImageQuality);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticity);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticityFonts);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticitySecurityFeatures);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticityFaceDetection);
    expect(result).toContain(ValidationFailure.InvalidDataValidation);
    expect(result).toContain(ValidationFailure.InvalidDataValidationDocumentNumbers);
    expect(result).toContain(ValidationFailure.InvalidDataConsistency);
    expect(result).toContain(ValidationFailure.InvalidDataConsistencyDocumentType);
    expect(result).toHaveLength(11);
  });
});

'''
'''--- tests/unit/getFacialValidationFailureDetails.spec.ts ---
/* eslint-disable no-magic-numbers */
// eslint-disable-next-line import/no-extraneous-dependencies
import { describe, expect, test } from '@jest/globals';

import OnfidoFacialReportBreakdown from '../../types/OnfidoFacialReportBreakdown';
import ValidationFailure from '../../types/ValidationFailure';
import type ValidationResult from '../../types/ValidationResult';
import getFacialValidationFailureDetails from '../../utils/getFacialValidationFailureDetails';

const createFacialResultPayload = ({
  visualAuthenticityResult = 'clear',
  imageIntegrityResult = 'clear',
  sourceIntegrityResult = 'clear',
  faceDetectedResult = 'clear',
  faceMatchResult = 'clear',
}: {
  visualAuthenticityResult?: ValidationResult;
  imageIntegrityResult?: ValidationResult;
  sourceIntegrityResult?: ValidationResult;
  faceDetectedResult?: ValidationResult;
  faceMatchResult?: ValidationResult;
}): OnfidoFacialReportBreakdown => ({
  visualAuthenticity: {
    result: visualAuthenticityResult,
    breakdown: {
      spoofingDetection: { result: visualAuthenticityResult, properties: { score: 0.9512 } },
    },
  },
  imageIntegrity: {
    result: imageIntegrityResult,
    breakdown: {
      sourceIntegrity: { result: sourceIntegrityResult, properties: {} },
      faceDetected: { result: faceDetectedResult, properties: {} },
    },
  },
  faceComparison: {
    result: faceMatchResult,
    breakdown: {
      faceMatch: {
        result: faceMatchResult,
        properties: {
          documentUuid: '5d6da4f3-898f-4f12-a695-d61686966d7f',
          score: 0.6512,
        },
      },
    },
  },
});

const successFacialResultPayload = createFacialResultPayload({});

const failureVisualAuthenticityFacialResultPayloadWithBreakdown = createFacialResultPayload({
  visualAuthenticityResult: 'consider',
});

const failureImageIntegrityFacialResultPayloadWithBreakdownSourceIntegrityFailing = createFacialResultPayload({
  imageIntegrityResult: 'consider',
  sourceIntegrityResult: 'consider',
});

const failureImageIntegrityFacialResultPayloadWithBreakdownFaceDetectedFailing = createFacialResultPayload({
  imageIntegrityResult: 'consider',
  faceDetectedResult: 'consider',
});

const failureImageIntegrityFacialResultPayloadWithBreakdownAllFailing = createFacialResultPayload({
  imageIntegrityResult: 'consider',
  sourceIntegrityResult: 'consider',
  faceDetectedResult: 'consider',
});

const failureFaceComparisonFacialResultPayloadWithBreakdown = createFacialResultPayload({
  faceMatchResult: 'consider',
});

const fullyFailingFacialResultPayload = createFacialResultPayload({
  visualAuthenticityResult: 'consider',
  imageIntegrityResult: 'consider',
  sourceIntegrityResult: 'consider',
  faceDetectedResult: 'consider',
  faceMatchResult: 'consider',
});

const fullyFailingFacialResultPayloadUnidentified = createFacialResultPayload({
  visualAuthenticityResult: 'unidentified',
  imageIntegrityResult: 'unidentified',
  sourceIntegrityResult: 'unidentified',
  faceDetectedResult: 'unidentified',
  faceMatchResult: 'unidentified',
});

const fullyFailingFacialResultPayloadRejected = createFacialResultPayload({
  visualAuthenticityResult: 'rejected',
  imageIntegrityResult: 'rejected',
  sourceIntegrityResult: 'rejected',
  faceDetectedResult: 'rejected',
  faceMatchResult: 'rejected',
});

const fullyFailingFacialResultPayloadCaution = createFacialResultPayload({
  visualAuthenticityResult: 'caution',
  imageIntegrityResult: 'caution',
  sourceIntegrityResult: 'caution',
  faceDetectedResult: 'caution',
  faceMatchResult: 'caution',
});

describe('getFacialValidationFailureDetails function', () => {
  test('getFacialValidationFailureDetails(successResultPayload) should return an empty array', () => {
    expect(getFacialValidationFailureDetails(successFacialResultPayload)).toEqual([]);
  });

  test('getFacialValidationFailureDetails(failureVisualAuthenticityFacialResultPayloadWithBreakdown) should return an array with ValidationFailure.InvalidVisualAuthenticitySpoofing', () => {
    expect(getFacialValidationFailureDetails(failureVisualAuthenticityFacialResultPayloadWithBreakdown)).toEqual([ValidationFailure.InvalidVisualAuthenticitySpoofing]);
  });

  test('getFacialValidationFailureDetails(failureImageIntegrityFacialResultPayload) should return an array with ValidationFailure.InvalidImageIntegrity', () => {
    expect(getFacialValidationFailureDetails(failureImageIntegrityFacialResultPayloadWithBreakdownSourceIntegrityFailing)).toEqual([ValidationFailure.InvalidImageIntegritySource]);
  });

  test('getFacialValidationFailureDetails(failureImageIntegrityFacialResultPayloadWithBreakdownFaceDetectedFailing) should return an array with ValidationFailure.InvalidImageIntegrity', () => {
    expect(getFacialValidationFailureDetails(failureImageIntegrityFacialResultPayloadWithBreakdownFaceDetectedFailing)).toEqual([
      ValidationFailure.InvalidImageIntegrityFaceDetected,
    ]);
  });

  test('getFacialValidationFailureDetails(failureImageIntegrityFacialResultPayloadWithBreakdownAllFailing) should return an array with ValidationFailure.InvalidImageIntegrity and ValidationFailure.InvalidImageIntegrityFaceDetected', () => {
    const result = getFacialValidationFailureDetails(failureImageIntegrityFacialResultPayloadWithBreakdownAllFailing);
    expect(result).toContain(ValidationFailure.InvalidImageIntegritySource);
    expect(result).toContain(ValidationFailure.InvalidImageIntegrityFaceDetected);
    expect(result).toHaveLength(2);
  });

  test('getFacialValidationFailureDetails(failureFaceComparisonFacialResultPayloadWithBreakdown) should return an array with ValidationFailure.InvalidFaceComparison', () => {
    expect(getFacialValidationFailureDetails(failureFaceComparisonFacialResultPayloadWithBreakdown)).toEqual([ValidationFailure.InvalidFaceComparison]);
  });

  test('getFacialValidationFailureDetails(fullyFailingFacialResultPayload) should return an array with ValidationFailure.InvalidVisualAuthenticitySpoofing, ValidationFailure.InvalidImageIntegrity, ValidationFailure.InvalidImageIntegrityFaceDetected and ValidationFailure.InvalidFaceComparison', () => {
    const result = getFacialValidationFailureDetails(fullyFailingFacialResultPayload);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticitySpoofing);
    expect(result).toContain(ValidationFailure.InvalidImageIntegritySource);
    expect(result).toContain(ValidationFailure.InvalidImageIntegrityFaceDetected);
    expect(result).toContain(ValidationFailure.InvalidFaceComparison);
    expect(result).toHaveLength(4);
  });

  test('getFacialValidationFailureDetails(fullyFailingFacialResultPayloadUnidentified) should return an array with ValidationFailure.InvalidVisualAuthenticitySpoofing, ValidationFailure.InvalidImageIntegrity, ValidationFailure.InvalidImageIntegrityFaceDetected and ValidationFailure.InvalidFaceComparison', () => {
    const result = getFacialValidationFailureDetails(fullyFailingFacialResultPayloadUnidentified);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticitySpoofing);
    expect(result).toContain(ValidationFailure.InvalidImageIntegritySource);
    expect(result).toContain(ValidationFailure.InvalidImageIntegrityFaceDetected);
    expect(result).toContain(ValidationFailure.InvalidFaceComparison);
    expect(result).toHaveLength(4);
  });

  test('getFacialValidationFailureDetails(fullyFailingFacialResultPayloadRejected) should return an array with ValidationFailure.InvalidVisualAuthenticitySpoofing, ValidationFailure.InvalidImageIntegrity, ValidationFailure.InvalidImageIntegrityFaceDetected and ValidationFailure.InvalidFaceComparison', () => {
    const result = getFacialValidationFailureDetails(fullyFailingFacialResultPayloadRejected);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticitySpoofing);
    expect(result).toContain(ValidationFailure.InvalidImageIntegritySource);
    expect(result).toContain(ValidationFailure.InvalidImageIntegrityFaceDetected);
    expect(result).toContain(ValidationFailure.InvalidFaceComparison);
    expect(result).toHaveLength(4);
  });

  test('getFacialValidationFailureDetails(fullyFailingFacialResultPayloadCaution) should return an array with ValidationFailure.InvalidVisualAuthenticitySpoofing, ValidationFailure.InvalidImageIntegrity, ValidationFailure.InvalidImageIntegrityFaceDetected and ValidationFailure.InvalidFaceComparison', () => {
    const result = getFacialValidationFailureDetails(fullyFailingFacialResultPayloadCaution);
    expect(result).toContain(ValidationFailure.InvalidVisualAuthenticitySpoofing);
    expect(result).toContain(ValidationFailure.InvalidImageIntegritySource);
    expect(result).toContain(ValidationFailure.InvalidImageIntegrityFaceDetected);
    expect(result).toContain(ValidationFailure.InvalidFaceComparison);
    expect(result).toHaveLength(4);
  });
});

'''
'''--- tests/unit/getStatusFromCheck.spec.ts ---
// eslint-disable-next-line import/no-extraneous-dependencies
import { describe, expect, test } from '@jest/globals';
import type { Check } from '@onfido/api';

import { CheckResultsStatus } from '../../types/CheckResults';
import getStatusFromCheck from '../../utils/getStatusFromCheck';

const createCheckPayload = ({
  status,
  result,
}: {
  status: 'in_progress' | 'awaiting_applicant' | 'complete' | 'withdrawn' | 'paused' | 'reopened';
  result: null | 'consider' | 'clear' | 'unidentified';
}): Check => ({
  id: '4db97401-ad5e-47ad-b776-1bba95fabc2e',
  createdAt: '2022-11-15T14:52:26Z',
  status,
  redirectUri: null,
  result,
  //   sandbox: true,
  tags: [],
  resultsUri: 'https://dashboard.onfido.com/checks/4db97401-ad5e-47ad-b776-1bba95fabc2e',
  formUri: null,
  //   paused: false,
  //   version: '3.4',
  reportIds: ['3c4b4060-d5f1-4a94-a352-6420a70cc257', 'a4d18abf-e055-4f38-bba6-2ee2c8e0152f', '8fbbbd51-8224-43ae-83e2-4f0d8cf2d50e'],
  href: '/v3.4/checks/4db97401-ad5e-47ad-b776-1bba95fabc2e',
  applicantId: 'd8e96461-cea9-4eef-b0a5-a03cd3b564f1',
  applicantProvidesData: false,
  webhookIds: null,
  privacyNoticesReadConsentGiven: true,
});

const waitingPayload = createCheckPayload({ status: 'in_progress', result: null });
const successPayload = createCheckPayload({ status: 'complete', result: 'clear' });
const failurePayload = createCheckPayload({ status: 'complete', result: 'consider' });
const unidentifiedPayload = createCheckPayload({ status: 'complete', result: 'unidentified' });
const withdrawnPayload = createCheckPayload({ status: 'withdrawn', result: null });
const pausedPayload = createCheckPayload({ status: 'paused', result: null });
const reopenedPayload = createCheckPayload({ status: 'reopened', result: null });
const awaitingApplicantPayload = createCheckPayload({ status: 'awaiting_applicant', result: null });

describe('getStatusFromCheck', () => {
  test('getStatusFromCheck(waitingPayload) should return CheckResultsStatus.loading status and isClear null', () => {
    const { status, isClear } = getStatusFromCheck(waitingPayload);
    expect(status).toEqual(CheckResultsStatus.loading);
    expect(isClear).toEqual(null);
  });

  test('getStatusFromCheck(successPayload) should return CheckResultsStatus.finished status and isClear should be true', () => {
    const { status, isClear } = getStatusFromCheck(successPayload);
    expect(status).toEqual(CheckResultsStatus.finished);
    expect(isClear).toEqual(true);
  });

  test('getStatusFromCheck(failurePayload) should return CheckResultsStatus.finished status and isClear should be true', () => {
    const { status, isClear } = getStatusFromCheck(failurePayload);
    expect(status).toEqual(CheckResultsStatus.finished);
    expect(isClear).toEqual(false);
  });

  test('getStatusFromCheck(unidentifiedPayload) should return CheckResultsStatus.finished status and isClear should be false', () => {
    const { status, isClear } = getStatusFromCheck(unidentifiedPayload);
    expect(status).toEqual(CheckResultsStatus.finished);
    expect(isClear).toEqual(false);
  });

  test('getStatusFromCheck(withdrawnPayload) should return CheckResultsStatus.finished status and isClear should be false', () => {
    const { status, isClear } = getStatusFromCheck(withdrawnPayload);
    expect(status).toEqual(CheckResultsStatus.finished);
    expect(isClear).toEqual(false);
  });

  test('getStatusFromCheck(pausedPayload) should return CheckResultsStatus.willTakeLonger status and isClear should be false', () => {
    const { status, isClear } = getStatusFromCheck(pausedPayload);
    expect(status).toEqual(CheckResultsStatus.willTakeLonger);
    expect(isClear).toEqual(null);
  });

  test('getStatusFromCheck(reopenedPayload) should return CheckResultsStatus.willTakeLonger status and isClear should be false', () => {
    const { status, isClear } = getStatusFromCheck(reopenedPayload);
    expect(status).toEqual(CheckResultsStatus.willTakeLonger);
    expect(isClear).toEqual(null);
  });

  test('getStatusFromCheck(awaitingApplicantPayload) should return CheckResultsStatus.willTakeLonger status and isClear should be false', () => {
    const { status, isClear } = getStatusFromCheck(awaitingApplicantPayload);
    expect(status).toEqual(CheckResultsStatus.finished);
    expect(isClear).toEqual(false);
  });
});

'''
'''--- tests/unit/isValidationFailure.spec.ts ---
// eslint-disable-next-line import/no-extraneous-dependencies
import { describe, expect, test } from '@jest/globals';

import isValidationFailure from '../../utils/isValidationFailure';

describe('isValidationFailure function', () => {
  test('isValidationFailure("consider") should return true', () => {
    expect(isValidationFailure('consider')).toBeTruthy();
  });

  test('isValidationFailure("unidentified") should return true', () => {
    expect(isValidationFailure('unidentified')).toBeTruthy();
  });

  test('isValidationFailure("rejected") should return true', () => {
    expect(isValidationFailure('rejected')).toBeTruthy();
  });

  test('isValidationFailure("caution") should return true', () => {
    expect(isValidationFailure('caution')).toBeTruthy();
  });

  test('isValidationFailure("clear") should return false', () => {
    expect(isValidationFailure('clear')).toBeFalsy();
  });
});

'''
'''--- tests/unit/validationMessages.spec.ts ---
// eslint-disable-next-line import/no-extraneous-dependencies
import { describe, expect, test } from '@jest/globals';

import ValidationFailure from '../../types/ValidationFailure';
import validationMessages from '../../utils/validationMessages';

const keys = Object.values(ValidationFailure);

describe('validationMessages', () => {
  keys.forEach((key) => {
    test(`should have a message for ${key}`, () => {
      expect(validationMessages.has(key)).toBe(true);
    });
  });

  test('should have the same number of messages as ValidationFailure', () => {
    expect(validationMessages.size).toBe(keys.length);
  });
});

'''
'''--- tsconfig.eslint.json ---
{
  "extends": "./tsconfig.json",
  "include": ["./**/*.js", "./**/*.jsx", "./**/*.ts", "./**/*.tsx"]
}

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": [
    "node_modules"
  ]
}

'''
'''--- types/ApplicantProperties.ts ---
interface ApplicantProperties {
  firstName: string;
  lastName: string;
  email: string;
  dob: string;
  csrf_token?: string;
  consent?: boolean;
  countryOfResidence?: string;
}

export default ApplicantProperties;

'''
'''--- types/ApplicantTokenPair.ts ---
interface ApplicantTokenPair {
  applicantId: string;
  sdkToken: string;
}

export default ApplicantTokenPair;

'''
'''--- types/CheckResults.ts ---
import type ValidationFailure from './ValidationFailure';

export interface CheckResults {
  isClear: boolean | null; // !isClear means the check failed
  status: CheckResultsStatus;
  validationFailureDetails: ValidationFailure[];
}

export enum CheckResultsStatus {
  loading = 'loading',
  willTakeLonger = 'will-take-longer',
  finished = 'finished',
  notFound = 'not-found',
}

'''
'''--- types/IParams.ts ---
import { ParsedUrlQuery } from 'querystring';

interface IParams extends ParsedUrlQuery {
  key: string;
}

export default IParams;

'''
'''--- types/OnfidoDocumentReportBreakdown.ts ---
interface OnfidoDocumentReportBreakdown {
  ageValidation?: {
    result: string;
    breakdown?: unknown;
  };
  policeRecord?: {
    result: string;
  };
  imageIntegrity?: {
    result: string;
    breakdown?: {
      supportedDocument?: {
        result: string;
        properties?: unknown;
      };
      imageQuality?: {
        result: string;
        properties?: unknown;
      };
      [key: string]: unknown;
    };
  };
  dataComparison?: {
    result: string;
    breakdown?: unknown;
  };
  dataConsistency?: {
    result: string;
    breakdown?: {
      documentType?: {
        result: string;
        properties?: unknown;
      };
      [key: string]: unknown;
    };
  };
  compromisedDocument?: {
    result: string;
  };
  visualAuthenticity?: {
    result: string;
    breakdown?: {
      faceDetection?: {
        result: string;
        properties?: unknown;
      };
      fonts?: {
        result: string;
        properties?: unknown;
      };
      securityFeatures?: {
        result: string;
        properties?: unknown;
      };
      [key: string]: unknown;
    };
  };
  dataValidation?: {
    result: string;
    breakdown?: {
      mrz?: {
        result: string;
        properties?: unknown;
      };
      documentNumbers?: {
        result: string;
        properties?: unknown;
      };
      [key: string]: unknown;
    };
  };
}

export default OnfidoDocumentReportBreakdown;

'''
'''--- types/OnfidoFacialReportBreakdown.ts ---
interface OnfidoFacialReportBreakdown {
  visualAuthenticity?: {
    result: string;
    breakdown?: {
      spoofingDetection?: {
        result: string;
        properties?: unknown;
      };
    };
  };
  imageIntegrity?: {
    result: string;
    breakdown?: {
      sourceIntegrity?: {
        result: string;
        properties?: unknown;
      };
      faceDetected?: {
        result: string;
        properties?: unknown;
      };
    };
  };
  faceComparison?: {
    result: string;
    breakdown?: {
      faceMatch?: {
        result: string;
        properties?: unknown;
      };
    };
  };
}

export default OnfidoFacialReportBreakdown;

'''
'''--- types/ValidationFailure.ts ---
// Check failure tests https://documentation.onfido.com/#pre-determined-breakdowns-document
// Types are determined in `utils/getDocumentValidationFailureDetails.ts` and `utils/getFacialValidationFailureDetails.ts` from the payload received
// Related texts are defined in `components/results/ResultsFailure.tsx`
enum ValidationFailure {
  InvalidImageIntegrity = 'InvalidImageIntegrity', // Generic Image Integrity failure
  InvalidImageIntegritySupportedDocument = 'InvalidImageIntegritySupportedDocument', // "Image Integrity - Supported Document"
  InvalidImageIntegrityImageQuality = 'InvalidImageIntegrityImageQuality', // "Image Integrity - Image Quality"
  InvalidVisualAuthenticity = 'InvalidVisualAuthenticity', // Generic Visual authenticity because there are many sub failures
  InvalidVisualAuthenticityFonts = 'InvalidVisualAuthenticityFonts', // "Visual Authenticity - Fonts"
  InvalidVisualAuthenticitySecurityFeatures = 'InvalidVisualAuthenticitySecurityFeatures', // "Visual Authenticity - Security Features"
  InvalidVisualAuthenticityFaceDetection = 'InvalidVisualAuthenticityFaceDetection', // "Visual Authenticity - Face Detection"
  InvalidDataValidation = 'InvalidDataValidation', // Generic Data Validation because there are many sub failures
  InvalidDataValidationDocumentNumbers = 'InvalidDataValidationDocumentNumbers', // "Data Validation - Document Numbers"
  InvalidDataConsistency = 'InvalidDataConsistency', // Generic Data Consistency because there are many sub failures
  InvalidDataConsistencyDocumentType = 'InvalidDataConsistencyDocumentType', // "Data Consistency - Document Type"
  InvalidVisualAuthenticitySpoofing = 'InvalidVisualAuthenticitySpoofing', // "Visual Authenticity - Spoofing Detection"
  InvalidFaceComparison = 'InvalidFaceComparison', // "Face Comparison - Face Match"
  InvalidImageIntegritySource = 'InvalidImageIntegritySource', // "Image Integrity - Source Integrity"
  InvalidImageIntegrityFaceDetected = 'InvalidImageIntegrityFaceDetected', // "Image Integrity - Face Detected"
}

export default ValidationFailure;

'''
'''--- types/ValidationResult.ts ---
type ValidationResult = 'clear' | 'consider' | 'unidentified' | 'rejected' | 'caution';

export default ValidationResult;

'''
'''--- utils/getDocumentValidationFailureDetails.ts ---
import type OnfidoDocumentReportBreakdown from '../types/OnfidoDocumentReportBreakdown';
import ValidationFailure from '../types/ValidationFailure';

import isFailure from './isValidationFailure';

const getDocumentValidationFailureDetails = (breakdown: OnfidoDocumentReportBreakdown | null): ValidationFailure[] => {
  const failures: ValidationFailure[] = [];

  if (!breakdown) {
    return failures;
  }

  if (breakdown.imageIntegrity) {
    if (isFailure(breakdown.imageIntegrity.result)) {
      failures.push(ValidationFailure.InvalidImageIntegrity);

      if (isFailure(breakdown.imageIntegrity.breakdown?.supportedDocument?.result)) {
        failures.push(ValidationFailure.InvalidImageIntegritySupportedDocument);
      }
      if (isFailure(breakdown.imageIntegrity.breakdown?.imageQuality?.result)) {
        failures.push(ValidationFailure.InvalidImageIntegrityImageQuality);
      }
    }
  }

  if (breakdown.visualAuthenticity) {
    if (isFailure(breakdown.visualAuthenticity.result)) {
      failures.push(ValidationFailure.InvalidVisualAuthenticity);

      if (isFailure(breakdown.visualAuthenticity.breakdown?.faceDetection?.result)) {
        failures.push(ValidationFailure.InvalidVisualAuthenticityFaceDetection);
      }
      if (isFailure(breakdown.visualAuthenticity.breakdown?.fonts?.result)) {
        failures.push(ValidationFailure.InvalidVisualAuthenticityFonts);
      }
      if (isFailure(breakdown.visualAuthenticity.breakdown?.securityFeatures?.result)) {
        failures.push(ValidationFailure.InvalidVisualAuthenticitySecurityFeatures);
      }
    }
  }

  if (breakdown.dataValidation) {
    if (isFailure(breakdown.dataValidation.result)) {
      failures.push(ValidationFailure.InvalidDataValidation);

      if (isFailure(breakdown.dataValidation.breakdown?.documentNumbers?.result)) {
        failures.push(ValidationFailure.InvalidDataValidationDocumentNumbers);
      }
    }
  }

  if (breakdown.dataConsistency) {
    if (isFailure(breakdown.dataConsistency.result)) {
      failures.push(ValidationFailure.InvalidDataConsistency);

      if (isFailure(breakdown.dataConsistency.breakdown?.documentType?.result)) {
        failures.push(ValidationFailure.InvalidDataConsistencyDocumentType);
      }
    }
  }

  return failures;
};

export default getDocumentValidationFailureDetails;

'''
'''--- utils/getFacialValidationFailureDetails.ts ---
import type OnfidoFacialReportBreakdown from '../types/OnfidoFacialReportBreakdown';
import ValidationFailure from '../types/ValidationFailure';

import isFailure from './isValidationFailure';

const getFacialValidationFailureDetails = (breakdown: OnfidoFacialReportBreakdown | null): ValidationFailure[] => {
  const failures: ValidationFailure[] = [];

  if (!breakdown) {
    return failures;
  }

  if (breakdown.visualAuthenticity) {
    if (isFailure(breakdown.visualAuthenticity.result)) {
      failures.push(ValidationFailure.InvalidVisualAuthenticitySpoofing);
    }
  }

  if (breakdown.imageIntegrity) {
    if (isFailure(breakdown.imageIntegrity.result)) {
      if (isFailure(breakdown.imageIntegrity.breakdown?.sourceIntegrity?.result)) {
        failures.push(ValidationFailure.InvalidImageIntegritySource);
      }
      if (isFailure(breakdown.imageIntegrity.breakdown?.faceDetected?.result)) {
        failures.push(ValidationFailure.InvalidImageIntegrityFaceDetected);
      }
    }
  }

  if (breakdown.faceComparison) {
    if (isFailure(breakdown.faceComparison.result)) {
      failures.push(ValidationFailure.InvalidFaceComparison);
    }
  }

  return failures;
};

export default getFacialValidationFailureDetails;

'''
'''--- utils/getStatusFromCheck.ts ---
import type { Check } from '@onfido/api';

import { CheckResults, CheckResultsStatus } from '../types/CheckResults';

// List of status: https://documentation.onfido.com/#check-status
// List of results: https://documentation.onfido.com/#check-results
const simplifiedStatus = new Map([
  ['in_progress', CheckResultsStatus.loading],
  ['awaiting_applicant', CheckResultsStatus.finished],
  ['complete', CheckResultsStatus.finished],
  ['withdrawn', CheckResultsStatus.finished],
  ['paused', CheckResultsStatus.willTakeLonger],
  ['reopened', CheckResultsStatus.willTakeLonger],
]);

const isStatusLoading = (status: CheckResultsStatus): boolean =>
  simplifiedStatus.get(status) === CheckResultsStatus.loading || simplifiedStatus.get(status) === CheckResultsStatus.willTakeLonger;

const getStatusFromCheck = (check: Check): Pick<CheckResults, 'isClear' | 'status'> => {
  const status = check.status as CheckResultsStatus;

  return {
    isClear: check.result === null && isStatusLoading(status) ? null : check.result === 'clear',
    status: simplifiedStatus.get(status) ?? CheckResultsStatus.finished,
  };
};

export default getStatusFromCheck;

'''
'''--- utils/isValidationFailure.ts ---
import type ValidationResult from '../types/ValidationResult';

const isValidationFailure = (result: ValidationResult | unknown | undefined) => result === 'consider' || result === 'unidentified' || result === 'rejected' || result === 'caution';

export default isValidationFailure;

'''
'''--- utils/listOfCountries.ts ---
/* eslint-disable max-lines */
const listOfCountries = [
  {
    value: 'AFG',
    label: 'Afghanistan',
  },
  {
    value: 'ALA',
    label: 'land Islands',
  },
  {
    value: 'ALB',
    label: 'Albania',
  },
  {
    value: 'DZA',
    label: 'Algeria',
  },
  {
    value: 'ASM',
    label: 'American Samoa',
  },
  {
    value: 'AND',
    label: 'Andorra',
  },
  {
    value: 'AGO',
    label: 'Angola',
  },
  {
    value: 'AIA',
    label: 'Anguilla',
  },
  {
    value: 'ATA',
    label: 'Antarctica',
  },
  {
    value: 'ATG',
    label: 'Antigua and Barbuda',
  },
  {
    value: 'ARG',
    label: 'Argentina',
  },
  {
    value: 'ARM',
    label: 'Armenia',
  },
  {
    value: 'ABW',
    label: 'Aruba',
  },
  {
    value: 'AUS',
    label: 'Australia',
  },
  {
    value: 'AUT',
    label: 'Austria',
  },
  {
    value: 'AZE',
    label: 'Azerbaijan',
  },
  {
    value: 'BHS',
    label: 'Bahamas',
  },
  {
    value: 'BHR',
    label: 'Bahrain',
  },
  {
    value: 'BGD',
    label: 'Bangladesh',
  },
  {
    value: 'BRB',
    label: 'Barbados',
  },
  {
    value: 'BLR',
    label: 'Belarus',
  },
  {
    value: 'BEL',
    label: 'Belgium',
  },
  {
    value: 'BLZ',
    label: 'Belize',
  },
  {
    value: 'BEN',
    label: 'Benin',
  },
  {
    value: 'BMU',
    label: 'Bermuda',
  },
  {
    value: 'BTN',
    label: 'Bhutan',
  },
  {
    value: 'BOL',
    label: 'Bolivia, Plurinational State of',
  },
  {
    value: 'BES',
    label: 'Bonaire, Sint Eustatius and Saba',
  },
  {
    value: 'BIH',
    label: 'Bosnia and Herzegovina',
  },
  {
    value: 'BWA',
    label: 'Botswana',
  },
  {
    value: 'BVT',
    label: 'Bouvet Island',
  },
  {
    value: 'BRA',
    label: 'Brazil',
  },
  {
    value: 'IOT',
    label: 'British Indian Ocean Territory',
  },
  {
    value: 'BRN',
    label: 'Brunei Darussalam',
  },
  {
    value: 'BGR',
    label: 'Bulgaria',
  },
  {
    value: 'BFA',
    label: 'Burkina Faso',
  },
  {
    value: 'BDI',
    label: 'Burundi',
  },
  {
    value: 'KHM',
    label: 'Cambodia',
  },
  {
    value: 'CMR',
    label: 'Cameroon',
  },
  {
    value: 'CAN',
    label: 'Canada',
  },
  {
    value: 'CPV',
    label: 'Cape Verde',
  },
  {
    value: 'CYM',
    label: 'Cayman Islands',
  },
  {
    value: 'CAF',
    label: 'Central African Republic',
  },
  {
    value: 'TCD',
    label: 'Chad',
  },
  {
    value: 'CHL',
    label: 'Chile',
  },
  {
    value: 'CHN',
    label: 'China',
  },
  {
    value: 'CXR',
    label: 'Christmas Island',
  },
  {
    value: 'CCK',
    label: 'Cocos (Keeling) Islands',
  },
  {
    value: 'COL',
    label: 'Colombia',
  },
  {
    value: 'COM',
    label: 'Comoros',
  },
  {
    value: 'COG',
    label: 'Congo',
  },
  {
    value: 'COD',
    label: 'Congo, the Democratic Republic of the',
  },
  {
    value: 'COK',
    label: 'Cook Islands',
  },
  {
    value: 'CRI',
    label: 'Costa Rica',
  },
  {
    value: 'CIV',
    label: "Cte d'Ivoire",
  },
  {
    value: 'HRV',
    label: 'Croatia',
  },
  {
    value: 'CUB',
    label: 'Cuba',
  },
  {
    value: 'CUW',
    label: 'Curaao',
  },
  {
    value: 'CYP',
    label: 'Cyprus',
  },
  {
    value: 'CZE',
    label: 'Czech Republic',
  },
  {
    value: 'DNK',
    label: 'Denmark',
  },
  {
    value: 'DJI',
    label: 'Djibouti',
  },
  {
    value: 'DMA',
    label: 'Dominica',
  },
  {
    value: 'DOM',
    label: 'Dominican Republic',
  },
  {
    value: 'ECU',
    label: 'Ecuador',
  },
  {
    value: 'EGY',
    label: 'Egypt',
  },
  {
    value: 'SLV',
    label: 'El Salvador',
  },
  {
    value: 'GNQ',
    label: 'Equatorial Guinea',
  },
  {
    value: 'ERI',
    label: 'Eritrea',
  },
  {
    value: 'EST',
    label: 'Estonia',
  },
  {
    value: 'ETH',
    label: 'Ethiopia',
  },
  {
    value: 'FLK',
    label: 'Falkland Islands (Malvinas)',
  },
  {
    value: 'FRO',
    label: 'Faroe Islands',
  },
  {
    value: 'FJI',
    label: 'Fiji',
  },
  {
    value: 'FIN',
    label: 'Finland',
  },
  {
    value: 'FRA',
    label: 'France',
  },
  {
    value: 'GUF',
    label: 'French Guiana',
  },
  {
    value: 'PYF',
    label: 'French Polynesia',
  },
  {
    value: 'ATF',
    label: 'French Southern Territories',
  },
  {
    value: 'GAB',
    label: 'Gabon',
  },
  {
    value: 'GMB',
    label: 'Gambia',
  },
  {
    value: 'GEO',
    label: 'Georgia',
  },
  {
    value: 'DEU',
    label: 'Germany',
  },
  {
    value: 'GHA',
    label: 'Ghana',
  },
  {
    value: 'GIB',
    label: 'Gibraltar',
  },
  {
    value: 'GRC',
    label: 'Greece',
  },
  {
    value: 'GRL',
    label: 'Greenland',
  },
  {
    value: 'GRD',
    label: 'Grenada',
  },
  {
    value: 'GLP',
    label: 'Guadeloupe',
  },
  {
    value: 'GUM',
    label: 'Guam',
  },
  {
    value: 'GTM',
    label: 'Guatemala',
  },
  {
    value: 'GGY',
    label: 'Guernsey',
  },
  {
    value: 'GIN',
    label: 'Guinea',
  },
  {
    value: 'GNB',
    label: 'Guinea-Bissau',
  },
  {
    value: 'GUY',
    label: 'Guyana',
  },
  {
    value: 'HTI',
    label: 'Haiti',
  },
  {
    value: 'HMD',
    label: 'Heard Island and McDonald Islands',
  },
  {
    value: 'VAT',
    label: 'Holy See (Vatican City State)',
  },
  {
    value: 'HND',
    label: 'Honduras',
  },
  {
    value: 'HKG',
    label: 'Hong Kong',
  },
  {
    value: 'HUN',
    label: 'Hungary',
  },
  {
    value: 'ISL',
    label: 'Iceland',
  },
  {
    value: 'IND',
    label: 'India',
  },
  {
    value: 'IDN',
    label: 'Indonesia',
  },
  {
    value: 'IRN',
    label: 'Iran, Islamic Republic of',
  },
  {
    value: 'IRQ',
    label: 'Iraq',
  },
  {
    value: 'IRL',
    label: 'Ireland',
  },
  {
    value: 'IMN',
    label: 'Isle of Man',
  },
  {
    value: 'ISR',
    label: 'Israel',
  },
  {
    value: 'ITA',
    label: 'Italy',
  },
  {
    value: 'JAM',
    label: 'Jamaica',
  },
  {
    value: 'JPN',
    label: 'Japan',
  },
  {
    value: 'JEY',
    label: 'Jersey',
  },
  {
    value: 'JOR',
    label: 'Jordan',
  },
  {
    value: 'KAZ',
    label: 'Kazakhstan',
  },
  {
    value: 'KEN',
    label: 'Kenya',
  },
  {
    value: 'KIR',
    label: 'Kiribati',
  },
  {
    value: 'PRK',
    label: "Korea, Democratic People's Republic of",
  },
  {
    value: 'KOR',
    label: 'Korea, Republic of',
  },
  {
    value: 'KWT',
    label: 'Kuwait',
  },
  {
    value: 'KGZ',
    label: 'Kyrgyzstan',
  },
  {
    value: 'LAO',
    label: "Lao People's Democratic Republic",
  },
  {
    value: 'LVA',
    label: 'Latvia',
  },
  {
    value: 'LBN',
    label: 'Lebanon',
  },
  {
    value: 'LSO',
    label: 'Lesotho',
  },
  {
    value: 'LBR',
    label: 'Liberia',
  },
  {
    value: 'LBY',
    label: 'Libya',
  },
  {
    value: 'LIE',
    label: 'Liechtenstein',
  },
  {
    value: 'LTU',
    label: 'Lithuania',
  },
  {
    value: 'LUX',
    label: 'Luxembourg',
  },
  {
    value: 'MAC',
    label: 'Macao',
  },
  {
    value: 'MKD',
    label: 'Macedonia, the former Yugoslav Republic of',
  },
  {
    value: 'MDG',
    label: 'Madagascar',
  },
  {
    value: 'MWI',
    label: 'Malawi',
  },
  {
    value: 'MYS',
    label: 'Malaysia',
  },
  {
    value: 'MDV',
    label: 'Maldives',
  },
  {
    value: 'MLI',
    label: 'Mali',
  },
  {
    value: 'MLT',
    label: 'Malta',
  },
  {
    value: 'MHL',
    label: 'Marshall Islands',
  },
  {
    value: 'MTQ',
    label: 'Martinique',
  },
  {
    value: 'MRT',
    label: 'Mauritania',
  },
  {
    value: 'MUS',
    label: 'Mauritius',
  },
  {
    value: 'MYT',
    label: 'Mayotte',
  },
  {
    value: 'MEX',
    label: 'Mexico',
  },
  {
    value: 'FSM',
    label: 'Micronesia, Federated States of',
  },
  {
    value: 'MDA',
    label: 'Moldova, Republic of',
  },
  {
    value: 'MCO',
    label: 'Monaco',
  },
  {
    value: 'MNG',
    label: 'Mongolia',
  },
  {
    value: 'MNE',
    label: 'Montenegro',
  },
  {
    value: 'MSR',
    label: 'Montserrat',
  },
  {
    value: 'MAR',
    label: 'Morocco',
  },
  {
    value: 'MOZ',
    label: 'Mozambique',
  },
  {
    value: 'MMR',
    label: 'Myanmar',
  },
  {
    value: 'NAM',
    label: 'Namibia',
  },
  {
    value: 'NRU',
    label: 'Nauru',
  },
  {
    value: 'NPL',
    label: 'Nepal',
  },
  {
    value: 'NLD',
    label: 'Netherlands',
  },
  {
    value: 'NCL',
    label: 'New Caledonia',
  },
  {
    value: 'NZL',
    label: 'New Zealand',
  },
  {
    value: 'NIC',
    label: 'Nicaragua',
  },
  {
    value: 'NER',
    label: 'Niger',
  },
  {
    value: 'NGA',
    label: 'Nigeria',
  },
  {
    value: 'NIU',
    label: 'Niue',
  },
  {
    value: 'NFK',
    label: 'Norfolk Island',
  },
  {
    value: 'MNP',
    label: 'Northern Mariana Islands',
  },
  {
    value: 'NOR',
    label: 'Norway',
  },
  {
    value: 'OMN',
    label: 'Oman',
  },
  {
    value: 'PAK',
    label: 'Pakistan',
  },
  {
    value: 'PLW',
    label: 'Palau',
  },
  {
    value: 'PSE',
    label: 'Palestinian Territory, Occupied',
  },
  {
    value: 'PAN',
    label: 'Panama',
  },
  {
    value: 'PNG',
    label: 'Papua New Guinea',
  },
  {
    value: 'PRY',
    label: 'Paraguay',
  },
  {
    value: 'PER',
    label: 'Peru',
  },
  {
    value: 'PHL',
    label: 'Philippines',
  },
  {
    value: 'PCN',
    label: 'Pitcairn',
  },
  {
    value: 'POL',
    label: 'Poland',
  },
  {
    value: 'PRT',
    label: 'Portugal',
  },
  {
    value: 'PRI',
    label: 'Puerto Rico',
  },
  {
    value: 'QAT',
    label: 'Qatar',
  },
  {
    value: 'REU',
    label: 'Runion',
  },
  {
    value: 'ROU',
    label: 'Romania',
  },
  {
    value: 'RUS',
    label: 'Russian Federation',
  },
  {
    value: 'RWA',
    label: 'Rwanda',
  },
  {
    value: 'BLM',
    label: 'Saint Barthlemy',
  },
  {
    value: 'SHN',
    label: 'Saint Helena, Ascension and Tristan da Cunha',
  },
  {
    value: 'KNA',
    label: 'Saint Kitts and Nevis',
  },
  {
    value: 'LCA',
    label: 'Saint Lucia',
  },
  {
    value: 'MAF',
    label: 'Saint Martin (French part)',
  },
  {
    value: 'SPM',
    label: 'Saint Pierre and Miquelon',
  },
  {
    value: 'VCT',
    label: 'Saint Vincent and the Grenadines',
  },
  {
    value: 'WSM',
    label: 'Samoa',
  },
  {
    value: 'SMR',
    label: 'San Marino',
  },
  {
    value: 'STP',
    label: 'Sao Tome and Principe',
  },
  {
    value: 'SAU',
    label: 'Saudi Arabia',
  },
  {
    value: 'SEN',
    label: 'Senegal',
  },
  {
    value: 'SRB',
    label: 'Serbia',
  },
  {
    value: 'SYC',
    label: 'Seychelles',
  },
  {
    value: 'SLE',
    label: 'Sierra Leone',
  },
  {
    value: 'SGP',
    label: 'Singapore',
  },
  {
    value: 'SXM',
    label: 'Sint Maarten (Dutch part)',
  },
  {
    value: 'SVK',
    label: 'Slovakia',
  },
  {
    value: 'SVN',
    label: 'Slovenia',
  },
  {
    value: 'SLB',
    label: 'Solomon Islands',
  },
  {
    value: 'SOM',
    label: 'Somalia',
  },
  {
    value: 'ZAF',
    label: 'South Africa',
  },
  {
    value: 'SGS',
    label: 'South Georgia and the South Sandwich Islands',
  },
  {
    value: 'SSD',
    label: 'South Sudan',
  },
  {
    value: 'ESP',
    label: 'Spain',
  },
  {
    value: 'LKA',
    label: 'Sri Lanka',
  },
  {
    value: 'SDN',
    label: 'Sudan',
  },
  {
    value: 'SUR',
    label: 'Suriname',
  },
  {
    value: 'SJM',
    label: 'Svalbard and Jan Mayen',
  },
  {
    value: 'SWZ',
    label: 'Swaziland',
  },
  {
    value: 'SWE',
    label: 'Sweden',
  },
  {
    value: 'CHE',
    label: 'Switzerland',
  },
  {
    value: 'SYR',
    label: 'Syrian Arab Republic',
  },
  {
    value: 'TWN',
    label: 'Taiwan, Province of China',
  },
  {
    value: 'TJK',
    label: 'Tajikistan',
  },
  {
    value: 'TZA',
    label: 'Tanzania, United Republic of',
  },
  {
    value: 'THA',
    label: 'Thailand',
  },
  {
    value: 'TLS',
    label: 'Timor-Leste',
  },
  {
    value: 'TGO',
    label: 'Togo',
  },
  {
    value: 'TKL',
    label: 'Tokelau',
  },
  {
    value: 'TON',
    label: 'Tonga',
  },
  {
    value: 'TTO',
    label: 'Trinidad and Tobago',
  },
  {
    value: 'TUN',
    label: 'Tunisia',
  },
  {
    value: 'TUR',
    label: 'Turkey',
  },
  {
    value: 'TKM',
    label: 'Turkmenistan',
  },
  {
    value: 'TCA',
    label: 'Turks and Caicos Islands',
  },
  {
    value: 'TUV',
    label: 'Tuvalu',
  },
  {
    value: 'UGA',
    label: 'Uganda',
  },
  {
    value: 'UKR',
    label: 'Ukraine',
  },
  {
    value: 'ARE',
    label: 'United Arab Emirates',
  },
  {
    value: 'GBR',
    label: 'United Kingdom',
  },
  {
    value: 'USA',
    label: 'United States',
  },
  {
    value: 'UMI',
    label: 'United States Minor Outlying Islands',
  },
  {
    value: 'URY',
    label: 'Uruguay',
  },
  {
    value: 'UZB',
    label: 'Uzbekistan',
  },
  {
    value: 'VUT',
    label: 'Vanuatu',
  },
  {
    value: 'VEN',
    label: 'Venezuela, Bolivarian Republic of',
  },
  {
    value: 'VNM',
    label: 'Viet Nam',
  },
  {
    value: 'VGB',
    label: 'Virgin Islands, British',
  },
  {
    value: 'VIR',
    label: 'Virgin Islands, U.S.',
  },
  {
    value: 'WLF',
    label: 'Wallis and Futuna',
  },
  {
    value: 'ESH',
    label: 'Western Sahara',
  },
  {
    value: 'YEM',
    label: 'Yemen',
  },
  {
    value: 'ZMB',
    label: 'Zambia',
  },
  {
    value: 'ZWE',
    label: 'Zimbabwe',
  },
];

export default listOfCountries;

'''
'''--- utils/statusCodes.ts ---
export const SUCCESS = 200;
export const NOT_FOUND = 404;
export const FORBIDDEN = 403;
export const SERVER_ERROR = 500;

'''
'''--- utils/validationMessages.ts ---
import ValidationFailure from '../types/ValidationFailure';

// More info about validation: https://documentation.onfido.com/v3.1/#breakdowns
const validationMessages: Map<ValidationFailure, string> = new Map([
  [ValidationFailure.InvalidImageIntegrity, 'There are issues with the images provided'],
  [ValidationFailure.InvalidImageIntegritySupportedDocument, 'The document provided is not supported'],
  [ValidationFailure.InvalidImageIntegrityImageQuality, 'The picture(s) you provided have quality issues, which may include: blurriness, darkness, glare, obstruction, etc.'], // https://documentation.onfido.com/#image-quality-reasons
  [ValidationFailure.InvalidVisualAuthenticity, 'There are issues with the pictures you provided'],
  [ValidationFailure.InvalidVisualAuthenticityFaceDetection, 'The face could not be detected in your documents'],
  [ValidationFailure.InvalidVisualAuthenticityFonts, 'The document provided is not readable'],
  [ValidationFailure.InvalidVisualAuthenticitySecurityFeatures, 'The documents provided are not valid'],
  [ValidationFailure.InvalidDataValidation, 'The data from your documents contains some errors'],
  [ValidationFailure.InvalidDataValidationDocumentNumbers, 'The document numbers you provided are invalid'],
  [ValidationFailure.InvalidDataConsistency, 'The document provided does not match the information provided'],
  [ValidationFailure.InvalidDataConsistencyDocumentType, 'The document type you provided is invalid'],
  [ValidationFailure.InvalidVisualAuthenticitySpoofing, 'The picture provided does not seem authentic'],
  [ValidationFailure.InvalidFaceComparison, 'The picture does not match the document provided'],
  [ValidationFailure.InvalidImageIntegritySource, 'The photo provided is not valid'],
  [ValidationFailure.InvalidImageIntegrityFaceDetected, 'Another face has been detected in the picture'],
]);

export default validationMessages;

'''