*GitHub Repository "near/near-sdk-contract-tools"*

'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- .github/workflows/rust.yml ---
name: Rust

on:
  push:
    branches: ['main', 'develop']
  pull_request:
    branches: ['main', 'develop']

env:
  CARGO_TERM_COLOR: always

jobs:
  check-formatting:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.74
          components: rustfmt
      - name: Check formatting
        run: >
          echo "::echo::on";
          cargo fmt -- --check;
  lint:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.74
          components: clippy
      - name: Run linter
        run: cargo clippy -- -D warnings
  test:
    runs-on: ubuntu-latest
    env:
      CARGO_TERM_COLOR: always

    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.74
      - uses: taiki-e/install-action@v2
        with:
          tool: nextest
      - uses: Swatinem/rust-cache@v2
      - name: Run unit and integration tests
        run: cargo nextest run --workspace --exclude workspaces-tests
      - name: Run doctests
        run: cargo test --doc
  workspaces-test:
    runs-on: ubuntu-latest
    env:
      CARGO_TERM_COLOR: always

    steps:
      - uses: actions/checkout@v3
      - uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.74
          targets: wasm32-unknown-unknown
      - uses: taiki-e/install-action@v2
        with:
          tool: cargo-make,nextest
      - uses: Swatinem/rust-cache@v2
      - name: Run workspaces tests
        run: cd workspaces-tests && cargo make nextest

'''
'''--- .vscode/settings.json ---
{
  "editor.tabSize": 4,
  "[rust]": {
    "editor.formatOnType": true,
    "editor.formatOnPaste": true,
    "editor.formatOnSave": true,
    "editor.defaultFormatter": "rust-lang.rust-analyzer"
  },
}

'''
'''--- Cargo.toml ---
[package]
authors.workspace = true
categories = ["wasm", "cryptography::cryptocurrencies"]
description = """
Helpful functions and macros for developing smart contracts on NEAR Protocol.
"""
documentation = "https://docs.rs/near-sdk-contract-tools"
edition.workspace = true
exclude = ["documents/"]
license.workspace = true
name = "near-sdk-contract-tools"
repository.workspace = true
version.workspace = true

[workspace]
members = [".", "macros", "workspaces-tests", "workspaces-tests-utils"]

[workspace.package]
authors = ["Jacob Lindahl <jacob.lindahl@near.org>"]
edition = "2021"
license = "GPL-3.0 OR Apache-2.0"
repository = "https://github.com/near/near-sdk-contract-tools"
version = "3.0.2"

[workspace.dependencies]
# normal dependencies
near-sdk = { version = "5.1.0", default-features = false }
near-sdk-contract-tools-macros = { version = "=3.0.2", path = "./macros" }
thiserror = "1"

# macro dependencies
darling = "0.20"
heck = "0.5"
proc-macro2 = "1"
quote = "1.0"
strum = "0.26"
strum_macros = "0.26"
syn = "2.0"

# test/dev-dependencies
near-crypto = "0.21"
near-workspaces = "0.10"
pretty_assertions = "1"
tokio = "1"

[workspace.lints.clippy]
pedantic = "warn"
module-name-repetitions = "allow"

[workspace.lints.rust]
missing-docs = "warn"

[dependencies]
near-sdk = { workspace = true, default-features = false, features = ["legacy"] }
near-sdk-contract-tools-macros.workspace = true
thiserror.workspace = true

[dev-dependencies]
near-sdk = { workspace = true, default-features = false, features = [
  "unit-testing",
  "legacy",
] }

[features]
unstable = ["near-sdk/unstable"]

[package.metadata.docs.rs]
features = ["unstable"]
rustdoc-args = ["--cfg", "docsrs"]

[profile.release]
codegen-units = 1
debug = false
lto = true
opt-level = "z"
overflow-checks = true
panic = "abort"

[lints]
workspace = true

'''
'''--- README.md ---
# near-sdk-contract-tools

## NFT

```rust
use near_sdk::near;
use near_sdk_contract_tools::nft::*;

#[derive(Default, NonFungibleToken)]
#[near(contract_state)]
pub struct MyNftContract {}

#[near]
impl MyNftContract {
    #[init]
    pub fn new() -> Self {
        let mut contract = Self {};

        contract.set_contract_metadata(&ContractMetadata::new("My NFT", "MNFT", None));

        contract
    }
}
```

## FT

```rust
use near_sdk::near;
use near_sdk_contract_tools::ft::*;

#[derive(Default, FungibleToken)]
#[near(contract_state)]
pub struct MyFtContract {}

#[near]
impl MyFtContract {
    #[init]
    pub fn new() -> Self {
        let mut contract = Self {};

        contract.set_metadata(&ContractMetadata::new("My Fungible Token", "MYFT", 24));

        contract
    }
}
```

## What is it?

This package is a collection of common tools and patterns in NEAR smart contract development:

- Storage fee management.
- Escrow pattern and derive macro.
- Owner pattern and derive macro.
- Pause pattern and derive macro.
- Role-based access control.
- Derive macros for NEP standards:
  - [NEP-141][nep141] (fungible token), extension [NEP-148][nep148].
  - [NEP-145][nep145] (storage management), and integrations for the fungible token and non-fungible token standards.
  - [NEP-171][nep171] (non-fungible token), extensions [NEP-177][nep177], [NEP-178][nep178], [NEP-181][nep181].
  - [NEP-297][nep297] (events).

Not to be confused with [`near-contract-standards`](https://crates.io/crates/near-contract-standards), which contains official implementations of standardized NEPs. This crate is intended to be a complement to `near-contract-standards`.

You can think of this collection of common tools and patterns (mostly in the form of [derive macros](https://doc.rust-lang.org/reference/procedural-macros.html#derive-macros)) as a sort of [OpenZeppelin](https://docs.openzeppelin.com/contracts/4.x/) for NEAR.

Pro tip: Use the [contract wizard](https://near.org/contractwizard.near/widget/ContractWizardUI) to generate starter code for your next project.

## Installation

```bash
cargo add near-sdk-contract-tools
```

## Examples

See also: [the full integration tests](tests/macros/mod.rs).

### Owner

```rust
use near_sdk::{near, AccountId, PanicOnDefault};
use near_sdk_contract_tools::{owner::Owner, Owner};

#[derive(Owner, PanicOnDefault)]
#[near(contract_state)]
struct Contract {
    // ...
}

#[near]
impl Contract {
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        let mut contract = Self {
            // ...
        };

        Owner::init(&mut contract, &owner_id);

        contract
    }

    pub fn owner_only(&self) {
        Self::require_owner();

        // ...
    }
}
```

The `Owner` derive macro exposes the following methods to the blockchain:

```rust, ignore
fn own_get_owner(&self) -> Option<AccountId>;
fn own_get_proposed_owner(&self) -> Option<AccountId>;
fn own_renounce_owner(&mut self);
fn own_propose_owner(&mut self, account_id: Option<AccountId>);
fn own_accept_owner(&mut self);
```

### Events

The `#[event]` macro can be applied to structs or enums.

```rust
use near_sdk_contract_tools::{event, standard::nep297::Event};

#[event(standard = "nft", version = "1.0.0")]
pub struct MintEvent {
    pub owner_id: String,
    pub token_id: String,
}

let e = MintEvent {
    owner_id: "account".to_string(),
    token_id: "token_1".to_string(),
};

// Emits the event to the blockchain
e.emit();
```

### Fungible Token

To create a contract that is compatible with the [NEP-141][nep141], [NEP-145][nep145], and [NEP-148][nep148] standards, that emits standard-compliant ([NEP-297][nep297]) events.

```rust
use near_sdk::near;
use near_sdk_contract_tools::ft::*;

#[derive(Default, FungibleToken)]
#[near(contract_state)]
struct MyFt {}

#[near]
impl MyFt {
    #[init]
    pub fn new() -> Self {
        let mut contract = Self {};

        contract.set_metadata(&ContractMetadata::new("My Fungible Token", "MYFT", 24));

        contract
    }
}
```

Standalone macros for each individual standard also exist.

### Non-fungible Token

Use the `NonFungibleToken` derive macro to implement [NEP-145][nep145], [NEP-171][nep171], [NEP-177][nep177], [NEP-178][nep178], and [NEP-181][nep181], with [NEP-297][nep297] events.

```rust
use near_sdk::{near, PanicOnDefault};
use near_sdk_contract_tools::nft::*;

#[derive(NonFungibleToken, PanicOnDefault)]
#[near(contract_state)]
pub struct MyNft {}
```

### Macro Combinations

One may wish to combine the features of multiple macros in one contract. All of the macros are written such that they will work in a standalone manner, so this should largely work without issue. However, sometimes it may be desirable for the macros to work in _combination_ with each other. For example, to make a fungible token pausable, use the fungible token hooks to require that a contract be unpaused before making a token transfer:

```rust
use near_sdk_contract_tools::{
    ft::*,
    pause::{*, hooks::Pausable},
    Pause,
};
use near_sdk::{near, PanicOnDefault};

#[derive(FungibleToken, Pause, PanicOnDefault)]
#[fungible_token(all_hooks = "Pausable")]
#[near(contract_state)]
struct Contract {}
```

### Custom Crates

If you are a library developer, have modified a crate that one of the `near-sdk-contract-tools` macros uses (like `serde` or `near-sdk`), or are otherwise using a crate under a different name, you can specify crate names in macros like so:

```rust, ignore
#[event(
    // ...
    crate = "near_sdk_contract_tools",
    macros = "near_sdk_contract_tools_macros",
    serde = "serde",
)]
// ...

#[derive(Owner)]
#[owner(
    // ...
    near_sdk = "near_sdk",
)]
```

## Other Tips

### [Internal vs. External Methods](https://youtu.be/kJzes_UP5j0?t=2172)

Internal methods are not available to be callable via the blockchain. External ones are public and can be called by other contracts.

### [Pull pattern](https://youtu.be/kJzes_UP5j0?t=2213)

Proposing ownership (rather than transferring directly) is a generally good practice because it prevents you from accidentally transferring ownership to an account that nobody has access to, bricking the contract.

### [Expand](https://youtu.be/kJzes_UP5j0?t=1790)

[`cargo expand`](https://crates.io/crates/cargo-expand) will generate one huge Rust file with all of the macros have been processed:

```text
cargo install cargo-expand
cargo expand > expanded.rs
```

### [Slots](https://youtu.be/kJzes_UP5j0?t=2527)

See [`src/slot.rs`](src/slot.rs). Slots are thin wrappers over a storage key.

### [`assert_one_yocto()`](https://youtu.be/kJzes_UP5j0?t=2989)

`near_sdk::assert_one_yocto()` is a function that requires a full access key (by requiring a deposit of one yoctonear, the smallest possible unit of NEAR).

If a user connects their NEAR account to a dapp, the dapp will still not be able to call functions that call `assert_one_yocto()`, since function call access keys are not allowed to transfer native tokens. These function will require a signature from a full access key, usually involving a confirmation screen in the user's wallet.

## Contributing

### Setup

Run `git config core.hooksPath hooks/` to set up commit hooks.

### Build and test

Install `cargo-make` if it is not installed already:

```text
cargo install cargo-make cargo-nextest
```

Run tests:

```text
cargo nextest run
cargo test --doc
cd workspaces-tests
cargo make nextest
```

## Audit

Version 1.0.0 of this library has been [audited](./documents/NEAR%20Contract%20Tools%20-%20Final%20-%2005.05.2023.pdf) by [Kudelski Security](https://www.kudelskisecurity.com/). (May 2023)

## Authors

- Jacob Lindahl [@sudo_build](https://twitter.com/sudo_build)

---

(Formerly known as [`near-contract-tools`](https://crates.io/crates/near-contract-tools).)

[nep145]: https://nomicon.io/Standards/StorageManagement
[nep141]: https://nomicon.io/Standards/Tokens/FungibleToken/Core
[nep148]: https://nomicon.io/Standards/Tokens/FungibleToken/Metadata
[nep171]: https://nomicon.io/Standards/NonFungibleToken/NonFungibleToken
[nep177]: https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata
[nep178]: https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement
[nep181]: https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration
[nep297]: https://nomicon.io/Standards/EventsFormat

'''
'''--- SECURITY.md ---
# Security Policy

## Reporting a Vulnerability

Please report vulnerabilities and security-related bugs to <security@near.org>, and we'll review promptly.

We really appreciate your help.

'''
'''--- macros/Cargo.toml ---
[package]
authors.workspace = true
categories = ["wasm"]
description = """
Macros for `near-sdk-contract-tools`
"""
documentation = "https://docs.rs/near-sdk-contract-tools-macros"
edition.workspace = true
license.workspace = true
name = "near-sdk-contract-tools-macros"
repository.workspace = true
version.workspace = true

[dependencies]
darling.workspace = true
heck.workspace = true
proc-macro2.workspace = true
quote.workspace = true
strum.workspace = true
strum_macros.workspace = true
syn.workspace = true

[lib]
proc-macro = true

[lints]
workspace = true

'''
'''--- macros/src/approval/mod.rs ---
pub mod simple_multisig;

'''
'''--- macros/src/approval/simple_multisig.rs ---
use darling::FromDeriveInput;
use proc_macro2::TokenStream;
use quote::quote;
use syn::Expr;

#[derive(Debug, FromDeriveInput)]
#[darling(attributes(simple_multisig), supports(struct_named))]
pub struct SimpleMultisigMeta {
    pub storage_key: Option<Expr>,
    pub action: Expr,
    pub role: Expr,

    pub generics: syn::Generics,
    pub ident: syn::Ident,

    // crates
    #[darling(rename = "crate", default = "crate::default_crate_name")]
    pub me: syn::Path,
    #[darling(default = "crate::default_near_sdk")]
    pub near_sdk: syn::Path,
}

pub fn expand(meta: SimpleMultisigMeta) -> Result<TokenStream, darling::Error> {
    let SimpleMultisigMeta {
        storage_key,
        action,
        role,
        generics,
        ident,
        me,
        near_sdk,
    } = meta;

    let (imp, ty, wher) = generics.split_for_impl();

    let root = storage_key.map(|storage_key| {
        quote! {
            fn root() -> #me::slot::Slot<()> {
                #me::slot::Slot::root(#storage_key)
            }
        }
    });

    Ok(quote! {
        impl #imp #me::approval::ApprovalManagerInternal<
                #action,
                #me::approval::simple_multisig::ApprovalState,
                #me::approval::simple_multisig::Configuration<Self>,
            > for #ident #ty #wher {
            #root
        }

        impl #imp #me::approval::simple_multisig::AccountAuthorizer for #ident #ty #wher {
            type AuthorizationError =
                #me::approval::simple_multisig::macro_types::MissingRole<
                    <#ident as #me::rbac::Rbac>::Role
                >;

            fn is_account_authorized(account_id: &#near_sdk::AccountId) -> Result<(), Self::AuthorizationError> {
                if <#ident as #me::rbac::Rbac>::has_role(account_id, &#role) {
                    Ok(())
                } else {
                    Err(#me::approval::simple_multisig::macro_types::MissingRole(#role))
                }
            }
        }
    })
}

'''
'''--- macros/src/escrow.rs ---
use darling::FromDeriveInput;
use proc_macro2::TokenStream;
use quote::quote;
use syn::Expr;

#[derive(Debug, FromDeriveInput)]
#[darling(attributes(escrow), supports(struct_named))]
pub struct EscrowMeta {
    pub storage_key: Option<Expr>,
    pub id: Expr,
    pub state: Option<Expr>,

    pub generics: syn::Generics,
    pub ident: syn::Ident,

    // crates
    #[darling(rename = "crate", default = "crate::default_crate_name")]
    pub me: syn::Path,
    #[darling(default = "crate::default_near_sdk")]
    pub near_sdk: syn::Path,
}

pub fn expand(meta: EscrowMeta) -> Result<TokenStream, darling::Error> {
    let EscrowMeta {
        storage_key,
        id,
        state,

        ident,
        generics,

        me,
        near_sdk: _near_sdk,
    } = meta;

    let (imp, ty, wher) = generics.split_for_impl();

    let root = storage_key.map(|storage_key| {
        quote! {
            fn root() -> #me::slot::Slot<()> {
                #me::slot::Slot::root(#storage_key)
            }
        }
    });

    let state = state.map_or_else(|| quote! { () }, |state| quote! { #state });

    Ok(quote! {
        impl #imp #me::escrow::EscrowInternal for #ident #ty #wher {
            type Id = #id;
            type State = #state;

            #root
        }
    })
}

'''
'''--- macros/src/lib.rs ---
#![allow(clippy::too_many_lines, clippy::unnecessary_wraps)]
//! Macros for near-sdk-contract-tools.

use darling::{ast::NestedMeta, FromDeriveInput, FromMeta};
use proc_macro::TokenStream;
use syn::{parse_macro_input, DeriveInput, Item};

mod approval;
mod escrow;
mod migrate;
mod owner;
mod pause;
mod rbac;
mod rename;
mod standard;
mod upgrade;

fn default_crate_name() -> syn::Path {
    syn::parse_str("::near_sdk_contract_tools").unwrap()
}

fn default_macros() -> syn::Path {
    syn::parse_str("::near_sdk_contract_tools").unwrap()
}

fn default_near_sdk() -> syn::Path {
    syn::parse_str("::near_sdk").unwrap()
}

fn default_serde() -> syn::Path {
    syn::parse_str("::near_sdk::serde").unwrap()
}

fn unitify(ty: Option<syn::Type>) -> syn::Type {
    ty.unwrap_or_else(|| syn::parse_quote! { () })
}

fn make_derive<T>(
    input: TokenStream,
    expand: fn(T) -> Result<proc_macro2::TokenStream, darling::Error>,
) -> TokenStream
where
    T: FromDeriveInput,
{
    let input = parse_macro_input!(input as DeriveInput);

    FromDeriveInput::from_derive_input(&input)
        .and_then(expand)
        .map_or_else(|e| e.write_errors().into(), Into::into)
}

/// Use on a struct to emit NEP-297 event strings.
///
/// Specify event standard parameters: `#[nep297(standard = "...", version = "...")]`
///
/// Optional: `#[nep297(name = "...")]`
///
/// Rename strategy for all variants (default: unchanged): `#[event(rename = "<strategy>")]`
/// Options for `<strategy>`:
/// - `UpperCamelCase`
/// - `lowerCamelCase`
/// - `snake_case`
/// - `kebab-case`
/// - `SHOUTY_SNAKE_CASE`
/// - `SHOUTY-KEBAB-CASE`
/// - `Title Case`
///
/// # Warning
///
/// Rename strategies are provided for convenience, and the actual string
/// transformation is delegated to the [`heck`](https://crates.io/crates/heck)
/// crate. It _is_ possible that unexpected name transformations or collisions
/// may occur, but it is _extremely unlikely_ if reasonable Rust naming
/// conventions are followed.
///
/// For example, `"HelloWorld"`, `"hello_world"`, and `"hello__world"`, when
/// snake-case-ified, are `"hello_world"`, so if you happened to name distinct
/// events thusly, the transformed names would collide.
#[proc_macro_derive(Nep297, attributes(nep297))]
pub fn derive_nep297(input: TokenStream) -> TokenStream {
    make_derive(input, standard::nep297::expand)
}

/// Creates a managed, lazily-loaded `Owner` implementation for the targeted
/// `#[near(contract_state)]` struct.
///
/// The storage key prefix for the fields can be optionally specified (default:
/// `"~o"`) using `#[owner(storage_key = "<expression>")]`.
#[proc_macro_derive(Owner, attributes(owner))]
pub fn derive_owner(input: TokenStream) -> TokenStream {
    make_derive(input, owner::expand)
}

/// Makes a contract pausable. Provides an implementation of the `Pause` trait.
///
/// The storage key prefix for the fields can be optionally specified (default:
/// `"~p"`) using `#[pause(storage_key = "<expression>")]`.
#[proc_macro_derive(Pause, attributes(pause))]
pub fn derive_pause(input: TokenStream) -> TokenStream {
    make_derive(input, pause::expand)
}

/// Adds role-based access control. No external methods are exposed.
///
/// The roles prefix can be specified using `#[rbac(roles = "MyRoles")]`.
/// Typically `"MyRoles"` is an enum and its variants are the different role
/// names.
///
/// The storage key prefix for the fields can be optionally specified (default:
/// `"~r"`) using `#[rbac(storage_key = "<expression>")]`.
#[proc_macro_derive(Rbac, attributes(rbac))]
pub fn derive_rbac(input: TokenStream) -> TokenStream {
    make_derive(input, rbac::expand)
}

/// Adds NEP-141 fungible token core functionality to a contract. Exposes
/// `ft_*` functions to the public blockchain, implements internal controller
/// and receiver functionality.
///
/// The storage key prefix for the fields can be optionally specified (default:
/// `"~$141"`) using `#[nep141(storage_key = "<expression>")]`.
#[proc_macro_derive(Nep141, attributes(nep141))]
pub fn derive_nep141(input: TokenStream) -> TokenStream {
    make_derive(input, standard::nep141::expand)
}

/// Adds NEP-145 fungible token core functionality to a contract. Exposes
/// `storage_*` functions to the public blockchain, implements internal
/// controller functionality.
///
/// The storage key prefix for the fields can be optionally specified (default:
/// `"~$145"`) using `#[nep145(storage_key = "<expression>")]`.
#[proc_macro_derive(Nep145, attributes(nep145))]
pub fn derive_nep145(input: TokenStream) -> TokenStream {
    make_derive(input, standard::nep145::expand)
}

/// Adds NEP-148 fungible token metadata functionality to a contract. Metadata
/// must be initialized during contract creation using `Nep148Controller::set_metadata`.
///
/// The storage key prefix for the fields can be optionally specified (default:
/// `"~$148"`) using `#[nep148(storage_key = "<expression>")]`.
#[proc_macro_derive(Nep148, attributes(nep148))]
pub fn derive_nep148(input: TokenStream) -> TokenStream {
    make_derive(input, standard::nep148::expand)
}

/// Implements NEP-141, NEP-145, and NEP-148 functionality, like
/// `#[derive(Nep141, Nep145, Nep148)]`. This is the recommended way to
/// implement a fungible token, as it also ensures that all of the standards
/// integrate with each other correctly.
///
/// Attributes are generally the union of those from the constituent derive
/// macros.
/// Specify attributes with `#[fungible_token(...)]`.
#[proc_macro_derive(FungibleToken, attributes(fungible_token))]
pub fn derive_fungible_token(input: TokenStream) -> TokenStream {
    make_derive(input, standard::fungible_token::expand)
}

/// Adds NEP-171 non-fungible token core functionality to a contract. Exposes
/// `nft_*` functions to the public blockchain, implements internal controller
/// and receiver functionality.
///
/// The storage key prefix for the fields can be optionally specified (default:
/// `"~$171"`) using `#[nep171(storage_key = "<expression>")]`.
///
/// Fields:
/// - `no_hooks`: Flag. Removes the requirement for the contract to implement
/// transfer hooks.
/// - `token_data`: specify the token metadata loading extensions invoked by
/// `nft_token`.
#[proc_macro_derive(Nep171, attributes(nep171))]
pub fn derive_nep171(input: TokenStream) -> TokenStream {
    make_derive(input, standard::nep171::expand)
}

/// Adds NEP-177 non-fungible token metadata functionality to a contract.
///
/// The storage key prefix for the fields can be optionally specified (default:
/// `"~$177"`) using `#[nep177(storage_key = "<expression>")]`.
#[proc_macro_derive(Nep177, attributes(nep177))]
pub fn derive_nep177(input: TokenStream) -> TokenStream {
    make_derive(input, standard::nep177::expand)
}

/// Adds NEP-178 non-fungible token approvals functionality to a contract.
///
/// The storage key prefix for the fields can be optionally specified (default:
/// `"~$178"`) using `#[nep178(storage_key = "<expression>")]`.
#[proc_macro_derive(Nep178, attributes(nep178))]
pub fn derive_nep178(input: TokenStream) -> TokenStream {
    make_derive(input, standard::nep178::expand)
}

/// Adds NEP-181 non-fungible token enumeration functionality to a contract.
///
/// The storage key prefix for the fields can be optionally specified (default:
/// `"~$181"`) using `#[nep181(storage_key = "<expression>")]`.
#[proc_macro_derive(Nep181, attributes(nep181))]
pub fn derive_nep181(input: TokenStream) -> TokenStream {
    make_derive(input, standard::nep181::expand)
}

/// Implements all NFT functionality at once, like `#[derive(Nep171, Nep177, Nep178, Nep181)]`.
#[proc_macro_derive(NonFungibleToken, attributes(non_fungible_token))]
pub fn derive_non_fungible_token(input: TokenStream) -> TokenStream {
    make_derive(input, standard::non_fungible_token::expand)
}

/// Migrate a contract's default struct from one schema to another.
///
/// Fields may be specified in the `#[migrate(...)]` attribute.
///
/// Fields include:
///  - `from` Old default struct type to convert from. (required)
///  - `to` New default struct type to convert into. (optional, default: `Self`)
///  - `convert` Identifier of a function that converts from the old schema to
///     the new schema. Mutually exclusive with `convert_with_args`. (optional,
///     default: `<Self::NewSchema as From<Self::OldSchema>>::from`)
///  - `convert_with_args` Identifier of a function that converts from the old
///     schema to the new schema and accepts a single `String` argument.
///     Mutually exclusive with `convert`. (optional)
///  - `allow` Expression to evaluate before allowing
#[proc_macro_derive(Migrate, attributes(migrate))]
pub fn derive_migrate(input: TokenStream) -> TokenStream {
    make_derive(input, migrate::expand)
}

/// Create a simple multisig component. Does not expose any functions to the
/// blockchain. Creates implementations for `ApprovalManager` and
/// `AccountApprover` for the target contract struct.
///
/// Fields may be specified in the `#[simple_multisig(...)]` attribute.
///
/// Fields include:
///  - `storage_key` Storage prefix for multisig data (optional, default: `b"~sm"`)
///  - `action` What sort of approval `Action` can be approved by the multisig
///     component?
///  - `role` Approving accounts are required to have this `Rbac` role.
#[proc_macro_derive(SimpleMultisig, attributes(simple_multisig))]
pub fn derive_simple_multisig(input: TokenStream) -> TokenStream {
    make_derive(input, approval::simple_multisig::expand)
}

/// Smart `#[event]` macro.
///
/// See documentation on the [`derive@Nep297`] derive macro for more details.
#[proc_macro_attribute]
pub fn event(attr: TokenStream, item: TokenStream) -> TokenStream {
    let attr = match NestedMeta::parse_meta_list(attr.into()) {
        Ok(v) => v,
        Err(e) => {
            return TokenStream::from(darling::Error::from(e).write_errors());
        }
    };
    let item = parse_macro_input!(item as Item);

    standard::event::EventAttributeMeta::from_list(&attr)
        .and_then(|meta| standard::event::event_attribute(meta, &item))
        .map_or_else(|e| e.write_errors().into(), Into::into)
}

/// Create an upgrade component. Does not expose any functions to the
/// blockchain.
///
/// Fields may be specified in the `#[upgrade(...)]` attribute.
///
/// Fields include:
///  - `hook` - If included, provides an implementation of `UpgradeHook`. An implementation must be explicity provided otherwise. Options include:
///     - `"none"` - Empty upgrade hook.
///     - `"owner"` - The upgrade function may only be called by the owner of the contract as specified by an `Owner` implementation.
///     - `"role(r)"` - The upgrade function may only be called by an account that has been assigned the role `r` as determined by an `Rbac` implementation.
///  - `serializer` - `"borsh"` or `"jsonbase64"` (default). Indicates the serialization format of code the `upgrade` function will accept.
///  - `migrate_method_name` - The name of the method to call after the upgrade. Default `"migrate"`.
///  - `migrate_method_args` - The input to send to the migrate function. Default empty vector.
///  - `migrate_minimum_gas` - How much gas to guarantee the migrate function, otherwise reject. Default 15T.
#[proc_macro_derive(Upgrade, attributes(upgrade))]
pub fn derive_upgrade(input: TokenStream) -> TokenStream {
    make_derive(input, upgrade::expand)
}

/// Creates a managed, lazily-loaded `Escrow` implementation for the targeted
/// `#[near(contract_state)]` struct.
///
/// Fields include:
///  - `id` - the type required for id, must be `borsh::BorshSerialize` & `serde::Serialize`, for events
///  - `state` - the type required for id, must be `borsh::BorshSerialize` & `borsh::BorshSerialize`
///  - `storage_key` Storage prefix for escrow data (optional, default: `b"~es"`)
#[proc_macro_derive(Escrow, attributes(escrow))]
pub fn derive_escrow(input: TokenStream) -> TokenStream {
    make_derive(input, escrow::expand)
}

'''
'''--- macros/src/migrate.rs ---
use darling::FromDeriveInput;
use proc_macro2::TokenStream;
use quote::{quote, ToTokens};

#[derive(Debug, FromDeriveInput)]
#[darling(attributes(migrate), supports(struct_named))]
pub struct MigrateMeta {
    pub from: syn::Type,
    pub to: Option<syn::Type>,

    pub ident: syn::Ident,
    pub generics: syn::Generics,

    // crates
    #[darling(rename = "crate", default = "crate::default_crate_name")]
    pub me: syn::Path,
    #[darling(default = "crate::default_near_sdk")]
    pub near_sdk: syn::Path,
}

pub fn expand(meta: MigrateMeta) -> Result<TokenStream, darling::Error> {
    let MigrateMeta {
        from,
        to,

        ident,
        generics,

        me,
        near_sdk,
    } = meta;

    let (imp, ty, wh) = generics.split_for_impl();

    let to = to.map_or_else(
        || quote! { Self }.to_token_stream(),
        |t| t.to_token_stream(),
    );

    Ok(quote! {
        impl #imp #me::migrate::MigrateController for #ident #ty #wh {
            type OldSchema = #from;
            type NewSchema = #to;
        }

        #[#near_sdk::near]
        impl #imp #ident #ty #wh {
            #[init(ignore_state)]
            pub fn migrate() -> Self {
                let old_state = <#ident as #me::migrate::MigrateController>::deserialize_old_schema();
                <#ident as #me::migrate::MigrateHook>::on_migrate(
                    old_state,
                )
            }
        }
    })
}

'''
'''--- macros/src/owner.rs ---
use darling::FromDeriveInput;
use proc_macro2::TokenStream;
use quote::quote;
use syn::Expr;

#[derive(Debug, FromDeriveInput)]
#[darling(attributes(owner), supports(struct_named))]
pub struct OwnerMeta {
    pub storage_key: Option<Expr>,

    pub generics: syn::Generics,
    pub ident: syn::Ident,

    // crates
    #[darling(rename = "crate", default = "crate::default_crate_name")]
    pub me: syn::Path,
    #[darling(default = "crate::default_near_sdk")]
    pub near_sdk: syn::Path,
}

pub fn expand(meta: OwnerMeta) -> Result<TokenStream, darling::Error> {
    let OwnerMeta {
        storage_key,
        ident,
        generics,

        me,
        near_sdk,
    } = meta;

    let (imp, ty, wher) = generics.split_for_impl();

    let root = storage_key.map(|storage_key| {
        quote! {
            fn root() -> #me::slot::Slot<()> {
                #me::slot::Slot::root(#storage_key)
            }
        }
    });

    Ok(quote! {
        impl #imp #me::owner::OwnerInternal for #ident #ty #wher {
            #root
        }

        #[#near_sdk::near]
        impl #imp #me::owner::OwnerExternal for #ident #ty #wher {
            fn own_get_owner(&self) -> Option<#near_sdk::AccountId> {
                <Self as #me::owner::OwnerInternal>::slot_owner().read()
            }

            fn own_get_proposed_owner(&self) -> Option<#near_sdk::AccountId> {
                <Self as #me::owner::OwnerInternal>::slot_proposed_owner().read()
            }

            #[payable]
            fn own_renounce_owner(&mut self) {
                #near_sdk::assert_one_yocto();
                #me::owner::Owner::renounce_owner(self);
            }

            #[payable]
            fn own_propose_owner(&mut self, account_id: Option<#near_sdk::AccountId>) {
                #near_sdk::assert_one_yocto();
                #me::owner::Owner::propose_owner(self, account_id);
            }

            #[payable]
            fn own_accept_owner(&mut self) {
                #near_sdk::assert_one_yocto();
                #me::owner::Owner::accept_owner(self);
            }
        }
    })
}

'''
'''--- macros/src/pause.rs ---
use darling::FromDeriveInput;
use proc_macro2::TokenStream;
use quote::quote;
use syn::Expr;

#[derive(Debug, FromDeriveInput)]
#[darling(attributes(pause), supports(struct_named))]
pub struct PauseMeta {
    pub storage_key: Option<Expr>,

    pub generics: syn::Generics,
    pub ident: syn::Ident,

    // crates
    #[darling(rename = "crate", default = "crate::default_crate_name")]
    pub me: syn::Path,
    #[darling(default = "crate::default_near_sdk")]
    pub near_sdk: syn::Path,
}

pub fn expand(meta: PauseMeta) -> Result<TokenStream, darling::Error> {
    let PauseMeta {
        storage_key,
        ident,
        generics,

        me,
        near_sdk,
    } = meta;

    let (imp, ty, wher) = generics.split_for_impl();

    let root = storage_key.map(|storage_key| {
        quote! {
            fn root() -> #me::slot::Slot<()> {
                #me::slot::Slot::new(#storage_key)
            }
        }
    });

    Ok(quote! {
        impl #imp #me::pause::PauseInternal for #ident #ty #wher {
            #root
        }

        #[#near_sdk::near]
        impl #imp #me::pause::PauseExternal for #ident #ty #wher {
            fn paus_is_paused(&self) -> bool {
                <Self as #me::pause::Pause>::is_paused()
            }
        }
    })
}

'''
'''--- macros/src/rbac.rs ---
use darling::FromDeriveInput;
use proc_macro2::TokenStream;
use quote::quote;
use syn::Expr;

#[derive(Debug, FromDeriveInput)]
#[darling(attributes(rbac), supports(struct_named))]
pub struct RbacMeta {
    pub storage_key: Option<Expr>,
    pub roles: Expr,

    // darling
    pub ident: syn::Ident,
    pub generics: syn::Generics,

    // crates
    #[darling(rename = "crate", default = "crate::default_crate_name")]
    pub me: syn::Path,
}

pub fn expand(meta: RbacMeta) -> Result<TokenStream, darling::Error> {
    let RbacMeta {
        storage_key,
        roles,

        ident,
        generics,

        me,
    } = meta;

    let (imp, ty, wher) = generics.split_for_impl();

    let root = storage_key.map(|storage_key| {
        quote! {
            fn root() -> #me::slot::Slot<()> {
                #me::slot::Slot::new(#storage_key)
            }
        }
    });

    Ok(quote! {
        impl #imp #me::rbac::RbacInternal for #ident #ty #wher {
            type Role = #roles;

            #root
        }
    })
}

'''
'''--- macros/src/rename.rs ---
use std::fmt::Display;

use darling::FromMeta;
use heck::{
    ToKebabCase, ToLowerCamelCase, ToShoutyKebabCase, ToShoutySnakeCase, ToSnakeCase, ToTitleCase,
    ToUpperCamelCase,
};

#[derive(Debug)]
#[allow(clippy::enum_variant_names)]
pub enum RenameStrategy {
    UpperCamelCase,
    LowerCamelCase,
    SnakeCase,
    KebabCase,
    ShoutySnakeCase,
    TitleCase,
    ShoutyKebabCase,
}

impl RenameStrategy {
    pub fn transform<T: AsRef<str>>(&self, s: T) -> String {
        let s = s.as_ref();
        match self {
            RenameStrategy::UpperCamelCase => s.to_upper_camel_case(),
            RenameStrategy::LowerCamelCase => s.to_lower_camel_case(),
            RenameStrategy::SnakeCase => s.to_snake_case(),
            RenameStrategy::KebabCase => s.to_kebab_case(),
            RenameStrategy::ShoutySnakeCase => s.to_shouty_snake_case(),
            RenameStrategy::TitleCase => s.to_title_case(),
            RenameStrategy::ShoutyKebabCase => s.to_shouty_kebab_case(),
        }
    }
}

impl FromMeta for RenameStrategy {
    fn from_string(value: &str) -> darling::Result<Self> {
        RenameStrategy::try_from(value)
            .map_err(|()| darling::Error::custom("Invalid rename strategy"))
    }
}

impl Display for RenameStrategy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                RenameStrategy::UpperCamelCase => "UpperCamelCase",
                RenameStrategy::LowerCamelCase => "lowerCamelCase",
                RenameStrategy::SnakeCase => "snake_case",
                RenameStrategy::KebabCase => "kebab-case",
                RenameStrategy::ShoutySnakeCase => "SHOUTY_SNAKE_CASE",
                RenameStrategy::TitleCase => "Title Case",
                RenameStrategy::ShoutyKebabCase => "SHOUTY-KEBAB-CASE",
            },
        )
    }
}

impl TryFrom<&str> for RenameStrategy {
    type Error = ();

    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "UpperCamelCase" => Ok(Self::UpperCamelCase),
            "lowerCamelCase" => Ok(Self::LowerCamelCase),
            "snake_case" => Ok(Self::SnakeCase),
            "kebab-case" => Ok(Self::KebabCase),
            "SHOUTY_SNAKE_CASE" | "SCREAMING_SNAKE_CASE" | "SHOUTING_SNAKE_CASE" => {
                Ok(Self::ShoutySnakeCase)
            }
            "Title Case" => Ok(Self::TitleCase),
            "SHOUTY-KEBAB-CASE" | "SCREAMING-KEBAB-CASE" | "SHOUTING-KEBAB-CASE" => {
                Ok(Self::ShoutyKebabCase)
            }
            _ => Err(()),
        }
    }
}

'''
'''--- macros/src/standard/event.rs ---
use darling::FromMeta;
use proc_macro2::TokenStream;
use quote::quote;
use syn::Item;

use crate::rename::RenameStrategy;

#[derive(Debug, FromMeta)]
pub struct EventAttributeMeta {
    pub standard: String,
    pub version: String,
    pub rename: Option<RenameStrategy>,
    pub rename_all: Option<RenameStrategy>,
    pub name: Option<String>,

    #[darling(rename = "crate", default = "crate::default_crate_name")]
    pub me: syn::Path,
    #[darling(default = "crate::default_macros")]
    pub macros: syn::Path,
    #[darling(default = "crate::default_serde")]
    pub serde: syn::Path,
}

pub fn event_attribute(
    attr: EventAttributeMeta,
    item: &Item,
) -> Result<TokenStream, darling::Error> {
    let EventAttributeMeta {
        standard,
        version,
        rename,
        rename_all,
        name,
        serde,
        me,
        macros,
    } = attr;

    let serde_untagged = matches!(item, Item::Enum(_)).then_some(quote! { #[serde(untagged)] });

    let default_rename = if rename.is_none() && rename_all.is_none() {
        Some(match item {
            Item::Enum(_) => quote! { rename_all = "snake_case", },
            Item::Struct(_) => quote! { rename = "snake_case", },
            _ => unreachable!(),
        })
    } else {
        None
    };

    let rename = rename.map(|r| {
        let r = r.to_string();
        quote! { rename = #r, }
    });
    let rename_all = rename_all.map(|r| {
        let r = r.to_string();
        quote! { rename_all = #r, }
    });

    let name = name.map(|n| quote! { name = #n, });

    let serde_str = quote! { #serde }.to_string();
    let me_str = quote! { #me }.to_string();

    Ok(quote::quote! {
        #[derive(#macros::Nep297, #serde::Serialize, #serde::Deserialize)]
        #[nep297(
            crate = #me_str,
            standard = #standard,
            version = #version,
            #rename #rename_all #default_rename #name
        )]
        #[serde(crate = #serde_str)]
        #serde_untagged
        #item
    })
}

'''
'''--- macros/src/standard/fungible_token.rs ---
use darling::FromDeriveInput;
use proc_macro2::TokenStream;
use quote::quote;
use syn::{Expr, Type};

use crate::unitify;

use super::{nep141, nep145, nep148};

#[derive(Debug, FromDeriveInput)]
#[darling(attributes(fungible_token), supports(struct_named))]
pub struct FungibleTokenMeta {
    // NEP-141 fields
    pub core_storage_key: Option<Expr>,
    pub all_hooks: Option<Type>,
    pub mint_hook: Option<Type>,
    pub transfer_hook: Option<Type>,
    pub burn_hook: Option<Type>,

    // NEP-148 fields
    pub metadata_storage_key: Option<Expr>,

    // NEP-145 fields
    pub storage_management_storage_key: Option<Expr>,
    pub force_unregister_hook: Option<Type>,

    // darling
    pub generics: syn::Generics,
    pub ident: syn::Ident,

    // crates
    #[darling(rename = "crate", default = "crate::default_crate_name")]
    pub me: syn::Path,
    #[darling(default = "crate::default_near_sdk")]
    pub near_sdk: syn::Path,
}

pub fn expand(meta: FungibleTokenMeta) -> Result<TokenStream, darling::Error> {
    let FungibleTokenMeta {
        core_storage_key,
        all_hooks,
        mint_hook,
        transfer_hook,
        burn_hook,

        metadata_storage_key,

        storage_management_storage_key,
        force_unregister_hook,

        generics,
        ident,

        me,
        near_sdk,
    } = meta;

    let all_hooks_or_unit = unitify(all_hooks.clone());
    let force_unregister_hook_or_unit = unitify(force_unregister_hook);

    let expand_nep141 = nep141::expand(nep141::Nep141Meta {
        storage_key: core_storage_key,
        all_hooks: Some(
            syn::parse_quote! { (#all_hooks_or_unit, #me::standard::nep145::hooks::Nep141StorageAccountingHook) },
        ),
        mint_hook,
        transfer_hook,
        burn_hook,

        generics: generics.clone(),
        ident: ident.clone(),

        me: me.clone(),
        near_sdk: near_sdk.clone(),
    });

    let expand_nep145 = nep145::expand(nep145::Nep145Meta {
        storage_key: storage_management_storage_key,
        all_hooks,
        force_unregister_hook: Some(
            syn::parse_quote! { (#force_unregister_hook_or_unit, #me::standard::nep141::hooks::BurnNep141OnForceUnregisterHook) },
        ),
        generics: generics.clone(),
        ident: ident.clone(),

        me: me.clone(),
        near_sdk: near_sdk.clone(),
    });

    let expand_nep148 = nep148::expand(nep148::Nep148Meta {
        storage_key: metadata_storage_key,
        generics,
        ident,

        me,
        near_sdk,
    });

    let mut e = darling::Error::accumulator();

    let nep141 = e.handle(expand_nep141);
    let nep145 = e.handle(expand_nep145);
    let nep148 = e.handle(expand_nep148);

    e.finish_with(quote! {
        #nep141
        #nep145
        #nep148
    })
}

'''
'''--- macros/src/standard/mod.rs ---
pub mod event;
pub mod fungible_token;
pub mod non_fungible_token;

pub mod nep141;
pub mod nep145;
pub mod nep148;
pub mod nep171;
pub mod nep177;
pub mod nep178;
pub mod nep181;
pub mod nep297;

'''
'''--- macros/src/standard/nep141.rs ---
use darling::FromDeriveInput;
use proc_macro2::TokenStream;
use quote::quote;
use syn::{Expr, Type};

#[derive(Debug, FromDeriveInput)]
#[darling(attributes(nep141), supports(struct_named))]
pub struct Nep141Meta {
    pub storage_key: Option<Expr>,
    pub all_hooks: Option<Type>,
    pub mint_hook: Option<Type>,
    pub transfer_hook: Option<Type>,
    pub burn_hook: Option<Type>,
    pub generics: syn::Generics,
    pub ident: syn::Ident,

    // crates
    #[darling(rename = "crate", default = "crate::default_crate_name")]
    pub me: syn::Path,
    #[darling(default = "crate::default_near_sdk")]
    pub near_sdk: syn::Path,
}

pub fn expand(meta: Nep141Meta) -> Result<TokenStream, darling::Error> {
    let Nep141Meta {
        storage_key,
        all_hooks,
        mint_hook,
        transfer_hook,
        burn_hook,
        generics,
        ident,

        me,
        near_sdk,
    } = meta;

    let (imp, ty, wher) = generics.split_for_impl();

    let root = storage_key.map(|storage_key| {
        quote! {
            fn root() -> #me::slot::Slot<()> {
                #me::slot::Slot::root(#storage_key)
            }
        }
    });

    let mint_hook = mint_hook.map_or_else(|| quote! { () }, |h| quote! { #h });
    let transfer_hook = transfer_hook.map_or_else(|| quote! { () }, |h| quote! { #h });
    let burn_hook = burn_hook.map_or_else(|| quote! { () }, |h| quote! { #h });

    let default_hook = all_hooks.map_or_else(|| quote! { () }, |h| quote! { #h });

    Ok(quote! {
        impl #imp #me::standard::nep141::Nep141ControllerInternal for #ident #ty #wher {
            type MintHook = (#mint_hook, #default_hook);
            type TransferHook = (#transfer_hook, #default_hook);
            type BurnHook = (#burn_hook, #default_hook);

            #root
        }

        #[#near_sdk::near]
        impl #imp #me::standard::nep141::Nep141 for #ident #ty #wher {
            #[payable]
            fn ft_transfer(
                &mut self,
                receiver_id: #near_sdk::AccountId,
                amount: #near_sdk::json_types::U128,
                memo: Option<String>,
            ) {
                use #me::standard::nep141::*;

                #near_sdk::assert_one_yocto();
                let sender_id = #near_sdk::env::predecessor_account_id();
                let amount: u128 = amount.into();

                let transfer = Nep141Transfer {
                    sender_id: sender_id.into(),
                    receiver_id: receiver_id.into(),
                    amount,
                    memo: memo.map(Into::into),
                    msg: None,
                    revert: false,
                };

                Nep141Controller::transfer(self, &transfer)
                    .unwrap_or_else(|e| #near_sdk::env::panic_str(&e.to_string()));
            }

            #[payable]
            fn ft_transfer_call(
                &mut self,
                receiver_id: #near_sdk::AccountId,
                amount: #near_sdk::json_types::U128,
                memo: Option<String>,
                msg: String,
            ) -> #near_sdk::Promise {
                use #me::standard::nep141::*;

                let prepaid_gas = #near_sdk::env::prepaid_gas();

                #near_sdk::require!(
                    prepaid_gas >= GAS_FOR_FT_TRANSFER_CALL,
                    MORE_GAS_FAIL_MESSAGE,
                );

                #near_sdk::assert_one_yocto();
                let sender_id = #near_sdk::env::predecessor_account_id();
                let amount: u128 = amount.into();

                let transfer = Nep141Transfer {
                    sender_id: sender_id.into(),
                    receiver_id: receiver_id.into(),
                    amount,
                    memo: memo.map(Into::into),
                    msg: Some(msg.clone().into()),
                    revert: false,
                };

                Nep141Controller::transfer(self, &transfer)
                    .unwrap_or_else(|e| #near_sdk::env::panic_str(&e.to_string()));

                let receiver_gas = prepaid_gas
                    .checked_sub(GAS_FOR_FT_TRANSFER_CALL)
                    .unwrap_or_else(|| #near_sdk::env::panic_str("Prepaid gas underflow."));

                // Initiating receiver's call and the callback
                ext_nep141_receiver::ext(transfer.receiver_id.clone().into())
                    .with_static_gas(receiver_gas)
                    .ft_on_transfer(transfer.sender_id.clone().into(), transfer.amount.into(), msg)
                    .then(
                        ext_nep141_resolver::ext(#near_sdk::env::current_account_id())
                            .with_static_gas(GAS_FOR_RESOLVE_TRANSFER)
                            .ft_resolve_transfer(
                                transfer.sender_id.clone().into(),
                                transfer.receiver_id.clone().into(),
                                transfer.amount.into(),
                            ),
                    )
            }

            fn ft_total_supply(&self) -> #near_sdk::json_types::U128 {
                #me::standard::nep141::Nep141Controller::total_supply(self).into()
            }

            fn ft_balance_of(&self, account_id: #near_sdk::AccountId) -> #near_sdk::json_types::U128 {
                #me::standard::nep141::Nep141Controller::balance_of(self, &account_id).into()
            }
        }

        #[#near_sdk::near]
        impl #imp #me::standard::nep141::Nep141Resolver for #ident #ty #wher {
            #[private]
            fn ft_resolve_transfer(
                &mut self,
                sender_id: #near_sdk::AccountId,
                receiver_id: #near_sdk::AccountId,
                amount: #near_sdk::json_types::U128,
            ) -> #near_sdk::json_types::U128 {
                use #near_sdk::{env, PromiseResult, serde_json, json_types::U128};
                use #me::standard::nep141::*;

                let amount = amount.0;

                let ft_on_transfer_promise_result = env::promise_result(0);

                let unused_amount = match ft_on_transfer_promise_result {
                    PromiseResult::Successful(value) => {
                        if let Ok(U128(unused_amount)) = serde_json::from_slice::<U128>(&value) {
                            std::cmp::min(amount, unused_amount)
                        } else {
                            amount
                        }
                    }
                    PromiseResult::Failed => amount,
                    _ => env::abort(),
                };

                let refunded_amount = if unused_amount > 0 {
                    let receiver_balance = Nep141Controller::balance_of(self, &receiver_id);
                    if receiver_balance > 0 {
                        let refund_amount = std::cmp::min(receiver_balance, unused_amount);
                        let transfer = Nep141Transfer {
                            sender_id: receiver_id.into(),
                            receiver_id: sender_id.into(),
                            amount: refund_amount,
                            memo: None,
                            msg: None,
                            revert: true,
                        };

                        Nep141Controller::transfer(self, &transfer)
                            .unwrap_or_else(|e| env::panic_str(&e.to_string()));

                        refund_amount
                    } else {
                        0
                    }
                } else {
                    0
                };

                // Used amount
                U128(amount - refunded_amount)
            }
        }
    })
}

'''
'''--- macros/src/standard/nep145.rs ---
use darling::FromDeriveInput;
use proc_macro2::TokenStream;
use quote::quote;
use syn::{Expr, Type};

#[derive(Debug, FromDeriveInput)]
#[darling(attributes(nep145), supports(struct_named))]
pub struct Nep145Meta {
    pub storage_key: Option<Expr>,
    pub all_hooks: Option<Type>,
    pub force_unregister_hook: Option<Type>,
    pub generics: syn::Generics,
    pub ident: syn::Ident,

    // crates
    #[darling(rename = "crate", default = "crate::default_crate_name")]
    pub me: syn::Path,
    #[darling(default = "crate::default_near_sdk")]
    pub near_sdk: syn::Path,
}

pub fn expand(meta: Nep145Meta) -> Result<TokenStream, darling::Error> {
    let Nep145Meta {
        storage_key,
        all_hooks,
        force_unregister_hook,
        generics,
        ident,

        me,
        near_sdk,
    } = meta;

    let (imp, ty, wher) = generics.split_for_impl();

    let root = storage_key.map(|storage_key| {
        quote! {
            fn root() -> #me::slot::Slot<()> {
                #me::slot::Slot::root(#storage_key)
            }
        }
    });

    let all_hooks = all_hooks.map_or_else(|| quote! { () }, |h| quote! { #h });
    let force_unregister_hook =
        force_unregister_hook.map_or_else(|| quote! { () }, |h| quote! { #h });

    Ok(quote! {
        impl #imp #me::standard::nep145::Nep145ControllerInternal for #ident #ty #wher {
            type ForceUnregisterHook = (#force_unregister_hook, #all_hooks);

            #root
        }

        #[#near_sdk::near]
        impl #imp #me::standard::nep145::Nep145 for #ident #ty #wher {
            #[payable]
            fn storage_deposit(
                &mut self,
                account_id: Option<#near_sdk::AccountId>,
                registration_only: Option<bool>,
            ) -> #me::standard::nep145::StorageBalance {
                use #me::standard::nep145::*;
                use #near_sdk::{env, Promise};

                let bounds = Nep145Controller::get_storage_balance_bounds(self);

                let attached = env::attached_deposit();
                let amount = bounds.bound(attached, registration_only.unwrap_or(false));
                let refund = attached.checked_sub(amount).unwrap_or_else(|| {
                    env::panic_str(&format!(
                        "Attached deposit {} is less than required {}",
                        attached, amount,
                    ))
                });
                let predecessor = env::predecessor_account_id();

                let storage_balance = Nep145Controller::deposit_to_storage_account(
                    self,
                    &account_id.unwrap_or_else(|| predecessor.clone()),
                    amount,
                )
                .unwrap_or_else(|e| env::panic_str(&format!("Storage deposit error: {}", e)));

                if !refund.is_zero() {
                    Promise::new(predecessor).transfer(refund);
                }

                storage_balance
            }

            #[payable]
            fn storage_withdraw(&mut self, amount: Option<#near_sdk::NearToken>) -> #me::standard::nep145::StorageBalance {
                use #me::standard::nep145::*;
                use #near_sdk::{env, Promise};

                near_sdk::assert_one_yocto();

                let predecessor = env::predecessor_account_id();

                let balance = Nep145Controller::get_storage_balance(self, &predecessor)
                    .unwrap_or_else(|e| env::panic_str(&e.to_string()));

                let amount = amount.unwrap_or(balance.available);

                if amount.is_zero() {
                    return balance;
                }

                let new_balance = Nep145Controller::withdraw_from_storage_account(self, &predecessor, amount)
                    .unwrap_or_else(|e| env::panic_str(&format!("Storage withdraw error: {}", e)));

                Promise::new(predecessor).transfer(amount);

                new_balance
            }

            fn storage_unregister(&mut self, force: Option<bool>) -> bool {
                use #me::standard::nep145::*;
                use #near_sdk::{env, Promise};

                near_sdk::assert_one_yocto();

                let predecessor = env::predecessor_account_id();

                let refund = if force.unwrap_or(false) {
                    match Nep145Controller::force_unregister_storage_account(self, &predecessor) {
                        Ok(refund) => refund,
                        Err(error::StorageForceUnregisterError::AccountNotRegistered(_)) => return false,
                    }
                } else {
                    match Nep145Controller::unregister_storage_account(self, &predecessor) {
                        Ok(refund) => refund,
                        Err(error::StorageUnregisterError::UnregisterWithLockedBalance(e)) => {
                            env::panic_str(&format!(
                                "Attempt to unregister from storage with locked balance: {}", e
                            ));
                        }
                        Err(error::StorageUnregisterError::AccountNotRegistered(_)) => return false,
                    }
                };

                Promise::new(predecessor).transfer(refund);
                true
            }

            fn storage_balance_of(&self, account_id: #near_sdk::AccountId) -> Option<#me::standard::nep145::StorageBalance> {
                #me::standard::nep145::Nep145Controller::get_storage_balance(self, &account_id).ok()
            }

            fn storage_balance_bounds(&self) -> #me::standard::nep145::StorageBalanceBounds {
                #me::standard::nep145::Nep145Controller::get_storage_balance_bounds(self)
            }
        }
    })
}

'''
'''--- macros/src/standard/nep148.rs ---
use darling::FromDeriveInput;
use proc_macro2::TokenStream;
use quote::quote;
use syn::Expr;

#[derive(Debug, FromDeriveInput)]
#[darling(attributes(nep148), supports(struct_named))]
pub struct Nep148Meta {
    pub storage_key: Option<Expr>,
    pub generics: syn::Generics,
    pub ident: syn::Ident,

    // crates
    #[darling(rename = "crate", default = "crate::default_crate_name")]
    pub me: syn::Path,
    #[darling(default = "crate::default_near_sdk")]
    pub near_sdk: syn::Path,
}

pub fn expand(meta: Nep148Meta) -> Result<TokenStream, darling::Error> {
    let Nep148Meta {
        storage_key,
        generics,
        ident,

        me,
        near_sdk,
    } = meta;

    let root = storage_key.map(|storage_key| {
        quote! {
            fn root() -> #me::slot::Slot<()> {
                #me::slot::Slot::root(#storage_key)
            }
        }
    });

    let (imp, ty, wher) = generics.split_for_impl();

    Ok(quote! {
        impl #imp #me::standard::nep148::Nep148ControllerInternal for #ident #ty #wher {
            #root
        }

        #[#near_sdk::near]
        impl #imp #me::standard::nep148::Nep148 for #ident #ty #wher {
            fn ft_metadata(&self) -> #me::standard::nep148::ContractMetadata {
                #me::standard::nep148::Nep148Controller::get_metadata(self)
            }
        }
    })
}

'''
'''--- macros/src/standard/nep171.rs ---
use darling::FromDeriveInput;
use proc_macro2::TokenStream;
use quote::quote;
use syn::{parse_quote, Expr, Type};

use crate::unitify;

#[derive(Debug, FromDeriveInput)]
#[darling(attributes(nep171), supports(struct_named))]
pub struct Nep171Meta {
    pub storage_key: Option<Expr>,
    pub all_hooks: Option<Type>,
    pub mint_hook: Option<Type>,
    pub transfer_hook: Option<Type>,
    pub burn_hook: Option<Type>,
    pub check_external_transfer: Option<Type>,
    pub token_data: Option<Type>,

    pub generics: syn::Generics,
    pub ident: syn::Ident,

    // crates
    #[darling(rename = "crate", default = "crate::default_crate_name")]
    pub me: syn::Path,
    #[darling(default = "crate::default_near_sdk")]
    pub near_sdk: syn::Path,
}

pub fn expand(meta: Nep171Meta) -> Result<TokenStream, darling::Error> {
    let Nep171Meta {
        storage_key,
        all_hooks,
        mint_hook,
        transfer_hook,
        burn_hook,
        check_external_transfer,
        token_data,

        generics,
        ident,

        me,
        near_sdk,
    } = meta;

    let (imp, ty, wher) = generics.split_for_impl();

    let token_data = unitify(token_data);

    let check_external_transfer = check_external_transfer.unwrap_or_else(|| {
        parse_quote! { #me::standard::nep171::DefaultCheckExternalTransfer }
    });

    let root = storage_key.map(|storage_key| {
        quote! {
            fn root() -> #me::slot::Slot<()> {
                #me::slot::Slot::root(#storage_key)
            }
        }
    });

    let all_hooks = unitify(all_hooks);
    let mint_hook = unitify(mint_hook);
    let transfer_hook = unitify(transfer_hook);
    let burn_hook = unitify(burn_hook);

    Ok(quote! {
        impl #imp #me::standard::nep171::Nep171ControllerInternal for #ident #ty #wher {
            type MintHook = (#mint_hook, #all_hooks);
            type TransferHook = (#transfer_hook, #all_hooks);
            type BurnHook = (#burn_hook, #all_hooks);

            type CheckExternalTransfer = #check_external_transfer;
            type LoadTokenMetadata = #token_data;

            #root
        }

        #[#near_sdk::near]
        impl #imp #me::standard::nep171::Nep171Resolver for #ident #ty #wher {
            #[private]
            fn nft_resolve_transfer(
                &mut self,
                previous_owner_id: #near_sdk::AccountId,
                receiver_id: #near_sdk::AccountId,
                token_id: #me::standard::nep171::TokenId,
                approved_account_ids: Option<std::collections::HashMap<#near_sdk::AccountId, u64>>,
            ) -> bool {
                use #me::standard::nep171::*;

                let _ = approved_account_ids; // #[near] cares about parameter names

                #near_sdk::require!(
                    #near_sdk::env::promise_results_count() == 1,
                    "Requires exactly one promise result.",
                );

                let should_revert =
                    if let #near_sdk::PromiseResult::Successful(value) = #near_sdk::env::promise_result(0) {
                        let value = #near_sdk::serde_json::from_slice::<bool>(&value).unwrap_or(true);
                        value
                    } else {
                        true
                    };

                if should_revert {
                    let transfer = action::Nep171Transfer {
                        token_id,
                        authorization: Nep171TransferAuthorization::Owner,
                        sender_id: receiver_id.into(),
                        receiver_id: previous_owner_id.into(),
                        memo: None,
                        msg: None,
                        revert: true,
                    };

                    <Self as Nep171Controller>::external_transfer(self, &transfer)
                        .is_err()
                } else {
                    true
                }
            }
        }

        #[#near_sdk::near]
        impl #imp #me::standard::nep171::Nep171 for #ident #ty #wher {
            #[payable]
            fn nft_transfer(
                &mut self,
                receiver_id: #near_sdk::AccountId,
                token_id: #me::standard::nep171::TokenId,
                approval_id: Option<u32>,
                memo: Option<String>,
            ) {
                use #me::standard::nep171::*;

                #near_sdk::assert_one_yocto();

                let sender_id = #near_sdk::env::predecessor_account_id();

                let transfer = action::Nep171Transfer {
                    token_id,
                    authorization: approval_id.map(Nep171TransferAuthorization::ApprovalId).unwrap_or(Nep171TransferAuthorization::Owner),
                    sender_id: sender_id.into(),
                    receiver_id: receiver_id.into(),
                    memo: memo.map(Into::into),
                    msg: None,
                    revert: false,
                };

                <Self as Nep171Controller>::external_transfer(self, &transfer)
                    .unwrap_or_else(|e| #near_sdk::env::panic_str(&e.to_string()));
            }

            #[payable]
            fn nft_transfer_call(
                &mut self,
                receiver_id: #near_sdk::AccountId,
                token_id: #me::standard::nep171::TokenId,
                approval_id: Option<u32>,
                memo: Option<String>,
                msg: String,
            ) -> #near_sdk::PromiseOrValue<bool> {
                use #me::standard::nep171::*;

                #near_sdk::assert_one_yocto();

                #near_sdk::require!(
                    #near_sdk::env::prepaid_gas() >= GAS_FOR_NFT_TRANSFER_CALL,
                    INSUFFICIENT_GAS_MESSAGE,
                );

                let sender_id = #near_sdk::env::predecessor_account_id();

                let transfer = action::Nep171Transfer {
                    token_id: token_id.clone(),
                    authorization: approval_id.map(Nep171TransferAuthorization::ApprovalId).unwrap_or(Nep171TransferAuthorization::Owner),
                    sender_id: sender_id.clone().into(),
                    receiver_id: receiver_id.clone().into(),
                    memo: memo.map(Into::into),
                    msg: Some(msg.clone().into()),
                    revert: false,
                };

                <Self as Nep171Controller>::external_transfer(self, &transfer)
                    .unwrap_or_else(|e| #near_sdk::env::panic_str(&e.to_string()));

                ext_nep171_receiver::ext(receiver_id.clone().into())
                    .with_static_gas(#near_sdk::env::prepaid_gas().saturating_sub(GAS_FOR_NFT_TRANSFER_CALL))
                    .nft_on_transfer(
                        sender_id.clone().into(),
                        sender_id.clone().into(),
                        token_id.clone(),
                        msg.clone(),
                    )
                    .then(
                        ext_nep171_resolver::ext(#near_sdk::env::current_account_id())
                            .with_static_gas(GAS_FOR_RESOLVE_TRANSFER)
                            .nft_resolve_transfer(
                                sender_id.clone().into(),
                                receiver_id.clone().into(),
                                token_id.clone(),
                                None,
                            ),
                    )
                    .into()
            }

            fn nft_token(
                &self,
                token_id: #me::standard::nep171::TokenId,
            ) -> Option<#me::standard::nep171::Token> {
                <Self as #me::standard::nep171::Nep171Controller>::load_token(self, &token_id)
            }
        }
    })
}

'''
'''--- macros/src/standard/nep177.rs ---
use darling::FromDeriveInput;
use proc_macro2::TokenStream;
use quote::quote;
use syn::Expr;

#[derive(Debug, FromDeriveInput)]
#[darling(attributes(nep177), supports(struct_named))]
pub struct Nep177Meta {
    pub storage_key: Option<Expr>,

    pub generics: syn::Generics,
    pub ident: syn::Ident,

    // crates
    #[darling(rename = "crate", default = "crate::default_crate_name")]
    pub me: syn::Path,
    #[darling(default = "crate::default_near_sdk")]
    pub near_sdk: syn::Path,
}

pub fn expand(meta: Nep177Meta) -> Result<TokenStream, darling::Error> {
    let Nep177Meta {
        storage_key,

        generics,
        ident,

        me,
        near_sdk,
    } = meta;

    let (imp, ty, wher) = generics.split_for_impl();

    let root = storage_key.map(|storage_key| {
        quote! {
            fn root() -> #me::slot::Slot<()> {
                #me::slot::Slot::root(#storage_key)
            }
        }
    });

    Ok(quote! {
        impl #imp #me::standard::nep177::Nep177ControllerInternal for #ident #ty #wher {
            #root
        }

        #[#near_sdk::near]
        impl #imp #me::standard::nep177::Nep177 for #ident #ty #wher {
            fn nft_metadata(&self) -> #me::standard::nep177::ContractMetadata {
                #me::standard::nep177::Nep177Controller::contract_metadata(self)
            }
        }
    })
}

'''
'''--- macros/src/standard/nep178.rs ---
use darling::FromDeriveInput;
use proc_macro2::TokenStream;
use quote::quote;
use syn::{Expr, Type};

use crate::unitify;

#[derive(Debug, FromDeriveInput)]
#[darling(attributes(nep178), supports(struct_named))]
pub struct Nep178Meta {
    pub storage_key: Option<Expr>,
    pub all_hooks: Option<Type>,
    pub approve_hook: Option<Type>,
    pub revoke_hook: Option<Type>,
    pub revoke_all_hook: Option<Type>,

    pub generics: syn::Generics,
    pub ident: syn::Ident,

    // crates
    #[darling(rename = "crate", default = "crate::default_crate_name")]
    pub me: syn::Path,
    #[darling(default = "crate::default_near_sdk")]
    pub near_sdk: syn::Path,
}

pub fn expand(meta: Nep178Meta) -> Result<TokenStream, darling::Error> {
    let Nep178Meta {
        storage_key,
        all_hooks,
        approve_hook,
        revoke_hook,
        revoke_all_hook,

        generics,
        ident,

        me,
        near_sdk,
    } = meta;

    let (imp, ty, wher) = generics.split_for_impl();

    let root = storage_key.map(|storage_key| {
        quote! {
            fn root() -> #me::slot::Slot<()> {
                #me::slot::Slot::root(#storage_key)
            }
        }
    });

    let all_hooks = unitify(all_hooks);
    let approve_hook = unitify(approve_hook);
    let revoke_hook = unitify(revoke_hook);
    let revoke_all_hook = unitify(revoke_all_hook);

    Ok(quote! {
        impl #imp #me::standard::nep178::Nep178ControllerInternal for #ident #ty #wher {
            type ApproveHook = (#approve_hook, #all_hooks);
            type RevokeHook = (#revoke_hook, #all_hooks);
            type RevokeAllHook = (#revoke_all_hook, #all_hooks);

            #root
        }

        #[#near_sdk::near]
        impl #imp #me::standard::nep178::Nep178 for #ident #ty #wher {
            #[payable]
            fn nft_approve(
                &mut self,
                token_id: #me::standard::nep171::TokenId,
                account_id: #near_sdk::AccountId,
                msg: Option<String>,
            ) -> #near_sdk::PromiseOrValue<()> {
                use #me::standard::nep178::*;

                #me::utils::assert_nonzero_deposit();

                let predecessor = #near_sdk::env::predecessor_account_id();

                let action = action::Nep178Approve {
                    token_id: token_id.clone(),
                    current_owner_id: predecessor.clone().into(),
                    account_id: account_id.clone().into(),
                };

                let approval_id = Nep178Controller::approve(self, &action)
                    .unwrap_or_else(|e| #near_sdk::env::panic_str(&e.to_string()));

                msg.map_or(#near_sdk::PromiseOrValue::Value(()), |msg| {
                    ext_nep178_receiver::ext(account_id)
                        .nft_on_approve(token_id, predecessor, approval_id, msg)
                        .into()
                })
            }

            #[payable]
            fn nft_revoke(
                &mut self,
                token_id: #me::standard::nep171::TokenId,
                account_id: #near_sdk::AccountId,
            ) {
                use #me::standard::nep178::*;

                #near_sdk::assert_one_yocto();

                let predecessor = #near_sdk::env::predecessor_account_id();

                let action = action::Nep178Revoke {
                    token_id,
                    current_owner_id: predecessor.into(),
                    account_id: account_id.into(),
                };

                Nep178Controller::revoke(self, &action)
                    .unwrap_or_else(|e| #near_sdk::env::panic_str(&e.to_string()));
            }

            #[payable]
            fn nft_revoke_all(&mut self, token_id: #me::standard::nep171::TokenId) {
                use #me::standard::nep178::*;

                #near_sdk::assert_one_yocto();

                let predecessor = #near_sdk::env::predecessor_account_id();

                let action = action::Nep178RevokeAll {
                    token_id,
                    current_owner_id: predecessor.into(),
                };

                Nep178Controller::revoke_all(self, &action)
                    .unwrap_or_else(|e| #near_sdk::env::panic_str(&e.to_string()));
            }

            fn nft_is_approved(
                &self,
                token_id: #me::standard::nep171::TokenId,
                approved_account_id: #near_sdk::AccountId,
                approval_id: Option<#me::standard::nep178::ApprovalId>,
            ) -> bool {
                match (
                    #me::standard::nep178::Nep178Controller::get_approval_id_for(
                        self,
                        &token_id,
                        &approved_account_id,
                    ),
                    approval_id,
                ) {
                    (Some(saved_approval_id), Some(provided_approval_id)) => saved_approval_id == provided_approval_id,
                    (Some(_), _) => true,
                    _ => false,
                }
            }
        }
    })
}

'''
'''--- macros/src/standard/nep181.rs ---
use darling::FromDeriveInput;
use proc_macro2::TokenStream;
use quote::quote;
use syn::Expr;

#[derive(Debug, FromDeriveInput)]
#[darling(attributes(nep181), supports(struct_named))]
pub struct Nep181Meta {
    pub storage_key: Option<Expr>,

    pub generics: syn::Generics,
    pub ident: syn::Ident,

    // crates
    #[darling(rename = "crate", default = "crate::default_crate_name")]
    pub me: syn::Path,
    #[darling(default = "crate::default_near_sdk")]
    pub near_sdk: syn::Path,
}

pub fn expand(meta: Nep181Meta) -> Result<TokenStream, darling::Error> {
    let Nep181Meta {
        storage_key,

        generics,
        ident,

        me,
        near_sdk,
    } = meta;

    let (imp, ty, wher) = generics.split_for_impl();

    let root = storage_key.map(|storage_key| {
        quote! {
            fn root() -> #me::slot::Slot<()> {
                #me::slot::Slot::root(#storage_key)
            }
        }
    });

    Ok(quote! {
        impl #imp #me::standard::nep181::Nep181ControllerInternal for #ident #ty #wher {
            #root
        }

        #[#near_sdk::near]
        impl #imp #me::standard::nep181::Nep181 for #ident #ty #wher {
            fn nft_total_supply(&self) -> #near_sdk::json_types::U128 {
                #me::standard::nep181::Nep181Controller::total_enumerated_tokens(self)
                    .into()
            }

            fn nft_tokens(
                &self,
                from_index: Option<#near_sdk::json_types::U128>,
                limit: Option<u32>,
            ) -> Vec<Token> {
                use #me::standard::{
                    nep171::Nep171Controller, nep181::Nep181Controller,
                };

                Nep181Controller::with_tokens(self, |tokens| {
                    let from_index = from_index.map_or(0, |i| i.0 as usize);
                    let it = tokens
                        .iter()
                        .skip(from_index)
                        .map(|token_id| Nep171Controller::load_token(self, &token_id).unwrap_or_else(|| {
                            #near_sdk::env::panic_str(&format!("Inconsistent state: Token `{}` is in the enumeration set but its metadata could not be loaded.", token_id))
                        }));

                    if let Some(limit) = limit {
                        it.take(limit as usize).collect()
                    } else {
                        it.collect()
                    }
                })
            }

            fn nft_supply_for_owner(&self, account_id: #near_sdk::AccountId) -> #near_sdk::json_types::U128 {
                #me::standard::nep181::Nep181Controller::with_tokens_for_owner(
                    self,
                    &account_id,
                    |tokens| (tokens.len() as u128).into(),
                )
            }

            fn nft_tokens_for_owner(
                &self,
                account_id: #near_sdk::AccountId,
                from_index: Option<#near_sdk::json_types::U128>,
                limit: Option<u32>,
            ) -> Vec<Token> {
                use #me::standard::{
                    nep171::Nep171Controller, nep181::Nep181Controller,
                };

                Nep181Controller::with_tokens_for_owner(self, &account_id, |tokens| {
                    let from_index = from_index.map_or(0, |i| i.0 as usize);
                    let it = tokens
                        .iter()
                        .skip(from_index)
                        .map(|token_id| Nep171Controller::load_token(self, &token_id).unwrap_or_else(|| {
                            #near_sdk::env::panic_str(&format!("Inconsistent state: Token `{}` is in the enumeration set but its metadata could not be loaded.", token_id))
                        }));

                    if let Some(limit) = limit {
                        it.take(limit as usize).collect()
                    } else {
                        it.collect()
                    }
                })
            }
        }
    })
}

'''
'''--- macros/src/standard/nep297.rs ---
use std::collections::HashSet;

use darling::{FromDeriveInput, FromVariant};
use proc_macro2::TokenStream;
use quote::quote;

use crate::rename::RenameStrategy;

#[derive(Debug, FromDeriveInput)]
#[darling(
    attributes(nep297),
    supports(struct_any, enum_any),
    and_then = "Self::check"
)]
pub struct Nep297Meta {
    pub standard: String,
    pub version: String,
    pub name: Option<String>,
    pub rename: Option<RenameStrategy>,
    pub rename_all: Option<RenameStrategy>,
    pub ident: syn::Ident,
    pub generics: syn::Generics,
    pub data: darling::ast::Data<EventVariantReceiver, ()>,

    // crates
    #[darling(rename = "crate", default = "crate::default_crate_name")]
    pub me: syn::Path,
}

macro_rules! disallow_field {
    ($self: ident, $field: ident, $e: ident, $shape: expr) => {
        if $self.$field.is_some() {
            $e.push(darling::Error::custom(format!(
                "The field `{}` is not allowed on {}s",
                stringify!($field),
                $shape,
            )));
        }
    };
}

impl Nep297Meta {
    pub fn check(self) -> darling::Result<Self> {
        let mut e = darling::Error::accumulator();

        match &self.data {
            darling::ast::Data::Enum(_) => {
                disallow_field!(self, name, e, "enum");
                disallow_field!(self, rename, e, "enum");
            }
            darling::ast::Data::Struct(_) => {
                disallow_field!(self, rename_all, e, "struct");
            }
        }

        e.finish_with(self)
    }
}

#[derive(Debug, FromVariant)]
#[darling(attributes(nep297))]
pub struct EventVariantReceiver {
    pub ident: syn::Ident,
    pub fields: darling::ast::Fields<()>,
    pub rename: Option<RenameStrategy>,
    pub name: Option<String>,
}

pub fn expand(meta: Nep297Meta) -> Result<TokenStream, darling::Error> {
    let Nep297Meta {
        standard,
        version,
        name,
        rename,
        rename_all,
        ident,
        generics,
        data,
        me,
    } = meta;

    let (imp, ty, wher) = generics.split_for_impl();

    // Variant attributes
    let (event, used_names) = match data {
        darling::ast::Data::Struct(_) => {
            let transformed_name = if let Some(name) = name {
                name
            } else if let Some(rename) = rename {
                rename.transform(ident.to_string())
            } else {
                ident.to_string()
            };

            (quote! { #transformed_name }, vec![transformed_name])
        }
        darling::ast::Data::Enum(variants) => {
            let (arms, used_names) = variants
                .into_iter()
                .map(|variant| {
                    let i = &variant.ident;

                    // This could be a function chain, but I found it to be unreadable
                    let transformed_name = if let Some(name) = variant.name {
                        name
                    } else if let Some(rename) = variant.rename.as_ref().or(rename_all.as_ref()) {
                        rename.transform(i.to_string())
                    } else {
                        i.to_string()
                    };

                    (
                        match variant.fields.style {
                            darling::ast::Style::Tuple => {
                                quote! { Self :: #i ( .. ) => #transformed_name , }
                            }
                            darling::ast::Style::Struct => {
                                quote! { Self :: #i { .. } => #transformed_name , }
                            }
                            darling::ast::Style::Unit => {
                                quote! { Self :: #i  => #transformed_name , }
                            }
                        },
                        transformed_name,
                    )
                })
                .unzip::<_, _, Vec<_>, Vec<_>>();

            (
                quote! {
                    match self {
                        #(#arms)*
                    }
                },
                used_names,
            )
        }
    };

    let mut e = darling::Error::accumulator();

    let mut no_duplicate_names = HashSet::<&String>::new();
    for used_name in &used_names {
        let fresh_insertion = no_duplicate_names.insert(used_name);
        if !fresh_insertion {
            e.push(darling::Error::custom(format!(
                "Event name collision: `{used_name}`",
            )));
        }
    }

    e.finish_with(quote! {
        impl #imp #me::standard::nep297::ToEventLog for #ident #ty #wher {
            type Data = #ident #ty;

            fn to_event_log<'__el>(&'__el self) -> #me::standard::nep297::EventLog<&'__el Self::Data> {
                #me::standard::nep297::EventLog {
                    standard: #standard.into(),
                    version: #version.into(),
                    event: #event.into(),
                    data: self,
                }
            }
        }
    })
}

#[cfg(test)]
mod tests {
    use darling::FromDeriveInput;

    use super::Nep297Meta;

    #[test]
    #[should_panic = "Event name collision: `first`"]
    fn disallow_duplicate_names() {
        let ast = syn::parse_str(
            r#"
            #[derive(Nep297)]
            #[nep297(standard = "x-name-collision", version = "1.0.0")]
            enum NameCollision {
                #[nep297(name = "first")]
                First,
                #[nep297(name = "first")]
                Second,
            }
        "#,
        )
        .unwrap();

        let meta = Nep297Meta::from_derive_input(&ast).unwrap();
        super::expand(meta).unwrap();
    }
}

'''
'''--- macros/src/standard/non_fungible_token.rs ---
use darling::FromDeriveInput;
use proc_macro2::TokenStream;
use quote::quote;
use syn::{parse_quote, Expr, Type};

use crate::unitify;

use super::{nep145, nep171, nep177, nep178, nep181};

#[derive(Debug, FromDeriveInput)]
#[darling(attributes(non_fungible_token), supports(struct_named))]
pub struct NonFungibleTokenMeta {
    pub all_hooks: Option<Type>,

    // NEP-145 fields
    pub storage_management_storage_key: Option<Expr>,
    pub force_unregister_hook: Option<Type>,

    // NEP-171 fields
    pub core_storage_key: Option<Expr>,
    pub mint_hook: Option<Type>,
    pub transfer_hook: Option<Type>,
    pub burn_hook: Option<Type>,
    pub token_data: Option<Type>,
    pub check_external_transfer: Option<Type>,

    // NEP-177 fields
    pub metadata_storage_key: Option<Expr>,

    // NEP-178 fields
    pub approval_storage_key: Option<Expr>,
    pub approve_hook: Option<Type>,
    pub revoke_hook: Option<Type>,
    pub revoke_all_hook: Option<Type>,

    // NEP-181 fields
    pub enumeration_storage_key: Option<Expr>,

    // darling
    pub generics: syn::Generics,
    pub ident: syn::Ident,

    // crates
    #[darling(rename = "crate", default = "crate::default_crate_name")]
    pub me: syn::Path,
    #[darling(default = "crate::default_near_sdk")]
    pub near_sdk: syn::Path,
}

pub fn expand(meta: NonFungibleTokenMeta) -> Result<TokenStream, darling::Error> {
    let NonFungibleTokenMeta {
        all_hooks,

        storage_management_storage_key,
        force_unregister_hook,

        core_storage_key,
        mint_hook,
        transfer_hook,
        burn_hook,
        token_data,
        check_external_transfer,

        metadata_storage_key,

        approval_storage_key,
        approve_hook,
        revoke_hook,
        revoke_all_hook,

        enumeration_storage_key,

        generics,
        ident,

        me,
        near_sdk,
    } = meta;

    let all_hooks_inner = unitify(all_hooks.clone());
    let force_unregister_hook = unitify(force_unregister_hook);

    let expand_nep145 = nep145::expand(nep145::Nep145Meta {
        storage_key: storage_management_storage_key,
        all_hooks: Some(all_hooks_inner.clone()),
        force_unregister_hook: Some(
            parse_quote! { (#force_unregister_hook, #me::standard::nep171::hooks::BurnNep171OnForceUnregisterHook) },
        ),
        generics: generics.clone(),
        ident: ident.clone(),
        me: me.clone(),
        near_sdk: near_sdk.clone(),
    });

    let token_data = unitify(token_data);

    let expand_nep171 = nep171::expand(nep171::Nep171Meta {
        storage_key: core_storage_key,
        all_hooks: Some(parse_quote! { (
            #all_hooks_inner,
            (
                #me::standard::nep145::hooks::Nep171StorageAccountingHook,
                (
                    #me::standard::nep178::TokenApprovals,
                    #me::standard::nep181::TokenEnumeration,
                ),
            ),
        ) }),
        mint_hook,
        transfer_hook,
        burn_hook,
        check_external_transfer: Some(check_external_transfer.unwrap_or_else(|| {
            parse_quote! { #me::standard::nep178::TokenApprovals }
        })),
        token_data: Some(syn::parse_quote! { (
            #token_data,
            (#me::standard::nep177::TokenMetadata, #me::standard::nep178::TokenApprovals),
        ) }),

        generics: generics.clone(),
        ident: ident.clone(),

        me: me.clone(),
        near_sdk: near_sdk.clone(),
    });

    let expand_nep177 = nep177::expand(nep177::Nep177Meta {
        storage_key: metadata_storage_key,

        generics: generics.clone(),
        ident: ident.clone(),

        me: me.clone(),
        near_sdk: near_sdk.clone(),
    });

    let expand_nep178 = nep178::expand(nep178::Nep178Meta {
        storage_key: approval_storage_key,
        all_hooks,
        approve_hook,
        revoke_hook,
        revoke_all_hook,

        generics: generics.clone(),
        ident: ident.clone(),
        me: me.clone(),
        near_sdk: near_sdk.clone(),
    });

    let expand_nep181 = nep181::expand(nep181::Nep181Meta {
        storage_key: enumeration_storage_key,
        generics,
        ident,
        me,
        near_sdk,
    });

    let mut e = darling::Error::accumulator();

    let nep145 = e.handle(expand_nep145);
    let nep171 = e.handle(expand_nep171);
    let nep177 = e.handle(expand_nep177);
    let nep178 = e.handle(expand_nep178);
    let nep181 = e.handle(expand_nep181);

    e.finish_with(quote! {
        #nep145
        #nep171
        #nep177
        #nep178
        #nep181
    })
}

'''
'''--- macros/src/upgrade.rs ---
use darling::{FromDeriveInput, FromMeta};
use proc_macro2::TokenStream;
use quote::quote;
use syn::Expr;

#[derive(Debug, Clone)]
pub enum HookBody {
    Empty,
    Custom,
    Owner,
    Role(Box<syn::Expr>),
}

impl FromMeta for HookBody {
    fn from_none() -> Option<Self> {
        Some(Self::Custom)
    }

    fn from_string(value: &str) -> darling::Result<Self> {
        if value == "empty" {
            Ok(HookBody::Empty)
        } else if value == "owner" {
            Ok(HookBody::Owner)
        } else if let Some(b) = value
            .strip_prefix("role(")
            .and_then(|s| s.strip_suffix(')'))
            .and_then(|s| syn::parse_str::<Expr>(s).ok())
            .map(|e| HookBody::Role(Box::new(e)))
        {
            Ok(b)
        } else {
            Err(darling::Error::custom(format!(
                r#"Invalid value "{value}", expected "empty", "owner", or "role(...)""#,
            )))
        }
    }
}

#[derive(Debug, Clone)]
pub enum Serializer {
    Borsh,
    JsonBase64,
}

impl FromMeta for Serializer {
    fn from_string(value: &str) -> darling::Result<Self> {
        match value {
            "borsh" => Ok(Self::Borsh),
            "jsonbase64" => Ok(Self::JsonBase64),
            _ => Err(darling::Error::custom(format!(
                r#"Invalid value "{value}", expected "borsh" or "jsonbase64""#
            ))),
        }
    }
}

#[derive(Debug, FromDeriveInput)]
#[darling(attributes(upgrade), supports(struct_named))]
pub struct UpgradeMeta {
    pub hook: HookBody,
    pub serializer: Option<Serializer>,
    pub migrate_method_name: Option<String>,
    pub migrate_method_args: Option<Expr>,
    pub migrate_minimum_gas: Option<Expr>,

    pub generics: syn::Generics,
    pub ident: syn::Ident,

    // crates
    #[darling(rename = "crate", default = "crate::default_crate_name")]
    pub me: syn::Path,
    #[darling(default = "crate::default_near_sdk")]
    pub near_sdk: syn::Path,
}

pub fn expand(meta: UpgradeMeta) -> Result<TokenStream, darling::Error> {
    let UpgradeMeta {
        hook,
        serializer,
        migrate_method_name,
        migrate_method_args,
        migrate_minimum_gas,

        ident,
        generics,

        me,
        near_sdk,
    } = meta;

    let (imp, ty, wher) = generics.split_for_impl();

    // Defaults are defined in main crate.
    // I don't think these defaults can be easily defined using
    // #[darling(default = "...")] because they are different types.
    let migrate_method_name = migrate_method_name.map_or_else(
        || quote! { #me::upgrade::DEFAULT_POST_UPGRADE_METHOD_NAME },
        |e| quote! { #e },
    );
    let migrate_method_args = migrate_method_args.map_or_else(
        || quote! { #me::upgrade::DEFAULT_POST_UPGRADE_METHOD_ARGS },
        |e| quote! { #e },
    );
    let migrate_minimum_gas = migrate_minimum_gas.map_or_else(
        || quote! { #me::upgrade::DEFAULT_POST_UPGRADE_MINIMUM_GAS },
        |e| quote! { #e },
    );

    let hook_implementation = match &hook {
        // Should we generate an UpgradeHook implementation with body?
        HookBody::Empty => Some(quote! {}), // empty implementation
        HookBody::Custom => None,           // user-provided implementation
        HookBody::Owner => Some(quote! {
            <Self as #me::owner::Owner>::require_owner();
        }),
        HookBody::Role(role) => Some(quote! {
            #me::rbac::Rbac::require_role(self, &#role);
        }),
    }
    .map(|body| {
        // Interpolate body if implementation is to be generated.
        quote! {
            impl #imp #me::upgrade::serialized::UpgradeHook for #ident #ty #wher {
                fn on_upgrade(&self) {
                    #body
                }
            }
        }
    });

    let (serializer_attribute, code_type, code_conversion) =
        match serializer.unwrap_or(Serializer::JsonBase64) {
            Serializer::Borsh => (
                quote! { #[serializer(borsh)] },
                quote! { Vec<u8> },
                quote! {},
            ),
            Serializer::JsonBase64 => (
                quote! {},
                quote! { #near_sdk::json_types::Base64VecU8 },
                quote! { let code: Vec<u8> = code.into(); },
            ),
        };

    Ok(quote! {
        #[#near_sdk::near]
        impl #imp #ident #ty #wher {
            pub fn upgrade(&mut self, #serializer_attribute code: #code_type) {
                #me::upgrade::serialized::UpgradeHook::on_upgrade(self);
                #code_conversion
                #me::upgrade::serialized::upgrade(
                    code,
                    #me::upgrade::PostUpgrade {
                        method: #migrate_method_name.to_string(),
                        args: #migrate_method_args,
                        minimum_gas: #migrate_minimum_gas,
                    },
                );
            }
        }

        #hook_implementation
    })
}

'''
'''--- rust-toolchain.toml ---
[toolchain]
channel = "1.74"

'''
'''--- rustfmt.toml ---
tab_spaces = 4
max_width = 100

'''
'''--- src/approval/mod.rs ---
//! Queue and approve actions

use near_sdk::{
    borsh::{BorshDeserialize, BorshSerialize},
    env, near, require,
    serde::Serialize,
    AccountId, BorshStorageKey,
};
use thiserror::Error;

use crate::{slot::Slot, DefaultStorageKey};

/// Error message emitted when the component is used before it is initialized
pub const NOT_INITIALIZED: &str = "init must be called before use";
/// Error message emitted when the init function is called multiple times
pub const ALREADY_INITIALIZED: &str = "init can only be called once";

pub mod native_transaction_action;
pub mod simple_multisig;

/// Actions can be executed after they are approved
pub trait Action<Cont: ?Sized> {
    /// Return type of the action. Useful if the action creates a `Promise`, for example.
    type Output;
    /// Perform the action. One time only.
    fn execute(self, contract: &mut Cont) -> Self::Output;
}

/// Defines the operating parameters for an `ApprovalManager` and performs
/// approvals.
pub trait ApprovalConfiguration<A, S> {
    /// Errors when approving a request.
    type ApprovalError;
    /// Errors when removing a request.
    type RemovalError;
    /// Errors when authorizing an account.
    type AuthorizationError;
    /// Errors when evaluating a request for execution candidacy.
    type ExecutionEligibilityError;

    /// Has the request reached full approval?
    ///
    /// # Errors
    ///
    /// Returns an error if the request is not approved for execution.
    fn is_approved_for_execution(
        &self,
        action_request: &ActionRequest<A, S>,
    ) -> Result<(), Self::ExecutionEligibilityError>;

    /// Can this request be removed by an allowed account?
    ///
    /// # Errors
    ///
    /// Returns an error if the request cannot be removed.
    fn is_removable(&self, action_request: &ActionRequest<A, S>) -> Result<(), Self::RemovalError>;

    /// Is the account allowed to execute, approve, or remove this request?
    ///
    /// # Errors
    ///
    /// Returns an error if the account is not allowed to perform such an action.
    fn is_account_authorized(
        &self,
        account_id: &AccountId,
        action_request: &ActionRequest<A, S>,
    ) -> Result<(), Self::AuthorizationError>;

    /// Modify `action_request.approval_state` in-place to increase approval.
    ///
    /// # Errors
    ///
    /// Returns an error if the request cannot be approved.
    fn try_approve_with_authorized_account(
        &self,
        account_id: AccountId,
        action_request: &mut ActionRequest<A, S>,
    ) -> Result<(), Self::ApprovalError>;
}

/// An action request is composed of an action that will be executed when the
/// associated approval state is satisfied.
#[derive(Debug)]
#[near(serializers = [borsh, json])]
pub struct ActionRequest<A, S> {
    /// The action that will be executed when the approval state is fulfilled.
    pub action: A,
    /// The associated approval state.
    pub approval_state: S,
}

#[derive(BorshStorageKey)]
#[near]
enum ApprovalStorageKey {
    NextRequestId,
    Config,
    Request(u32),
}

/// The account is ineligile to perform an action for some reason
#[derive(Error, Clone, Debug)]
#[error("Unauthorized account: '{0}' for {1}")]
pub struct UnauthorizedAccountError<AuthErr>(AccountId, AuthErr);

/// Top-level errors that may occur when attempting to approve a request
#[derive(Error, Clone, Debug)]
pub enum ApprovalError<AuthErr, AppErr> {
    /// The account is not allowed to act on requests
    #[error(transparent)]
    UnauthorizedAccount(#[from] UnauthorizedAccountError<AuthErr>),
    /// The approval function encountered another error
    #[error("Approval error: {0}")]
    ApprovalError(AppErr),
}

/// Errors that may occur when trying to execute a request
#[derive(Error, Clone, Debug)]
pub enum ExecutionError<AuthErr, ExecErr> {
    /// The account is not allowed to act on requests
    #[error(transparent)]
    UnauthorizedAccount(#[from] UnauthorizedAccountError<AuthErr>),
    /// Unapproved requests cannot be executed
    #[error("Request not approved: {0}")]
    ExecutionEligibility(ExecErr),
}

/// Errors that may occur when trying to create a request
#[derive(Error, Clone, Debug)]
pub enum CreationError<AuthErr> {
    /// The account is not allowed to act on requests
    #[error(transparent)]
    UnauthorizedAccount(#[from] UnauthorizedAccountError<AuthErr>),
}

/// Errors that may occur when trying to remove a request
#[derive(Error, Clone, Debug)]
pub enum RemovalError<AuthErr, RemErr> {
    /// The account is not allowed to act on requests
    #[error(transparent)]
    UnauthorizedAccount(#[from] UnauthorizedAccountError<AuthErr>),
    /// This request is not (yet?) allowed to be removed
    #[error("Removal not allowed: {0}")]
    RemovalNotAllowed(RemErr),
}

/// Internal functions for [`ApprovalManager`]. Using these methods may result in unexpected behavior.
pub trait ApprovalManagerInternal<A, S, C>
where
    A: Action<Self> + BorshSerialize + BorshDeserialize,
    S: BorshSerialize + BorshDeserialize + Serialize,
    C: ApprovalConfiguration<A, S> + BorshDeserialize + BorshSerialize,
{
    /// Storage root
    #[must_use]
    fn root() -> Slot<()> {
        Slot::new(DefaultStorageKey::ApprovalManager)
    }

    /// Because requests will be deleted from the requests collection,
    /// maintain a simple counter to guarantee unique IDs
    #[must_use]
    fn slot_next_request_id() -> Slot<u32> {
        Self::root().field(ApprovalStorageKey::NextRequestId)
    }

    /// Approval context included in relevant approval-related calls
    #[must_use]
    fn slot_config() -> Slot<C> {
        Self::root().field(ApprovalStorageKey::Config)
    }

    /// Current list of pending action requests.
    #[must_use]
    fn slot_request(request_id: u32) -> Slot<ActionRequest<A, S>> {
        Self::root().field(ApprovalStorageKey::Request(request_id))
    }
}

/// Collection of action requests that manages their approval state and
/// execution
pub trait ApprovalManager<A, S, C>
where
    A: Action<Self> + BorshSerialize + BorshDeserialize,
    S: BorshSerialize + BorshDeserialize + Serialize,
    C: ApprovalConfiguration<A, S> + BorshDeserialize + BorshSerialize,
{
    /// Reads config from storage. Panics if the component has not been
    /// initialized.
    fn get_config() -> C;

    /// Get a request by ID
    fn get_request(request_id: u32) -> Option<ActionRequest<A, S>>;

    /// Must be called before using the Approval construct. Can only be called
    /// once.
    fn init(config: C);

    /// Creates a new action request initialized with the given approval state.
    ///
    /// # Errors
    ///
    /// - If the acting account is unauthorized.
    fn create_request(
        &mut self,
        action: A,
        approval_state: S,
    ) -> Result<u32, CreationError<C::AuthorizationError>>;

    /// Executes an action request and removes it from the collection if the
    /// approval state of the request is fulfilled.
    ///
    /// # Errors
    ///
    /// - If the acting account is unauthorized.
    /// - If the request is ineligible for execution.
    fn execute_request(
        &mut self,
        request_id: u32,
    ) -> Result<A::Output, ExecutionError<C::AuthorizationError, C::ExecutionEligibilityError>>;

    /// Is the given request ID able to be executed if such a request were to
    /// be initiated by an authorized account?
    ///
    /// # Errors
    ///
    /// - If the request is ineligible for execution.
    fn is_approved_for_execution(request_id: u32) -> Result<(), C::ExecutionEligibilityError>;

    /// Tries to approve the action request designated by the given request ID
    /// with the given arguments. Panics if the request ID does not exist.
    ///
    /// # Errors
    ///
    /// - If the acting account is unauthorized.
    /// - If another error was encountered when approving the request.
    fn approve_request(
        &mut self,
        request_id: u32,
    ) -> Result<(), ApprovalError<C::AuthorizationError, C::ApprovalError>>;

    /// Tries to remove the action request indicated by `request_id`.
    ///
    /// # Errors
    ///
    /// - If the acting account is unauthorized.
    /// - If the request cannot be removed.
    fn remove_request(
        &mut self,
        request_id: u32,
    ) -> Result<(), RemovalError<C::AuthorizationError, C::RemovalError>>;
}

impl<T: ApprovalManagerInternal<A, S, C>, A, S, C> ApprovalManager<A, S, C> for T
where
    A: Action<Self> + BorshSerialize + BorshDeserialize,
    S: BorshSerialize + BorshDeserialize + Serialize,
    C: ApprovalConfiguration<A, S> + BorshDeserialize + BorshSerialize,
{
    fn get_config() -> C {
        Self::slot_config()
            .read()
            .unwrap_or_else(|| env::panic_str(NOT_INITIALIZED))
    }

    fn get_request(request_id: u32) -> Option<ActionRequest<A, S>> {
        Self::slot_request(request_id).read()
    }

    fn init(config: C) {
        require!(
            Self::slot_config().swap(&config).is_none(),
            ALREADY_INITIALIZED,
        );
    }

    fn create_request(
        &mut self,
        action: A,
        approval_state: S,
    ) -> Result<u32, CreationError<C::AuthorizationError>> {
        let request_id = Self::slot_next_request_id().read().unwrap_or(0);

        let request = ActionRequest {
            action,
            approval_state,
        };

        let config = Self::get_config();
        let predecessor = env::predecessor_account_id();

        config
            .is_account_authorized(&predecessor, &request)
            .map_err(|e| UnauthorizedAccountError(predecessor, e))?;

        Self::slot_next_request_id().write(&(request_id + 1));
        Self::slot_request(request_id).write(&request);

        Ok(request_id)
    }

    fn execute_request(
        &mut self,
        request_id: u32,
    ) -> Result<A::Output, ExecutionError<C::AuthorizationError, C::ExecutionEligibilityError>>
    {
        Self::is_approved_for_execution(request_id)
            .map_err(ExecutionError::ExecutionEligibility)?;

        let predecessor = env::predecessor_account_id();
        let config = Self::get_config();

        let mut request_slot = Self::slot_request(request_id);
        let request = request_slot.read().unwrap();

        config
            .is_account_authorized(&predecessor, &request)
            .map_err(|e| UnauthorizedAccountError(predecessor, e))?;

        let result = request.action.execute(self);
        request_slot.remove();

        Ok(result)
    }

    fn is_approved_for_execution(request_id: u32) -> Result<(), C::ExecutionEligibilityError> {
        let request = Self::slot_request(request_id).read().unwrap();

        let config = Self::get_config();
        config.is_approved_for_execution(&request)
    }

    fn approve_request(
        &mut self,
        request_id: u32,
    ) -> Result<(), ApprovalError<C::AuthorizationError, C::ApprovalError>> {
        let mut request_slot = Self::slot_request(request_id);
        let mut request = request_slot.read().unwrap();

        let predecessor = env::predecessor_account_id();
        let config = Self::get_config();

        config
            .is_account_authorized(&predecessor, &request)
            .map_err(|e| UnauthorizedAccountError(predecessor.clone(), e))?;

        config
            .try_approve_with_authorized_account(predecessor, &mut request)
            .map_err(ApprovalError::ApprovalError)?;

        request_slot.write(&request);

        Ok(())
    }

    fn remove_request(
        &mut self,
        request_id: u32,
    ) -> Result<(), RemovalError<C::AuthorizationError, C::RemovalError>> {
        let mut request_slot = Self::slot_request(request_id);
        let request = request_slot.read().unwrap();
        let predecessor = env::predecessor_account_id();

        let config = Self::get_config();

        config
            .is_removable(&request)
            .map_err(RemovalError::RemovalNotAllowed)?;

        config
            .is_account_authorized(&predecessor, &request)
            .map_err(|e| UnauthorizedAccountError(predecessor, e))?;

        request_slot.remove();

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use near_sdk::{
        near, test_utils::VMContextBuilder, testing_env, AccountId, BorshStorageKey, PanicOnDefault,
    };
    use near_sdk_contract_tools_macros::Rbac;

    use crate::{rbac::Rbac, slot::Slot};

    use super::{
        Action, ActionRequest, ApprovalConfiguration, ApprovalManager, ApprovalManagerInternal,
    };

    #[derive(BorshStorageKey)]
    #[near]
    enum Role {
        Multisig,
    }

    #[derive(Debug, PartialEq, Eq, Clone)]
    #[near]
    enum MyAction {
        SayHello,
        SayGoodbye,
    }

    impl Action<Contract> for MyAction {
        type Output = &'static str;

        fn execute(self, _contract: &mut Contract) -> Self::Output {
            match self {
                Self::SayHello => {
                    println!("Hello!");
                    "hello"
                }
                Self::SayGoodbye => {
                    println!("Goodbye!");
                    "goodbye"
                }
            }
        }
    }

    #[derive(Rbac, PanicOnDefault)]
    #[rbac(roles = "Role", crate = "crate")]
    #[near(contract_state)]
    struct Contract {}

    #[near]
    impl Contract {
        #[init]
        pub fn new(threshold: u8) -> Self {
            let contract = Self {};

            <Self as ApprovalManager<_, _, _>>::init(MultisigConfig { threshold });

            contract
        }
    }

    impl ApprovalManagerInternal<MyAction, MultisigApprovalState, MultisigConfig> for Contract {
        fn root() -> Slot<()> {
            Slot::new(b"a")
        }
    }

    #[derive(Debug)]
    #[near]
    struct MultisigConfig {
        pub threshold: u8,
    }

    #[derive(Default, Debug)]
    #[near(serializers = [borsh, json])]
    struct MultisigApprovalState {
        pub approved_by: Vec<AccountId>,
    }

    impl ApprovalConfiguration<MyAction, MultisigApprovalState> for MultisigConfig {
        type ApprovalError = String;
        type RemovalError = ();
        type AuthorizationError = String;
        type ExecutionEligibilityError = String;

        fn is_approved_for_execution(
            &self,
            action_request: &super::ActionRequest<MyAction, MultisigApprovalState>,
        ) -> Result<(), Self::ExecutionEligibilityError> {
            let valid_signatures = action_request
                .approval_state
                .approved_by
                .iter()
                .filter(|account_id| Contract::has_role(account_id, &Role::Multisig))
                .count();

            let threshold = self.threshold as usize;

            if valid_signatures >= threshold {
                Ok(())
            } else {
                Err("Insufficient signatures".to_string())
            }
        }

        fn is_removable(
            &self,
            _action_request: &super::ActionRequest<MyAction, MultisigApprovalState>,
        ) -> Result<(), Self::RemovalError> {
            Ok(())
        }

        fn is_account_authorized(
            &self,
            account_id: &AccountId,
            _action_request: &ActionRequest<MyAction, MultisigApprovalState>,
        ) -> Result<(), Self::AuthorizationError> {
            if Contract::has_role(account_id, &Role::Multisig) {
                Ok(())
            } else {
                Err("Account is missing Multisig role".to_string())
            }
        }

        fn try_approve_with_authorized_account(
            &self,
            account_id: AccountId,
            action_request: &mut ActionRequest<MyAction, MultisigApprovalState>,
        ) -> Result<(), Self::ApprovalError> {
            if action_request
                .approval_state
                .approved_by
                .contains(&account_id)
            {
                return Err("Already approved by account".to_string());
            }

            action_request.approval_state.approved_by.push(account_id);

            Ok(())
        }
    }

    fn predecessor(account_id: &AccountId) {
        let mut context = VMContextBuilder::new();
        context.predecessor_account_id(account_id.clone());
        testing_env!(context.build());
    }

    #[test]
    fn successful_approval() {
        let alice: AccountId = "alice".parse().unwrap();
        let bob: AccountId = "bob_acct".parse().unwrap();
        let charlie: AccountId = "charlie".parse().unwrap();

        let mut contract = Contract::new(2);

        contract.add_role(&alice, &Role::Multisig);
        contract.add_role(&bob, &Role::Multisig);
        contract.add_role(&charlie, &Role::Multisig);

        predecessor(&alice);
        let request_id = contract
            .create_request(MyAction::SayHello, MultisigApprovalState::default())
            .unwrap();

        assert_eq!(request_id, 0);
        assert!(Contract::is_approved_for_execution(request_id).is_err());

        contract.approve_request(request_id).unwrap();

        assert!(Contract::is_approved_for_execution(request_id).is_err());

        predecessor(&charlie);
        contract.approve_request(request_id).unwrap();

        assert!(Contract::is_approved_for_execution(request_id).is_ok());

        assert_eq!(contract.execute_request(request_id).unwrap(), "hello");
    }

    #[test]
    #[should_panic(expected = "Already approved by account")]
    fn duplicate_approval() {
        let alice: AccountId = "alice".parse().unwrap();

        let mut contract = Contract::new(2);

        contract.add_role(&alice, &Role::Multisig);

        predecessor(&alice);
        let request_id = contract
            .create_request(MyAction::SayHello, MultisigApprovalState::default())
            .unwrap();

        contract.approve_request(request_id).unwrap();

        contract.approve_request(request_id).unwrap();
    }

    #[test]
    #[should_panic = "Insufficient signatures"]
    fn no_execution_before_approval() {
        let alice: AccountId = "alice".parse().unwrap();

        let mut contract = Contract::new(2);

        contract.add_role(&alice, &Role::Multisig);

        predecessor(&alice);

        let request_id = contract
            .create_request(MyAction::SayHello, MultisigApprovalState::default())
            .unwrap();

        contract.approve_request(request_id).unwrap();

        contract.execute_request(request_id).unwrap();
    }

    #[test]
    fn successful_removal() {
        let alice: AccountId = "alice".parse().unwrap();
        let bob: AccountId = "bob_acct".parse().unwrap();

        let mut contract = Contract::new(2);

        contract.add_role(&alice, &Role::Multisig);
        contract.add_role(&bob, &Role::Multisig);

        predecessor(&alice);

        let request_id = contract
            .create_request(MyAction::SayHello, MultisigApprovalState::default())
            .unwrap();

        contract.approve_request(request_id).unwrap();

        predecessor(&bob);

        contract.remove_request(request_id).unwrap();
    }

    #[test]
    fn dynamic_eligibility() {
        let alice: AccountId = "alice".parse().unwrap();
        let bob: AccountId = "bob_acct".parse().unwrap();
        let charlie: AccountId = "charlie".parse().unwrap();

        let mut contract = Contract::new(2);

        contract.add_role(&alice, &Role::Multisig);
        contract.add_role(&bob, &Role::Multisig);
        contract.add_role(&charlie, &Role::Multisig);

        predecessor(&alice);
        let request_id = contract
            .create_request(MyAction::SayGoodbye, MultisigApprovalState::default())
            .unwrap();

        contract.approve_request(request_id).unwrap();

        predecessor(&bob);
        contract.approve_request(request_id).unwrap();

        assert!(Contract::is_approved_for_execution(request_id).is_ok());

        contract.remove_role(&alice, &Role::Multisig);

        assert!(Contract::is_approved_for_execution(request_id).is_err());

        predecessor(&charlie);
        contract.approve_request(request_id).unwrap();

        assert!(Contract::is_approved_for_execution(request_id).is_ok());
    }
}

'''
'''--- src/approval/native_transaction_action.rs ---
//! Approval action type for native NEAR transaction actions (create account,
//! delete account, add key, delete key, deploy contract, function call, stake,
//! transfer)

use near_sdk::{
    json_types::{Base64VecU8, U64},
    near, AccountId, Gas, NearToken, Promise,
};

/// Every native NEAR action can be mapped to a Promise action.
/// NOTE: The native ADD_KEY action is split into two: one for adding a
/// full-access key, one for a function call access key.
#[derive(Clone, Debug, Eq, PartialEq)]
#[near(serializers = [borsh, json])]
pub enum PromiseAction {
    /// Native CREATE_ACCOUNT action
    CreateAccount,
    /// Native DEPLOY_CONTRACT action
    DeployContract {
        /// WASM binary blob
        code: Base64VecU8,
    },
    /// Native FUNCTION_CALL action
    FunctionCall {
        /// Name of function to call on receiver
        function_name: String,
        /// Function input (optional)
        arguments: Base64VecU8,
        /// Attached deposit
        amount: NearToken,
        /// Attached gas
        gas: Gas,
    },
    /// Native TRANSFER action
    Transfer {
        /// Amount of NEAR tokens to transfer to receiver
        amount: NearToken,
    },
    /// Native STAKE action
    Stake {
        /// Amount of tokens to stake
        amount: NearToken,
        /// Public key of validator node
        public_key: String,
    },
    /// Native ADD_KEY action for full-access keys
    AddFullAccessKey {
        /// Public key to add to account
        public_key: String,
        /// Starting nonce (default: 0)
        nonce: Option<U64>,
    },
    /// Native ADD_KEY action for function call keys
    AddAccessKey {
        /// Public key to add to account
        public_key: String,
        /// Gas allowance
        allowance: NearToken,
        /// Target contract account ID
        receiver_id: AccountId,
        /// Restrict this key to calls to these functions
        function_names: Vec<String>,
        /// Starting nonce (default: 0)
        nonce: Option<U64>,
    },
    /// Native DELETE_KEY action
    DeleteKey {
        /// Public key to remove
        public_key: String,
    },
    /// Native DELETE_ACCOUNT action
    DeleteAccount {
        /// Remaining account balance transferred to beneficiary
        beneficiary_id: AccountId,
    },
}

/// A native protocol-level transaction that (de)serializes into many different
/// formats.
#[derive(Eq, PartialEq, Clone, Debug)]
#[near(serializers = [borsh, json])]
pub struct NativeTransactionAction {
    /// Receiver of the transaction
    pub receiver_id: AccountId,
    /// List of actions to perform on receiver
    pub actions: Vec<PromiseAction>,
}

impl<C> super::Action<C> for NativeTransactionAction {
    type Output = Promise;

    fn execute(self, _contract: &mut C) -> Self::Output {
        let mut promise = Promise::new(self.receiver_id);

        // Construct promise
        for action in self.actions {
            promise = match action {
                PromiseAction::AddAccessKey {
                    public_key,
                    allowance,
                    receiver_id,
                    function_names,
                    nonce,
                } => promise.add_access_key_allowance_with_nonce(
                    public_key.parse().unwrap(),
                    near_sdk::Allowance::limited(allowance)
                        .unwrap_or(near_sdk::Allowance::Unlimited),
                    receiver_id,
                    function_names.join(","),
                    nonce.map_or(0, Into::into),
                ),
                PromiseAction::AddFullAccessKey { public_key, nonce } => promise
                    .add_full_access_key_with_nonce(
                        public_key.parse().unwrap(),
                        nonce.map_or(0, Into::into),
                    ),
                PromiseAction::CreateAccount => promise.create_account(),
                PromiseAction::DeployContract { code } => promise.deploy_contract(code.0),
                PromiseAction::FunctionCall {
                    function_name,
                    arguments,
                    amount,
                    gas,
                } => promise.function_call(function_name, arguments.0, amount, gas),
                PromiseAction::Transfer { amount } => promise.transfer(amount),
                PromiseAction::Stake { amount, public_key } => {
                    promise.stake(amount, public_key.parse().unwrap())
                }
                PromiseAction::DeleteKey { public_key } => {
                    promise.delete_key(public_key.parse().unwrap())
                }
                PromiseAction::DeleteAccount { beneficiary_id } => {
                    promise.delete_account(beneficiary_id)
                }
            };
        }

        promise
    }
}

'''
'''--- src/approval/simple_multisig.rs ---
//! Simple multi-signature wallet component. Generic over approvable actions.
//! Use with
//! [`NativeTransactionAction`](super::native_transaction_action::NativeTransactionAction)
//! for multisig over native transactions.

use std::marker::PhantomData;

use near_sdk::{env, near, AccountId};
use thiserror::Error;

use super::{ActionRequest, ApprovalConfiguration};

/// Check which accounts are eligible to submit approvals to an
/// [`ApprovalManager`](super::ApprovalManager)
pub trait AccountAuthorizer {
    /// Why can this account not be authorized?
    type AuthorizationError;

    /// Determines whether an account ID is allowed to submit an approval
    ///
    /// # Errors
    ///
    /// Returns an error if the account is not authorized.
    fn is_account_authorized(account_id: &AccountId) -> Result<(), Self::AuthorizationError>;
}

/// M (threshold) of N approval scheme
#[derive(Clone, Debug)]
#[near(serializers = [borsh, json])]
pub struct Configuration<Au: AccountAuthorizer> {
    /// How many approvals are required?
    pub threshold: u8,
    /// A request cannot be executed, and can be deleted by any
    /// approval-eligible member after this period has elapsed.
    /// 0 = perpetual validity, no deletion
    pub validity_period_nanoseconds: u64,
    #[borsh(skip)]
    #[serde(skip)]
    _authorizer: PhantomData<Au>,
}

impl<Au: AccountAuthorizer> Configuration<Au> {
    /// Create an approval scheme with the given threshold
    #[must_use]
    pub fn new(threshold: u8, validity_period_nanoseconds: u64) -> Self {
        Self {
            threshold,
            validity_period_nanoseconds,
            _authorizer: PhantomData,
        }
    }

    /// Is the given approval state still considered valid?
    ///
    /// # Panics
    ///
    /// - If the request timestamp is in the future.
    #[must_use]
    pub fn is_within_validity_period(&self, approval_state: &ApprovalState) -> bool {
        if self.validity_period_nanoseconds == 0 {
            true
        } else {
            env::block_timestamp()
                .checked_sub(approval_state.created_at_nanoseconds)
                .unwrap() // inconsistent state if a request timestamp is in the future
                < self.validity_period_nanoseconds
        }
    }
}

/// Approval state for simple multisig
#[derive(Clone, Debug)]
#[near(serializers = [borsh, json])]
pub struct ApprovalState {
    /// List of accounts that have approved an action thus far
    pub approved_by: Vec<AccountId>,
    /// Network timestamp when the request was created
    pub created_at_nanoseconds: u64,
}

impl Default for ApprovalState {
    fn default() -> Self {
        Self::new()
    }
}

impl ApprovalState {
    /// Creates an [`ApprovalState`] with the current network timestamp.
    #[must_use]
    pub fn new() -> Self {
        Self {
            approved_by: Vec::new(),
            created_at_nanoseconds: env::block_timestamp(),
        }
    }
}

/// If a request has expired, some actions may not be performed.
#[derive(Error, Clone, Debug)]
#[error("Validity period exceeded")]
pub struct RequestExpiredError;

/// Why might a simple multisig approval attempt fail?
#[derive(Error, Clone, Debug)]
pub enum ApprovalError {
    /// The account has already approved this action request.
    #[error("Already approved by this account")]
    AlreadyApprovedByAccount,
    /// The request has expired and cannot be approved or executed.
    #[error(transparent)]
    RequestExpired(#[from] RequestExpiredError),
}

/// Errors when evaluating a request for execution
#[derive(Error, Clone, Debug)]
pub enum ExecutionEligibilityError {
    /// The request does not have enough approvals
    #[error("Insufficient approvals on request: required {required} but only has {current}")]
    InsufficientApprovals {
        /// Current number of approvals
        current: usize,
        /// Required number of approvals
        required: usize,
    },
    /// The request has expired and cannot be approved or executed
    #[error(transparent)]
    RequestExpired(#[from] RequestExpiredError),
}

/// What errors may occur when removing a request?
#[derive(Error, Clone, Debug)]
pub enum RemovalError {
    /// Requests may not be removed while they are still valid
    #[error("Removal prohibited before expiration")]
    RequestStillValid,
}

impl<Au, Ac> ApprovalConfiguration<Ac, ApprovalState> for Configuration<Au>
where
    Au: AccountAuthorizer,
{
    type ApprovalError = ApprovalError;
    type RemovalError = RemovalError;
    type AuthorizationError = Au::AuthorizationError;
    type ExecutionEligibilityError = ExecutionEligibilityError;

    fn is_approved_for_execution(
        &self,
        action_request: &ActionRequest<Ac, ApprovalState>,
    ) -> Result<(), ExecutionEligibilityError> {
        if !self.is_within_validity_period(&action_request.approval_state) {
            return Err(RequestExpiredError.into());
        }

        let current = action_request.approval_state.approved_by.len();
        let required = self.threshold as usize;

        if current < required {
            return Err(ExecutionEligibilityError::InsufficientApprovals { current, required });
        }

        Ok(())
    }

    fn is_removable(
        &self,
        action_request: &ActionRequest<Ac, ApprovalState>,
    ) -> Result<(), Self::RemovalError> {
        if self.is_within_validity_period(&action_request.approval_state) {
            Err(RemovalError::RequestStillValid)
        } else {
            Ok(())
        }
    }

    fn is_account_authorized(
        &self,
        account_id: &AccountId,
        _action_request: &ActionRequest<Ac, ApprovalState>,
    ) -> Result<(), Self::AuthorizationError> {
        Au::is_account_authorized(account_id)
    }

    fn try_approve_with_authorized_account(
        &self,
        account_id: AccountId,
        action_request: &mut ActionRequest<Ac, ApprovalState>,
    ) -> Result<(), Self::ApprovalError> {
        if !self.is_within_validity_period(&action_request.approval_state) {
            return Err(RequestExpiredError.into());
        }

        if action_request
            .approval_state
            .approved_by
            .contains(&account_id)
        {
            return Err(ApprovalError::AlreadyApprovedByAccount);
        }

        action_request.approval_state.approved_by.push(account_id);

        Ok(())
    }
}

/// Types used by near-sdk-contract-tools-macros
pub mod macro_types {
    use thiserror::Error;

    /// Account that attempted an action is missing a role
    #[derive(Error, Clone, Debug)]
    #[error("Missing role '{0}' required for this action")]
    pub struct MissingRole<R>(pub R);
}

#[cfg(test)]
mod tests {
    use near_sdk::{
        env, near, test_utils::VMContextBuilder, testing_env, AccountId, BorshStorageKey,
        PanicOnDefault,
    };
    use thiserror::Error;

    use crate::{
        approval::{
            simple_multisig::{AccountAuthorizer, ApprovalState, Configuration},
            ApprovalManager, ApprovalManagerInternal,
        },
        rbac::Rbac,
        slot::Slot,
        Rbac,
    };

    #[near]
    enum Action {
        SayHello,
        SayGoodbye,
    }

    impl crate::approval::Action<Contract> for Action {
        type Output = &'static str;

        fn execute(self, _contract: &mut Contract) -> Self::Output {
            match self {
                Self::SayHello => "hello",
                Self::SayGoodbye => "goodbye",
            }
        }
    }

    #[derive(BorshStorageKey)]
    #[near]
    enum Role {
        Multisig,
    }

    #[derive(Rbac, Debug, PanicOnDefault)]
    #[rbac(roles = "Role", crate = "crate")]
    #[near(contract_state)]
    struct Contract {}

    impl ApprovalManagerInternal<Action, ApprovalState, Configuration<Self>> for Contract {
        fn root() -> Slot<()> {
            Slot::new(b"m")
        }
    }

    #[derive(Error, Clone, Debug)]
    #[error("Missing role: {0}")]
    struct MissingRole(&'static str);

    impl AccountAuthorizer for Contract {
        type AuthorizationError = MissingRole;

        fn is_account_authorized(account_id: &near_sdk::AccountId) -> Result<(), MissingRole> {
            if Self::has_role(account_id, &Role::Multisig) {
                Ok(())
            } else {
                Err(MissingRole("Multisig"))
            }
        }
    }

    #[near]
    impl Contract {
        #[init]
        pub fn new() -> Self {
            <Self as ApprovalManager<_, _, _>>::init(Configuration::new(2, 10000));
            Self {}
        }

        pub fn obtain_multisig_permission(&mut self) {
            self.add_role(&env::predecessor_account_id(), &Role::Multisig);
        }

        pub fn create(&mut self, say_hello: bool) -> u32 {
            let action = if say_hello {
                Action::SayHello
            } else {
                Action::SayGoodbye
            };

            self.create_request(action, ApprovalState::new()).unwrap()
        }

        pub fn approve(&mut self, request_id: u32) {
            self.approve_request(request_id).unwrap();
        }

        pub fn execute(&mut self, request_id: u32) -> &'static str {
            self.execute_request(request_id).unwrap()
        }

        pub fn remove(&mut self, request_id: u32) {
            self.remove_request(request_id).unwrap();
        }
    }

    fn predecessor(account_id: &AccountId) {
        let mut context = VMContextBuilder::new();
        context.predecessor_account_id(account_id.clone());
        testing_env!(context.build());
    }

    #[test]
    fn successful_approval() {
        let alice: AccountId = "alice".parse().unwrap();
        let bob: AccountId = "bob_acct".parse().unwrap();
        let charlie: AccountId = "charlie".parse().unwrap();

        let mut contract = Contract::new();

        predecessor(&alice);
        contract.obtain_multisig_permission();
        predecessor(&bob);
        contract.obtain_multisig_permission();
        predecessor(&charlie);
        contract.obtain_multisig_permission();

        let request_id = contract.create(true);

        assert_eq!(request_id, 0);
        assert!(Contract::is_approved_for_execution(request_id).is_err());

        predecessor(&alice);
        contract.approve(request_id);

        assert!(Contract::is_approved_for_execution(request_id).is_err());

        predecessor(&charlie);
        contract.approve(request_id);

        assert!(Contract::is_approved_for_execution(request_id).is_ok());

        predecessor(&bob);
        contract.approve(request_id);

        assert!(Contract::is_approved_for_execution(request_id).is_ok());

        assert_eq!(contract.execute(request_id), "hello");
    }

    #[test]
    fn successful_removal() {
        let alice: AccountId = "alice".parse().unwrap();

        let mut contract = Contract::new();

        predecessor(&alice);
        contract.obtain_multisig_permission();

        let request_id = contract.create(true);

        contract.approve(request_id);

        let created_at = Contract::get_request(request_id)
            .unwrap()
            .approval_state
            .created_at_nanoseconds;

        let mut context = VMContextBuilder::new();
        context
            .predecessor_account_id(alice)
            .block_timestamp(created_at + 10000);
        testing_env!(context.build());

        contract.remove(request_id);
    }

    #[test]
    #[should_panic = "RemovalNotAllowed"]
    fn unsuccessful_removal_not_expired() {
        let alice: AccountId = "alice".parse().unwrap();

        let mut contract = Contract::new();

        predecessor(&alice);
        contract.obtain_multisig_permission();

        let request_id = contract.create(true);

        contract.approve(request_id);

        let created_at = Contract::get_request(request_id)
            .unwrap()
            .approval_state
            .created_at_nanoseconds;

        let mut context = VMContextBuilder::new();
        context
            .predecessor_account_id(alice)
            .block_timestamp(created_at + 9999);
        testing_env!(context.build());

        contract.remove(request_id);
    }

    #[test]
    #[should_panic = "UnauthorizedAccount"]
    fn unsuccessful_removal_no_permission() {
        let alice: AccountId = "alice".parse().unwrap();
        let bob: AccountId = "bob_acct".parse().unwrap();

        let mut contract = Contract::new();

        predecessor(&alice);
        contract.obtain_multisig_permission();

        let request_id = contract.create(true);

        contract.approve(request_id);

        let created_at = Contract::get_request(request_id)
            .unwrap()
            .approval_state
            .created_at_nanoseconds;

        let mut context = VMContextBuilder::new();
        context
            .predecessor_account_id(bob)
            .block_timestamp(created_at + 10000);
        testing_env!(context.build());

        contract.remove(request_id);
    }
}

'''
'''--- src/escrow.rs ---
//! Escrow pattern implements locking functionality over some arbitrary storage
//! key.
//!
//! Upon locking something, it adds a flag in the store that some item on some
//! `id` is locked with some `state`. This allows you to verify if an item is
//! locked, and add some additional functionality to unlock the item.
//!
//! The crate exports a [derive macro](near_sdk_contract_tools_macros::Escrow)
//! that derives a default implementation for escrow.
//!
//! # Safety
//!
//! The state for this contract is stored under the
//! [`root`][EscrowInternal::root], make sure you don't accidentally collide
//! these storage entries in your contract. You can change the key this is
//! stored under by providing `storage_key` to the macro.
use crate::{event, standard::nep297::Event};
use crate::{slot::Slot, DefaultStorageKey};
use near_sdk::{
    borsh::{BorshDeserialize, BorshSerialize},
    env::panic_str,
    require,
    serde::Serialize,
    BorshStorageKey,
};

const ESCROW_ALREADY_LOCKED_MESSAGE: &str = "Already locked";
const ESCROW_NOT_LOCKED_MESSAGE: &str = "Lock required";
const ESCROW_UNLOCK_HANDLER_FAILED_MESSAGE: &str = "Unlock handler failed";

#[derive(BorshSerialize, BorshStorageKey)]
#[borsh(crate = "near_sdk::borsh")]
enum StorageKey<'a, T> {
    Locked(&'a T),
}

/// Emit the state of an escrow lock and whether it was locked or unlocked.
#[event(
    standard = "x-escrow",
    version = "1.0.0",
    crate = "crate",
    macros = "crate"
)]
pub struct Lock<Id: Serialize, State: Serialize> {
    /// The identifier for a lock.
    pub id: Id,
    /// If the lock was locked or unlocked, and any state along with it.
    pub locked: Option<State>,
}

/// Inner storage modifiers and functionality required for escrow to succeed.
pub trait EscrowInternal {
    /// Identifier over which the escrow exists.
    type Id: BorshSerialize;
    /// State stored inside the lock.
    type State: BorshSerialize + BorshDeserialize;

    /// Retrieve the state root.
    #[must_use]
    fn root() -> Slot<()> {
        Slot::root(DefaultStorageKey::Escrow)
    }

    /// Inner function to retrieve the slot keyed by its [`Id`](EscrowInternal::Id).
    fn locked_slot(&self, id: &Self::Id) -> Slot<Self::State> {
        Self::root().field(StorageKey::Locked(id))
    }

    /// Read the state from the slot.
    fn get_locked(&self, id: &Self::Id) -> Option<Self::State> {
        self.locked_slot(id).read()
    }

    /// Set the state at `id` to `locked`.
    fn set_locked(&mut self, id: &Self::Id, locked: &Self::State) {
        self.locked_slot(id).write(locked);
    }

    /// Clear the state at `id`.
    fn set_unlocked(&mut self, id: &Self::Id) {
        self.locked_slot(id).remove();
    }
}

/// Some escrowable capabilities, with a simple locking/unlocking mechanism.
///
/// If you add additional `Approve` capabilities here, you can make use of a
/// step-wise locking system.
pub trait Escrow {
    /// Identifier over which the escrow exists.
    type Id: BorshSerialize;
    /// State stored inside the lock.
    type State: BorshSerialize + BorshDeserialize;

    /// Lock some [`State`](Escrow::State) by its [`Id`](Escrow::Id) within the
    /// store.
    fn lock(&mut self, id: &Self::Id, state: &Self::State);

    /// Unlock and release some [`State`](Escrow::State) by its
    /// [`Id`](Escrow::Id).
    ///
    /// Optionally, you can provide a handler which would allow you to inject
    /// logic if you should unlock or not.
    fn unlock(&mut self, id: &Self::Id, unlock_handler: impl FnOnce(&Self::State) -> bool);

    /// Check if the item is locked
    fn is_locked(&self, id: &Self::Id) -> bool;
}

impl<T> Escrow for T
where
    T: EscrowInternal,
{
    type Id = <Self as EscrowInternal>::Id;
    type State = <Self as EscrowInternal>::State;

    fn lock(&mut self, id: &Self::Id, state: &Self::State) {
        require!(self.get_locked(id).is_none(), ESCROW_ALREADY_LOCKED_MESSAGE);

        self.set_locked(id, state);
    }

    fn unlock(&mut self, id: &Self::Id, unlock_handler: impl FnOnce(&Self::State) -> bool) {
        let lock = self
            .get_locked(id)
            .unwrap_or_else(|| panic_str(ESCROW_NOT_LOCKED_MESSAGE));

        if unlock_handler(&lock) {
            self.set_unlocked(id);
        } else {
            panic_str(ESCROW_UNLOCK_HANDLER_FAILED_MESSAGE)
        }
    }

    fn is_locked(&self, id: &Self::Id) -> bool {
        self.get_locked(id).is_some()
    }
}

/// A wrapper trait allowing all implementations of `State` and `Id` that
/// implement [`serde::Serialize`] to emit an event on success if they want to.
pub trait EventEmittedOnEscrow<Id: Serialize, State: Serialize> {
    /// Optionally implement an event on success of lock
    fn lock_emit(&mut self, id: &Id, state: &State);
    /// Optionally implement an event on success of unlock
    fn unlock_emit(&mut self, id: &Id, unlock_handler: impl FnOnce(&State) -> bool);
}

impl<T> EventEmittedOnEscrow<<T as Escrow>::Id, <T as Escrow>::State> for T
where
    T: Escrow + EscrowInternal,
    <T as Escrow>::Id: Serialize,
    <T as Escrow>::State: Serialize,
{
    fn lock_emit(&mut self, id: &<T as Escrow>::Id, state: &<T as Escrow>::State) {
        self.lock(id, state);
        Lock {
            id: id.to_owned(),
            locked: Some(state),
        }
        .emit();
    }

    fn unlock_emit(
        &mut self,
        id: &<T as Escrow>::Id,
        unlock_handler: impl FnOnce(&<T as Escrow>::State) -> bool,
    ) {
        self.unlock(id, unlock_handler);
        Lock::<_, <T as Escrow>::State> { id, locked: None }.emit();
    }
}

#[cfg(test)]
mod tests {
    use super::Escrow;
    use crate::escrow::EscrowInternal;
    use near_sdk::{
        near, test_utils::VMContextBuilder, testing_env, AccountId, NearToken, PanicOnDefault,
        VMContext,
    };
    use near_sdk_contract_tools_macros::Escrow;

    const ID: u64 = 1;
    const IS_NOT_READY: bool = false;
    const ONE_YOCTO: u128 = 1;

    #[derive(Escrow, PanicOnDefault)]
    #[escrow(id = "u64", state = "bool", crate = "crate")]
    #[near(contract_state)]
    struct Contract {}

    #[near]
    impl Contract {
        #[init]
        pub fn new() -> Self {
            Self {}
        }
    }

    fn alice() -> AccountId {
        "alice".parse().unwrap()
    }

    fn get_context(attached_deposit: u128, signer: Option<AccountId>) -> VMContext {
        VMContextBuilder::new()
            .signer_account_id(signer.clone().unwrap_or_else(alice))
            .predecessor_account_id(signer.unwrap_or_else(alice))
            .attached_deposit(NearToken::from_yoctonear(attached_deposit))
            .is_view(false)
            .build()
    }

    #[test]
    fn test_can_lock() {
        testing_env!(get_context(ONE_YOCTO, None));
        let mut contract = Contract::new();

        contract.lock(&ID, &IS_NOT_READY);
        assert!(contract.get_locked(&ID).is_some());
    }

    #[test]
    #[should_panic(expected = "Already locked")]
    fn test_cannot_lock_twice() {
        testing_env!(get_context(ONE_YOCTO, None));
        let mut contract = Contract::new();

        contract.lock(&ID, &IS_NOT_READY);
        contract.lock(&ID, &IS_NOT_READY);
    }

    #[test]
    fn test_can_unlock() {
        testing_env!(get_context(ONE_YOCTO, None));
        let mut contract = Contract::new();

        let is_ready = true;
        contract.lock(&ID, &is_ready);
        contract.unlock(&ID, |readiness| readiness == &is_ready);

        assert!(contract.get_locked(&ID).is_none());
    }

    #[test]
    #[should_panic(expected = "Unlock handler failed")]
    fn test_cannot_unlock_until_ready() {
        testing_env!(get_context(ONE_YOCTO, None));
        let mut contract = Contract::new();

        let is_ready = true;
        contract.lock(&ID, &IS_NOT_READY);
        contract.unlock(&ID, |readiness| readiness == &is_ready);

        assert!(contract.get_locked(&ID).is_none());
    }
}

'''
'''--- src/fast_account_id.rs ---
//! A fast alternative to `near_sdk::AccountId` that is faster to use, and has a
//! smaller Borsh serialization footprint.

use std::{ops::Deref, rc::Rc, str::FromStr};

use near_sdk::borsh::{BorshDeserialize, BorshSerialize};

static ALPHABET: &[u8; 39] = b".abcdefghijklmnopqrstuvwxyz0123456789-_";

const fn char_index(c: u8) -> Option<usize> {
    match c {
        b'.' => Some(0),
        b'a'..=b'z' => Some((1 + c - b'a') as usize),
        b'0'..=b'9' => Some((27 + c - b'0') as usize),
        b'-' => Some(37),
        b'_' => Some(38),
        _ => None,
    }
}

/// An alternative to `near_sdk::AccountId` that is faster to use, and has a
/// smaller Borsh serialization footprint.
///
/// Limitations:
///  - Does not implement `serde` serialization traits.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct FastAccountId(Rc<str>);

impl FastAccountId {
    /// Creates a new `FastAccountId` from a `&str` without performing any checks.
    #[must_use]
    pub fn new_unchecked(account_id: &str) -> Self {
        Self(Rc::from(account_id))
    }
}

impl std::fmt::Display for FastAccountId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", &self.0)
    }
}

impl Deref for FastAccountId {
    type Target = str;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl AsRef<str> for FastAccountId {
    fn as_ref(&self) -> &str {
        &self.0
    }
}

impl From<near_sdk::AccountId> for FastAccountId {
    fn from(account_id: near_sdk::AccountId) -> Self {
        Self(Rc::from(account_id.as_str()))
    }
}

impl FromStr for FastAccountId {
    type Err = <near_sdk::AccountId as FromStr>::Err;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        near_sdk::AccountId::from_str(s).map(Self::from)
    }
}

impl TryFrom<&str> for FastAccountId {
    type Error = <near_sdk::AccountId as FromStr>::Err;

    fn try_from(s: &str) -> Result<Self, Self::Error> {
        near_sdk::AccountId::from_str(s).map(Self::from)
    }
}

impl BorshSerialize for FastAccountId {
    fn serialize<W: std::io::Write>(&self, writer: &mut W) -> std::io::Result<()> {
        // A valid NEAR account ID cannot be longer than 64.
        #[allow(clippy::cast_possible_truncation)]
        let len: u8 = self.0.len() as u8;
        writer.write_all(&[len])?;
        let compressed = compress_account_id(&self.0).ok_or(std::io::ErrorKind::InvalidData)?;
        writer.write_all(&compressed)?;
        Ok(())
    }
}

impl BorshDeserialize for FastAccountId {
    fn deserialize_reader<R: std::io::Read>(buf: &mut R) -> std::io::Result<Self> {
        let mut l = [0u8];
        buf.read_exact(&mut l)?;
        let len = l[0] as usize;
        let mut compressed = [0u8; near_sdk::AccountId::MAX_LEN];
        buf.read_exact(&mut compressed[..compressed_size(len)])?;
        let account_id = decompress_account_id(&compressed, len);
        Ok(Self(Rc::from(account_id)))
    }
}

fn append_sub_byte(v: &mut [u8], start_bit: usize, sub_byte: u8, num_bits: usize) {
    assert!(num_bits <= 8);

    let sub_bits = sub_byte & (0b1111_1111 >> (8 - num_bits));

    let bit_offset = start_bit % 8;
    let keep_mask = !select_bits_mask(bit_offset, num_bits);
    let first_byte = (v[start_bit / 8] & keep_mask) | (sub_bits << bit_offset);

    v[start_bit / 8] = first_byte;

    if bit_offset + num_bits > 8 {
        let second_byte = sub_bits >> (8 - bit_offset);
        v[start_bit / 8 + 1] = second_byte;
    }
}

fn read_sub_byte(v: &[u8], start_bit: usize, num_bits: usize) -> u8 {
    assert!(num_bits <= 8);

    let bit_offset = start_bit % 8;
    let keep_mask = select_bits_mask(bit_offset, num_bits);
    let first_byte = v[start_bit / 8] & keep_mask;

    let mut sub_byte = first_byte >> bit_offset;

    if bit_offset + num_bits > 8 {
        let num_bits_second = bit_offset + num_bits - 8;
        let second_byte = v[start_bit / 8 + 1];
        let keep_mask = 0b1111_1111 >> (8 - num_bits_second);
        sub_byte |= (second_byte & keep_mask) << (8 - bit_offset);
    }

    sub_byte
}

const fn select_bits_mask(start_bit_index: usize, num_bits: usize) -> u8 {
    (0b1111_1111 << start_bit_index)
        & (0b1111_1111 >> (8usize.saturating_sub(num_bits + start_bit_index)))
}

fn decompress_account_id(compressed: &[u8], len: usize) -> String {
    let mut s = String::with_capacity(len);
    for i in 0..len {
        let sub_byte = read_sub_byte(compressed, i * 6, 6);
        let c = ALPHABET[sub_byte as usize] as char;
        s.push(c);
    }
    s
}

const fn compressed_size(len: usize) -> usize {
    debug_assert!(
        len <= near_sdk::AccountId::MAX_LEN,
        "Account ID is too long"
    );
    len * 3 / 4 + (len * 3 % 4 > 0) as usize
}

fn compress_account_id(account_id: &str) -> Option<Vec<u8>> {
    let mut v = vec![0u8; compressed_size(account_id.len())];

    let mut i = 0;
    for c in account_id.as_bytes() {
        // ALPHABET is not that long.
        #[allow(clippy::cast_possible_truncation)]
        let index = char_index(*c)? as u8;
        append_sub_byte(&mut v, i, index, 6);
        i += 6;
    }

    Some(v)
}

#[cfg(test)]
mod tests {
    use near_sdk::borsh;

    use super::*;

    #[test]
    fn test_char_index() {
        // because char_index() is implemented using a match so that it is const
        for c in ALPHABET {
            assert_eq!(char_index(*c), ALPHABET.iter().position(|d| d == c));
        }

        assert!(char_index(b'A').is_none());
    }

    #[test]
    fn test_append_sub_byte() {
        let mut v = vec![0u8; 2];
        append_sub_byte(&mut v, 0, 0b111, 3);
        append_sub_byte(&mut v, 3, 0b010, 3);
        append_sub_byte(&mut v, 6, 0b110, 3);
        append_sub_byte(&mut v, 9, 0b111_0101, 7);

        assert_eq!(v, vec![0b1001_0111, 0b1110_1011]);
    }

    #[test]
    fn test_read_sub_byte() {
        let v = vec![0b1001_0111, 0b1110_1011];
        assert_eq!(read_sub_byte(&v, 0, 3), 0b111);
        assert_eq!(read_sub_byte(&v, 3, 3), 0b010);
        assert_eq!(read_sub_byte(&v, 6, 3), 0b110);
        assert_eq!(read_sub_byte(&v, 9, 7), 0b111_0101);
    }

    #[test]
    fn test_compression_decompression() {
        let account_id = "test.near";
        let compressed = compress_account_id(account_id).unwrap();
        assert_eq!(compressed.len(), 7);
        let decompressed = decompress_account_id(&compressed, account_id.len());
        assert_eq!(account_id, decompressed);
    }

    #[test]
    fn test_account_id_borsh() {
        let account_id = "0".repeat(64);
        let sdk_account_id = near_sdk::AccountId::from_str(&account_id).unwrap();
        let expected_serialized_length = 64 * 3 / 4 + 1; // no +1 for remainder (64 * 3 % 4 == 0), but +1 for length
        let account_id = FastAccountId::new_unchecked(&account_id);
        let serialized = borsh::to_vec(&account_id).unwrap();
        assert_eq!(serialized.len(), expected_serialized_length);
        let deserializalized = FastAccountId::try_from_slice(&serialized).unwrap();
        assert_eq!(account_id, deserializalized);

        let sdk_serialized = borsh::to_vec(&sdk_account_id).unwrap();
        assert!(sdk_serialized.len() > serialized.len()); // gottem
    }

    #[test]
    fn various_serializations() {
        let tests = [
            "",
            "1",
            "a",
            "abcdef",
            "a.b.c.d",
            "root.near",
            "system",
            "near",
            "a_b-cdefghijklmnopqrstuvwxy.z0123456789",
            "0000000000000000000000000000000000000000000000000000000000000000",
        ];

        for test in tests {
            let account_id = FastAccountId::new_unchecked(test);
            let serialized = borsh::to_vec(&account_id).unwrap();
            let deserializalized = FastAccountId::try_from_slice(&serialized).unwrap();
            assert_eq!(account_id, deserializalized);
        }
    }
}

'''
'''--- src/hook.rs ---
//! # Hooks
//!
//! Hooks are a way to wrap (inject code before and after) component functions.
//!
//! Most of the time, hooks are used to implement cross-cutting concerns, such as
//! logging, accounting, or integration with other components.
//!
//! ## Example
//!
//! ```
//! use near_sdk::{env, log, near, PanicOnDefault};
//! use near_sdk_contract_tools::{hook::Hook, standard::nep141::*, Nep141};
//!
//! pub struct MyTransferHook;
//!
//! impl Hook<MyContract, Nep141Transfer<'_>> for MyTransferHook {
//!     fn hook<R>(contract: &mut MyContract, transfer: &Nep141Transfer<'_>, f: impl FnOnce(&mut MyContract) -> R) -> R {
//!         // Log, check preconditions, save state, etc.
//!         log!("NEP-141 transfer from {} to {} of {} tokens", transfer.sender_id, transfer.receiver_id, transfer.amount);
//!
//!         let storage_usage_before = env::storage_usage();
//!
//!         let r = f(contract); // execute wrapped function
//!
//!         let storage_usage_after = env::storage_usage();
//!         log!("Storage delta: {}", storage_usage_after - storage_usage_before);
//!
//!         r
//!     }
//! }
//!
//! #[derive(Nep141, PanicOnDefault)]
//! #[nep141(transfer_hook = "MyTransferHook")]
//! #[near(contract_state)]
//! struct MyContract {}
//! ```

/// Generic hook trait for injecting code before and after component functions.
pub trait Hook<C, A = ()> {
    /// Execute a function with hooks.
    fn hook<R>(contract: &mut C, _args: &A, f: impl FnOnce(&mut C) -> R) -> R {
        f(contract)
    }
}

impl<C, A> Hook<C, A> for () {}

impl<C, A, T, U> Hook<C, A> for (T, U)
where
    T: Hook<C, A>,
    U: Hook<C, A>,
{
    fn hook<R>(contract: &mut C, args: &A, f: impl FnOnce(&mut C) -> R) -> R {
        T::hook(contract, args, |contract| U::hook(contract, args, f))
    }
}

'''
'''--- src/lib.rs ---
#![allow(clippy::wildcard_imports)]
#![doc = include_str!("../README.md")]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]

pub use near_sdk_contract_tools_macros::*;

/// Default storage keys used by various traits' `root()` functions.
#[derive(Clone, Debug)]
pub enum DefaultStorageKey {
    /// Default storage key for [`approval::ApprovalManagerInternal::root`].
    ApprovalManager,
    /// Default storage key for [`standard::nep141::Nep141ControllerInternal::root`].
    Nep141,
    /// Default storage key for [`standard::nep145::Nep145ControllerInternal::root`]
    Nep145,
    /// Default storage key for [`standard::nep148::Nep148ControllerInternal::root`].
    Nep148,
    /// Default storage key for [`standard::nep171::Nep171ControllerInternal::root`].
    Nep171,
    /// Default storage key for [`standard::nep177::Nep177ControllerInternal::root`].
    Nep177,
    /// Default storage key for [`standard::nep178::Nep178ControllerInternal::root`].
    Nep178,
    /// Default storage key for [`standard::nep181::Nep181ControllerInternal::root`].
    Nep181,
    /// Default storage key for [`owner::OwnerInternal::root`].
    Owner,
    /// Default storage key for [`pause::PauseInternal::root`].
    Pause,
    /// Default storage key for [`rbac::RbacInternal::root`].
    Rbac,
    /// Default storage key for [`escrow::EscrowInternal::root`]
    Escrow,
}

impl near_sdk::IntoStorageKey for DefaultStorageKey {
    fn into_storage_key(self) -> Vec<u8> {
        match self {
            DefaultStorageKey::ApprovalManager => b"~am".to_vec(),
            DefaultStorageKey::Nep141 => b"~$141".to_vec(),
            DefaultStorageKey::Nep145 => b"~$145".to_vec(),
            DefaultStorageKey::Nep148 => b"~$148".to_vec(),
            DefaultStorageKey::Nep171 => b"~$171".to_vec(),
            DefaultStorageKey::Nep177 => b"~$177".to_vec(),
            DefaultStorageKey::Nep178 => b"~$178".to_vec(),
            DefaultStorageKey::Nep181 => b"~$181".to_vec(),
            DefaultStorageKey::Owner => b"~o".to_vec(),
            DefaultStorageKey::Pause => b"~p".to_vec(),
            DefaultStorageKey::Rbac => b"~r".to_vec(),
            DefaultStorageKey::Escrow => b"~es".to_vec(),
        }
    }
}

pub mod standard;

pub mod approval;
pub mod escrow;
pub mod fast_account_id;
pub mod hook;
pub mod migrate;
pub mod owner;
pub mod pause;
pub mod rbac;
pub mod slot;
pub mod upgrade;
pub mod utils;

/// Re-exports of the NFT standard traits.
pub mod nft {
    pub use crate::{
        standard::{
            nep145::{
                self, ext_nep145, Nep145, Nep145Controller, Nep145ControllerInternal,
                StorageBalance, StorageBalanceBounds,
            },
            nep171::{
                self, action::*, ext_nep171, ext_nep171_receiver, ext_nep171_resolver, Nep171,
                Nep171Controller, Nep171ControllerInternal, Nep171Receiver, Nep171Resolver, Token,
                TokenId,
            },
            nep177::{
                self, ext_nep177, ContractMetadata, Nep177, Nep177Controller,
                Nep177ControllerInternal, TokenMetadata,
            },
            nep178::{
                self, action::*, ext_nep178, ext_nep178_receiver, ApprovalId, Nep178,
                Nep178Controller, Nep178ControllerInternal, Nep178Receiver, TokenApprovals,
            },
            nep181::{
                self, ext_nep181, Nep181, Nep181Controller, Nep181ControllerInternal,
                TokenEnumeration,
            },
        },
        Nep171, Nep177, Nep178, Nep181, NonFungibleToken,
    };
}

/// Re-exports of the FT standard traits.
pub mod ft {
    pub use crate::{
        standard::{
            nep141::{
                self, ext_nep141, ext_nep141_receiver, ext_nep141_resolver, Nep141, Nep141Burn,
                Nep141Controller, Nep141ControllerInternal, Nep141Mint, Nep141Receiver,
                Nep141Resolver, Nep141Transfer,
            },
            nep145::{
                self, ext_nep145, Nep145, Nep145Controller, Nep145ControllerInternal,
                StorageBalance, StorageBalanceBounds,
            },
            nep148::{
                self, ext_nep148, ContractMetadata, Nep148, Nep148Controller,
                Nep148ControllerInternal,
            },
        },
        FungibleToken, Nep141, Nep145, Nep148,
    };
}

'''
'''--- src/migrate.rs ---
//! Migrate pattern implements methods to change the storage representation of a struct.
//!
//! The migration controller takes the old and new schema and deserializes
//! the contract state from the old schema. The [`on_migrate`][`MigrateHook::on_migrate`]
//! method takes this state and replaces it with the new schema.
//! [`MigrateExternal`] exposes this functionality publicly.
//!
//! The crate exports a [derive macro](near_sdk_contract_tools_macros::Migrate)
//! that derives a default implementation for migration.
//!
//! Note: [`MigrateHook`] must be implemented by the user and is not derived
//! by default. It must convert data in the old schema to the new schema without
//! failing. For a complete example checkout [upgrade_new.rs](https://github.com/near/near-sdk-contract-tools/blob/develop/workspaces-tests/src/bin/upgrade_new.rs)
//! in workspace-tests.
//!
//! # Safety
//! The contract state must conform to the old schema otherwise deserializing it
//! will fail and throw an error.
#![allow(missing_docs)] // #[ext_contract(...)] does not play nicely with clippy

use near_sdk::{
    borsh::{BorshDeserialize, BorshSerialize},
    env, ext_contract,
};

// TODO: Migration events?
// *Possibly* unnecessary, since the salient occurence will probably be the instigating event (e.g. a code upgrade)
// Alternative solution: post-migration hook/callback so that the author can implement their own events if desired

/// Conversion between two storage schemas
pub trait MigrateController {
    /// Schema that currently exists in storage, to convert from
    type OldSchema: BorshDeserialize;
    /// Schema that will be used henceforth, to convert into
    type NewSchema: BorshSerialize;

    /// Deserializes the old schema from storage.
    ///
    /// It is probably not necessary to override this function.
    #[must_use]
    fn deserialize_old_schema() -> Self::OldSchema {
        env::state_read::<Self::OldSchema>()
            .unwrap_or_else(|| env::panic_str("Failed to deserialize old state"))
    }
}

/// Called on migration. Must be implemented by the user. (The derive macro
/// does not implement this for you.)
pub trait MigrateHook: MigrateController {
    /// Receives the old schema deserialized from storage as well as optional
    /// arguments from caller, and replaces it with the new schema.
    fn on_migrate(
        old_schema: <Self as MigrateController>::OldSchema,
    ) -> <Self as MigrateController>::NewSchema;
}

/// Migrate-able contracts expose this trait publicly
#[ext_contract(ext_migrate)]
pub trait MigrateExternal {
    /// Perform the migration with optional arguments
    fn migrate();
}

'''
'''--- src/owner.rs ---
//! Owner pattern implements methods to query, manage and transfer ownership
//! of the contract.
//!
//! The account that owns the contract is called the "current" owner. A contract
//! is always initialized with an owner account. The current owner can propose an
//! ownership transfer to a different account. This proposed account is the
//! "proposed owner". If the proposed owner accepts the transfer, it becomes
//! the current owner. The current owner can also renounce ownership of the
//! contract.
//!
//! The owner of the contract may be initialized once (e.g. at contract
//! creation) using [`Owner::init`].
//!
//! Note: There is no way to recover ownership of a renounced contract.
//!
//! The pattern consists of methods in [`Owner`] and [`OwnerExternal`]. The
//! latter exposes methods externally and can be called by other contracts.
//! This [derive macro](near_sdk_contract_tools_macros::Owner)
//! derives default implementation both these traits.
//!
//! # Safety
//! The default implementation assumes or enforces the following invariants.
//! Violating assumed invariants may corrupt contract state and show unexpected
//! behavior (UB). Enforced invariants throw an error (ERR) but contract
//! state remains intact.
//!
//! * (UB) The owner root storage slot is not used or modified. The default key is `~o`.
//! * (ERR) [`Owner::init`] may be called a maximum of one time.
//! * (ERR) Only the current owner can call [`Owner::renounce_owner`] and [`Owner::propose_owner`].
//! * (ERR) Only the proposed owner can call [`Owner::accept_owner`].
//! * (ERR) The external functions exposed in [`OwnerExternal`] call their
//!   respective [`Owner`] methods and expect the same invariants.

use near_sdk::{env, near, require, AccountId, BorshStorageKey};
use near_sdk_contract_tools_macros::event;

use crate::{slot::Slot, standard::nep297::Event, DefaultStorageKey};

const ONLY_OWNER_FAIL_MESSAGE: &str = "Owner only";
const OWNER_INIT_FAIL_MESSAGE: &str = "Owner already initialized";
const NO_OWNER_FAIL_MESSAGE: &str = "No owner";
const ONLY_PROPOSED_OWNER_FAIL_MESSAGE: &str = "Proposed owner only";
const NO_PROPOSED_OWNER_FAIL_MESSAGE: &str = "No proposed owner";

/// Events emitted by function calls on an ownable contract
#[event(
    standard = "x-own",
    version = "1.0.0",
    crate = "crate",
    macros = "near_sdk_contract_tools_macros"
)]
#[derive(Debug, Clone)]
pub enum OwnerEvent {
    /// Emitted when the current owner of the contract changes
    Transfer {
        /// Former owner of the contract. Will be `None` if the contract is being initialized.
        old: Option<AccountId>,
        /// The new owner of the contract. Will be `None` if ownership is renounced.
        new: Option<AccountId>,
    },
    /// Emitted when the proposed owner of the contract changes
    Propose {
        /// Old proposed owner.
        old: Option<AccountId>,
        /// New proposed owner.
        new: Option<AccountId>,
    },
}

#[derive(BorshStorageKey, Debug, Clone)]
#[near]
enum StorageKey {
    IsInitialized,
    Owner,
    ProposedOwner,
}

/// Internal functions for [`Owner`]. Using these methods may result in unexpected behavior.
pub trait OwnerInternal {
    /// Storage root
    #[must_use]
    fn root() -> Slot<()> {
        Slot::new(DefaultStorageKey::Owner)
    }

    /// Storage slot for initialization state
    #[must_use]
    fn slot_is_initialized() -> Slot<bool> {
        Self::root().field(StorageKey::IsInitialized)
    }

    /// Storage slot for owner account ID
    #[must_use]
    fn slot_owner() -> Slot<AccountId> {
        Self::root().field(StorageKey::Owner)
    }

    /// Storage slot for proposed owner account ID
    #[must_use]
    fn slot_proposed_owner() -> Slot<AccountId> {
        Self::root().field(StorageKey::ProposedOwner)
    }
}

/// A contract with an owner.
pub trait Owner {
    /// Updates the current owner and emits relevant event.
    fn update_owner(&mut self, new: Option<AccountId>);

    /// Updates proposed owner and emits relevant event.
    fn update_proposed(&mut self, new: Option<AccountId>);

    /// Updates the current owner without any checks or emitting events.
    fn update_owner_unchecked(&mut self, new: Option<AccountId>);

    /// Updates proposed owner without any checks or emitting events.
    fn update_proposed_unchecked(&mut self, new: Option<AccountId>);

    /// Same as [`require_owner`](Owner::require_owner) but as a method.
    fn assert_owner(&self);

    /// Initializes the contract owner. Can only be called once.
    ///
    /// Emits an `OwnerEvent::Transfer` event.
    ///
    /// # Examples
    ///
    /// ```
    /// use near_sdk::{AccountId, near, PanicOnDefault};
    /// use near_sdk_contract_tools::{Owner, owner::Owner};
    ///
    /// #[derive(Owner, PanicOnDefault)]
    /// #[near(contract_state)]
    /// struct Contract {}
    ///
    /// #[near]
    /// impl Contract {
    ///     #[init]
    ///     pub fn new(owner_id: AccountId) -> Self {
    ///         let mut contract = Self {};
    ///
    ///         Owner::init(&mut contract, &owner_id);
    ///
    ///         contract
    ///     }
    /// }
    /// ```
    fn init(&mut self, owner_id: &AccountId);

    /// Requires the predecessor to be the owner.
    ///
    /// # Examples
    ///
    /// ```
    /// use near_sdk::{AccountId, near, PanicOnDefault};
    /// use near_sdk_contract_tools::{Owner, owner::Owner};
    ///
    /// #[derive(Owner, PanicOnDefault)]
    /// #[near(contract_state)]
    /// struct Contract {}
    ///
    /// #[near]
    /// impl Contract {
    ///     pub fn owner_only(&self) {
    ///         Self::require_owner();
    ///
    ///         // ...
    ///     }
    /// }
    /// ```
    fn require_owner();

    /// Removes the contract's owner. Can only be called by the current owner.
    ///
    /// Emits an `OwnerEvent::Transfer` event, and an `OwnerEvent::Propose`
    /// event if there is a currently proposed owner.
    fn renounce_owner(&mut self);

    /// Prepares the contract to change owners, setting the proposed owner to
    /// the provided account ID. Can only be called by the current owner.
    ///
    /// Emits an `OwnerEvent::Propose` event.
    ///
    /// The currently proposed owner may be reset by calling this function with
    /// the argument `None`.
    fn propose_owner(&mut self, account_id: Option<AccountId>);

    /// Sets new owner equal to proposed owner. Can only be called by proposed
    /// owner.
    ///
    /// Emits events corresponding to the transfer of ownership and reset of the
    /// proposed owner.
    fn accept_owner(&mut self);
}

impl<T: OwnerInternal> Owner for T {
    fn update_owner(&mut self, new: Option<AccountId>) {
        let owner = Self::slot_owner();
        let old = owner.read();
        if old != new {
            OwnerEvent::Transfer {
                old,
                new: new.clone(),
            }
            .emit();
            self.update_owner_unchecked(new);
        }
    }

    fn update_proposed(&mut self, new: Option<AccountId>) {
        let proposed_owner = Self::slot_proposed_owner();
        let old = proposed_owner.read();
        if old != new {
            OwnerEvent::Propose {
                old,
                new: new.clone(),
            }
            .emit();
            self.update_proposed_unchecked(new);
        }
    }

    fn update_owner_unchecked(&mut self, new: Option<AccountId>) {
        let mut owner = Self::slot_owner();
        owner.set(new.as_ref());
    }

    fn update_proposed_unchecked(&mut self, new: Option<AccountId>) {
        let mut proposed_owner = Self::slot_proposed_owner();
        proposed_owner.set(new.as_ref());
    }

    fn assert_owner(&self) {
        require!(
            &env::predecessor_account_id()
                == Self::slot_owner()
                    .read()
                    .as_ref()
                    .unwrap_or_else(|| env::panic_str(NO_OWNER_FAIL_MESSAGE)),
            ONLY_OWNER_FAIL_MESSAGE,
        );
    }

    fn init(&mut self, owner_id: &AccountId) {
        require!(
            !Self::slot_is_initialized().exists(),
            OWNER_INIT_FAIL_MESSAGE,
        );

        Self::slot_is_initialized().write(&true);
        Self::slot_owner().write(owner_id);

        OwnerEvent::Transfer {
            old: None,
            new: Some(owner_id.clone()),
        }
        .emit();
    }

    fn require_owner() {
        require!(
            &env::predecessor_account_id()
                == Self::slot_owner()
                    .read()
                    .as_ref()
                    .unwrap_or_else(|| env::panic_str(NO_OWNER_FAIL_MESSAGE)),
            ONLY_OWNER_FAIL_MESSAGE,
        );
    }

    fn renounce_owner(&mut self) {
        Self::require_owner();

        self.update_proposed(None);
        self.update_owner(None);
    }

    fn propose_owner(&mut self, account_id: Option<AccountId>) {
        Self::require_owner();

        self.update_proposed(account_id);
    }

    fn accept_owner(&mut self) {
        let proposed_owner = Self::slot_proposed_owner()
            .take()
            .unwrap_or_else(|| env::panic_str(NO_PROPOSED_OWNER_FAIL_MESSAGE));

        require!(
            env::predecessor_account_id() == proposed_owner,
            ONLY_PROPOSED_OWNER_FAIL_MESSAGE,
        );

        OwnerEvent::Propose {
            old: Some(proposed_owner.clone()),
            new: None,
        }
        .emit();

        self.update_owner(Some(proposed_owner));
    }
}

pub mod hooks {
    //! Hooks for integrating the owner component with other components.

    use crate::hook::Hook;

    use super::Owner;

    /// Hook that requires the predecessor to be the owner.
    pub struct OnlyOwner;

    impl<C, A> Hook<C, A> for OnlyOwner
    where
        C: Owner,
    {
        fn hook<R>(contract: &mut C, _args: &A, f: impl FnOnce(&mut C) -> R) -> R {
            contract.assert_owner();
            f(contract)
        }
    }
}

mod ext {
    #![allow(missing_docs)] // #[ext_contract(...)] does not play nicely with clippy

    use near_sdk::{ext_contract, AccountId};

    /// Externally-accessible functions for `Owner`.
    #[ext_contract(ext_owner)]
    pub trait OwnerExternal {
        /// Returns the account ID of the current owner.
        fn own_get_owner(&self) -> Option<AccountId>;

        /// Returns the account ID that the current owner has proposed take over ownership.
        fn own_get_proposed_owner(&self) -> Option<AccountId>;

        /// Current owner may call this function to renounce ownership, setting
        /// current owner to `None`.
        ///
        /// **WARNING**: Once this function has been called, this implementation
        /// does not provide a way for the contract to have an owner again!
        fn own_renounce_owner(&mut self);

        /// Propose a new owner. Can only be called by the current owner.
        fn own_propose_owner(&mut self, account_id: Option<AccountId>);

        /// The proposed owner may call this function to accept ownership from the
        /// previous owner.
        fn own_accept_owner(&mut self);
    }
}
pub use ext::*;

#[cfg(test)]
mod tests {
    use near_sdk::{
        near, test_utils::VMContextBuilder, testing_env, AccountId, NearToken, PanicOnDefault,
    };

    use crate::{
        owner::{Owner, OwnerExternal},
        Owner,
    };

    #[derive(Owner, PanicOnDefault)]
    #[owner(crate = "crate")]
    #[near(contract_state)]
    struct Contract {}

    #[allow(clippy::unused_self, clippy::needless_pass_by_value)]
    #[near]
    impl Contract {
        #[init]
        pub fn new(owner_id: AccountId) -> Self {
            let mut contract = Self {};

            Owner::init(&mut contract, &owner_id);

            contract
        }

        pub fn owner_only(&self) {
            Self::require_owner();
        }
    }

    #[test]
    fn require_owner() {
        let owner_id: AccountId = "owner".parse().unwrap();

        let contract = Contract::new(owner_id.clone());

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(owner_id)
            .build());

        contract.owner_only();
    }

    #[test]
    #[should_panic(expected = "Owner only")]
    fn require_owner_fail() {
        let owner_id: AccountId = "owner".parse().unwrap();

        let contract = Contract::new(owner_id);

        let alice: AccountId = "alice".parse().unwrap();

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(alice)
            .build());

        contract.owner_only();
    }

    #[test]
    fn renounce_owner() {
        let owner_id: AccountId = "owner".parse().unwrap();

        let mut contract = Contract::new(owner_id.clone());
        assert_eq!(contract.own_get_owner(), Some(owner_id.clone()));
        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(owner_id)
            .attached_deposit(NearToken::from_yoctonear(1u128))
            .build());
        contract.own_renounce_owner();
        assert_eq!(contract.own_get_owner(), None);
    }

    #[test]
    fn propose_owner() {
        let owner_id: AccountId = "owner".parse().unwrap();
        let mut contract = Contract::new(owner_id.clone());

        let proposed_owner: AccountId = "proposed".parse().unwrap();

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(owner_id)
            .attached_deposit(NearToken::from_yoctonear(1u128))
            .build());

        assert_eq!(contract.own_get_proposed_owner(), None);

        contract.own_propose_owner(Some(proposed_owner.clone()));

        assert_eq!(contract.own_get_proposed_owner(), Some(proposed_owner));
    }

    #[test]
    #[should_panic(expected = "Owner only")]
    fn propose_owner_unauthorized() {
        let owner_id: AccountId = "owner".parse().unwrap();
        let mut contract = Contract::new(owner_id);

        let proposed_owner: AccountId = "proposed".parse().unwrap();

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(proposed_owner.clone())
            .attached_deposit(NearToken::from_yoctonear(1u128))
            .build());

        contract.own_propose_owner(Some(proposed_owner));
    }

    #[test]
    #[should_panic(expected = "Requires attached deposit of exactly 1 yoctoNEAR")]
    fn propose_owner_no_deposit() {
        let owner_id: AccountId = "owner".parse().unwrap();
        let mut contract = Contract::new(owner_id.clone());

        let proposed_owner: AccountId = "proposed".parse().unwrap();

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(owner_id)
            .build());

        contract.own_propose_owner(Some(proposed_owner));
    }

    #[test]
    fn accept_owner() {
        let owner_id: AccountId = "owner".parse().unwrap();

        let mut contract = Contract::new(owner_id.clone());

        let proposed_owner: AccountId = "proposed".parse().unwrap();

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(owner_id)
            .attached_deposit(NearToken::from_yoctonear(1u128))
            .build());

        contract.own_propose_owner(Some(proposed_owner.clone()));

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(proposed_owner.clone())
            .attached_deposit(NearToken::from_yoctonear(1u128))
            .build());

        contract.own_accept_owner();

        assert_eq!(contract.own_get_owner(), Some(proposed_owner));
        assert_eq!(contract.own_get_proposed_owner(), None);
    }

    #[test]
    #[should_panic(expected = "Proposed owner only")]
    fn accept_owner_unauthorized() {
        let owner_id: AccountId = "owner".parse().unwrap();

        let mut contract = Contract::new(owner_id.clone());

        let proposed_owner: AccountId = "proposed".parse().unwrap();

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(owner_id)
            .attached_deposit(NearToken::from_yoctonear(1u128))
            .build());

        contract.own_propose_owner(Some(proposed_owner));

        let third_party: AccountId = "third".parse().unwrap();

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(third_party)
            .attached_deposit(NearToken::from_yoctonear(1u128))
            .build());

        contract.own_accept_owner();
    }

    #[test]
    #[should_panic(expected = "Requires attached deposit of exactly 1 yoctoNEAR")]
    fn accept_owner_no_deposit() {
        let owner_id: AccountId = "owner".parse().unwrap();

        let mut contract = Contract::new(owner_id.clone());

        let proposed_owner: AccountId = "proposed".parse().unwrap();

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(owner_id)
            .attached_deposit(NearToken::from_yoctonear(1u128))
            .build());

        contract.own_propose_owner(Some(proposed_owner.clone()));

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(proposed_owner)
            .build());

        contract.own_accept_owner();
    }

    #[test]
    fn update_owner_unchecked() {
        let owner_id: AccountId = "owner".parse().unwrap();

        let mut contract = Contract::new(owner_id);

        let new_owner: AccountId = "new_owner".parse().unwrap();

        contract.update_owner_unchecked(Some(new_owner.clone()));

        assert_eq!(contract.own_get_owner(), Some(new_owner));
        assert_eq!(contract.own_get_proposed_owner(), None);
    }

    #[test]
    fn update_proposed_unchecked() {
        let owner_id: AccountId = "owner".parse().unwrap();

        let mut contract = Contract::new(owner_id.clone());

        let proposed_owner: AccountId = "proposed".parse().unwrap();

        contract.update_proposed_unchecked(Some(proposed_owner.clone()));

        assert_eq!(contract.own_get_owner(), Some(owner_id));
        assert_eq!(contract.own_get_proposed_owner(), Some(proposed_owner));
    }
}

'''
'''--- src/pause.rs ---
//! Pause pattern implements methods to pause, unpause and get the status of the
//! contract.
//!
//! [`Pause`] implements methods to pause and unpause the contract. When the
//! methods are called the contracts status changes and the respective event
//! is emitted. A contract starts off as "unpaused" by default. [`PauseExternal`]
//! exposes an external function to check the status of the contract.
//!
//! This [derive macro](near_sdk_contract_tools_macros::Pause)
//! derives a default implementation for both these traits.
//!
//! # Safety
//! The default implementation assumes or enforces the following invariants.
//! Violating assumed invariants may corrupt contract state and show unexpected
//! behavior (UB). Enforced invariants throw an error (ERR) but contract
//! state remains intact.
//!
//! * Initial state is unpaused.
//! * (UB) The pause root storage slot is not used or modified. The default key is `~p`.
//! * (ERR) Only an "unpaused" contract can call `pause`.
//! * (ERR) Only a "paused" contract can call `unpause`.
//! * (ERR) [`Pause::require_paused`] may only be called when the contract is paused.
//! * (ERR) [`Pause::require_unpaused`] may only be called when the contract is unpaused.

use crate::{slot::Slot, standard::nep297::Event, DefaultStorageKey};
use near_sdk::require;
use near_sdk_contract_tools_macros::event;

const UNPAUSED_FAIL_MESSAGE: &str = "Disallowed while contract is unpaused";
const PAUSED_FAIL_MESSAGE: &str = "Disallowed while contract is paused";

/// Events emitted when contract pause state is changed
#[event(
    standard = "x-paus",
    version = "1.0.0",
    crate = "crate",
    macros = "near_sdk_contract_tools_macros"
)]
#[derive(Debug, Clone)]
pub enum PauseEvent {
    /// Emitted when the contract is paused
    Pause,
    /// Emitted when the contract is unpaused
    Unpause,
}

/// Internal functions for [`Pause`]. Using these methods may result in unexpected behavior.
pub trait PauseInternal {
    /// Storage root
    #[must_use]
    fn root() -> Slot<()> {
        Slot::new(DefaultStorageKey::Pause)
    }

    /// Storage slot for pause state
    #[must_use]
    fn slot_paused() -> Slot<bool> {
        Self::root().transmute()
    }
}

/// Contract private-only interactions for a pausable contracts.
///
/// # Examples
///
/// ```
/// use near_sdk::{near, PanicOnDefault};
/// use near_sdk_contract_tools::{pause::Pause, Pause};
///
/// #[derive(Pause, PanicOnDefault)]
/// #[near(contract_state)]
/// struct Contract {
///     // ...
/// }
///
/// #[near]
/// impl Contract {
///     pub fn only_when_unpaused(&self) {
///         Self::require_unpaused();
///     }
///
///     pub fn only_when_paused(&self) {
///         Self::require_paused();
///     }
///
///     pub fn emergency_shutdown(&mut self) {
///         self.pause();
///     }
///
///     pub fn emergency_shutdown_end(&mut self) {
///         self.unpause();
///     }
/// }
/// ```
pub trait Pause {
    /// Force the contract pause state in a particular direction.
    /// Does not emit events or check the current pause state.
    fn set_is_paused(&mut self, is_paused: bool);

    /// Returns `true` if the contract is paused, `false` otherwise
    fn is_paused() -> bool;

    /// Pauses the contract if it is currently unpaused, panics otherwise.
    /// Emits a `PauseEvent::Pause` event.
    fn pause(&mut self);

    /// Unpauses the contract if it is currently paused, panics otherwise.
    /// Emits a `PauseEvent::Unpause` event.
    fn unpause(&mut self);

    /// Rejects if the contract is unpaused.
    fn require_paused();

    /// Rejects if the contract is paused.
    fn require_unpaused();
}

impl<T: PauseInternal> Pause for T {
    fn set_is_paused(&mut self, is_paused: bool) {
        Self::slot_paused().write(&is_paused);
    }

    fn is_paused() -> bool {
        Self::slot_paused().read().unwrap_or(false)
    }

    fn pause(&mut self) {
        Self::require_unpaused();
        self.set_is_paused(true);
        PauseEvent::Pause.emit();
    }

    fn unpause(&mut self) {
        Self::require_paused();
        self.set_is_paused(false);
        PauseEvent::Unpause.emit();
    }

    fn require_paused() {
        require!(Self::is_paused(), UNPAUSED_FAIL_MESSAGE);
    }

    fn require_unpaused() {
        require!(!Self::is_paused(), PAUSED_FAIL_MESSAGE);
    }
}

mod ext {
    #![allow(missing_docs)] // #[ext_contract(...)] does not play nicely with clippy

    use near_sdk::ext_contract;

    /// External (public) methods for [`Pause`]
    #[ext_contract(ext_pause)]
    pub trait PauseExternal {
        /// Returns `true` if the contract is paused, `false` otherwise
        fn paus_is_paused(&self) -> bool;
    }
}
pub use ext::*;

pub mod hooks {
    //! Hooks to integrate [`Pause`] with other components.

    use crate::hook::Hook;

    use super::Pause;

    /// Ensures that a contract is unpaused before calling a method.
    pub struct Pausable;

    impl<C, A> Hook<C, A> for Pausable
    where
        C: Pause,
    {
        fn hook<R>(contract: &mut C, _args: &A, f: impl FnOnce(&mut C) -> R) -> R {
            C::require_unpaused();
            f(contract)
        }
    }
}

'''
'''--- src/rbac.rs ---
//! Role-Based Access Control pattern implements methods to manage roles for
//! accounts and control their access.
//!
//! RBAC expects the user to provide a type for [`Rbac::Role`]. Typically,
//! this is an enum and its variants are the distinct roles. An account can be
//! associated with multiple roles. [`Rbac`] implements methods to add, remove,
//! and check an account for a role. It also provides "guard" methods to require
//! or prohibit a particular role. Typically, these are used to guard access to
//! external functions exposed by the contract.
//!
//! This [derive macro](near_sdk_contract_tools_macros::Rbac) derives
//! a default implementation for RBAC. For a complete example check out
//! [`counter_multisig.rs`](https://github.com/near/near-sdk-contract-tools/blob/develop/workspaces-tests/src/bin/counter_multisig.rs)
//! in workspace-tests directory.
//!
//! # Safety
//! The default implementation assumes or enforces the following invariants.
//! Violating assumed invariants may corrupt contract state and show unexpected
//! behavior (UB). "guard" methods enforce invariants and throw an error (ERR)
//! when accessed by unauthorized accounts.
//!
//! * (UB) The rbac root storage slot is not used or modified. The default key
//!     is `~r`.
//! * (ERR) [`Rbac::require_role`] may only be called when the predecessor
//!     account has the specified role.
//! * (ERR) [`Rbac::prohibit_role`] may only be called when the predecessor
//!     account does not have the specified role.
use std::iter::FusedIterator;

use near_sdk::{
    borsh::BorshSerialize, collections::UnorderedSet, env, require, AccountId, BorshStorageKey,
    IntoStorageKey,
};

use crate::{slot::Slot, DefaultStorageKey};

const REQUIRE_ROLE_FAIL_MESSAGE: &str = "Unauthorized role";
const PROHIBIT_ROLE_FAIL_MESSAGE: &str = "Prohibited role";

#[derive(BorshSerialize, BorshStorageKey)]
#[borsh(crate = "near_sdk::borsh")]
enum StorageKey<R> {
    Role(R),
}

/// Internal functions for [`Rbac`]. Using these methods may result in unexpected behavior.
pub trait RbacInternal {
    /// Roles type (probably an enum).
    type Role: BorshSerialize + IntoStorageKey;

    /// Storage slot namespace for items.
    #[must_use]
    fn root() -> Slot<()> {
        Slot::new(DefaultStorageKey::Rbac)
    }

    /// Storage slot for the backing `UnorderedSet` of all accounts assigned
    /// to a role.
    fn slot_members_of(role: &Self::Role) -> Slot<UnorderedSet<AccountId>> {
        Self::root().field::<UnorderedSet<AccountId>>(StorageKey::Role(role))
    }
}

/// Role-based access control
pub trait Rbac {
    /// Roles type (probably an enum).
    type Role: BorshSerialize + IntoStorageKey;

    /// Deserializes the backing `UnorderedSet` structure, executes predicate
    /// `f` on it, reserializes the structure, and writes it back into storage,
    /// returning the return value of `f`.
    fn with_members_of_mut<T>(
        role: &Self::Role,
        f: impl FnOnce(&mut UnorderedSet<AccountId>) -> T,
    ) -> T;

    /// Deserializes the backing `UnorderedSet` structure and executes predicate
    /// `f` on it. Returns the return value of `f`.
    fn with_members_of<T>(role: &Self::Role, f: impl FnOnce(&UnorderedSet<AccountId>) -> T) -> T;

    /// Iterates over all accounts that have been assigned a role.
    fn iter_members_of(role: &Self::Role) -> Iter;

    /// Returns whether a given account has been given a certain role.
    fn has_role(account_id: &AccountId, role: &Self::Role) -> bool;

    /// Assigns a role to an account.
    fn add_role(&mut self, account_id: &AccountId, role: &Self::Role);

    /// Removes a role from an account.
    fn remove_role(&mut self, account_id: &AccountId, role: &Self::Role);

    /// Requires transaction predecessor to have a given role.
    fn require_role(role: &Self::Role);

    /// Requires transaction predecessor to not have a given role.
    fn prohibit_role(role: &Self::Role);
}

impl<I: RbacInternal> Rbac for I {
    type Role = <Self as RbacInternal>::Role;

    fn with_members_of_mut<T>(
        role: &Self::Role,
        f: impl FnOnce(&mut UnorderedSet<AccountId>) -> T,
    ) -> T {
        let mut slot = Self::slot_members_of(role);
        let mut set = slot
            .read()
            .unwrap_or_else(|| UnorderedSet::new(slot.key.clone()));
        let value = f(&mut set);
        slot.write(&set);
        value
    }

    fn with_members_of<T>(role: &Self::Role, f: impl FnOnce(&UnorderedSet<AccountId>) -> T) -> T {
        let slot = Self::slot_members_of(role);
        let set = slot
            .read()
            .unwrap_or_else(|| UnorderedSet::new(slot.key.clone()));
        f(&set)
    }

    fn iter_members_of(role: &Self::Role) -> Iter {
        let slot = Self::slot_members_of(role);
        let set = slot.read().unwrap_or_else(|| UnorderedSet::new(slot.key));
        // Cannot use with_members_of because Iter must be owned
        Iter::new(set)
    }

    fn has_role(account_id: &AccountId, role: &Self::Role) -> bool {
        Self::slot_members_of(role)
            .read()
            .is_some_and(|set| set.contains(account_id))
    }

    fn add_role(&mut self, account_id: &AccountId, role: &Self::Role) {
        Self::with_members_of_mut(role, |set| set.insert(account_id));
    }

    fn remove_role(&mut self, account_id: &AccountId, role: &Self::Role) {
        Self::with_members_of_mut(role, |set| set.remove(account_id));
    }

    fn require_role(role: &Self::Role) {
        let predecessor = env::predecessor_account_id();
        require!(
            Self::has_role(&predecessor, role),
            REQUIRE_ROLE_FAIL_MESSAGE,
        );
    }

    fn prohibit_role(role: &Self::Role) {
        let predecessor = env::predecessor_account_id();
        require!(
            !Self::has_role(&predecessor, role),
            PROHIBIT_ROLE_FAIL_MESSAGE,
        );
    }
}

/// An iterator for `AccountId`s.
pub struct Iter {
    inner_collection: UnorderedSet<AccountId>,
    index: usize,
}

impl Iter {
    /// Creates a new iterator from an `UnorderedSet`.
    #[must_use]
    pub fn new(s: UnorderedSet<AccountId>) -> Self {
        Self {
            inner_collection: s,
            index: 0,
        }
    }
}

// iter.nth always takes a usize, so we truncation unavoidable.
// However, it is vanishingly unlikely that someone will have over u32::MAX
// different roles.
#[allow(clippy::cast_possible_truncation)]
impl Iterator for Iter {
    type Item = AccountId;

    fn next(&mut self) -> Option<Self::Item> {
        let value = self.inner_collection.iter().nth(self.index);
        if value.is_some() {
            self.index += 1;
        }
        value
    }

    fn nth(&mut self, n: usize) -> Option<Self::Item> {
        self.index = usize::min(self.inner_collection.len() as usize, self.index + n);
        self.next()
    }

    #[inline]
    fn count(self) -> usize
    where
        Self: Sized,
    {
        self.inner_collection.len() as usize - self.index
    }

    #[inline]
    fn size_hint(&self) -> (usize, Option<usize>) {
        let s = (self.inner_collection.len() as usize).saturating_sub(self.index);
        (s, Some(s))
    }
}

impl FusedIterator for Iter {}
impl ExactSizeIterator for Iter {}

#[cfg(test)]
mod tests {
    use near_sdk::{
        near, test_utils::VMContextBuilder, testing_env, AccountId, BorshStorageKey, PanicOnDefault,
    };
    use near_sdk_contract_tools_macros::Rbac;

    use super::Rbac;

    #[derive(BorshStorageKey)]
    #[near]
    enum Role {
        A,
        B,
    }

    #[derive(Rbac, PanicOnDefault)]
    #[rbac(roles = "Role", crate = "crate")]
    #[near(contract_state)]
    struct Contract {}

    #[test]
    pub fn empty() {
        let a: AccountId = "account".parse().unwrap();

        assert!(!Contract::has_role(&a, &Role::A));
        assert!(!Contract::has_role(&a, &Role::B));
    }

    #[test]
    pub fn add_role() {
        let mut r = Contract {};
        let a: AccountId = "account".parse().unwrap();

        r.add_role(&a, &Role::A);

        assert!(Contract::has_role(&a, &Role::A));
        assert!(!Contract::has_role(&a, &Role::B));
    }

    #[test]
    pub fn remove_role() {
        let mut r = Contract {};
        let a: AccountId = "account".parse().unwrap();

        r.add_role(&a, &Role::B);
        r.add_role(&a, &Role::A);

        assert!(Contract::has_role(&a, &Role::A));
        assert!(Contract::has_role(&a, &Role::B));

        r.remove_role(&a, &Role::B);

        assert!(Contract::has_role(&a, &Role::A));
        assert!(!Contract::has_role(&a, &Role::B));
    }

    #[test]
    pub fn multiple_accounts() {
        let mut r = Contract {};
        let a: AccountId = "account_a".parse().unwrap();
        let b: AccountId = "account_b".parse().unwrap();

        r.add_role(&a, &Role::B);
        r.add_role(&a, &Role::A);
        r.add_role(&b, &Role::B);
        r.add_role(&b, &Role::A);

        assert!(Contract::has_role(&a, &Role::A));
        assert!(Contract::has_role(&a, &Role::B));
        assert!(Contract::has_role(&b, &Role::A));
        assert!(Contract::has_role(&b, &Role::B));

        r.remove_role(&a, &Role::B);
        r.remove_role(&b, &Role::A);

        assert!(Contract::has_role(&a, &Role::A));
        assert!(!Contract::has_role(&a, &Role::B));
        assert!(!Contract::has_role(&b, &Role::A));
        assert!(Contract::has_role(&b, &Role::B));
    }

    #[test]
    pub fn require_role_success() {
        let mut r = Contract {};
        let a: AccountId = "account".parse().unwrap();

        r.add_role(&a, &Role::A);

        testing_env!(VMContextBuilder::new().predecessor_account_id(a).build());

        Contract::require_role(&Role::A);
    }

    #[test]
    #[should_panic = "Unauthorized role"]
    pub fn require_role_fail_wrong_role() {
        let mut r = Contract {};
        let a: AccountId = "account".parse().unwrap();

        r.add_role(&a, &Role::A);

        testing_env!(VMContextBuilder::new().predecessor_account_id(a).build());

        Contract::require_role(&Role::B);
    }

    #[test]
    #[should_panic = "Unauthorized role"]
    pub fn require_role_fail_no_role() {
        let a: AccountId = "account".parse().unwrap();

        testing_env!(VMContextBuilder::new().predecessor_account_id(a).build());

        Contract::require_role(&Role::B);
    }

    #[test]
    #[should_panic = "Prohibited role"]
    pub fn prohibit_role_fail() {
        let mut r = Contract {};
        let a: AccountId = "account".parse().unwrap();

        r.add_role(&a, &Role::A);

        testing_env!(VMContextBuilder::new().predecessor_account_id(a).build());

        Contract::prohibit_role(&Role::A);
    }

    #[test]
    pub fn prohibit_role_success_diff_role() {
        let mut r = Contract {};
        let a: AccountId = "account".parse().unwrap();

        r.add_role(&a, &Role::A);

        testing_env!(VMContextBuilder::new().predecessor_account_id(a).build());

        Contract::prohibit_role(&Role::B);
    }

    #[test]
    pub fn prohibit_role_success_no_role() {
        let a: AccountId = "account".parse().unwrap();

        testing_env!(VMContextBuilder::new().predecessor_account_id(a).build());

        Contract::prohibit_role(&Role::B);
    }
}

'''
'''--- src/slot.rs ---
//! Managed storage slots
//!
//! Makes it easy to create and manage storage keys and avoid unnecessary
//! writes to contract storage. This reduces transaction IO  and saves on gas.
use std::{marker::PhantomData, ops::Deref};

use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    env, near, IntoStorageKey,
};

use crate::utils::prefix_key;

#[derive(Clone, Debug)]
#[near]
/// A storage slot, composed of a storage location (key) and a data type
pub struct Slot<T> {
    /// The storage key this slot controls.
    pub key: Vec<u8>,
    #[borsh(skip)]
    _marker: PhantomData<T>,
}

impl Slot<()> {
    /// A placeholder slot. Useful for creating namespaced fields.
    pub fn root<K: IntoStorageKey>(key: K) -> Self {
        Self {
            key: key.into_storage_key(),
            _marker: PhantomData,
        }
    }
}

impl<T> Slot<T> {
    /// Creates a new [`Slot`] that controls the given storage key
    pub fn new(key: impl IntoStorageKey) -> Self {
        Self {
            key: key.into_storage_key(),
            _marker: PhantomData,
        }
    }

    /// Creates a new [`Slot`] that controls the given key namespaced (prefixed)
    /// by the parent key, to be used as a namespace for another subfield.
    pub fn ns(&self, key: impl IntoStorageKey) -> Slot<()> {
        Slot {
            key: prefix_key(&self.key, &key.into_storage_key()),
            _marker: PhantomData,
        }
    }

    /// Creates a new [`Slot`] that controls the given key namespaced (prefixed)
    /// by the parent key.
    pub fn field<U>(&self, key: impl IntoStorageKey) -> Slot<U> {
        Slot {
            key: prefix_key(&self.key, &key.into_storage_key()),
            _marker: PhantomData,
        }
    }

    /// Creates a [`Slot`] that tries to parse a different data type from the same
    /// storage slot.
    ///
    /// # Warning
    ///
    /// If the data in the slot is not parsable into the new type, methods like
    /// [`Slot::read`] and [`Slot::take`] will panic.
    #[must_use]
    pub fn transmute<U>(&self) -> Slot<U> {
        Slot {
            key: self.key.clone(),
            _marker: PhantomData,
        }
    }

    /// Write raw bytes into the storage slot. No type checking.
    pub fn write_raw(&mut self, value: &[u8]) -> bool {
        env::storage_write(&self.key, value)
    }

    /// Read raw bytes from the slot. No type checking or parsing.
    #[must_use]
    pub fn read_raw(&self) -> Option<Vec<u8>> {
        env::storage_read(&self.key)
    }

    /// Returns `true` if this slot's key is currently present in the smart
    /// contract storage, `false` otherwise.
    #[must_use]
    pub fn exists(&self) -> bool {
        env::storage_has_key(&self.key)
    }

    /// Removes the managed key from storage.
    pub fn remove(&mut self) -> bool {
        env::storage_remove(&self.key)
    }
}

impl<T: BorshSerialize> Slot<T> {
    /// Writes a value to the managed storage slot.
    ///
    /// # Panics
    ///
    /// If Borsh serialization fails.
    pub fn write(&mut self, value: &T) -> bool {
        self.write_raw(&borsh::to_vec(value).unwrap())
    }

    /// Writes a value to the managed storage slot which is dereferenced from
    /// the target type.
    ///
    /// # Panics
    ///
    /// If Borsh serialization fails.
    pub fn write_deref<U: BorshSerialize + ?Sized>(&mut self, value: &U) -> bool
    where
        T: Deref<Target = U>,
    {
        self.write_raw(&borsh::to_vec(value).unwrap())
    }

    /// If the given value is `Some(T)`, writes `T` to storage. Otherwise,
    /// removes the key from storage.
    pub fn set(&mut self, value: Option<&T>) -> bool {
        match value {
            Some(value) => self.write(value),
            _ => self.remove(),
        }
    }
}

impl<T: BorshDeserialize> Slot<T> {
    /// Reads a value from storage, if present.
    ///
    /// # Panics
    ///
    /// If Borsh deserialization fails.
    #[must_use]
    pub fn read(&self) -> Option<T> {
        self.read_raw().map(|v| T::try_from_slice(&v).unwrap())
    }

    /// Removes a value from storage and returns it if present.
    ///
    /// # Panics
    ///
    /// If Borsh deserialization fails.
    #[must_use]
    pub fn take(&mut self) -> Option<T> {
        if self.remove() {
            // unwrap should be safe if remove returns true
            Some(T::try_from_slice(&env::storage_get_evicted().unwrap()).unwrap())
        } else {
            None
        }
    }
}

impl<T: BorshSerialize + BorshDeserialize> Slot<T> {
    /// Writes a value to storage and returns the evicted value, if present.
    ///
    /// # Panics
    ///
    /// If Borsh serialization fails.
    #[must_use]
    pub fn swap(&mut self, value: &T) -> Option<T> {
        let v = borsh::to_vec(&value).unwrap();

        if self.write_raw(&v) {
            // unwrap should be safe because write_raw returned true
            Some(T::try_from_slice(&env::storage_get_evicted().unwrap()).unwrap())
        } else {
            None
        }
    }
}

impl<T> IntoStorageKey for Slot<T> {
    fn into_storage_key(self) -> Vec<u8> {
        self.key
    }
}

impl<T, U> PartialEq<Slot<U>> for Slot<T> {
    fn eq(&self, other: &Slot<U>) -> bool {
        self.key == other.key
    }
}

#[cfg(test)]
mod tests {
    use super::Slot;

    #[test]
    fn partialeq() {
        let a1 = Slot::<u32>::new(b"a");
        let a2 = Slot::<i32>::new(b"a");
        assert_eq!(a1, a2);
        let b = Slot::<u32>::new(b"b");
        assert_ne!(a1, b);
    }
}

'''
'''--- src/standard/mod.rs ---
//! Implementations of NEP standards.

pub mod nep141;
pub mod nep145;
pub mod nep148;
pub mod nep171;
pub mod nep177;
pub mod nep178;
pub mod nep181;
pub mod nep297;

'''
'''--- src/standard/nep141/error.rs ---
//! Error types for NEP-141 implementations.

use near_sdk::AccountId;
use thiserror::Error;

/// Errors that may occur when withdrawing (burning) tokens.
#[derive(Debug, Error)]
pub enum WithdrawError {
    /// The account does not have enough balance to withdraw the given amount.
    #[error(transparent)]
    BalanceUnderflow(#[from] BalanceUnderflowError),
    /// The total supply is less than the amount to be burned.
    #[error(transparent)]
    TotalSupplyUnderflow(#[from] TotalSupplyUnderflowError),
}

/// An account does not have enough balance to withdraw the given amount.
#[derive(Debug, Error)]
#[error("The account {account_id} does not have enough balance to withdraw {amount} (current balance: {balance}).")]
pub struct BalanceUnderflowError {
    /// The account ID.
    pub account_id: AccountId,
    /// The current balance of the account.
    pub balance: u128,
    /// The amount of the failed withdrawal attempt.
    pub amount: u128,
}

/// The total supply is less than the amount to be burned.
#[derive(Debug, Error)]
#[error("The total supply ({total_supply}) is less than the amount to be burned ({amount}).")]
pub struct TotalSupplyUnderflowError {
    /// The total supply.
    pub total_supply: u128,
    /// The amount of the failed withdrawal attempt.
    pub amount: u128,
}

/// Errors that may occur when depositing (minting) tokens.
#[derive(Debug, Error)]
pub enum DepositError {
    /// The balance of the receiver would overflow u128.
    #[error(transparent)]
    BalanceOverflow(#[from] BalanceOverflowError),
    /// The total supply would overflow u128.
    #[error(transparent)]
    TotalSupplyOverflow(#[from] TotalSupplyOverflowError),
}

/// The balance of the account would overflow u128.
#[derive(Debug, Error)]
#[error("The balance of {account_id} ({balance}) plus {amount} would overflow u128.")]
pub struct BalanceOverflowError {
    /// The account ID.
    pub account_id: AccountId,
    /// The current balance of the account.
    pub balance: u128,
    /// The amount of the failed deposit attempt.
    pub amount: u128,
}

/// The total supply would overflow u128.
#[derive(Debug, Error)]
#[error("The total supply ({total_supply}) plus {amount} would overflow u128.")]
pub struct TotalSupplyOverflowError {
    /// The total supply.
    pub total_supply: u128,
    /// The amount of the failed deposit attempt.
    pub amount: u128,
}

/// Errors that may occur when transferring tokens.
#[derive(Debug, Error)]
pub enum TransferError {
    /// The balance of the receiver would overflow u128.
    #[error("Balance of the receiver would overflow u128: {0}")]
    ReceiverBalanceOverflow(#[from] BalanceOverflowError),
    /// The balance of the sender is insufficient.
    #[error("Balance of the sender is insufficient: {0}")]
    SenderBalanceUnderflow(#[from] BalanceUnderflowError),
}

'''
'''--- src/standard/nep141/event.rs ---
//! NEP-141 standard events for minting, burning, and transferring tokens.

use std::borrow::Cow;

use near_sdk::{
    json_types::U128,
    serde::{Deserialize, Serialize},
    AccountIdRef,
};

use near_sdk_contract_tools_macros::event;

/// NEP-141 standard events for minting, burning, and transferring tokens.
#[event(
    crate = "crate",
    macros = "crate",
    standard = "nep141",
    version = "1.0.0"
)]
#[derive(Debug, Clone)]
pub enum Nep141Event<'a> {
    /// Token mint event. Emitted when tokens are created and total_supply is
    /// increased.
    FtMint(Vec<FtMintData<'a>>),

    /// Token transfer event. Emitted when tokens are transferred between two
    /// accounts. No change to total_supply.
    FtTransfer(Vec<FtTransferData<'a>>),

    /// Token burn event. Emitted when tokens are burned (removed from supply).
    /// Decrease in total_supply.
    FtBurn(Vec<FtBurnData<'a>>),
}

/// Individual mint metadata
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct FtMintData<'a> {
    /// Address to which new tokens were minted
    pub owner_id: Cow<'a, AccountIdRef>,
    /// Amount of minted tokens
    pub amount: U128,
    /// Optional note
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<Cow<'a, str>>,
}

/// Individual transfer metadata
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct FtTransferData<'a> {
    /// Account ID of the sender
    pub old_owner_id: Cow<'a, AccountIdRef>,
    /// Account ID of the receiver
    pub new_owner_id: Cow<'a, AccountIdRef>,
    /// Amount of transferred tokens
    pub amount: U128,
    /// Optional note
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<Cow<'a, str>>,
}

/// Individual burn metadata
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct FtBurnData<'a> {
    /// Account ID from which tokens were burned
    pub owner_id: Cow<'a, AccountIdRef>,
    /// Amount of burned tokens
    pub amount: U128,
    /// Optional note
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<Cow<'a, str>>,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::standard::nep297::Event;

    #[test]
    fn mint() {
        assert_eq!(
            Nep141Event::FtMint(vec![FtMintData {
                owner_id: AccountIdRef::new_or_panic("foundation.near").into(),
                amount: 500u128.into(),
                memo: None,
            }])
            .to_event_string(),
            r#"EVENT_JSON:{"standard":"nep141","version":"1.0.0","event":"ft_mint","data":[{"owner_id":"foundation.near","amount":"500"}]}"#,
        );
    }

    #[test]
    fn transfer() {
        assert_eq!(
            Nep141Event::FtTransfer(vec![
                FtTransferData {
                    old_owner_id: AccountIdRef::new_or_panic("from.near").into(),
                    new_owner_id: AccountIdRef::new_or_panic("to.near").into(),
                    amount: 42u128.into(),
                    memo: Some("hi hello bonjour".into()),
                },
                FtTransferData {
                    old_owner_id: AccountIdRef::new_or_panic("user1.near").into(),
                    new_owner_id: AccountIdRef::new_or_panic("user2.near").into(),
                    amount: 7500u128.into(),
                    memo: None,
                },
            ])
            .to_event_string(),
            r#"EVENT_JSON:{"standard":"nep141","version":"1.0.0","event":"ft_transfer","data":[{"old_owner_id":"from.near","new_owner_id":"to.near","amount":"42","memo":"hi hello bonjour"},{"old_owner_id":"user1.near","new_owner_id":"user2.near","amount":"7500"}]}"#,
        );
    }

    #[test]
    fn burn() {
        assert_eq!(
            Nep141Event::FtBurn(vec![FtBurnData {
                owner_id: AccountIdRef::new_or_panic("foundation.near").into(),
                amount: 100u128.into(),
                memo: None,
            }])
            .to_event_string(),
            r#"EVENT_JSON:{"standard":"nep141","version":"1.0.0","event":"ft_burn","data":[{"owner_id":"foundation.near","amount":"100"}]}"#,
        );
    }
}

'''
'''--- src/standard/nep141/ext.rs ---
#![allow(missing_docs)]

use near_sdk::{ext_contract, json_types::U128, AccountId, Promise, PromiseOrValue};

/// A contract that may be the recipient of an `ft_transfer_call` function
/// call.
#[ext_contract(ext_nep141_receiver)]
pub trait Nep141Receiver {
    /// Function that is called in an `ft_transfer_call` promise chain.
    /// Returns the number of unused tokens, that is, those that the receiver
    /// does not wish to keep. (The contract will attempt to refund the
    /// difference from `amount` to the original sender.)
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;
}

/// Fungible token contract callback after `ft_transfer_call` execution.
#[ext_contract(ext_nep141_resolver)]
pub trait Nep141Resolver {
    /// Callback, last in `ft_transfer_call` promise chain. Returns the amount
    /// of tokens refunded to the original sender.
    fn ft_resolve_transfer(
        &mut self,
        sender_id: AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128;
}

/// Externally-accessible NEP-141-compatible fungible token interface.
#[ext_contract(ext_nep141)]
pub trait Nep141 {
    /// Performs a token transfer
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);

    /// Performs a token transfer, then initiates a promise chain that calls
    /// `ft_on_transfer` on the receiving account, followed by
    /// `ft_resolve_transfer` on the original token contract (this contract).
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> Promise;

    /// Returns the current total amount of tokens tracked by the contract
    fn ft_total_supply(&self) -> U128;

    /// Returns the amount of tokens controlled by `account_id`
    fn ft_balance_of(&self, account_id: AccountId) -> U128;
}

'''
'''--- src/standard/nep141/hooks.rs ---
//! Hooks to integrate NEP-141 with other standards.

use crate::{hook::Hook, standard::nep145::Nep145ForceUnregister};

use super::{Nep141Burn, Nep141Controller, Nep141ControllerInternal};

/// Hook that burns all tokens on NEP-145 force unregister.
pub struct BurnNep141OnForceUnregisterHook;

impl<C: Nep141Controller + Nep141ControllerInternal> Hook<C, Nep145ForceUnregister<'_>>
    for BurnNep141OnForceUnregisterHook
{
    fn hook<R>(
        contract: &mut C,
        args: &Nep145ForceUnregister<'_>,
        f: impl FnOnce(&mut C) -> R,
    ) -> R {
        let r = f(contract);

        let balance = contract.balance_of(&args.account_id);
        contract
            .burn(
                &Nep141Burn::new(balance, args.account_id.clone())
                    .memo("storage forced unregistration"),
            )
            .unwrap_or_else(|e| {
                near_sdk::env::panic_str(&format!(
                    "Failed to burn tokens during forced unregistration: {e}",
                ))
            });

        <C as Nep141ControllerInternal>::slot_account(&args.account_id).remove();

        r
    }
}

'''
'''--- src/standard/nep141/mod.rs ---
//! NEP-141 fungible token core implementation
//! <https://github.com/near/NEPs/blob/master/neps/nep-0141.md>

use std::borrow::Cow;

use near_sdk::{borsh::BorshSerialize, near, AccountIdRef, BorshStorageKey, Gas};

use crate::{hook::Hook, slot::Slot, standard::nep297::*, DefaultStorageKey};

mod error;
pub use error::*;
mod event;
pub use event::*;
mod ext;
pub use ext::*;
pub mod hooks;

/// Gas value required for [`Nep141Resolver::ft_resolve_transfer`] call,
/// independent of the amount of gas required for the preceding
/// [`Nep141::ft_transfer`] call.
pub const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas::from_gas(5_000_000_000_000);
/// Gas value required for [`Nep141::ft_transfer_call`] calls (includes gas for
/// the subsequent [`Nep141Resolver::ft_resolve_transfer`] call).
pub const GAS_FOR_FT_TRANSFER_CALL: Gas =
    Gas::from_gas(25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER.as_gas());
/// Error message for insufficient gas.
pub const MORE_GAS_FAIL_MESSAGE: &str = "Insufficient gas attached.";

#[derive(BorshSerialize, BorshStorageKey)]
#[borsh(crate = "near_sdk::borsh")]
enum StorageKey<'a> {
    TotalSupply,
    Account(&'a AccountIdRef),
}

/// Transfer metadata generic over both types of transfer (`ft_transfer` and
/// `ft_transfer_call`).
#[derive(PartialEq, Eq, Clone, Debug)]
#[near]
pub struct Nep141Transfer<'a> {
    /// Sender's account ID.
    pub sender_id: Cow<'a, AccountIdRef>,
    /// Receiver's account ID.
    pub receiver_id: Cow<'a, AccountIdRef>,
    /// Transferred amount.
    pub amount: u128,
    /// Optional memo string.
    pub memo: Option<Cow<'a, str>>,
    /// Message passed to contract located at `receiver_id`.
    pub msg: Option<Cow<'a, str>>,
    /// Is this transfer a revert as a result of a [`Nep141::ft_transfer_call`] -> [`Nep141Receiver::ft_on_transfer`] call?
    pub revert: bool,
}

impl<'a> Nep141Transfer<'a> {
    /// Create a new transfer action.
    pub fn new(
        amount: u128,
        sender_id: impl Into<Cow<'a, AccountIdRef>>,
        receiver_id: impl Into<Cow<'a, AccountIdRef>>,
    ) -> Self {
        Self {
            sender_id: sender_id.into(),
            receiver_id: receiver_id.into(),
            amount,
            memo: None,
            msg: None,
            revert: false,
        }
    }

    /// Add a memo string.
    #[must_use]
    pub fn memo(self, memo: impl Into<Cow<'a, str>>) -> Self {
        Self {
            memo: Some(memo.into()),
            ..self
        }
    }

    /// Add a message string.
    #[must_use]
    pub fn msg(self, msg: impl Into<Cow<'a, str>>) -> Self {
        Self {
            msg: Some(msg.into()),
            ..self
        }
    }

    /// Returns `true` if this transfer comes from a `ft_transfer_call`
    /// call, `false` otherwise.
    #[must_use]
    pub fn is_transfer_call(&self) -> bool {
        self.msg.is_some()
    }
}

/// Describes a mint operation.
#[derive(Clone, Debug, PartialEq, Eq)]
#[near]
pub struct Nep141Mint<'a> {
    /// Amount to mint.
    pub amount: u128,
    /// Account ID to mint to.
    pub receiver_id: Cow<'a, AccountIdRef>,
    /// Optional memo string.
    pub memo: Option<Cow<'a, str>>,
}

impl<'a> Nep141Mint<'a> {
    /// Create a new mint action.
    pub fn new(amount: u128, receiver_id: impl Into<Cow<'a, AccountIdRef>>) -> Self {
        Self {
            amount,
            receiver_id: receiver_id.into(),
            memo: None,
        }
    }

    /// Add a memo string.
    #[must_use]
    pub fn memo(self, memo: impl Into<Cow<'a, str>>) -> Self {
        Self {
            memo: Some(memo.into()),
            ..self
        }
    }
}

/// Describes a burn operation.
#[derive(Clone, Debug, PartialEq, Eq)]
#[near]
pub struct Nep141Burn<'a> {
    /// Amount to burn.
    pub amount: u128,
    /// Account ID to burn from.
    pub owner_id: Cow<'a, AccountIdRef>,
    /// Optional memo string.
    pub memo: Option<Cow<'a, str>>,
}

impl<'a> Nep141Burn<'a> {
    /// Create a new burn action.
    pub fn new(amount: u128, owner_id: impl Into<Cow<'a, AccountIdRef>>) -> Self {
        Self {
            amount,
            owner_id: owner_id.into(),
            memo: None,
        }
    }

    /// Add a memo string.
    #[must_use]
    pub fn memo(self, memo: impl Into<Cow<'a, str>>) -> Self {
        Self {
            memo: Some(memo.into()),
            ..self
        }
    }
}

/// Internal functions for [`Nep141Controller`]. Using these methods may result in unexpected behavior.
pub trait Nep141ControllerInternal {
    /// Hook for mint operations.
    type MintHook: for<'a> Hook<Self, Nep141Mint<'a>>
    where
        Self: Sized;
    /// Hook for transfer operations.
    type TransferHook: for<'a> Hook<Self, Nep141Transfer<'a>>
    where
        Self: Sized;
    /// Hook for burn operations.
    type BurnHook: for<'a> Hook<Self, Nep141Burn<'a>>
    where
        Self: Sized;

    /// Root storage slot.
    #[must_use]
    fn root() -> Slot<()> {
        Slot::new(DefaultStorageKey::Nep141)
    }

    /// Slot for account data.
    #[must_use]
    fn slot_account(account_id: &AccountIdRef) -> Slot<u128> {
        Self::root().field(StorageKey::Account(account_id))
    }

    /// Slot for storing total supply.
    #[must_use]
    fn slot_total_supply() -> Slot<u128> {
        Self::root().field(StorageKey::TotalSupply)
    }
}

/// Non-public implementations of functions for managing a fungible token.
pub trait Nep141Controller {
    /// Hook for mint operations.
    type MintHook: for<'a> Hook<Self, Nep141Mint<'a>>
    where
        Self: Sized;
    /// Hook for transfer operations.
    type TransferHook: for<'a> Hook<Self, Nep141Transfer<'a>>
    where
        Self: Sized;
    /// Hook for burn operations.
    type BurnHook: for<'a> Hook<Self, Nep141Burn<'a>>
    where
        Self: Sized;

    /// Get the balance of an account. Returns 0 if the account does not exist.
    fn balance_of(&self, account_id: &AccountIdRef) -> u128;

    /// Get the total circulating supply of the token.
    fn total_supply(&self) -> u128;

    /// Removes tokens from an account and decreases total supply. No event
    /// emission or hook invocation.
    ///
    /// # Errors
    ///
    /// - Account balance underflow.
    /// - Total supply underflow.
    fn withdraw_unchecked(
        &mut self,
        account_id: &AccountIdRef,
        amount: u128,
    ) -> Result<(), WithdrawError>;

    /// Increases the token balance of an account. Updates total supply. No
    /// event emission or hook invocation.
    ///
    /// # Errors
    ///
    /// - Account balance overflow.
    /// - Total supply overflow.
    fn deposit_unchecked(
        &mut self,
        account_id: &AccountIdRef,
        amount: u128,
    ) -> Result<(), DepositError>;

    /// Decreases the balance of `sender_account_id` by `amount` and increases
    /// the balance of `receiver_account_id` by the same. No change to total
    /// supply. No event emission or hook invocation.
    ///
    /// # Errors
    ///
    /// - Receiver balance overflow.
    /// - Sender balance underflow.
    fn transfer_unchecked(
        &mut self,
        sender_account_id: &AccountIdRef,
        receiver_account_id: &AccountIdRef,
        amount: u128,
    ) -> Result<(), TransferError>;

    /// Performs an NEP-141 token transfer, with event emission. Invokes
    /// [`Nep141Controller::TransferHook`].
    ///
    /// # Errors
    ///
    /// - Receiver balance overflow.
    /// - Sender balance underflow.
    fn transfer(&mut self, transfer: &Nep141Transfer<'_>) -> Result<(), TransferError>;

    /// Performs an NEP-141 token mint, with event emission. Invokes
    /// [`Nep141Controller::MintHook`].
    ///
    /// # Errors
    ///
    /// - Account balance overflow.
    /// - Total supply overflow.
    fn mint(&mut self, mint: &Nep141Mint<'_>) -> Result<(), DepositError>;

    /// Performs an NEP-141 token burn, with event emission. Invokes
    /// [`Nep141Controller::BurnHook`].
    ///
    /// # Errors
    ///
    /// - Account balance underflow.
    /// - Total supply underflow.
    fn burn(&mut self, burn: &Nep141Burn<'_>) -> Result<(), WithdrawError>;
}

impl<T: Nep141ControllerInternal> Nep141Controller for T {
    type MintHook = T::MintHook;
    type TransferHook = T::TransferHook;
    type BurnHook = T::BurnHook;

    fn balance_of(&self, account_id: &AccountIdRef) -> u128 {
        Self::slot_account(account_id).read().unwrap_or(0)
    }

    fn total_supply(&self) -> u128 {
        Self::slot_total_supply().read().unwrap_or(0)
    }

    fn withdraw_unchecked(
        &mut self,
        account_id: &AccountIdRef,
        amount: u128,
    ) -> Result<(), WithdrawError> {
        if amount != 0 {
            let balance = self.balance_of(account_id);
            if let Some(balance) = balance.checked_sub(amount) {
                Self::slot_account(account_id).write(&balance);
            } else {
                return Err(BalanceUnderflowError {
                    account_id: account_id.to_owned(),
                    balance,
                    amount,
                }
                .into());
            }

            let total_supply = self.total_supply();
            if let Some(total_supply) = total_supply.checked_sub(amount) {
                Self::slot_total_supply().write(&total_supply);
            } else {
                return Err(TotalSupplyUnderflowError {
                    total_supply,
                    amount,
                }
                .into());
            }
        }

        Ok(())
    }

    fn deposit_unchecked(
        &mut self,
        account_id: &AccountIdRef,
        amount: u128,
    ) -> Result<(), DepositError> {
        if amount != 0 {
            let balance = self.balance_of(account_id);
            if let Some(balance) = balance.checked_add(amount) {
                Self::slot_account(account_id).write(&balance);
            } else {
                return Err(BalanceOverflowError {
                    account_id: account_id.to_owned(),
                    balance,
                    amount,
                }
                .into());
            }

            let total_supply = self.total_supply();
            if let Some(total_supply) = total_supply.checked_add(amount) {
                Self::slot_total_supply().write(&total_supply);
            } else {
                return Err(TotalSupplyOverflowError {
                    total_supply,
                    amount,
                }
                .into());
            }
        }

        Ok(())
    }

    fn transfer_unchecked(
        &mut self,
        sender_account_id: &AccountIdRef,
        receiver_account_id: &AccountIdRef,
        amount: u128,
    ) -> Result<(), TransferError> {
        let sender_balance = self.balance_of(sender_account_id);

        if let Some(sender_balance) = sender_balance.checked_sub(amount) {
            let receiver_balance = self.balance_of(receiver_account_id);
            if let Some(receiver_balance) = receiver_balance.checked_add(amount) {
                Self::slot_account(sender_account_id).write(&sender_balance);
                Self::slot_account(receiver_account_id).write(&receiver_balance);
            } else {
                return Err(BalanceOverflowError {
                    account_id: receiver_account_id.to_owned(),
                    balance: receiver_balance,
                    amount,
                }
                .into());
            }
        } else {
            return Err(BalanceUnderflowError {
                account_id: sender_account_id.to_owned(),
                balance: sender_balance,
                amount,
            }
            .into());
        }

        Ok(())
    }

    fn transfer(&mut self, transfer: &Nep141Transfer<'_>) -> Result<(), TransferError> {
        Self::TransferHook::hook(self, transfer, |contract| {
            contract.transfer_unchecked(
                &transfer.sender_id,
                &transfer.receiver_id,
                transfer.amount,
            )?;

            Nep141Event::FtTransfer(vec![FtTransferData {
                old_owner_id: transfer.sender_id.clone(),
                new_owner_id: transfer.receiver_id.clone(),
                amount: transfer.amount.into(),
                memo: transfer.memo.clone(),
            }])
            .emit();

            Ok(())
        })
    }

    fn mint(&mut self, mint: &Nep141Mint) -> Result<(), DepositError> {
        Self::MintHook::hook(self, mint, |contract| {
            contract.deposit_unchecked(&mint.receiver_id, mint.amount)?;

            Nep141Event::FtMint(vec![FtMintData {
                owner_id: mint.receiver_id.clone(),
                amount: mint.amount.into(),
                memo: mint.memo.clone(),
            }])
            .emit();

            Ok(())
        })
    }

    fn burn(&mut self, burn: &Nep141Burn) -> Result<(), WithdrawError> {
        Self::BurnHook::hook(self, burn, |contract| {
            contract.withdraw_unchecked(&burn.owner_id, burn.amount)?;

            Nep141Event::FtBurn(vec![FtBurnData {
                owner_id: burn.owner_id.clone(),
                amount: burn.amount.into(),
                memo: burn.memo.clone(),
            }])
            .emit();

            Ok(())
        })
    }
}

'''
'''--- src/standard/nep145/error.rs ---
//! Error types for the NEP-145 standard.

use near_sdk::{AccountId, NearToken};
use thiserror::Error;

/// Occurs when an account has insufficient storage balance to perform an operation.
#[derive(Debug, Error)]
#[error(
    "Account {account_id} has insufficient balance: {available} available, but attempted to use {attempted_to_use}"
)]
pub struct InsufficientBalanceError {
    /// The account that attempted to perform the operation.
    pub account_id: AccountId,

    /// The amount of storage balance available to the account.
    pub available: NearToken,

    /// The amount of storage balance the account attempted to use.
    pub attempted_to_use: NearToken,
}

/// Occurs when an account is not registered.
#[derive(Debug, Error)]
#[error("Account {0} is not registered")]
pub struct AccountNotRegisteredError(pub AccountId);

/// Occurs when an account attempts to unlock more tokens than it has deposited.
#[derive(Debug, Error)]
#[error("Account {0} cannot unlock more tokens than it has deposited")]
pub struct ExcessiveUnlockError(pub AccountId);

/// Occurs when an account attempts to withdraw more tokens than the contract
/// allows without unregistering.
#[derive(Debug, Error)]
#[error("Account {account_id} must cover the minimum balance {minimum_balance}")]
pub struct MinimumBalanceUnderrunError {
    /// The account that attempted to perform the operation.
    pub account_id: AccountId,

    /// The minimum balance required to remain registered.
    pub minimum_balance: NearToken,
}

/// Occurs when an account attempts to deposit more tokens than the contract
/// allows.
#[derive(Debug, Error)]
#[error("Account {account_id} must not exceed the maximum balance {maximum_balance}")]
pub struct MaximumBalanceOverrunError {
    /// The account that attempted to perform the operation.
    pub account_id: AccountId,

    /// The maximum balance allowed.
    pub maximum_balance: NearToken,
}

/// Occurs when an account attempts to unregister with a locked balance.
#[derive(Debug, Error)]
#[error("Account {account_id} cannot unregister with locked balance {locked_balance} > 0")]
pub struct UnregisterWithLockedBalanceError {
    /// The account that attempted to perform the operation.
    pub account_id: AccountId,

    /// The amount of storage balance locked by the account.
    pub locked_balance: NearToken,
}

/// Errors that can occur when locking storage balance.
#[derive(Debug, Error)]
pub enum StorageLockError {
    /// The account is not registered.
    #[error(transparent)]
    AccountNotRegistered(#[from] AccountNotRegisteredError),
    /// The account has insufficient balance.
    #[error(transparent)]
    InsufficientBalance(#[from] InsufficientBalanceError),
}

/// Errors that can occur when unlocking storage balance.
#[derive(Debug, Error)]
pub enum StorageUnlockError {
    /// The account is not registered.
    #[error(transparent)]
    AccountNotRegistered(#[from] AccountNotRegisteredError),
    /// The account tried to unlock more tokens than it has deposited.
    #[error(transparent)]
    ExcessiveUnlock(#[from] ExcessiveUnlockError),
}

/// Errors that can occur when depositing storage balance.
#[derive(Debug, Error)]
pub enum StorageDepositError {
    /// The deposit does not meet the minimum balance requirement.
    #[error(transparent)]
    MinimumBalanceUnderrun(#[from] MinimumBalanceUnderrunError),
    /// The deposit exceeds the maximum balance limit.
    #[error(transparent)]
    MaximumBalanceOverrunError(#[from] MaximumBalanceOverrunError),
}

/// Errors that can occur when withdrawing storage balance.
#[derive(Debug, Error)]
pub enum StorageWithdrawError {
    /// The account is not registered.
    #[error(transparent)]
    AccountNotRegistered(#[from] AccountNotRegisteredError),
    /// The withdrawal does not keep the minimum balance requirement.
    #[error(transparent)]
    MinimumBalanceUnderrun(#[from] MinimumBalanceUnderrunError),
    /// The withdrawal exceeds the available storage balance.
    #[error(transparent)]
    InsufficientBalance(#[from] InsufficientBalanceError),
}

/// Errors that can occur when unregistering storage balance.
#[derive(Debug, Error)]
pub enum StorageUnregisterError {
    /// The account is not registered.
    #[error(transparent)]
    AccountNotRegistered(#[from] AccountNotRegisteredError),
    /// The account has a locked balance (is still using storage somewhere),
    /// and cannot be unregistered.
    #[error(transparent)]
    UnregisterWithLockedBalance(#[from] UnregisterWithLockedBalanceError),
}

/// Errors that can occur when force-unregistering storage balance.
#[derive(Debug, Error)]
pub enum StorageForceUnregisterError {
    /// The account is not registered.
    #[error(transparent)]
    AccountNotRegistered(#[from] AccountNotRegisteredError),
}

/// Errors that can occur when performing storage accounting.
#[derive(Debug, Error)]
pub enum StorageAccountingError {
    /// Storage lock error.
    #[error(transparent)]
    StorageLock(#[from] StorageLockError),

    /// Storage unlock error.
    #[error(transparent)]
    StorageUnlock(#[from] StorageUnlockError),
}

'''
'''--- src/standard/nep145/ext.rs ---
//! External interface for NEP-145.
#![allow(missing_docs)] // ext_contract doesn't play nice with #![warn(missing_docs)]

use super::{StorageBalance, StorageBalanceBounds};
use near_sdk::{ext_contract, AccountId, NearToken};

/// NEAR uses storage staking which means that a contract account must have
/// sufficient balance to cover all storage added over time. This standard
/// provides a uniform way to pass storage costs onto users.
///
/// # Motivation
///
/// It allows accounts and contracts to:
///
/// - Check an account's storage balance.
/// - Determine the minimum storage needed to add account information such
///     that the account can interact as expected with a contract.
/// - Add storage balance for an account; either one's own or another.
/// - Withdraw some storage deposit by removing associated account data from
///     the contract and then making a call to remove unused deposit.
/// - Unregister an account to recover full storage balance.
#[ext_contract(ext_nep145)]
pub trait Nep145 {
    /// Payable method that receives an attached deposit of NEAR for a given account.
    ///
    /// Returns the updated storage balance record for the given account.
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance;

    /// Withdraw specified amount of available NEAR for predecessor account.
    /// This method is safe to call, and does not remove data.
    ///
    /// Returns the updated storage balance record for the given account.
    fn storage_withdraw(&mut self, amount: Option<NearToken>) -> StorageBalance;

    /// Unregister the predecessor account and withdraw all available NEAR.
    ///
    /// Returns `true` iff the account was successfully unregistered.
    /// Returns `false` iff account was not registered before.
    fn storage_unregister(&mut self, force: Option<bool>) -> bool;

    /// Returns the storage balance for the given account, or `None` if the account
    /// is not registered.
    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance>;

    /// Returns minimum and maximum allowed balance amounts to interact with this
    /// contract. See [`StorageBalanceBounds`] for more details.
    fn storage_balance_bounds(&self) -> StorageBalanceBounds;
}

'''
'''--- src/standard/nep145/hooks.rs ---
//! Hooks to integrate NEP-145 with other components.

use near_sdk::{env, AccountIdRef};

use crate::{
    hook::Hook,
    standard::{
        nep141::{Nep141Burn, Nep141Mint, Nep141Transfer},
        nep171::action::{Nep171Burn, Nep171Mint, Nep171Transfer},
    },
};

use super::Nep145Controller;

fn require_registration(contract: &impl Nep145Controller, account_id: &AccountIdRef) {
    contract
        .get_storage_balance(account_id)
        .unwrap_or_else(|e| env::panic_str(&e.to_string()));
}

fn apply_storage_accounting_hook<C: Nep145Controller, R>(
    contract: &mut C,
    account_id: &AccountIdRef,
    f: impl FnOnce(&mut C) -> R,
) -> R {
    let storage_usage_start = env::storage_usage();
    require_registration(contract, account_id);

    let r = f(contract);

    contract
        .storage_accounting(account_id, storage_usage_start)
        .unwrap_or_else(|e| env::panic_str(&format!("Storage accounting error: {e}")));

    r
}

/// Hook to perform storage accounting before and after a storage write.
pub struct PredecessorStorageAccountingHook;

impl<C: Nep145Controller, A> Hook<C, A> for PredecessorStorageAccountingHook {
    fn hook<R>(contract: &mut C, _args: &A, f: impl FnOnce(&mut C) -> R) -> R {
        apply_storage_accounting_hook(contract, &env::predecessor_account_id(), f)
    }
}

/// NEP-141 support for NEP-145.
pub struct Nep141StorageAccountingHook;

impl<C: Nep145Controller> Hook<C, Nep141Mint<'_>> for Nep141StorageAccountingHook {
    fn hook<R>(contract: &mut C, action: &Nep141Mint<'_>, f: impl FnOnce(&mut C) -> R) -> R {
        apply_storage_accounting_hook(contract, &action.receiver_id, f)
    }
}

impl<C: Nep145Controller> Hook<C, Nep141Transfer<'_>> for Nep141StorageAccountingHook {
    fn hook<R>(contract: &mut C, action: &Nep141Transfer<'_>, f: impl FnOnce(&mut C) -> R) -> R {
        apply_storage_accounting_hook(contract, &action.receiver_id, f)
    }
}

impl<C: Nep145Controller> Hook<C, Nep141Burn<'_>> for Nep141StorageAccountingHook {
    fn hook<R>(contract: &mut C, _action: &Nep141Burn<'_>, f: impl FnOnce(&mut C) -> R) -> R {
        f(contract)
    }
}

/// NEP-171 support for NEP-145.
pub struct Nep171StorageAccountingHook;

impl<C: Nep145Controller> Hook<C, Nep171Mint<'_>> for Nep171StorageAccountingHook {
    fn hook<R>(contract: &mut C, action: &Nep171Mint<'_>, f: impl FnOnce(&mut C) -> R) -> R {
        apply_storage_accounting_hook(contract, &action.receiver_id, f)
    }
}

impl<C: Nep145Controller> Hook<C, Nep171Transfer<'_>> for Nep171StorageAccountingHook {
    fn hook<R>(contract: &mut C, action: &Nep171Transfer<'_>, f: impl FnOnce(&mut C) -> R) -> R {
        apply_storage_accounting_hook(contract, &action.receiver_id, f)
    }
}

impl<C: Nep145Controller> Hook<C, Nep171Burn<'_>> for Nep171StorageAccountingHook {
    fn hook<R>(contract: &mut C, _action: &Nep171Burn<'_>, f: impl FnOnce(&mut C) -> R) -> R {
        f(contract)
    }
}

'''
'''--- src/standard/nep145/mod.rs ---
//! NEP-145 Storage Management
//! <https://github.com/near/NEPs/blob/master/neps/nep-0145.md>

use std::{borrow::Cow, cmp::Ordering};

use near_sdk::{borsh::BorshSerialize, env, near, AccountIdRef, BorshStorageKey, NearToken};

use crate::{hook::Hook, slot::Slot, DefaultStorageKey};

pub mod error;
use error::*;
mod ext;
pub use ext::*;
pub mod hooks;

const PANIC_MESSAGE_STORAGE_TOTAL_OVERFLOW: &str = "storage total balance overflow";
const PANIC_MESSAGE_STORAGE_AVAILABLE_OVERFLOW: &str = "storage available balance overflow";
const PANIC_MESSAGE_STORAGE_FEE_OVERFLOW: &str = "storage fee overflow";
const PANIC_MESSAGE_STORAGE_CREDIT_OVERFLOW: &str = "storage credit overflow";
const PANIC_MESSAGE_INCONSISTENT_STATE_AVAILABLE: &str =
    "inconsistent state: available storage balance greater than total storage balance";

/// An account's storage balance.
#[derive(Clone, Debug, PartialEq, Eq)]
#[near(serializers = [borsh, json])]
pub struct StorageBalance {
    /// The total amount of storage balance.
    pub total: NearToken,

    /// The amount of storage balance that is available for use.
    pub available: NearToken,
}

impl Default for StorageBalance {
    fn default() -> Self {
        Self {
            total: NearToken::from_yoctonear(0),
            available: NearToken::from_yoctonear(0),
        }
    }
}

/// Storage balance bounds.
#[derive(Clone, Debug, PartialEq, Eq)]
#[near(serializers = [borsh, json])]
pub struct StorageBalanceBounds {
    /// The minimum storage balance.
    pub min: NearToken,

    /// The maximum storage balance.
    pub max: Option<NearToken>,
}

impl StorageBalanceBounds {
    /// Restricts a balance to be within the bounds.
    #[must_use]
    pub fn bound(&self, balance: NearToken, registration_only: bool) -> NearToken {
        if registration_only {
            self.min
        } else if let Some(max) = self.max {
            NearToken::from_yoctonear(u128::min(max.as_yoctonear(), balance.as_yoctonear()))
        } else {
            balance
        }
    }
}

impl Default for StorageBalanceBounds {
    fn default() -> Self {
        Self {
            min: NearToken::from_yoctonear(0),
            max: None,
        }
    }
}

#[derive(BorshSerialize, BorshStorageKey)]
#[borsh(crate = "near_sdk::borsh")]
enum StorageKey<'a> {
    BalanceBounds,
    Account(&'a AccountIdRef),
}

/// Describes a force unregister action.
#[derive(Clone, Debug, PartialEq, Eq)]
#[near]
pub struct Nep145ForceUnregister<'a> {
    /// The account to be unregistered.
    pub account_id: Cow<'a, AccountIdRef>,
    /// The account's balance at the time of unregistration.
    pub balance: StorageBalance,
}

/// NEP-145 Storage Management internal controller interface.
pub trait Nep145ControllerInternal {
    /// NEP-145 lifecycle hook.
    type ForceUnregisterHook: for<'a> Hook<Self, Nep145ForceUnregister<'a>>
    where
        Self: Sized;

    /// Root storage slot.
    #[must_use]
    fn root() -> Slot<()> {
        Slot::new(DefaultStorageKey::Nep145)
    }

    /// Storage slot for balance bounds.
    #[must_use]
    fn slot_balance_bounds() -> Slot<StorageBalanceBounds> {
        Slot::new(StorageKey::BalanceBounds)
    }

    /// Storage slot for individual account balance.
    #[must_use]
    fn slot_account(account_id: &AccountIdRef) -> Slot<StorageBalance> {
        Slot::new(StorageKey::Account(account_id))
    }
}

/// NEP-145 Storage Management controller interface. These functions are not directly
/// exposed to the blockchain.
pub trait Nep145Controller {
    /// NEP-145 lifecycle hook.
    type ForceUnregisterHook: for<'a> Hook<Self, Nep145ForceUnregister<'a>>
    where
        Self: Sized;

    /// Returns the storage balance of the given account.
    ///
    /// # Errors
    ///
    /// - If the account is not registered.
    fn get_storage_balance(
        &self,
        account_id: &AccountIdRef,
    ) -> Result<StorageBalance, AccountNotRegisteredError>;

    /// Locks the given amount of storage balance for the given account.
    ///
    /// # Errors
    ///
    /// - If the account is not registered.
    /// - If the account's balance is too low.
    fn lock_storage(
        &mut self,
        account_id: &AccountIdRef,
        amount: NearToken,
    ) -> Result<StorageBalance, StorageLockError>;

    /// Unlocks the given amount of storage balance for the given account.
    ///
    /// # Errors
    ///
    /// - If the account is not registered.
    /// - If the account attempts to unlock more tokens than are deposited.
    fn unlock_storage(
        &mut self,
        account_id: &AccountIdRef,
        amount: NearToken,
    ) -> Result<StorageBalance, StorageUnlockError>;

    /// Deposits the given amount of storage balance for the given account.
    ///
    /// # Errors
    ///
    /// - If the account balance would be less than the minimum balance.
    /// - If the account balance would be greater than the maximum balance.
    fn deposit_to_storage_account(
        &mut self,
        account_id: &AccountIdRef,
        amount: NearToken,
    ) -> Result<StorageBalance, StorageDepositError>;

    /// Withdraws the given amount of storage balance for the given account.
    ///
    /// # Errors
    ///
    /// - If the account is not registered.
    /// - If the account attempts to withdraw more tokens than are deposited.
    /// - If the account balance would be less than the minimum balance.
    fn withdraw_from_storage_account(
        &mut self,
        account_id: &AccountIdRef,
        amount: NearToken,
    ) -> Result<StorageBalance, StorageWithdrawError>;

    /// Unregisters the given account, returning the amount of storage balance
    /// that should be refunded.
    ///
    /// # Errors
    ///
    /// - If the account is not registered.
    /// - If the account still has a locked balance.
    fn unregister_storage_account(
        &mut self,
        account_id: &AccountIdRef,
    ) -> Result<NearToken, StorageUnregisterError>;

    /// Force unregisters the given account, returning the amount of storage balance
    /// that should be refunded.
    ///
    /// # Errors
    ///
    /// - If the account is not registered.
    fn force_unregister_storage_account(
        &mut self,
        account_id: &AccountIdRef,
    ) -> Result<NearToken, StorageForceUnregisterError>;

    /// Returns the storage balance bounds for the contract.
    fn get_storage_balance_bounds(&self) -> StorageBalanceBounds;

    /// Sets the storage balance bounds for the contract.
    fn set_storage_balance_bounds(&mut self, bounds: &StorageBalanceBounds);

    /// Convenience method for performing storage accounting, to be used after
    /// storage writes that are to be debited from the account's balance.
    ///
    /// # Errors
    ///
    /// See: [`lock_storage`](Nep145Controller::lock_storage) and [`unlock_storage`](Nep145Controller::unlock_storage).
    fn storage_accounting(
        &mut self,
        account_id: &AccountIdRef,
        storage_usage_start: u64,
    ) -> Result<(), StorageAccountingError> {
        let storage_usage_end = env::storage_usage();

        match storage_usage_end.cmp(&storage_usage_start) {
            Ordering::Equal => {}
            Ordering::Greater => {
                let storage_consumed = storage_usage_end - storage_usage_start;
                let storage_fee = env::storage_byte_cost()
                    .checked_mul(u128::from(storage_consumed))
                    .unwrap_or_else(|| env::panic_str(PANIC_MESSAGE_STORAGE_FEE_OVERFLOW));

                Nep145Controller::lock_storage(self, account_id, storage_fee)?;
            }
            Ordering::Less => {
                let storage_released = storage_usage_start - storage_usage_end;
                let storage_credit = env::storage_byte_cost()
                    .checked_mul(u128::from(storage_released))
                    .unwrap_or_else(|| env::panic_str(PANIC_MESSAGE_STORAGE_CREDIT_OVERFLOW));

                Nep145Controller::unlock_storage(self, account_id, storage_credit)?;
            }
        };

        Ok(())
    }
}

impl<T: Nep145ControllerInternal> Nep145Controller for T {
    type ForceUnregisterHook = <Self as Nep145ControllerInternal>::ForceUnregisterHook;

    fn get_storage_balance(
        &self,
        account_id: &AccountIdRef,
    ) -> Result<StorageBalance, AccountNotRegisteredError> {
        Self::slot_account(account_id)
            .read()
            .ok_or_else(|| AccountNotRegisteredError(account_id.to_owned()))
    }

    fn lock_storage(
        &mut self,
        account_id: &AccountIdRef,
        amount: NearToken,
    ) -> Result<StorageBalance, StorageLockError> {
        let mut account_slot = Self::slot_account(account_id);
        let mut balance = account_slot
            .read()
            .ok_or(AccountNotRegisteredError(account_id.to_owned()))?;

        balance.available =
            balance
                .available
                .checked_sub(amount)
                .ok_or(InsufficientBalanceError {
                    account_id: account_id.to_owned(),
                    attempted_to_use: amount,
                    available: balance.available,
                })?;

        account_slot.write(&balance);

        Ok(balance)
    }

    fn unlock_storage(
        &mut self,
        account_id: &AccountIdRef,
        amount: NearToken,
    ) -> Result<StorageBalance, StorageUnlockError> {
        let mut account_slot = Self::slot_account(account_id);

        let mut balance = account_slot
            .read()
            .ok_or(AccountNotRegisteredError(account_id.to_owned()))?;

        balance.available = {
            let new_available = balance
                .available
                .checked_add(amount)
                .unwrap_or_else(|| env::panic_str(PANIC_MESSAGE_STORAGE_AVAILABLE_OVERFLOW));

            if new_available > balance.total {
                return Err(ExcessiveUnlockError(account_id.to_owned()).into());
            }

            new_available
        };

        account_slot.write(&balance);

        Ok(balance)
    }

    fn deposit_to_storage_account(
        &mut self,
        account_id: &AccountIdRef,
        amount: NearToken,
    ) -> Result<StorageBalance, StorageDepositError> {
        let mut account_slot = Self::slot_account(account_id);

        let mut balance = account_slot.read().unwrap_or_default();

        balance.total = {
            let new_total = balance
                .total
                .checked_add(amount)
                .unwrap_or_else(|| env::panic_str(PANIC_MESSAGE_STORAGE_TOTAL_OVERFLOW));

            let bounds = self.get_storage_balance_bounds();

            if new_total < bounds.min {
                return Err(MinimumBalanceUnderrunError {
                    account_id: account_id.to_owned(),
                    minimum_balance: bounds.min,
                }
                .into());
            }

            if let Some(maximum_balance) = bounds.max {
                if new_total > maximum_balance {
                    return Err(MaximumBalanceOverrunError {
                        account_id: account_id.to_owned(),
                        maximum_balance,
                    }
                    .into());
                }
            }

            new_total
        };

        balance.available = balance
            .available
            .checked_add(amount)
            .unwrap_or_else(|| env::panic_str(PANIC_MESSAGE_INCONSISTENT_STATE_AVAILABLE));

        account_slot.write(&balance);

        Ok(balance)
    }

    fn withdraw_from_storage_account(
        &mut self,
        account_id: &AccountIdRef,
        amount: NearToken,
    ) -> Result<StorageBalance, StorageWithdrawError> {
        let mut account_slot = Self::slot_account(account_id);

        let mut balance = account_slot
            .read()
            .ok_or_else(|| AccountNotRegisteredError(account_id.to_owned()))?;

        balance.available =
            balance
                .available
                .checked_sub(amount)
                .ok_or_else(|| InsufficientBalanceError {
                    account_id: account_id.to_owned(),
                    available: balance.available,
                    attempted_to_use: amount,
                })?;

        balance.total = {
            let bounds = self.get_storage_balance_bounds();

            balance
                .total
                .checked_sub(amount)
                .filter(|&new_total| new_total >= bounds.min)
                .ok_or(MinimumBalanceUnderrunError {
                    account_id: account_id.to_owned(),
                    minimum_balance: bounds.min,
                })?
        };

        account_slot.write(&balance);

        Ok(balance)
    }

    fn unregister_storage_account(
        &mut self,
        account_id: &AccountIdRef,
    ) -> Result<NearToken, StorageUnregisterError> {
        let mut account_slot = Self::slot_account(account_id);

        let balance = account_slot
            .read()
            .ok_or_else(|| AccountNotRegisteredError(account_id.to_owned()))?;

        match balance.total.checked_sub(balance.available) {
            Some(locked_balance) if !locked_balance.is_zero() => {
                return Err(UnregisterWithLockedBalanceError {
                    account_id: account_id.to_owned(),
                    locked_balance,
                }
                .into())
            }
            None => env::panic_str(PANIC_MESSAGE_INCONSISTENT_STATE_AVAILABLE),
            _ => {}
        }

        account_slot.remove();

        Ok(balance.total)
    }

    fn force_unregister_storage_account(
        &mut self,
        account_id: &AccountIdRef,
    ) -> Result<NearToken, StorageForceUnregisterError> {
        let mut account_slot = Self::slot_account(account_id);

        let balance = account_slot
            .read()
            .ok_or_else(|| AccountNotRegisteredError(account_id.to_owned()))?;

        let action = Nep145ForceUnregister {
            account_id: account_id.into(),
            balance,
        };

        Self::ForceUnregisterHook::hook(self, &action, |_| {
            account_slot.remove();
        });

        Ok(action.balance.available)
    }

    fn get_storage_balance_bounds(&self) -> StorageBalanceBounds {
        Self::slot_balance_bounds().read().unwrap_or_default()
    }

    fn set_storage_balance_bounds(&mut self, bounds: &StorageBalanceBounds) {
        Self::slot_balance_bounds().write(bounds);
    }
}

'''
'''--- src/standard/nep148.rs ---
//! NEP-148 fungible token metadata implementation
//! <https://github.com/near/NEPs/blob/master/neps/nep-0148.md>

use near_sdk::{env, json_types::Base64VecU8, near, BorshStorageKey};

use crate::{slot::Slot, DefaultStorageKey};

pub use ext::*;

/// Version of the NEP-148 metadata spec.
pub const FT_METADATA_SPEC: &str = "ft-1.0.0";
/// Error message for unset metadata.
pub const ERR_METADATA_UNSET: &str = "NEP-148 metadata is not set";

/// NEP-148-compatible metadata struct
#[derive(Eq, PartialEq, Clone, Debug)]
#[near(serializers = [borsh, json])]
pub struct ContractMetadata {
    /// Version of the NEP-148 spec
    pub spec: String,
    /// Human-friendly name of the token contract
    pub name: String,
    /// Short, ideally unique string to concisely identify the token contract
    pub symbol: String,
    /// String representation (HTTP URL, data URL, IPFS, Arweave, etc.) of an
    /// icon for this token
    pub icon: Option<String>,
    /// External (off-chain) URL to additional JSON metadata for this token contract
    pub reference: Option<String>,
    /// Hash of the content that should be present in the `reference` field.
    /// For tamper protection.
    pub reference_hash: Option<Base64VecU8>,
    /// Cosmetic. Number of base-10 decimal places to shift the floating point.
    /// 24 is a common value.
    pub decimals: u8,
}

impl ContractMetadata {
    /// Creates a new metadata struct.
    #[must_use]
    pub fn new(name: impl Into<String>, symbol: impl Into<String>, decimals: u8) -> Self {
        Self {
            spec: FT_METADATA_SPEC.into(),
            name: name.into(),
            symbol: symbol.into(),
            icon: None,
            reference: None,
            reference_hash: None,
            decimals,
        }
    }

    /// Sets the spec field.
    #[must_use]
    pub fn spec(mut self, spec: impl Into<String>) -> Self {
        self.spec = spec.into();
        self
    }

    /// Sets the name field.
    #[must_use]
    pub fn name(mut self, name: impl Into<String>) -> Self {
        self.name = name.into();
        self
    }

    /// Sets the symbol field.
    #[must_use]
    pub fn symbol(mut self, symbol: impl Into<String>) -> Self {
        self.symbol = symbol.into();
        self
    }

    /// Sets the icon field.
    #[must_use]
    pub fn icon(mut self, icon: impl Into<String>) -> Self {
        self.icon = Some(icon.into());
        self
    }

    /// Sets the reference field.
    #[must_use]
    pub fn reference(mut self, reference: impl Into<String>) -> Self {
        self.reference = Some(reference.into());
        self
    }

    /// Sets the `reference_hash` field.
    #[must_use]
    pub fn reference_hash(mut self, reference_hash: impl Into<Base64VecU8>) -> Self {
        self.reference_hash = Some(reference_hash.into());
        self
    }

    /// Sets the decimals field.
    #[must_use]
    pub fn decimals(mut self, decimals: u8) -> Self {
        self.decimals = decimals;
        self
    }
}

#[derive(BorshStorageKey)]
#[near]
enum StorageKey {
    Metadata,
}

/// Internal functions for [`Nep148Controller`].
pub trait Nep148ControllerInternal {
    /// Returns the root storage slot for NEP-148.
    #[must_use]
    fn root() -> Slot<()> {
        Slot::new(DefaultStorageKey::Nep148)
    }

    /// Returns the storage slot for NEP-148 metadata.
    #[must_use]
    fn metadata() -> Slot<ContractMetadata> {
        Self::root().field(StorageKey::Metadata)
    }
}

/// Management functions for NEP-148.
pub trait Nep148Controller {
    /// Returns the metadata struct for this contract.
    ///
    /// # Panics
    ///
    /// Panics if the metadata has not been set.
    fn get_metadata(&self) -> ContractMetadata;

    /// Sets the metadata struct for this contract.
    fn set_metadata(&mut self, metadata: &ContractMetadata);
}

impl<T: Nep148ControllerInternal> Nep148Controller for T {
    fn get_metadata(&self) -> ContractMetadata {
        Self::metadata()
            .read()
            .unwrap_or_else(|| env::panic_str(ERR_METADATA_UNSET))
    }

    fn set_metadata(&mut self, metadata: &ContractMetadata) {
        Self::metadata().set(Some(metadata));
    }
}

mod ext {
    #![allow(missing_docs)] // ext_contract doesn't play well

    use near_sdk::ext_contract;

    use super::ContractMetadata;

    /// Contract that supports the NEP-148 metadata standard
    #[ext_contract(ext_nep148)]
    pub trait Nep148 {
        /// Returns the metadata struct for this contract.
        fn ft_metadata(&self) -> ContractMetadata;
    }
}

'''
'''--- src/standard/nep171/action.rs ---
//! NEP-171 actions.
//!
//! Used when calling various functions on [`Nep171Controller`]. Also used when
//! implementing [`Hook`]s for the NEP-171 component.

use std::borrow::Cow;

use super::*;

/// NEP-171 mint action.
#[derive(Clone, Debug, PartialEq, Eq)]
#[near]
pub struct Nep171Mint<'a> {
    /// Token IDs to mint.
    pub token_ids: Vec<TokenId>,
    /// Account ID of the receiver.
    pub receiver_id: Cow<'a, AccountIdRef>,
    /// Optional memo string.
    pub memo: Option<Cow<'a, str>>,
}

impl<'a> Nep171Mint<'a> {
    /// Create a new mint action.
    pub fn new(token_ids: Vec<TokenId>, receiver_id: impl Into<Cow<'a, AccountIdRef>>) -> Self {
        Self {
            token_ids,
            receiver_id: receiver_id.into(),
            memo: None,
        }
    }

    /// Add a memo string.
    #[must_use]
    pub fn memo(self, memo: impl Into<Cow<'a, str>>) -> Self {
        Self {
            memo: Some(memo.into()),
            ..self
        }
    }
}

/// NEP-171 burn action.
#[derive(Clone, Debug, PartialEq, Eq)]
#[near]
pub struct Nep171Burn<'a> {
    /// Token IDs to burn.
    pub token_ids: Vec<TokenId>,
    /// Account ID of the owner.
    pub owner_id: Cow<'a, AccountIdRef>,
    /// Optional memo string.
    pub memo: Option<Cow<'a, str>>,
}

impl<'a> Nep171Burn<'a> {
    /// Create a new burn action.
    pub fn new(token_ids: Vec<TokenId>, owner_id: impl Into<Cow<'a, AccountIdRef>>) -> Self {
        Self {
            token_ids,
            owner_id: owner_id.into(),
            memo: None,
        }
    }

    /// Add a memo string.
    #[must_use]
    pub fn memo(self, memo: impl Into<Cow<'a, str>>) -> Self {
        Self {
            memo: Some(memo.into()),
            ..self
        }
    }
}

/// Transfer metadata generic over both types of transfer (`nft_transfer` and
/// `nft_transfer_call`).
#[derive(PartialEq, Eq, Clone, Debug, Hash)]
#[near]
pub struct Nep171Transfer<'a> {
    /// Why is this sender allowed to perform this transfer?
    pub authorization: Nep171TransferAuthorization,
    /// Sending account ID.
    pub sender_id: Cow<'a, AccountIdRef>,
    /// Receiving account ID.
    pub receiver_id: Cow<'a, AccountIdRef>,
    /// Token ID.
    pub token_id: TokenId,
    /// Optional memo string.
    pub memo: Option<Cow<'a, str>>,
    /// Message passed to contract located at `receiver_id` in the case of `nft_transfer_call`.
    pub msg: Option<Cow<'a, str>>,
    /// `true` if the transfer is a revert for a `nft_transfer_call`.
    pub revert: bool,
}

impl<'a> Nep171Transfer<'a> {
    /// Create a new transfer action.
    pub fn new(
        token_id: TokenId,
        sender_id: impl Into<Cow<'a, AccountIdRef>>,
        receiver_id: impl Into<Cow<'a, AccountIdRef>>,
        authorization: Nep171TransferAuthorization,
    ) -> Self {
        Self {
            authorization,
            sender_id: sender_id.into(),
            receiver_id: receiver_id.into(),
            token_id,
            memo: None,
            msg: None,
            revert: false,
        }
    }

    /// Add a memo string.
    #[must_use]
    pub fn memo(self, memo: impl Into<Cow<'a, str>>) -> Self {
        Self {
            memo: Some(memo.into()),
            ..self
        }
    }

    /// Add a message string.
    #[must_use]
    pub fn msg(self, msg: impl Into<Cow<'a, str>>) -> Self {
        Self {
            msg: Some(msg.into()),
            ..self
        }
    }
}

'''
'''--- src/standard/nep171/error.rs ---
//! Potential errors produced by various token manipulations.

use near_sdk::AccountId;
use thiserror::Error;

use crate::standard::nep178::ApprovalId;

use super::TokenId;

/// Potential errors encountered when performing a burn operation.
#[derive(Error, Clone, Debug)]
pub enum Nep171BurnError {
    /// The token could not be burned because it does not exist.
    #[error(transparent)]
    TokenDoesNotExist(#[from] TokenDoesNotExistError),
    /// The token could not be burned because it is not owned by the expected owner.
    #[error(transparent)]
    TokenNotOwnedByExpectedOwner(#[from] TokenNotOwnedByExpectedOwnerError),
}

/// Potential errors encountered when attempting to mint a new token.
#[derive(Error, Clone, Debug)]
pub enum Nep171MintError {
    /// The token could not be minted because a token with the same ID already exists.
    #[error(transparent)]
    TokenAlreadyExists(#[from] TokenAlreadyExistsError),
}

/// Potential errors encountered when performing a token transfer.
#[derive(Error, Clone, Debug)]
pub enum Nep171TransferError {
    /// The token could not be transferred because it does not exist.
    #[error(transparent)]
    TokenDoesNotExist(#[from] TokenDoesNotExistError),
    /// The token could not be transferred because the sender is not allowed to perform transfers of this token on behalf of its current owner. See: NEP-178.
    ///
    /// NOTE: If you only implement NEP-171, approval IDs will _not work_, and this error will always be returned whenever the sender is not the current owner.
    #[error(transparent)]
    SenderNotApproved(#[from] SenderNotApprovedError),
    /// The token could not be transferred because the token is being sent to the account that currently owns it. Reflexive transfers are not allowed.
    #[error(transparent)]
    TokenReceiverIsCurrentOwner(#[from] TokenReceiverIsCurrentOwnerError),
    /// The token could not be transferred because it is no longer owned by the expected owner.
    #[error(transparent)]
    TokenNotOwnedByExpectedOwner(#[from] TokenNotOwnedByExpectedOwnerError),
}

/// Occurs when trying to create a token ID that already exists.
/// Overwriting pre-existing token IDs is not allowed.
#[derive(Error, Clone, Debug)]
#[error("Token `{token_id}` already exists")]
pub struct TokenAlreadyExistsError {
    /// The conflicting token ID.
    pub token_id: TokenId,
}

/// When attempting to interact with a non-existent token ID.
#[derive(Error, Clone, Debug)]
#[error("Token `{token_id}` does not exist")]
pub struct TokenDoesNotExistError {
    /// The invalid token ID.
    pub token_id: TokenId,
}

/// Occurs when performing a checked operation that expects a token to be
/// owned by a particular account, but the token is _not_ owned by that
/// account.
#[derive(Error, Clone, Debug)]
#[error("Token `{token_id}` is owned by `{owner_id}` instead of expected `{expected_owner_id}`")]
pub struct TokenNotOwnedByExpectedOwnerError {
    /// The token was supposed to be owned by this account.
    pub expected_owner_id: AccountId,
    /// The token is actually owned by this account.
    pub owner_id: AccountId,
    /// The ID of the token in question.
    pub token_id: TokenId,
}

/// Occurs when a particular account is not allowed to transfer a token (e.g. on behalf of another user). See: NEP-178.
#[derive(Error, Clone, Debug)]
#[error("Sender `{sender_id}` does not have permission to transfer token `{token_id}`, owned by `{owner_id}`, with approval ID {approval_id}")]
pub struct SenderNotApprovedError {
    /// The unapproved sender.
    pub sender_id: AccountId,
    /// The owner of the token.
    pub owner_id: AccountId,
    /// The ID of the token in question.
    pub token_id: TokenId,
    /// The approval ID that the sender tried to use to transfer the token.
    pub approval_id: ApprovalId,
}

/// Occurs when attempting to perform a transfer of a token from one
/// account to the same account.
#[derive(Error, Clone, Debug)]
#[error(
    "Receiver must be different from current owner `{owner_id}` to transfer token `{token_id}`"
)]
pub struct TokenReceiverIsCurrentOwnerError {
    /// The account ID of current owner of the token.
    pub owner_id: AccountId,
    /// The ID of the token in question.
    pub token_id: TokenId,
}

'''
'''--- src/standard/nep171/event.rs ---
//! Event log metadata & associated structures.

use std::borrow::Cow;

use near_sdk::{
    serde::{Deserialize, Serialize},
    AccountIdRef,
};
use near_sdk_contract_tools_macros::event;

/// NEP-171 standard events.
#[event(
    crate = "crate",
    macros = "near_sdk_contract_tools_macros",
    standard = "nep171",
    version = "1.2.0"
)]
#[derive(Debug, Clone)]
pub enum Nep171Event<'a> {
    /// Emitted when a token is newly minted.
    NftMint(Vec<NftMintLog<'a>>),
    /// Emitted when a token is transferred between two parties.
    NftTransfer(Vec<NftTransferLog<'a>>),
    /// Emitted when a token is burned.
    NftBurn(Vec<NftBurnLog<'a>>),
    /// Emitted when the metadata associated with an NFT contract is updated.
    NftMetadataUpdate(Vec<NftMetadataUpdateLog<'a>>),
    /// Emitted when the metadata associated with an NFT contract is updated.
    ContractMetadataUpdate(Vec<NftContractMetadataUpdateLog<'a>>),
}

/// Tokens minted to a single owner.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct NftMintLog<'a> {
    /// To whom were the new tokens minted?
    pub owner_id: Cow<'a, AccountIdRef>,
    /// Which tokens were minted?
    pub token_ids: Vec<Cow<'a, str>>,
    /// Additional mint information.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<Cow<'a, str>>,
}

/// Tokens are transferred from one account to another.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct NftTransferLog<'a> {
    /// NEP-178 authorized account ID.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorized_id: Option<Cow<'a, AccountIdRef>>,
    /// Account ID of the previous owner.
    pub old_owner_id: Cow<'a, AccountIdRef>,
    /// Account ID of the new owner.
    pub new_owner_id: Cow<'a, AccountIdRef>,
    /// IDs of the transferred tokens.
    pub token_ids: Vec<Cow<'a, str>>,
    /// Additional transfer information.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<Cow<'a, str>>,
}

/// Tokens are burned from a single holder.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct NftBurnLog<'a> {
    /// What is the ID of the account from which the tokens were burned?
    pub owner_id: Cow<'a, AccountIdRef>,
    /// IDs of the burned tokens.
    pub token_ids: Vec<Cow<'a, str>>,
    /// NEP-178 authorized account ID.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorized_id: Option<Cow<'a, AccountIdRef>>,
    /// Additional burn information.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<Cow<'a, str>>,
}

/// Token metadata update.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct NftMetadataUpdateLog<'a> {
    /// IDs of the updated tokens.
    pub token_ids: Vec<Cow<'a, str>>,
    /// Additional update information.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<Cow<'a, str>>,
}

/// Contract metadata update.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct NftContractMetadataUpdateLog<'a> {
    /// Additional update information.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<Cow<'a, str>>,
}

'''
'''--- src/standard/nep171/ext.rs ---
#![allow(missing_docs)]

use std::collections::HashMap;

use near_sdk::{ext_contract, AccountId, PromiseOrValue};

use super::TokenId;

/// Interface of contracts that implement NEP-171.
#[ext_contract(ext_nep171)]
pub trait Nep171 {
    /// Transfer a token.
    fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u32>,
        memo: Option<String>,
    );

    /// Transfer a token, and call [`Nep171Receiver::nft_on_transfer`] on the receiving account.
    fn nft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u32>,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<bool>;

    /// Get individual token information.
    fn nft_token(&self, token_id: TokenId) -> Option<super::Token>;
}

/// Original token contract follow-up to [`Nep171::nft_transfer_call`].
#[ext_contract(ext_nep171_resolver)]
pub trait Nep171Resolver {
    /// Final method call on the original token contract during an
    /// [`Nep171::nft_transfer_call`] promise chain.
    fn nft_resolve_transfer(
        &mut self,
        previous_owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        approved_account_ids: Option<HashMap<AccountId, u64>>,
    ) -> bool;
}

/// A contract that may be the recipient of an `nft_transfer_call` function
/// call.
#[ext_contract(ext_nep171_receiver)]
pub trait Nep171Receiver {
    /// Function that is called in an `nft_transfer_call` promise chain.
    /// Performs some action after receiving a non-fungible token.
    ///
    /// Returns `true` if token should be returned to `sender_id`.
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> PromiseOrValue<bool>;
}

'''
'''--- src/standard/nep171/hooks.rs ---
//! Hooks to integrate NEP-171 with other components.

use crate::{
    hook::Hook,
    standard::{nep145::Nep145ForceUnregister, nep181::Nep181Controller},
};

use super::{action::Nep171Burn, Nep171Controller};

/// Hook that burns all NEP-171 tokens held by an account when the account
/// performs an NEP-145 force unregister.
pub struct BurnNep171OnForceUnregisterHook;

impl<C> Hook<C, Nep145ForceUnregister<'_>> for BurnNep171OnForceUnregisterHook
where
    C: Nep171Controller + Nep181Controller,
{
    fn hook<R>(
        contract: &mut C,
        action: &Nep145ForceUnregister<'_>,
        f: impl FnOnce(&mut C) -> R,
    ) -> R {
        let token_ids =
            contract.with_tokens_for_owner(&action.account_id, |t| t.iter().collect::<Vec<_>>());

        contract
            .burn(
                &Nep171Burn::new(token_ids, action.account_id.clone())
                    .memo("storage forced unregistration"),
            )
            .unwrap_or_else(|e| {
                near_sdk::env::panic_str(&format!(
                    "Failed to burn tokens during forced unregistration: {e}",
                ))
            });

        f(contract)
    }
}

'''
'''--- src/standard/nep171/mod.rs ---
//! NEP-171 non-fungible token core implementation.
//!
//! Reference: <https://github.com/near/NEPs/blob/master/neps/nep-0171.md>
//!
//! # Usage
//!
//! It is recommended to use the [`near_sdk_contract_tools_macros::Nep171`]
//! derive macro or the [`near_sdk_contract_tools_macros::NonFungibleToken`]
//! macro to implement NEP-171 with this crate.
//!
//! ## Basic implementation with no transfer hooks
//!
//! ```rust
#![doc = include_str!("../../../tests/macros/standard/nep171/no_hooks.rs")]
//! ```
//!
//! ## Basic implementation with transfer hooks
//!
//! ```rust
#![doc = include_str!("../../../tests/macros/standard/nep171/hooks.rs")]
//! ```
//!
//! ## Using the `NonFungibleToken` derive macro for partially-automatic integration with other utilities
//!
//! The `NonFungibleToken` derive macro automatically wires up all of the NFT-related standards' implementations (NEP-171, NEP-177, NEP-178) for you.
//!
//! ```rust
#![doc = include_str!("../../../tests/macros/standard/nep171/non_fungible_token.rs")]
//! ```
//!
//! ## Manual integration with other utilities
//!
//! Note: NFT-related utilities are automatically integrated with each other
//! when using the [`near_sdk_contract_tools_macros::NonFungibleToken`] derive
//! macro.
//! ```rust
#![doc = include_str!("../../../tests/macros/standard/nep171/manual_integration.rs")]
//! ```

use std::error::Error;

use near_sdk::{
    borsh::BorshSerialize,
    near,
    serde::{Deserialize, Serialize},
    AccountId, AccountIdRef, BorshStorageKey, Gas, NearSchema,
};

use crate::{hook::Hook, slot::Slot, standard::nep297::Event, DefaultStorageKey};

pub mod action;
use action::*;

pub mod error;
use error::*;
pub mod event;
use event::*;
// separate module with re-export because ext_contract doesn't play well with #![warn(missing_docs)]
mod ext;
pub use ext::*;
pub mod hooks;

/// Minimum required gas for [`Nep171Resolver::nft_resolve_transfer`] call in promise chain during [`Nep171::nft_transfer_call`].
pub const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas::from_gas(5_000_000_000_000);
/// Minimum gas required to execute the main body of [`Nep171::nft_transfer_call`] + gas for [`Nep171Resolver::nft_resolve_transfer`].
pub const GAS_FOR_NFT_TRANSFER_CALL: Gas =
    Gas::from_gas(25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER.as_gas());
/// Error message when insufficient gas is attached to function calls with a minimum attached gas requirement (i.e. those that produce a promise chain, perform cross-contract calls).
pub const INSUFFICIENT_GAS_MESSAGE: &str = "More gas is required";

/// NFT token IDs.
pub type TokenId = String;

#[derive(BorshSerialize, BorshStorageKey)]
#[borsh(crate = "near_sdk::borsh")]
enum StorageKey<'a> {
    TokenOwner(&'a str),
}

/// Internal (storage location) methods for implementors of [`Nep171Controller`].
pub trait Nep171ControllerInternal {
    /// Hook for mint operations.
    type MintHook: for<'a> Hook<Self, Nep171Mint<'a>>
    where
        Self: Sized;
    /// Hook for transfer operations.
    type TransferHook: for<'a> Hook<Self, Nep171Transfer<'a>>
    where
        Self: Sized;
    /// Hook for burn operations.
    type BurnHook: for<'a> Hook<Self, Nep171Burn<'a>>
    where
        Self: Sized;

    /// Invoked during an external transfer.
    type CheckExternalTransfer: CheckExternalTransfer<Self>
    where
        Self: Sized;

    /// Load additional token data into [`Token::extensions_metadata`].
    type LoadTokenMetadata: LoadTokenMetadata<Self>
    where
        Self: Sized;

    /// Root storage slot.
    #[must_use]
    fn root() -> Slot<()> {
        Slot::root(DefaultStorageKey::Nep171)
    }

    /// Storage slot for the owner of a token.
    #[must_use]
    fn slot_token_owner(token_id: &TokenId) -> Slot<AccountId> {
        Self::root().field(StorageKey::TokenOwner(token_id))
    }
}

/// Non-public controller interface for NEP-171 implementations.
pub trait Nep171Controller {
    /// Hook for mint operations.
    type MintHook: for<'a> Hook<Self, Nep171Mint<'a>>
    where
        Self: Sized;
    /// Hook for transfer operations.
    type TransferHook: for<'a> Hook<Self, Nep171Transfer<'a>>
    where
        Self: Sized;
    /// Hook for burn operations.
    type BurnHook: for<'a> Hook<Self, Nep171Burn<'a>>
    where
        Self: Sized;

    /// Invoked during an external transfer.
    type CheckExternalTransfer: CheckExternalTransfer<Self>
    where
        Self: Sized;

    /// Load additional token data into [`Token::extensions_metadata`].
    type LoadTokenMetadata: LoadTokenMetadata<Self>
    where
        Self: Sized;

    /// Transfer a token from `sender_id` to `receiver_id`, as for an external
    /// call to `nft_transfer`. Checks that the transfer is valid using
    /// [`CheckExternalTransfer::check_external_transfer`] before performing
    /// the transfer. Emits events and runs relevant hooks.
    ///
    /// # Errors
    ///
    /// - If the token does not exist.
    /// - If the sender is not approved.
    /// - If the sender is the receiver.
    /// - If the correct account does not own the token.
    fn external_transfer(&mut self, transfer: &Nep171Transfer) -> Result<(), Nep171TransferError>
    where
        Self: Sized;

    /// Performs a token transfer without running [`CheckExternalTransfer::check_external_transfer`].
    /// Does not emit events or run hooks.
    ///
    /// # Warning
    ///
    /// This function performs _no checks_. It is up to the caller to ensure
    /// that the transfer is valid. Possible unintended effects of invalid
    /// transfers include:
    ///
    /// - Transferring a token "from" an account that does not own it.
    /// - Creating token IDs that did not previously exist.
    /// - Transferring a token to the account that already owns it.
    fn transfer_unchecked(&mut self, token_ids: &[TokenId], receiver_id: &AccountIdRef);

    /// Mints a new token `token_id` to `owner_id`. Emits events and runs
    /// relevant hooks.
    ///
    /// # Errors
    ///
    /// - If the token ID already exists.
    fn mint(&mut self, action: &Nep171Mint<'_>) -> Result<(), Nep171MintError>;

    /// Mints a new token `token_id` to `owner_id` without checking if the
    /// token already exists. Does not emit events or run hooks.
    fn mint_unchecked(&mut self, token_ids: &[TokenId], owner_id: &AccountIdRef);

    /// Burns tokens `token_ids` owned by `current_owner_id`. Emits events and
    /// runs relevant hooks.
    ///
    /// # Errors
    ///
    /// - If the token does not exist.
    /// - If the token is not owned by the expected owner.
    fn burn(&mut self, action: &Nep171Burn<'_>) -> Result<(), Nep171BurnError>;

    /// Burns tokens `token_ids` without checking the owners. Does not emit
    /// events or run hooks.
    fn burn_unchecked(&mut self, token_ids: &[TokenId]) -> bool;

    /// Returns the owner of a token, if it exists.
    fn token_owner(&self, token_id: &TokenId) -> Option<AccountId>;

    /// Loads the metadata associated with a token.
    fn load_token(&self, token_id: &TokenId) -> Option<Token>;
}

/// Authorization for a transfer.
#[derive(PartialEq, Eq, Clone, Debug, Hash)]
#[near(serializers = [borsh, json])]
pub enum Nep171TransferAuthorization {
    /// The sender is the owner of the token.
    Owner,
    /// The sender holds a valid approval ID for the token.
    ApprovalId(u32),
}

/// Different ways of checking if a transfer is valid.
pub trait CheckExternalTransfer<C> {
    /// Checks if a transfer is valid. Returns the account ID of the current
    /// owner of the token.
    ///
    /// # Errors
    ///
    /// Returns an error if the external transfer should not be performed.
    fn check_external_transfer(
        contract: &C,
        transfer: &Nep171Transfer,
    ) -> Result<AccountId, Nep171TransferError>;
}

/// Default external transfer checker. Only allows transfers by the owner of a
/// token. Does not support approval IDs.
pub struct DefaultCheckExternalTransfer;

impl<T: Nep171Controller> CheckExternalTransfer<T> for DefaultCheckExternalTransfer {
    fn check_external_transfer(
        contract: &T,
        transfer: &Nep171Transfer,
    ) -> Result<AccountId, Nep171TransferError> {
        let owner_id =
            contract
                .token_owner(&transfer.token_id)
                .ok_or_else(|| TokenDoesNotExistError {
                    token_id: transfer.token_id.clone(),
                })?;

        match transfer.authorization {
            Nep171TransferAuthorization::Owner => {
                if transfer.sender_id.as_ref() != owner_id {
                    return Err(TokenNotOwnedByExpectedOwnerError {
                        expected_owner_id: transfer.sender_id.clone().into(),
                        owner_id,
                        token_id: transfer.token_id.clone(),
                    }
                    .into());
                }
            }
            Nep171TransferAuthorization::ApprovalId(approval_id) => {
                return Err(SenderNotApprovedError {
                    owner_id,
                    sender_id: transfer.sender_id.clone().into(),
                    token_id: transfer.token_id.clone(),
                    approval_id,
                }
                .into())
            }
        }

        if transfer.receiver_id.as_ref() == owner_id {
            return Err(TokenReceiverIsCurrentOwnerError {
                owner_id,
                token_id: transfer.token_id.clone(),
            }
            .into());
        }

        Ok(owner_id)
    }
}

impl<T: Nep171ControllerInternal> Nep171Controller for T {
    type MintHook = <Self as Nep171ControllerInternal>::MintHook;
    type TransferHook = <Self as Nep171ControllerInternal>::TransferHook;
    type BurnHook = <Self as Nep171ControllerInternal>::BurnHook;

    type CheckExternalTransfer = <Self as Nep171ControllerInternal>::CheckExternalTransfer;
    type LoadTokenMetadata = <Self as Nep171ControllerInternal>::LoadTokenMetadata;

    fn external_transfer(&mut self, transfer: &Nep171Transfer) -> Result<(), Nep171TransferError> {
        match Self::CheckExternalTransfer::check_external_transfer(self, transfer) {
            Ok(current_owner_id) => {
                Self::TransferHook::hook(self, transfer, |contract| {
                    contract.transfer_unchecked(
                        std::array::from_ref(&transfer.token_id),
                        &transfer.receiver_id,
                    );

                    Nep171Event::NftTransfer(vec![NftTransferLog {
                        authorized_id: None,
                        old_owner_id: current_owner_id.into(),
                        new_owner_id: transfer.receiver_id.clone(),
                        token_ids: vec![transfer.token_id.clone().into()],
                        memo: transfer.memo.clone(),
                    }])
                    .emit();
                });

                Ok(())
            }
            Err(e) => Err(e),
        }
    }

    fn transfer_unchecked(&mut self, token_ids: &[TokenId], receiver_id: &AccountIdRef) {
        for token_id in token_ids {
            let mut slot = Self::slot_token_owner(token_id);
            slot.write_deref(receiver_id);
        }
    }

    fn mint_unchecked(&mut self, token_ids: &[TokenId], owner_id: &AccountIdRef) {
        for token_id in token_ids {
            let mut slot = Self::slot_token_owner(token_id);
            slot.write_deref(owner_id);
        }
    }

    fn mint(&mut self, action: &Nep171Mint<'_>) -> Result<(), Nep171MintError> {
        if action.token_ids.is_empty() {
            return Ok(());
        }

        for token_id in &action.token_ids {
            let slot = Self::slot_token_owner(token_id);
            if slot.exists() {
                return Err(TokenAlreadyExistsError {
                    token_id: token_id.to_string(),
                }
                .into());
            }
        }

        Self::MintHook::hook(self, action, |contract| {
            contract.mint_unchecked(&action.token_ids, &action.receiver_id);

            Nep171Event::NftMint(vec![NftMintLog {
                token_ids: action.token_ids.iter().map(Into::into).collect(),
                owner_id: action.receiver_id.clone(),
                memo: action.memo.clone(),
            }])
            .emit();

            Ok(())
        })
    }

    fn burn(&mut self, action: &Nep171Burn<'_>) -> Result<(), Nep171BurnError> {
        if action.token_ids.is_empty() {
            return Ok(());
        }

        for token_id in &action.token_ids {
            if let Some(actual_owner_id) = self.token_owner(token_id) {
                if actual_owner_id != action.owner_id.as_ref() {
                    return Err(TokenNotOwnedByExpectedOwnerError {
                        expected_owner_id: action.owner_id.clone().into(),
                        owner_id: actual_owner_id,
                        token_id: token_id.clone(),
                    }
                    .into());
                }
            } else {
                return Err(TokenDoesNotExistError {
                    token_id: token_id.clone(),
                }
                .into());
            }
        }

        Self::BurnHook::hook(self, action, |contract| {
            contract.burn_unchecked(&action.token_ids);

            Nep171Event::NftBurn(vec![NftBurnLog {
                token_ids: action.token_ids.iter().map(Into::into).collect(),
                owner_id: action.owner_id.clone(),
                authorized_id: None,
                memo: action.memo.clone(),
            }])
            .emit();

            Ok(())
        })
    }

    fn burn_unchecked(&mut self, token_ids: &[TokenId]) -> bool {
        let mut removed_successfully = true;

        for token_id in token_ids {
            removed_successfully &= Self::slot_token_owner(token_id).remove();
        }

        removed_successfully
    }

    fn token_owner(&self, token_id: &TokenId) -> Option<AccountId> {
        Self::slot_token_owner(token_id).read()
    }

    fn load_token(&self, token_id: &TokenId) -> Option<Token> {
        let mut metadata = std::collections::HashMap::new();
        Self::LoadTokenMetadata::load(self, token_id, &mut metadata).ok()?;
        Some(Token {
            token_id: token_id.clone(),
            owner_id: self.token_owner(token_id)?,
            extensions_metadata: metadata,
        })
    }
}

/// Token information structure.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, NearSchema)]
#[serde(crate = "near_sdk::serde")]
pub struct Token {
    /// Token ID.
    pub token_id: TokenId,
    /// Current owner of the token.
    pub owner_id: AccountId,
    /// Metadata provided by extensions.
    #[serde(flatten)]
    pub extensions_metadata: std::collections::HashMap<String, near_sdk::serde_json::Value>,
}

/// Trait for NFT extensions to load token metadata.
pub trait LoadTokenMetadata<C> {
    /// Load token metadata into `metadata`.
    ///
    /// # Errors
    ///
    /// If the token metadata could not be loaded.
    fn load(
        contract: &C,
        token_id: &TokenId,
        metadata: &mut std::collections::HashMap<String, near_sdk::serde_json::Value>,
    ) -> Result<(), Box<dyn Error>>;
}

impl<C> LoadTokenMetadata<C> for () {
    fn load(
        _contract: &C,
        _token_id: &TokenId,
        _metadata: &mut std::collections::HashMap<String, near_sdk::serde_json::Value>,
    ) -> Result<(), Box<dyn Error>> {
        Ok(())
    }
}

impl<C, T: LoadTokenMetadata<C>, U: LoadTokenMetadata<C>> LoadTokenMetadata<C> for (T, U) {
    fn load(
        contract: &C,
        token_id: &TokenId,
        metadata: &mut std::collections::HashMap<String, near_sdk::serde_json::Value>,
    ) -> Result<(), Box<dyn Error>> {
        T::load(contract, token_id, metadata)?;
        U::load(contract, token_id, metadata)?;
        Ok(())
    }
}

// further variations are technically unnecessary: just use (T, (U, V)) or ((T, U), V)

'''
'''--- src/standard/nep177.rs ---
//! NEP-177 non-fungible token contract metadata implementation.
//!
//! Reference: <https://github.com/near/NEPs/blob/master/neps/nep-0177.md>
use std::error::Error;

use near_sdk::{
    borsh::BorshSerialize, env, json_types::U64, near, AccountId, AccountIdRef, BorshStorageKey,
};
use thiserror::Error;

use crate::{
    slot::Slot,
    standard::{
        nep171::{
            action::{Nep171Burn, Nep171Mint},
            error::{Nep171BurnError, Nep171MintError, TokenDoesNotExistError},
            event::{Nep171Event, NftContractMetadataUpdateLog, NftMetadataUpdateLog},
            LoadTokenMetadata, Nep171Controller, TokenId,
        },
        nep297::Event,
    },
    DefaultStorageKey,
};

pub use ext::*;

const CONTRACT_METADATA_NOT_INITIALIZED_ERROR: &str = "Contract metadata not initialized";

/// Non-fungible token contract metadata.
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
#[near(serializers = [borsh, json])]
pub struct ContractMetadata {
    /// The metadata specification version. Essentially a version like "nft-2.0.0", replacing "2.0.0" with the implemented version of NEP-177.
    pub spec: String,
    /// The name of the NFT contract, e.g. "Mochi Rising  Digital Edition" or "Metaverse 3".
    pub name: String,
    /// The symbol of the NFT contract, e.g. "MOCHI" or "M3".
    pub symbol: String,
    /// Data URI for the contract icon.
    pub icon: Option<String>,
    /// Gateway known to have reliable access to decentralized storage assets referenced by `reference` or `media` URLs.
    pub base_uri: Option<String>,
    /// URL to a JSON file with more info about the NFT contract.
    pub reference: Option<String>,
    /// Base-64-encoded SHA-256 hash of the referenced JSON file. Required if `reference` is present.
    pub reference_hash: Option<String>,
}

impl ContractMetadata {
    /// The metadata specification version.
    pub const SPEC: &'static str = "nft-2.1.0";

    /// Creates a new contract metadata, specifying the name, symbol, and
    /// optional base URI. Other fields are set to `None`.
    #[must_use]
    pub fn new(
        name: impl Into<String>,
        symbol: impl Into<String>,
        base_uri: Option<String>,
    ) -> Self {
        Self {
            spec: Self::SPEC.to_string(),
            name: name.into(),
            symbol: symbol.into(),
            icon: None,
            base_uri,
            reference: None,
            reference_hash: None,
        }
    }
}

/// Non-fungible token metadata.
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Default)]
#[near(serializers = [borsh, json])]
pub struct TokenMetadata {
    /// This token's title, e.g. "Arch Nemesis: Mail Carrier" or "Parcel #5055".
    pub title: Option<String>,
    /// Free-text description of this specific token.
    pub description: Option<String>,
    /// The token's image or other associated media.
    pub media: Option<String>,
    /// Base-64-encoded SHA-256 hash of the media. Required if `media` is present.
    pub media_hash: Option<String>,
    /// Number of copies of this set of metadata in existence when token was minted.
    pub copies: Option<U64>,
    /// When the token was issued, in milliseconds since the UNIX epoch.
    pub issued_at: Option<U64>,
    /// When the token expires, in milliseconds since the UNIX epoch.
    pub expires_at: Option<U64>,
    /// When the token starts being valid, in milliseconds since the UNIX epoch.
    pub starts_at: Option<U64>,
    /// When the token was last updated, in milliseconds since the UNIX epoch.
    pub updated_at: Option<U64>,
    /// Anything extra the NFT wants to store on-chain. Can be stringified JSON.
    pub extra: Option<String>,
    /// URL to an off-chain JSON file with more info about the token.
    pub reference: Option<String>,
    /// Base-64-encoded SHA-256 hash of the referenced JSON file. Required if `reference` is present.
    pub reference_hash: Option<String>,
}

// Builder pattern for TokenMetadata.
impl TokenMetadata {
    /// Create a new `TokenMetadata` with all fields set to `None`.
    #[must_use]
    pub fn new() -> Self {
        Self::default()
    }

    /// Set the title.
    #[must_use]
    pub fn title(mut self, title: impl Into<String>) -> Self {
        self.title = Some(title.into());
        self
    }

    /// Set the description.
    #[must_use]
    pub fn description(mut self, description: impl Into<String>) -> Self {
        self.description = Some(description.into());
        self
    }

    /// Set the media.
    #[must_use]
    pub fn media(mut self, media: impl Into<String>) -> Self {
        self.media = Some(media.into());
        self
    }

    /// Set the media hash.
    #[must_use]
    pub fn media_hash(mut self, media_hash: impl Into<String>) -> Self {
        self.media_hash = Some(media_hash.into());
        self
    }

    /// Set the copies.
    #[must_use]
    pub fn copies(mut self, copies: impl Into<U64>) -> Self {
        self.copies = Some(copies.into());
        self
    }

    /// Set the time the token was issued.
    #[must_use]
    pub fn issued_at(mut self, issued_at: impl Into<U64>) -> Self {
        self.issued_at = Some(issued_at.into());
        self
    }

    /// Set the time the token expires.
    #[must_use]
    pub fn expires_at(mut self, expires_at: impl Into<U64>) -> Self {
        self.expires_at = Some(expires_at.into());
        self
    }

    /// Set the time the token starts being valid.
    #[must_use]
    pub fn starts_at(mut self, starts_at: impl Into<U64>) -> Self {
        self.starts_at = Some(starts_at.into());
        self
    }

    /// Set the time the token was last updated.
    #[must_use]
    pub fn updated_at(mut self, updated_at: impl Into<U64>) -> Self {
        self.updated_at = Some(updated_at.into());
        self
    }

    /// Set the extra data.
    #[must_use]
    pub fn extra(mut self, extra: impl Into<String>) -> Self {
        self.extra = Some(extra.into());
        self
    }

    /// Set the reference.
    #[must_use]
    pub fn reference(mut self, reference: impl Into<String>) -> Self {
        self.reference = Some(reference.into());
        self
    }

    /// Set the reference hash.
    #[must_use]
    pub fn reference_hash(mut self, reference_hash: impl Into<String>) -> Self {
        self.reference_hash = Some(reference_hash.into());
        self
    }
}

/// Error returned when trying to load token metadata that does not exist.
#[derive(Error, Debug)]
#[error("Token metadata does not exist: {0}")]
pub struct TokenMetadataMissingError(pub TokenId);

impl<C: Nep177Controller> LoadTokenMetadata<C> for TokenMetadata {
    fn load(
        contract: &C,
        token_id: &TokenId,
        metadata: &mut std::collections::HashMap<String, near_sdk::serde_json::Value>,
    ) -> Result<(), Box<dyn Error>> {
        metadata.insert(
            "metadata".to_string(),
            near_sdk::serde_json::to_value(
                contract
                    .token_metadata(token_id)
                    .ok_or_else(|| TokenMetadataMissingError(token_id.to_string()))?,
            )?,
        );
        Ok(())
    }
}

#[derive(BorshSerialize, BorshStorageKey)]
#[borsh(crate = "near_sdk::borsh")]
enum StorageKey<'a> {
    ContractMetadata,
    TokenMetadata(&'a TokenId),
}

/// Internal functions for [`Nep177Controller`].
pub trait Nep177ControllerInternal {
    /// Storage root.
    #[must_use]
    fn root() -> Slot<()> {
        Slot::root(DefaultStorageKey::Nep177)
    }

    /// Storage slot for contract metadata.
    #[must_use]
    fn slot_contract_metadata() -> Slot<ContractMetadata> {
        Self::root().field(StorageKey::ContractMetadata)
    }

    /// Storage slot for token metadata.
    #[must_use]
    fn slot_token_metadata(token_id: &TokenId) -> Slot<TokenMetadata> {
        Self::root().field(StorageKey::TokenMetadata(token_id))
    }
}

/// Functions for managing non-fungible tokens with attached metadata, NEP-177.
pub trait Nep177Controller {
    /// Mint a new token with metadata.
    ///
    /// # Errors
    ///
    /// - If the token ID already exists.
    fn mint_with_metadata(
        &mut self,
        token_id: &TokenId,
        owner_id: &AccountIdRef,
        metadata: &TokenMetadata,
    ) -> Result<(), Nep171MintError>;

    /// Burn a token with metadata.
    ///
    /// # Errors
    ///
    /// - If the token ID does not exist.
    /// - If the token is not owned by the expected owner.
    fn burn_with_metadata(
        &mut self,
        token_id: &TokenId,
        owner_id: &AccountId,
    ) -> Result<(), Nep171BurnError>;

    /// Sets the metadata for a token ID without checking whether the token
    /// exists, etc. and emits an [`Nep171Event::NftMetadataUpdate`] event.
    fn set_token_metadata_unchecked(
        &mut self,
        token_id: &TokenId,
        metadata: Option<&TokenMetadata>,
    );

    /// Sets the metadata for a token ID and emits an [`Nep171Event::NftMetadataUpdate`] event.
    ///
    /// # Errors
    ///
    /// - If the token does not exist.
    fn set_token_metadata(
        &mut self,
        token_id: &TokenId,
        metadata: &TokenMetadata,
    ) -> Result<(), UpdateTokenMetadataError>;

    /// Sets the contract metadata and emits an [`Nep171Event::ContractMetadataUpdate`] event.
    fn set_contract_metadata(&mut self, metadata: &ContractMetadata);

    /// Returns the contract metadata.
    fn contract_metadata(&self) -> ContractMetadata;

    /// Returns the metadata for a token ID.
    fn token_metadata(&self, token_id: &TokenId) -> Option<TokenMetadata>;
}

/// Error returned when a token update fails.
#[derive(Error, Debug)]
pub enum UpdateTokenMetadataError {
    /// The token does not exist.
    #[error(transparent)]
    TokenNotFound(#[from] TokenDoesNotExistError),
}

impl<T: Nep177ControllerInternal + Nep171Controller> Nep177Controller for T {
    fn set_token_metadata(
        &mut self,
        token_id: &TokenId,
        metadata: &TokenMetadata,
    ) -> Result<(), UpdateTokenMetadataError> {
        if self.token_owner(token_id).is_some() {
            self.set_token_metadata_unchecked(token_id, Some(metadata));
            Ok(())
        } else {
            Err(TokenDoesNotExistError {
                token_id: token_id.clone(),
            }
            .into())
        }
    }

    fn set_contract_metadata(&mut self, metadata: &ContractMetadata) {
        Self::slot_contract_metadata().set(Some(metadata));
        Nep171Event::ContractMetadataUpdate(vec![NftContractMetadataUpdateLog { memo: None }])
            .emit();
    }

    fn mint_with_metadata(
        &mut self,
        token_id: &TokenId,
        owner_id: &AccountIdRef,
        metadata: &TokenMetadata,
    ) -> Result<(), Nep171MintError> {
        self.mint(&Nep171Mint::new(vec![token_id.clone()], owner_id))?;
        self.set_token_metadata_unchecked(token_id, Some(metadata));
        Ok(())
    }

    fn burn_with_metadata(
        &mut self,
        token_id: &TokenId,
        owner_id: &AccountId,
    ) -> Result<(), Nep171BurnError> {
        self.burn(&Nep171Burn::new(vec![token_id.clone()], owner_id))?;
        self.set_token_metadata_unchecked(token_id, None);
        Ok(())
    }

    fn set_token_metadata_unchecked(
        &mut self,
        token_id: &TokenId,
        metadata: Option<&TokenMetadata>,
    ) {
        <Self as Nep177ControllerInternal>::slot_token_metadata(token_id).set(metadata);
        Nep171Event::NftMetadataUpdate(vec![NftMetadataUpdateLog {
            token_ids: vec![token_id.into()],
            memo: None,
        }])
        .emit();
    }

    fn token_metadata(&self, token_id: &TokenId) -> Option<TokenMetadata> {
        <Self as Nep177ControllerInternal>::slot_token_metadata(token_id).read()
    }

    fn contract_metadata(&self) -> ContractMetadata {
        Self::slot_contract_metadata()
            .read()
            .unwrap_or_else(|| env::panic_str(CONTRACT_METADATA_NOT_INITIALIZED_ERROR))
    }
}

// separate module with re-export because ext_contract doesn't play well with #![warn(missing_docs)]
mod ext {
    #![allow(missing_docs)]

    use super::*;

    #[near_sdk::ext_contract(ext_nep177)]
    pub trait Nep177 {
        fn nft_metadata(&self) -> ContractMetadata;
    }
}

'''
'''--- src/standard/nep178/action.rs ---
//! NEP-178 actions.
//!
//! Used when calling various functions on [`Nep178Controller`]. Also used when
//! implementing [`Hook`]s for the NEP-178 component.

use super::*;

/// NEP-178 approve action.
#[derive(Clone, Debug, PartialEq, Eq)]
#[near]
pub struct Nep178Approve<'a> {
    /// Token ID that the target account is being approved for.
    pub token_id: TokenId,
    /// Account ID of the current owner of the token.
    pub current_owner_id: Cow<'a, AccountIdRef>,
    /// Account ID of the target account. This account will be able to
    /// transfer the token.
    pub account_id: Cow<'a, AccountIdRef>,
}

/// NEP-178 revoke action.
#[derive(Clone, Debug, PartialEq, Eq)]
#[near]
pub struct Nep178Revoke<'a> {
    /// Token ID that the target account will no longer be able to transfer
    /// (approval revoked).
    pub token_id: TokenId,
    /// Account ID of the current owner of the token.
    pub current_owner_id: Cow<'a, AccountIdRef>,
    /// Account ID of the target account. This account will no longer be able
    /// to transfer the token.
    pub account_id: Cow<'a, AccountIdRef>,
}

/// NEP-178 revoke all action.
#[derive(Clone, Debug, PartialEq, Eq)]
#[near]
pub struct Nep178RevokeAll<'a> {
    /// Token ID that all approvals will be revoked from.
    pub token_id: TokenId,
    /// Account ID of the current owner of the token.
    pub current_owner_id: Cow<'a, AccountIdRef>,
}

'''
'''--- src/standard/nep178/error.rs ---
//! NEP-178 errors.

use super::{TokenId, MAX_APPROVALS};
use near_sdk::AccountId;
use thiserror::Error;

/// Occurs when an account is not authorized to manage approvals for a token.
#[derive(Error, Debug)]
#[error("Account `{account_id}` is not authorized to manage approvals for token `{token_id}`.")]
pub struct UnauthorizedError {
    /// The token ID.
    pub token_id: TokenId,
    /// The unauthorized account ID.
    pub account_id: AccountId,
}

/// The account is already approved for the token.
#[derive(Error, Debug)]
#[error("Account {account_id} is already approved for token {token_id}.")]
pub struct AccountAlreadyApprovedError {
    /// The token ID.
    pub token_id: TokenId,
    /// The account ID that has already been approved.
    pub account_id: AccountId,
}

/// The token has too many approvals.
#[derive(Error, Debug)]
#[error(
    "Too many approvals for token {token_id}, maximum is {}.",
    MAX_APPROVALS
)]
pub struct TooManyApprovalsError {
    /// The token ID.
    pub token_id: TokenId,
}

/// Errors that can occur when managing non-fungible token approvals.
#[derive(Error, Debug)]
pub enum Nep178ApproveError {
    /// The account is not authorized to create approvals for the token.
    #[error(transparent)]
    Unauthorized(#[from] UnauthorizedError),
    /// The account is already approved for the token.
    #[error(transparent)]
    AccountAlreadyApproved(#[from] AccountAlreadyApprovedError),
    /// The token has too many approvals.
    #[error(transparent)]
    TooManyApprovals(#[from] TooManyApprovalsError),
}

/// The account is not approved for the token.
#[derive(Error, Debug)]
#[error("Account {account_id} is not approved for token {token_id}")]
pub struct AccountNotApprovedError {
    /// The token ID.
    pub token_id: TokenId,
    /// The account ID that is not approved.
    pub account_id: AccountId,
}

/// Errors that can occur when revoking non-fungible token approvals.
#[derive(Error, Debug)]
pub enum Nep178RevokeError {
    /// The account is not authorized to revoke approvals for the token.
    #[error(transparent)]
    Unauthorized(#[from] UnauthorizedError),
    /// The account is not approved for the token.
    #[error(transparent)]
    AccountNotApproved(#[from] AccountNotApprovedError),
}

/// Errors that can occur when revoking all approvals for a non-fungible token.
#[derive(Error, Debug)]
pub enum Nep178RevokeAllError {
    /// The account is not authorized to revoke approvals for the token.
    #[error(transparent)]
    Unauthorized(#[from] UnauthorizedError),
}

'''
'''--- src/standard/nep178/ext.rs ---
#![allow(missing_docs)]

use near_sdk::PromiseOrValue;

use super::*;

/// NEP-178 external interface.
///
/// See <https://github.com/near/NEPs/blob/master/neps/nep-0178.md#interface> for more details.
#[near_sdk::ext_contract(ext_nep178)]
pub trait Nep178 {
    fn nft_approve(
        &mut self,
        token_id: TokenId,
        account_id: AccountId,
        msg: Option<String>,
    ) -> PromiseOrValue<()>;

    fn nft_revoke(&mut self, token_id: TokenId, account_id: AccountId);

    fn nft_revoke_all(&mut self, token_id: TokenId);

    fn nft_is_approved(
        &self,
        token_id: TokenId,
        approved_account_id: AccountId,
        approval_id: Option<ApprovalId>,
    ) -> bool;
}

/// NEP-178 receiver interface.
///
/// Respond to notification that contract has been granted approval for a token.
///
/// See <https://github.com/near/NEPs/blob/master/neps/nep-0178.md#approved-account-contract-interface> for more details.
#[near_sdk::ext_contract(ext_nep178_receiver)]
pub trait Nep178Receiver {
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: ApprovalId,
        msg: String,
    );
}

'''
'''--- src/standard/nep178/mod.rs ---
//! NEP-178 non-fungible token approval management implementation.
//!
//! Reference: <https://github.com/near/NEPs/blob/master/neps/nep-0178.md>
use std::{borrow::Cow, collections::HashMap, error::Error};

use near_sdk::{
    borsh::BorshSerialize, collections::UnorderedMap, near, AccountId, AccountIdRef,
    BorshStorageKey,
};

use crate::{
    hook::Hook,
    slot::Slot,
    standard::nep171::{
        action::{Nep171Burn, Nep171Mint, Nep171Transfer},
        error::Nep171TransferError,
        CheckExternalTransfer, DefaultCheckExternalTransfer, LoadTokenMetadata, Nep171Controller,
        Nep171TransferAuthorization, TokenId,
    },
    DefaultStorageKey,
};

pub mod action;
use action::*;
pub mod error;
use error::*;
// separate module with re-export because ext_contract doesn't play well with #![warn(missing_docs)]
mod ext;
pub use ext::*;

/// Type for approval IDs.
pub type ApprovalId = u32;
/// Maximum number of approvals per token.
pub const MAX_APPROVALS: u64 = 32;

/// NFT token approvals. Hooks are implemented on this struct.
#[derive(Debug)]
#[near]
pub struct TokenApprovals {
    /// The next approval ID to use. Only incremented.
    pub next_approval_id: ApprovalId,

    /// The list of approved accounts.
    pub accounts: UnorderedMap<AccountId, ApprovalId>,
}

impl<C: Nep178Controller> LoadTokenMetadata<C> for TokenApprovals {
    fn load(
        contract: &C,
        token_id: &TokenId,
        metadata: &mut std::collections::HashMap<String, near_sdk::serde_json::Value>,
    ) -> Result<(), Box<dyn Error>> {
        metadata.insert(
            "approved_account_ids".to_string(),
            near_sdk::serde_json::to_value(contract.get_approvals_for(token_id))?,
        );
        Ok(())
    }
}

impl<C: Nep178Controller> Hook<C, Nep171Mint<'_>> for TokenApprovals {}

impl<C: Nep178Controller> Hook<C, Nep171Transfer<'_>> for TokenApprovals {
    fn hook<R>(contract: &mut C, args: &Nep171Transfer<'_>, f: impl FnOnce(&mut C) -> R) -> R {
        let r = f(contract);
        contract.revoke_all_unchecked(&args.token_id);
        r
    }
}

impl<C: Nep178Controller> Hook<C, Nep171Burn<'_>> for TokenApprovals {
    fn hook<R>(contract: &mut C, args: &Nep171Burn<'_>, f: impl FnOnce(&mut C) -> R) -> R {
        let r = f(contract);
        for token_id in &args.token_ids {
            contract.revoke_all_unchecked(token_id);
        }
        r
    }
}

impl<C: Nep171Controller + Nep178Controller> CheckExternalTransfer<C> for TokenApprovals {
    fn check_external_transfer(
        contract: &C,
        transfer: &Nep171Transfer,
    ) -> Result<AccountId, Nep171TransferError> {
        let normal_check =
            DefaultCheckExternalTransfer::check_external_transfer(contract, transfer);

        match (&transfer.authorization, normal_check) {
            (_, r @ Ok(_)) => r,
            (
                Nep171TransferAuthorization::ApprovalId(approval_id),
                Err(Nep171TransferError::SenderNotApproved(s)),
            ) => {
                let saved_approval =
                    contract.get_approval_id_for(&transfer.token_id, &transfer.sender_id);

                if saved_approval == Some(*approval_id) {
                    Ok(s.owner_id)
                } else {
                    Err(s.into())
                }
            }
            (_, e @ Err(_)) => e,
        }
    }
}

#[derive(BorshSerialize, BorshStorageKey)]
#[borsh(crate = "near_sdk::borsh")]
enum StorageKey<'a> {
    TokenApprovals(&'a TokenId),
    TokenApprovalsUnorderedMap(&'a TokenId),
}

/// Internal functions for [`Nep178Controller`].
pub trait Nep178ControllerInternal {
    /// Hook for approve operations.
    type ApproveHook: for<'a> Hook<Self, Nep178Approve<'a>>
    where
        Self: Sized;
    /// Hook for revoke operations.
    type RevokeHook: for<'a> Hook<Self, Nep178Revoke<'a>>
    where
        Self: Sized;
    /// Hook for revoke all operations.
    type RevokeAllHook: for<'a> Hook<Self, Nep178RevokeAll<'a>>
    where
        Self: Sized;

    /// Storage root.
    #[must_use]
    fn root() -> Slot<()> {
        Slot::root(DefaultStorageKey::Nep178)
    }

    /// Storage slot for token approvals.
    #[must_use]
    fn slot_token_approvals(token_id: &TokenId) -> Slot<TokenApprovals> {
        Self::root().field(StorageKey::TokenApprovals(token_id))
    }

    /// Storage slot for token approvals `UnorderedMap`.
    #[must_use]
    fn slot_token_approvals_unordered_map(
        token_id: &TokenId,
    ) -> Slot<UnorderedMap<AccountId, ApprovalId>> {
        Self::root().field(StorageKey::TokenApprovalsUnorderedMap(token_id))
    }
}

/// Functions for managing token approvals, NEP-178.
pub trait Nep178Controller {
    /// Hook for approve operations.
    type ApproveHook: for<'a> Hook<Self, Nep178Approve<'a>>
    where
        Self: Sized;
    /// Hook for revoke operations.
    type RevokeHook: for<'a> Hook<Self, Nep178Revoke<'a>>
    where
        Self: Sized;
    /// Hook for revoke all operations.
    type RevokeAllHook: for<'a> Hook<Self, Nep178RevokeAll<'a>>
    where
        Self: Sized;

    /// Approve a token for transfer by a delegated account.
    ///
    /// # Errors
    ///
    /// - If the acting account is not authorized to create approvals for the token.
    /// - If the target account is already approved for the token.
    /// - If the token exceeds the maximum number of approvals.
    fn approve(&mut self, action: &Nep178Approve<'_>) -> Result<ApprovalId, Nep178ApproveError>;

    /// Approve a token without checking if the account is already approved or
    /// if it exceeds the maximum number of approvals.
    fn approve_unchecked(&mut self, token_id: &TokenId, account_id: &AccountIdRef) -> ApprovalId;

    /// Revoke approval for an account to transfer token.
    ///
    /// # Errors
    ///
    /// - If the acting account is not authorized to revoke approvals for the token.
    /// - If the target account is not approved for the token.
    fn revoke(&mut self, action: &Nep178Revoke<'_>) -> Result<(), Nep178RevokeError>;

    /// Revoke approval for an account to transfer token without checking if
    /// the account is approved.
    fn revoke_unchecked(&mut self, token_id: &TokenId, account_id: &AccountIdRef);

    /// Revoke all approvals for a token.
    ///
    /// # Errors
    ///
    /// - If the acting account is not authorized to revoke approvals for the token.
    fn revoke_all(&mut self, action: &Nep178RevokeAll<'_>) -> Result<(), Nep178RevokeAllError>;

    /// Revoke all approvals for a token without checking current owner.
    fn revoke_all_unchecked(&mut self, token_id: &TokenId);

    /// Get the approval ID for an account, if it is approved for a token.
    fn get_approval_id_for(
        &self,
        token_id: &TokenId,
        account_id: &AccountIdRef,
    ) -> Option<ApprovalId>;

    /// Get the approvals for a token.
    fn get_approvals_for(&self, token_id: &TokenId) -> HashMap<AccountId, ApprovalId>;
}

impl<T: Nep178ControllerInternal + Nep171Controller> Nep178Controller for T {
    type ApproveHook = T::ApproveHook;
    type RevokeHook = T::RevokeHook;
    type RevokeAllHook = T::RevokeAllHook;

    fn approve_unchecked(&mut self, token_id: &TokenId, account_id: &AccountIdRef) -> ApprovalId {
        let mut slot = Self::slot_token_approvals(token_id);
        let mut approvals = slot.read().unwrap_or_else(|| TokenApprovals {
            next_approval_id: 0,
            accounts: UnorderedMap::new(Self::slot_token_approvals_unordered_map(token_id)),
        });
        let approval_id = approvals.next_approval_id;
        approvals.accounts.insert(&account_id.into(), &approval_id);
        approvals.next_approval_id += 1; // overflow unrealistic
        slot.write(&approvals);

        approval_id
    }

    fn approve(&mut self, action: &Nep178Approve<'_>) -> Result<ApprovalId, Nep178ApproveError> {
        // owner check
        if self.token_owner(&action.token_id).as_deref() != Some(action.current_owner_id.as_ref()) {
            return Err(UnauthorizedError {
                token_id: action.token_id.clone(),
                account_id: action.account_id.clone().into(),
            }
            .into());
        }

        let mut slot = Self::slot_token_approvals(&action.token_id);
        let mut approvals = slot.read().unwrap_or_else(|| TokenApprovals {
            next_approval_id: 0,
            accounts: UnorderedMap::new(Self::slot_token_approvals_unordered_map(&action.token_id)),
        });

        if approvals.accounts.len() >= MAX_APPROVALS {
            return Err(TooManyApprovalsError {
                token_id: action.token_id.clone(),
            }
            .into());
        }

        let approval_id = approvals.next_approval_id;
        if approvals
            .accounts
            .get(&AccountId::from(action.account_id.as_ref()))
            .is_some()
        {
            return Err(AccountAlreadyApprovedError {
                token_id: action.token_id.clone(),
                account_id: action.account_id.clone().into(),
            }
            .into());
        }

        Self::ApproveHook::hook(self, action, |_| {
            approvals
                .accounts
                .insert(&action.account_id.clone().into(), &approval_id);
            approvals.next_approval_id += 1; // overflow unrealistic
            slot.write(&approvals);

            Ok(approval_id)
        })
    }

    fn revoke_unchecked(&mut self, token_id: &TokenId, account_id: &AccountIdRef) {
        let mut slot = Self::slot_token_approvals(token_id);
        let Some(mut approvals) = slot.read() else {
            return;
        };

        let old = approvals.accounts.remove(&account_id.into());

        if old.is_some() {
            slot.write(&approvals);
        }
    }

    fn revoke(&mut self, action: &Nep178Revoke) -> Result<(), Nep178RevokeError> {
        // owner check
        if self.token_owner(&action.token_id).as_deref() != Some(action.current_owner_id.as_ref()) {
            return Err(UnauthorizedError {
                token_id: action.token_id.clone(),
                account_id: action.account_id.clone().into(),
            }
            .into());
        }

        let mut slot = Self::slot_token_approvals(&action.token_id);
        let mut approvals = slot.read().ok_or_else(|| AccountNotApprovedError {
            token_id: action.token_id.clone(),
            account_id: action.account_id.clone().into(),
        })?;

        if approvals
            .accounts
            .get(&AccountId::from(action.account_id.as_ref()))
            .is_none()
        {
            return Err(AccountNotApprovedError {
                token_id: action.token_id.clone(),
                account_id: action.account_id.clone().into(),
            }
            .into());
        }

        Self::RevokeHook::hook(self, action, |_| {
            approvals
                .accounts
                .remove(&AccountId::from(action.account_id.as_ref()));
            slot.write(&approvals);

            Ok(())
        })
    }

    fn revoke_all(&mut self, action: &Nep178RevokeAll) -> Result<(), Nep178RevokeAllError> {
        // owner check
        if self.token_owner(&action.token_id).as_deref() != Some(action.current_owner_id.as_ref()) {
            return Err(UnauthorizedError {
                token_id: action.token_id.clone(),
                account_id: action.current_owner_id.clone().into(),
            }
            .into());
        }

        Self::RevokeAllHook::hook(self, action, |contract| {
            contract.revoke_all_unchecked(&action.token_id);

            Ok(())
        })
    }

    fn revoke_all_unchecked(&mut self, token_id: &TokenId) {
        let mut slot = Self::slot_token_approvals(token_id);
        let Some(mut approvals) = slot.read() else {
            return;
        };

        if !approvals.accounts.is_empty() {
            approvals.accounts.clear();
            slot.write(&approvals);
        }
    }

    fn get_approval_id_for(
        &self,
        token_id: &TokenId,
        account_id: &AccountIdRef,
    ) -> Option<ApprovalId> {
        let slot = Self::slot_token_approvals(token_id);
        let approvals = slot.read()?;

        approvals.accounts.get(&account_id.into())
    }

    fn get_approvals_for(&self, token_id: &TokenId) -> HashMap<AccountId, ApprovalId> {
        let slot = Self::slot_token_approvals(token_id);
        let Some(approvals) = slot.read() else {
            return HashMap::default();
        };

        approvals.accounts.into_iter().collect()
    }
}

'''
'''--- src/standard/nep181.rs ---
//! NEP-181 non-fungible token contract metadata implementation.
//!
//! Reference: <https://github.com/near/NEPs/blob/master/neps/nep-0181.md>
use std::borrow::Cow;

use near_sdk::{
    borsh::BorshSerialize, collections::UnorderedSet, env, AccountId, AccountIdRef, BorshStorageKey,
};

use crate::{hook::Hook, slot::Slot, standard::nep171::*, DefaultStorageKey};

pub use ext::*;

/// Extension hook for [`Nep171Controller`].
pub struct TokenEnumeration;

impl<C: Nep171Controller + Nep181Controller> Hook<C, action::Nep171Mint<'_>> for TokenEnumeration {
    fn hook<R>(contract: &mut C, args: &action::Nep171Mint<'_>, f: impl FnOnce(&mut C) -> R) -> R {
        let r = f(contract);
        contract.add_tokens_to_enumeration(&args.token_ids, &args.receiver_id);
        r
    }
}

impl<C: Nep171Controller + Nep181Controller> Hook<C, action::Nep171Transfer<'_>>
    for TokenEnumeration
{
    fn hook<R>(
        contract: &mut C,
        args: &action::Nep171Transfer<'_>,
        f: impl FnOnce(&mut C) -> R,
    ) -> R {
        let r = f(contract);
        let owner_id = match args.authorization {
            Nep171TransferAuthorization::Owner => args.sender_id.clone(),
            Nep171TransferAuthorization::ApprovalId(_) => Cow::Owned(contract.token_owner(&args.token_id).unwrap_or_else(|| {
                env::panic_str(&format!("Inconsistent state: Enumeration reconciliation should only run after a token has been transferred, but token {} does not exist.", args.token_id))
            })),
        };

        contract.transfer_token_enumeration(
            std::array::from_ref(&args.token_id),
            owner_id.as_ref(),
            &args.receiver_id,
        );
        r
    }
}

impl<C: Nep171Controller + Nep181Controller> Hook<C, action::Nep171Burn<'_>> for TokenEnumeration {
    fn hook<R>(contract: &mut C, args: &action::Nep171Burn<'_>, f: impl FnOnce(&mut C) -> R) -> R {
        let r = f(contract);
        contract.remove_tokens_from_enumeration(&args.token_ids, &args.owner_id);
        r
    }
}

#[derive(BorshSerialize, BorshStorageKey)]
#[borsh(crate = "near_sdk::borsh")]
enum StorageKey<'a> {
    Tokens,
    OwnerTokens(&'a AccountIdRef),
}

/// Internal functions for [`Nep181Controller`].
pub trait Nep181ControllerInternal {
    /// Storage root.
    #[must_use]
    fn root() -> Slot<()> {
        Slot::root(DefaultStorageKey::Nep181)
    }

    /// Storage slot for all tokens.
    #[must_use]
    fn slot_tokens() -> Slot<UnorderedSet<TokenId>> {
        Self::root().field(StorageKey::Tokens)
    }

    /// Storage slot for tokens owned by an account.
    #[must_use]
    fn slot_owner_tokens(owner_id: &AccountIdRef) -> Slot<UnorderedSet<TokenId>> {
        Self::root().field(StorageKey::OwnerTokens(owner_id))
    }
}

/// Functions for managing non-fungible tokens with attached metadata, NEP-181.
pub trait Nep181Controller {
    /// Add tokens to enumeration.
    ///
    /// # Warning
    ///
    /// Does not perform consistency checks. May cause inconsistent state if
    /// the same token ID is added to the enumeration multiple times.
    fn add_tokens_to_enumeration(&mut self, token_ids: &[TokenId], owner_id: &AccountIdRef);

    /// Remove tokens from enumeration.
    ///
    /// # Warning
    ///
    /// Does not perform consistency checks. May cause inconsistent state if
    /// any of the token IDs are not currently enumerated (owned) by `owner_id`.
    fn remove_tokens_from_enumeration(&mut self, token_ids: &[TokenId], owner_id: &AccountIdRef);

    /// Transfer tokens between owners.
    ///
    /// # Warning
    ///
    /// Does not perform consistency checks. May cause inconsistent state if
    /// any of the token IDs are not currently enumerated (owned) by
    /// `from_owner_id`, or have not previously been added to enumeration via
    /// [`Nep181Controller::add_tokens_to_enumeration`].
    fn transfer_token_enumeration(
        &mut self,
        token_ids: &[TokenId],
        from_owner_id: &AccountIdRef,
        to_owner_id: &AccountIdRef,
    );

    /// Total number of tokens in enumeration.
    fn total_enumerated_tokens(&self) -> u128;

    /// Execute a function with a reference to the set of all tokens.
    fn with_tokens<T>(&self, f: impl FnOnce(&UnorderedSet<TokenId>) -> T) -> T;

    /// Execute a function with a reference to the set of tokens owned by an
    /// account.
    fn with_tokens_for_owner<T>(
        &self,
        owner_id: &AccountIdRef,
        f: impl FnOnce(&UnorderedSet<TokenId>) -> T,
    ) -> T;
}

impl<T: Nep181ControllerInternal + Nep171Controller> Nep181Controller for T {
    fn add_tokens_to_enumeration(&mut self, token_ids: &[TokenId], owner_id: &AccountIdRef) {
        let mut all_tokens_slot = Self::slot_tokens();
        let mut all_tokens = all_tokens_slot
            .read()
            .unwrap_or_else(|| UnorderedSet::new(StorageKey::Tokens));

        all_tokens.extend(token_ids.iter().cloned());

        all_tokens_slot.write(&all_tokens);

        let mut owner_tokens_slot = Self::slot_owner_tokens(owner_id);
        let mut owner_tokens = owner_tokens_slot
            .read()
            .unwrap_or_else(|| UnorderedSet::new(StorageKey::OwnerTokens(owner_id)));

        owner_tokens.extend(token_ids.iter().cloned());

        owner_tokens_slot.write(&owner_tokens);
    }

    fn remove_tokens_from_enumeration(&mut self, token_ids: &[TokenId], owner_id: &AccountIdRef) {
        let mut all_tokens_slot = Self::slot_tokens();
        if let Some(mut all_tokens) = all_tokens_slot.read() {
            for token_id in token_ids {
                all_tokens.remove(token_id);
            }
            all_tokens_slot.write(&all_tokens);
        }

        let mut owner_tokens_slot = Self::slot_owner_tokens(owner_id);
        if let Some(mut owner_tokens) = owner_tokens_slot.read() {
            for token_id in token_ids {
                owner_tokens.remove(token_id);
            }
            owner_tokens_slot.write(&owner_tokens);
        }
    }

    fn transfer_token_enumeration(
        &mut self,
        token_ids: &[TokenId],
        from_owner_id: &AccountIdRef,
        to_owner_id: &AccountIdRef,
    ) {
        let mut from_owner_tokens_slot = Self::slot_owner_tokens(from_owner_id);
        if let Some(mut from_owner_tokens) = from_owner_tokens_slot.read() {
            for token_id in token_ids {
                from_owner_tokens.remove(token_id);
            }
            from_owner_tokens_slot.write(&from_owner_tokens);
        }

        let mut to_owner_tokens_slot = Self::slot_owner_tokens(to_owner_id);
        let mut to_owner_tokens = to_owner_tokens_slot
            .read()
            .unwrap_or_else(|| UnorderedSet::new(StorageKey::OwnerTokens(to_owner_id)));

        to_owner_tokens.extend(token_ids.iter().cloned());

        to_owner_tokens_slot.write(&to_owner_tokens);
    }

    fn total_enumerated_tokens(&self) -> u128 {
        Self::slot_tokens()
            .read()
            .map(|tokens| tokens.len())
            .unwrap_or_default()
            .into()
    }

    fn with_tokens<U>(&self, f: impl FnOnce(&UnorderedSet<TokenId>) -> U) -> U {
        f(&Self::slot_tokens()
            .read()
            .unwrap_or_else(|| UnorderedSet::new(StorageKey::Tokens)))
    }

    fn with_tokens_for_owner<U>(
        &self,
        owner_id: &AccountIdRef,
        f: impl FnOnce(&UnorderedSet<TokenId>) -> U,
    ) -> U {
        f(&Self::slot_owner_tokens(owner_id)
            .read()
            .unwrap_or_else(|| UnorderedSet::new(StorageKey::OwnerTokens(owner_id))))
    }
}

// separate module with re-export because ext_contract doesn't play well with #![warn(missing_docs)]
mod ext {
    #![allow(missing_docs)]

    use near_sdk::json_types::U128;

    use super::*;

    #[near_sdk::ext_contract(ext_nep181)]
    pub trait Nep181 {
        fn nft_total_supply(&self) -> U128;
        fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u32>) -> Vec<Token>;
        fn nft_supply_for_owner(&self, account_id: AccountId) -> U128;
        fn nft_tokens_for_owner(
            &self,
            account_id: AccountId,
            from_index: Option<U128>,
            limit: Option<u32>,
        ) -> Vec<Token>;
    }
}

'''
'''--- src/standard/nep297.rs ---
//! Helpers for `#[derive(near_sdk_contract_tools::Nep297)]`

use std::borrow::Cow;

use near_sdk::{
    serde::{self, Deserialize, Serialize},
    serde_json, NearSchema,
};

/// Emit events according to the [NEP-297 event standard](https://nomicon.io/Standards/EventsFormat).
///
/// # Examples
///
/// ```
/// use near_sdk_contract_tools::event;
///
/// #[event(standard = "nft", version = "1.0.0")]
/// pub struct MintEvent {
///     pub owner_id: String,
///     pub token_id: String,
/// }
///
/// let e = MintEvent {
///     owner_id: "account".to_string(),
///     token_id: "token_1".to_string(),
/// };
///
/// use near_sdk_contract_tools::standard::nep297::Event;
///
/// e.emit();
/// ```
pub trait Event {
    /// Converts the event into an NEP-297 event-formatted string.
    fn to_event_string(&self) -> String;

    /// Emits the event string to the blockchain.
    fn emit(&self);
}

impl<T: ToEventLog> Event for T
where
    T::Data: Serialize,
{
    fn to_event_string(&self) -> String {
        format!(
            "EVENT_JSON:{}",
            serde_json::to_string(&self.to_event_log()).unwrap_or_else(|e| {
                #[cfg(not(target_arch = "wasm32"))]
                {
                    panic!("Failed to serialize event: {e}")
                }

                #[cfg(target_arch = "wasm32")]
                {
                    near_sdk::env::panic_str(&format!("Failed to serialize event: {e}"))
                }
            }),
        )
    }

    fn emit(&self) {
        near_sdk::env::log_str(&self.to_event_string());
    }
}

/// This type can be converted into an [`EventLog`] struct.
pub trait ToEventLog {
    /// Metadata associated with the event.
    type Data;

    /// Retrieves the event log before serialization.
    fn to_event_log(&self) -> EventLog<&Self::Data>;
}

/// NEP-297 Event Log Data
/// <https://github.com/near/NEPs/blob/master/neps/nep-0297.md#specification>
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, NearSchema)]
#[serde(crate = "near_sdk::serde")]
pub struct EventLog<'a, T> {
    /// Name of the event standard, e.g. `"nep171"`.
    pub standard: Cow<'a, str>,
    /// Version of the standard, e.g. `"1.0.0"`.
    pub version: Cow<'a, str>,
    /// Name of the particular event, e.g. `"nft_mint"`, `"ft_transfer"`.
    pub event: Cow<'a, str>,
    /// Data type of the event metadata.
    pub data: T,
}

impl<'de, T: Deserialize<'de>> EventLog<'de, T> {
    /// Deserializes an event log from a string.
    ///
    /// # Errors
    ///
    /// Will return `Err` if the string is not a valid event log. A valid event
    /// log begins with the string `"EVENT_JSON:"`, and is followed by a JSON
    /// string.
    pub fn from_event_log_string(s: &'de str) -> Result<Self, serde::de::value::Error> {
        let data_str = s
            .strip_prefix("EVENT_JSON:")
            .ok_or(serde::de::Error::custom(serde::de::Unexpected::Str(
                "EVENT_JSON:",
            )))?;
        let data =
            serde_json::from_str::<EventLog<T>>(data_str).map_err(serde::de::Error::custom)?;
        let x = Some(1);
        x.as_ref();
        Ok(data)
    }

    /// Converts the event log into a borrowed reference.
    pub fn as_ref(&self) -> EventLog<&T> {
        EventLog {
            standard: Cow::Borrowed(&self.standard),
            version: Cow::Borrowed(&self.version),
            event: Cow::Borrowed(&self.event),
            data: &self.data,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn to_and_from_event_log() {
        #[derive(Debug, PartialEq, Eq)]
        struct MyEvent;

        impl ToEventLog for MyEvent {
            type Data = u32;

            fn to_event_log(&self) -> EventLog<&u32> {
                EventLog {
                    standard: "nep171".into(),
                    version: "1.0.0".into(),
                    event: "nft_mint".into(),
                    data: &1,
                }
            }
        }

        let event = MyEvent;

        let string = event.to_event_string();

        assert_eq!(string, "EVENT_JSON:{\"standard\":\"nep171\",\"version\":\"1.0.0\",\"event\":\"nft_mint\",\"data\":1}");

        let from_event_log_str = EventLog::<u32>::from_event_log_string(&string).unwrap();

        assert_eq!(from_event_log_str.as_ref(), event.to_event_log());
    }
}

'''
'''--- src/upgrade/mod.rs ---
//! Contract code upgrades.
//!
//! If you ever wish to update the logic of your contract without having to
//! use a full-access key, you can take advantage of the upgrade patterns in
//! this module. Upgrading a contract usually consists of two parts:
//!
//! 1. A reflexive `DEPLOY_CONTRACT` action.
//! 2. A follow-up state migration, if necessary. (See: [`crate::migrate`].)
//!
//! This module provides a few different ways to perform an upgrade. Most new
//! projects should probably start with the [`serialized`] module.
//!
//! By default, after updating the contract logic the contract state is
//! migrated. This behaviour can be changed by providing a
//! custom [`PostUpgrade`].
//!
//! The
#![cfg_attr(feature = "unstable", doc = "[`raw`]")]
#![cfg_attr(not(feature = "unstable"), doc = "`raw` (feature: `unstable`)")]
//! module is included mostly for legacy / compatibility reasons,
//! and for the niche efficiency use-case, since it allows for the most
//! efficient binary serialization (though only by a little). However, it is
//! more difficult to use and has more sharp edges.
//!
//! # Safety
//!
//! If the contract state is migrated, the new contract logic must deserialize
//! the existing state according to the old schema and migrate it to the new
//! schema. If the new contract has a different storage schema from the old
//! contract and does not migrate the state schema, the contract may become
//! unusable.
use near_sdk::Gas;

/// Default value for the name of the function that will be called after
/// upgrade (usually a migrate function).
pub const DEFAULT_POST_UPGRADE_METHOD_NAME: &str = "migrate";
/// Default input to send to the post-upgrade function.
pub const DEFAULT_POST_UPGRADE_METHOD_ARGS: Vec<u8> = vec![];
/// Guarantee the post-upgrade function receives at least this much gas by
/// default.
pub const DEFAULT_POST_UPGRADE_MINIMUM_GAS: Gas = Gas::from_gas(15_000_000_000_000);

#[cfg(feature = "unstable")]
pub mod raw;
pub mod serialized;

/// Function call after upgrade descriptor
#[derive(Debug, Clone)]
pub struct PostUpgrade {
    /// Function name
    pub method: String,
    /// Serialized function input
    pub args: Vec<u8>,
    /// Guarantee minimum gas
    pub minimum_gas: Gas,
}

impl Default for PostUpgrade {
    fn default() -> Self {
        Self {
            method: DEFAULT_POST_UPGRADE_METHOD_NAME.to_string(),
            args: DEFAULT_POST_UPGRADE_METHOD_ARGS,
            minimum_gas: DEFAULT_POST_UPGRADE_MINIMUM_GAS,
        }
    }
}

'''
'''--- src/upgrade/raw.rs ---
//! Accepts contract deployment as raw binary.
//!
//! This pattern was common in NEAR smart contracts at the time of writing,
//! but is included here mostly for compatibility/legacy reasons. Unless you
//! are really sure you know what you are doing, you should probably be using
//! [`super::serialized`].
//!
//! # Warning
//!
//! Functions in this module are generally _not callable_ from any call tree
//! originating from a function annotated by `#[near]`.

use near_sdk::{env, sys};

use super::PostUpgrade;

/// This function performs low-level, `unsafe` interactions with the NEAR VM.
/// This function automatically sets the return value of the function call to
/// the contract deployment &rarr; migrate function call promise, so the
/// contract should not try to return any other values. This also means that
/// this function probably should not be called from a `#[near]`
/// context, since the macro may automatically set a different return value.
///
/// # Safety
///
/// Requires that `near_sdk::env::input()` contains the plain, raw bytes of a
/// valid WebAssembly smart contract.
#[allow(clippy::needless_pass_by_value)]
pub unsafe fn upgrade(post_upgrade: PostUpgrade) {
    // Create a promise batch
    let promise_id = sys::promise_batch_create(
        env::current_account_id().as_bytes().len() as u64,
        env::current_account_id().as_bytes().as_ptr() as u64,
    );

    sys::input(0);

    // Deploy the contract code
    sys::promise_batch_action_deploy_contract(promise_id, u64::MAX, 0);

    let gas = post_upgrade.minimum_gas.as_gas();

    // Call promise to migrate the state.
    // Batched together to fail upgrade if migration fails.
    sys::promise_batch_action_function_call_weight(
        promise_id,
        post_upgrade.method.len() as u64,
        post_upgrade.method.as_ptr() as u64,
        post_upgrade.args.len() as u64,
        post_upgrade.args.as_ptr() as u64,
        0,
        gas,
        u64::MAX,
    );

    sys::promise_return(promise_id);
}

'''
'''--- src/upgrade/serialized.rs ---
#![allow(clippy::must_use_candidate)]
//! Contract upgrade functions that work as expected in conjunction with
//! `#[near]`.

use near_sdk::{env, GasWeight, NearToken, Promise};

use super::PostUpgrade;

/// Upgrade lifecycle hooks
pub trait UpgradeHook {
    /// `on_upgrade` should be called when the smart contract is upgraded. If
    /// you use the [`crate::Upgrade`] macro, it will call the hook
    /// automatically for you.
    fn on_upgrade(&self);
}

/// Creates a promise that upgrades the current contract with given code
pub fn upgrade(code: Vec<u8>, post_upgrade: PostUpgrade) -> Promise {
    Promise::new(env::current_account_id())
        .deploy_contract(code)
        .function_call_weight(
            post_upgrade.method,
            post_upgrade.args,
            NearToken::from_yoctonear(0u128),
            post_upgrade.minimum_gas,
            GasWeight(u64::MAX),
        )
}

/// Creates a promise that upgrades the current contract with given code and
/// common defaults for the subsequent post-upgrade invocation.
pub fn upgrade_default(code: Vec<u8>) -> Promise {
    upgrade(code, PostUpgrade::default())
}

'''
'''--- src/utils.rs ---
//! Utility functions for storage key generation, storage fee management

use near_sdk::{env, require, NearToken, Promise};

/// Concatenate bytes to form a key. Useful for generating storage keys.
///
/// # Examples
///
/// ```
/// use near_sdk_contract_tools::utils::prefix_key;
///
/// assert_eq!(prefix_key(b"p", b"key"), b"pkey");
/// ```
#[must_use]
pub fn prefix_key(prefix: &[u8], key: &[u8]) -> Vec<u8> {
    [prefix, key].concat()
}

/// Calculates the storage fee of an action, given an initial storage amount,
/// and refunds the predecessor a portion of the attached deposit if necessary.
/// Returns refund Promise if refund was applied.
///
/// # Warning
///
/// New collections (those in `near_sdk::store`) cache writes, only applying
/// state changes on drop. However, this function only accounts for actual
/// changes to storage usage. You can force writes (allowing this function to
/// detect storage changes) by calling `.flush()` on `near_sdk::store::*`
/// collections.
///
/// # Examples
///
/// ```
/// use near_sdk_contract_tools::utils::apply_storage_fee_and_refund;
///
/// let initial_storage_usage = near_sdk::env::storage_usage();
/// let additional_fees = 0;
///
/// // Action that consumes storage.
/// near_sdk::env::storage_write(b"key", b"value");
///
/// near_sdk::testing_env!(near_sdk::test_utils::VMContextBuilder::new()
///     .attached_deposit(near_sdk::NearToken::from_near(1))
///     .build());
/// // Attached deposit must cover storage fee or this function will panic
/// apply_storage_fee_and_refund(initial_storage_usage, additional_fees);
/// ```
#[must_use]
pub fn apply_storage_fee_and_refund(
    initial_storage_usage: u64,
    additional_fees: u128,
) -> Option<Promise> {
    // Storage consumption after storage event
    let storage_usage_end = env::storage_usage();

    let storage_byte_cost = env::storage_byte_cost();

    // Storage fee incurred by storage event, clamped >= 0
    let storage_fee = storage_byte_cost
        .checked_mul(u128::from(
            storage_usage_end.saturating_sub(initial_storage_usage),
        ))
        .unwrap_or_else(|| env::panic_str("Storage fee overflows"));

    let total_required_deposit = storage_fee
        .checked_add(NearToken::from_yoctonear(additional_fees))
        .unwrap_or_else(|| env::panic_str("Required deposit overflows u128"));

    let attached_deposit = env::attached_deposit();

    require!(
        attached_deposit >= total_required_deposit,
        format!(
            "Insufficient deposit: attached {attached_deposit} yoctoNEAR < required {total_required_deposit} yoctoNEAR ({storage_fee} storage + {additional_fees} additional)",
        )
    );

    let refund = attached_deposit.saturating_sub(total_required_deposit);

    // Send refund transfer if required
    if refund.is_zero() {
        None
    } else {
        Some(Promise::new(env::predecessor_account_id()).transfer(refund))
    }
}

/// Asserts that the attached deposit is greater than zero.
pub fn assert_nonzero_deposit() {
    require!(
        !env::attached_deposit().is_zero(),
        "Attached deposit must be greater than zero"
    );
}

#[cfg(test)]
mod tests {
    use super::prefix_key;

    #[test]
    fn test_prefix_key() {
        assert_eq!(prefix_key(b"a", b"b"), b"ab");
        assert_eq!(prefix_key("a".as_ref(), "b".as_ref()), b"ab");
        assert_eq!(prefix_key("a".as_ref(), b"b"), b"ab");
        assert_eq!(prefix_key(&[], "abc".as_ref()), b"abc");
        assert_eq!(prefix_key(&[], b""), [0u8; 0]);
        assert_eq!(prefix_key("abc".as_ref(), b""), b"abc");
    }
}

'''
'''--- tests/macros/escrow.rs ---
use near_sdk::{
    json_types::U64, near, test_utils::VMContextBuilder, testing_env, AccountId, BorshStorageKey,
    NearToken, PanicOnDefault, VMContext,
};
use near_sdk_contract_tools::{
    escrow::{Escrow, EscrowInternal},
    Escrow,
};

const ID: U64 = U64(1);
const IS_NOT_READY: bool = false;

#[derive(BorshStorageKey)]
#[near]
enum StorageKey {
    MyStorageKey,
}

mod ensure_default {
    use super::*;

    // Ensure compilation of default state type.
    #[derive(Escrow, PanicOnDefault)]
    #[escrow(id = "U64")]
    #[near(contract_state)]
    struct StatelessLock {}
}

#[derive(Escrow, PanicOnDefault)]
#[escrow(id = "U64", state = "bool", storage_key = "StorageKey::MyStorageKey")]
#[near(contract_state)]
struct IsReadyLockableContract {}

#[near]
impl IsReadyLockableContract {
    #[init]
    pub fn new() -> Self {
        Self {}
    }
}

fn alice() -> AccountId {
    "alice".parse().unwrap()
}

fn get_context(attached_deposit: NearToken, signer: Option<AccountId>) -> VMContext {
    VMContextBuilder::new()
        .signer_account_id(signer.clone().unwrap_or_else(alice))
        .predecessor_account_id(signer.unwrap_or_else(alice))
        .attached_deposit(attached_deposit)
        .is_view(false)
        .build()
}

#[test]
fn test_can_lock() {
    testing_env!(get_context(NearToken::from_yoctonear(1u128), None));
    let mut contract = IsReadyLockableContract::new();

    contract.lock(&ID, &IS_NOT_READY);
    assert!(contract.get_locked(&ID).is_some());
}

#[test]
#[should_panic(expected = "Already locked")]
fn test_cannot_lock_twice() {
    testing_env!(get_context(NearToken::from_yoctonear(1u128), None));
    let mut contract = IsReadyLockableContract::new();

    contract.lock(&ID, &IS_NOT_READY);
    contract.lock(&ID, &IS_NOT_READY);
}

#[test]
fn test_can_unlock() {
    testing_env!(get_context(NearToken::from_yoctonear(1u128), None));
    let mut contract = IsReadyLockableContract::new();

    let is_ready = true;
    contract.lock(&ID, &is_ready);
    contract.unlock(&ID, |readiness| readiness == &is_ready);

    assert!(contract.get_locked(&ID).is_none());
}

#[test]
#[should_panic(expected = "Unlock handler failed")]
fn test_cannot_unlock_until_ready() {
    testing_env!(get_context(NearToken::from_yoctonear(1u128), None));
    let mut contract = IsReadyLockableContract::new();

    let is_ready = true;
    contract.lock(&ID, &IS_NOT_READY);
    contract.unlock(&ID, |readiness| readiness == &is_ready);

    assert!(contract.get_locked(&ID).is_none());
}

'''
'''--- tests/macros/event.rs ---
use near_sdk_contract_tools::standard::nep297::{Event, ToEventLog};

use crate::macros::event::test_events::Nep171NftMintData;

mod test_events {
    use near_sdk::serde::Serialize;
    use near_sdk_contract_tools::Nep297;

    #[derive(Serialize)]
    #[serde(crate = "near_sdk::serde")]
    pub struct Nep171NftMintData {
        pub owner_id: String,
        pub token_ids: Vec<String>,
    }

    #[derive(Nep297, Serialize)]
    #[serde(crate = "near_sdk::serde")]
    // Required fields
    #[nep297(standard = "nep171", version = "1.0.0")]
    // Optional. Default event name is the untransformed variant name, e.g. NftMint, AnotherEvent, CustomEvent
    #[nep297(rename = "snake_case")]
    pub struct NftMint(pub Vec<Nep171NftMintData>); // Name will be "nft_mint" because rename = snake_case

    #[derive(Nep297, Serialize)]
    #[serde(crate = "near_sdk::serde")]
    #[nep297(standard = "nep171", version = "1.0.0", name = "sneaky_event")]
    pub struct AnotherEvent; // Name will be "sneaky_event"

    #[derive(Nep297, Serialize)]
    #[serde(crate = "near_sdk::serde")]
    #[nep297(standard = "nep171", version = "1.0.0", rename = "SHOUTY-KEBAB-CASE")]
    pub struct CustomEvent; // Name will be "CUSTOM-EVENT"

    #[derive(Nep297, Serialize)]
    #[serde(crate = "near_sdk::serde")]
    #[nep297(standard = "enum-event", version = "1.0.0")]
    #[allow(clippy::enum_variant_names)]
    pub enum EnumEvent {
        VariantOne,
        #[nep297(name = "genuine_variant_two")]
        VariantTwo(),
        #[nep297(rename = "SHOUTY_SNAKE_CASE")]
        VariantThree(u32, u64),
        #[nep297(rename = "kebab-case")]
        #[allow(unused)] // just here to make sure it compiles
        VariantFour {
            foo: u32,
            bar: u64,
        },
    }

    #[derive(Nep297, Serialize)]
    #[serde(crate = "near_sdk::serde")]
    #[nep297(standard = "enum-event", version = "1.0.0", rename_all = "snake_case")]
    #[allow(clippy::enum_variant_names)]
    pub enum EnumEventRenameAll {
        VariantOne,
        #[nep297(rename = "lowerCamelCase")]
        VariantTwo,
        #[nep297(name = "threedom!")]
        VariantThree,
    }
}

#[test]
fn derive_event() {
    let e = test_events::NftMint(vec![Nep171NftMintData {
        owner_id: "owner".to_string(),
        token_ids: vec!["token_1".to_string(), "token_2".to_string()],
    }]);

    assert_eq!(
        e.to_event_string(),
        r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"owner","token_ids":["token_1","token_2"]}]}"#
    );

    assert_eq!(
        test_events::AnotherEvent.to_event_log().event,
        "sneaky_event"
    );
    assert_eq!(
        test_events::CustomEvent.to_event_log().event,
        "CUSTOM-EVENT"
    );
    assert_eq!(
        test_events::EnumEvent::VariantOne.to_event_log().event,
        "VariantOne"
    );
    assert_eq!(
        test_events::EnumEvent::VariantTwo().to_event_log().event,
        "genuine_variant_two"
    );
    assert_eq!(
        test_events::EnumEvent::VariantThree(0, 0)
            .to_event_log()
            .event,
        "VARIANT_THREE"
    );
    assert_eq!(
        test_events::EnumEventRenameAll::VariantOne
            .to_event_log()
            .event,
        "variant_one"
    );
    assert_eq!(
        test_events::EnumEventRenameAll::VariantTwo
            .to_event_log()
            .event,
        "variantTwo"
    );
    assert_eq!(
        test_events::EnumEventRenameAll::VariantThree
            .to_event_log()
            .event,
        "threedom!"
    );
}

mod event_attribute_macro {
    use near_sdk_contract_tools::{event, standard::nep297::Event};

    mod my_event {
        use near_sdk_contract_tools::event;

        #[event(standard = "my_event_standard", version = "1")]
        pub struct One;
        #[event(standard = "my_event_standard", version = "1")]
        pub struct ThreePointFive {
            pub foo: &'static str,
        }
        #[event(standard = "my_event_standard", version = "1")]
        pub struct Six;
    }

    #[event(standard = "my_event_standard", version = "1")]
    #[allow(unused)]
    enum MyEvent {
        One,
        ThreePointFive { foo: &'static str },
        Six,
    }

    #[test]
    fn test() {
        let e = my_event::ThreePointFive { foo: "hello" };
        e.emit();
        assert_eq!(
            e.to_event_string(),
            r#"EVENT_JSON:{"standard":"my_event_standard","version":"1","event":"three_point_five","data":{"foo":"hello"}}"#,
        );

        let f = MyEvent::ThreePointFive { foo: "hello" };
        f.emit();
        assert_eq!(e.to_event_string(), f.to_event_string());
    }
}

'''
'''--- tests/macros/migrate.rs ---
use near_sdk::{env, near, PanicOnDefault};
use near_sdk_contract_tools::{migrate::MigrateHook, Migrate};

mod old {
    use super::*;

    #[derive(Debug, PanicOnDefault)]
    #[near(contract_state)]
    pub struct Old {
        pub foo: u64,
    }

    #[near]
    impl Old {
        #[init]
        pub fn new(foo: u64) -> Self {
            Self { foo }
        }
    }
}

#[derive(Migrate, PanicOnDefault)]
#[migrate(from = "old::Old")]
#[near(contract_state)]
struct MyContract {
    pub bar: u64,
}

impl MigrateHook for MyContract {
    fn on_migrate(old: old::Old) -> Self {
        Self { bar: old.foo }
    }
}

#[test]
fn default_from() {
    let old = old::Old::new(99);

    // This is done automatically in real #[near] WASM contracts
    env::state_write(&old);

    assert_eq!(old.foo, 99);

    let migrated = MyContract::migrate();

    assert_eq!(migrated.bar, 99);
}

'''
'''--- tests/macros/mod.rs ---
use near_sdk::{
    env, near, test_utils::VMContextBuilder, testing_env, AccountId, BorshStorageKey,
    PanicOnDefault,
};
use near_sdk_contract_tools::{
    escrow::Escrow, migrate::MigrateHook, owner::Owner, pause::Pause, rbac::Rbac,
    standard::nep297::Event, Escrow, Migrate, Owner, Pause, Rbac,
};

mod escrow;
mod event;
mod migrate;
mod owner;
mod pause;
mod standard;

mod my_event {
    use near_sdk::{serde::Serialize, AccountId};
    use near_sdk_contract_tools::Nep297;

    #[derive(Serialize, Nep297)]
    #[serde(crate = "near_sdk::serde")]
    #[nep297(standard = "x-myevent", version = "1.0.0", rename = "snake_case")]
    pub struct ValueChanged {
        pub from: u32,
        pub to: u32,
    }

    #[derive(Serialize, Nep297)]
    #[serde(crate = "near_sdk::serde")]
    #[nep297(standard = "x-myevent", version = "1.0.0", rename = "snake_case")]
    pub struct PermissionGranted {
        pub to: AccountId,
    }
}

#[derive(BorshStorageKey)]
#[near]
enum StorageKey {
    Owner,
    Pause,
    Rbac,
}

#[derive(BorshStorageKey)]
#[near]
pub enum Role {
    CanPause,
    CanSetValue,
}

mod integration {
    use super::*;

    #[derive(Owner, Pause, Rbac, Escrow, PanicOnDefault)]
    #[owner(storage_key = "StorageKey::Owner")]
    #[pause(storage_key = "StorageKey::Pause")]
    #[rbac(storage_key = "StorageKey::Rbac", roles = "Role")]
    #[escrow(storage_key = "StorageKey::Owner", id = "u64", state = "String")]
    #[near(contract_state)]
    pub struct Integration {
        pub value: u32,
    }

    #[allow(clippy::needless_pass_by_value)]
    #[near]
    impl Integration {
        #[init]
        pub fn new(owner_id: AccountId) -> Self {
            let mut contract = Self { value: 0 };

            Owner::init(&mut contract, &owner_id);
            contract.add_role(&owner_id, &Role::CanSetValue);
            contract.add_role(&owner_id, &Role::CanPause);

            contract
        }

        pub fn add_value_setter(&mut self, account_id: AccountId) {
            Self::require_owner();

            self.add_role(&account_id, &Role::CanSetValue);

            my_event::PermissionGranted { to: account_id }.emit();
        }

        pub fn set_value(&mut self, value: u32) {
            Self::require_unpaused();
            Self::require_role(&Role::CanSetValue);

            let old = self.value;

            self.value = value;

            my_event::ValueChanged {
                from: old,
                to: value,
            }
            .emit();
        }

        pub fn pause(&mut self) {
            Self::require_role(&Role::CanPause);
            Pause::pause(self);
        }

        pub fn unpause(&mut self) {
            Self::require_role(&Role::CanPause);
            Pause::unpause(self);
        }

        pub fn get_value(&self) -> u32 {
            self.value
        }

        pub fn lock_data(&mut self, id: u64, data: String) {
            self.lock(&id, &data);
        }

        pub fn unlock_data(&mut self, id: u64) {
            self.unlock(&id, |data| !data.is_empty());
        }

        pub fn check_is_locked(&self, id: u64) -> bool {
            self.is_locked(&id)
        }
    }
}
use integration::Integration;

#[derive(Migrate, Owner, Pause, Rbac, PanicOnDefault)]
#[migrate(from = "Integration")]
#[owner(storage_key = "StorageKey::Owner")]
#[pause(storage_key = "StorageKey::Pause")]
#[rbac(storage_key = "StorageKey::Rbac", roles = "Role")]
#[near(contract_state)]
struct MigrateIntegration {
    pub new_value: String,
    pub moved_value: u32,
}

impl MigrateHook for MigrateIntegration {
    fn on_migrate(old: Integration) -> Self {
        Self::require_owner();
        Self::require_unpaused();

        Self {
            new_value: "my string".to_string(),
            moved_value: old.value,
        }
    }
}

#[near]
impl MigrateIntegration {
    pub fn add_value_setter(&mut self, account_id: AccountId) {
        Self::require_owner();

        self.add_role(&account_id, &Role::CanSetValue);

        my_event::PermissionGranted { to: account_id }.emit();
    }

    pub fn set_value(&mut self, value: u32) {
        Self::require_unpaused();
        Self::require_role(&Role::CanSetValue);

        let old = self.moved_value;

        self.moved_value = value;

        my_event::ValueChanged {
            from: old,
            to: value,
        }
        .emit();
    }

    pub fn pause(&mut self) {
        Self::require_role(&Role::CanPause);
        Pause::pause(self);
    }

    pub fn unpause(&mut self) {
        Self::require_role(&Role::CanPause);
        Pause::unpause(self);
    }

    pub fn get_value(&self) -> u32 {
        self.moved_value
    }
}

#[test]
fn integration() {
    let owner: AccountId = "owner".parse().unwrap();
    let alice: AccountId = "alice".parse().unwrap();
    let context = VMContextBuilder::new()
        .predecessor_account_id(owner.clone())
        .build();

    testing_env!(context);
    let mut c = Integration::new(owner.clone());

    c.set_value(5);

    assert_eq!(c.get_value(), 5);

    c.add_value_setter(alice.clone());

    let context = VMContextBuilder::new()
        .predecessor_account_id(alice.clone())
        .build();

    testing_env!(context);

    c.set_value(15);

    assert_eq!(c.get_value(), 15);

    let context = VMContextBuilder::new()
        .predecessor_account_id(owner.clone())
        .build();

    testing_env!(context);

    Integration::pause(&mut c);
    Integration::unpause(&mut c);

    c.set_value(25);

    assert_eq!(c.get_value(), 25);

    // Perform migration
    env::state_write(&c);

    let mut migrated = MigrateIntegration::migrate();

    assert_eq!(migrated.moved_value, 25);
    assert_eq!(migrated.get_value(), 25);
    assert_eq!(migrated.new_value, "my string");

    let bob: AccountId = "bob_addr".parse().unwrap();

    migrated.set_value(5);

    assert_eq!(migrated.get_value(), 5);

    // make sure alice still has permission
    let context = VMContextBuilder::new()
        .predecessor_account_id(alice.clone())
        .build();

    testing_env!(context);

    migrated.set_value(256);

    assert_eq!(migrated.get_value(), 256);

    // add bob permissions
    let context = VMContextBuilder::new()
        .predecessor_account_id(owner.clone())
        .build();

    testing_env!(context);

    migrated.add_value_setter(bob.clone());

    let context = VMContextBuilder::new()
        .predecessor_account_id(bob.clone())
        .build();

    testing_env!(context);

    migrated.set_value(77);

    assert_eq!(migrated.get_value(), 77);

    let context = VMContextBuilder::new()
        .predecessor_account_id(owner.clone())
        .build();

    testing_env!(context);

    MigrateIntegration::pause(&mut migrated);
    MigrateIntegration::unpause(&mut migrated);

    migrated.set_value(8);

    assert_eq!(migrated.get_value(), 8);

    c.lock_data(1, "Data".to_string());
    assert!(c.check_is_locked(1));
    c.unlock_data(1);
}

#[test]
#[should_panic(expected = "Unauthorized")]
fn integration_fail_missing_role() {
    let owner: AccountId = "owner".parse().unwrap();
    let alice: AccountId = "alice".parse().unwrap();
    let context = VMContextBuilder::new()
        .predecessor_account_id(owner.clone())
        .build();

    testing_env!(context);
    let mut c = Integration::new(owner.clone());

    let context = VMContextBuilder::new()
        .predecessor_account_id(alice.clone())
        .build();

    testing_env!(context);

    c.set_value(15);
}

#[test]
#[should_panic(expected = "Disallowed while contract is paused")]
fn integration_fail_set_paused() {
    let owner: AccountId = "owner".parse().unwrap();
    let context = VMContextBuilder::new()
        .predecessor_account_id(owner.clone())
        .build();

    testing_env!(context);
    let mut c = Integration::new(owner.clone());

    Integration::pause(&mut c);

    c.set_value(5);
}

#[test]
#[should_panic(expected = "Owner only")]
fn integration_fail_migrate_allow() {
    let owner: AccountId = "owner".parse().unwrap();
    let alice: AccountId = "alice".parse().unwrap();
    let context = VMContextBuilder::new()
        .predecessor_account_id(owner.clone())
        .build();

    testing_env!(context);
    let c = Integration::new(owner.clone());

    env::state_write(&c);

    let context = VMContextBuilder::new()
        .predecessor_account_id(alice.clone())
        .build();

    testing_env!(context);

    MigrateIntegration::migrate();
}

#[test]
#[should_panic(expected = "Disallowed while contract is paused")]
fn integration_fail_migrate_paused() {
    let owner: AccountId = "owner".parse().unwrap();
    let context = VMContextBuilder::new()
        .predecessor_account_id(owner.clone())
        .build();

    testing_env!(context);
    let mut c = Integration::new(owner.clone());

    Integration::pause(&mut c);

    env::state_write(&c);

    MigrateIntegration::migrate();
}
#[test]
#[should_panic(expected = "Already locked")]
fn integration_fail_cannot_lock_twice() {
    let owner: AccountId = "owner".parse().unwrap();
    let context = VMContextBuilder::new()
        .predecessor_account_id(owner.clone())
        .build();

    testing_env!(context);
    let mut c = Integration::new(owner.clone());

    let id = 1;
    let data = "Data".to_string();
    c.lock_data(id, data.clone());
    c.lock_data(id, data.clone());
}

#[cfg(test)]
mod pausable_fungible_token {
    use near_sdk::{
        env, near, test_utils::VMContextBuilder, testing_env, AccountId, NearToken, PanicOnDefault,
    };
    use near_sdk_contract_tools::{
        ft::*,
        hook::Hook,
        pause::{hooks::Pausable, Pause},
        Pause,
    };

    #[derive(FungibleToken, Pause, PanicOnDefault)]
    #[fungible_token(all_hooks = "Pausable", transfer_hook = "TransferHook")]
    #[near(contract_state)]
    struct Contract {
        pub storage_usage: u64,
    }

    #[near]
    impl Contract {
        #[init]
        pub fn new() -> Self {
            let mut contract = Self { storage_usage: 0 };

            contract.set_metadata(&ContractMetadata::new("Pausable Fungible Token", "PFT", 18));

            contract
        }
    }

    #[derive(Default)]
    struct TransferHook;

    impl Hook<Contract, Nep141Transfer<'_>> for TransferHook {
        fn hook<R>(
            contract: &mut Contract,
            _args: &Nep141Transfer,
            f: impl FnOnce(&mut Contract) -> R,
        ) -> R {
            let state = env::storage_usage();
            let r = f(contract);
            let storage_delta = env::storage_usage() - state;
            println!("Storage delta: {storage_delta}");

            contract.storage_usage = storage_delta;
            r
        }
    }

    #[test]
    fn hooks_modify_state() {
        let alice: AccountId = "alice".parse().unwrap();
        let bob: AccountId = "bob_account".parse().unwrap();

        let mut c = Contract::new();

        let context = VMContextBuilder::new()
            .attached_deposit(NearToken::from_near(1).saturating_div(100))
            .predecessor_account_id(alice.clone())
            .build();
        testing_env!(context);
        c.storage_deposit(None, None);
        let context = VMContextBuilder::new()
            .attached_deposit(NearToken::from_near(1).saturating_div(100))
            .predecessor_account_id(bob.clone())
            .build();
        testing_env!(context);
        c.storage_deposit(None, None);

        c.deposit_unchecked(&alice, 100).unwrap();

        let context = VMContextBuilder::new()
            .attached_deposit(NearToken::from_yoctonear(1))
            .predecessor_account_id(alice.clone())
            .build();
        testing_env!(context);

        c.ft_transfer(bob.clone(), 50.into(), None);

        assert_ne!(c.storage_usage, 0);
    }

    #[test]
    #[should_panic(expected = "Disallowed while contract is paused")]
    fn hooks_can_terminate_on_error() {
        let alice: AccountId = "alice".parse().unwrap();
        let bob: AccountId = "bob_account".parse().unwrap();

        let mut c = Contract::new();

        c.deposit_unchecked(&alice, 100).unwrap();

        let context = VMContextBuilder::new()
            .attached_deposit(NearToken::from_yoctonear(1))
            .predecessor_account_id(alice.clone())
            .build();

        testing_env!(context);

        Pause::pause(&mut c);

        c.ft_transfer(bob.clone(), 50.into(), None);
    }
}

#[cfg(test)]
mod owned_fungible_token {
    use near_sdk::{
        env, json_types::U128, near, test_utils::VMContextBuilder, testing_env, AccountId,
    };
    use near_sdk::{NearToken, PanicOnDefault};
    use near_sdk_contract_tools::{
        ft::*,
        owner::{hooks::OnlyOwner, *},
        Owner,
    };

    #[derive(Owner, FungibleToken, PanicOnDefault)]
    #[fungible_token(all_hooks = "OnlyOwner")] // only the owner can transfer, etc. the tokens
    #[near(contract_state)]
    pub struct Contract {}

    #[near]
    impl Contract {
        #[init]
        pub fn new() -> Self {
            let mut contract = Self {};

            Owner::init(&mut contract, &env::predecessor_account_id());

            contract
        }

        pub fn mint(&mut self, amount: U128) {
            Nep141Controller::mint(
                self,
                &Nep141Mint::new(amount.0, env::predecessor_account_id()),
            )
            .unwrap();
        }
    }

    #[test]
    fn mint_and_transfer() {
        let alice: AccountId = "alice".parse().unwrap();
        let bob: AccountId = "bob".parse().unwrap();
        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(alice.clone())
            .build());

        let mut contract = Contract::new(); // since alice is the predecessor during init, alice is the owner

        // internal method calls
        contract
            .deposit_to_storage_account(&alice, NearToken::from_near(1))
            .unwrap();
        contract
            .deposit_to_storage_account(&bob, NearToken::from_near(1))
            .unwrap();

        // external; alice is still predecessor
        contract.mint(U128(100));

        assert_eq!(contract.ft_balance_of(alice.clone()), U128(100));
        assert_eq!(contract.ft_balance_of(bob.clone()), U128(0));

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(alice.clone())
            .attached_deposit(NearToken::from_yoctonear(1u128))
            .build());
        contract.ft_transfer(bob.clone(), U128(10), None);

        assert_eq!(contract.ft_balance_of(alice), U128(90));
        assert_eq!(contract.ft_balance_of(bob), U128(10));
    }

    #[test]
    #[should_panic = "Owner only"]
    fn mint_fail_not_owner() {
        let alice: AccountId = "alice".parse().unwrap();
        let bob: AccountId = "bob".parse().unwrap();
        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(alice.clone())
            .build());

        let mut contract = Contract::new(); // since alice is the predecessor during init, alice is the owner

        // internal method calls
        contract
            .deposit_to_storage_account(&alice, NearToken::from_near(1))
            .unwrap();
        contract
            .deposit_to_storage_account(&bob, NearToken::from_near(1))
            .unwrap();

        testing_env!(VMContextBuilder::new().predecessor_account_id(bob).build());

        contract.mint(U128(100));
    }

    #[test]
    #[should_panic = "Owner only"]
    fn transfer_fail_not_owner() {
        let alice: AccountId = "alice".parse().unwrap();
        let bob: AccountId = "bob".parse().unwrap();
        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(alice.clone())
            .build());

        let mut contract = Contract::new(); // since alice is the predecessor during init, alice is the owner

        // internal method calls
        contract
            .deposit_to_storage_account(&alice, NearToken::from_near(1))
            .unwrap();
        contract
            .deposit_to_storage_account(&bob, NearToken::from_near(1))
            .unwrap();

        Nep141Controller::deposit_unchecked(&mut contract, &bob, 100).unwrap();

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(bob)
            .attached_deposit(NearToken::from_yoctonear(1))
            .build());
        contract.ft_transfer(alice, U128(10), None);
    }
}

'''
'''--- tests/macros/owner.rs ---
use near_sdk::{
    env, near, test_utils::VMContextBuilder, testing_env, AccountId, BorshStorageKey,
    PanicOnDefault,
};
use near_sdk_contract_tools::{
    owner::{Owner, OwnerExternal},
    Owner,
};

mod implicit_key {
    use super::*;

    #[derive(Owner, PanicOnDefault)]
    #[near(contract_state)]
    pub struct OwnedStructImplicitKey {
        pub permissioned_item: u32,
    }

    #[near]
    impl OwnedStructImplicitKey {
        #[init]
        pub fn new() -> Self {
            let mut contract = Self {
                permissioned_item: 0,
            };

            // This method can only be called once throughout the entire duration of the contract
            Owner::init(&mut contract, &env::predecessor_account_id());

            contract
        }

        pub fn set_permissioned_item(&mut self, value: u32) {
            Self::require_owner();

            self.permissioned_item = value;
        }

        pub fn get_permissioned_item(&self) -> u32 {
            self.permissioned_item
        }
    }
}
use implicit_key::OwnedStructImplicitKey;

#[derive(BorshStorageKey)]
#[near]
enum StorageKey {
    MyStorageKey,
}

#[derive(Owner, PanicOnDefault)]
#[owner(storage_key = "StorageKey::MyStorageKey")]
#[near(contract_state)]
pub struct OwnedStructExplicitKey {
    pub permissioned_item: u32,
}

#[near]
impl OwnedStructExplicitKey {
    #[init]
    pub fn new() -> Self {
        let mut contract = Self {
            permissioned_item: 0,
        };

        // This method can only be called once throughout the entire duration of the contract
        Owner::init(&mut contract, &env::predecessor_account_id());

        contract
    }

    pub fn try_init_again(&mut self) {
        // Should fail
        Owner::init(self, &env::predecessor_account_id());
    }

    pub fn set_permissioned_item(&mut self, value: u32) {
        Self::require_owner();

        self.permissioned_item = value;
    }

    pub fn get_permissioned_item(&self) -> u32 {
        self.permissioned_item
    }
}

#[test]
fn derive_owner_im() {
    let owner: AccountId = "owner".parse().unwrap();
    let context = VMContextBuilder::new()
        .predecessor_account_id(owner.clone())
        .build();

    testing_env!(context);
    let mut c = OwnedStructImplicitKey::new();

    assert_eq!(
        c.own_get_owner(),
        Some(owner.clone()),
        "Owner is initialized",
    );

    c.set_permissioned_item(4);

    assert_eq!(
        c.get_permissioned_item(),
        4,
        "Permissioned item set correctly",
    );
}

#[test]
#[should_panic(expected = "Owner only")]
fn derive_owner_im_unauthorized() {
    let owner: AccountId = "owner".parse().unwrap();
    let context = VMContextBuilder::new()
        .predecessor_account_id(owner.clone())
        .build();

    testing_env!(context);
    let mut c = OwnedStructImplicitKey::new();

    let alice: AccountId = "alice".parse().unwrap();
    let context = VMContextBuilder::new()
        .predecessor_account_id(alice.clone())
        .build();
    testing_env!(context);

    // Alice is not authorized to call owner-only method
    c.set_permissioned_item(4);
}

#[test]
fn derive_owner_ex() {
    let owner: AccountId = "owner".parse().unwrap();
    let context = VMContextBuilder::new()
        .predecessor_account_id(owner.clone())
        .build();

    testing_env!(context);
    let mut c = OwnedStructExplicitKey::new();

    assert_eq!(
        c.own_get_owner(),
        Some(owner.clone()),
        "Owner is initialized",
    );

    c.set_permissioned_item(4);

    assert_eq!(
        c.get_permissioned_item(),
        4,
        "Permissioned item set correctly",
    );
}

#[test]
#[should_panic(expected = "Owner already initialized")]
fn derive_owner_ex_init_again() {
    let owner: AccountId = "owner".parse().unwrap();
    let context = VMContextBuilder::new()
        .predecessor_account_id(owner.clone())
        .build();

    testing_env!(context);
    let mut c = OwnedStructExplicitKey::new();

    c.try_init_again();
}

#[test]
#[should_panic(expected = "Owner only")]
fn derive_owner_ex_unauthorized() {
    let owner: AccountId = "owner".parse().unwrap();
    let context = VMContextBuilder::new()
        .predecessor_account_id(owner.clone())
        .build();

    testing_env!(context);
    let mut c = OwnedStructExplicitKey::new();

    let alice: AccountId = "alice".parse().unwrap();
    let context = VMContextBuilder::new()
        .predecessor_account_id(alice.clone())
        .build();
    testing_env!(context);

    // Alice is not authorized to call owner-only method
    c.set_permissioned_item(4);
}

'''
'''--- tests/macros/pause.rs ---
use near_sdk::{near, BorshStorageKey, PanicOnDefault};
use near_sdk_contract_tools::{
    pause::{Pause, PauseExternal},
    Pause,
};

#[derive(BorshStorageKey)]
#[near]
enum StorageKey {
    Pause,
}

mod implicit_key {
    use super::*;

    #[derive(Pause, PanicOnDefault)]
    #[near(contract_state)]
    struct ContractImplicitKey {}
}

#[derive(Pause, PanicOnDefault)]
#[pause(storage_key = "StorageKey::Pause")]
#[near(contract_state)]
struct Contract {
    pub value: u32,
}

#[near]
impl Contract {
    pub fn only_when_unpaused(&mut self, value: u32) {
        Self::require_unpaused();

        self.value = value;
    }

    pub fn only_when_paused(&mut self, value: u32) {
        Self::require_paused();

        self.value = value;
    }

    pub fn get_value(&self) -> u32 {
        self.value
    }
}

#[test]
fn derive_pause() {
    let mut contract = Contract { value: 0 };

    assert!(
        !contract.paus_is_paused(),
        "Initial state should be unpaused",
    );

    Contract::require_unpaused();

    contract.pause();

    assert!(contract.paus_is_paused(), "Pausing the contract works");

    Contract::require_paused();

    contract.unpause();

    assert!(!contract.paus_is_paused(), "Unpausing the contract works");

    Contract::require_unpaused();
}

#[test]
fn derive_pause_methods() {
    let mut contract = Contract { value: 0 };

    contract.only_when_unpaused(5);

    assert_eq!(contract.get_value(), 5);

    contract.pause();

    contract.only_when_paused(10);

    assert_eq!(contract.get_value(), 10);
}

#[test]
#[should_panic(expected = "Disallowed while contract is unpaused")]
fn derive_pause_methods_fail_unpaused() {
    let mut contract = Contract { value: 0 };

    contract.only_when_paused(5);
}

#[test]
#[should_panic(expected = "Disallowed while contract is paused")]
fn derive_pause_methods_fail_paused() {
    let mut contract = Contract { value: 0 };

    contract.pause();

    contract.only_when_unpaused(5);
}

'''
'''--- tests/macros/standard/fungible_token.rs ---
use near_sdk::{json_types::Base64VecU8, near, PanicOnDefault};
use near_sdk_contract_tools::ft::*;

#[derive(FungibleToken, PanicOnDefault)]
#[near(contract_state)]
struct MyFungibleTokenContract {}

#[near]
impl MyFungibleTokenContract {
    #[init]
    pub fn new() -> Self {
        let mut contract = Self {};

        contract.set_metadata(
            &ContractMetadata::new("My Fungible Token", "MYFT", 24)
                .icon("https://example.com/icon.png")
                .reference("https://example.com/metadata.json")
                .reference_hash(Base64VecU8::from([97, 115, 100, 102].to_vec())),
        );

        contract
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::{test_utils::VMContextBuilder, testing_env, AccountId, NearToken};

    #[test]
    fn fungible_token_transfer() {
        let mut ft = MyFungibleTokenContract::new();

        let alice: AccountId = "alice".parse().unwrap();
        let bob: AccountId = "bob".parse().unwrap();

        let context = VMContextBuilder::new()
            .predecessor_account_id(alice.clone())
            .attached_deposit(NearToken::from_near(1u128).saturating_div(100))
            .build();
        testing_env!(context);
        ft.storage_deposit(None, None);

        let context = VMContextBuilder::new()
            .predecessor_account_id(bob.clone())
            .attached_deposit(NearToken::from_near(1u128).saturating_div(100))
            .build();
        testing_env!(context);
        ft.storage_deposit(None, None);

        assert_eq!(ft.ft_balance_of(alice.clone()).0, 0);
        assert_eq!(ft.ft_balance_of(bob.clone()).0, 0);
        assert_eq!(ft.ft_total_supply().0, 0);

        ft.deposit_unchecked(&alice, 100).unwrap();
        ft.deposit_unchecked(&bob, 20).unwrap();

        assert_eq!(ft.ft_balance_of(alice.clone()).0, 100);
        assert_eq!(ft.ft_balance_of(bob.clone()).0, 20);
        assert_eq!(ft.ft_total_supply().0, 120);

        let context = VMContextBuilder::new()
            .predecessor_account_id(alice.clone())
            .attached_deposit(NearToken::from_yoctonear(1u128))
            .build();

        testing_env!(context);

        ft.ft_transfer(bob.clone(), 50.into(), None);

        assert_eq!(ft.ft_balance_of(alice.clone()).0, 50);
        assert_eq!(ft.ft_balance_of(bob.clone()).0, 70);
        assert_eq!(ft.ft_total_supply().0, 120);
    }

    #[test]
    fn metadata() {
        let ft = MyFungibleTokenContract::new();
        let meta = ft.ft_metadata();

        assert_eq!(meta.decimals, 24);
        assert_eq!(meta.name, "My Fungible Token");
        assert_eq!(meta.symbol, "MYFT");
        assert_eq!(meta.icon, Some("https://example.com/icon.png".into()));
        assert_eq!(
            meta.reference,
            Some("https://example.com/metadata.json".into())
        );
        assert_eq!(
            meta.reference_hash,
            Some(Base64VecU8::from([97, 115, 100, 102].to_vec()))
        );
    }
}

'''
'''--- tests/macros/standard/mod.rs ---
pub mod fungible_token;
pub mod nep141;
pub mod nep145;
pub mod nep148;
pub mod nep171;

'''
'''--- tests/macros/standard/nep141.rs ---
use near_sdk::{
    borsh, collections::Vector, env, json_types::U128, log, near, test_utils::VMContextBuilder,
    testing_env, AccountId, NearToken, PanicOnDefault, PromiseOrValue,
};
use near_sdk_contract_tools::{hook::Hook, standard::nep141::*, Nep141};

#[derive(Nep141, PanicOnDefault)]
#[nep141(transfer_hook = "TransferHook")]
#[near(contract_state)]
struct FungibleToken {
    pub transfers: Vector<Vec<u8>>,
    pub hooks: Vector<String>,
}

#[derive(Default)]
struct TransferHook;

impl Hook<FungibleToken, Nep141Transfer<'_>> for TransferHook {
    fn hook<R>(
        contract: &mut FungibleToken,
        args: &Nep141Transfer,
        f: impl FnOnce(&mut FungibleToken) -> R,
    ) -> R {
        let storage_usage_start = env::storage_usage();
        contract.hooks.push(&"before_transfer".to_string());
        let r = f(contract);
        contract.hooks.push(&"after_transfer".to_string());
        contract.transfers.push(&borsh::to_vec(&args).unwrap());
        let storage_usage_end = env::storage_usage();
        println!("Storage delta: {}", storage_usage_end - storage_usage_start);
        r
    }
}

mod receiver {
    use super::*;

    #[derive(PanicOnDefault)]
    #[near(contract_state)]
    struct FungibleTokenReceiver {
        pub log: Vector<(String, u128)>,
    }

    impl near_sdk_contract_tools::standard::nep141::Nep141Receiver for FungibleTokenReceiver {
        fn ft_on_transfer(
            &mut self,
            sender_id: AccountId,
            amount: U128,
            msg: String,
        ) -> PromiseOrValue<U128> {
            let used_amount: u128 = amount.0 / 2;

            let out = format!("ft_on_transfer[from={sender_id}, used={used_amount}]");
            log!(&out);
            println!("{out}");

            self.log.push(&(msg, amount.0));

            PromiseOrValue::Value(U128(used_amount))
        }
    }
}

#[test]
fn nep141_transfer() {
    let mut ft = FungibleToken {
        transfers: Vector::new(b"t"),
        hooks: Vector::new(b"h"),
    };

    let alice: AccountId = "alice".parse().unwrap();
    let bob: AccountId = "bob".parse().unwrap();

    assert_eq!(ft.ft_balance_of(alice.clone()).0, 0);
    assert_eq!(ft.ft_balance_of(bob.clone()).0, 0);
    assert_eq!(ft.ft_total_supply().0, 0);

    ft.deposit_unchecked(&alice, 100).unwrap();
    ft.deposit_unchecked(&bob, 20).unwrap();

    assert_eq!(ft.transfers.pop(), None);
    assert_eq!(ft.ft_balance_of(alice.clone()).0, 100);
    assert_eq!(ft.ft_balance_of(bob.clone()).0, 20);
    assert_eq!(ft.ft_total_supply().0, 120);

    let context = VMContextBuilder::new()
        .predecessor_account_id(alice.clone())
        .attached_deposit(NearToken::from_yoctonear(1u128))
        .build();

    testing_env!(context);

    ft.ft_transfer(bob.clone(), 50.into(), None);

    assert_eq!(
        ft.transfers.pop(),
        Some(borsh::to_vec(&Nep141Transfer::new(50, alice.clone(), bob.clone())).unwrap())
    );

    let expected_hook_execution_order = vec!["before_transfer", "after_transfer"];
    let actual_hook_execution_order = ft.hooks.to_vec();
    assert_eq!(expected_hook_execution_order, actual_hook_execution_order);

    assert_eq!(ft.ft_balance_of(alice).0, 50);
    assert_eq!(ft.ft_balance_of(bob).0, 70);
    assert_eq!(ft.ft_total_supply().0, 120);
}

'''
'''--- tests/macros/standard/nep145.rs ---
use near_sdk::{env, log, near, store::LookupMap, AccountId, NearToken, PanicOnDefault};
use near_sdk_contract_tools::{hook::Hook, standard::nep145::*, Nep145};

#[derive(Nep145, PanicOnDefault)]
#[nep145(force_unregister_hook = "ForceUnregisterHook")]
#[near(contract_state)]
pub struct Contract {
    pub storage: LookupMap<AccountId, Vec<u64>>,
}

pub struct ForceUnregisterHook;

impl Hook<Contract, Nep145ForceUnregister<'_>> for ForceUnregisterHook {
    fn hook<R>(
        contract: &mut Contract,
        _args: &Nep145ForceUnregister<'_>,
        f: impl FnOnce(&mut Contract) -> R,
    ) -> R {
        log!("Before force unregister");
        let r = f(contract);
        log!("After force unregister");
        r
    }
}

#[near]
impl Contract {
    #[init]
    pub fn new() -> Self {
        let mut contract = Self {
            storage: LookupMap::new(b"s"),
        };

        Nep145Controller::set_storage_balance_bounds(
            &mut contract,
            &StorageBalanceBounds {
                min: NearToken::from_yoctonear(0),
                max: None,
            },
        );

        contract
    }

    pub fn use_storage(&mut self, num: u64) {
        let storage_usage_start = env::storage_usage();

        let predecessor = env::predecessor_account_id();

        self.storage.insert(predecessor.clone(), (0..num).collect());

        self.storage.flush();

        let storage_usage = env::storage_usage() - storage_usage_start;
        let storage_fee = env::storage_byte_cost().saturating_mul(u128::from(storage_usage));

        Nep145Controller::lock_storage(self, &predecessor, storage_fee)
            .unwrap_or_else(|e| env::panic_str(&format!("Storage lock error: {e}")));
    }
}

#[cfg(test)]
mod tests {
    use near_sdk::{test_utils::VMContextBuilder, testing_env, NearToken};

    use super::*;

    fn alice() -> AccountId {
        "alice.near".parse().unwrap()
    }

    #[test]
    fn storage_sanity_check() {
        let one_near = NearToken::from_near(1u128);
        let byte_cost = env::storage_byte_cost();

        let mut contract = Contract::new();

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(alice())
            .attached_deposit(one_near)
            .build());

        Nep145::storage_deposit(&mut contract, None, None);

        assert_eq!(
            Nep145::storage_balance_of(&contract, alice()),
            Some(StorageBalance {
                total: one_near,
                available: one_near,
            }),
        );

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(alice())
            .build());

        contract.use_storage(1000);

        let first = Nep145::storage_balance_of(&contract, alice()).unwrap();

        assert_eq!(first.total, one_near);
        assert!(
            one_near.as_yoctonear()
                - (first.available.as_yoctonear() + 8 * 1000 * byte_cost.as_yoctonear())
                < 100 * byte_cost.as_yoctonear()
        ); // about 100 bytes for storing keys, etc.

        contract.use_storage(2000);

        let second = Nep145::storage_balance_of(&contract, alice()).unwrap();

        assert_eq!(second.total, one_near);
        assert_eq!(
            second.available.as_yoctonear(),
            first.available.as_yoctonear() - 8 * 1000 * byte_cost.as_yoctonear()
        );

        let available = second.available;
        let half_available = available.saturating_div(2);

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(alice())
            .attached_deposit(NearToken::from_yoctonear(1))
            .build());

        Nep145::storage_withdraw(&mut contract, Some(half_available));

        let third = Nep145::storage_balance_of(&contract, alice()).unwrap();

        assert_eq!(third.total, one_near.saturating_sub(half_available));
        assert_eq!(third.available, half_available);

        Nep145::storage_withdraw(&mut contract, None);

        let fourth = Nep145::storage_balance_of(&contract, alice()).unwrap();

        assert_eq!(fourth.total, one_near.saturating_sub(available));
        assert_eq!(fourth.available, NearToken::from_yoctonear(0));
    }

    #[test]
    #[should_panic = "insufficient balance"]
    fn storage_over_lock_fail() {
        let one_near = NearToken::from_near(1u128);
        let byte_cost = env::storage_byte_cost();

        let mut contract = Contract::new();

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(alice())
            .attached_deposit(one_near)
            .build());

        Nep145::storage_deposit(&mut contract, None, None);

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(alice())
            .build());

        #[allow(clippy::cast_possible_truncation)]
        contract.use_storage(
            one_near
                .as_yoctonear()
                .saturating_div(byte_cost.as_yoctonear()) as u64
                + 1,
        );
    }

    #[test]
    #[should_panic = "insufficient balance"]
    fn storage_over_withdraw_fail() {
        let mut contract = Contract::new();

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(alice())
            .attached_deposit(NearToken::from_near(1))
            .build());

        Nep145::storage_deposit(&mut contract, None, None);

        let balance = Nep145::storage_balance_of(&contract, alice()).unwrap();

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(alice())
            .attached_deposit(NearToken::from_yoctonear(1))
            .build());

        Nep145::storage_withdraw(
            &mut contract,
            Some(
                balance
                    .available
                    .saturating_add(NearToken::from_yoctonear(1)),
            ),
        );
    }
}

'''
'''--- tests/macros/standard/nep148.rs ---
use near_sdk::{json_types::Base64VecU8, near, PanicOnDefault};
use near_sdk_contract_tools::{standard::nep148::*, Nep148};

#[derive(Nep148, PanicOnDefault)]
#[near(contract_state)]
struct DerivesFTMetadata {}

#[near]
impl DerivesFTMetadata {
    #[init]
    pub fn new() -> Self {
        let mut contract = Self {};

        contract.set_metadata(
            &ContractMetadata::new("Test Fungible Token", "TFT", 18)
                .icon("https://example.com/icon.png")
                .reference("https://example.com/metadata.json")
                .reference_hash(vec![97, 115, 100, 102]),
        );

        contract
    }
}

#[test]
fn test() {
    let ft = DerivesFTMetadata::new();
    let meta = ft.ft_metadata();
    println!("{:?}", &meta);
    assert_eq!(meta.decimals, 18);
    assert_eq!(meta.name, "Test Fungible Token");
    assert_eq!(meta.symbol, "TFT");
    assert_eq!(meta.icon, Some("https://example.com/icon.png".into()));
    assert_eq!(
        meta.reference,
        Some("https://example.com/metadata.json".into())
    );
    assert_eq!(
        meta.reference_hash,
        Some(Base64VecU8::from([97, 115, 100, 102].to_vec()))
    );
}

'''
'''--- tests/macros/standard/nep171/hooks.rs ---
use near_sdk::{log, near, PanicOnDefault};
use near_sdk_contract_tools::{hook::Hook, nft::*};

#[derive(Nep171, PanicOnDefault)]
#[nep171(transfer_hook = "Self")]
#[near(contract_state)]
pub struct Contract {
    transfer_count: u32,
}

impl Hook<Contract, Nep171Transfer<'_>> for Contract {
    fn hook<R>(
        contract: &mut Contract,
        args: &Nep171Transfer,
        f: impl FnOnce(&mut Contract) -> R,
    ) -> R {
        log!(
            "{:?} is transferring {} to {}",
            args.sender_id,
            args.token_id,
            args.receiver_id,
        );
        let r = f(contract);
        contract.transfer_count += 1;
        r
    }
}

'''
'''--- tests/macros/standard/nep171/manual_integration.rs ---
use near_sdk::{env, near, PanicOnDefault};
use near_sdk_contract_tools::{
    hook::Hook,
    owner::Owner,
    pause::Pause,
    standard::{
        nep171::*,
        nep177::{self, Nep177Controller},
        nep178, nep181,
    },
    Nep171, Nep177, Nep178, Nep181, Owner, Pause,
};

#[derive(Nep171, Nep177, Nep178, Nep181, Pause, Owner, PanicOnDefault)]
#[nep171(
    all_hooks = "(nep178::TokenApprovals, nep181::TokenEnumeration)",
    transfer_hook = "Self",
    check_external_transfer = "nep178::TokenApprovals",
    token_data = "(nep177::TokenMetadata, nep178::TokenApprovals)"
)]
#[nep178()]
#[near(contract_state)]
pub struct Contract {
    next_token_id: u32,
}

impl Hook<Contract, action::Nep171Transfer<'_>> for Contract {
    fn hook<R>(
        contract: &mut Contract,
        _args: &action::Nep171Transfer<'_>,
        f: impl FnOnce(&mut Contract) -> R,
    ) -> R {
        Contract::require_unpaused();
        f(contract)
    }
}

#[near]
impl Contract {
    #[init]
    pub fn new() -> Self {
        let mut contract = Self { next_token_id: 0 };

        contract.set_contract_metadata(&nep177::ContractMetadata::new(
            "My NFT".to_string(),
            "MYNFT".to_string(),
            None,
        ));

        Owner::init(&mut contract, &env::predecessor_account_id());

        contract
    }

    pub fn mint(&mut self) -> TokenId {
        Self::require_unpaused();

        let token_id = format!("token_{}", self.next_token_id);
        self.next_token_id += 1;
        Nep177Controller::mint_with_metadata(
            self,
            &token_id,
            &env::predecessor_account_id(),
            &nep177::TokenMetadata::new()
                .title(format!("Token {token_id}"))
                .description(format!("This is token {token_id}.")),
        )
        .unwrap_or_else(|e| env::panic_str(&format!("Minting failed: {e}")));

        token_id
    }
}

'''
'''--- tests/macros/standard/nep171/mod.rs ---
#![allow(dead_code)]

use near_sdk::{env, near, store, AccountId, PanicOnDefault};
use near_sdk_contract_tools::{hook::Hook, nft::*};

mod hooks;
mod manual_integration;
mod no_hooks;
mod non_fungible_token;

#[derive(Debug, Clone, PartialEq, PartialOrd)]
#[near]
struct TokenRecord {
    owner_id: AccountId,
    token_id: TokenId,
}

impl From<Token> for TokenRecord {
    fn from(token: Token) -> Self {
        Self {
            owner_id: token.owner_id,
            token_id: token.token_id,
        }
    }
}

mod full_no_hooks {
    use near_sdk::NearToken;

    use super::*;

    #[derive(NonFungibleToken, PanicOnDefault)]
    #[near(contract_state)]
    struct NonFungibleTokenNoHooks {
        pub before_nft_transfer_balance_record: store::Vector<Option<TokenRecord>>,
        pub after_nft_transfer_balance_record: store::Vector<Option<TokenRecord>>,
    }

    #[test]
    fn nft_no_hooks() {
        let mut n = NonFungibleTokenNoHooks {
            before_nft_transfer_balance_record: store::Vector::new(b"a"),
            after_nft_transfer_balance_record: store::Vector::new(b"b"),
        };

        let token_id = "token1".to_string();
        let alice: AccountId = "alice".parse().unwrap();

        Nep145Controller::deposit_to_storage_account(&mut n, &alice, NearToken::from_near(1))
            .unwrap();

        n.mint_with_metadata(&token_id, &alice, &TokenMetadata::new().title("Title"))
            .unwrap();

        let nft_tok = n.nft_token(token_id);
        dbg!(nft_tok);
    }
}

#[derive(Nep171, PanicOnDefault)]
#[nep171(transfer_hook = "Self")]
#[near(contract_state)]
struct NonFungibleToken {
    pub before_nft_transfer_balance_record: store::Vector<Option<TokenRecord>>,
    pub after_nft_transfer_balance_record: store::Vector<Option<TokenRecord>>,
}

impl Hook<NonFungibleToken, Nep171Transfer<'_>> for NonFungibleToken {
    fn hook<R>(
        contract: &mut NonFungibleToken,
        args: &Nep171Transfer<'_>,
        f: impl FnOnce(&mut NonFungibleToken) -> R,
    ) -> R {
        let before_nft_transfer = contract.nft_token(args.token_id.clone()).map(Into::into);
        contract
            .before_nft_transfer_balance_record
            .push(before_nft_transfer);
        let r = f(contract);
        let after_nft_transfer = contract.nft_token(args.token_id.clone()).map(Into::into);
        contract
            .after_nft_transfer_balance_record
            .push(after_nft_transfer);
        r
    }
}

#[near]
impl NonFungibleToken {
    #[init]
    pub fn new() -> Self {
        Self {
            before_nft_transfer_balance_record: store::Vector::new(b"b"),
            after_nft_transfer_balance_record: store::Vector::new(b"a"),
        }
    }

    pub fn mint(&mut self, token_id: TokenId, receiver_id: AccountId) {
        Nep171Controller::mint(self, &Nep171Mint::new(vec![token_id], receiver_id)).unwrap_or_else(
            |e| {
                env::panic_str(&format!("Mint failed: {e:?}"));
            },
        );
    }
}

mod tests {
    use near_sdk::{
        test_utils::{get_logs, VMContextBuilder},
        testing_env, AccountId, NearToken,
    };
    use near_sdk_contract_tools::standard::{
        nep171::{
            event::{Nep171Event, NftTransferLog},
            Nep171,
        },
        nep297::Event,
    };

    use super::*;

    #[test]
    fn hook_execution_success() {
        let mut contract = NonFungibleToken::new();
        let token_id = "token1";
        let account_alice: AccountId = "alice.near".parse().unwrap();
        let account_bob: AccountId = "bob.near".parse().unwrap();

        contract.mint(token_id.to_string(), account_alice.clone());

        assert_eq!(
            contract.before_nft_transfer_balance_record.get(0),
            None,
            "before_nft_transfer_balance_record should be empty",
        );
        assert_eq!(
            contract.after_nft_transfer_balance_record.get(0),
            None,
            "after_nft_transfer_balance_record should be empty",
        );

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(account_alice.clone())
            .attached_deposit(NearToken::from_yoctonear(1u128))
            .build());

        contract.nft_transfer(account_bob.clone(), token_id.to_string(), None, None);

        assert_eq!(
            contract.before_nft_transfer_balance_record.get(0),
            Some(&Some(TokenRecord {
                owner_id: account_alice.clone(),
                token_id: token_id.to_string(),
            })),
            "before_nft_transfer_balance_record should contain the token record for the original owner before transferring",
        );
        assert_eq!(
            contract.after_nft_transfer_balance_record.get(0),
            Some(&Some(TokenRecord {
                owner_id: account_bob.clone(),
                token_id: token_id.to_string(),
            })),
            "after_nft_transfer_balance_record should contain the token record for the new owner after transferring",
        );

        assert_eq!(
            get_logs(),
            vec![Nep171Event::NftTransfer(vec![NftTransferLog {
                memo: None,
                authorized_id: None,
                old_owner_id: account_alice.into(),
                new_owner_id: account_bob.into(),
                token_ids: vec![token_id.into()]
            }])
            .to_event_string()]
        );
    }
}

'''
'''--- tests/macros/standard/nep171/no_hooks.rs ---
use near_sdk::{env, near, PanicOnDefault};
use near_sdk_contract_tools::nft::*;

#[derive(Nep171, PanicOnDefault)]
#[near(contract_state)]
pub struct Contract {
    pub next_token_id: u32,
}

#[near]
impl Contract {
    pub fn mint(&mut self) -> TokenId {
        let token_id = format!("token_{}", self.next_token_id);
        self.next_token_id += 1;

        Nep171Controller::mint(
            self,
            &Nep171Mint::new(vec![token_id.clone()], env::predecessor_account_id()),
        )
        .unwrap_or_else(|e| env::panic_str(&format!("Minting failed: {e}")));

        token_id
    }
}

'''
'''--- tests/macros/standard/nep171/non_fungible_token.rs ---
use near_sdk::{env, near, PanicOnDefault};
use near_sdk_contract_tools::{
    nft::*,
    owner::Owner,
    pause::{hooks::Pausable, Pause},
    Owner, Pause,
};

#[derive(NonFungibleToken, Pause, Owner, PanicOnDefault)]
#[non_fungible_token(transfer_hook = "Pausable")]
#[near(contract_state)]
pub struct Contract {
    next_token_id: u32,
}

#[near]
impl Contract {
    #[init]
    pub fn new() -> Self {
        let mut contract = Self { next_token_id: 0 };

        contract.set_contract_metadata(&ContractMetadata::new(
            "My NFT".to_string(),
            "MYNFT".to_string(),
            None,
        ));

        Owner::init(&mut contract, &env::predecessor_account_id());

        contract
    }

    pub fn mint(&mut self) -> TokenId {
        Self::require_unpaused();

        let token_id = format!("token_{}", self.next_token_id);
        self.next_token_id += 1;
        self.mint_with_metadata(
            &token_id,
            &env::predecessor_account_id(),
            &TokenMetadata::new()
                .title(format!("Token {token_id}"))
                .description(format!("This is token {token_id}.")),
        )
        .unwrap_or_else(|e| env::panic_str(&format!("Minting failed: {e}")));

        token_id
    }
}

'''
'''--- tests/mod.rs ---
// They're tests: who cares if we use "foo"
#[allow(clippy::disallowed_names)]
// We don't care about test performance so much and makes for better diffs
#[allow(clippy::redundant_clone)]
mod macros;

'''
'''--- workspaces-tests-utils/Cargo.toml ---
[package]
name = "workspaces-tests-utils"
version = "0.1.0"
edition = "2021"
publish = false

[dependencies]
near-sdk = { workspace = true, default-features = false }
near-sdk-contract-tools = { path = "../", default-features = false, features = [
    "unstable",
] }
near-workspaces.workspace = true
pretty_assertions.workspace = true

[features]
unstable = ["near-sdk/unstable"]

'''
'''--- workspaces-tests-utils/src/lib.rs ---
#![allow(missing_docs)]

use near_sdk::{json_types::U128, serde::de::DeserializeOwned, serde_json::json};
use near_workspaces::{
    result::ExecutionFinalResult, types::NearToken, Account, AccountId, Contract,
};
use pretty_assertions::assert_eq;

pub const ONE_YOCTO: NearToken = NearToken::from_yoctonear(1);
pub const ONE_NEAR: NearToken = NearToken::from_near(1);

pub async fn nft_token<T: DeserializeOwned>(contract: &Contract, token_id: &str) -> Option<T> {
    contract
        .view("nft_token")
        .args_json(json!({ "token_id": token_id }))
        .await
        .unwrap()
        .json::<Option<T>>()
        .unwrap()
}

pub async fn ft_balance_of(contract: &Contract, account: &AccountId) -> u128 {
    contract
        .view("ft_balance_of")
        .args_json(json!({ "account_id": account }))
        .await
        .unwrap()
        .json::<U128>()
        .map(u128::from)
        .unwrap()
}

pub struct Setup {
    pub contract: Contract,
    pub accounts: Vec<Account>,
}

/// Setup for individual tests
pub async fn setup(wasm: &[u8], num_accounts: usize) -> Setup {
    let worker = near_workspaces::sandbox().await.unwrap();

    // Initialize contract
    let contract = worker.dev_deploy(wasm).await.unwrap();
    contract.call("new").transact().await.unwrap().unwrap();

    // Initialize user accounts
    let mut accounts = vec![];
    for _ in 0..num_accounts {
        accounts.push(worker.dev_create_account().await.unwrap());
    }

    Setup { contract, accounts }
}

/// For dynamic should_panic messages
pub fn expect_execution_error(result: &ExecutionFinalResult, expected_error: impl AsRef<str>) {
    let failures = result.failures();

    assert_eq!(failures.len(), 1);

    let actual_error_string = failures[0]
        .clone()
        .into_result()
        .unwrap_err()
        .into_inner()
        .unwrap()
        .to_string();

    assert_eq!(
        format!("Action #0: ExecutionError(\"{}\")", expected_error.as_ref()),
        actual_error_string
    );
}

'''
'''--- workspaces-tests/Cargo.toml ---
[package]
autobins = false
edition.workspace = true
name = "workspaces-tests"
publish = false
version = "0.1.0"

[[bin]]
name = "basic_adder"

[[bin]]
name = "counter_multisig"

[[bin]]
name = "cross_target"

[[bin]]
name = "escrow"

[[bin]]
name = "fungible_token"

[[bin]]
name = "fungible_token_receiver"

[[bin]]
name = "native_multisig"

[[bin]]
name = "non_fungible_token_full"

[[bin]]
name = "non_fungible_token_nep171"

[[bin]]
name = "non_fungible_token_receiver"

[[bin]]
name = "rbac"

[[bin]]
name = "simple_multisig"

[[bin]]
name = "storage_fee"

[[bin]]
name = "upgrade_bad"

[[bin]]
name = "upgrade_new"

[[bin]]
name = "upgrade_old_borsh"

[[bin]]
name = "upgrade_old_jsonbase64"

[[bin]]
name = "upgrade_old_multisig"

[[bin]]
name = "upgrade_old_raw"

[lints.clippy]
# pedantic = "warn"
new-without-default = "allow"
# must-use-candidate = "allow"
# missing-panics-doc = "allow"

[dependencies]
near-sdk.workspace = true
near-sdk-contract-tools = { path = "../", default-features = false, features = [
    "unstable",
] }
strum.workspace = true
strum_macros.workspace = true
thiserror.workspace = true

[dev-dependencies]
near-crypto.workspace = true
tokio.workspace = true
pretty_assertions.workspace = true
near-workspaces = { workspace = true, features = ["unstable"] }
workspaces-tests-utils = { path = "../workspaces-tests-utils", default-features = false, features = [
    "unstable",
] }

[features]
unstable = ["near-sdk/unstable"]

'''
'''--- workspaces-tests/Makefile.toml ---
[tasks.build]
clear = true
script = """
rustup target add wasm32-unknown-unknown
cargo build --package workspaces-tests --target wasm32-unknown-unknown --release
"""

[tasks.test]
clear = true
dependencies = ["build"]
script = """
#!/usr/bin/env bash
set -e

if [[ -n $1 ]]; then
    cargo test --package workspaces-tests --test "$1" "$2" -- --nocapture
else
    # don't show all output if running all tests
    cargo test --package workspaces-tests
fi
"""

[tasks.nextest]
clear = true
dependencies = ["build"]
script = """
#!/usr/bin/env bash
set -e

if [[ -n $2 ]]; then
    cargo nextest run --package workspaces-tests --no-default-features --test "$1" -E "test($2)"
elif [[ -n $1 ]]; then
    cargo nextest run --package workspaces-tests --no-default-features --test "$1"
else
    cargo nextest run --package workspaces-tests --no-default-features
fi
"""

'''
'''--- workspaces-tests/README.md ---
# `workspaces` tests

This package contains tests for the `near-sdk-contract-tools` package using the `workspaces` crate.

## Running the tests

1. Ensure that the Cargo extension `cargo-make` is installed: `cargo install cargo-make`
2. Run `cargo make test`

## Creating a new test

If you wish to create a new test in this package, create a new file under the `tests` directory with the name of your test.

If your test requires the creation of new smart contracts, follow these steps for each new contract:

1. Create the file in `src/bin/<contract-name>.rs` where `<contract-name>` is the name of the new smart contract.
2. Add an entry to `Cargo.toml` like so:
    ```toml
    [[bin]]
    name = "<contract-name>"
    ```
3. The new contract must contain a `main` method, although it will not be used. This is due to [limitations](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#library) on how Cargo handles packages with multiple entry points. Unfortunately, `#![no_main]` does not work for these purposes. Therefore, `src/bin/<contract-name>.rs` must contain the following:
    ```rust
    pub fn main() {}
    ```
4. Compile the smart contract using the following command:
    ```text
    cargo build --target wasm32-unknown-unknown --release --bin <contract-name>
    ```
5. Include the compiled contract in the test file:
    ```rust
    include_bytes!("../../target/wasm32-unknown-unknown/release/<contract-name>.wasm")
    ```

'''
'''--- workspaces-tests/src/bin/basic_adder.rs ---
workspaces_tests::predicate!();

use near_sdk::{near, PanicOnDefault};

#[derive(PanicOnDefault)]
#[near(contract_state)]
pub struct Contract {}

#[near]
impl Contract {
    #[init]
    pub fn new() -> Self {
        Self {}
    }

    pub fn add_five(&self, value: u32) -> u32 {
        value + 5
    }
}

'''
'''--- workspaces-tests/src/bin/counter_multisig.rs ---
workspaces_tests::predicate!();

use near_sdk::{env, near, BorshStorageKey, PanicOnDefault};
use near_sdk_contract_tools::{
    approval::{simple_multisig::Configuration, *},
    rbac::Rbac,
    Rbac, SimpleMultisig,
};
use std::string::ToString;
use strum_macros::Display;

#[derive(BorshStorageKey, Clone, Debug, Display)]
#[near]
pub enum Role {
    Member,
}

#[near(serializers = [borsh, json])]
pub enum CounterAction {
    Increment,
    Decrement,
    Reset,
}

impl Action<Contract> for CounterAction {
    type Output = u32;

    fn execute(self, contract: &mut Contract) -> Self::Output {
        match self {
            CounterAction::Increment => {
                contract.counter += 1;
            }
            CounterAction::Decrement => {
                contract.counter -= 1;
            }
            CounterAction::Reset => {
                contract.counter = 0;
            }
        }

        contract.counter
    }
}

#[derive(Rbac, SimpleMultisig, PanicOnDefault)]
#[simple_multisig(action = "CounterAction", role = "Role::Member")]
#[rbac(roles = "Role")]
#[near(contract_state)]
pub struct Contract {
    pub counter: u32,
}

#[near]
impl Contract {
    const THRESHOLD: u8 = 2;
    const VALIDITY_PERIOD_NANOSECONDS: u64 = 1_000_000 * 1_000 * 60 * 60 * 24 * 7;

    #[init]
    pub fn new() -> Self {
        <Self as ApprovalManager<_, _, _>>::init(Configuration::new(
            Self::THRESHOLD,
            Self::VALIDITY_PERIOD_NANOSECONDS,
        ));

        Self { counter: 0 }
    }

    pub fn obtain_multisig_permission(&mut self) {
        self.add_role(&env::predecessor_account_id(), &Role::Member);
    }

    pub fn request_increment(&mut self) -> u32 {
        self.create_request(CounterAction::Increment, Default::default())
            .map_err(|e| env::panic_str(&e.to_string()))
            .unwrap()
    }

    pub fn request_decrement(&mut self) -> u32 {
        self.create_request(CounterAction::Decrement, Default::default())
            .map_err(|e| env::panic_str(&e.to_string()))
            .unwrap()
    }

    pub fn request_reset(&mut self) -> u32 {
        self.create_request(CounterAction::Reset, Default::default())
            .map_err(|e| env::panic_str(&e.to_string()))
            .unwrap()
    }

    pub fn approve(&mut self, request_id: u32) {
        self.approve_request(request_id)
            .map_err(|e| env::panic_str(&e.to_string()))
            .unwrap();
    }

    pub fn get_request(
        &self,
        request_id: u32,
    ) -> Option<ActionRequest<CounterAction, simple_multisig::ApprovalState>> {
        <Self as ApprovalManager<_, _, _>>::get_request(request_id)
    }

    pub fn is_approved(&self, request_id: u32) -> bool {
        <Self as ApprovalManager<_, _, _>>::is_approved_for_execution(request_id).is_ok()
    }

    pub fn execute(&mut self, request_id: u32) -> u32 {
        self.execute_request(request_id)
            .map_err(|e| env::panic_str(&e.to_string()))
            .unwrap()
    }

    pub fn get_counter(&self) -> u32 {
        self.counter
    }
}

'''
'''--- workspaces-tests/src/bin/cross_target.rs ---
workspaces_tests::predicate!();

use near_sdk::{env, near, require, AccountId, PanicOnDefault};

#[derive(PanicOnDefault)]
#[near(contract_state)]
pub struct Contract {
    owner_id: AccountId,
    value: String,
    calls: u32,
}

#[near]
impl Contract {
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        Self {
            owner_id,
            value: "".into(),
            calls: 0,
        }
    }

    pub fn set_value(&mut self, value: String) {
        require!(env::predecessor_account_id() == self.owner_id, "Owner only");
        self.value = value;
        self.calls += 1;
    }

    pub fn get_value(&self) -> &str {
        &self.value
    }

    pub fn get_calls(&self) -> u32 {
        self.calls
    }
}

'''
'''--- workspaces-tests/src/bin/escrow.rs ---
workspaces_tests::predicate!();

use near_sdk::{env, near, AccountId, PanicOnDefault};
use near_sdk_contract_tools::{escrow::Escrow, Escrow};

#[derive(Clone)]
#[near(serializers = [borsh, json])]
pub enum PrimaryColour {
    Red,
    Yellow,
    Blue,
}

#[derive(Clone)]
#[near(serializers = [borsh, json])]
pub enum SecondaryColour {
    Orange,
    Green,
    Purple,
}

impl From<(PrimaryColour, PrimaryColour)> for SecondaryColour {
    fn from(f: (PrimaryColour, PrimaryColour)) -> Self {
        match f {
            (PrimaryColour::Red, PrimaryColour::Yellow)
            | (PrimaryColour::Yellow, PrimaryColour::Red) => Self::Orange,
            (PrimaryColour::Blue, PrimaryColour::Yellow)
            | (PrimaryColour::Yellow, PrimaryColour::Blue) => Self::Green,
            (PrimaryColour::Red, PrimaryColour::Blue)
            | (PrimaryColour::Blue, PrimaryColour::Red) => Self::Purple,
            _ => panic!("Not a secondary colour output"),
        }
    }
}

#[derive(Escrow, PanicOnDefault)]
#[escrow(id = "PrimaryColour", state = "AccountId")]
#[near(contract_state)]
pub struct Contract {}

#[near]
impl Contract {
    #[init]
    pub fn new() -> Self {
        Self {}
    }

    pub fn assign(&mut self, colour: PrimaryColour) {
        let predecessor = env::predecessor_account_id();
        self.lock(&colour, &predecessor);
    }

    pub fn mix(
        &mut self,
        colour: PrimaryColour,
        with: PrimaryColour,
    ) -> (AccountId, AccountId, SecondaryColour) {
        let predecessor = env::predecessor_account_id();

        let mut mixed_colour = SecondaryColour::Green;
        let mut paired = None;

        self.unlock(&with, |assignee| {
            mixed_colour = SecondaryColour::from((colour, with.clone()));
            paired = Some((predecessor, assignee.clone()));
            true
        });
        let (me, assignee) = paired.unwrap();
        (me, assignee, mixed_colour)
    }

    pub fn get_locked(&self, colour: PrimaryColour) -> bool {
        self.is_locked(&colour)
    }
}

'''
'''--- workspaces-tests/src/bin/fungible_token.rs ---
workspaces_tests::predicate!();

use near_sdk::{
    env,
    json_types::{Base64VecU8, U128},
    near,
    store::Vector,
    PanicOnDefault,
};
use near_sdk_contract_tools::ft::*;

#[derive(FungibleToken, PanicOnDefault)]
#[near(contract_state)]
pub struct Contract {
    blobs: Vector<Vec<u8>>,
}

#[near]
impl Contract {
    #[init]
    pub fn new() -> Self {
        let mut contract = Self {
            blobs: Vector::new(b"b"),
        };

        contract.set_metadata(&ContractMetadata::new("My Fungible Token", "MYFT", 24));

        contract
    }

    pub fn mint(&mut self, amount: U128) {
        Nep141Controller::mint(
            self,
            &Nep141Mint::new(amount.0, env::predecessor_account_id()),
        )
        .unwrap();
    }

    pub fn use_storage(&mut self, blob: Base64VecU8) {
        let storage_start = env::storage_usage();
        let blob = blob.into();
        self.blobs.push(blob);
        self.blobs.flush();
        let storage_end = env::storage_usage();
        self.lock_storage(
            &env::predecessor_account_id(),
            env::storage_byte_cost().saturating_mul(u128::from(storage_end - storage_start)),
        )
        .unwrap_or_else(|e| env::panic_str(&format!("Storage lock error: {}", e)));
    }
}

'''
'''--- workspaces-tests/src/bin/fungible_token_receiver.rs ---
workspaces_tests::predicate!();

use near_sdk::{
    env, json_types::U128, log, near, AccountId, NearToken, PanicOnDefault, PromiseOrValue,
};
use near_sdk_contract_tools::ft::*;

#[derive(PanicOnDefault)]
#[near(contract_state)]
pub struct Contract {}

#[near]
impl Nep141Receiver for Contract {
    fn ft_on_transfer(
        &mut self,
        sender_id: near_sdk::AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        log!("Received {} from {}", amount.0, sender_id);

        if msg == "panic" {
            env::panic_str("panic requested");
        } else if let Some(account_id) = msg.strip_prefix("transfer:") {
            let account_id: AccountId = account_id.parse().unwrap();

            log!("Transferring {} to {}", amount.0, account_id);

            return ext_nep141::ext(env::predecessor_account_id())
                .with_attached_deposit(NearToken::from_yoctonear(1u128))
                .ft_transfer(account_id, amount, None)
                .then(Contract::ext(env::current_account_id()).return_value(amount)) // ask to return the token even though we don't own it anymore
                .into();
        }

        PromiseOrValue::Value(if msg == "return" { amount } else { U128(0) })
    }
}

#[near]
impl Contract {
    #[init]
    pub fn new() -> Self {
        Self {}
    }

    #[private]
    pub fn return_value(&self, value: U128) -> U128 {
        value
    }
}

'''
'''--- workspaces-tests/src/bin/native_multisig.rs ---
workspaces_tests::predicate!();

use near_sdk::{env, near, AccountId, BorshStorageKey, PanicOnDefault, Promise};
use near_sdk_contract_tools::{
    approval::{
        native_transaction_action::{self, NativeTransactionAction},
        simple_multisig::{ApprovalState, Configuration},
        ApprovalManager,
    },
    rbac::Rbac,
    Rbac, SimpleMultisig,
};

#[derive(BorshStorageKey, Clone, Debug)]
#[near]
pub enum Role {
    Multisig,
}

#[derive(Rbac, SimpleMultisig, PanicOnDefault)]
#[simple_multisig(action = "NativeTransactionAction", role = "Role::Multisig")]
#[rbac(roles = "Role")]
#[near(contract_state)]
pub struct Contract {}

#[near]
impl Contract {
    const APPROVAL_THRESHOLD: u8 = 2;
    const VALIDITY_PERIOD: u64 = 1_000_000 * 1_000 * 60 * 60 * 24 * 7;

    #[init]
    pub fn new() -> Self {
        <Self as ApprovalManager<_, _, _>>::init(Configuration::new(
            Self::APPROVAL_THRESHOLD,
            Self::VALIDITY_PERIOD,
        ));

        Self {}
    }

    pub fn obtain_multisig_permission(&mut self) {
        self.add_role(&env::predecessor_account_id(), &Role::Multisig);
    }

    pub fn request(
        &mut self,
        receiver_id: AccountId,
        actions: Vec<native_transaction_action::PromiseAction>,
    ) -> u32 {
        let request_id = self
            .create_request(
                native_transaction_action::NativeTransactionAction {
                    receiver_id,
                    actions,
                },
                ApprovalState::new(),
            )
            .unwrap();

        near_sdk::log!(format!("Request ID: {request_id}"));

        request_id
    }

    pub fn approve(&mut self, request_id: u32) {
        self.approve_request(request_id).unwrap();
    }

    pub fn is_approved(&self, request_id: u32) -> bool {
        <Contract as ApprovalManager<_, _, _>>::is_approved_for_execution(request_id).is_ok()
    }

    pub fn execute(&mut self, request_id: u32) -> Promise {
        self.execute_request(request_id).unwrap()
    }

    #[private]
    pub fn private_add_one(&mut self, value: u32) -> u32 {
        value + 1
    }
}

'''
'''--- workspaces-tests/src/bin/non_fungible_token_full.rs ---
workspaces_tests::predicate!();

use near_sdk::{env, log, near, serde_json::json, PanicOnDefault};
use near_sdk_contract_tools::{
    hook::Hook,
    nft::{
        nep171::{CheckExternalTransfer, LoadTokenMetadata},
        *,
    },
};

#[derive(NonFungibleToken, PanicOnDefault)]
#[non_fungible_token(
    transfer_hook = "Self",
    approve_hook = "Self",
    revoke_hook = "Self",
    revoke_all_hook = "Self",
    token_data = "ExtraTokenData",
    check_external_transfer = "ExtraCheckExternalTransfer"
)]
#[near(contract_state)]
pub struct Contract {}

pub struct ExtraCheckExternalTransfer;

impl CheckExternalTransfer<Contract> for ExtraCheckExternalTransfer {
    fn check_external_transfer(
        contract: &Contract,
        transfer: &Nep171Transfer,
    ) -> Result<near_sdk::AccountId, nep171::error::Nep171TransferError> {
        TokenApprovals::check_external_transfer(contract, transfer)
    }
}

pub struct ExtraTokenData;

impl LoadTokenMetadata<Contract> for ExtraTokenData {
    fn load(
        _contract: &Contract,
        _token_id: &TokenId,
        metadata: &mut std::collections::HashMap<String, near_sdk::serde_json::Value>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        metadata.insert(
            "funky_data".to_string(),
            json!({
                "funky": "data",
            }),
        );
        Ok(())
    }
}

impl Hook<Contract, Nep178Approve<'_>> for Contract {
    fn hook<R>(
        contract: &mut Contract,
        args: &Nep178Approve<'_>,
        f: impl FnOnce(&mut Contract) -> R,
    ) -> R {
        log!("before_nft_approve({})", args.token_id);
        let r = f(contract);
        log!("after_nft_approve({})", args.token_id);
        r
    }
}

impl Hook<Contract, Nep178Revoke<'_>> for Contract {
    fn hook<R>(
        contract: &mut Contract,
        args: &Nep178Revoke<'_>,
        f: impl FnOnce(&mut Contract) -> R,
    ) -> R {
        log!("before_nft_revoke({})", args.token_id);
        let r = f(contract);
        log!("after_nft_revoke({})", args.token_id);
        r
    }
}

impl Hook<Contract, Nep178RevokeAll<'_>> for Contract {
    fn hook<R>(
        contract: &mut Contract,
        args: &Nep178RevokeAll<'_>,
        f: impl FnOnce(&mut Contract) -> R,
    ) -> R {
        log!("before_nft_revoke_all({})", args.token_id);
        let r = f(contract);
        log!("after_nft_revoke_all({})", args.token_id);
        r
    }
}

impl Hook<Contract, Nep171Transfer<'_>> for Contract {
    fn hook<R>(
        contract: &mut Contract,
        args: &Nep171Transfer<'_>,
        f: impl FnOnce(&mut Contract) -> R,
    ) -> R {
        log!("before_nft_transfer({})", args.token_id);
        let r = f(contract);
        log!("after_nft_transfer({})", args.token_id);
        r
    }
}

#[near]
impl Contract {
    #[init]
    pub fn new() -> Self {
        let mut contract = Self {};

        contract.set_contract_metadata(&ContractMetadata::new(
            "My NFT Smart Contract".to_string(),
            "MNSC".to_string(),
            None,
        ));

        contract
    }

    pub fn mint(&mut self, token_ids: Vec<TokenId>) {
        let receiver = env::predecessor_account_id();
        for token_id in token_ids {
            self.mint_with_metadata(
                &token_id,
                &receiver,
                &TokenMetadata::new()
                    .title(token_id.clone())
                    .description("description"),
            )
            .unwrap_or_else(|e| env::panic_str(&format!("Failed to mint: {:#?}", e)));
        }
    }
}

'''
'''--- workspaces-tests/src/bin/non_fungible_token_nep171.rs ---
workspaces_tests::predicate!();

use near_sdk::{env, log, near, PanicOnDefault};
use near_sdk_contract_tools::{hook::Hook, nft::Nep171Mint, standard::nep171::*, Nep171};

#[derive(Nep171, PanicOnDefault)]
#[nep171(transfer_hook = "Self")]
#[near(contract_state)]
pub struct Contract {}

impl Hook<Contract, action::Nep171Transfer<'_>> for Contract {
    fn hook<R>(
        contract: &mut Contract,
        args: &action::Nep171Transfer<'_>,
        f: impl FnOnce(&mut Contract) -> R,
    ) -> R {
        log!("before_nft_transfer({})", args.token_id);
        let r = f(contract);
        log!("after_nft_transfer({})", args.token_id);
        r
    }
}

#[near]
impl Contract {
    #[init]
    pub fn new() -> Self {
        Self {}
    }

    pub fn mint(&mut self, token_ids: Vec<TokenId>) {
        Nep171Controller::mint(
            self,
            &Nep171Mint::new(token_ids, env::predecessor_account_id()),
        )
        .unwrap_or_else(|e| env::panic_str(&format!("Failed to mint: {:#?}", e)));
    }
}

'''
'''--- workspaces-tests/src/bin/non_fungible_token_receiver.rs ---
workspaces_tests::predicate!();

use near_sdk::{env, log, near, AccountId, NearToken, PanicOnDefault, PromiseOrValue};
use near_sdk_contract_tools::standard::nep171::*;

#[derive(PanicOnDefault)]
#[near(contract_state)]
pub struct Contract {}

#[near]
impl Nep171Receiver for Contract {
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> PromiseOrValue<bool> {
        log!(
            "Received {} from {} via {}",
            token_id,
            previous_owner_id,
            sender_id,
        );

        if msg == "panic" {
            near_sdk::env::panic_str("panic requested");
        } else if let Some(account_id) = msg.strip_prefix("transfer:") {
            log!("Transferring {} to {}", token_id, account_id);
            return ext_nep171::ext(env::predecessor_account_id())
                .with_attached_deposit(NearToken::from_yoctonear(1u128))
                .nft_transfer(account_id.parse().unwrap(), token_id, None, None)
                .then(Contract::ext(env::current_account_id()).return_true()) // ask to return the token even though we don't own it anymore
                .into();
        }

        PromiseOrValue::Value(msg == "return")
    }
}

#[near]
impl Contract {
    #[init]
    pub fn new() -> Self {
        Self {}
    }

    pub fn return_true(&self) -> bool {
        log!("returning true");
        true
    }
}

'''
'''--- workspaces-tests/src/bin/rbac.rs ---
workspaces_tests::predicate!();

use std::str::FromStr;

use near_sdk_contract_tools::{rbac::Rbac, Rbac};

use near_sdk::{env, near, AccountId, BorshStorageKey, PanicOnDefault};

#[derive(BorshStorageKey)]
#[near]
pub enum Role {
    Alpha,
    Beta,
    Gamma,
    Delta,
}

impl FromStr for Role {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "a" => Ok(Self::Alpha),
            "b" => Ok(Self::Beta),
            "g" => Ok(Self::Gamma),
            "d" => Ok(Self::Delta),
            _ => Err(()),
        }
    }
}

#[derive(Rbac, PanicOnDefault)]
#[rbac(roles = "Role")]
#[near(contract_state, serializers = [borsh, json])]
pub struct Contract {
    pub alpha: u32,
    pub beta: u32,
    pub gamma: u32,
    pub delta: u32,
}

#[near]
impl Contract {
    #[init]
    pub fn new() -> Self {
        Self {
            alpha: 0,
            beta: 0,
            gamma: 0,
            delta: 0,
        }
    }

    pub fn acquire_role(&mut self, role: String) {
        let role: Role = Role::from_str(&role).expect("Invalid role identifier");
        let predecessor = env::predecessor_account_id();
        self.add_role(&predecessor, &role);
    }

    pub fn members(&self, role: String) -> Vec<AccountId> {
        let role: Role = Role::from_str(&role).expect("Invalid role identifier");
        Self::iter_members_of(&role).collect()
    }

    pub fn count_members(&self, role: String) -> u32 {
        let role: Role = Role::from_str(&role).expect("Invalid role identifier");
        Self::iter_members_of(&role).count() as u32
    }

    pub fn requires_alpha(&mut self) {
        Self::require_role(&Role::Alpha);
        self.alpha += 1;
    }

    pub fn requires_beta(&mut self) {
        Self::require_role(&Role::Beta);
        self.beta += 1;
    }

    pub fn requires_gamma(&mut self) {
        Self::require_role(&Role::Gamma);
        self.gamma += 1;
    }

    pub fn requires_delta(&mut self) {
        Self::require_role(&Role::Delta);
        self.delta += 1;
    }

    pub fn get(&self) -> near_sdk::serde_json::Value {
        near_sdk::serde_json::to_value(self).unwrap()
    }
}

'''
'''--- workspaces-tests/src/bin/simple_multisig.rs ---
workspaces_tests::predicate!();

use std::fmt::Display;

use near_sdk::{env, near, AccountId, BorshStorageKey, PanicOnDefault};
use near_sdk_contract_tools::{
    approval::{
        self,
        simple_multisig::{AccountAuthorizer, ApprovalState, Configuration},
        ApprovalManager, ApprovalManagerInternal,
    },
    rbac::Rbac,
    slot::Slot,
    Rbac,
};
use thiserror::Error;

#[derive(BorshStorageKey)]
#[near]
enum StorageKey {
    SimpleMultisig,
}

#[near]
enum MyAction {
    SayHello,
    SayGoodbye,
}

impl approval::Action<Contract> for MyAction {
    type Output = &'static str;

    fn execute(self, _contract: &mut Contract) -> Self::Output {
        match self {
            Self::SayHello => "hello",
            Self::SayGoodbye => "goodbye",
        }
    }
}

#[derive(BorshStorageKey, Debug, Clone)]
#[near]
pub enum Role {
    Multisig,
}

#[derive(Rbac, PanicOnDefault)]
#[rbac(roles = "Role")]
#[near(contract_state)]
pub struct Contract {}

// This single function implementation completely implements simple multisig on
// the contract
impl ApprovalManagerInternal<MyAction, ApprovalState, Configuration<Self>> for Contract {
    fn root() -> Slot<()> {
        Slot::new(StorageKey::SimpleMultisig)
    }
}

#[derive(Clone, Copy, Debug)]
pub enum ApproverError {
    UnauthorizedAccount,
}

impl Display for ApproverError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Unauthorized account")
    }
}

#[derive(Error, Clone, Debug)]
#[error("Missing role: {0:?}")]
pub struct MissingRole(Role);

impl AccountAuthorizer for Contract {
    type AuthorizationError = MissingRole;

    fn is_account_authorized(account_id: &AccountId) -> Result<(), Self::AuthorizationError> {
        if Contract::has_role(account_id, &Role::Multisig) {
            Ok(())
        } else {
            Err(MissingRole(Role::Multisig))
        }
    }
}

#[near]
impl Contract {
    const APPROVAL_THRESHOLD: u8 = 2;
    const VALIDITY_PERIOD: u64 = 1000000 * 1000 * 60 * 60 * 24 * 7;

    #[init]
    pub fn new() -> Self {
        <Self as ApprovalManager<_, _, _>>::init(Configuration::new(
            Self::APPROVAL_THRESHOLD,
            Self::VALIDITY_PERIOD,
        ));

        Self {}
    }

    pub fn obtain_multisig_permission(&mut self) {
        self.add_role(&env::predecessor_account_id(), &Role::Multisig);
    }

    pub fn request(&mut self, action: String) -> u32 {
        let action = match &action[..] {
            "hello" => MyAction::SayHello,
            "goodbye" => MyAction::SayGoodbye,
            _ => env::panic_str("action must be \"hello\" or \"goodbye\""),
        };

        let request_id = self.create_request(action, ApprovalState::new()).unwrap();

        near_sdk::log!(format!("Request ID: {request_id}"));

        request_id
    }

    pub fn approve(&mut self, request_id: u32) {
        self.approve_request(request_id).unwrap();
    }

    pub fn is_approved(&self, request_id: u32) -> bool {
        <Contract as ApprovalManager<_, _, _>>::is_approved_for_execution(request_id).is_ok()
    }

    pub fn execute(&mut self, request_id: u32) -> String {
        self.execute_request(request_id).unwrap().to_string()
    }
}

'''
'''--- workspaces-tests/src/bin/storage_fee.rs ---
workspaces_tests::predicate!();

use near_sdk::{env, near, store::Vector, NearToken, PanicOnDefault, Promise};
use near_sdk_contract_tools::utils::apply_storage_fee_and_refund;

#[derive(PanicOnDefault)]
#[near(contract_state)]
pub struct ContractBad {
    pub items: Vector<String>,
}

#[near]
impl ContractBad {
    #[init]
    pub fn new() -> Self {
        Self {
            items: Vector::new(b"i"),
        }
    }

    pub fn storage_byte_cost(&self) -> NearToken {
        env::storage_byte_cost()
    }

    #[payable]
    pub fn store(&mut self, item: String) -> Option<Promise> {
        let initial_storage_usage = env::storage_usage();

        self.items.push(item);

        self.items.flush(); // Force write before sending refund

        apply_storage_fee_and_refund(initial_storage_usage, 0)
    }
}

'''
'''--- workspaces-tests/src/bin/upgrade_bad.rs ---
workspaces_tests::predicate!();

use near_sdk::{near, PanicOnDefault};

#[derive(PanicOnDefault)]
#[near(contract_state)]
pub struct ContractBad {
    pub foo: u32,
}

#[near]
impl ContractBad {
    #[init]
    pub fn new() -> Self {
        Self { foo: 0 }
    }

    pub fn increment_foo(&mut self) {
        self.foo += 1;
    }

    pub fn get_foo(&self) -> u32 {
        self.foo
    }
}

'''
'''--- workspaces-tests/src/bin/upgrade_new.rs ---
workspaces_tests::predicate!();

use near_sdk::{near, PanicOnDefault};
use near_sdk_contract_tools::{migrate::*, Migrate};

#[near]
pub struct ContractOld {
    pub foo: u32,
}

#[derive(Migrate, PanicOnDefault)]
#[migrate(from = "ContractOld")]
#[near(contract_state)]
pub struct ContractNew {
    pub bar: u64,
}

impl MigrateHook for ContractNew {
    fn on_migrate(old_schema: ContractOld) -> Self {
        Self {
            bar: old_schema.foo as u64,
        }
    }
}

#[near]
impl ContractNew {
    #[init]
    pub fn new() -> Self {
        Self { bar: 0 }
    }

    pub fn get_bar(&self) -> u64 {
        self.bar
    }
}

'''
'''--- workspaces-tests/src/bin/upgrade_old_borsh.rs ---
workspaces_tests::predicate!();

use near_sdk::{env, near, PanicOnDefault};
use near_sdk_contract_tools::{owner::*, Owner, Upgrade};

#[derive(Owner, Upgrade, PanicOnDefault)]
#[upgrade(serializer = "borsh", hook = "owner")]
#[near(contract_state)]
pub struct ContractOld {
    pub foo: u32,
}

#[near]
impl ContractOld {
    #[init]
    pub fn new() -> Self {
        let mut contract = Self { foo: 0 };

        Owner::init(&mut contract, &env::predecessor_account_id());
        contract
    }

    pub fn increment_foo(&mut self) {
        self.foo += 1;
    }

    pub fn get_foo(&self) -> u32 {
        self.foo
    }
}

'''
'''--- workspaces-tests/src/bin/upgrade_old_jsonbase64.rs ---
workspaces_tests::predicate!();

use near_sdk::{env, near, PanicOnDefault};
use near_sdk_contract_tools::{owner::*, Owner, Upgrade};

#[derive(Owner, Upgrade, PanicOnDefault)]
#[upgrade(serializer = "jsonbase64", hook = "owner")]
#[near(contract_state)]
pub struct ContractOld {
    pub foo: u32,
}

#[near]
impl ContractOld {
    #[init]
    pub fn new() -> Self {
        let mut contract = Self { foo: 0 };

        Owner::init(&mut contract, &env::predecessor_account_id());
        contract
    }

    pub fn increment_foo(&mut self) {
        self.foo += 1;
    }

    pub fn get_foo(&self) -> u32 {
        self.foo
    }
}

'''
'''--- workspaces-tests/src/bin/upgrade_old_multisig.rs ---
workspaces_tests::predicate!();

use near_sdk::{env, json_types::Base64VecU8, near, BorshStorageKey, PanicOnDefault};
use near_sdk_contract_tools::{
    approval::{self, ApprovalManager},
    owner::*,
    rbac::Rbac,
    Owner, Rbac, SimpleMultisig, Upgrade,
};

#[derive(BorshStorageKey, Debug, Clone)]
#[near]
pub enum Role {
    Multisig,
}

#[derive(Debug, Clone)]
#[near(serializers = [borsh, json])]
pub enum ContractAction {
    Upgrade { code: Base64VecU8 },
}

impl approval::Action<Contract> for ContractAction {
    type Output = ();

    fn execute(self, _contract: &mut Contract) -> Self::Output {
        match self {
            ContractAction::Upgrade { code } => _contract.upgrade(code.into()),
        }
    }
}

#[derive(Owner, Debug, Clone, Rbac, Upgrade, SimpleMultisig, PanicOnDefault)]
#[rbac(roles = "Role")]
#[simple_multisig(role = "Role::Multisig", action = "ContractAction")]
#[upgrade(serializer = "borsh", hook = "owner")]
#[near(contract_state)]
pub struct Contract {
    pub foo: u32,
}

#[near]
impl Contract {
    #[init]
    pub fn new() -> Self {
        <Self as ApprovalManager<_, _, _>>::init(approval::simple_multisig::Configuration::new(
            1, 0,
        ));

        let mut contract = Self { foo: 0 };

        let predecessor = env::predecessor_account_id();

        Owner::init(&mut contract, &predecessor);

        contract.add_role(&predecessor, &Role::Multisig);

        contract
    }

    pub fn request(&mut self, request: ContractAction) -> u32 {
        self.create_request(request, Default::default()).unwrap()
    }

    pub fn approve(&mut self, request_id: u32) {
        self.approve_request(request_id).unwrap()
    }

    pub fn execute(&mut self, request_id: u32) {
        env::log_str("executing request");
        self.execute_request(request_id).unwrap()
    }
}

'''
'''--- workspaces-tests/src/bin/upgrade_old_raw.rs ---
workspaces_tests::predicate!();

use near_sdk::{env, near, PanicOnDefault};
use near_sdk_contract_tools::{owner::*, upgrade::PostUpgrade, Owner};

#[derive(Owner, PanicOnDefault)]
#[near(contract_state)]
pub struct ContractOld {
    pub foo: u32,
}

#[near]
impl ContractOld {
    #[init]
    pub fn new() -> Self {
        let mut contract = Self { foo: 0 };

        Owner::init(&mut contract, &env::predecessor_account_id());
        contract
    }

    pub fn increment_foo(&mut self) {
        self.foo += 1;
    }

    pub fn get_foo(&self) -> u32 {
        self.foo
    }
}

#[no_mangle]
pub fn upgrade() {
    near_sdk::env::setup_panic_hook();

    ContractOld::require_owner();

    unsafe {
        near_sdk_contract_tools::upgrade::raw::upgrade(PostUpgrade::default());
    }
}

'''
'''--- workspaces-tests/src/lib.rs ---
#![allow(missing_docs)]
#![cfg(not(windows))]

#[macro_export]
macro_rules! predicate {
    () => {
        pub fn main() {}
    };
}

'''
'''--- workspaces-tests/tests/counter_multisig.rs ---
use near_sdk::serde_json::json;
use near_workspaces::{Account, Contract};
use pretty_assertions::assert_eq;

const WASM: &[u8] =
    include_bytes!("../../target/wasm32-unknown-unknown/release/counter_multisig.wasm");

struct Setup {
    pub contract: Contract,
    pub accounts: Vec<Account>,
}

/// Setup for individual tests
async fn setup(num_accounts: usize) -> Setup {
    let worker = near_workspaces::sandbox().await.unwrap();

    // Initialize contract
    let contract = worker.dev_deploy(WASM).await.unwrap();
    contract.call("new").transact().await.unwrap().unwrap();

    // Initialize user accounts
    let mut accounts = vec![];
    for _ in 0..(num_accounts + 1) {
        accounts.push(worker.dev_create_account().await.unwrap());
    }

    Setup { contract, accounts }
}

async fn setup_roles(num_accounts: usize) -> Setup {
    let s = setup(num_accounts).await;

    for account in s.accounts[..s.accounts.len() - 1].iter() {
        account
            .call(s.contract.id(), "obtain_multisig_permission")
            .transact()
            .await
            .unwrap()
            .unwrap();
    }

    s
}

#[tokio::test]
async fn success() {
    let Setup { contract, accounts } = setup_roles(3).await;

    let alice = &accounts[0];
    let bob = &accounts[1];
    let charlie = &accounts[2];

    let create_request = |account: &Account, fname: &str| {
        let fname = fname.to_string();
        let account = account.clone();
        let contract_id = contract.id();
        async move {
            account
                .clone()
                .call(contract_id, &fname)
                .transact()
                .await
                .unwrap()
                .json::<u32>()
                .unwrap()
        }
    };

    // Increment
    let request_id = create_request(alice, "request_increment").await;

    let is_approved = |request_id: u32| {
        let view = contract
            .view("is_approved")
            .args_json(json!({ "request_id": request_id }));
        async move { view.await.unwrap().json::<bool>().unwrap() }
    };

    assert!(!is_approved(request_id).await);

    let approve = |account: Account, request_id: u32| {
        let contract_id = contract.id();
        async move {
            account
                .call(contract_id, "approve")
                .args_json(json!({ "request_id": request_id }))
                .transact()
                .await
                .unwrap()
        }
    };

    approve(alice.clone(), request_id).await.unwrap();

    assert!(!is_approved(request_id).await);

    approve(bob.clone(), request_id).await.unwrap();

    assert!(is_approved(request_id).await);

    approve(charlie.clone(), request_id).await.unwrap();

    assert!(is_approved(request_id).await);

    let get_counter = || async {
        contract
            .view("get_counter")
            .await
            .unwrap()
            .json::<u32>()
            .unwrap()
    };

    let counter = get_counter().await;

    assert_eq!(counter, 0);

    let execute = |account: Account, request_id: u32| {
        let contract_id = contract.id();
        async move {
            account
                .call(contract_id, "execute")
                .args_json(json!({ "request_id": request_id }))
                .transact()
                .await
                .unwrap()
                .json::<u32>()
                .unwrap()
        }
    };

    let result = execute(alice.clone(), request_id).await;

    assert_eq!(result, 1);

    let counter = get_counter().await;

    assert_eq!(counter, 1);

    let request_id = create_request(bob, "request_increment").await;
    approve(bob.clone(), request_id).await.unwrap();
    approve(alice.clone(), request_id).await.unwrap();
    let result = execute(bob.clone(), request_id).await;
    let counter = get_counter().await;
    assert_eq!(result, counter);
    assert_eq!(counter, 2);

    let request_id = create_request(charlie, "request_decrement").await;
    approve(bob.clone(), request_id).await.unwrap();
    approve(charlie.clone(), request_id).await.unwrap();
    let result = execute(alice.clone(), request_id).await;
    let counter = get_counter().await;
    assert_eq!(result, counter);
    assert_eq!(counter, 1);

    let request_id = create_request(charlie, "request_reset").await;
    approve(bob.clone(), request_id).await.unwrap();
    approve(alice.clone(), request_id).await.unwrap();
    let result = execute(alice.clone(), request_id).await;
    let counter = get_counter().await;
    assert_eq!(result, counter);
    assert_eq!(counter, 0);
}

'''
'''--- workspaces-tests/tests/escrow.rs ---
use near_sdk::{
    serde::{Deserialize, Serialize},
    serde_json::{self, json},
};
use near_workspaces::{Account, AccountId, Contract};
use pretty_assertions::assert_eq;
use tokio::join;

const WASM: &[u8] = include_bytes!("../../target/wasm32-unknown-unknown/release/escrow.wasm");

#[derive(Deserialize, Clone, Default, Debug, PartialEq, Eq)]
#[serde(crate = "near_sdk::serde")]
struct ContractSchema {}

#[derive(Serialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum PrimaryColour {
    Red,
    Yellow,
    Blue,
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(crate = "near_sdk::serde")]
pub enum SecondaryColour {
    Orange,
    Green,
    Purple,
}

struct Setup {
    pub contract: Contract,
    pub accounts: Vec<Account>,
}

/// Setup for individual tests
async fn setup(num_accounts: usize, wasm: &[u8]) -> Setup {
    let worker = near_workspaces::sandbox().await.unwrap();

    // Initialize user accounts
    let mut accounts = vec![];
    for _ in 0..(num_accounts + 1) {
        accounts.push(worker.dev_create_account().await.unwrap());
    }

    let alice = &accounts[0].clone();

    let contract = alice.deploy(wasm).await.unwrap().unwrap();
    contract.call("new").transact().await.unwrap().unwrap();

    Setup { contract, accounts }
}

#[tokio::test]
async fn happy() {
    let Setup { contract, accounts } = setup(2, WASM).await;

    let alice = &accounts[0];
    let bob = &accounts[1];

    let call = |who: Account, contract: AccountId, method: String, args: Vec<u8>| async move {
        who.call(&contract, &method)
            .args(args)
            .transact()
            .await
            .unwrap()
            .unwrap()
    };

    let assign = |who: Account, colour: PrimaryColour| {
        call(
            who,
            contract.id().clone(),
            "assign".to_string(),
            serde_json::to_vec(&json!({ "colour": colour })).unwrap(),
        )
    };
    let mix = |who: Account, contract: AccountId, colour: PrimaryColour, with: PrimaryColour| async move {
        who.call(&contract, "mix")
            .args(serde_json::to_vec(&json!({ "colour": colour, "with": with })).unwrap())
            .transact()
            .await
            .unwrap()
            .json::<(AccountId, AccountId, SecondaryColour)>()
            .unwrap()
    };
    let alice_colour = PrimaryColour::Red;
    join!(
        assign(alice.clone(), alice_colour.clone()),
        assign(bob.clone(), PrimaryColour::Blue),
    );
    let (pair_x, pair_y, mixed_colour) = mix(
        bob.clone(),
        contract.id().clone(),
        PrimaryColour::Blue,
        alice_colour.clone(),
    )
    .await;

    let locked = contract
        .view("get_locked")
        .args(serde_json::to_vec(&json!({ "colour": alice_colour })).unwrap())
        .await
        .unwrap()
        .json::<bool>()
        .unwrap();

    assert!(!locked);
    assert_eq!(pair_x, bob.clone().id().to_owned());
    assert_eq!(pair_y, alice.clone().id().to_owned());
    assert_eq!(mixed_colour, SecondaryColour::Purple);
}

#[tokio::test]
#[should_panic(expected = "Already locked")]
async fn unhappy_cant_lock() {
    let Setup { contract, accounts } = setup(1, WASM).await;

    let alice = &accounts[0];

    let call = |who: Account, contract: AccountId, method: String, args: Vec<u8>| async move {
        who.call(&contract, &method)
            .args(args)
            .transact()
            .await
            .unwrap()
            .unwrap()
    };

    let assign = |who: Account, colour: PrimaryColour| {
        call(
            who,
            contract.id().clone(),
            "assign".to_string(),
            serde_json::to_vec(&json!({ "colour": colour })).unwrap(),
        )
    };

    join!(
        assign(alice.clone(), PrimaryColour::Red),
        assign(alice.clone(), PrimaryColour::Red),
    );
}

'''
'''--- workspaces-tests/tests/fungible_token.rs ---
use near_sdk::{
    json_types::{Base64VecU8, U128},
    serde_json::json,
    NearToken,
};
use near_sdk_contract_tools::{
    nft::StorageBalance,
    standard::{
        nep141::{FtTransferData, Nep141Event},
        nep145::error::InsufficientBalanceError,
        nep297::Event,
    },
};
use near_workspaces::{network::Sandbox, operations::Function, Account, Contract, Worker};
use pretty_assertions::assert_eq;
use tokio::task::JoinSet;
use workspaces_tests_utils::{expect_execution_error, ft_balance_of, ONE_NEAR, ONE_YOCTO};

const WASM: &[u8] =
    include_bytes!("../../target/wasm32-unknown-unknown/release/fungible_token.wasm");

const RECEIVER_WASM: &[u8] =
    include_bytes!("../../target/wasm32-unknown-unknown/release/fungible_token_receiver.wasm");

struct Setup {
    pub contract: Contract,
    pub accounts: Vec<Account>,
    pub worker: Worker<Sandbox>,
}

/// Setup for individual tests
async fn setup(num_accounts: usize) -> Setup {
    let worker = near_workspaces::sandbox().await.unwrap();

    // Initialize contract
    let contract = worker.dev_deploy(WASM).await.unwrap();
    contract.call("new").transact().await.unwrap().unwrap();

    // Initialize user accounts
    let mut accounts = vec![];
    for _ in 0..num_accounts {
        accounts.push(worker.dev_create_account().await.unwrap());
    }

    Setup {
        contract,
        accounts,
        worker,
    }
}

async fn setup_balances(num_accounts: usize, amount: impl Fn(usize) -> U128) -> Setup {
    let setup = setup(num_accounts).await;

    let mut transaction_set = JoinSet::new();

    for (i, account) in setup.accounts.iter().enumerate() {
        let transaction = account
            .batch(setup.contract.id())
            .call(
                Function::new("storage_deposit")
                    .args_json(json!({}))
                    .deposit(ONE_NEAR.saturating_div(100)),
            )
            .call(Function::new("mint").args_json(json!({ "amount": amount(i) })))
            .transact();
        transaction_set.spawn(async move {
            transaction.await.unwrap().unwrap();
        });
    }

    while transaction_set.join_next().await.is_some() {}

    setup
}

#[tokio::test]
async fn start_empty() {
    let Setup {
        contract, accounts, ..
    } = setup(3).await;

    // All accounts must start with 0 balance
    for account in accounts.iter() {
        assert_eq!(ft_balance_of(&contract, account.id()).await, 0);
    }
}

#[tokio::test]
async fn mint() {
    let Setup {
        contract, accounts, ..
    } = setup_balances(3, |i| 10u128.pow(3 - i as u32).into()).await;
    let alice = &accounts[0];
    let bob = &accounts[1];
    let charlie = &accounts[2];

    // Verify issued balances
    assert_eq!(ft_balance_of(&contract, alice.id()).await, 1000);
    assert_eq!(ft_balance_of(&contract, bob.id()).await, 100);
    assert_eq!(ft_balance_of(&contract, charlie.id()).await, 10);
}

#[tokio::test]
async fn transfer_normal() {
    let Setup {
        contract, accounts, ..
    } = setup_balances(3, |i| 10u128.pow(3 - i as u32).into()).await;
    let alice = &accounts[0];
    let bob = &accounts[1];
    let charlie = &accounts[2];

    alice
        .call(contract.id(), "ft_transfer")
        .deposit(ONE_YOCTO)
        .args_json(json!({
            "receiver_id": bob.id(),
            "amount": "10",
        }))
        .transact()
        .await
        .unwrap()
        .unwrap();
    assert_eq!(ft_balance_of(&contract, alice.id()).await, 990);
    assert_eq!(ft_balance_of(&contract, bob.id()).await, 110);
    assert_eq!(ft_balance_of(&contract, charlie.id()).await, 10);
}

#[tokio::test]
async fn transfer_zero() {
    let Setup {
        contract, accounts, ..
    } = setup_balances(3, |i| 10u128.pow(3 - i as u32).into()).await;
    let alice = &accounts[0];
    let bob = &accounts[1];
    let charlie = &accounts[2];

    alice
        .call(contract.id(), "ft_transfer")
        .deposit(ONE_YOCTO)
        .args_json(json!({
            "receiver_id": bob.id(),
            "amount": "0",
        }))
        .transact()
        .await
        .unwrap()
        .unwrap();
    assert_eq!(ft_balance_of(&contract, alice.id()).await, 1000);
    assert_eq!(ft_balance_of(&contract, bob.id()).await, 100);
    assert_eq!(ft_balance_of(&contract, charlie.id()).await, 10);
}

#[tokio::test]
#[should_panic(expected = "invalid digit found in string")]
async fn transfer_negative() {
    let Setup {
        contract, accounts, ..
    } = setup_balances(3, |i| 10u128.pow(3 - i as u32).into()).await;
    let alice = &accounts[0];
    let bob = &accounts[1];

    alice
        .call(contract.id(), "ft_transfer")
        .deposit(ONE_YOCTO)
        .args_json(json!({
            "receiver_id": bob.id(),
            "amount": "-10",
        }))
        .transact()
        .await
        .unwrap()
        .unwrap();
}

#[tokio::test]
#[should_panic(expected = "Requires attached deposit of exactly 1 yoctoNEAR")]
async fn transfer_no_deposit() {
    let Setup {
        contract, accounts, ..
    } = setup_balances(3, |i| 10u128.pow(3 - i as u32).into()).await;
    let alice = &accounts[0];
    let bob = &accounts[1];

    alice
        .call(contract.id(), "ft_transfer")
        .args_json(json!({
            "receiver_id": bob.id(),
            "amount": "10",
        }))
        .transact()
        .await
        .unwrap()
        .unwrap();
}

#[tokio::test]
#[should_panic(expected = "Balance of the sender is insufficient")]
async fn transfer_more_than_balance() {
    let Setup {
        contract, accounts, ..
    } = setup_balances(3, |i| 10u128.pow(3 - i as u32).into()).await;
    let alice = &accounts[0];
    let bob = &accounts[1];

    alice
        .call(contract.id(), "ft_transfer")
        .args_json(json!({
            "receiver_id": bob.id(),
            "amount": "1000000",
        }))
        .deposit(ONE_YOCTO)
        .transact()
        .await
        .unwrap()
        .unwrap();
}

#[tokio::test]
#[should_panic(expected = "TotalSupplyOverflowError")]
async fn transfer_overflow_u128() {
    let Setup {
        contract, accounts, ..
    } = setup_balances(2, |_| (u128::MAX / 2).into()).await;
    let alice = &accounts[0];

    alice
        .call(contract.id(), "mint")
        .args_json(json!({
            "amount": "2",
        }))
        .transact()
        .await
        .unwrap()
        .unwrap();
}

#[tokio::test]
async fn transfer_fail_not_registered() {
    let Setup {
        contract,
        accounts,
        worker,
    } = setup_balances(2, |i| 10u128.pow(3 - i as u32).into()).await;
    let alice = &accounts[0];
    let charlie = worker.dev_create_account().await.unwrap();

    let result = alice
        .call(contract.id(), "ft_transfer")
        .deposit(ONE_YOCTO)
        .args_json(json!({
            "receiver_id": charlie.id(),
            "amount": "10",
        }))
        .transact()
        .await
        .unwrap();

    expect_execution_error(
        &result,
        format!(
            "Smart contract panicked: Account {} is not registered",
            charlie.id(),
        ),
    );
}

#[tokio::test]
async fn fail_run_out_of_space() {
    let Setup {
        contract, accounts, ..
    } = setup_balances(2, |i| 10u128.pow(3 - i as u32).into()).await;
    let alice = &accounts[0];

    let balance = contract
        .view("storage_balance_of")
        .args_json(json!({ "account_id": alice.id() }))
        .await
        .unwrap()
        .json::<Option<StorageBalance>>()
        .unwrap()
        .unwrap();

    let result = alice
        .call(contract.id(), "use_storage")
        .args_json(json!({
            "blob": Base64VecU8::from(vec![1u8; 10000]),
        }))
        .transact()
        .await
        .unwrap();

    expect_execution_error(
        &result,
        format!(
            "Smart contract panicked: Storage lock error: {}",
            InsufficientBalanceError {
                account_id: alice.id().clone(),
                available: balance.available,
                attempted_to_use: NearToken::from_yoctonear(100490000000000000000000),
            }
        ),
    );
}

#[tokio::test]
async fn transfer_call_normal() {
    let Setup {
        contract, accounts, ..
    } = setup_balances(3, |i| 10u128.pow(3 - i as u32).into()).await;
    let alice = &accounts[0];
    let bob = &accounts[1];
    let charlie = &accounts[2];

    bob.batch(bob.id())
        .deploy(RECEIVER_WASM)
        .call(Function::new("new").args_json(json!({})))
        .transact()
        .await
        .unwrap()
        .unwrap();

    let result = alice
        .call(contract.id(), "ft_transfer_call")
        .deposit(ONE_YOCTO)
        .max_gas()
        .args_json(json!({
            "receiver_id": bob.id(),
            "amount": "10",
            "msg": "", // keep all of the tokens
        }))
        .transact()
        .await
        .unwrap()
        .unwrap();

    assert_eq!(
        result.logs().to_vec(),
        vec![
            Nep141Event::FtTransfer(vec![FtTransferData {
                old_owner_id: alice.id().into(),
                new_owner_id: bob.id().into(),
                amount: U128(10),
                memo: None,
            }])
            .to_event_string(),
            format!("Received 10 from {}", alice.id()),
        ]
    );

    assert_eq!(ft_balance_of(&contract, alice.id()).await, 990);
    assert_eq!(ft_balance_of(&contract, bob.id()).await, 110);
    assert_eq!(ft_balance_of(&contract, charlie.id()).await, 10);
}

#[tokio::test]
async fn transfer_call_return() {
    let Setup {
        contract, accounts, ..
    } = setup_balances(3, |i| 10u128.pow(3 - i as u32).into()).await;
    let alice = &accounts[0];
    let bob = &accounts[1];
    let charlie = &accounts[2];

    bob.batch(bob.id())
        .deploy(RECEIVER_WASM)
        .call(Function::new("new").args_json(json!({})))
        .transact()
        .await
        .unwrap()
        .unwrap();

    let result = alice
        .call(contract.id(), "ft_transfer_call")
        .deposit(ONE_YOCTO)
        .max_gas()
        .args_json(json!({
            "receiver_id": bob.id(),
            "amount": "10",
            "msg": "return", // return all of the tokens
        }))
        .transact()
        .await
        .unwrap()
        .unwrap();

    assert_eq!(
        result.logs().to_vec(),
        vec![
            Nep141Event::FtTransfer(vec![FtTransferData {
                old_owner_id: alice.id().into(),
                new_owner_id: bob.id().into(),
                amount: U128(10),
                memo: None,
            }])
            .to_event_string(),
            format!("Received 10 from {}", alice.id()),
            Nep141Event::FtTransfer(vec![FtTransferData {
                old_owner_id: bob.id().into(),
                new_owner_id: alice.id().into(),
                amount: U128(10),
                memo: None,
            }])
            .to_event_string(),
        ]
    );

    assert_eq!(ft_balance_of(&contract, alice.id()).await, 1000);
    assert_eq!(ft_balance_of(&contract, bob.id()).await, 100);
    assert_eq!(ft_balance_of(&contract, charlie.id()).await, 10);
}

#[tokio::test]
async fn transfer_call_inner_transfer() {
    let Setup {
        contract, accounts, ..
    } = setup_balances(3, |i| 10u128.pow(3 - i as u32).into()).await;
    let alice = &accounts[0];
    let bob = &accounts[1];
    let charlie = &accounts[2];

    bob.batch(bob.id())
        .deploy(RECEIVER_WASM)
        .call(Function::new("new").args_json(json!({})))
        .transact()
        .await
        .unwrap()
        .unwrap();

    let result = alice
        .call(contract.id(), "ft_transfer_call")
        .deposit(ONE_YOCTO)
        .max_gas()
        .args_json(json!({
            "receiver_id": bob.id(),
            "amount": "10",
            "msg": format!("transfer:{}", charlie.id()),
        }))
        .transact()
        .await
        .unwrap()
        .unwrap();

    assert_eq!(
        result.logs().to_vec(),
        vec![
            Nep141Event::FtTransfer(vec![FtTransferData {
                old_owner_id: alice.id().into(),
                new_owner_id: bob.id().into(),
                amount: U128(10),
                memo: None,
            }])
            .to_event_string(),
            format!("Received 10 from {}", alice.id()),
            format!("Transferring 10 to {}", charlie.id()),
            Nep141Event::FtTransfer(vec![FtTransferData {
                old_owner_id: bob.id().into(),
                new_owner_id: charlie.id().into(),
                amount: U128(10),
                memo: None,
            }])
            .to_event_string(),
            Nep141Event::FtTransfer(vec![FtTransferData {
                old_owner_id: bob.id().into(),
                new_owner_id: alice.id().into(),
                amount: U128(10),
                memo: None,
            }])
            .to_event_string(),
        ]
    );

    assert_eq!(ft_balance_of(&contract, alice.id()).await, 1000);
    assert_eq!(ft_balance_of(&contract, bob.id()).await, 90);
    assert_eq!(ft_balance_of(&contract, charlie.id()).await, 20);
}

#[tokio::test]
async fn transfer_call_inner_panic() {
    let Setup {
        contract, accounts, ..
    } = setup_balances(3, |i| 10u128.pow(3 - i as u32).into()).await;
    let alice = &accounts[0];
    let bob = &accounts[1];
    let charlie = &accounts[2];

    bob.batch(bob.id())
        .deploy(RECEIVER_WASM)
        .call(Function::new("new").args_json(json!({})))
        .transact()
        .await
        .unwrap()
        .unwrap();

    let result = alice
        .call(contract.id(), "ft_transfer_call")
        .deposit(ONE_YOCTO)
        .max_gas()
        .args_json(json!({
            "receiver_id": bob.id(),
            "amount": "10",
            "msg": "panic",
        }))
        .transact()
        .await
        .unwrap()
        .unwrap();

    let inner_outcome = result.outcomes().to_vec()[2];

    assert!(inner_outcome.is_failure());

    assert_eq!(
        result.logs().to_vec(),
        vec![
            Nep141Event::FtTransfer(vec![FtTransferData {
                old_owner_id: alice.id().into(),
                new_owner_id: bob.id().into(),
                amount: U128(10),
                memo: None,
            }])
            .to_event_string(),
            format!("Received 10 from {}", alice.id()),
            Nep141Event::FtTransfer(vec![FtTransferData {
                old_owner_id: bob.id().into(),
                new_owner_id: alice.id().into(),
                amount: U128(10),
                memo: None,
            }])
            .to_event_string(),
        ]
    );

    assert_eq!(ft_balance_of(&contract, alice.id()).await, 1000);
    assert_eq!(ft_balance_of(&contract, bob.id()).await, 100);
    assert_eq!(ft_balance_of(&contract, charlie.id()).await, 10);
}

'''
'''--- workspaces-tests/tests/native_multisig.rs ---
use std::{future::IntoFuture, time::Duration};

use near_crypto::{KeyType, SecretKey};
use near_sdk::{serde_json::json, Gas};
use near_sdk_contract_tools::approval::native_transaction_action::PromiseAction;
use near_workspaces::{
    result::{ExecutionResult, Value},
    sandbox,
    types::{AccessKeyPermission, Finality, NearToken},
    Account, AccountDetailsPatch, Contract, DevNetwork, Worker,
};
use pretty_assertions::assert_eq;
use tokio::{join, time::sleep};
use workspaces_tests_utils::ONE_NEAR;

const WASM: &[u8] =
    include_bytes!("../../target/wasm32-unknown-unknown/release/native_multisig.wasm");

const SECOND_WASM: &[u8] =
    include_bytes!("../../target/wasm32-unknown-unknown/release/cross_target.wasm");

const BASIC_ADDER_WASM: &[u8] =
    include_bytes!("../../target/wasm32-unknown-unknown/release/basic_adder.wasm");

struct Setup<T: DevNetwork> {
    pub worker: Worker<T>,
    pub contract: Contract,
    pub accounts: Vec<Account>,
}

async fn setup<T: DevNetwork>(worker: Worker<T>, num_accounts: usize) -> Setup<T> {
    // Initialize contract
    let contract = worker.dev_deploy(WASM).await.unwrap();
    contract.call("new").transact().await.unwrap().unwrap();

    // Initialize user accounts
    let mut accounts = vec![];
    for _ in 0..(num_accounts + 1) {
        accounts.push(worker.dev_create_account().await.unwrap());
    }

    Setup {
        worker,
        contract,
        accounts,
    }
}

async fn setup_roles<T: DevNetwork>(worker: Worker<T>, num_accounts: usize) -> Setup<T> {
    let s = setup(worker, num_accounts).await;

    for account in s.accounts[..s.accounts.len() - 1].iter() {
        account
            .call(s.contract.id(), "obtain_multisig_permission")
            .transact()
            .await
            .unwrap()
            .unwrap();
    }

    s
}

async fn double_approve_and_execute(
    contract: &Contract,
    signer_1: &Account,
    signer_2: &Account,
    executor: &Account,
    request_id: u32,
) -> ExecutionResult<Value> {
    signer_1
        .call(contract.id(), "approve")
        .args_json(json!({ "request_id": request_id }))
        .max_gas()
        .transact()
        .await
        .unwrap()
        .unwrap();

    signer_2
        .call(contract.id(), "approve")
        .args_json(json!({ "request_id": request_id }))
        .max_gas()
        .transact()
        .await
        .unwrap()
        .unwrap();

    executor
        .call(contract.id(), "execute")
        .args_json(json!({ "request_id": request_id }))
        .max_gas()
        .transact()
        .await
        .unwrap()
        .unwrap()
}

#[tokio::test]
async fn stake() {
    let Setup {
        contract,
        accounts,
        worker,
    } = setup_roles(sandbox().await.unwrap(), 2).await;

    const MINIMUM_STAKE: NearToken = NearToken::from_yoctonear(800_000_000_000_000_000_000_000_000);

    worker
        .patch(contract.id())
        .account(AccountDetailsPatch::default().balance(MINIMUM_STAKE.saturating_mul(4)))
        .transact()
        .await
        .unwrap();

    let alice = &accounts[0];
    let bob = &accounts[1];

    let secret_key = SecretKey::from_random(KeyType::ED25519);
    let public_key = secret_key.public_key();

    let contract_before = contract.view_account().await.unwrap();
    assert_eq!(
        contract_before.locked.as_yoctonear(),
        0,
        "Account should start with no staked tokens"
    );

    let amount = MINIMUM_STAKE.saturating_mul(2);

    let request_id = alice
        .call(contract.id(), "request")
        .args_json(json!({
            "receiver_id": contract.id(),
            "actions": [
                PromiseAction::Stake {
                    amount,
                    public_key: public_key.to_string(),
                },
            ],
        }))
        .max_gas()
        .transact()
        .await
        .unwrap()
        .json::<u32>()
        .unwrap();

    double_approve_and_execute(&contract, alice, bob, alice, request_id).await;

    let contract_after = contract.view_account().await.unwrap();

    assert_eq!(
        contract_after.locked, amount,
        "Locked amount should be equal to the amount staked"
    );
}

#[tokio::test]
async fn delete_account() {
    let Setup {
        contract,
        accounts,
        worker,
    } = setup_roles(sandbox().await.unwrap(), 2).await;

    let alice = &accounts[0];
    let bob = &accounts[1];

    let (alice_before, contract_before) = join!(
        alice.view_account().into_future(),
        contract.view_account().into_future(),
    );

    let alice_balance_before = alice_before.unwrap().balance;
    let contract_balance_before = contract_before.unwrap().balance;

    let request_id = alice
        .call(contract.id(), "request")
        .args_json(json!({
            "receiver_id": contract.id(),
            "actions": [
                PromiseAction::DeleteAccount {
                    beneficiary_id: alice.id().clone(),
                },
            ],
        }))
        .max_gas()
        .transact()
        .await
        .unwrap()
        .json::<u32>()
        .unwrap();

    double_approve_and_execute(&contract, alice, bob, alice, request_id).await;

    let (contract_view, alice_view, gas_price) = join!(
        contract.view_account().into_future(),
        alice.view_account().into_future(),
        worker.gas_price().into_future(),
    );

    contract_view.expect_err("Contract account should be deleted");

    let alice_balance_after = alice_view.unwrap().balance;
    let gas_price = gas_price.unwrap();
    const MAX_GAS: u128 = 300_000_000_000_000;

    assert!(
        alice_balance_after.as_yoctonear().abs_diff(
            alice_balance_before
                .saturating_add(contract_balance_before)
                .as_yoctonear()
        ) <= gas_price.saturating_mul(MAX_GAS).as_yoctonear(),
        "All contract account funds (sans gas) transfer to the beneficiary account",
    );
}

#[tokio::test]
async fn create_account_transfer_deploy_contract_function_call() {
    let Setup {
        contract,
        accounts,
        worker,
    } = setup_roles(sandbox().await.unwrap(), 2).await;

    let alice = &accounts[0];
    let bob = &accounts[1];

    let new_account_id_str = format!("new.{}", contract.id());
    let new_account_id: near_workspaces::AccountId = new_account_id_str.parse().unwrap();

    // Account does not exist yet
    assert!(worker.view_account(&new_account_id).await.is_err());

    let request_id = alice
        .call(contract.id(), "request")
        .args_json(json!({
            "receiver_id": new_account_id_str.clone(),
            "actions": [
                PromiseAction::CreateAccount,
                PromiseAction::Transfer { amount: NearToken::from_near(30) },
                PromiseAction::DeployContract { code: BASIC_ADDER_WASM.to_vec().into() },
                PromiseAction::FunctionCall {
                    function_name: "new".into(),
                    arguments: vec![].into(),
                    amount: NearToken::from_yoctonear(0),
                    gas: Gas::from_tgas(1),
                }
            ],
        }))
        .max_gas()
        .transact()
        .await
        .unwrap()
        .json::<u32>()
        .unwrap();

    double_approve_and_execute(&contract, alice, bob, alice, request_id).await;

    let state = worker.view_account(&new_account_id).await.unwrap();
    assert!(state.balance >= ONE_NEAR.saturating_mul(30));

    let result = worker
        .view(&new_account_id, "add_five")
        .args_json(json!({ "value": 5 }))
        .await
        .unwrap()
        .json::<u32>()
        .unwrap();

    assert_eq!(
        result, 10,
        "Contract is deployed to child account and is working"
    );
}

#[tokio::test]
async fn add_both_access_key_kinds_and_delete() {
    let Setup {
        contract, accounts, ..
    } = setup_roles(sandbox().await.unwrap(), 2).await;

    let alice = &accounts[0];
    let bob = &accounts[1];

    // Add a new access key to the contract account
    let execute_actions = |actions: Vec<PromiseAction>| {
        let contract = &contract;

        async move {
            let request_id = alice
                .call(contract.id(), "request")
                .args_json(json!({
                    "receiver_id": contract.id(),
                    "actions": actions,
                }))
                .transact()
                .await
                .unwrap()
                .json::<u32>()
                .unwrap();

            double_approve_and_execute(contract, alice, bob, alice, request_id).await;

            // Finality is apparently insufficient here, as I was still getting some
            // errors on both Testnet and Sandbox if I didn't add the delay.
            sleep(Duration::from_secs(1)).await;
        }
    };

    // Add full-access key
    let full_access_key = {
        let secret_key = SecretKey::from_random(KeyType::ED25519);
        let new_public_key = secret_key.public_key();
        let new_public_key_string = new_public_key.to_string();

        let keys_before = contract
            .view_access_keys()
            .finality(Finality::Final)
            .await
            .unwrap();

        // workspaces::types::PublicKey wrapper type's contents are package-private
        // and there is no Display/.to_string() implementation.
        let new_key_json_string = near_sdk::serde_json::to_string(&new_public_key_string).unwrap();

        assert!(
            !keys_before
                .iter()
                .any(|a| near_sdk::serde_json::to_string(&a.public_key).unwrap()
                    == new_key_json_string),
            "New key does not exist in access keys before being added"
        );

        execute_actions(vec![PromiseAction::AddFullAccessKey {
            public_key: new_public_key_string.clone(),
            nonce: None,
        }])
        .await;

        let keys_after = contract
            .view_access_keys()
            .finality(Finality::Final)
            .await
            .unwrap();

        assert_eq!(
            keys_before.len() + 1,
            keys_after.len(),
            "There should be exactly one additional access key"
        );

        let key = keys_after
            .iter()
            .find(|a| {
                near_sdk::serde_json::to_string(&a.public_key).unwrap() == new_key_json_string
            })
            .unwrap();

        match &key.access_key.permission {
            AccessKeyPermission::FullAccess => {}
            _ => panic!("Expected full access key"),
        }

        new_public_key_string
    };

    // Add function-call access key
    let function_call_key = {
        let secret_key = SecretKey::from_random(KeyType::ED25519);
        let new_public_key = secret_key.public_key();
        let new_public_key_string = new_public_key.to_string();

        let keys_before = contract
            .view_access_keys()
            .finality(Finality::Final)
            .await
            .unwrap();

        // workspaces::types::PublicKey wrapper type's contents are package-private
        // and there is no Display/.to_string() implementation.
        let new_key_json_string = near_sdk::serde_json::to_string(&new_public_key_string).unwrap();

        assert!(
            !keys_before
                .iter()
                .any(|a| near_sdk::serde_json::to_string(&a.public_key).unwrap()
                    == new_key_json_string),
            "New key does not exist in access keys before being added",
        );

        execute_actions(vec![PromiseAction::AddAccessKey {
            public_key: new_public_key_string.clone(),
            allowance: NearToken::from_yoctonear(1234567890),
            receiver_id: alice.id().clone(),
            function_names: vec!["one".into(), "two".into(), "three".into()],
            nonce: None,
        }])
        .await;

        let keys_after = contract
            .view_access_keys()
            .finality(Finality::Final)
            .await
            .unwrap();

        assert_eq!(
            keys_before.len() + 1,
            keys_after.len(),
            "There should be exactly one additional access key"
        );

        let key = keys_after
            .iter()
            .find(|a| {
                near_sdk::serde_json::to_string(&a.public_key).unwrap() == new_key_json_string
            })
            .unwrap();

        let perm = match &key.access_key.permission {
            AccessKeyPermission::FunctionCall(fc) => fc,
            _ => panic!("Expected function call permission"),
        };

        assert_eq!(perm.allowance, Some(NearToken::from_yoctonear(1234567890)));
        assert_eq!(perm.method_names, &["one", "two", "three"]);
        assert_eq!(perm.receiver_id, alice.id().to_string());

        new_public_key_string
    };

    // Delete the access keys
    {
        let keys_before = contract
            .view_access_keys()
            .finality(Finality::Final)
            .await
            .unwrap();

        execute_actions(vec![
            PromiseAction::DeleteKey {
                public_key: full_access_key.clone(),
            },
            PromiseAction::DeleteKey {
                public_key: function_call_key.clone(),
            },
        ])
        .await;

        let keys_after = contract
            .view_access_keys()
            .finality(Finality::Final)
            .await
            .unwrap();

        assert_eq!(
            keys_before.len() - 2,
            keys_after.len(),
            "There should be exactly two fewer access keys"
        );

        let full_json = near_sdk::serde_json::to_string(&full_access_key).unwrap();
        let func_json = near_sdk::serde_json::to_string(&function_call_key).unwrap();

        assert!(!keys_after.iter().any(|a| {
            let k = near_sdk::serde_json::to_string(&a.public_key).unwrap();
            k == full_json || k == func_json
        }));
    }
}

#[tokio::test]
async fn transfer() {
    let Setup {
        contract, accounts, ..
    } = setup_roles(sandbox().await.unwrap(), 3).await;

    let alice = &accounts[0];
    let bob = &accounts[1];
    let charlie = &accounts[2];

    // Send 10 NEAR to charlie
    let request_id = alice
        .call(contract.id(), "request")
        .args_json(json!({
            "receiver_id": charlie.id(),
            "actions": [
                PromiseAction::Transfer {
                    amount: NearToken::from_near(10),
                },
            ],
        }))
        .transact()
        .await
        .unwrap()
        .json::<u32>()
        .unwrap();

    let is_approved = || async {
        contract
            .view("is_approved")
            .args_json(json!({ "request_id": request_id }))
            .await
            .unwrap()
            .json::<bool>()
            .unwrap()
    };

    assert!(!is_approved().await);

    alice
        .call(contract.id(), "approve")
        .args_json(json!({ "request_id": request_id }))
        .transact()
        .await
        .unwrap()
        .unwrap();

    assert!(!is_approved().await);

    bob.call(contract.id(), "approve")
        .args_json(json!({ "request_id": request_id }))
        .transact()
        .await
        .unwrap()
        .unwrap();

    assert!(is_approved().await);

    charlie
        .call(contract.id(), "approve")
        .args_json(json!({ "request_id": request_id }))
        .transact()
        .await
        .unwrap()
        .unwrap();

    assert!(is_approved().await);

    let balance_before = charlie.view_account().await.unwrap().balance;

    alice
        .call(contract.id(), "execute")
        .args_json(json!({ "request_id": request_id }))
        .transact()
        .await
        .unwrap()
        .unwrap();

    let balance_after = charlie.view_account().await.unwrap().balance;

    // charlie's balance should have increased by exactly 10 NEAR
    assert_eq!(
        balance_after.saturating_sub(balance_before),
        NearToken::from_near(10),
    );
}

#[tokio::test]
async fn reflexive_xcc() {
    let Setup {
        contract, accounts, ..
    } = setup_roles(sandbox().await.unwrap(), 3).await;

    let alice = &accounts[0];
    let bob = &accounts[1];
    let charlie = &accounts[2];

    let actions = vec![PromiseAction::FunctionCall {
        function_name: "private_add_one".into(),
        arguments: json!({ "value": 25 })
            .to_string()
            .as_bytes()
            .to_vec()
            .into(),
        amount: NearToken::from_yoctonear(0),
        gas: Gas::from_tgas(50),
    }];

    let request_id = alice
        .call(contract.id(), "request")
        .args_json(json!({
            "receiver_id": contract.id(),
            "actions": actions,
        }))
        .transact()
        .await
        .unwrap()
        .json::<u32>()
        .unwrap();

    alice
        .call(contract.id(), "approve")
        .args_json(json!({ "request_id": request_id }))
        .transact()
        .await
        .unwrap()
        .unwrap();

    bob.call(contract.id(), "approve")
        .args_json(json!({ "request_id": request_id }))
        .transact()
        .await
        .unwrap()
        .unwrap();

    let result = charlie
        .call(contract.id(), "execute")
        .max_gas()
        .args_json(json!({ "request_id": request_id }))
        .transact()
        .await
        .unwrap()
        .json::<u32>()
        .unwrap();

    assert_eq!(result, 26);
}

#[tokio::test]
async fn external_xcc() {
    let Setup {
        worker,
        contract,
        accounts,
    } = setup_roles(sandbox().await.unwrap(), 3).await;

    let alice = &accounts[0];
    let bob = &accounts[1];
    let charlie = &accounts[2];

    let second_contract = worker.dev_deploy(SECOND_WASM).await.unwrap();
    second_contract
        .call("new")
        .args_json(json!({ "owner_id": contract.id() }))
        .transact()
        .await
        .unwrap()
        .unwrap();

    let actions = vec![PromiseAction::FunctionCall {
        function_name: "set_value".into(),
        arguments: json!({ "value": "Hello, world!" })
            .to_string()
            .as_bytes()
            .to_vec()
            .into(),
        amount: NearToken::from_yoctonear(0),
        gas: Gas::from_tgas(50),
    }];

    let request_id = alice
        .call(contract.id(), "request")
        .args_json(json!({
            "receiver_id": second_contract.id(),
            "actions": actions,
        }))
        .transact()
        .await
        .unwrap()
        .json::<u32>()
        .unwrap();

    alice
        .call(contract.id(), "approve")
        .args_json(json!({ "request_id": request_id }))
        .transact()
        .await
        .unwrap()
        .unwrap();

    bob.call(contract.id(), "approve")
        .args_json(json!({ "request_id": request_id }))
        .transact()
        .await
        .unwrap()
        .unwrap();

    let value_before = second_contract
        .view("get_value")
        .await
        .unwrap()
        .json::<String>()
        .unwrap();

    assert_eq!(value_before, "");

    let calls_before = second_contract
        .view("get_calls")
        .await
        .unwrap()
        .json::<u32>()
        .unwrap();

    assert_eq!(calls_before, 0);

    charlie
        .call(contract.id(), "execute")
        .max_gas()
        .args_json(json!({ "request_id": request_id }))
        .transact()
        .await
        .unwrap()
        .unwrap();

    let value_after = second_contract
        .view("get_value")
        .await
        .unwrap()
        .json::<String>()
        .unwrap();

    assert_eq!(value_after, "Hello, world!");

    let calls_after = second_contract
        .view("get_calls")
        .await
        .unwrap()
        .json::<u32>()
        .unwrap();

    assert_eq!(calls_after, 1);
}

'''
'''--- workspaces-tests/tests/non_fungible_token.rs ---
use std::collections::HashMap;

use near_sdk::{json_types::U128, serde_json::json};
use near_sdk_contract_tools::standard::{
    nep171::{
        self,
        event::{Nep171Event, NftTransferLog},
        Token,
    },
    nep177::{self, TokenMetadata},
    nep178::error::{
        AccountAlreadyApprovedError, Nep178ApproveError, TooManyApprovalsError, UnauthorizedError,
    },
    nep297::Event,
};
use near_workspaces::{operations::Function, types::Gas};
use pretty_assertions::assert_eq;
use tokio::task::JoinSet;
use workspaces_tests_utils::{
    expect_execution_error, nft_token, setup, Setup, ONE_NEAR, ONE_YOCTO,
};

const WASM_171_ONLY: &[u8] =
    include_bytes!("../../target/wasm32-unknown-unknown/release/non_fungible_token_nep171.wasm");

const WASM_FULL: &[u8] =
    include_bytes!("../../target/wasm32-unknown-unknown/release/non_fungible_token_full.wasm");

const RECEIVER_WASM: &[u8] =
    include_bytes!("../../target/wasm32-unknown-unknown/release/non_fungible_token_receiver.wasm");

const THIRTY_TERAGAS: Gas = Gas::from_gas(30_000_000_000_000);

fn token_meta(id: impl Into<String>) -> near_sdk::serde_json::Value {
    near_sdk::serde_json::to_value(TokenMetadata::new().title(id).description("description"))
        .unwrap()
}

async fn setup_balances(
    wasm: &[u8],
    num_accounts: usize,
    token_ids: impl Fn(usize) -> Vec<String>,
    storage_deposit: bool,
) -> Setup {
    let s = setup(wasm, num_accounts).await;

    for (i, account) in s.accounts.iter().enumerate() {
        let batch = if storage_deposit {
            account.batch(s.contract.id()).call(
                Function::new("storage_deposit")
                    .args_json(json!({}))
                    .deposit(ONE_NEAR.saturating_div(100)),
            )
        } else {
            account.batch(s.contract.id())
        };

        batch
            .call(Function::new("mint").args_json(json!({ "token_ids": token_ids(i) })))
            .transact()
            .await
            .unwrap()
            .unwrap();
    }

    s
}

#[tokio::test]
async fn create_and_mint() {
    let Setup { contract, accounts } =
        setup_balances(WASM_171_ONLY, 3, |i| vec![format!("token_{i}")], false).await;
    let alice = &accounts[0];
    let bob = &accounts[1];
    let charlie = &accounts[2];

    let (token_0, token_1, token_2, token_3) = tokio::join!(
        nft_token(&contract, "token_0"),
        nft_token(&contract, "token_1"),
        nft_token(&contract, "token_2"),
        nft_token(&contract, "token_3"),
    );

    // Verify minted tokens
    assert_eq!(
        token_0,
        Some(Token {
            token_id: "token_0".to_string(),
            owner_id: alice.id().clone(),
            extensions_metadata: Default::default(),
        }),
    );
    assert_eq!(
        token_1,
        Some(Token {
            token_id: "token_1".to_string(),
            owner_id: bob.id().clone(),
            extensions_metadata: Default::default(),
        }),
    );
    assert_eq!(
        token_2,
        Some(Token {
            token_id: "token_2".to_string(),
            owner_id: charlie.id().clone(),
            extensions_metadata: Default::default(),
        }),
    );
    assert_eq!(token_3, None::<Token>);
}

#[tokio::test]
async fn create_and_mint_with_metadata_and_enumeration() {
    let Setup { contract, accounts } =
        setup_balances(WASM_FULL, 3, |i| vec![format!("token_{i}")], true).await;
    let alice = &accounts[0];
    let bob = &accounts[1];
    let charlie = &accounts[2];

    let metadata = contract
        .view("nft_metadata")
        .await
        .unwrap()
        .json::<Option<nep177::ContractMetadata>>()
        .unwrap()
        .unwrap();

    assert_eq!(
        metadata,
        nep177::ContractMetadata {
            spec: nep177::ContractMetadata::SPEC.to_string(),
            name: "My NFT Smart Contract".to_string(),
            symbol: "MNSC".to_string(),
            icon: None,
            base_uri: None,
            reference: None,
            reference_hash: None,
        },
    );

    let (token_0, token_1, token_2, token_3) = tokio::join!(
        nft_token(&contract, "token_0"),
        nft_token(&contract, "token_1"),
        nft_token(&contract, "token_2"),
        nft_token(&contract, "token_3"),
    );

    // Verify minted tokens
    assert_eq!(
        token_0,
        Some(Token {
            token_id: "token_0".to_string(),
            owner_id: alice.id().clone(),
            extensions_metadata: [
                ("metadata".to_string(), token_meta("token_0")),
                ("approved_account_ids".to_string(), json!({})),
                ("funky_data".to_string(), json!({"funky": "data"})),
            ]
            .into(),
        }),
    );
    assert_eq!(
        token_1,
        Some(Token {
            token_id: "token_1".to_string(),
            owner_id: bob.id().clone(),
            extensions_metadata: [
                ("metadata".to_string(), token_meta("token_1")),
                ("approved_account_ids".to_string(), json!({})),
                ("funky_data".to_string(), json!({"funky": "data"})),
            ]
            .into(),
        }),
    );
    assert_eq!(
        token_2,
        Some(Token {
            token_id: "token_2".to_string(),
            owner_id: charlie.id().clone(),
            extensions_metadata: [
                ("metadata".to_string(), token_meta("token_2")),
                ("approved_account_ids".to_string(), json!({})),
                ("funky_data".to_string(), json!({"funky": "data"})),
            ]
            .into(),
        }),
    );
    assert_eq!(token_3, None::<Token>);

    // indeterminate order, so hashmap for equality instead of vec
    let (
        all_tokens_enumeration,
        all_tokens_enumeration_limit,
        alice_supply,
        alice_tokens_all,
        alice_tokens_offset,
        nonexistent_account_tokens,
    ) = tokio::join!(
        async {
            contract
                .view("nft_tokens")
                .args_json(json!({}))
                .await
                .unwrap()
                .json::<Vec<Token>>()
                .unwrap()
                .into_iter()
                .map(|token| (token.token_id.clone(), token))
                .collect::<HashMap<_, _>>()
        },
        async {
            contract
                .view("nft_tokens")
                .args_json(json!({ "from_index": "0", "limit": 100 }))
                .await
                .unwrap()
                .json::<Vec<Token>>()
                .unwrap()
                .into_iter()
                .map(|token| (token.token_id.clone(), token))
                .collect::<HashMap<_, _>>()
        },
        async {
            contract
                .view("nft_supply_for_owner")
                .args_json(json!({ "account_id": alice.id() }))
                .await
                .unwrap()
                .json::<U128>()
                .unwrap()
        },
        async {
            contract
                .view("nft_tokens_for_owner")
                .args_json(json!({ "account_id": alice.id(), "limit": 100 }))
                .await
                .unwrap()
                .json::<Vec<Token>>()
                .unwrap()
        },
        async {
            contract
                .view("nft_tokens_for_owner")
                .args_json(json!({ "account_id": alice.id(), "from_index": "1" }))
                .await
                .unwrap()
                .json::<Vec<Token>>()
                .unwrap()
        },
        async {
            contract
                .view("nft_tokens_for_owner")
                .args_json(json!({ "account_id": "0000000000000000000000000000000000000000000000000000000000000000", "from_index": "1" }))
                .await
                .unwrap()
                .json::<Vec<Token>>()
                .unwrap()
        },
    );

    assert_eq!(
        all_tokens_enumeration,
        [
            token_0.clone().unwrap(),
            token_1.clone().unwrap(),
            token_2.clone().unwrap(),
        ]
        .into_iter()
        .map(|token| (token.token_id.clone(), token))
        .collect::<HashMap<_, _>>(),
    );

    assert_eq!(
        all_tokens_enumeration, all_tokens_enumeration_limit,
        "only 3 tokens in circulation, so limit:100 should be the same as unlimited"
    );

    assert_eq!(
        alice_supply.0, 1,
        "alice has one token, so alice's supply (balance) should be 1"
    );

    assert_eq!(
        alice_tokens_all,
        vec![token_0.clone().unwrap()],
        "alice has one token, so it should be returned in the list of all of alice's tokens"
    );

    assert_eq!(
        alice_tokens_offset,
        vec![],
        "alice only has one token so an offset:1 should return empty"
    );

    assert_eq!(
        nonexistent_account_tokens,
        vec![],
        "nonexistent account should return empty",
    );
}

#[tokio::test]
async fn transfer_success() {
    let Setup { contract, accounts } =
        setup_balances(WASM_171_ONLY, 3, |i| vec![format!("token_{i}")], false).await;
    let alice = &accounts[0];
    let bob = &accounts[1];
    let charlie = &accounts[2];

    let result = alice
        .call(contract.id(), "nft_transfer")
        .args_json(json!({
            "token_id": "token_0",
            "receiver_id": bob.id(),
        }))
        .deposit(ONE_YOCTO)
        .transact()
        .await
        .unwrap()
        .unwrap();

    assert_eq!(
        result.logs(),
        vec![
            "before_nft_transfer(token_0)".to_string(),
            Nep171Event::NftTransfer(vec![NftTransferLog {
                old_owner_id: alice.id().into(),
                new_owner_id: bob.id().into(),
                authorized_id: None,
                memo: None,
                token_ids: vec!["token_0".into()],
            }])
            .to_event_string(),
            "after_nft_transfer(token_0)".to_string(),
        ],
    );

    let (token_0, token_1, token_2) = tokio::join!(
        nft_token(&contract, "token_0"),
        nft_token(&contract, "token_1"),
        nft_token(&contract, "token_2"),
    );

    assert_eq!(
        token_0,
        Some(Token {
            token_id: "token_0".to_string(),
            owner_id: bob.id().clone(),
            extensions_metadata: Default::default(),
        }),
    );
    assert_eq!(
        token_1,
        Some(Token {
            token_id: "token_1".to_string(),
            owner_id: bob.id().clone(),
            extensions_metadata: Default::default(),
        }),
    );
    assert_eq!(
        token_2,
        Some(Token {
            token_id: "token_2".to_string(),
            owner_id: charlie.id().clone(),
            extensions_metadata: Default::default(),
        }),
    );
}

#[tokio::test]
#[should_panic = "Smart contract panicked: Requires attached deposit of exactly 1 yoctoNEAR"]
async fn transfer_fail_no_deposit_full() {
    transfer_fail_no_deposit(WASM_FULL, true).await;
}

#[tokio::test]
#[should_panic = "Smart contract panicked: Requires attached deposit of exactly 1 yoctoNEAR"]
async fn transfer_fail_no_deposit_171() {
    transfer_fail_no_deposit(WASM_171_ONLY, false).await;
}

async fn transfer_fail_no_deposit(wasm: &[u8], storage_deposit: bool) {
    let Setup { contract, accounts } =
        setup_balances(wasm, 2, |i| vec![format!("token_{i}")], storage_deposit).await;
    let alice = &accounts[0];
    let bob = &accounts[1];

    alice
        .call(contract.id(), "nft_transfer")
        .args_json(json!({
            "token_id": "token_0",
            "receiver_id": bob.id(),
        }))
        .transact()
        .await
        .unwrap()
        .unwrap();
}

#[tokio::test]
#[should_panic = "Smart contract panicked: Token `token_5` does not exist"]
async fn transfer_fail_token_dne_full() {
    transfer_fail_token_dne(WASM_FULL, true).await;
}

#[tokio::test]
#[should_panic = "Smart contract panicked: Token `token_5` does not exist"]
async fn transfer_fail_token_dne_171() {
    transfer_fail_token_dne(WASM_171_ONLY, false).await;
}

async fn transfer_fail_token_dne(wasm: &[u8], storage_deposit: bool) {
    let Setup { contract, accounts } =
        setup_balances(wasm, 2, |i| vec![format!("token_{i}")], storage_deposit).await;
    let alice = &accounts[0];
    let bob = &accounts[1];

    alice
        .call(contract.id(), "nft_transfer")
        .args_json(json!({
            "token_id": "token_5",
            "receiver_id": bob.id(),
        }))
        .deposit(ONE_YOCTO)
        .transact()
        .await
        .unwrap()
        .unwrap();
}

#[tokio::test]
async fn transfer_fail_not_owner_full() {
    transfer_fail_not_owner(WASM_FULL, true).await;
}

#[tokio::test]
async fn transfer_fail_not_owner_171() {
    transfer_fail_not_owner(WASM_171_ONLY, false).await;
}

async fn transfer_fail_not_owner(wasm: &[u8], storage_deposit: bool) {
    let Setup { contract, accounts } =
        setup_balances(wasm, 3, |i| vec![format!("token_{i}")], storage_deposit).await;
    let alice = &accounts[0];
    let bob = &accounts[1];
    let charlie = &accounts[2];

    let result = alice
        .call(contract.id(), "nft_transfer")
        .args_json(json!({
            "token_id": "token_2", // charlie's token
            "receiver_id": bob.id(),
        }))
        .deposit(ONE_YOCTO)
        .transact()
        .await
        .unwrap();

    expect_execution_error(
        &result,
        format!(
            "Smart contract panicked: Token `token_2` is owned by `{}` instead of expected `{}`",
            charlie.id(),
            alice.id(),
        ),
    );
}

#[tokio::test]
async fn transfer_fail_reflexive_transfer_full() {
    transfer_fail_reflexive_transfer(WASM_FULL, true).await;
}

#[tokio::test]
async fn transfer_fail_reflexive_transfer_171() {
    transfer_fail_reflexive_transfer(WASM_171_ONLY, false).await;
}

async fn transfer_fail_reflexive_transfer(wasm: &[u8], storage_deposit: bool) {
    let Setup { contract, accounts } =
        setup_balances(wasm, 2, |i| vec![format!("token_{i}")], storage_deposit).await;
    let alice = &accounts[0];

    let result = alice
        .call(contract.id(), "nft_transfer")
        .args_json(json!({
            "token_id": "token_0",
            "receiver_id": alice.id(),
        }))
        .deposit(ONE_YOCTO)
        .transact()
        .await
        .unwrap();

    expect_execution_error(&result, format!("Smart contract panicked: Receiver must be different from current owner `{}` to transfer token `token_0`", alice.id()));
}

#[tokio::test]
async fn transfer_call_success() {
    let Setup { contract, accounts } =
        setup_balances(WASM_171_ONLY, 2, |i| vec![format!("token_{i}")], false).await;
    let alice = &accounts[0];
    let bob = &accounts[1];

    bob.batch(bob.id())
        .deploy(RECEIVER_WASM)
        .call(Function::new("new"))
        .transact()
        .await
        .unwrap()
        .unwrap();

    let result = alice
        .call(contract.id(), "nft_transfer_call")
        .args_json(json!({
            "token_id": "token_0",
            "receiver_id": bob.id(),
            "msg": "",
        }))
        .gas(THIRTY_TERAGAS)
        .deposit(ONE_YOCTO)
        .transact()
        .await
        .unwrap()
        .unwrap();

    let logs = result.logs();

    assert_eq!(
        vec![
            "before_nft_transfer(token_0)".to_string(),
            Nep171Event::NftTransfer(vec![NftTransferLog {
                token_ids: vec!["token_0".into()],
                authorized_id: None,
                old_owner_id: alice.id().into(),
                new_owner_id: bob.id().into(),
                memo: None,
            }])
            .to_event_string(),
            "after_nft_transfer(token_0)".to_string(),
            format!("Received token_0 from {} via {}", alice.id(), alice.id()),
        ],
        logs
    );

    // not returned
    assert_eq!(
        nft_token(&contract, "token_0").await,
        Some(Token {
            token_id: "token_0".to_string(),
            owner_id: bob.id().clone(),
            extensions_metadata: Default::default(),
        }),
    );
}

#[tokio::test]
async fn transfer_call_return_success() {
    let Setup { contract, accounts } =
        setup_balances(WASM_171_ONLY, 2, |i| vec![format!("token_{i}")], false).await;
    let alice = &accounts[0];
    let bob = &accounts[1];

    bob.batch(bob.id())
        .deploy(RECEIVER_WASM)
        .call(Function::new("new"))
        .transact()
        .await
        .unwrap()
        .unwrap();

    let result = alice
        .call(contract.id(), "nft_transfer_call")
        .args_json(json!({
            "token_id": "token_0",
            "receiver_id": bob.id(),
            "msg": "return",
        }))
        .gas(THIRTY_TERAGAS)
        .deposit(ONE_YOCTO)
        .transact()
        .await
        .unwrap()
        .unwrap();

    let logs = result.logs();

    assert_eq!(
        vec![
            "before_nft_transfer(token_0)".to_string(),
            Nep171Event::NftTransfer(vec![NftTransferLog {
                token_ids: vec!["token_0".into()],
                authorized_id: None,
                old_owner_id: alice.id().into(),
                new_owner_id: bob.id().into(),
                memo: None,
            }])
            .to_event_string(),
            "after_nft_transfer(token_0)".to_string(),
            format!("Received token_0 from {} via {}", alice.id(), alice.id()),
            "before_nft_transfer(token_0)".to_string(),
            Nep171Event::NftTransfer(vec![NftTransferLog {
                token_ids: vec!["token_0".into()],
                authorized_id: None,
                old_owner_id: bob.id().into(),
                new_owner_id: alice.id().into(),
                memo: None,
            }])
            .to_event_string(),
            "after_nft_transfer(token_0)".to_string(),
        ],
        logs
    );

    // returned
    assert_eq!(
        nft_token(&contract, "token_0").await,
        Some(Token {
            token_id: "token_0".to_string(),
            owner_id: alice.id().clone(),
            extensions_metadata: Default::default(),
        }),
    );
}

#[tokio::test]
async fn transfer_call_receiver_panic() {
    let Setup { contract, accounts } =
        setup_balances(WASM_171_ONLY, 2, |i| vec![format!("token_{i}")], false).await;
    let alice = &accounts[0];
    let bob = &accounts[1];

    bob.batch(bob.id())
        .deploy(RECEIVER_WASM)
        .call(Function::new("new"))
        .transact()
        .await
        .unwrap()
        .unwrap();

    let result = alice
        .call(contract.id(), "nft_transfer_call")
        .args_json(json!({
            "token_id": "token_0",
            "receiver_id": bob.id(),
            "msg": "panic",
        }))
        .gas(THIRTY_TERAGAS)
        .deposit(ONE_YOCTO)
        .transact()
        .await
        .unwrap()
        .unwrap();

    let logs = result.logs();

    assert_eq!(
        vec![
            "before_nft_transfer(token_0)".to_string(),
            Nep171Event::NftTransfer(vec![NftTransferLog {
                token_ids: vec!["token_0".into()],
                authorized_id: None,
                old_owner_id: alice.id().into(),
                new_owner_id: bob.id().into(),
                memo: None,
            }])
            .to_event_string(),
            "after_nft_transfer(token_0)".to_string(),
            format!("Received token_0 from {} via {}", alice.id(), alice.id()),
            "before_nft_transfer(token_0)".to_string(),
            Nep171Event::NftTransfer(vec![NftTransferLog {
                token_ids: vec!["token_0".into()],
                authorized_id: None,
                old_owner_id: bob.id().into(),
                new_owner_id: alice.id().into(),
                memo: None,
            }])
            .to_event_string(),
            "after_nft_transfer(token_0)".to_string(),
        ],
        logs
    );

    // returned
    assert_eq!(
        nft_token(&contract, "token_0").await,
        Some(Token {
            token_id: "token_0".to_string(),
            owner_id: alice.id().clone(),
            extensions_metadata: Default::default(),
        }),
    );
}

#[tokio::test]
async fn transfer_call_receiver_send_return() {
    let Setup { contract, accounts } =
        setup_balances(WASM_171_ONLY, 3, |i| vec![format!("token_{i}")], false).await;
    let alice = &accounts[0];
    let bob = &accounts[1];
    let charlie = &accounts[2];

    bob.batch(bob.id())
        .deploy(RECEIVER_WASM)
        .call(Function::new("new"))
        .transact()
        .await
        .unwrap()
        .unwrap();

    let result = alice
        .call(contract.id(), "nft_transfer_call")
        .args_json(json!({
            "token_id": "token_0",
            "receiver_id": bob.id(),
            "msg": format!("transfer:{}", charlie.id()),
        }))
        .gas(THIRTY_TERAGAS.saturating_mul(10)) // xtra gas
        .deposit(ONE_YOCTO)
        .transact()
        .await
        .unwrap()
        .unwrap();

    let logs = result.logs();

    println!("{logs:#?}");

    assert_eq!(
        vec![
            "before_nft_transfer(token_0)".to_string(),
            Nep171Event::NftTransfer(vec![NftTransferLog {
                token_ids: vec!["token_0".into()],
                authorized_id: None,
                old_owner_id: alice.id().into(),
                new_owner_id: bob.id().into(),
                memo: None,
            }])
            .to_event_string(),
            "after_nft_transfer(token_0)".to_string(),
            format!("Received token_0 from {} via {}", alice.id(), alice.id()),
            format!("Transferring token_0 to {}", charlie.id()),
            "before_nft_transfer(token_0)".to_string(),
            Nep171Event::NftTransfer(vec![NftTransferLog {
                token_ids: vec!["token_0".into()],
                authorized_id: None,
                old_owner_id: bob.id().into(),
                new_owner_id: charlie.id().into(),
                memo: None,
            }])
            .to_event_string(),
            "after_nft_transfer(token_0)".to_string(),
            "returning true".to_string(),
        ],
        logs
    );

    // not returned
    assert_eq!(
        nft_token(&contract, "token_0").await,
        Some(Token {
            token_id: "token_0".to_string(),
            owner_id: charlie.id().clone(),
            extensions_metadata: Default::default(),
        }),
    );
}

#[tokio::test]
async fn transfer_approval_success() {
    let Setup { contract, accounts } =
        setup_balances(WASM_FULL, 3, |i| vec![format!("token_{i}")], true).await;
    let alice = &accounts[0];
    let bob = &accounts[1];
    let charlie = &accounts[2];

    alice
        .call(contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "token_0",
            "account_id": bob.id(),
        }))
        .deposit(ONE_YOCTO)
        .transact()
        .await
        .unwrap()
        .unwrap();

    let view_token = nft_token::<Token>(&contract, "token_0").await;

    let expected_view_token = Token {
        token_id: "token_0".into(),
        owner_id: alice.id().clone(),
        extensions_metadata: [
            ("metadata".to_string(), token_meta("token_0")),
            (
                "approved_account_ids".to_string(),
                json!({
                    bob.id().to_string(): 0,
                }),
            ),
            ("funky_data".to_string(), json!({"funky": "data"})),
        ]
        .into(),
    };

    assert_eq!(view_token, Some(expected_view_token));

    let is_approved = contract
        .view("nft_is_approved")
        .args_json(json!({
            "token_id": "token_0",
            "approved_account_id": bob.id().to_string(),
        }))
        .await
        .unwrap()
        .json::<bool>()
        .unwrap();

    assert!(is_approved);

    bob.call(contract.id(), "nft_transfer")
        .args_json(json!({
            "token_id": "token_0",
            "approval_id": 0,
            "receiver_id": charlie.id().to_string(),
        }))
        .deposit(ONE_YOCTO)
        .transact()
        .await
        .unwrap()
        .unwrap();

    assert_eq!(
        nft_token(&contract, "token_0").await,
        Some(Token {
            token_id: "token_0".to_string(),
            owner_id: charlie.id().clone(),
            extensions_metadata: [
                ("metadata".to_string(), token_meta("token_0")),
                ("approved_account_ids".to_string(), json!({})),
                ("funky_data".to_string(), json!({"funky": "data"})),
            ]
            .into(),
        }),
    );
}

#[tokio::test]
async fn transfer_approval_unapproved_fail() {
    let Setup { contract, accounts } =
        setup_balances(WASM_FULL, 4, |i| vec![format!("token_{i}")], true).await;
    let alice = &accounts[0];
    let bob = &accounts[1];
    let charlie = &accounts[2];
    let debbie = &accounts[3];

    alice
        .call(contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "token_0",
            "account_id": debbie.id(),
        }))
        .deposit(ONE_YOCTO)
        .transact()
        .await
        .unwrap()
        .unwrap();

    let is_approved = contract
        .view("nft_is_approved")
        .args_json(json!({
            "token_id": "token_0",
            "approved_account_id": bob.id().to_string(),
        }))
        .await
        .unwrap()
        .json::<bool>()
        .unwrap();

    assert!(!is_approved);

    let result = bob
        .call(contract.id(), "nft_transfer")
        .args_json(json!({
            "token_id": "token_0",
            "approval_id": 0,
            "receiver_id": charlie.id().to_string(),
        }))
        .deposit(ONE_YOCTO)
        .transact()
        .await
        .unwrap();

    let expected_error_message = format!(
        "Smart contract panicked: {}",
        nep171::error::SenderNotApprovedError {
            owner_id: alice.id().clone(),
            sender_id: bob.id().clone(),
            token_id: "token_0".to_string(),
            approval_id: 0,
        }
    );

    expect_execution_error(&result, expected_error_message);
}

#[tokio::test]
#[should_panic = "Attached deposit must be greater than zero"]
async fn transfer_approval_no_deposit_fail() {
    let Setup { contract, accounts } =
        setup_balances(WASM_FULL, 2, |i| vec![format!("token_{i}")], true).await;
    let alice = &accounts[0];
    let bob = &accounts[1];

    alice
        .call(contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "token_0",
            "account_id": bob.id(),
        }))
        .transact()
        .await
        .unwrap()
        .unwrap();
}

#[tokio::test]
async fn transfer_approval_double_approval_fail() {
    let Setup { contract, accounts } =
        setup_balances(WASM_FULL, 2, |i| vec![format!("token_{i}")], true).await;
    let alice = &accounts[0];
    let bob = &accounts[1];

    alice
        .call(contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "token_0",
            "account_id": bob.id(),
        }))
        .deposit(ONE_YOCTO)
        .transact()
        .await
        .unwrap()
        .unwrap();

    let result = alice
        .call(contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "token_0",
            "account_id": bob.id(),
        }))
        .deposit(ONE_YOCTO)
        .transact()
        .await
        .unwrap();

    let expected_error = format!(
        "Smart contract panicked: {}",
        Nep178ApproveError::AccountAlreadyApproved(AccountAlreadyApprovedError {
            account_id: bob.id().clone(),
            token_id: "token_0".to_string(),
        }),
    );

    expect_execution_error(&result, expected_error);
}

#[tokio::test]
async fn transfer_approval_unauthorized_approval_fail() {
    let Setup { contract, accounts } =
        setup_balances(WASM_FULL, 2, |i| vec![format!("token_{i}")], true).await;
    let _alice = &accounts[0];
    let bob = &accounts[1];

    let result = bob
        .call(contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "token_0",
            "account_id": bob.id(),
        }))
        .deposit(ONE_YOCTO)
        .transact()
        .await
        .unwrap();

    let expected_error = format!(
        "Smart contract panicked: {}",
        Nep178ApproveError::Unauthorized(UnauthorizedError {
            account_id: bob.id().clone(),
            token_id: "token_0".to_string(),
        }),
    );

    expect_execution_error(&result, expected_error);
}

#[tokio::test]
async fn transfer_approval_too_many_approvals_fail() {
    let Setup { contract, accounts } =
        setup_balances(WASM_FULL, 2, |i| vec![format!("token_{i}")], true).await;
    let alice = &accounts[0];
    let bob = &accounts[1];

    let mut set = JoinSet::new();

    for i in 0..32 {
        let contract = contract.clone();
        let alice = alice.clone();
        set.spawn(async move {
            alice
                .call(contract.id(), "nft_approve")
                .args_json(json!({
                    "token_id": "token_0",
                    "account_id": format!("account_{}", i),
                }))
                .deposit(ONE_YOCTO)
                .transact()
                .await
                .unwrap()
                .unwrap();
        });
    }

    while (set.join_next().await).is_some() {}

    let result = alice
        .call(contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "token_0",
            "account_id": bob.id(),
        }))
        .deposit(ONE_YOCTO)
        .transact()
        .await
        .unwrap();

    let expected_error = format!(
        "Smart contract panicked: {}",
        Nep178ApproveError::TooManyApprovals(TooManyApprovalsError {
            token_id: "token_0".to_string(),
        }),
    );

    expect_execution_error(&result, expected_error);
}

#[tokio::test]
async fn transfer_approval_approved_but_wrong_approval_id_fail() {
    let Setup { contract, accounts } =
        setup_balances(WASM_FULL, 3, |i| vec![format!("token_{i}")], true).await;
    let alice = &accounts[0];
    let bob = &accounts[1];
    let charlie = &accounts[2];

    alice
        .call(contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "token_0",
            "account_id": bob.id(),
        }))
        .deposit(ONE_YOCTO)
        .transact()
        .await
        .unwrap()
        .unwrap();

    let result = bob
        .call(contract.id(), "nft_transfer")
        .args_json(json!({
            "token_id": "token_0",
            "approval_id": 1,
            "receiver_id": charlie.id().to_string(),
        }))
        .deposit(ONE_YOCTO)
        .transact()
        .await
        .unwrap();

    let expected_error = format!(
        "Smart contract panicked: {}",
        nep171::error::Nep171TransferError::SenderNotApproved(
            nep171::error::SenderNotApprovedError {
                sender_id: bob.id().clone(),
                owner_id: alice.id().clone(),
                token_id: "token_0".to_string(),
                approval_id: 1,
            }
        ),
    );

    expect_execution_error(&result, expected_error);
}

#[tokio::test]
#[should_panic = "Account this_account_is_not_registered.near is not registered"]
async fn transfer_fail_not_registered_nep145() {
    let Setup { contract, accounts } =
        setup_balances(WASM_FULL, 1, |i| vec![format!("token_{i}")], true).await;
    let alice = &accounts[0];

    alice
        .call(contract.id(), "nft_transfer")
        .args_json(json!({
            "token_id": "token_0",
            "receiver_id": "this_account_is_not_registered.near",
        }))
        .deposit(ONE_YOCTO)
        .transact()
        .await
        .unwrap()
        .unwrap();
}

'''
'''--- workspaces-tests/tests/rbac.rs ---
use std::collections::HashSet;

use near_sdk::{
    serde::Deserialize,
    serde_json::{self, json},
};
use near_workspaces::{Account, AccountId, Contract};
use pretty_assertions::assert_eq;
use tokio::join;

const WASM: &[u8] = include_bytes!("../../target/wasm32-unknown-unknown/release/rbac.wasm");

#[derive(Deserialize, Clone, Default, Debug, PartialEq, Eq)]
#[serde(crate = "near_sdk::serde")]
struct ContractSchema {
    pub alpha: u32,
    pub beta: u32,
    pub gamma: u32,
    pub delta: u32,
}

struct Setup {
    pub contract: Contract,
    pub accounts: Vec<Account>,
}

/// Setup for individual tests
async fn setup(num_accounts: usize, wasm: &[u8]) -> Setup {
    let worker = near_workspaces::sandbox().await.unwrap();

    // Initialize user accounts
    let mut accounts = vec![];
    for _ in 0..(num_accounts + 1) {
        accounts.push(worker.dev_create_account().await.unwrap());
    }

    let alice = &accounts[0].clone();

    let contract = alice.deploy(wasm).await.unwrap().unwrap();
    contract.call("new").transact().await.unwrap().unwrap();

    Setup { contract, accounts }
}

#[tokio::test]
async fn happy() {
    let Setup { contract, accounts } = setup(4, WASM).await;

    let alice = &accounts[0];
    let bob = &accounts[1];
    let charlie = &accounts[2];
    let daisy = &accounts[3];

    let call = |who: Account, contract: AccountId, method: String, args: Vec<u8>| async move {
        who.call(&contract, &method)
            .args(args)
            .transact()
            .await
            .unwrap()
            .unwrap()
    };

    let acquire_role = |who: Account, role: &str| {
        call(
            who,
            contract.id().clone(),
            "acquire_role".to_string(),
            serde_json::to_vec(&json!({ "role": role })).unwrap(),
        )
    };

    let count_members = |contract: Contract, role: &str| {
        let role = role.to_string();
        async move {
            contract
                .view("count_members")
                .args_json(json!({ "role": role }))
                .await
                .unwrap()
                .json::<u32>()
                .unwrap()
        }
    };

    let members = |contract: Contract, role: &str| {
        let role = role.to_string();
        async move {
            contract
                .view("members")
                .args_json(json!({ "role": role }))
                .await
                .unwrap()
                .json::<HashSet<String>>()
                .unwrap()
        }
    };

    join!(
        // alice has every role
        acquire_role(alice.clone(), "a"),
        acquire_role(alice.clone(), "b"),
        acquire_role(alice.clone(), "g"),
        acquire_role(alice.clone(), "d"),
        // duplicate alice roles should have no effect
        acquire_role(alice.clone(), "a"),
        acquire_role(alice.clone(), "b"),
        acquire_role(alice.clone(), "g"),
        acquire_role(alice.clone(), "d"),
        // bob has same roles as alice
        acquire_role(bob.clone(), "a"),
        acquire_role(bob.clone(), "b"),
        acquire_role(bob.clone(), "g"),
        acquire_role(bob.clone(), "d"),
        // charlie has the first two roles
        acquire_role(charlie.clone(), "a"),
        acquire_role(charlie.clone(), "b"),
        // daisy has no roles
    );

    call(
        alice.clone(),
        contract.id().clone(),
        "requires_alpha".to_string(),
        vec![],
    )
    .await;

    call(
        charlie.clone(),
        contract.id().clone(),
        "requires_alpha".to_string(),
        vec![],
    )
    .await;

    call(
        alice.clone(),
        contract.id().clone(),
        "requires_beta".to_string(),
        vec![],
    )
    .await;

    call(
        bob.clone(),
        contract.id().clone(),
        "requires_gamma".to_string(),
        vec![],
    )
    .await;

    call(
        alice.clone(),
        contract.id().clone(),
        "requires_delta".to_string(),
        vec![],
    )
    .await;

    let schema = contract
        .view("get")
        .await
        .unwrap()
        .json::<ContractSchema>()
        .unwrap();

    assert_eq!(
        schema,
        ContractSchema {
            alpha: 2,
            beta: 1,
            gamma: 1,
            delta: 1,
        },
    );

    let (members_a, members_b, members_g, members_d, count_a, count_b, count_g, count_d) = join!(
        members(contract.clone(), "a"),
        members(contract.clone(), "b"),
        members(contract.clone(), "g"),
        members(contract.clone(), "d"),
        count_members(contract.clone(), "a"),
        count_members(contract.clone(), "b"),
        count_members(contract.clone(), "g"),
        count_members(contract.clone(), "d"),
    );

    let (alice_str, bob_str, charlie_str, _daisy_str) = (
        alice.id().to_string(),
        bob.id().to_string(),
        charlie.id().to_string(),
        daisy.id().to_string(),
    );

    assert_eq!(count_a, 3);
    assert_eq!(count_b, 3);
    assert_eq!(count_g, 2);
    assert_eq!(count_d, 2);

    assert_eq!(
        members_a,
        [alice_str.clone(), bob_str.clone(), charlie_str.clone()].into(),
    );
    assert_eq!(
        members_b,
        [alice_str.clone(), bob_str.clone(), charlie_str].into(),
    );
    assert_eq!(members_g, [alice_str.clone(), bob_str.clone()].into());
    assert_eq!(members_d, [alice_str, bob_str].into());
}

#[tokio::test]
#[should_panic = "Unauthorized role"]
async fn fail_missing_role() {
    let Setup { contract, accounts } = setup(1, WASM).await;

    let alice = &accounts[0];

    alice
        .call(contract.id(), "requires_alpha")
        .transact()
        .await
        .unwrap()
        .unwrap();
}

'''
'''--- workspaces-tests/tests/simple_multisig.rs ---
use near_sdk::serde_json::json;
use near_workspaces::{Account, Contract};
use pretty_assertions::assert_eq;

const WASM: &[u8] =
    include_bytes!("../../target/wasm32-unknown-unknown/release/simple_multisig.wasm");

struct Setup {
    pub contract: Contract,
    pub accounts: Vec<Account>,
}

/// Setup for individual tests
async fn setup(num_accounts: usize) -> Setup {
    let worker = near_workspaces::sandbox().await.unwrap();

    // Initialize contract
    let contract = worker.dev_deploy(WASM).await.unwrap();
    contract.call("new").transact().await.unwrap().unwrap();

    // Initialize user accounts
    let mut accounts = vec![];
    for _ in 0..(num_accounts + 1) {
        accounts.push(worker.dev_create_account().await.unwrap());
    }

    Setup { contract, accounts }
}

async fn setup_roles(num_accounts: usize) -> Setup {
    let s = setup(num_accounts).await;

    for account in s.accounts[..s.accounts.len() - 1].iter() {
        account
            .call(s.contract.id(), "obtain_multisig_permission")
            .transact()
            .await
            .unwrap()
            .unwrap();
    }

    s
}

#[tokio::test]
async fn successful_request() {
    let Setup { contract, accounts } = setup_roles(3).await;

    let alice = &accounts[0];
    let bob = &accounts[1];
    let charlie = &accounts[2];

    let request_id = alice
        .call(contract.id(), "request")
        .args_json(json!({"action": "hello"}))
        .transact()
        .await
        .unwrap()
        .json::<u32>()
        .unwrap();

    let is_approved = || async {
        contract
            .view("is_approved")
            .args_json(json!({ "request_id": request_id }))
            .await
            .unwrap()
            .json::<bool>()
            .unwrap()
    };

    assert!(!is_approved().await);

    alice
        .call(contract.id(), "approve")
        .args_json(json!({ "request_id": request_id }))
        .transact()
        .await
        .unwrap()
        .unwrap();

    assert!(!is_approved().await);

    bob.call(contract.id(), "approve")
        .args_json(json!({ "request_id": request_id }))
        .transact()
        .await
        .unwrap()
        .unwrap();

    assert!(is_approved().await);

    charlie
        .call(contract.id(), "approve")
        .args_json(json!({ "request_id": request_id }))
        .transact()
        .await
        .unwrap()
        .unwrap();

    assert!(is_approved().await);

    let exec_result = charlie
        .call(contract.id(), "execute")
        .args_json(json!({ "request_id": request_id }))
        .transact()
        .await
        .unwrap()
        .json::<String>()
        .unwrap();

    assert_eq!(exec_result, "hello");
}

#[tokio::test]
#[should_panic = "UnauthorizedAccount"]
async fn unauthorized_account() {
    let Setup { contract, accounts } = setup_roles(3).await;

    let alice = &accounts[0];
    let unauthorized_account = &accounts[3];

    let request_id = alice
        .call(contract.id(), "request")
        .args_json(json!({"action": "hello"}))
        .transact()
        .await
        .unwrap()
        .json::<u32>()
        .unwrap();

    unauthorized_account
        .call(contract.id(), "approve")
        .args_json(json!({ "request_id": request_id }))
        .transact()
        .await
        .unwrap()
        .unwrap();
}

'''
'''--- workspaces-tests/tests/storage_fee.rs ---
use near_sdk::serde_json::json;
use near_workspaces::{sandbox, types::NearToken, Account, Contract, DevNetwork, Worker};
use workspaces_tests_utils::ONE_NEAR;

const WASM: &[u8] = include_bytes!("../../target/wasm32-unknown-unknown/release/storage_fee.wasm");

struct Setup<T: DevNetwork> {
    pub worker: Worker<T>,
    pub contract: Contract,
    pub accounts: Vec<Account>,
}

async fn setup<T: DevNetwork>(worker: Worker<T>, num_accounts: usize) -> Setup<T> {
    // Initialize contract
    let contract = worker.dev_deploy(WASM).await.unwrap();
    contract.call("new").transact().await.unwrap().unwrap();

    // Initialize user accounts
    let mut accounts = vec![];
    for _ in 0..(num_accounts + 1) {
        accounts.push(worker.dev_create_account().await.unwrap());
    }

    Setup {
        worker,
        contract,
        accounts,
    }
}

#[tokio::test]
async fn storage_fee() {
    let Setup {
        contract,
        accounts,
        worker,
    } = setup(sandbox().await.unwrap(), 1).await;

    let alice = &accounts[0];
    let balance_start = alice.view_account().await.unwrap().balance;

    let byte_cost = contract
        .view("storage_byte_cost")
        .await
        .unwrap()
        .json::<NearToken>()
        .unwrap();

    let num_bytes = NearToken::from_near(1)
        .as_yoctonear()
        .saturating_div(byte_cost.as_yoctonear());
    let payload = "0".repeat(usize::try_from(num_bytes).unwrap());
    // This is the absolute minimum this payload should require to store (uncompressed)
    let minimum_storage_fee = byte_cost.saturating_mul(num_bytes);
    let gas_price = worker.gas_price().await.unwrap();

    let go = || async {
        let balance_before = alice.view_account().await.unwrap().balance;

        let r = alice
            .call(contract.id(), "store")
            .args_json(json!({
                "item": payload,
            }))
            .deposit(ONE_NEAR.saturating_mul(10)) // Should receive back about 9 NEAR as refund
            .transact()
            .await
            .unwrap()
            .unwrap();

        let balance_after = alice.view_account().await.unwrap().balance;

        // How much was actually charged to the account?
        // Note that there will be *some* overhead, e.g. collection indexing
        let net_fee = balance_before
            .saturating_sub(balance_after)
            .saturating_sub(gas_price.saturating_mul(r.total_gas_burnt.as_gas() as u128));

        assert!(net_fee >= minimum_storage_fee);

        // Sanity/validity check / allow up to 100 bytes worth of additional storage to be charged
        assert!(net_fee.saturating_sub(minimum_storage_fee) < byte_cost.saturating_mul(100));
    };

    for _ in 0..5 {
        go().await;
    }

    let balance_end = alice.view_account().await.unwrap().balance;
    assert!(balance_start.saturating_sub(balance_end) >= minimum_storage_fee.saturating_mul(5));
}

'''
'''--- workspaces-tests/tests/upgrade.rs ---
use near_sdk::{borsh::BorshSerialize, serde::Serialize};
use near_workspaces::{Account, Contract};
use pretty_assertions::assert_eq;

const WASM_BORSH: &[u8] =
    include_bytes!("../../target/wasm32-unknown-unknown/release/upgrade_old_borsh.wasm");

const WASM_JSON: &[u8] =
    include_bytes!("../../target/wasm32-unknown-unknown/release/upgrade_old_jsonbase64.wasm");

const WASM_RAW: &[u8] =
    include_bytes!("../../target/wasm32-unknown-unknown/release/upgrade_old_raw.wasm");

const NEW_WASM: &[u8] =
    include_bytes!("../../target/wasm32-unknown-unknown/release/upgrade_new.wasm");

const BAD_WASM: &[u8] =
    include_bytes!("../../target/wasm32-unknown-unknown/release/upgrade_bad.wasm");

const RANDOM_WASM: &[u8] =
    include_bytes!("../../target/wasm32-unknown-unknown/release/counter_multisig.wasm");

#[derive(BorshSerialize)]
#[borsh(crate = "near_sdk::borsh")]
struct ArgsBorsh {
    pub code: Vec<u8>,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
struct ArgsJson {
    pub code: near_sdk::json_types::Base64VecU8,
}

struct Setup {
    pub contract: Contract,
    pub accounts: Vec<Account>,
}

/// Setup for individual tests
async fn setup(num_accounts: usize, wasm: &[u8]) -> Setup {
    let worker = near_workspaces::sandbox().await.unwrap();

    // Initialize user accounts
    let mut accounts = vec![];
    for _ in 0..(num_accounts + 1) {
        accounts.push(worker.dev_create_account().await.unwrap());
    }

    let alice = &accounts[0].clone();

    let contract = alice.deploy(wasm).await.unwrap().unwrap();
    contract.call("new").transact().await.unwrap().unwrap();

    Setup { contract, accounts }
}

async fn perform_upgrade_test(wasm: &[u8], args: Vec<u8>) {
    let Setup { contract, accounts } = setup(1, wasm).await;

    let alice = &accounts[0];

    alice
        .call(contract.id(), "increment_foo")
        .transact()
        .await
        .unwrap()
        .unwrap();

    let val = alice
        .call(contract.id(), "get_foo")
        .transact()
        .await
        .unwrap()
        .json::<u32>()
        .unwrap();

    assert_eq!(val, 1);

    alice
        .call(contract.id(), "upgrade")
        .max_gas()
        .args(args)
        .transact()
        .await
        .unwrap()
        .unwrap();

    let new_val = alice
        .call(contract.id(), "get_bar")
        .transact()
        .await
        .unwrap()
        .json::<u64>()
        .unwrap();

    assert_eq!(new_val, 1);
}

#[tokio::test]
async fn upgrade_borsh() {
    perform_upgrade_test(
        WASM_BORSH,
        near_sdk::borsh::to_vec(&ArgsBorsh {
            code: NEW_WASM.to_vec(),
        })
        .unwrap(),
    )
    .await;
}

#[tokio::test]
#[ignore]
async fn upgrade_jsonbase64() {
    // For some reason this test fails only on GitHub Actions due to a running-out-of-gas error.
    if std::env::var_os("GITHUB_ACTIONS").is_some() {
        eprintln!("Skipping upgrade_jsonbase64 test on GitHub Actions.");
        return;
    }
    perform_upgrade_test(
        WASM_JSON,
        near_sdk::serde_json::to_vec(&ArgsJson {
            code: NEW_WASM.to_vec().into(),
        })
        .unwrap(),
    )
    .await;
}

#[tokio::test]
async fn upgrade_raw() {
    perform_upgrade_test(WASM_RAW, NEW_WASM.to_vec()).await;
}

#[tokio::test]
#[should_panic = "Failed to deserialize input from Borsh."]
async fn upgrade_failure_blank_wasm() {
    perform_upgrade_test(WASM_BORSH, vec![]).await;
}

#[tokio::test]
#[should_panic = "MethodResolveError(MethodNotFound)"]
async fn upgrade_failure_no_upgrade() {
    let Setup { contract, accounts } = setup(1, BAD_WASM).await;

    let alice = &accounts[0];

    alice
        .call(contract.id(), "upgrade")
        .max_gas()
        .transact()
        .await
        .unwrap()
        .unwrap();
}

#[tokio::test]
#[should_panic = "MethodResolveError(MethodNotFound)"]
async fn upgrade_failure_random_wasm() {
    let Setup { contract, accounts } = setup(1, RANDOM_WASM).await;

    let alice = &accounts[0];

    alice
        .call(contract.id(), "upgrade")
        .max_gas()
        .transact()
        .await
        .unwrap()
        .unwrap();
}

async fn fail_owner(wasm: &[u8], args: Vec<u8>) {
    let Setup { contract, accounts } = setup(2, wasm).await;

    let bob = &accounts[1];

    bob.call(contract.id(), "upgrade")
        .max_gas()
        .args(args)
        .transact()
        .await
        .unwrap()
        .unwrap();
}

#[tokio::test]
#[should_panic = "Smart contract panicked: Owner only"]
async fn upgrade_failure_not_owner_borsh() {
    fail_owner(
        WASM_BORSH,
        near_sdk::borsh::to_vec(&ArgsBorsh {
            code: NEW_WASM.to_vec(),
        })
        .unwrap(),
    )
    .await;
}

#[tokio::test]
#[should_panic = "Smart contract panicked: Owner only"]
async fn upgrade_failure_not_owner_jsonbase64() {
    fail_owner(
        WASM_JSON,
        near_sdk::serde_json::to_vec(&ArgsJson {
            code: NEW_WASM.to_vec().into(),
        })
        .unwrap(),
    )
    .await;
}

#[tokio::test]
#[should_panic = "Smart contract panicked: Owner only"]
async fn upgrade_failure_not_owner_raw() {
    fail_owner(WASM_RAW, NEW_WASM.to_vec()).await;
}

'''
'''--- workspaces-tests/tests/upgrade_multisig.rs ---
use near_sdk::{json_types::Base64VecU8, serde_json::json};
use near_workspaces::{Account, Contract};
use pretty_assertions::assert_eq;

const WASM: &[u8] =
    include_bytes!("../../target/wasm32-unknown-unknown/release/upgrade_old_multisig.wasm");

const NEW_WASM: &[u8] =
    include_bytes!("../../target/wasm32-unknown-unknown/release/upgrade_new.wasm");

struct Setup {
    pub contract: Contract,
    pub accounts: Vec<Account>,
}

/// Setup for individual tests
async fn setup(num_accounts: usize, wasm: &[u8]) -> Setup {
    let worker = near_workspaces::sandbox().await.unwrap();

    // Initialize user accounts
    let mut accounts = vec![];
    for _ in 0..(num_accounts + 1) {
        accounts.push(worker.dev_create_account().await.unwrap());
    }

    let alice = &accounts[0].clone();

    let contract = alice.deploy(wasm).await.unwrap().unwrap();
    contract.call("new").transact().await.unwrap().unwrap();

    Setup { contract, accounts }
}

#[tokio::test]
async fn upgrade_multisig() {
    let Setup { contract, accounts } = setup(1, WASM).await;

    let alice = &accounts[0];

    let code = Base64VecU8::from(Vec::from(NEW_WASM));

    let request_id: u32 = alice
        .call(contract.id(), "request")
        .max_gas()
        .args_json(json!({
            "request": {
                "Upgrade": {
                    "code": code,
                },
            },
        }))
        .transact()
        .await
        .unwrap()
        .unwrap()
        .json()
        .unwrap();

    alice
        .call(contract.id(), "approve")
        .max_gas()
        .args_json(json!({
            "request_id": request_id,
        }))
        .transact()
        .await
        .unwrap()
        .unwrap();

    alice
        .call(contract.id(), "execute")
        .max_gas()
        .args_json(json!({
            "request_id": request_id,
        }))
        .transact()
        .await
        .unwrap()
        .unwrap();

    let new_val = alice
        .call(contract.id(), "get_bar")
        .transact()
        .await
        .unwrap()
        .json::<u64>()
        .unwrap();

    assert_eq!(new_val, 0);
}

'''