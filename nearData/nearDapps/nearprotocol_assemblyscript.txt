*GitHub Repository "nearprotocol/assemblyscript"*

'''--- .eslintrc.js ---
module.exports = {
  root: true,
  parser: "@typescript-eslint/parser",
  plugins: [
    "@typescript-eslint",
  ],
  extends: [
    "eslint:recommended",
    "plugin:@typescript-eslint/eslint-recommended",
    "plugin:@typescript-eslint/recommended",
  ],
  parserOptions: {
    ecmaVersion: 2020,
    sourceType: "module",
    ecmaFeatures: {}
  },
  globals: {
    "BigInt64Array": "readonly",
    "BigUint64Array": "readonly",
    "__non_webpack_require__": "readonly"
  },

  // === General rules =========================================================

  rules: {
    // Omitted semicolons are hugely popular, yet within the compiler it makes
    // sense to be better safe than sorry.
    "semi": "error",

    // Our code bases uses 2 spaces for indentation, and we enforce it here so
    // files don't mix spaces, tabs or different indentation levels.
    "indent": ["error", 2, {
      "SwitchCase": 1,
      "VariableDeclarator": "first",
      "offsetTernaryExpressions": true,
      "ignoredNodes": [ // FIXME: something's odd here
        "ConditionalExpression > *",
        "ConditionalExpression > * > *",
        "ConditionalExpression > * > * > *"
      ]
    }],

    // This is mostly visual style, making comments look uniform.
    "spaced-comment": ["error", "always", {
      "markers": ["/"],   // triple-slash
      "exceptions": ["/"] // all slashes
    }],

    // This tends to be annoying as it encourages developers to make everything
    // that is never reassigned a 'const', sometimes semantically incorrect so,
    // typically leading to huge diffs in follow-up PRs modifying affected code.
    "prefer-const": "off",

    // It is perfectly fine to declare top-level variables with `var`, yet this
    // rule doesn't provide configuration options that would help.
    "no-var": "off",

    // Quite often, dealing with multiple related cases at once or otherwise
    // falling through is exactly the point of using a switch.
    "no-fallthrough": "off",

    // Typical false-positives here are `do { ... } while (true)` statements or
    // similar, but the only option provided here is not checking any loops.
    "no-constant-condition": ["error", { checkLoops: false }],

    // Functions are nested in blocks occasionally, and there haven't been any
    // problems with this so far, so turning the check off.
    "no-inner-declarations": "off",

    // Quite common in scenarios where an iteration starts at `current = this`.
    "@typescript-eslint/no-this-alias": "off",

    // Disabled here, but enabled again for JavaScript files.
    "no-unused-vars": "off",

    // Disabled here, but enabled again for TypeScript files.
    "@typescript-eslint/no-unused-vars": "off"
  },
  overrides: [

    // === JavaScript rules ====================================================

    {
      env: {
        "browser": true,
        "amd": true,
        "node": true,
        "es6": true
      },
      files: [
        "**/*.js",
        "bin/*"
      ],
      rules: {
        // We are testing both ESM and UMD, so don't limit us.
        "@typescript-eslint/no-var-requires": "off",

        // This rule does not behave well in JS files.
        "@typescript-eslint/explicit-module-boundary-types": "off",

        // Enforcing to remove function parameters on stubs makes code less
        // maintainable, so we instead allow unused function parameters.
        "no-unused-vars": [
          "warn", {
            "vars": "local",
            "args": "none",
            "ignoreRestSiblings": false
          }
        ]
      }
    },

    // === TypeScript rules ====================================================

    {
      files: [
        "**/*.ts"
      ],
      rules: {
        // Enforcing to remove function parameters on stubs makes code less
        // maintainable, so we instead allow unused function parameters.
        "@typescript-eslint/no-unused-vars": [
          "warn", {
            "vars": "local",
            "varsIgnorePattern": "^[A-Z](?:From|To)?$", // ignore type params
            "args": "none",
            "ignoreRestSiblings": false
          }
        ]
      }
    },

    // === AssemblyScript rules (extends TypeScript rules) =====================

    {
      files: [
        "**/assembly/**/*.ts",
        "src/**/*.ts",
        "lib/parse/src/**/*.ts"
      ],
      rules: {
        // Namespaces are quite useful in AssemblyScript
        "@typescript-eslint/no-namespace": "off",

        // There is actually codegen difference here
        "@typescript-eslint/no-array-constructor": "off",

        // Sometimes it can't be avoided to add a @ts-ignore
        "@typescript-eslint/ban-ts-comment": "off",

        // Utilized to achieve portability in some cases
        "@typescript-eslint/no-non-null-assertion": "off",
      }
    },

    // === Compiler rules (extends AssemblyScript rules) =======================

    {
      files: [
        "src/**/*.ts",
        "std/assembly/**/*.ts"
      ],
      rules: {
        // There is an actual codegen difference here - TODO: revisit
        "no-cond-assign": "off",

        // Not all types can be omitted in AS yet - TODO: revisit
        "@typescript-eslint/no-inferrable-types": "off",

        // Used rarely to reference internals that are not user-visible
        "@typescript-eslint/triple-slash-reference": "off",

        // The compiler has its own `Function` class for example
        "no-shadow-restricted-names": "off",
        "@typescript-eslint/ban-types": "off"
      }
    },

    // === Standard Library rules (extends AssemblyScript rules) ===============

    {
      files: [
        "std/assembly/**/*.ts"
      ],
      rules: {
        // We are implementing with --noLib, so we shadow all the time
        "no-shadow-restricted-names": "off",

        // Similarly, sometimes we need the return type to be String, not string
        "@typescript-eslint/ban-types": "off"
      }
    },

    // === Standard Definition rules (extends TypeScript rules) ================

    {
      files: [
        "std/**/*.d.ts"
      ],
      rules: {
        // Often required to achieve compatibility with TypeScript
        "@typescript-eslint/no-explicit-any": "off",

        // Interfaces can be stubs here, i.e. not yet fully implemented
        "@typescript-eslint/no-empty-interface": "off",

        // Definitions make use of `object` to model rather unusual constraints
        "@typescript-eslint/ban-types": "off"
      }
    },

    // === Compiler Definition rules (extends TypeScript rules) ================

    {
      files: [
        "./index.d.ts",
        "./index.release.d.ts",
      ],
      rules: {
        // Our definitions are complicated, and all attempts to describe them
        // as modules have failed so far. As such, we re-export namespaces.
        "@typescript-eslint/no-namespace": "off",
        "@typescript-eslint/triple-slash-reference": "off"
      }
    },

    // === Test rules (extends TypeScript rules) ===============================

    {
      files: [
        "./tests/compiler/**/*.ts",
        "./lib/loader/tests/assembly/**/*.ts"
      ],
      rules: {
        // Tests typically include unusual code patterns on purpose. This is
        // very likely not an extensive list, but covers what's there so far.
        "no-empty": "off",
        "no-cond-assign": "off",
        "no-compare-neg-zero": "off",
        "no-inner-declarations": "off",
        "no-constant-condition": "off",
        "use-isnan": "off",
        "@typescript-eslint/no-namespace": "off",
        "@typescript-eslint/no-unused-vars": "off",
        "@typescript-eslint/no-empty-function": "off",
        "@typescript-eslint/no-non-null-assertion": "off",
        "@typescript-eslint/no-extra-semi": "off",
        "@typescript-eslint/no-inferrable-types": "off",
        "@typescript-eslint/ban-types": "off",
        "@typescript-eslint/triple-slash-reference": "off",
        "@typescript-eslint/ban-ts-comment": "off",
        "@typescript-eslint/no-extra-non-null-assertion": "off",
        "@typescript-eslint/no-empty-interface": "off"
      }
    },
  ]
};

'''
'''--- .github/FUNDING.yml ---
open_collective: assemblyscript

'''
'''--- .github/ISSUE_TEMPLATE.md ---
<!--
 Thanks for submitting an issue to AssemblyScript! Please take a moment to
 read the contributing guidelines linked below to get off to a good start ðŸ™‚
-->

'''
'''--- .github/PULL_REQUEST_TEMPLATE.md ---
<!--
 Thanks for submitting a pull request to AssemblyScript! Please take a moment to
 review the contributing guidelines linked below, and confirm with an [x] ðŸ™‚
-->

â¯ˆ
â¯ˆ
â¯ˆ

- [ ] I've read the contributing guidelines
- [ ] I've added my name and email to the NOTICE file

'''
'''--- .github/workflows/publish.yml ---
name: Publish
on:
  schedule:
  - cron: '0 0 * * *'
jobs:
  release:
    name: Packages
    if: github.repository == 'AssemblyScript/assemblyscript'
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v1
      with:
        ref: main
    - uses: dcodeIO/setup-node-nvm@master
      with:
        node-version: current
    - name: Install dependencies
      run: | # npm>=7 is currently broken: https://github.com/npm/cli/issues/1973
        npm -g install npm@6
        npm -v
        npm ci
    - name: Build packages
      run: |
        VERSION=$(npx aspublish --version)
        if [[ "$VERSION" == "" ]]; then
          echo "Changes do not trigger a release"
        elif [[ "$VERSION" != "0."* ]]; then
          echo "Unexpected version: $VERSION"
          exit 1
        else
          echo "Building version: $VERSION"
          npm version "$VERSION" --no-git-tag-version
          npm run build
          npm test
          cd lib/loader
          npm version "$VERSION" --no-git-tag-version
          npm run build
          npm test
          cd ../rtrace
          npm version "$VERSION" --no-git-tag-version
          npm run build
          npm test
          cd ../..
        fi
    - name: Publish packages
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
      run: |
        if [ $(node -pe "require('./package.json').version") != "0.0.0" ]; then
          npx aspublish
        fi
        cd lib/loader
        if [ $(node -pe "require('./package.json').version") != "0.0.0" ]; then
          npm publish --access public
        fi
        cd ../rtrace
        if [ $(node -pe "require('./package.json').version") != "0.0.0" ]; then
          npm publish --access public
        fi
        cd ../..

'''
'''--- .github/workflows/stale.yml ---
name: Stale
on:
  schedule:
  - cron: '30 23 * * *'
jobs:
  stale:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/stale@v3
      with:
        stale-issue-message: 'This issue has been automatically marked as stale because it has not had recent activity. It will be closed in one week if no further activity occurs. Thank you for your contributions!'
        stale-issue-label: 'stale'
        exempt-issue-labels: 'bug,enhancement,compatibility'
        exempt-all-milestones: true
        exempt-all-assignees: true
        days-before-stale: 30
        days-before-close: 7
        days-before-pr-stale: -1
        days-before-pr-close: -1

'''
'''--- .github/workflows/test.yml ---
name: Test
on:
  push:
    branches:
    - main
  pull_request:
jobs:
  check:
    name: "Check"
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v1.0.0
    - name: "Check that distribution files are unmodified"
      if: github.event_name == 'pull_request'
      run: |
        if git --no-pager diff --name-only $(git rev-parse origin/${{ github.base_ref }})...${{ github.sha }} | grep -q "^dist/"; then
          printf "\nThe pull request modifies distribution files, but it shouldn't.\n" &&
          printf "Please see https://github.com/AssemblyScript/assemblyscript/blob/main/CONTRIBUTING.md\n" &&
          exit 1;
        else
          printf "\nOK: Distributions files have not been modified.\n";
        fi
  test:
    name: "Compiler (Linux, node ${{ matrix.node_version }})"
    runs-on: ubuntu-latest
    needs: check
    strategy:
      matrix:
        node_version: ["current", "lts_latest"]
    steps:
    - uses: actions/checkout@v1.0.0
    - uses: dcodeIO/setup-node-nvm@master
      with:
        node-version: ${{ matrix.node_version }}
    - name: Install dependencies
      run: npm ci --no-audit
    - name: Clean distribution files
      run: npm run clean
    - name: Check sources
      run: npm run check
    - name: Test sources
      run: npm test
    - name: Build distribution files
      run: npm run build
    - name: Test distribution
      run: npm test
    - name: Test browser build
      run: node tests/browser-asc
  test-windows:
    name: "Compiler (Windows, node current)"
    runs-on: windows-latest
    needs: check
    steps:
    - uses: actions/checkout@v1.0.0
    - uses: dcodeIO/setup-node-nvm@master
      with:
        node-version: current
    - name: Install dependencies
      run: npm ci --no-audit
    - name: Clean distribution files
      run: npm run clean
    - name: Test sources
      run: npm test
    - name: Build distribution files
      run: npm run build
    - name: Test distribution
      run: npm test
    - name: Test browser build
      run: node tests/browser-asc
  test-macos:
    name: "Compiler (MacOS, node current)"
    runs-on: macos-latest
    needs: check
    steps:
    - uses: actions/checkout@v1.0.0
    - uses: dcodeIO/setup-node-nvm@master
      with:
        node-version: current
    - name: Install dependencies
      run: npm ci --no-audit
    - name: Clean distribution files
      run: npm run clean
    - name: Test sources
      run: npm test
    - name: Build distribution files
      run: npm run build
    - name: Test distribution
      run: npm test
    - name: Test browser build
      run: node tests/browser-asc
  test-bootstrap:
    name: "Compiler (Bootstrap)"
    runs-on: ubuntu-latest
    needs: check
    steps:
    - uses: actions/checkout@v1.0.0
    - uses: dcodeIO/setup-node-nvm@master
      with:
        node-version: current
    - name: Install dependencies
      run: npm ci --no-audit
    - name: Clean distribution files
      run: npm run clean
    - name: Bootstrap the compiler
      run: npm run bootstrap
    - name: Run compiler tests (untouched-bootstrap)
      run: npm run test:compiler -- --wasm out/assemblyscript.untouched-bootstrap.wasm
    - name: Run compiler tests (optimized-bootstrap)
      run: npm run test:compiler -- --wasm out/assemblyscript.optimized-bootstrap.wasm
  test-features:
    name: "Features"
    runs-on: ubuntu-latest
    needs: check
    steps:
    - uses: actions/checkout@v1.0.0
    - uses: dcodeIO/setup-node-nvm@master
      with:
        node-mirror: https://nodejs.org/download/v8-canary/
        node-version: 17
    - name: Install dependencies
      run: npm ci --no-audit
    - name: Clean distribution files
      run: npm run clean
    - name: Test experimental features
      env:
        ASC_FEATURES: mutable-globals,threads,reference-types,bigint-integration,gc
      run: |
        npm run test:compiler rt/flags features/js-bigint-integration features/reference-types features/threads std-wasi/process std-wasi/crypto
  test-runtimes:
    name: "Runtimes"
    runs-on: ubuntu-latest
    needs: check
    steps:
    - uses: actions/checkout@v1.0.0
    - uses: dcodeIO/setup-node-nvm@master
      with:
        node-version: current
    - name: Install dependencies
      run: npm ci --no-audit
    - name: Clean distribution files
      run: npm run clean
    - name: Test default allocator
      run: |
        cd tests/allocators/default
        npm run build
        cd ..
        npm test default
    - name: Test stub allocator
      run: |
        cd tests/allocators/stub
        npm run build
        cd ..
        npm test stub
  test-loader:
    name: "Loader"
    runs-on: ubuntu-latest
    needs: check
    steps:
    - uses: actions/checkout@v1.0.0
    - uses: dcodeIO/setup-node-nvm@master
      with:
        node-version: current
    - name: Install dependencies
      run: npm ci --no-audit
    - name: Clean distribution files
      run: npm run clean
    - name: Test the loader
      run: |
        cd lib/loader
        npm run asbuild
        npm run test

'''
'''--- CODE_OF_CONDUCT.md ---
# Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at [https://contributor-covenant.org/version/1/4][version]

[homepage]: https://contributor-covenant.org
[version]: https://contributor-covenant.org/version/1/4/

'''
'''--- CONTRIBUTING.md ---
Contributing
============

The following is a set of guidelines for contributing to AssemblyScript and its packages, which are hosted in the [AsssemblyScript Organization](https://github.com/AssemblyScript) on GitHub. These are mostly guidelines, not rules. Use your best judgement, and feel free to propose changes to this document in a pull request.

Code of Conduct
---------------

This project and everyone participating in it is governed by the [AssemblyScript Code of Conduct](CODE_OF_CONDUCT.md). By participating, you are expected to uphold this code.

Filing Issues
-------------

Bugs and enhancement suggestions are tracked as GitHub issues.

#### How Do I Submit A (Good) Bug Report?

After you've determined which repository your bug is related to and that the issue is still present in the latest version of the main branch, create an issue on that repository and provide the following information:

* Use a **clear and descriptive title** for the issue to identify the problem.
* Explain which **behavior you expected** to see instead and why.
* Describe the exact **steps to reproduce the problem** in as many details as necessary.
* When providing code samples, please use [code blocks](https://help.github.com/articles/creating-and-highlighting-code-blocks/).

#### How Do I Submit A (Good) Enhancement Suggestion?

Instructions are similar to those for bug reports. Please provide the following information:

* Use a **clear and descriptive title** for the issue to identify the suggestion.
* Provide a **description of the suggested enhancement** in as many details as necessary.
* When providing code samples, please use [code blocks](https://help.github.com/articles/creating-and-highlighting-code-blocks/).

Submitting Pull Requests
------------------------

Instructions are similar to those for bug reports. Please provide the following information:

* If this is not a trivial fix, consider **creating an issue to discuss first** and **later link to it from the PR**.
* Use a **clear and descriptive title** for the pull request.
* Provide a **description of the changes** in as many details as necessary.
* **Document your new code** where necessary.
* Please **refrain from refactoring (unrelated code)** as it makes your pull request easier to review.
* **Create tests for your new code** where necessary. For creating or updating tests, please see the [Test Instructions](./tests).

Before submitting your pull request, also make sure that the following conditions are met:

* Your new code **adheres to the code style** through running `npm run check`.
* Your new code **passes all existing and new tests** through running `npm run test`.
* Your PR **excludes distribution files** in `dist/**`.
* You appended yourself to the **list of contributors** in the [NOTICE](./NOTICE) file.

Please note that if a pull request is rather complicated, i.e. touches lots of internals, or became stale, it is not uncommon that a core contributor performs the final integration to get it done in good conscience while naming you as a co-author.

Thank you!

'''
'''--- README.md ---
<p align="center">
  <a href="https://assemblyscript.org" target="_blank" rel="noopener"><img width="100" src="https://avatars1.githubusercontent.com/u/28916798?s=200&v=4" alt="AssemblyScript logo"></a>
</p>

<p align="center">
  <a href="https://github.com/AssemblyScript/assemblyscript/actions?query=workflow%3ATest"><img src="https://img.shields.io/github/workflow/status/AssemblyScript/assemblyscript/Test/main?label=test&logo=github" alt="Test status" /></a>
  <a href="https://github.com/AssemblyScript/assemblyscript/actions?query=workflow%3APublish"><img src="https://img.shields.io/github/workflow/status/AssemblyScript/assemblyscript/Publish/main?label=publish&logo=github" alt="Publish status" /></a>
  <a href="https://www.npmjs.com/package/assemblyscript"><img src="https://img.shields.io/npm/v/assemblyscript.svg?label=compiler&color=007acc&logo=npm" alt="npm compiler version" /></a>
  <a href="https://www.npmjs.com/package/@assemblyscript/loader"><img src="https://img.shields.io/npm/v/@assemblyscript/loader.svg?label=loader&color=007acc&logo=npm" alt="npm loader version" /></a>
  <a href="https://discord.gg/assemblyscript"><img src="https://img.shields.io/discord/721472913886281818.svg?label=&logo=discord&logoColor=ffffff&color=7389D8&labelColor=6A7EC2" alt="Discord online" /></a>
</p>

<p align="justify"><strong>AssemblyScript</strong> compiles a variant of <a href="http://www.typescriptlang.org">TypeScript</a> (basically JavaScript with types) to <a href="http://webassembly.org">WebAssembly</a> using <a href="https://github.com/WebAssembly/binaryen">Binaryen</a>. It generates lean and mean WebAssembly modules while being just an <code>npm install</code> away.</p>

<h3 align="center">
  <a href="https://assemblyscript.org">About</a> &nbsp;Â·&nbsp;
  <a href="https://assemblyscript.org/introduction.html">Introduction</a> &nbsp;Â·&nbsp;
  <a href="https://assemblyscript.org/quick-start.html">Quick&nbsp;start</a> &nbsp;Â·&nbsp;
  <a href="https://assemblyscript.org/examples.html">Examples</a> &nbsp;Â·&nbsp;
  <a href="https://assemblyscript.org/development.html">Development&nbsp;instructions</a>
</h3>
<br>

<h2 align="center">Contributors</h2>

<p align="center">
  <a href="https://assemblyscript.org/#contributors"><img src="https://assemblyscript.org/contributors.svg" alt="Contributor logos" width="720" /></a>
</p>

<h2 align="center">Thanks to our sponsors!</h2>

<p align="justify">Most of the core team members and most contributors do this open source work in their free time. If you use AssemblyScript for a serious task or plan to do so, and you'd like us to invest more time on it, <a href="https://opencollective.com/assemblyscript/donate" target="_blank" rel="noopener">please donate</a> to our <a href="https://opencollective.com/assemblyscript" target="_blank" rel="noopener">OpenCollective</a>. By sponsoring this project, your logo will show up below. Thank you so much for your support!</p>

<p align="center">
  <a href="https://assemblyscript.org/#sponsors"><img src="https://assemblyscript.org/sponsors.svg" alt="Sponsor logos" width="720" /></a>
</p>

'''
'''--- cli/README.md ---
Compiler frontend for node.js
=============================

Usage
-----

For an up to date list of available command line options, see:

```
$> asc --help
```

API
---

The API accepts the same options as the CLI but also lets you override stdout and stderr and/or provide a callback. Example:

```js
const asc = require("assemblyscript/cli/asc");
asc.ready.then(() => {
  asc.main([
    "myModule.ts",
    "--binaryFile", "myModule.wasm",
    "--optimize",
    "--sourceMap",
    "--measure"
  ], {
    stdout: process.stdout,
    stderr: process.stderr
  }, function(err) {
    if (err)
      throw err;
    ...
  });
});
```

Available command line options can also be obtained programmatically:

```js
const options = require("assemblyscript/cli/asc.json");
...
```

You can also compile a source string directly, for example in a browser environment:

```js
const asc = require("assemblyscript/cli/asc");
asc.ready.then(() => {
  const { binary, text, stdout, stderr } = asc.compileString(`...`, { optimize: 2 });
});
...
```

'''
'''--- cli/asc.d.ts ---
/**
 * @fileoverview Definitions for asc.
 * @license Apache-2.0
 */

import { OptionDescription } from "./util/options";
export { OptionDescription };
import { Transform } from "./transform";

/** Ready promise resolved once/if the compiler is ready. */
export const ready: Promise<void>;

/** Whether this is a webpack bundle or not. */
export const isBundle: boolean;

/** Whether asc runs the sources directly or not. */
export const isDev: boolean;

/** AssemblyScript version. */
export const version: string;

/** Available CLI options. */
export const options: { [key: string]: OptionDescription };

/** Common root used in source maps. */
export var sourceMapRoot: string;

/** Prefix used for library files. */
export var libraryPrefix: string;

/** Default Binaryen optimization level. */
export var defaultOptimizeLevel: number;

/** Default Binaryen shrink level. */
export var defaultShrinkLevel: number;

/** Bundled library files. */
export const libraryFiles: { [key: string]: string };

/** Bundled definition files. */
export const definitionFiles: { assembly: string, portable: string };

/** A compatible output stream. */
export interface OutputStream {
  /** Writes another chunk of data to the stream. */
  write(chunk: Uint8Array | string): void;
}

/** An in-memory output stream. */
export interface MemoryStream extends OutputStream {
  /** Resets the stream to offset zero. */
  reset(): void;
  /** Converts the output to a buffer. */
  toBuffer(): Uint8Array;
  /** Converts the output to a string. */
  toString(): string;
}

/** Relevant subset of the Source class for diagnostic reporting. */
export interface Source {
  /** Normalized path with file extension. */
  normalizedPath: string;
}

/** Relevant subset of the Range class for diagnostic reporting. */
export interface Range {
  /** Start offset within the source file. */
  start: number;
  /** End offset within the source file. */
  end: number;
  /** Respective source file. */
  source: Source;
}

/** Relevant subset of the DiagnosticMessage class for diagnostic reporting. */
export interface DiagnosticMessage {
  /** Message code. */
  code: number;
  /** Message category. */
  category: number;
  /** Message text. */
  message: string;
  /** Respective source range, if any. */
  range: Range | null;
  /** Related range, if any. */
  relatedRange: Range | null;
}

/** A function handling diagnostic messages. */
type DiagnosticReporter = (diagnostic: DiagnosticMessage) => void;

/** Compiler options. */
export interface CompilerOptions {
  /** Prints just the compiler's version and exits. */
  version?: boolean;
  /** Prints the help message and exits. */
  help?: boolean;
  /** Optimizes the module. */
  optimize?: boolean;
  /** How much to focus on optimizing code. */
  optimizeLevel?: number;
  /** How much to focus on shrinking code size. */
  shrinkLevel?: number;
  /** Re-optimizes until no further improvements can be made. */
  converge?: boolean;
  /** Specifies the base directory of input and output files. */
  baseDir?: string;
  /** Specifies the output file. File extension indicates format. */
  outFile?: string;
  /** Specifies the binary output file (.wasm). */
  binaryFile?: string;
  /** Specifies the text output file (.wat). */
  textFile?: string;
  /** Specifies the JavaScript (via wasm2js) output file (.js). */
  jsFile?: string;
  /** Specifies the WebIDL output file (.webidl). */
  idlFile?: string;
  /** Specifies the TypeScript definition output file (.d.ts). */
  tsdFile?: string;
  /** Enables source map generation. Optionally takes the URL. */
  sourceMap?: boolean | string;
  /** Specifies the runtime variant to include in the program. */
  runtime?: string;
  /** Disallows the use of unsafe features in user code. */
  noUnsafe?: boolean;
  /** Enables debug information in emitted binaries. */
  debug?: boolean;
  /** Replaces assertions with just their value without trapping. */
  noAssert?: boolean;
  /** Performs compilation as usual but does not emit code. */
  noEmit?: boolean;
  /** Imports the memory provided as 'env.memory'. */
  importMemory?: boolean;
  /** Does not export the memory as 'memory'. */
  noExportMemory?: boolean;
  /** Sets the initial memory size in pages. */
  initialMemory?: number;
  /** Sets the maximum memory size in pages. */
  maximumMemory?: number;
  /** Declare memory as shared. Requires maximumMemory. */
  sharedMemory?: boolean;
  /** Sets the start offset of compiler-generated static memory. */
  memoryBase?: number;
  /** Imports the function table provided as 'env.table'. */
  importTable?: boolean;
  /** Exports the function table as 'table'. */
  exportTable?: boolean;
  /** Exports an explicit start function to be called manually. */
  explicitStart?: boolean;
  /** "Adds one or multiple paths to custom library components. */
  lib?: string | string[];
  /** Adds one or multiple paths to package resolution. */
  path?: string | string[];
  /** Aliases a global object under another name. */
  use?: string | string[];
  /** Sets the trap mode to use. */
  trapMode?: "allow" | "clamp" | "js";
  /** Specifies additional Binaryen passes to run. */
  runPasses?: string | string[];
  /** Skips validating the module using Binaryen. */
  noValidate?: boolean;
  /** Enables WebAssembly features that are disabled by default. */
  enable?: string | string[];
  /** Disables WebAssembly features that are enabled by default. */
  disable?: string | string[];
  /** Specifies the path to a custom transform to 'require'. */
  transform?: string | string[];
  /** Make yourself sad for no good reason. */
  pedantic?: boolean;
  /** Enables tracing of package resolution. */
  traceResolution?: boolean;
  /** Lists files to be compiled and exits. */
  listFiles?: boolean;
  /** Prints measuring information on I/O and compile times. */
  measure?: boolean;
  /** Disables terminal colors. */
  noColors?: boolean;
  /** Specifies an alternative file extension. */
  extension?: string;
}

/** Compiler API options. */
export interface APIOptions {
  /** Standard output stream to use. */
  stdout?: OutputStream;
  /** Standard error stream to use. */
  stderr?: OutputStream;
  /** Reads a file from disk (or memory). */
  readFile?: (filename: string, baseDir: string) => string | null;
  /** Writes a file to disk (or memory). */
  writeFile?: (filename: string, contents: Uint8Array, baseDir: string) => void;
  /** Lists all files within a directory. */
  listFiles?: (dirname: string, baseDir: string) => string[] | null;
  /** Handler for diagnostic messages. */
  reportDiagnostic?: DiagnosticReporter;
  /** Additional transforms to apply. */
  transforms?: Transform[];
}

/** Convenience function that parses and compiles source strings directly. */
export function compileString(sources: { [key: string]: string } | string, options?: CompilerOptions): {
  /** Standard output. */
  stdout: OutputStream,
  /** Standard error. */
  stderr: OutputStream,
  /** Emitted binary. */
  binary: Uint8Array | null,
  /** Emitted text format. */
  text: string | null
}

/** Runs the command line utility using the specified arguments array. */
export function main(argv: string[], options: APIOptions, callback?: (err: Error | null) => number): number;
export function main(argv: string[], callback?: (err: Error | null) => number): number;

/** Checks diagnostics emitted so far for errors. */
export function checkDiagnostics(emitter: Record<string,unknown>, stderr?: OutputStream, reportDiagnostic?: DiagnosticReporter): boolean;

/** An object of stats for the current task. */
export interface Stats {
  readTime: number,
  readCount: number,
  writeTime: number,
  writeCount: number,
  parseTime: number,
  parseCount: number,
  compileTime: number,
  compileCount: number,
  emitTime: number,
  emitCount: number,
  validateTime: number,
  validateCount: number,
  optimizeTime: number,
  optimizeCount: number
}

/** Creates an empty set of stats. */
export function createStats(): Stats;

/** Measures the execution time of the specified function.  */
export function measure(fn: () => void): number;

/** Formats a high resolution time to a human readable string. */
export function formatTime(time: number): string;

/** Formats and prints out the contents of a set of stats. */
export function printStats(stats: Stats, output: OutputStream): void;

/** Creates a memory stream that can be used in place of stdout/stderr. */
export function createMemoryStream(fn?: (chunk: Uint8Array | string) => void): MemoryStream;

/** Compatible TypeScript compiler options for syntax highlighting etc. */
export const tscOptions: Record<string,unknown>;

'''
'''--- cli/asc.js ---
/**
 * @license
 * Copyright 2020 Daniel Wirtz / The AssemblyScript Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview Compiler frontend for node.js
 *
 * Uses the low-level API exported from src/index.ts so it works with the compiler compiled to
 * JavaScript as well as the compiler compiled to WebAssembly (eventually). Runs the sources
 * directly through ts-node if distribution files are not present.
 *
 * Can also be packaged as a bundle suitable for in-browser use with the standard library injected
 * in the build step. See dist/asc.js for the bundle and webpack.config.js for building details.
 */

/* global BUNDLE_VERSION, BUNDLE_LIBRARY, BUNDLE_DEFINITIONS */

const fs = require("fs");
const path = require("path");
const process = require("process"); // ensure shim
const utf8 = require("./util/utf8");
const colorsUtil = require("./util/colors");
const optionsUtil = require("./util/options");
const mkdirp = require("./util/mkdirp");
const find = require("./util/find");
const binaryen = global.binaryen || (global.binaryen = require("binaryen"));

const dynrequire = typeof __webpack_require__ === "function"
  ? __non_webpack_require__
  : require;

const WIN = process.platform === "win32";
const EOL = WIN ? "\r\n" : "\n";
const SEP = WIN ? "\\"   : "/";

function toUpperSnakeCase(str) {
  return str.replace(/-/g, "_").toUpperCase();
}

// Sets up an extension with its definition counterpart and relevant regexes.
function setupExtension(ext) {
  if (!ext.startsWith(".")) ext = `.${ext}`;
  return {
    ext,
    ext_d: `.d${ext}`,
    re: new RegExp("\\" + ext + "$"),
    re_d: new RegExp("\\.d\\" + ext + "$"),
    re_except_d: new RegExp("^(?!.*\\.d\\" + ext + "$).*\\" + ext + "$"),
    re_index: new RegExp("(?:^|[\\\\\\/])index\\" + ext + "$")
  };
}

const defaultExtension = setupExtension(".ts");

// Proxy Binaryen's ready event
Object.defineProperty(exports, "ready", {
  get() { return binaryen.ready; }
});

// Emscripten adds an `uncaughtException` listener to Binaryen that results in an additional
// useless code fragment on top of an actual error. suppress this:
if (process.removeAllListeners) {
  process.removeAllListeners("uncaughtException");
}

// Use distribution files if present, otherwise run the sources directly.
function loadAssemblyScriptJS() {
  var exports;
  try {
    // note that this case will always trigger in recent node.js versions for typical installs
    // see: https://nodejs.org/api/packages.html#packages_self_referencing_a_package_using_its_name
    exports = require("assemblyscript");
  } catch (e) {
    try { // `asc` on the command line (unnecessary in recent node)
      exports = dynrequire("../dist/assemblyscript.js");
    } catch (e) {
      try { // `asc` on the command line without dist files (unnecessary in recent node)
        dynrequire("ts-node").register({
          project: path.join(__dirname, "..", "src", "tsconfig.json"),
          skipIgnore: true,
          compilerOptions: { target: "ES2016" }
        });
        dynrequire("../src/glue/js");
        exports = dynrequire("../src");
      } catch (e_ts) {
        try { // `require("dist/asc.js")` in explicit browser tests
          exports = dynrequire("./assemblyscript");
        } catch (e) {
          throw Error(`${e_ts.stack}\n---\n${e.stack}`);
        }
      }
    }
  }
  return exports;
}

// Loads the specified bootstrapped Wasm binary of the compiler.
function loadAssemblyScriptWasm(binaryPath) {
  const loader = require("../lib/loader/umd/index");
  const rtrace = new (require("../lib/rtrace/umd/index").Rtrace)({
    onerror(err, info) {
      console.log(err, info);
    },
    getMemory() {
      return exports.memory;
    },
    oncollect() {
      var gcProfile = rtrace.gcProfile;
      if (gcProfile && gcProfile.length && fs.writeFileSync) {
        let timestamp = Date.now();
        fs.writeFileSync(
          `rtrace-gc-profile-${timestamp}.json`,
          JSON.stringify(gcProfile)
        );
        fs.writeFileSync(
          `rtrace-gc-profile-${timestamp}.csv`,
          `time,memory,pause\n${gcProfile.join("\n")}`
        );
      }
    }
  });
  var { exports } = loader.instantiateSync(fs.readFileSync(binaryPath), rtrace.install({ binaryen }));
  if (exports._start) exports._start();
  return exports;
}

/** Ensures that an object is a wrapper class instead of just a pointer. */
function __wrap(ptrOrObj, wrapperClass) {
  if (typeof ptrOrObj === "number") {
    return ptrOrObj === 0 ? null : wrapperClass.wrap(ptrOrObj);
  }
  return ptrOrObj;
}

var assemblyscript, __newString, __getString, __pin, __unpin, __collect;

function loadAssemblyScript() {
  const wasmArg = process.argv.findIndex(arg => arg == "--wasm");
  if (~wasmArg) {
    let binaryPath = process.argv[wasmArg + 1];
    process.argv.splice(wasmArg, 2);
    assemblyscript = loadAssemblyScriptWasm(binaryPath);
    __newString = assemblyscript.__newString;
    __getString = assemblyscript.__getString;
    __pin = assemblyscript.__pin;
    __unpin = assemblyscript.__unpin;
    __collect = assemblyscript.__collect;
  } else {
    assemblyscript = loadAssemblyScriptJS();
    __newString = str => str;
    __getString = ptr => ptr;
    __pin = ptr => ptr;
    __unpin = _ => undefined;
    __collect = _ => undefined;
  }
}
loadAssemblyScript();

/** Whether this is a webpack bundle or not. */
exports.isBundle = typeof BUNDLE_VERSION === "string";

/** AssemblyScript version. */
exports.version = exports.isBundle ? BUNDLE_VERSION : dynrequire("../package.json").version;

/** Available CLI options. */
exports.options = require("./asc.json");

/** Prefix used for library files. */
exports.libraryPrefix = __getString(assemblyscript.LIBRARY_PREFIX.valueOf());

/** Default Binaryen optimization level. */
exports.defaultOptimizeLevel = 3;

/** Default Binaryen shrink level. */
exports.defaultShrinkLevel = 0;

/** Bundled library files. */
exports.libraryFiles = exports.isBundle ? BUNDLE_LIBRARY : (() => { // set up if not a bundle
  const libDir = path.join(__dirname, "..", "std", "assembly");
  const bundled = {};
  find
    .files(libDir, defaultExtension.re_except_d)
    .forEach(file => {
      bundled[file.replace(defaultExtension.re, "")] = fs.readFileSync(path.join(libDir, file), "utf8");
    });
  return bundled;
})();

/** Bundled definition files. */
exports.definitionFiles = exports.isBundle ? BUNDLE_DEFINITIONS : (() => { // set up if not a bundle
  const readDefinition = name => fs.readFileSync(
    path.join(__dirname, "..", "std", name, `index${defaultExtension.ext_d}`),
    "utf8"
  );
  return {
    assembly: readDefinition("assembly"),
    portable: readDefinition("portable")
  };
})();

/** Convenience function that parses and compiles source strings directly. */
exports.compileString = (sources, options) => {
  if (typeof sources === "string") sources = { [`input${defaultExtension.ext}`]: sources };
  const output = Object.create({
    stdout: createMemoryStream(),
    stderr: createMemoryStream()
  });
  var argv = [
    "--binaryFile", "binary",
    "--textFile", "text",
  ];
  Object.keys(options || {}).forEach(key => {
    var val = options[key];
    var opt = exports.options[key];
    if (opt && opt.type === "b") {
      if (val) argv.push(`--${key}`);
    } else {
      if (Array.isArray(val)) {
        val.forEach(val => { argv.push(`--${key}`, String(val)); });
      }
      else argv.push(`--${key}`, String(val));
    }
  });
  exports.main(argv.concat(Object.keys(sources)), {
    stdout: output.stdout,
    stderr: output.stderr,
    readFile: name => Object.prototype.hasOwnProperty.call(sources, name) ? sources[name] : null,
    writeFile: (name, contents) => { output[name] = contents; },
    listFiles: () => []
  });
  return output;
};

/** Runs the command line utility using the specified arguments array. */
exports.main = function main(argv, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = {};
  } else if (!options) {
    options = {};
  }

  // Bundle semantic version
  let bundleMinorVersion = 0, bundleMajorVersion = 0, bundlePatchVersion = 0;
  const versionParts = (exports.version || "").split(".");
  if (versionParts.length === 3) {
    bundleMajorVersion = parseInt(versionParts[0]) | 0;
    bundleMinorVersion = parseInt(versionParts[1]) | 0;
    bundlePatchVersion = parseInt(versionParts[2]) | 0;
  }

  const stdout = options.stdout || process.stdout;
  const stderr = options.stderr || process.stderr;
  const readFile = options.readFile || readFileNode;
  const writeFile = options.writeFile || writeFileNode;
  const listFiles = options.listFiles || listFilesNode;
  const stats = options.stats || createStats();
  let extension = defaultExtension;

  // Output must be specified if not present in the environment
  if (!stdout) throw Error("'options.stdout' must be specified");
  if (!stderr) throw Error("'options.stderr' must be specified");

  // Parse command line options but do not populate option defaults yet
  const optionsResult = optionsUtil.parse(argv, exports.options, false);
  let opts = optionsResult.options;
  argv = optionsResult.arguments;

  if (opts.noColors) {
    colorsUtil.stdout.supported =
    colorsUtil.stderr.supported = false;
  } else {
    colorsUtil.stdout = colorsUtil.from(stdout);
    colorsUtil.stderr = colorsUtil.from(stderr);
  }

  // Check for unknown options
  const unknownOpts = optionsResult.unknown;
  if (unknownOpts.length) {
    unknownOpts.forEach(arg => {
      stderr.write(
        `${colorsUtil.stderr.yellow("WARNING ")}Unknown option '${arg}'%{EOL}`
      );
    });
  }

  // Check for trailing arguments
  const trailingArgv = optionsResult.trailing;
  if (trailingArgv.length) {
    stderr.write(
      `${colorsUtil.stderr.yellow("WARNING ")}Unsupported trailing arguments: ${trailingArgv.join(" ")}${EOL}`
    );
  }

  // Use default callback if none is provided
  if (!callback) callback = function defaultCallback(err) {
    var code = 0;
    if (err) {
      stderr.write(`${colorsUtil.stderr.red("FAILURE ")}${err.stack.replace(/^ERROR: /i, "")}${EOL}`);
      code = 1;
    }
    return code;
  };

  // Just print the version if requested
  if (opts.version) {
    stdout.write(`Version ${exports.version}${EOL}`);
    return callback(null);
  }

  // Use another extension if requested
  if (typeof opts.extension === "string") {
    if (/^\.?[0-9a-zA-Z]{1,14}$/.test(opts.extension)) {
      extension = setupExtension(opts.extension);
    } else {
      return callback(Error(`Invalid extension: ${opts.extension}`));
    }
  }

  // Set up base directory
  const baseDir = path.normalize(opts.baseDir || ".");

  // Check if a config file is present
  let asconfigPath = optionsUtil.resolvePath(opts.config || "asconfig.json", baseDir);
  let asconfigFile = path.basename(asconfigPath);
  let asconfigDir = path.dirname(asconfigPath);
  let asconfig = getAsconfig(asconfigFile, asconfigDir, readFile);
  let asconfigHasEntries = asconfig != null && Array.isArray(asconfig.entries) && asconfig.entries.length;

  // Print the help message if requested or no source files are provided
  if (opts.help || (!argv.length && !asconfigHasEntries)) {
    var out = opts.help ? stdout : stderr;
    var color = opts.help ? colorsUtil.stdout : colorsUtil.stderr;
    out.write([
      color.white("SYNTAX"),
      "  " + color.cyan("asc") + " [entryFile ...] [options]",
      "",
      color.white("EXAMPLES"),
      "  " + color.cyan("asc") + " hello" + extension.ext,
      "  " + color.cyan("asc") + " hello" + extension.ext + " -b hello.wasm -t hello.wat",
      "  " + color.cyan("asc") + " hello1" + extension.ext + " hello2" + extension.ext + " -b -O > hello.wasm",
      "  " + color.cyan("asc") + " --config asconfig.json --target release",
      "",
      color.white("OPTIONS"),
    ].concat(
      optionsUtil.help(exports.options, 24, EOL)
    ).join(EOL) + EOL);
    return callback(null);
  }

  // I/O must be specified if not present in the environment
  if (!fs.readFileSync) {
    if (readFile === readFileNode)   throw Error("'options.readFile' must be specified");
    if (writeFile === writeFileNode) throw Error("'options.writeFile' must be specified");
    if (listFiles === listFilesNode) throw Error("'options.listFiles' must be specified");
  }

  // Load additional options from asconfig.json
  const seenAsconfig = new Set();
  seenAsconfig.add(asconfigPath);
  const target = opts.target || "release";
  while (asconfig) {
    // Merge target first
    if (asconfig.targets) {
      const targetOptions = asconfig.targets[target];
      if (targetOptions) {
        opts = optionsUtil.merge(exports.options, opts, targetOptions, asconfigDir);
      }
    }
    // Merge general options
    const generalOptions = asconfig.options;
    if (generalOptions) {
      opts = optionsUtil.merge(exports.options, opts, generalOptions, asconfigDir);
    }

    // Append entries
    if (asconfig.entries) {
      for (let entry of asconfig.entries) {
        argv.push(optionsUtil.resolvePath(entry, asconfigDir));
      }
    }

    // Look up extended asconfig and repeat
    if (asconfig.extends) {
      asconfigPath = optionsUtil.resolvePath(asconfig.extends, asconfigDir, true);
      asconfigFile = path.basename(asconfigPath);
      asconfigDir = path.dirname(asconfigPath);
      if (seenAsconfig.has(asconfigPath)) break;
      seenAsconfig.add(asconfigPath);
      asconfig = getAsconfig(asconfigFile, asconfigDir, readFile);
    } else {
      break;
    }
  }

  // Populate option defaults once user-defined options are set
  optionsUtil.addDefaults(exports.options, opts);

  // If showConfig print options and exit
  if (opts.showConfig) {
    stderr.write(JSON.stringify({
      options: opts,
      entries: argv
    }, null, 2));
    return callback(null);
  }

  // create a unique set of values
  function unique(values) {
    return [...new Set(values)];
  }

  // Set up options
  var program;
  const compilerOptions = __pin(assemblyscript.newOptions());
  assemblyscript.setTarget(compilerOptions, 0);
  assemblyscript.setNoAssert(compilerOptions, opts.noAssert);
  assemblyscript.setExportMemory(compilerOptions, !opts.noExportMemory);
  assemblyscript.setImportMemory(compilerOptions, opts.importMemory);
  assemblyscript.setInitialMemory(compilerOptions, opts.initialMemory >>> 0);
  assemblyscript.setMaximumMemory(compilerOptions, opts.maximumMemory >>> 0);
  assemblyscript.setSharedMemory(compilerOptions, opts.sharedMemory);
  assemblyscript.setImportTable(compilerOptions, opts.importTable);
  assemblyscript.setExportTable(compilerOptions, opts.exportTable);
  assemblyscript.setExplicitStart(compilerOptions, opts.explicitStart);
  assemblyscript.setMemoryBase(compilerOptions, opts.memoryBase >>> 0);
  assemblyscript.setTableBase(compilerOptions, opts.tableBase >>> 0);
  assemblyscript.setSourceMap(compilerOptions, opts.sourceMap != null);
  assemblyscript.setNoUnsafe(compilerOptions, opts.noUnsafe);
  assemblyscript.setPedantic(compilerOptions, opts.pedantic);
  assemblyscript.setLowMemoryLimit(compilerOptions, opts.lowMemoryLimit >>> 0);
  assemblyscript.setExportRuntime(compilerOptions, opts.exportRuntime);
  assemblyscript.setBundleVersion(compilerOptions, bundleMajorVersion, bundleMinorVersion, bundlePatchVersion);
  if (!opts.stackSize && opts.runtime == "incremental") {
    opts.stackSize = assemblyscript.DEFAULT_STACK_SIZE;
  }
  assemblyscript.setStackSize(compilerOptions, opts.stackSize);

  // Instrument callback to perform GC
  callback = (function(callback) {
    return function wrappedCallback(err) {
      __unpin(compilerOptions);
      if (program) __unpin(program);
      __collect();
      return callback(err);
    };
  })(callback);

  // Add or override aliases if specified
  if (opts.use) {
    let aliases = opts.use;
    for (let i = 0, k = aliases.length; i < k; ++i) {
      let part = aliases[i];
      let p = part.indexOf("=");
      if (p < 0) return callback(Error(`Global alias '${part}' is invalid.`));
      let alias = part.substring(0, p).trim();
      let name = part.substring(p + 1).trim();
      if (!alias.length) {
        return callback(Error(`Global alias '${part}' is invalid.`));
      }
      {
        let aliasPtr = __pin(__newString(alias));
        let namePtr = __newString(name);
        assemblyscript.setGlobalAlias(compilerOptions, aliasPtr, namePtr);
        __unpin(aliasPtr);
      }
    }
  }

  // Disable default features if specified
  var features;
  if ((features = opts.disable) != null) {
    if (typeof features === "string") features = features.split(",");
    for (let i = 0, k = features.length; i < k; ++i) {
      let name = features[i].trim();
      let flag = assemblyscript[`FEATURE_${toUpperSnakeCase(name)}`];
      if (!flag) return callback(Error(`Feature '${name}' is unknown.`));
      assemblyscript.disableFeature(compilerOptions, flag);
    }
  }

  // Enable experimental features if specified
  if ((features = opts.enable) != null) {
    if (typeof features === "string") features = features.split(",");
    for (let i = 0, k = features.length; i < k; ++i) {
      let name = features[i].trim();
      let flag = assemblyscript[`FEATURE_${toUpperSnakeCase(name)}`];
      if (!flag) return callback(Error(`Feature '${name}' is unknown.`));
      assemblyscript.enableFeature(compilerOptions, flag);
    }
  }

  // Set up optimization levels
  var optimizeLevel = 0;
  var shrinkLevel = 0;
  if (opts.optimize) {
    optimizeLevel = exports.defaultOptimizeLevel;
    shrinkLevel = exports.defaultShrinkLevel;
  }
  if (typeof opts.optimizeLevel === "number") optimizeLevel = opts.optimizeLevel;
  if (typeof opts.shrinkLevel === "number") shrinkLevel = opts.shrinkLevel;
  optimizeLevel = Math.min(Math.max(optimizeLevel, 0), 3);
  shrinkLevel = Math.min(Math.max(shrinkLevel, 0), 2);
  assemblyscript.setOptimizeLevelHints(compilerOptions, optimizeLevel, shrinkLevel);

  // Initialize the program
  program = __pin(assemblyscript.newProgram(compilerOptions));

  // Collect transforms *constructors* from the `--transform` CLI flag as well
  // as the `transform` option into the `transforms` array.
  let transforms = [];
  // `transform` option from `main()`
  if (Array.isArray(options.transforms)) {
    transforms.push(...options.transforms);
  }
  // `--transform` CLI flag
  if (opts.transform) {
    let tsNodeRegistered = false;
    let transformArgs = unique(opts.transform);
    for (let i = 0, k = transformArgs.length; i < k; ++i) {
      let filename = transformArgs[i].trim();
      if (!tsNodeRegistered && filename.endsWith(".ts")) { // ts-node requires .ts specifically
        dynrequire("ts-node").register({
          transpileOnly: true,
          skipProject: true,
          compilerOptions: { target: "ES2016" }
        });
        tsNodeRegistered = true;
      }
      try {
        transforms.push(dynrequire(dynrequire.resolve(filename, {
          paths: [baseDir, process.cwd()]
        })));
      } catch (e) {
        return callback(e);
      }
    }
  }

  // Fix up the prototype of the transformsâ€™ constructors and instantiate them.
  try {
    transforms = transforms.map(classOrModule => {
      // Except if itâ€™s a legacy module, just pass it through.
      if (typeof classOrModule !== "function") {
        return classOrModule;
      }
      Object.assign(classOrModule.prototype, {
        program,
        baseDir,
        stdout,
        stderr,
        log: console.error,
        readFile,
        writeFile,
        listFiles
      });
      return new classOrModule();
    });
  } catch (e) {
    return callback(e);
  }

  function applyTransform(name, ...args) {
    for (let i = 0, k = transforms.length; i < k; ++i) {
      let transform = transforms[i];
      if (typeof transform[name] === "function") {
        try {
          stats.transformCount++;
          stats.transfromTime += measure(() => {
            transform[name](...args);
          });
        } catch (e) {
          return e;
        }
      }
    }
  }

  // Parse library files
  Object.keys(exports.libraryFiles).forEach(libPath => {
    if (libPath.includes("/")) return; // in sub-directory: imported on demand
    stats.parseCount++;
    stats.parseTime += measure(() => {
      let textPtr = __pin(__newString(exports.libraryFiles[libPath]));
      let pathPtr = __newString(exports.libraryPrefix + libPath + extension.ext);
      assemblyscript.parse(program, textPtr, pathPtr, false);
      __unpin(textPtr);
    });
  });
  let customLibDirs = [];
  if (opts.lib) {
    let lib = opts.lib;
    if (typeof lib === "string") lib = lib.split(",");
    customLibDirs.push(...lib.map(p => p.trim()));
    customLibDirs = unique(customLibDirs); // `lib` and `customLibDirs` may include duplicates
    for (let i = 0, k = customLibDirs.length; i < k; ++i) { // custom
      let libDir = customLibDirs[i];
      let libFiles;
      if (libDir.endsWith(extension.ext)) {
        libFiles = [ path.basename(libDir) ];
        libDir = path.dirname(libDir);
      } else {
        libFiles = listFiles(libDir, baseDir) || [];
      }
      for (let j = 0, l = libFiles.length; j < l; ++j) {
        let libPath = libFiles[j];
        let libText = readFile(libPath, libDir);
        if (libText == null) {
          return callback(Error(`Library file '${libPath}' not found.`));
        }
        stats.parseCount++;
        exports.libraryFiles[libPath.replace(extension.re, "")] = libText;
        stats.parseTime += measure(() => {
          let textPtr = __pin(__newString(libText));
          let pathPtr = __newString(exports.libraryPrefix + libPath);
          assemblyscript.parse(program, textPtr, pathPtr, false);
          __unpin(textPtr);
        });
      }
    }
  }
  opts.path = opts.path || [];

  // Maps package names to parent directory
  const packageMains = new Map();
  const packageBases = new Map();

  // Gets the file matching the specified source path, imported at the given dependee path
  function getFile(internalPath, dependeePath) {
    var sourceText = null; // text reported back to the compiler
    var sourcePath = null; // path reported back to the compiler

    const libraryPrefix = exports.libraryPrefix;
    const libraryFiles = exports.libraryFiles;

    // Try file.ext, file/index.ext, file.d.ext
    if (!internalPath.startsWith(libraryPrefix)) {
      if ((sourceText = readFile(sourcePath = internalPath + extension.ext, baseDir)) == null) {
        if ((sourceText = readFile(sourcePath = internalPath + "/index" + extension.ext, baseDir)) == null) {
          // portable d.ext: uses the .js file next to it in JS or becomes an import in Wasm
          sourcePath = internalPath + extension.ext;
          sourceText = readFile(internalPath + extension.ext_d, baseDir);
        }
      }

    // Search library in this order: stdlib, custom lib dirs, paths
    } else {
      const plainName = internalPath.substring(libraryPrefix.length);
      const indexName = `${plainName}/index`;
      if (Object.prototype.hasOwnProperty.call(libraryFiles, plainName)) {
        sourceText = libraryFiles[plainName];
        sourcePath = libraryPrefix + plainName + extension.ext;
      } else if (Object.prototype.hasOwnProperty.call(libraryFiles, indexName)) {
        sourceText = libraryFiles[indexName];
        sourcePath = libraryPrefix + indexName + extension.ext;
      } else { // custom lib dirs
        for (const libDir of customLibDirs) {
          if ((sourceText = readFile(plainName + extension.ext, libDir)) != null) {
            sourcePath = libraryPrefix + plainName + extension.ext;
            break;
          } else {
            if ((sourceText = readFile(indexName + extension.ext, libDir)) != null) {
              sourcePath = libraryPrefix + indexName + extension.ext;
              break;
            }
          }
        }
        if (sourceText == null) { // paths
          const match = internalPath.match(/^~lib\/((?:@[^/]+\/)?[^/]+)(?:\/(.+))?/); // ~lib/(pkg)/(path), ~lib/(@org/pkg)/(path)
          if (match) {
            const packageName = match[1];
            const isPackageRoot = match[2] === undefined;
            const filePath = isPackageRoot ? "index" : match[2];
            const basePath = packageBases.has(dependeePath)
              ? packageBases.get(dependeePath)
              : ".";

            if (opts.traceResolution) {
              stderr.write(`Looking for package '${packageName}' file '${filePath}' relative to '${basePath}'${EOL}`);
            }
            const paths = [];
            const parts = path.resolve(baseDir, basePath).split(SEP);
            for (let i = parts.length, k = WIN ? 1 : 0; i >= k; --i) {
              if (parts[i - 1] !== "node_modules") {
                paths.push(`${parts.slice(0, i).join(SEP)}${SEP}node_modules`);
              }
            }
            for (const currentPath of paths.concat(...opts.path).map(p => path.relative(baseDir, p))) {
              if (opts.traceResolution) {
                stderr.write(`  in ${path.join(currentPath, packageName)}${EOL}`);
              }
              let mainPath = "assembly";
              if (packageMains.has(packageName)) { // use cached
                mainPath = packageMains.get(packageName);
              } else { // evaluate package.json
                let jsonPath = path.join(currentPath, packageName, "package.json");
                let jsonText = readFile(jsonPath, baseDir);
                if (jsonText != null) {
                  try {
                    let json = JSON.parse(jsonText);
                    if (typeof json.ascMain === "string") {
                      mainPath = json.ascMain.replace(extension.re_index, "");
                      packageMains.set(packageName, mainPath);
                    }
                  } catch (e) { /* nop */ }
                }
              }
              const mainDir = path.join(currentPath, packageName, mainPath);
              const plainName = filePath;
              if ((sourceText = readFile(path.join(mainDir, plainName + extension.ext), baseDir)) != null) {
                sourcePath = `${libraryPrefix}${packageName}/${plainName}${extension.ext}`;
                packageBases.set(sourcePath.replace(extension.re, ""), path.join(currentPath, packageName));
                if (opts.traceResolution) {
                  stderr.write(`  -> ${path.join(mainDir, plainName + extension.ext)}${EOL}`);
                }
                break;
              } else if (!isPackageRoot) {
                const indexName = `${filePath}/index`;
                if ((sourceText = readFile(path.join(mainDir, indexName + extension.ext), baseDir)) !== null) {
                  sourcePath = `${libraryPrefix}${packageName}/${indexName}${extension.ext}`;
                  packageBases.set(sourcePath.replace(extension.re, ""), path.join(currentPath, packageName));
                  if (opts.traceResolution) {
                    stderr.write(`  -> ${path.join(mainDir, indexName + extension.ext)}${EOL}`);
                  }
                  break;
                }
              }
            }
          }
        }
      }
    }
    // No such file
    if (sourceText == null) return null;
    return { sourceText, sourcePath };
  }

  // Parses the backlog of imported files after including entry files
  function parseBacklog() {
    var internalPath;
    while ((internalPath = __getString(assemblyscript.nextFile(program)))) {
      let file = getFile(internalPath, assemblyscript.getDependee(program, internalPath));
      if (file) {
        stats.parseCount++;
        stats.parseTime += measure(() => {
          let textPtr = __pin(__newString(file.sourceText));
          let pathPtr = __newString(file.sourcePath);
          assemblyscript.parse(program, textPtr, pathPtr, false);
          __unpin(textPtr);
        });
      } else {
        stats.parseTime += measure(() => {
          let textPtr = __newString(null); // no need to pin
          let pathPtr = __newString(internalPath + extension.ext);
          assemblyscript.parse(program, textPtr, pathPtr, false);
        });
      }
    }
    var numErrors = checkDiagnostics(program, stderr, options.reportDiagnostic);
    if (numErrors) {
      const err = Error(`${numErrors} parse error(s)`);
      err.stack = err.message; // omit stack
      return callback(err);
    }
  }

  // Include runtime before entry files so its setup runs first
  {
    let runtimeName = String(opts.runtime);
    let runtimePath = `rt/index-${runtimeName}`;
    let runtimeText = exports.libraryFiles[runtimePath];
    if (runtimeText == null) {
      runtimePath = runtimeName;
      runtimeText = readFile(runtimePath + extension.ext, baseDir);
      if (runtimeText == null) return callback(Error(`Runtime '${runtimeName}' not found.`));
    } else {
      runtimePath = `~lib/${runtimePath}`;
    }
    stats.parseCount++;
    stats.parseTime += measure(() => {
      let textPtr = __pin(__newString(runtimeText));
      let pathPtr = __newString(runtimePath + extension.ext);
      assemblyscript.parse(program, textPtr, pathPtr, true);
      __unpin(textPtr);
    });
  }

  // Include entry files
  for (let i = 0, k = argv.length; i < k; ++i) {
    const filename = argv[i];
    let sourcePath = String(filename)
      .replace(/\\/g, "/")
      .replace(extension.re, "")
      .replace(/[\\/]$/, "");

    // Setting the path to relative path
    sourcePath = path.isAbsolute(sourcePath)
      ? path.relative(baseDir, sourcePath).replace(/\\/g, "/")
      : sourcePath;

    // Try entryPath.ext, then entryPath/index.ext
    let sourceText = readFile(sourcePath + extension.ext, baseDir);
    if (sourceText == null) {
      const path = `${sourcePath}/index${extension.ext}`;
      sourceText = readFile(path, baseDir);
      if (sourceText != null) sourcePath = path;
      else sourcePath += extension.ext;
    } else {
      sourcePath += extension.ext;
    }

    stats.parseCount++;
    stats.parseTime += measure(() => {
      let textPtr = __pin(__newString(sourceText));
      let pathPtr = __newString(sourcePath);
      assemblyscript.parse(program, textPtr, pathPtr, true);
      __unpin(textPtr);
    });
  }

  // Parse entry files
  {
    let code = parseBacklog();
    if (code) return code;
  }

  // Call afterParse transform hook
  {
    let error = applyTransform("afterParse", program.parser);
    if (error) return callback(error);
  }

  // Parse additional files, if any
  {
    let code = parseBacklog();
    if (code) return code;
  }

  // Print files and exit if listFiles
  if (opts.listFiles) {
    // FIXME: not a proper C-like API
    stderr.write(program.sources.map(s => s.normalizedPath).sort().join(EOL) + EOL);
    return callback(null);
  }

  // Pre-emptively initialize the program
  stats.initializeCount++;
  stats.initializeTime += measure(() => {
    try {
      assemblyscript.initializeProgram(program);
    } catch (e) {
      crash("initialize", e);
    }
  });

  // Call afterInitialize transform hook
  {
    let error = applyTransform("afterInitialize", program);
    if (error) return callback(error);
  }

  var module;
  stats.compileCount++;
  stats.compileTime += measure(() => {
    try {
      module = assemblyscript.compile(program);
    } catch (e) {
      crash("compile", e);
    }
    // From here on we are going to use Binaryen.js, except that we keep pass
    // order as defined in the compiler.
    if (typeof module === "number") { // Wasm
      const original = assemblyscript.Module.wrap(module);
      module = binaryen.wrapModule(original.ref);
      module.optimize = function(...args) {
        original.optimize(...args);
      };
    } else { // JS
      const original = module;
      module = binaryen.wrapModule(module.ref);
      module.optimize = function(...args) {
        original.optimize(...args);
      };
    }
  });
  var numErrors = checkDiagnostics(program, stderr, options.reportDiagnostic);
  if (numErrors) {
    if (module) module.dispose();
    const err = Error(`${numErrors} compile error(s)`);
    err.stack = err.message; // omit stack
    return callback(err);
  }

  // Call afterCompile transform hook
  {
    let error = applyTransform("afterCompile", module);
    if (error) return callback(error);
  }

  // Validate the module if requested
  if (!opts.noValidate) {
    stats.validateCount++;
    let isValid;
    stats.validateTime += measure(() => {
      isValid = module.validate();
    });
    if (!isValid) {
      module.dispose();
      return callback(Error("validate error"));
    }
  }

  // Set Binaryen-specific options
  if (opts.trapMode === "clamp" || opts.trapMode === "js") {
    stats.optimizeCount++;
    stats.optimizeTime += measure(() => {
      try {
        module.runPasses([`trap-mode-${opts.trapMode}`]);
      } catch (e) {
        crash("runPasses", e);
      }
    });
  } else if (opts.trapMode !== "allow") {
    module.dispose();
    return callback(Error("Unsupported trap mode"));
  }

  // Optimize the module
  const debugInfo = opts.debug;
  const converge = opts.converge;
  const runPasses = [];
  if (opts.runPasses) {
    if (typeof opts.runPasses === "string") {
      opts.runPasses = opts.runPasses.split(",");
    }
    if (opts.runPasses.length) {
      opts.runPasses.forEach(pass => {
        if (!runPasses.includes(pass = pass.trim())) {
          runPasses.push(pass);
        }
      });
    }
  }

  stats.optimizeTime += measure(() => {
    stats.optimizeCount++;
    try {
      module.optimize(optimizeLevel, shrinkLevel, debugInfo);
    } catch (e) {
      crash("optimize", e);
    }
    try {
      module.runPasses(runPasses);
    } catch (e) {
      crash("runPasses", e);
    }
    if (converge) {
      let last;
      try {
        last = module.emitBinary();
      } catch (e) {
        crash("emitBinary (converge)", e);
      }
      do {
        stats.optimizeCount++;
        try {
          module.optimize(optimizeLevel, shrinkLevel, debugInfo);
        } catch (e) {
          crash("optimize (converge)", e);
        }
        try {
          module.runPasses(runPasses);
        } catch (e) {
          crash("runPasses (converge)", e);
        }
        let next;
        try {
          next = module.emitBinary();
        } catch (e) {
          crash("emitBinary (converge)", e);
        }
        if (next.length >= last.length) {
          if (next.length > last.length) {
            stderr.write(`Last converge was suboptimial.${EOL}`);
          }
          break;
        }
        last = next;
      } while (true);
    }
  });

  // Prepare output
  if (!opts.noEmit) {
    if (opts.outFile != null) {
      if (opts.textFile == null && /\.was?t$/.test(opts.outFile)) {
        opts.textFile = opts.outFile;
      } else if (opts.jsFile == null && /\.js$/.test(opts.outFile)) {
        opts.jsFile = opts.outFile;
      } else if (opts.binaryFile == null) {
        opts.binaryFile = opts.outFile;
      }
    }

    let hasStdout = false;
    let hasOutput = opts.textFile != null
                 || opts.binaryFile != null
                 || opts.jsFile != null
                 || opts.tsdFile != null
                 || opts.idlFile != null;

    // Write binary
    if (opts.binaryFile != null) {
      let basename = path.basename(opts.binaryFile);
      let sourceMapURL = opts.sourceMap != null
        ? opts.sourceMap.length
          ? opts.sourceMap
          : `./${basename}.map`
        : null;

      let wasm;
      stats.emitCount++;
      stats.emitTime += measure(() => {
        try {
          wasm = module.emitBinary(sourceMapURL);
        } catch (e) {
          crash("emitBinary", e);
        }
      });

      if (opts.binaryFile.length) {
        writeFile(opts.binaryFile, wasm.binary, baseDir);
      } else {
        writeStdout(wasm.binary);
        hasStdout = true;
      }

      // Post-process source map
      if (wasm.sourceMap != "") {
        if (opts.binaryFile.length) {
          let map = JSON.parse(wasm.sourceMap);
          map.sourceRoot = `./${basename}`;
          let contents = [];
          map.sources.forEach((name, index) => {
            let text = assemblyscript.getSource(program, __newString(name.replace(extension.re, "")));
            if (text == null) return callback(Error(`Source of file '${name}' not found.`));
            contents[index] = text;
          });
          map.sourcesContent = contents;
          writeFile(path.join(
            path.dirname(opts.binaryFile),
            path.basename(sourceMapURL)
          ).replace(/^\.\//, ""), JSON.stringify(map), baseDir);
        } else {
          stderr.write(`Skipped source map (stdout already occupied)${EOL}`);
        }
      }
    }

    // Write text (also fallback)
    if (opts.textFile != null || !hasOutput) {
      let out;
      if (opts.textFile != null && opts.textFile.length) {
        // use superset text format when extension is `.wast`.
        // Otherwise use official stack IR format (wat).
        let wastFormat = opts.textFile.endsWith(".wast");
        stats.emitCount++;
        stats.emitTime += measure(() => {
          try {
            out = wastFormat
              ? module.emitText()
              : module.emitStackIR(true);
          } catch (e) {
            crash("emitText", e);
          }
        });
        writeFile(opts.textFile, out, baseDir);
      } else if (!hasStdout) {
        stats.emitCount++;
        stats.emitTime += measure(() => {
          try {
            out = module.emitStackIR(true);
          } catch (e) {
            crash("emitText", e);
          }
        });
        writeStdout(out);
      }
    }

    // Write WebIDL
    if (opts.idlFile != null) {
      let idl;
      if (opts.idlFile.length) {
        stats.emitCount++;
        stats.emitTime += measure(() => {
          try {
            idl = assemblyscript.buildIDL(program);
          } catch (e) {
            crash("buildIDL", e);
          }
        });
        writeFile(opts.idlFile, __getString(idl), baseDir);
      } else if (!hasStdout) {
        stats.emitCount++;
        stats.emitTime += measure(() => {
          try {
            idl = assemblyscript.buildIDL(program);
          } catch (e) {
            crash("buildIDL", e);
          }
        });
        writeStdout(__getString(idl));
        hasStdout = true;
      }
    }

    // Write TypeScript definition
    if (opts.tsdFile != null) {
      let tsd;
      if (opts.tsdFile.length) {
        stats.emitCount++;
        stats.emitTime += measure(() => {
          try {
            tsd = assemblyscript.buildTSD(program);
          } catch (e) {
            crash("buildTSD", e);
          }
        });
        writeFile(opts.tsdFile, __getString(tsd), baseDir);
      } else if (!hasStdout) {
        stats.emitCount++;
        stats.emitTime += measure(() => {
          try {
            tsd = assemblyscript.buildTSD(program);
          } catch (e) {
            crash("buildTSD", e);
          }
        });
        writeStdout(__getString(tsd));
        hasStdout = true;
      }
    }

    // Write JS (modifies the binary, so must be last)
    if (opts.jsFile != null) {
      let js;
      if (opts.jsFile.length) {
        stats.emitCount++;
        stats.emitTime += measure(() => {
          try {
            js = module.emitAsmjs();
          } catch (e) {
            crash("emitJS", e);
          }
        });
        writeFile(opts.jsFile, js, baseDir);
      } else if (!hasStdout) {
        stats.emitCount++;
        stats.emitTime += measure(() => {
          try {
            js = module.emitAsmjs();
          } catch (e) {
            crash("emitJS", e);
          }
        });
        writeStdout(js);
      }
    }
  }

  module.dispose();
  if (opts.measure) {
    printStats(stats, stderr);
  }

  return callback(null);

  function readFileNode(filename, baseDir) {
    let name = path.resolve(baseDir, filename);
    try {
      let text;
      stats.readCount++;
      stats.readTime += measure(() => {
        text = fs.readFileSync(name, "utf8");
      });
      return text;
    } catch (e) {
      return null;
    }
  }

  function writeFileNode(filename, contents, baseDir) {
    try {
      stats.writeCount++;
      stats.writeTime += measure(() => {
        const dirPath = path.resolve(baseDir, path.dirname(filename));
        filename = path.basename(filename);
        const outputFilePath = path.join(dirPath, filename);
        if (!fs.existsSync(dirPath)) mkdirp(dirPath);
        fs.writeFileSync(outputFilePath, contents);
      });
      return true;
    } catch (e) {
      return false;
    }
  }

  function listFilesNode(dirname, baseDir) {
    var files;
    try {
      stats.readCount++;
      stats.readTime += measure(() => {
        files = fs.readdirSync(path.join(baseDir, dirname))
          .filter(file => extension.re_except_d.test(file));
      });
      return files;
    } catch (e) {
      return null;
    }
  }

  function writeStdout(contents) {
    if (!writeStdout.used) {
      stats.writeCount++;
      writeStdout.used = true;
    }
    stats.writeTime += measure(() => {
      stdout.write(contents);
    });
  }
};

const toString = Object.prototype.toString;

function isObject(arg) {
  return toString.call(arg) === "[object Object]";
}

function getAsconfig(file, baseDir, readFile) {
  const contents = readFile(file, baseDir);
  const location = path.join(baseDir, file);
  if (!contents) return null;

  // obtain the configuration
  let config;
  try {
    config = JSON.parse(contents);
  } catch(ex) {
    throw new Error(`Asconfig is not valid json: ${location}`);
  }

  // validate asconfig shape
  if (config.options && !isObject(config.options)) {
    throw new Error(`Asconfig.options is not an object: ${location}`);
  }

  if (config.include && !Array.isArray(config.include)) {
    throw new Error(`Asconfig.include is not an array: ${location}`);
  }

  if (config.targets) {
    if (!isObject(config.targets)) {
      throw new Error(`Asconfig.targets is not an object: ${location}`);
    }
    const targets = Object.keys(config.targets);
    for (let i = 0; i < targets.length; i++) {
      const target = targets[i];
      if (!isObject(config.targets[target])) {
        throw new Error(`Asconfig.targets.${target} is not an object: ${location}`);
      }
    }
  }

  if (config.extends && typeof config.extends !== "string") {
    throw new Error(`Asconfig.extends is not a string: ${location}`);
  }

  return config;
}

exports.getAsconfig = getAsconfig;

/** Checks diagnostics emitted so far for errors. */
function checkDiagnostics(program, stderr, reportDiagnostic) {
  var numErrors = 0;
  do {
    let diagnosticPtr = assemblyscript.nextDiagnostic(program);
    if (!diagnosticPtr) break;
    __pin(diagnosticPtr);
    if (stderr) {
      stderr.write(
        __getString(assemblyscript.formatDiagnostic(diagnosticPtr, stderr.isTTY, true)) +
        EOL + EOL
      );
    }
    if (reportDiagnostic) {
      const diagnostic = __wrap(diagnosticPtr, assemblyscript.DiagnosticMessage);
      const range = __wrap(diagnostic.range, assemblyscript.Range);
      const relatedRange = __wrap(diagnostic.relatedRange, assemblyscript.Range);
      const rangeSource = range ? __wrap(range.source, assemblyscript.Source) : null;
      const relatedRangeSource = relatedRange ? __wrap(relatedRange.source, assemblyscript.Source) : null;

      reportDiagnostic({
        message: __getString(diagnostic.message),
        code: diagnostic.code,
        category: diagnostic.category,
        range: range ? {
          start: range.start,
          end: range.end,
          source: rangeSource ? {
            normalizedPath: __getString(rangeSource.normalizedPath)
          } : null,
        } : null,
        relatedRange: relatedRange ? {
          start: relatedRange.start,
          end: relatedRange.end,
          source: relatedRangeSource ? {
            normalizedPath: __getString(relatedRangeSource.normalizedPath)
          } : null
        } : null
      });
    }
    if (assemblyscript.isError(diagnosticPtr)) ++numErrors;
    __unpin(diagnosticPtr);
  } while (true);
  return numErrors;
}

exports.checkDiagnostics = checkDiagnostics;

/** Creates an empty set of stats. */
function createStats() {
  return {
    readTime: 0,
    readCount: 0,
    writeTime: 0,
    writeCount: 0,
    parseTime: 0,
    parseCount: 0,
    initializeTime: 0,
    initializeCount: 0,
    compileTime: 0,
    compileCount: 0,
    emitTime: 0,
    emitCount: 0,
    validateTime: 0,
    validateCount: 0,
    optimizeTime: 0,
    optimizeCount: 0,
    transformTime: 0,
    transformCount: 0
  };
}

exports.createStats = createStats;

/** Measures the execution time of the specified function.  */
function measure(fn) {
  const start = process.hrtime();
  fn();
  const times = process.hrtime(start);
  return times[0] * 1e9 + times[1];
}

exports.measure = measure;

function pad(str, len) {
  while (str.length < len) str = ` ${str}`;
  return str;
}

/** Formats a high resolution time to a human readable string. */
function formatTime(time) {
  return time ? `${(time / 1e6).toFixed(3)} ms` : "n/a";
}

exports.formatTime = formatTime;

/** Formats and prints out the contents of a set of stats. */
function printStats(stats, output) {
  const format = (time, count) => `${pad(formatTime(time), 12)}  n=${count}`;
  (output || process.stdout).write([
    "I/O Read   : " + format(stats.readTime, stats.readCount),
    "I/O Write  : " + format(stats.writeTime, stats.writeCount),
    "Parse      : " + format(stats.parseTime, stats.parseCount),
    "Initialize : " + format(stats.initializeTime, stats.initializeCount),
    "Compile    : " + format(stats.compileTime, stats.compileCount),
    "Emit       : " + format(stats.emitTime, stats.emitCount),
    "Validate   : " + format(stats.validateTime, stats.validateCount),
    "Optimize   : " + format(stats.optimizeTime, stats.optimizeCount),
    "Transform  : " + format(stats.transformTime, stats.transformCount),
    ""
  ].join(EOL) + EOL);
}

exports.printStats = printStats;

var allocBuffer = typeof global !== "undefined" && global.Buffer
  ? global.Buffer.allocUnsafe || (len => new global.Buffer(len))
  : len => new Uint8Array(len);

/** Creates a memory stream that can be used in place of stdout/stderr. */
function createMemoryStream(fn) {
  var stream = [];
  stream.write = function(chunk) {
    if (fn) fn(chunk);
    if (typeof chunk === "string") {
      let buffer = allocBuffer(utf8.length(chunk));
      utf8.write(chunk, buffer, 0);
      chunk = buffer;
    }
    this.push(chunk);
  };
  stream.reset = function() {
    stream.length = 0;
  };
  stream.toBuffer = function() {
    var offset = 0, i = 0, k = this.length;
    while (i < k) offset += this[i++].length;
    var buffer = allocBuffer(offset);
    offset = i = 0;
    while (i < k) {
      buffer.set(this[i], offset);
      offset += this[i].length;
      ++i;
    }
    return buffer;
  };
  stream.toString = function() {
    var buffer = this.toBuffer();
    return utf8.read(buffer, 0, buffer.length);
  };
  return stream;
}

exports.createMemoryStream = createMemoryStream;

/** Compatible TypeScript compiler options for syntax highlighting etc. */
exports.tscOptions = {
  alwaysStrict: true,
  noImplicitAny: true,
  noImplicitReturns: true,
  noImplicitThis: true,
  noEmitOnError: true,
  strictNullChecks: true,
  experimentalDecorators: true,
  target: "esnext",
  module: "commonjs",
  noLib: true,
  types: [],
  allowJs: false
};

// Gracefully handle crashes
function crash(stage, e) {
  const BAR = colorsUtil.red("â–Œ ");
  console.error([
    EOL,
    BAR, "Whoops, the AssemblyScript compiler has crashed during ", stage, " :-(", EOL,
    BAR, EOL,
    BAR, "Here is a stack trace that may or may not be useful:", EOL,
    BAR, EOL,
    e.stack.replace(/^/mg, BAR), EOL,
    BAR, EOL,
    BAR, "If it refers to the dist files, try to 'npm install source-map-support' and", EOL,
    BAR, "run again, which should then show the actual code location in the sources.", EOL,
    BAR, EOL,
    BAR, "If you see where the error is, feel free to send us a pull request. If not,", EOL,
    BAR, "please let us know: https://github.com/AssemblyScript/assemblyscript/issues", EOL,
    BAR, EOL,
    BAR, "Thank you!", EOL
  ].join(""));
  process.exit(1);
}

'''
'''--- cli/asc.json ---
{
  "version": {
    "category": "General",
    "description": "Prints just the compiler's version and exits.",
    "type": "b",
    "alias": "v"
  },
  "help": {
    "category": "General",
    "description": "Prints this message and exits.",
    "type": "b",
    "alias": "h"
  },
  "noColors": {
    "category": "General",
    "description": "Disables terminal colors.",
    "type": "b",
    "default": false
  },
  "config": {
    "category": "General",
    "description": "Configuration file to apply. CLI arguments take precedence.",
    "type": "s",
    "cliOnly": true
  },
  "target": {
    "category": "General",
    "description": "Target configuration to use. Defaults to 'release'.",
    "type": "s",
    "cliOnly": true
  },

  "optimize": {
    "category": "Optimization",
    "description": [
      "Optimizes the module. Typical shorthands are:",
      "",
      " Default optimizations   -O",
      " Make a release build    -O --noAssert",
      " Make a debug build      --debug",
      " Optimize for speed      -Ospeed",
      " Optimize for size       -Osize",
      ""
    ],
    "type": "b",
    "alias": "O"
  },
  "optimizeLevel": {
    "category": "Optimization",
    "description": "How much to focus on optimizing code. [0-3]",
    "type": "i"
  },
  "shrinkLevel": {
    "category": "Optimization",
    "description": "How much to focus on shrinking code size. [0-2, s=1, z=2]",
    "type": "i"
  },
  "converge": {
    "category": "Optimization",
    "description": "Re-optimizes until no further improvements can be made.",
    "type": "b",
    "default": false
  },
  "noAssert": {
    "category": "Optimization",
    "description": "Replaces assertions with just their value without trapping.",
    "type": "b",
    "default": false
  },

  "outFile": {
    "category": "Output",
    "description": "Specifies the output file. File extension indicates format.",
    "type": "s",
    "alias": "o",
    "isPath": true
  },
  "binaryFile": {
    "category": "Output",
    "description": "Specifies the binary output file (.wasm).",
    "type": "s",
    "alias": "b",
    "isPath": true
  },
  "textFile": {
    "category": "Output",
    "description": "Specifies the text output file (.wat).",
    "type": "s",
    "alias": "t",
    "isPath": true
  },
  "jsFile": {
    "category": "Output",
    "description": "Specifies the JavaScript (via wasm2js) output file (.js).",
    "type": "s",
    "alias": "j",
    "isPath": true
  },
  "idlFile": {
    "category": "Output",
    "description": "Specifies the WebIDL output file (.webidl).",
    "type": "s",
    "alias": "i",
    "isPath": true
  },
  "tsdFile": {
    "category": "Output",
    "description": "Specifies the TypeScript definition output file (.d.ts).",
    "type": "s",
    "alias": "d",
    "isPath": true
  },

  "sourceMap": {
    "category": "Debugging",
    "description": [
      "Enables source map generation. Optionally takes the URL",
      "used to reference the source map from the binary file."
    ],
    "type": "s"
  },
  "debug": {
    "category": "Debugging",
    "description": "Enables debug information in emitted binaries.",
    "type": "b",
    "default": false
  },

  "importMemory": {
    "category": "Features",
    "description": "Imports the memory from 'env.memory'.",
    "type": "b",
    "default": false
  },
  "noExportMemory": {
    "category": "Features",
    "description": "Does not export the memory as 'memory'.",
    "type": "b",
    "default": false
  },
  "initialMemory": {
    "category": "Features",
    "description": "Sets the initial memory size in pages.",
    "type": "i",
    "default": 0
  },
  "maximumMemory": {
    "category": "Features",
    "description": "Sets the maximum memory size in pages.",
    "type": "i",
    "default": 0
  },
  "sharedMemory": {
    "category": "Features",
    "description": "Declare memory as shared. Requires maximumMemory.",
    "type": "b",
    "default": false
  },
  "importTable": {
    "category": "Features",
    "description": "Imports the function table from 'env.table'.",
    "type": "b",
    "default": false
  },
  "exportTable": {
    "category": "Features",
    "description": "Exports the function table as 'table'.",
    "type": "b",
    "default": false
  },
  "runtime": {
    "category": "Features",
    "description": [
      "Specifies the runtime variant to include in the program.",
      "",
      " incremental  TLSF + incremental GC (default)",
      " minimal      TLSF + lightweight GC invoked externally",
      " stub         Minimal runtime stub (never frees)",
      " ...          Path to a custom runtime implementation",
      ""
    ],
    "type": "s",
    "default": "incremental"
  },
  "exportRuntime": {
    "category": "Features",
    "description": "Exports the runtime helpers (__new, __collect etc.).",
    "type": "b",
    "default": false
  },
  "stackSize": {
    "category": "Features",
    "description": [
      "Overrides the stack size. Only relevant for incremental GC",
      "or when using a custom runtime that requires stack space.",
      "Defaults to 0 without and to 16384 with incremental GC."
    ],
    "default": 0,
    "type": "i"
  },
  "explicitStart": {
    "category": "Features",
    "description": "Exports an explicit '_start' function to call.",
    "type": "b",
    "default": false
  },
  "enable": {
    "category": "Features",
    "description": [
      "Enables WebAssembly features being disabled by default.",
      "",
      " nontrapping-f2i     Non-trapping float to integer ops.",
      " bulk-memory         Bulk memory operations.",
      " simd                SIMD types and operations.",
      " threads             Threading and atomic operations.",
      " reference-types     Reference types and operations.",
      " gc                  Garbage collection (WIP).",
      ""
    ],
    "TODO_doesNothingYet": [
      " exception-handling  Exception handling.",
      " tail-calls          Tail call operations.",
      " multi-value         Multi value types.",
      " memory64            Memory64 operations."
    ],
    "type": "S",
    "mutuallyExclusive": "disable"
  },
  "disable": {
    "category": "Features",
    "description": [
      "Disables WebAssembly features being enabled by default.",
      "",
      " mutable-globals     Mutable global imports and exports.",
      " sign-extension      Sign-extension operations",
      ""
    ],
    "type": "S",
    "mutuallyExclusive": "enable"
  },
  "use": {
    "category": "Features",
    "description": [
      "Aliases a global object under another name, e.g., to switch",
      "the default 'Math' implementation used: --use Math=JSMath",
      "Can also be used to introduce an integer constant."
    ],
    "type": "S",
    "alias": "u"
  },
  "lowMemoryLimit": {
    "category": "Features",
    "description": "Enforces very low (<64k) memory constraints.",
    "default": 0,
    "type": "i"
  },

  "memoryBase": {
    "category": "Linking",
    "description": "Sets the start offset of emitted memory segments.",
    "type": "i",
    "default": 0
  },
  "tableBase": {
    "category": "Linking",
    "description": "Sets the start offset of emitted table elements.",
    "type": "i",
    "default": 0
  },

  "transform": {
    "category": "API",
    "description": "Specifies the path to a custom transform to 'require'.",
    "type": "S",
    "isPath": true,
    "useNodeResolution": true
  },

  "trapMode": {
    "category": "Binaryen",
    "description": [
      "Sets the trap mode to use.",
      "",
      " allow  Allow trapping operations. This is the default.",
      " clamp  Replace trapping operations with clamping semantics.",
      " js     Replace trapping operations with JS semantics.",
      ""
    ],
    "type": "s",
    "default": "allow"
  },
  "runPasses": {
    "category": "Binaryen",
    "description":  [
      "Specifies additional Binaryen passes to run after other",
      "optimizations, if any. See: Binaryen/src/passes/pass.cpp"
    ],
    "type": "s"
  },
  "noValidate": {
    "category": "Binaryen",
    "description": "Skips validating the module using Binaryen.",
    "type": "b",
    "default": false
  },

  "baseDir": {
    "description": "Specifies the base directory of input and output files.",
    "type": "s",
    "default": "."
  },
  "extension": {
    "description": "Specifies an alternative file extension to use.",
    "type": "s",
    "cliOnly": true
  },
  "noUnsafe": {
    "description": [
      "Disallows the use of unsafe features in user code.",
      "Does not affect library files and external modules."
    ],
    "type": "b",
    "default": false
  },
  "noEmit": {
    "description": "Performs compilation as usual but does not emit code.",
    "type": "b",
    "default": false
  },
  "showConfig": {
    "description": "Print computed compiler options and exit.",
    "type": "b",
    "default": false
  },
  "measure": {
    "description": "Prints measuring information on I/O and compile times.",
    "type": "b",
    "default": false
  },
  "pedantic": {
    "description": "Make yourself sad for no good reason.",
    "type": "b",
    "default": false
  },
  "lib": {
    "description": [
      "Adds one or multiple paths to custom library components and",
      "uses exports of all top-level files at this path as globals."
    ],
    "type": "S",
    "isPath": true
  },
  "path": {
    "description": [
      "Adds one or multiple paths to package resolution, similar",
      "to node_modules. Prefers an 'ascMain' entry in a package's",
      "package.json and falls back to an inner 'assembly/' folder."
    ],
    "type": "S",
    "isPath": true
  },
  "traceResolution": {
    "description": "Enables tracing of package resolution.",
    "type": "b",
    "default": false
  },
  "listFiles": {
    "description": "Lists files to be compiled and exits.",
    "type": "b",
    "default": false
  },
  "wasm": {
    "description": "Uses the specified Wasm binary of the compiler.",
    "type": "s"
  },
  " ...": {
    "description": "Specifies node.js options (CLI only). See: node --help"
  },
  "-Os": { "value": { "optimizeLevel": 0, "shrinkLevel": 1 } },
  "-Oz": { "value": { "optimizeLevel": 0, "shrinkLevel": 2 } },
  "-O0": { "value": { "optimizeLevel": 0, "shrinkLevel": 0 } },
  "-O1": { "value": { "optimizeLevel": 1, "shrinkLevel": 0 } },
  "-O2": { "value": { "optimizeLevel": 2, "shrinkLevel": 0 } },
  "-O3": { "value": { "optimizeLevel": 3, "shrinkLevel": 0 } },
  "-O0s": { "value": { "optimizeLevel": 0, "shrinkLevel": 1 } },
  "-O1s": { "value": { "optimizeLevel": 1, "shrinkLevel": 1 } },
  "-O2s": { "value": { "optimizeLevel": 2, "shrinkLevel": 1 } },
  "-O3s": { "value": { "optimizeLevel": 3, "shrinkLevel": 1 } },
  "-O0z": { "value": { "optimizeLevel": 0, "shrinkLevel": 2 } },
  "-O1z": { "value": { "optimizeLevel": 1, "shrinkLevel": 2 } },
  "-O2z": { "value": { "optimizeLevel": 2, "shrinkLevel": 2 } },
  "-O3z": { "value": { "optimizeLevel": 3, "shrinkLevel": 2 } },
  "-Ospeed": { "value": { "optimizeLevel": 3, "shrinkLevel": 0 } },
  "-Osize": { "value": { "optimizeLevel": 0, "shrinkLevel": 2, "converge": true } }
}

'''
'''--- cli/shim/README.md ---
Shims used when bundling asc for browser usage.

'''
'''--- cli/shim/fs.js ---
module.exports = {};

'''
'''--- cli/shim/path.js ---
const process = require("process"); // ensure shim

// https://github.com/browserify/path-browserify v1.0.1
//
// Copyright (c) 2013 James Halliday
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
}

// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;
  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length)
      code = path.charCodeAt(i);
    else if (code === 47 /*/*/)
      break;
    else
      code = 47 /*/*/;
    if (code === 47 /*/*/) {
      if (lastSlash === i - 1 || dots === 1) {
        // NOOP
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf('/');
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = '';
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += '/..';
          else
            res = '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += '/' + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}

var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0)
        path = arguments[i];
      else {
        if (cwd === undefined)
          cwd = process.cwd();
        path = cwd;
      }

      assertPath(path);

      // Skip empty entries
      if (path.length === 0) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

    if (resolvedAbsolute) {
      if (resolvedPath.length > 0)
        return '/' + resolvedPath;
      else
        return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  },

  normalize: function normalize(path) {
    assertPath(path);

    if (path.length === 0) return '.';

    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

    // Normalize the path
    path = normalizeStringPosix(path, !isAbsolute);

    if (path.length === 0 && !isAbsolute) path = '.';
    if (path.length > 0 && trailingSeparator) path += '/';

    if (isAbsolute) return '/' + path;
    return path;
  },

  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
  },

  join: function join() {
    if (arguments.length === 0)
      return '.';
    var joined;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === undefined)
          joined = arg;
        else
          joined += '/' + arg;
      }
    }
    if (joined === undefined)
      return '.';
    return posix.normalize(joined);
  },

  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);

    if (from === to) return '';

    from = posix.resolve(from);
    to = posix.resolve(to);

    if (from === to) return '';

    if (from === ".") return to; // FIX for 'odule.ts' (see issue #1398)

    // Trim any leading backslashes
    var fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47 /*/*/)
        break;
    }
    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart;

    // Trim any leading backslashes
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47 /*/*/)
        break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;

    // Compare paths to find the longest common path from root
    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;
    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
            // We get here if `from` is the exact base path for `to`.
            // For example: from='/foo/bar'; to='/foo/bar/baz'
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            // We get here if `from` is the root
            // For example: from='/'; to='/foo'
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
            // We get here if `to` is the exact base path for `from`.
            // For example: from='/foo/bar/baz'; to='/foo/bar'
            lastCommonSep = i;
          } else if (i === 0) {
            // We get here if `to` is the root.
            // For example: from='/foo'; to='/'
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode)
        break;
      else if (fromCode === 47 /*/*/)
        lastCommonSep = i;
    }

    var out = '';
    // Generate the relative path based on the path difference between `to`
    // and `from`
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
        if (out.length === 0)
          out += '..';
        else
          out += '/..';
      }
    }

    // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts
    if (out.length > 0)
      return out + to.slice(toStart + lastCommonSep);
    else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47 /*/*/)
        ++toStart;
      return to.slice(toStart);
    }
  },

  _makeLong: function _makeLong(path) {
    return path;
  },

  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var code = path.charCodeAt(0);
    var hasRoot = code === 47 /*/*/;
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) return hasRoot ? '/' : '.';
    if (hasRoot && end === 1) return '//';
    return path.slice(0, end);
  },

  basename: function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
    assertPath(path);

    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return '';
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }

      if (end === -1) return '';
      return path.slice(start, end);
    }
  },

  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;
    for (var i = path.length - 1; i >= 0; --i) {
      var code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }
    return path.slice(startDot, end);
  },

  format: function format(pathObject) {
    if (pathObject === null || typeof pathObject !== 'object') {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format('/', pathObject);
  },

  parse: function parse(path) {
    assertPath(path);

    var ret = { root: '', dir: '', base: '', ext: '', name: '' };
    if (path.length === 0) return ret;
    var code = path.charCodeAt(0);
    var isAbsolute = code === 47 /*/*/;
    var start;
    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1;

    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;

    // Get non-dir info
    for (; i >= start; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }
      ret.ext = path.slice(startDot, end);
    }

    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

    return ret;
  },

  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};

posix.posix = posix;

module.exports = posix;

'''
'''--- cli/shim/process.js ---
module.exports = {
  platform: "linux",
  cwd() {
    return ".";
  },
  umask() {
    return 0;
  },
  hrtime,
  argv: [],
  exit(code = 0) {
    throw Error(`exit ${code}`);
  }
};

// https://github.com/kumavis/browser-process-hrtime v1.0.0
//
// Copyright 2014 kumavis
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
// this list of conditions and the following disclaimer in the documentation
// and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

var performance = global.performance || {};
var performanceNow =
  performance.now        ||
  performance.mozNow     ||
  performance.msNow      ||
  performance.oNow       ||
  performance.webkitNow  ||
  function(){ return (new Date()).getTime(); };

function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance);
  var seconds = Math.floor(clocktime * 1e-3);
  var nanoseconds = Math.floor(clocktime * 1e6 - seconds * 1e9);
  if (previousTimestamp) {
    seconds -= previousTimestamp[0];
    nanoseconds -= previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [ seconds, nanoseconds ];
}

'''
'''--- cli/transform.d.ts ---
/**
 * @fileoverview Compiler transform interface definitions.
 * @license Apache-2.0
 */

import { Program, Parser, Module } from "..";
import { OutputStream } from "./asc";

export abstract class Transform {

  /** Program reference. */
  readonly program: Program;

  /** Base directory. */
  readonly baseDir: string;

  /** Output stream used by the compiler. */
  readonly stdout: OutputStream;

  /** Error stream used by the compiler. */
  readonly stderr: OutputStream;

  /** Logs a message to console. */
  readonly log: typeof console.log;

  /** Writes a file to disk. */
  writeFile(filename: string, contents: string | Uint8Array, baseDir: string): boolean;

  /** Reads a file from disk. */
  readFile(filename: string, baseDir: string): string | null;

  /** Lists all files in a directory. */
  listFiles(dirname: string, baseDir: string): string[] | null;

  /** Called when parsing is complete, before a program is instantiated from the AST. */
  afterParse?(parser: Parser): void;

  /** Called after the program is instantiated. */
  afterInitialize?(program: Program): void;

  /** Called when compilation is complete, before the module is being validated. */
  afterCompile?(module: Module): void;
}

'''
'''--- cli/transform.js ---
/**
 * @fileoverview Compiler transform interface.
 * @license Apache-2.0
 */

// becomes replaced with the actual base by asc
exports.Transform = function Transform() { /* nop */ };

'''
'''--- cli/util/colors.d.ts ---
/**
 * @fileoverview Terminal colors utility definitions.
 * @license Apache-2.0
 */

interface Colors {
  /** Whether terminal colors are supported. */
  supported: boolean;
  /** Colors a string in gray if {@link supported}. */
  gray(text: string): string;
  /** Colors a string in red if {@link supported}. */
  red(text: string): string;
  /** Colors a string in green if {@link supported}. */
  green(text: string): string;
  /** Colors a string in yellow if {@link supported}. */
  yellow(text: string): string;
  /** Colors a string in blue if {@link supported}. */
  blue(text: string): string;
  /** Colors a string in magenta if {@link supported}. */
  magenta(text: string): string;
  /** Colors a string in cyan if {@link supported}. */
  cyan(text: string): string;
  /** Colors a string in white if {@link supported}. */
  white(text: string): string;
}

interface Exports extends Colors {
  /** Standard output wrapper. */
  stdout: Colors;
  /** Standard error wrapper. */
  stderr: Colors;
  /** Creates an instance for the specified stream. */
  from(stream: Record<string,unknown>, base?: Record<string,unknown>): Colors;
  /** Gray color escape sequence. */
  GRAY: string;
  /** Red color escape sequence. */
  RED: string;
  /** Green color escape sequence. */
  GREEN: string;
  /** Yellow color escape sequence. */
  YELLOW: string;
  /** Blue color escape sequence. */
  BLUE: string;
  /** Magenta color escape sequence. */
  MAGENTA: string;
  /** Cyan color escape sequence. */
  CYAN: string;
  /** White color escape sequence. */
  WHITE: string;
  /** Reset color escape sequence. */
  RESET: string;
}

declare const colors: Exports;
export = colors;

'''
'''--- cli/util/colors.js ---
/**
 * @fileoverview Terminal colors utility.
 * @license Apache-2.0
 */

var proc = typeof process !== "undefined" && process || {};
var isCI = proc.env && "CI" in proc.env; // doesn't work when bundled because 'process' is a mock

function from(stream, base) {
  var colors = base || {};
  colors.supported = (stream && !!stream.isTTY) || isCI;
  colors.gray = text => colors.supported ? exports.GRAY + text + exports.RESET : text;
  colors.red = text => colors.supported ? exports.RED + text + exports.RESET : text;
  colors.green = text => colors.supported ? exports.GREEN + text + exports.RESET : text;
  colors.yellow = text => colors.supported ? exports.YELLOW + text + exports.RESET : text;
  colors.blue = text => colors.supported ? exports.BLUE + text + exports.RESET : text;
  colors.magenta = text => colors.supported ? exports.MAGENTA + text + exports.RESET : text;
  colors.cyan = text => colors.supported ? exports.CYAN + text + exports.RESET : text;
  colors.white = text => colors.supported ? exports.WHITE + text + exports.RESET : text;
  return colors;
}

exports.stdout = from(proc.stdout, exports);
exports.stderr = from(proc.stderr);
exports.from = from;

exports.GRAY = "\u001b[90m";
exports.RED = "\u001b[91m";
exports.GREEN = "\u001b[92m";
exports.YELLOW = "\u001b[93m";
exports.BLUE = "\u001b[94m";
exports.MAGENTA = "\u001b[95m";
exports.CYAN = "\u001b[96m";
exports.WHITE = "\u001b[97m";
exports.RESET = "\u001b[0m";

'''
'''--- cli/util/find.d.ts ---
/**
 * @fileoverview File finding utility definitions.
 * @license Apache-2.0
 */

export function files(dirname: string, filter?: ((name: string) => bool) | RegExp): string[];

'''
'''--- cli/util/find.js ---
/**
 * @fileoverview File finding utility.
 * @license Apache-2.0
 */

const fs = require("fs");
const path = require("path");

function findFiles(dirname, filter) {
  var out = [];
  fs.readdirSync(dirname).forEach(name => {
    if (fs.statSync(path.join(dirname, name)).isDirectory()) {
      findFiles(path.join(dirname, name), filter).forEach(iname => out.push(name + "/" + iname));
    } else if (!filter || typeof filter === "function" ? filter(name) : filter.test(name)) {
      out.push(name);
    }
  });
  return out;
}

exports.files = findFiles;

'''
'''--- cli/util/mkdirp.d.ts ---
/**
 * @fileoverview Recursive mkdir definitions.
 * @license Apache-2.0
 */

interface Options {
  mode?: number;
}
declare function mkdirp(path: string, options?: Options): string | null;
export = mkdirp;

'''
'''--- cli/util/mkdirp.js ---
/**
 * @fileoverview Recursive mkdir.
 * @license
 * Copyright 2010 James Halliday (mail@substack.net)
 *
 * This project is free software released under the MIT/X11 license:
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

const path = require("path");
const fs = require("fs");
const process = require("process"); // ensure shim

module.exports = function mkdirp(p, opts, made) {
  if (!opts || typeof opts !== "object") {
    opts = { mode: opts };
  }
  var mode = opts.mode;
  if (mode === undefined) {
    mode = 0o777 & (~process.umask());
  }
  if (!made) made = null;
  p = path.resolve(p);
  try {
    fs.mkdirSync(p, mode);
    made = made || p;
  } catch (err0) {
    switch (err0.code) {
      case "ENOENT":
        made = mkdirp(path.dirname(p), opts, made);
        mkdirp(p, opts, made);
        break;
      default:
        var stat;
        try {
          stat = fs.statSync(p);
        } catch (err1) {
          throw err0;
        }
        if (!stat.isDirectory()) throw err0;
        break;
    }
  }
  return made;
};

'''
'''--- cli/util/options.d.ts ---
/**
 * @fileoverview Command line options utility definitions.
 * @license Apache-2.0
 */

/** A set of options. */
export interface OptionSet {
  [key: string]: number | string
}

/** Command line option description. */
export interface OptionDescription {
  /** Textual description. */
  description?: string | string[],
  /** Data type. One of (b)oolean [default], (i)nteger, (f)loat or (s)tring. Uppercase means multiple values. */
  type?: "b" | "i" | "f" | "s" | "I" | "F" | "S",
  /** Substituted options, if any. */
  value?: OptionSet,
  /** Short alias, if any. */
  alias?: string
  /** The default value, if any. */
  default?: string | number | boolean | string[] | number[];
  /** The category this option belongs in. */
  category?: string;
}

/** Configuration object. */
interface Config {
  [key: string]: OptionDescription;
}

/** Parsing result. */
interface Result {
  /** Parsed options. */
  options: OptionSet,
  /** Unknown options. */
  unknown: string[],
  /** Normal arguments. */
  arguments: string[],
  /** Trailing arguments. */
  trailing: string[]
}

/** Parses the specified command line arguments according to the given configuration. */
export function parse(argv: string[], config: Config, propagateDefaults?: boolean): Result;

/** Help formatting options. */
interface HelpOptions {
  /** Leading indent. Defaults to 2. */
  indent?: number,
  /** Table padding. Defaults to 24. */
  padding?: number,
  /** End of line character. Defaults to "\n". */
  eol?: string
}

/** Generates the help text for the specified configuration. */
export function help(config: Config, options?: HelpOptions): string;

/** Merges two sets of options into one, preferring the current over the parent set. */
export function merge(config: Config, currentOptions: OptionSet, parentOptions: OptionSet, parentBaseDir: string): OptionSet;

/** Resolves a single relative path. Keeps absolute paths, otherwise prepends baseDir. */
export function resolvePath(path: string, baseDir: string, useNodeResolution?: boolean): string;

/** Populates default values on a parsed options result. */
export function addDefaults(config: Config, options: OptionSet): void;

'''
'''--- cli/util/options.js ---
/**
 * @fileoverview Command line options utility.
 * @license Apache-2.0
 */

const path = require("path");
const colorsUtil = require("./colors");

// type | meaning
// -----|---------------
// b    | boolean
// i    | integer
// f    | float
// s    | string
// I    | integer array
// F    | float array
// S    | string array

/** Parses the specified command line arguments according to the given configuration. */
function parse(argv, config, propagateDefaults = true) {
  var options = {};
  var unknown = [];
  var args = [];
  var trailing = [];

  // make an alias map and initialize defaults
  var aliases = {};
  Object.keys(config).forEach(key => {
    if (key.startsWith(" ")) return;
    var option = config[key];
    if (option.alias != null) {
      if (typeof option.alias === "string") aliases[option.alias] = key;
      else if (Array.isArray(option.alias)) option.alias.forEach(alias => aliases[alias] = key);
    }
    if (propagateDefaults && option.default != null) options[key] = option.default;
  });

  // iterate over argv
  for (var i = 0, k = (argv = argv.slice()).length; i < k; ++i) {
    let arg = argv[i];
    if (arg == "--") { ++i; break; }
    let match = /^(?:(-\w)(?:=(.*))?|(--\w{2,})(?:=(.*))?)$/.exec(arg), option, key;
    if (match) {
      if (config[arg]) option = config[key = arg]; // exact
      else if (match[1] != null) { // alias
        option = config[key = aliases[match[1].substring(1)]];
        if (option && match[2] != null) argv[i--] = match[2];
      } else if (match[3] != null) { // full
        option = config[key = match[3].substring(2)];
        if (option && match[4] != null) argv[i--] = match[4];
      }
    } else {
      if (arg.charCodeAt(0) == 45) option = config[key = arg]; // exact
      else { args.push(arg); continue; } // argument
    }
    if (option) {
      if (option.value) {
        // alias setting fixed values
        Object.keys(option.value).forEach(k => options[k] = option.value[k]);
      } else if (option.type == null || option.type === "b") {
        // boolean flag not taking a value
        options[key] = true;
      } else {
        if (i + 1 < argv.length && argv[i + 1].charCodeAt(0) != 45) {
          // non-boolean with given value
          switch (option.type) {
            case "i": options[key] = parseInt(argv[++i], 10); break;
            case "I": options[key] = (options[key] || []).concat(parseInt(argv[++i], 10)); break;
            case "f": options[key] = parseFloat(argv[++i]); break;
            case "F": options[key] = (options[key] || []).concat(parseFloat(argv[++i])); break;
            case "s": options[key] = String(argv[++i]); break;
            case "S": options[key] = (options[key] || []).concat(argv[++i].split(",")); break;
            default: unknown.push(arg); --i;
          }
        } else {
          // non-boolean with omitted value
          switch (option.type) {
            case "i":
            case "f": options[key] = option.default || 0; break;
            case "s": options[key] = option.default || ""; break;
            case "I":
            case "F":
            case "S": options[key] = option.default || []; break;
            default: unknown.push(arg);
          }
        }
      }
    } else unknown.push(arg);
  }
  while (i < k) trailing.push(argv[i++]); // trailing
  if (propagateDefaults) addDefaults(config, options);

  return { options, unknown, arguments: args, trailing };
}

exports.parse = parse;

/** Generates the help text for the specified configuration. */
function help(config, options) {
  if (!options) options = {};
  var indent = options.indent || 2;
  var padding = options.padding || 24;
  var eol = options.eol || "\n";
  var sbCategories = {};
  var sbOther = [];
  Object.keys(config).forEach(key => {
    var option = config[key];
    if (option.description == null) return;
    var text = "";
    while (text.length < indent) text += " ";
    text += "--" + key;
    if (option.alias) text += ", -" + option.alias;
    while (text.length < padding) text += " ";
    var sb;
    if (!options.noCategories && option.category) {
      if (!(sb = sbCategories[option.category])) {
        sbCategories[option.category] = sb = [];
      }
    } else {
      sb = sbOther;
    }
    if (Array.isArray(option.description)) {
      sb.push(text + option.description[0] + option.description.slice(1).map(line => {
        for (let i = 0; i < padding; ++i) line = " " + line;
        return eol + line;
      }).join(""));
    } else sb.push(text + option.description);
  });
  var sb = [];
  var hasCategories = false;
  Object.keys(sbCategories).forEach(category => {
    hasCategories = true;
    sb.push(eol + " " + colorsUtil.gray(category) + eol);
    sb.push(sbCategories[category].join(eol));
  });
  if (hasCategories) {
    sb.push(eol + " " + colorsUtil.gray("Other") + eol);
  }
  sb.push(sbOther.join(eol));
  return sb.join(eol);
}

exports.help = help;

/** Sanitizes an option value to be a valid value of the option's type. */
function sanitizeValue(value, type) {
  if (value != null) {
    switch (type) {
      case undefined:
      case "b": return Boolean(value);
      case "i": return Math.trunc(value) || 0;
      case "f": return Number(value) || 0;
      case "s": {
        if (value === true) return "";
        return String(value);
      }
      case "I": {
        if (!Array.isArray(value)) value = [ value ];
        return value.map(v => Math.trunc(v) || 0);
      }
      case "F": {
        if (!Array.isArray(value)) value = [ value ];
        return value.map(v => Number(v) || 0);
      }
      case "S": {
        if (!Array.isArray(value)) value = [ value ];
        return value.map(String);
      }
    }
  }
  return undefined;
}

/** Merges two sets of options into one, preferring the current over the parent set. */
function merge(config, currentOptions, parentOptions, parentBaseDir) {
  const mergedOptions = {};
  for (const [key, { type, mutuallyExclusive, isPath, useNodeResolution, cliOnly }] of Object.entries(config)) {
    let currentValue = sanitizeValue(currentOptions[key], type);
    let parentValue = sanitizeValue(parentOptions[key], type);
    if (currentValue == null) {
      if (parentValue != null) {
        // only parent value present
        if (cliOnly) continue;
        if (Array.isArray(parentValue)) {
          let exclude;
          if (isPath) {
            parentValue = parentValue.map(value => resolvePath(value, parentBaseDir, useNodeResolution));
          }
          if (mutuallyExclusive != null && (exclude = currentOptions[mutuallyExclusive])) {
            mergedOptions[key] = parentValue.filter(value => !exclude.includes(value));
          } else {
            mergedOptions[key] = parentValue.slice();
          }
        } else {
          if (isPath) {
            parentValue = resolvePath(parentValue, parentBaseDir, useNodeResolution);
          }
          mergedOptions[key] = parentValue;
        }
      }
    } else if (parentValue == null) {
      // only current value present
      if (Array.isArray(currentValue)) {
        mergedOptions[key] = currentValue.slice();
      } else {
        mergedOptions[key] = currentValue;
      }
    } else {
      // both current and parent values present
      if (Array.isArray(currentValue)) {
        if (cliOnly) {
          mergedOptions[key] = currentValue.slice();
          continue;
        }
        let exclude;
        if (isPath) {
          parentValue = parentValue.map(value => resolvePath(value, parentBaseDir, useNodeResolution));
        }
        if (mutuallyExclusive != null && (exclude = currentOptions[mutuallyExclusive])) {
          mergedOptions[key] = [
            ...currentValue,
            ...parentValue.filter(value => !currentValue.includes(value) && !exclude.includes(value))
          ];
        } else {
          mergedOptions[key] = [
            ...currentValue,
            ...parentValue.filter(value => !currentValue.includes(value)) // dedup
          ];
        }
      } else {
        mergedOptions[key] = currentValue;
      }
    }
  }
  return mergedOptions;
}

exports.merge = merge;

const dynrequire = typeof __webpack_require__ === "function"
  ? __non_webpack_require__
  : require;

/** Resolves a single possibly relative path. Keeps absolute paths, otherwise prepends baseDir. */
function resolvePath(p, baseDir, useNodeResolution = false) {
  if (path.isAbsolute(p)) return p;
  if (useNodeResolution && !p.startsWith(".")) {
    return dynrequire.resolve(p, { paths: [ baseDir ] });
  }
  return path.join(baseDir, p);
}

exports.resolvePath = resolvePath;

/** Populates default values on a parsed options result. */
function addDefaults(config, options) {
  for (const [key, { default: defaultValue }] of Object.entries(config)) {
    if (options[key] == null && defaultValue != null) {
      options[key] = defaultValue;
    }
  }
}

exports.addDefaults = addDefaults;

'''
'''--- cli/util/utf8.d.ts ---
/**
 * @fileoverview UTF8 utility definitions.
 * @license Apache-2.0
 */

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
export function length(string: string): number;

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
export function read(buffer: Uint8Array, start: number, end: number): string;

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
export function write(string: string, buffer: Uint8Array, offset: number): number;

'''
'''--- cli/util/utf8.js ---
/**
 * @fileoverview UTF8 utility.
 * @license Apache-2.0
 */

// @protobufjs/utf8

/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
  var len = 0,
      c = 0;
  for (var i = 0, l = string.length; i < l; ++i) {
    c = string.charCodeAt(i);
    if (c < 128)
      len += 1;
    else if (c < 2048)
      len += 2;
    else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
      ++i;
      len += 4;
    } else
      len += 3;
  }
  return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
  var len = end - start;
  if (len < 1)
    return "";
  var parts = null,
      chunk = [],
      i = 0, // char offset
      t;     // temporary
  while (start < end) {
    t = buffer[start++];
    if (t < 128)
      chunk[i++] = t;
    else if (t > 191 && t < 224)
      chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
    else if (t > 239 && t < 365) {
      t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
      chunk[i++] = 0xD800 + (t >> 10);
      chunk[i++] = 0xDC00 + (t & 1023);
    } else
      chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
    if (i > 8191) {
      (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
      i = 0;
    }
  }
  if (parts) {
    if (i)
      parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
    return parts.join("");
  }
  return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
  var start = offset,
      c1, // character 1
      c2; // character 2
  for (var i = 0; i < string.length; ++i) {
    c1 = string.charCodeAt(i);
    if (c1 < 128) {
      buffer[offset++] = c1;
    } else if (c1 < 2048) {
      buffer[offset++] = c1 >> 6 | 192;
      buffer[offset++] = c1 & 63 | 128;
    } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
      c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
      ++i;
      buffer[offset++] = c1 >> 18 | 240;
      buffer[offset++] = c1 >> 12 & 63 | 128;
      buffer[offset++] = c1 >> 6 & 63 | 128;
      buffer[offset++] = c1 & 63 | 128;
    } else {
      buffer[offset++] = c1 >> 12 | 224;
      buffer[offset++] = c1 >> 6 & 63 | 128;
      buffer[offset++] = c1 & 63 | 128;
    }
  }
  return offset - start;
};

'''
'''--- index.d.ts ---
import "./src/glue/js";
export * from "./src";

'''
'''--- index.js ---
try { require("source-map-support").install(); } catch (e) { /* nop */ }
require("ts-node").register({
  project: require("path").join(__dirname, "src", "tsconfig.json"),
  skipIgnore: true
});
require("./src/glue/js");
module.exports = require("./src");

'''
'''--- index.release.d.ts ---
/// <reference path="./dist/assemblyscript.d.ts" />
export * from "assemblyscript";

'''
'''--- index.release.js ---
module.exports = require("./dist/assemblyscript");

'''
'''--- lib/loader/README.md ---
# AssemblyScript Loader

A convenient loader for [AssemblyScript](https://assemblyscript.org) modules. Demangles module exports to a friendly object structure compatible with TypeScript definitions and provides useful utility to read/write data from/to memory.

[Documentation](https://assemblyscript.org/loader.html)

'''
'''--- lib/loader/index.d.ts ---
/// <reference lib="esnext.bigint" />

export interface ResultObject {
  module: WebAssembly.Module;
  instance: WebAssembly.Instance;
}

/** WebAssembly imports with an optional env object and two levels of nesting. */
export type Imports = {
  [key: string]: Record<string,unknown> | undefined;
  env?: {
    memory?: WebAssembly.Memory;
    table?: WebAssembly.Table;
    seed?(): number;
    abort?(msg: number, file: number, line: number, column: number): void;
    trace?(msg: number, numArgs?: number, ...args: number[]): void;
    mark?(): void;
  };
};

/** Utility mixed in by the loader. */
export interface ASUtil {
  memory?: WebAssembly.Memory;
  table?: WebAssembly.Table;

  /** Explicit start function, if requested. */
  _start(): void;

  /** Copies a string's value from the module's memory. */
  __getString(ptr: number): string;
  /** Copies an ArrayBuffer's value from the module's memory. */
  __getArrayBuffer(ptr: number): ArrayBuffer;

  /** Copies an array's values from the module's memory. Infers the array type from RTTI. */
  __getArray(ptr: number): number[];
  /** Copies an Int8Array's values from the module's memory. */
  __getInt8Array(ptr: number): Int8Array;
  /** Copies an Uint8Array's values from the module's memory. */
  __getUint8Array(ptr: number): Uint8Array;
  /** Copies an Uint8ClampedArray's values from the module's memory. */
  __getUint8ClampedArray(ptr: number): Uint8ClampedArray;
  /** Copies an Int16Array's values from the module's memory. */
  __getInt16Array(ptr: number): Int16Array;
  /** Copies an Uint16Array's values from the module's memory. */
  __getUint16Array(ptr: number): Uint16Array;
  /** Copies an Int32Array's values from the module's memory. */
  __getInt32Array(ptr: number): Int32Array;
  /** Copies an Uint32Array's values from the module's memory. */
  __getUint32Array(ptr: number): Uint32Array;
  /** Copies an Int32Array's values from the module's memory. */
  __getInt64Array?(ptr: number): BigInt64Array;
  /** Copies an Uint32Array's values from the module's memory. */
  __getUint64Array?(ptr: number): BigUint64Array;
  /** Copies a Float32Array's values from the module's memory. */
  __getFloat32Array(ptr: number): Float32Array;
  /** Copies a Float64Array's values from the module's memory. */
  __getFloat64Array(ptr: number): Float64Array;

  /** Gets a live view on an array's values in the module's memory. Infers the array type from RTTI. */
  __getArrayView(ptr: number): ArrayBufferView;
  /** Gets a live view on an Int8Array's values in the module's memory. */
  __getInt8ArrayView(ptr: number): Int8Array;
  /** Gets a live view on an Uint8Array's values in the module's memory. */
  __getUint8ArrayView(ptr: number): Uint8Array;
  /** Gets a live view on an Uint8ClampedArray's values in the module's memory. */
  __getUint8ClampedArrayView(ptr: number): Uint8ClampedArray;
  /** Gets a live view on an Int16Array's values in the module's memory. */
  __getInt16ArrayView(ptr: number): Int16Array;
  /** Gets a live view on an Uint16Array's values in the module's memory. */
  __getUint16ArrayView(ptr: number): Uint16Array;
  /** Gets a live view on an Int32Array's values in the module's memory. */
  __getInt32ArrayView(ptr: number): Int32Array;
  /** Gets a live view on an Uint32Array's values in the module's memory. */
  __getUint32ArrayView(ptr: number): Uint32Array;
  /** Gets a live view on an Int32Array's values in the module's memory. */
  __getInt64ArrayView?(ptr: number): BigInt64Array;
  /** Gets a live view on an Uint32Array's values in the module's memory. */
  __getUint64ArrayView?(ptr: number): BigUint64Array;
  /** Gets a live view on a Float32Array's values in the module's memory. */
  __getFloat32ArrayView(ptr: number): Float32Array;
  /** Gets a live view on a Float64Array's values in the module's memory. */
  __getFloat64ArrayView(ptr: number): Float64Array;

  /** Tests whether a managed object is an instance of the class represented by the specified base id. */
  __instanceof(ptr: number, baseId: number): boolean;
  /** Allocates a new string in the module's memory and returns a reference (pointer) to it. */
  __newString(str: string): number;
  /** Allocates a new ArrayBuffer in the module's memory and returns a reference (pointer) to it. */
  __newArrayBuffer(buf: ArrayBuffer): number;
  /** Allocates a new array in the module's memory and returns a reference (pointer) to it. */
  __newArray(id: number, values: ArrayLike<number>): number;

  /** Allocates an instance of the class represented by the specified id. */
  __new(size: number, id: number): number;
  /** Pins a managed object externally, preventing it from becoming garbage collected. */
  __pin(ptr: number): number;
  /** Unpins a managed object externally, allowing it to become garbage collected. */
  __unpin(ptr: number): void;
  /** Performs a full garbage collection cycle. */
  __collect(incremental?: boolean): void;
}

/** Asynchronously instantiates an AssemblyScript module from anything that can be instantiated. */
export declare function instantiate<T extends Record<string,unknown>>(
  source: WebAssembly.Module | BufferSource | Response | PromiseLike<WebAssembly.Module | BufferSource | Response>,
  imports?: Imports
): Promise<ResultObject & { exports: ASUtil & T }>;

/** Synchronously instantiates an AssemblyScript module from a WebAssembly.Module or binary buffer. */
export declare function instantiateSync<T extends Record<string,unknown>>(
  source: WebAssembly.Module | BufferSource,
  imports?: Imports
): ResultObject & { exports: ASUtil & T };

/** Asynchronously instantiates an AssemblyScript module from a response, i.e. as obtained by `fetch`. */
export declare function instantiateStreaming<T extends Record<string,unknown>>(
  source: Response | PromiseLike<Response>,
  imports?: Imports
): Promise<ResultObject & { exports: ASUtil & T }>;

/** Demangles an AssemblyScript module's exports to a friendly object structure. */
export declare function demangle<T extends Record<string,unknown>>(
  exports: Record<string,unknown>,
  extendedExports?: Record<string,unknown>
): T;

'''
'''--- lib/loader/index.js ---
// Runtime header offsets
const ID_OFFSET = -8;
const SIZE_OFFSET = -4;

// Runtime ids
const ARRAYBUFFER_ID = 0;
const STRING_ID = 1;
// const ARRAYBUFFERVIEW_ID = 2;

// Runtime type information
const ARRAYBUFFERVIEW = 1 << 0;
const ARRAY = 1 << 1;
const STATICARRAY = 1 << 2;
// const SET = 1 << 3;
// const MAP = 1 << 4;
const VAL_ALIGN_OFFSET = 6;
// const VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;
const VAL_SIGNED = 1 << 11;
const VAL_FLOAT = 1 << 12;
// const VAL_NULLABLE = 1 << 13;
const VAL_MANAGED = 1 << 14;
// const KEY_ALIGN_OFFSET = 15;
// const KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;
// const KEY_SIGNED = 1 << 20;
// const KEY_FLOAT = 1 << 21;
// const KEY_NULLABLE = 1 << 22;
// const KEY_MANAGED = 1 << 23;

// Array(BufferView) layout
const ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;
const ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;
const ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;
const ARRAYBUFFERVIEW_SIZE = 12;
const ARRAY_LENGTH_OFFSET = 12;
const ARRAY_SIZE = 16;

const BIGINT = typeof BigUint64Array !== "undefined";
const THIS = Symbol();

const STRING_SMALLSIZE = 192; // break-even point in V8
const STRING_CHUNKSIZE = 1024; // mitigate stack overflow
const utf16 = new TextDecoder("utf-16le", { fatal: true }); // != wtf16

/** Gets a string from memory. */
function getStringImpl(buffer, ptr) {
  let len = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2] >>> 1;
  const wtf16 = new Uint16Array(buffer, ptr, len);
  if (len <= STRING_SMALLSIZE) return String.fromCharCode(...wtf16);
  try {
    return utf16.decode(wtf16);
  } catch {
    let str = "", off = 0;
    while (len - off > STRING_CHUNKSIZE) {
      str += String.fromCharCode(...wtf16.subarray(off, off += STRING_CHUNKSIZE));
    }
    return str + String.fromCharCode(...wtf16.subarray(off));
  }
}

/** Prepares the base module prior to instantiation. */
function preInstantiate(imports) {
  const extendedExports = {};

  function getString(memory, ptr) {
    if (!memory) return "<yet unknown>";
    return getStringImpl(memory.buffer, ptr);
  }

  // add common imports used by stdlib for convenience
  const env = (imports.env = imports.env || {});
  env.abort = env.abort || function abort(msg, file, line, colm) {
    const memory = extendedExports.memory || env.memory; // prefer exported, otherwise try imported
    throw Error(`abort: ${getString(memory, msg)} at ${getString(memory, file)}:${line}:${colm}`);
  };
  env.trace = env.trace || function trace(msg, n, ...args) {
    const memory = extendedExports.memory || env.memory;
    console.log(`trace: ${getString(memory, msg)}${n ? " " : ""}${args.slice(0, n).join(", ")}`);
  };
  env.seed = env.seed || Date.now;
  imports.Math = imports.Math || Math;
  imports.Date = imports.Date || Date;

  return extendedExports;
}

const E_NOEXPORTRUNTIME = "Operation requires compiling with --exportRuntime";
const F_NOEXPORTRUNTIME = function() { throw Error(E_NOEXPORTRUNTIME); };

/** Prepares the final module once instantiation is complete. */
function postInstantiate(extendedExports, instance) {
  const exports = instance.exports;
  const memory = exports.memory;
  const table = exports.table;
  const __new = exports.__new || F_NOEXPORTRUNTIME;
  const __pin = exports.__pin || F_NOEXPORTRUNTIME;
  const __unpin = exports.__unpin || F_NOEXPORTRUNTIME;
  const __collect = exports.__collect || F_NOEXPORTRUNTIME;
  const __rtti_base = exports.__rtti_base;
  const getRttiCount = __rtti_base
    ? function (arr) { return arr[__rtti_base >>> 2]; }
    : F_NOEXPORTRUNTIME;

  extendedExports.__new = __new;
  extendedExports.__pin = __pin;
  extendedExports.__unpin = __unpin;
  extendedExports.__collect = __collect;

  /** Gets the runtime type info for the given id. */
  function getInfo(id) {
    const U32 = new Uint32Array(memory.buffer);
    const count = getRttiCount(U32);
    if ((id >>>= 0) >= count) throw Error(`invalid id: ${id}`);
    return U32[(__rtti_base + 4 >>> 2) + id * 2];
  }

  /** Gets and validate runtime type info for the given id for array like objects */
  function getArrayInfo(id) {
    const info = getInfo(id);
    if (!(info & (ARRAYBUFFERVIEW | ARRAY | STATICARRAY))) throw Error(`not an array: ${id}, flags=${info}`);
    return info;
  }

  /** Gets the runtime base id for the given id. */
  function getBase(id) {
    const U32 = new Uint32Array(memory.buffer);
    const count = getRttiCount(U32);
    if ((id >>>= 0) >= count) throw Error(`invalid id: ${id}`);
    return U32[(__rtti_base + 4 >>> 2) + id * 2 + 1];
  }

  /** Gets the runtime alignment of a collection's values. */
  function getValueAlign(info) {
    return 31 - Math.clz32((info >>> VAL_ALIGN_OFFSET) & 31); // -1 if none
  }

  /** Gets the runtime alignment of a collection's keys. */
  // function getKeyAlign(info) {
  //   return 31 - Math.clz32((info >>> KEY_ALIGN_OFFSET) & 31); // -1 if none
  // }

  /** Allocates a new string in the module's memory and returns its pointer. */
  function __newString(str) {
    if (str == null) return 0;
    const length = str.length;
    const ptr = __new(length << 1, STRING_ID);
    const U16 = new Uint16Array(memory.buffer);
    for (var i = 0, p = ptr >>> 1; i < length; ++i) U16[p + i] = str.charCodeAt(i);
    return ptr;
  }

  extendedExports.__newString = __newString;

  /** Allocates a new ArrayBuffer in the module's memory and returns its pointer. */
  function __newArrayBuffer(buf) {
    if (buf == null) return 0;
    const bufview = new Uint8Array(buf);
    const ptr = __new(bufview.length, ARRAYBUFFER_ID);
    const U8 = new Uint8Array(memory.buffer);
    U8.set(bufview, ptr);
    return ptr;
  }

  extendedExports.__newArrayBuffer = __newArrayBuffer;

  /** Reads a string from the module's memory by its pointer. */
  function __getString(ptr) {
    if (!ptr) return null;
    const buffer = memory.buffer;
    const id = new Uint32Array(buffer)[ptr + ID_OFFSET >>> 2];
    if (id !== STRING_ID) throw Error(`not a string: ${ptr}`);
    return getStringImpl(buffer, ptr);
  }

  extendedExports.__getString = __getString;

  /** Gets the view matching the specified alignment, signedness and floatness. */
  function getView(alignLog2, signed, float) {
    const buffer = memory.buffer;
    if (float) {
      switch (alignLog2) {
        case 2: return new Float32Array(buffer);
        case 3: return new Float64Array(buffer);
      }
    } else {
      switch (alignLog2) {
        case 0: return new (signed ? Int8Array : Uint8Array)(buffer);
        case 1: return new (signed ? Int16Array : Uint16Array)(buffer);
        case 2: return new (signed ? Int32Array : Uint32Array)(buffer);
        case 3: return new (signed ? BigInt64Array : BigUint64Array)(buffer);
      }
    }
    throw Error(`unsupported align: ${alignLog2}`);
  }

  /** Allocates a new array in the module's memory and returns its pointer. */
  function __newArray(id, values) {
    const info = getArrayInfo(id);
    const align = getValueAlign(info);
    const length = values.length;
    const buf = __new(length << align, info & STATICARRAY ? id : ARRAYBUFFER_ID);
    let result;
    if (info & STATICARRAY) {
      result = buf;
    } else {
      __pin(buf);
      const arr = __new(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);
      __unpin(buf);
      const U32 = new Uint32Array(memory.buffer);
      U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = buf;
      U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;
      U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length << align;
      if (info & ARRAY) U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length;
      result = arr;
    }
    const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);
    if (info & VAL_MANAGED) {
      for (let i = 0; i < length; ++i) {
        const value = values[i];
        view[(buf >>> align) + i] = value;
      }
    } else {
      view.set(values, buf >>> align);
    }
    return result;
  }

  extendedExports.__newArray = __newArray;

  /** Gets a live view on an array's values in the module's memory. Infers the array type from RTTI. */
  function __getArrayView(arr) {
    const U32 = new Uint32Array(memory.buffer);
    const id = U32[arr + ID_OFFSET >>> 2];
    const info = getArrayInfo(id);
    const align = getValueAlign(info);
    let buf = info & STATICARRAY
      ? arr
      : U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
    const length = info & ARRAY
      ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2]
      : U32[buf + SIZE_OFFSET >>> 2] >>> align;
    return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf >>>= align, buf + length);
  }

  extendedExports.__getArrayView = __getArrayView;

  /** Copies an array's values from the module's memory. Infers the array type from RTTI. */
  function __getArray(arr) {
    const input = __getArrayView(arr);
    const len = input.length;
    const out = new Array(len);
    for (let i = 0; i < len; i++) out[i] = input[i];
    return out;
  }

  extendedExports.__getArray = __getArray;

  /** Copies an ArrayBuffer's value from the module's memory. */
  function __getArrayBuffer(ptr) {
    const buffer = memory.buffer;
    const length = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2];
    return buffer.slice(ptr, ptr + length);
  }

  extendedExports.__getArrayBuffer = __getArrayBuffer;

  /** Copies a typed array's values from the module's memory. */
  function getTypedArray(Type, alignLog2, ptr) {
    return new Type(getTypedArrayView(Type, alignLog2, ptr));
  }

  /** Gets a live view on a typed array's values in the module's memory. */
  function getTypedArrayView(Type, alignLog2, ptr) {
    const buffer = memory.buffer;
    const U32 = new Uint32Array(buffer);
    const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
    return new Type(buffer, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);
  }

  /** Attach a set of get TypedArray and View functions to the exports. */
  function attachTypedArrayFunctions(ctor, name, align) {
    extendedExports[`__get${name}`] = getTypedArray.bind(null, ctor, align);
    extendedExports[`__get${name}View`] = getTypedArrayView.bind(null, ctor, align);
  }

  [
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
  ].forEach(ctor => {
    attachTypedArrayFunctions(ctor, ctor.name, 31 - Math.clz32(ctor.BYTES_PER_ELEMENT));
  });

  if (BIGINT) {
    [BigUint64Array, BigInt64Array].forEach(ctor => {
      attachTypedArrayFunctions(ctor, ctor.name.slice(3), 3);
    });
  }

  /** Tests whether an object is an instance of the class represented by the specified base id. */
  function __instanceof(ptr, baseId) {
    const U32 = new Uint32Array(memory.buffer);
    let id = U32[ptr + ID_OFFSET >>> 2];
    if (id <= getRttiCount(U32)) {
      do {
        if (id == baseId) return true;
        id = getBase(id);
      } while (id);
    }
    return false;
  }

  extendedExports.__instanceof = __instanceof;

  // Pull basic exports to extendedExports so code in preInstantiate can use them
  extendedExports.memory = extendedExports.memory || memory;
  extendedExports.table  = extendedExports.table  || table;

  // Demangle exports and provide the usual utility on the prototype
  return demangle(exports, extendedExports);
}

function isResponse(src) {
  return typeof Response !== "undefined" && src instanceof Response;
}

function isModule(src) {
  return src instanceof WebAssembly.Module;
}

/** Asynchronously instantiates an AssemblyScript module from anything that can be instantiated. */
export async function instantiate(source, imports = {}) {
  if (isResponse(source = await source)) return instantiateStreaming(source, imports);
  const module = isModule(source) ? source : await WebAssembly.compile(source);
  const extended = preInstantiate(imports);
  const instance = await WebAssembly.instantiate(module, imports);
  const exports = postInstantiate(extended, instance);
  return { module, instance, exports };
}

/** Synchronously instantiates an AssemblyScript module from a WebAssembly.Module or binary buffer. */
export function instantiateSync(source, imports = {}) {
  const module = isModule(source) ? source : new WebAssembly.Module(source);
  const extended = preInstantiate(imports);
  const instance = new WebAssembly.Instance(module, imports);
  const exports = postInstantiate(extended, instance);
  return { module, instance, exports };
}

/** Asynchronously instantiates an AssemblyScript module from a response, i.e. as obtained by `fetch`. */
export async function instantiateStreaming(source, imports = {}) {
  if (!WebAssembly.instantiateStreaming) {
    return instantiate(
      isResponse(source = await source)
        ? source.arrayBuffer()
        : source,
      imports
    );
  }
  const extended = preInstantiate(imports);
  const result = await WebAssembly.instantiateStreaming(source, imports);
  const exports = postInstantiate(extended, result.instance);
  return { ...result, exports };
}

/** Demangles an AssemblyScript module's exports to a friendly object structure. */
export function demangle(exports, extendedExports = {}) {
  const setArgumentsLength = exports["__argumentsLength"]
    ? length => { exports["__argumentsLength"].value = length; }
    : exports["__setArgumentsLength"] || exports["__setargc"] || (() => { /* nop */ });
  for (let internalName in exports) {
    if (!Object.prototype.hasOwnProperty.call(exports, internalName)) continue;
    const elem = exports[internalName];
    let parts = internalName.split(".");
    let curr = extendedExports;
    while (parts.length > 1) {
      let part = parts.shift();
      if (!Object.prototype.hasOwnProperty.call(curr, part)) curr[part] = {};
      curr = curr[part];
    }
    let name = parts[0];
    let hash = name.indexOf("#");
    if (hash >= 0) {
      const className = name.substring(0, hash);
      const classElem = curr[className];
      if (typeof classElem === "undefined" || !classElem.prototype) {
        const ctor = function(...args) {
          return ctor.wrap(ctor.prototype.constructor(0, ...args));
        };
        ctor.prototype = {
          valueOf() { return this[THIS]; }
        };
        ctor.wrap = function(thisValue) {
          return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });
        };
        if (classElem) Object.getOwnPropertyNames(classElem).forEach(name =>
          Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name))
        );
        curr[className] = ctor;
      }
      name = name.substring(hash + 1);
      curr = curr[className].prototype;
      if (/^(get|set):/.test(name)) {
        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {
          let getter = exports[internalName.replace("set:", "get:")];
          let setter = exports[internalName.replace("get:", "set:")];
          Object.defineProperty(curr, name, {
            get() { return getter(this[THIS]); },
            set(value) { setter(this[THIS], value); },
            enumerable: true
          });
        }
      } else {
        if (name === 'constructor') {
          (curr[name] = (...args) => {
            setArgumentsLength(args.length);
            return elem(...args);
          }).original = elem;
        } else { // instance method
          (curr[name] = function(...args) { // !
            setArgumentsLength(args.length);
            return elem(this[THIS], ...args);
          }).original = elem;
        }
      }
    } else {
      if (/^(get|set):/.test(name)) {
        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {
          Object.defineProperty(curr, name, {
            get: exports[internalName.replace("set:", "get:")],
            set: exports[internalName.replace("get:", "set:")],
            enumerable: true
          });
        }
      } else if (typeof elem === "function" && elem !== setArgumentsLength) {
        (curr[name] = (...args) => {
          setArgumentsLength(args.length);
          return elem(...args);
        }).original = elem;
      } else {
        curr[name] = elem;
      }
    }
  }
  return extendedExports;
}

export default {
  instantiate,
  instantiateSync,
  instantiateStreaming,
  demangle
};

'''
'''--- lib/loader/package.json ---
{
  "name": "@assemblyscript/loader",
  "description": "A convenient loader for AssemblyScript modules.",
  "keywords": [
    "assemblyscript",
    "loader",
    "glue",
    "interop",
    "webassembly",
    "wasm"
  ],
  "version": "0.0.0",
  "author": "Daniel Wirtz <dcode+assemblyscript@dcode.io>",
  "license": "Apache-2.0",
  "homepage": "https://assemblyscript.org",
  "repository": {
    "type": "git",
    "url": "https://github.com/AssemblyScript/assemblyscript.git",
    "directory": "lib/loader"
  },
  "bugs": {
    "url": "https://github.com/AssemblyScript/assemblyscript/issues"
  },
  "type": "module",
  "main": "index.js",
  "types": "index.d.ts",
  "exports": {
    "import": "./index.js",
    "require": "./umd/index.js"
  },
  "scripts": {
    "asbuild": "npm run asbuild:default && npm run asbuild:legacy",
    "asbuild:default": "node ../../bin/asc tests/assembly/index.ts --binaryFile tests/build/default.wasm --exportRuntime",
    "asbuild:legacy": "node ../../bin/asc tests/assembly/index.ts --disable mutable-globals --binaryFile tests/build/legacy.wasm --exportRuntime",
    "build": "npx esm2umd loader index.js > umd/index.js",
    "test": "node tests && node tests/umd"
  },
  "files": [
    "index.d.ts",
    "index.js",
    "package.json",
    "umd/index.d.ts",
    "umd/index.js",
    "umd/package.json",
    "README.md"
  ],
  "devDependencies": {
    "esm2umd": "^0.1.2"
  }
}

'''
'''--- lib/loader/tests/assembly/index.ts ---
export { memory };

export const COLOR: string = "red";

export function strlen(str: string): i32 {
  return str.length;
}

export namespace math {
  export function add(a: i32, b: i32): i32 {
    return a + b;
  }
}

export class Car {
  static readonly MAX_DOORS: i32 = 5;
  static readonly usualDoors: i32 = 3;

  numDoors: i32;
  private doorsOpen: bool = false;

  get isDoorsOpen(): bool { return this.doorsOpen; }
  set isDoorsOpen(value: bool) { this.doorsOpen = value; }

  constructor(numDoors: i32) {
    this.numDoors = numDoors;
  }

  openDoors(): bool {
    if (this.doorsOpen) return false;
    this.doorsOpen = true;
    return true;
  }

  closeDoors(): bool {
    if (!this.doorsOpen) return false;
    this.doorsOpen = false;
    return true;
  }
}

export function sum(arr: Int32Array): i32 {
  var v = 0;
  for (let i = 0, k = arr.length; i < k; ++i) v += arr[i];
  return v;
}

export function sumStatic(arr: StaticArray<i32>): i32 {
  var v = 0;
  for (let i = 0, k = arr.length; i < k; ++i) v += arr[i];
  return v;
}

export function changeLength(arr: Array<i32>, length: i32): void {
  arr.length = length;
}

export function varadd(a: i32 = 1, b: i32 = 2): i32 {
  return a + b;
}

export const varadd_ref = varadd;

export function calladd(fn: (a: i32, b: i32) => i32, a: i32, b: i32): i32 {
  return fn(a, b);
}

export function dotrace(num: f64): void {
  trace("The answer is", 1, num);
}

export const UINT8ARRAY_ID = idof<Uint8Array>();
export const INT16ARRAY_ID = idof<Int16Array>();
export const UINT16ARRAY_ID = idof<Uint16Array>();
export const INT32ARRAY_ID = idof<Int32Array>();
export const UINT32ARRAY_ID = idof<Uint32Array>();
export const FLOAT32ARRAY_ID = idof<Float32Array>();
export const ARRAYI32_ID = idof<Array<i32>>();
export const STATICARRAYI32_ID = idof<StaticArray<i32>>();
export const STATICARRAYU32_ID = idof<StaticArray<u32>>();
export const STATICARRAYU8_ID = idof<StaticArray<u8>>();
export const STATICARRAYI16_ID = idof<StaticArray<i16>>();
export const STATICARRAYF32_ID = idof<StaticArray<f32>>();

export function newFloat32Array(size: i32): Float32Array {
  return new Float32Array(size);
}

export function modifyFloat32Array(array: Float32Array, index: i32, value: f32): void {
  array[index] = value;
}

'''
'''--- lib/loader/tests/assembly/tsconfig.json ---
{
  "extends": "../../../../std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}
'''
'''--- lib/loader/tests/index.html ---
<script>var exports = {};</script>
<script src="../index.js"></script>
<script>
function assert(c) {
  if (!c) throw Error("assertion failed");
}
(async () => {
  var module;

  module = await exports.instantiate(fetch("./build/untouched.wasm"));
  assert(module.memory);

  module = await exports.instantiate(await fetch("./build/untouched.wasm"));
  assert(module.memory);

  module = await exports.instantiate((await fetch("./build/untouched.wasm")).arrayBuffer());
  assert(module.memory);

  module = await exports.instantiate(await (await fetch("./build/untouched.wasm")).arrayBuffer());
  assert(module.memory);

  module = await exports.instantiateStreaming(fetch("./build/untouched.wasm"));
  assert(module.memory);

  module = await exports.instantiateStreaming(await fetch("./build/untouched.wasm"));
  assert(module.memory);

  var instantiateStreaming = WebAssembly.instantiateStreaming;
  delete WebAssembly.instantiateStreaming;

  module = await exports.instantiate(fetch("./build/untouched.wasm"));
  assert(module.memory);

  module = await exports.instantiate(await fetch("./build/untouched.wasm"));
  assert(module.memory);

  module = await exports.instantiateStreaming(fetch("./build/untouched.wasm"));
  assert(module.memory);

  module = await exports.instantiateStreaming(await fetch("./build/untouched.wasm"));
  assert(module.memory);

  WebAssembly.instantiateStreaming = instantiateStreaming;

  console.log("ok");
})();
</script>

'''
'''--- lib/loader/tests/index.js ---
import fs from "fs";
import assert from "assert";
import { inspect } from "util";
import loader from "../index.js";
import { dirname } from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

test("default.wasm");
test("legacy.wasm");

testInstantiate("default.wasm");
testInstantiate("legacy.wasm");

function test(file) {
  var buffer = fs.readFileSync(__dirname + "/build/" + file);
  var result = loader.instantiateSync(buffer, {});
  const exports = result.exports;

  console.log(inspect(exports, true, 100, true));

  // should export memory
  assert(exports.memory instanceof WebAssembly.Memory);
  assert(typeof exports.memory.compare === "function");

  // should be able to get an exported string
  assert.strictEqual(exports.__getString(exports.COLOR), "red");

  // should be able to allocate and work with a new small string
  {
    let str = "Hello world!ð¤­¢";
    let ref = exports.__newString(str);
    assert.strictEqual(exports.__getString(ref), str);
    assert.strictEqual(exports.strlen(ref), str.length);
  }

  // should be able to allocate and work with a new small ArrayBuffer
  {
    let input  = new Uint8Array([1, 2, 3, 4]);
    let bufPtr = exports.__newArrayBuffer(input.buffer);
    let output = new Uint8Array(exports.__getArrayBuffer(bufPtr));

    assert.deepStrictEqual(output, input);
  }

  // should be able to allocate and work with a new big string
  {
    let str = `
      âˆ€ âˆ âˆ‚ âˆƒ âˆ„ âˆ… âˆ† âˆ‡ âˆˆ âˆ‰ âˆŠ âˆ‹ âˆŒ âˆ âˆŽ âˆ âˆ âˆ‘ âˆ’ âˆ“ âˆ” âˆ• âˆ– âˆ— âˆ˜ âˆ™ âˆš âˆ›
      âˆœ âˆ âˆž âˆŸ âˆ  âˆ¡ âˆ¢ âˆ£ âˆ¤ âˆ¥ âˆ¦ âˆ§ âˆ¨ âˆ© âˆª âˆ« âˆ¬ âˆ­ âˆ® âˆ¯ âˆ° âˆ± âˆ² âˆ³ âˆ´ âˆµ âˆ¶ âˆ·
      âˆ¸ âˆ¹ âˆº âˆ» âˆ¼ âˆ½ âˆ¾ âˆ¿ â‰€ â‰ â‰‚ â‰ƒ â‰„ â‰… â‰† â‰‡ â‰ˆ â‰‰ â‰Š â‰‹ â‰Œ â‰ â‰Ž â‰ â‰ â‰‘ â‰’ â‰“
      â‰” â‰• â‰– â‰— â‰˜ â‰™ â‰š â‰› â‰œ â‰ â‰ž â‰Ÿ â‰  â‰¡ â‰¢ â‰£ â‰¤ â‰¥ â‰¦ â‰§ â‰¨ â‰© â‰ª â‰« â‰¬ â‰­ â‰® â‰¯
      â‰° â‰± â‰² â‰³ â‰´ â‰µ â‰¶ â‰· â‰¸ â‰¹ â‰º â‰» â‰¼ â‰½ â‰¾ â‰¿
    `;
    let ref = exports.__newString(str);
    assert.strictEqual(exports.__getString(ref), str);
    assert.strictEqual(exports.strlen(ref), str.length);
  }

  // should be able to allocate a typed array
  {
    let arr = [1, 2, 3, 4, 5, 0x80000000 | 0];
    let ref = exports.__newArray(exports.INT32ARRAY_ID, arr);
    assert(exports.__instanceof(ref, exports.INT32ARRAY_ID));

    // should be able to get the values of an array
    assert.deepStrictEqual(exports.__getArray(ref), arr);

    // should be able to get a view on an array
    assert.deepStrictEqual(exports.__getArrayView(ref), new Int32Array(arr));

    // should be able to sum up its values
    assert.strictEqual(exports.sum(ref), arr.reduce((a, b) => (a + b) | 0, 0) | 0);
  }

  // should be able to allocate a typed array
  {
    let arr = [1, 2, 3, 4, 5, 0x80000000 | 0];
    let ref = exports.__newArray(exports.STATICARRAYI32_ID, arr);
    assert(exports.__instanceof(ref, exports.STATICARRAYI32_ID));

    // should be able to get the values of an array
    assert.deepStrictEqual(exports.__getArray(ref), arr);

    // should be able to get a view on an array
    assert.deepStrictEqual(exports.__getArrayView(ref), new Int32Array(arr));

    // should be able to sum up its values
    assert.strictEqual(exports.sumStatic(ref), arr.reduce((a, b) => (a + b) | 0, 0) | 0);
  }

  /*
  {
    let arrU8Arr = new Uint8Array([0, 1, 2]);
    let refU8Arr = module.__newUint8Array(arrU8Arr);
    assert(module.__instanceof(refU8Arr, module.UINT8ARRAY_ID));
    assert.deepStrictEqual(module.__getUint8Array(refU8Arr), arrU8Arr);

    let arrU16Arr = new Uint16Array([0, 0x7FFF, 0xFFFF]);
    let refU16Arr = module.__newUint16Array(arrU16Arr);
    assert(module.__instanceof(refU16Arr, module.UINT16ARRAY_ID));
    assert.deepStrictEqual(module.__getUint16Array(refU16Arr), arrU16Arr);

    let arrI16Arr = new Int16Array([0, -1, -2]);
    let refI16Arr = module.__newInt16Array(arrI16Arr);
    assert(module.__instanceof(refI16Arr, module.INT16ARRAY_ID));
    assert.deepStrictEqual(module.__getInt16Array(refI16Arr), arrI16Arr);
  }
  */

  // should be able to distinguish between signed and unsigned
  {
    let values = [0, 255, 127];
    let arr = new Uint8Array(values);
    let ref = exports.__newArray(exports.UINT8ARRAY_ID, arr);
    assert(exports.__instanceof(ref, exports.UINT8ARRAY_ID));
    assert.deepStrictEqual(exports.__getUint8Array(ref), arr);
    assert.deepStrictEqual(exports.__getUint8ArrayView(ref), arr);
    assert.deepStrictEqual(exports.__getArray(ref), values);
  }

  // should be able to distinguish between signed and unsigned for static array layout
  {
    let arr = [0, 255, 127];
    let ref = exports.__newArray(exports.STATICARRAYU8_ID, arr);
    assert(exports.__instanceof(ref, exports.STATICARRAYU8_ID));
    assert.deepStrictEqual(exports.__getArray(ref), arr);
  }

  // should be able to distinguish between signed and unsigned
  {
    let values = [0, 0xFFFF, -0x00FF];
    let arr = new Int16Array(values);
    let ref = exports.__newArray(exports.INT16ARRAY_ID, arr);
    assert(exports.__instanceof(ref, exports.INT16ARRAY_ID));
    assert.deepStrictEqual(exports.__getInt16Array(ref), arr);
    assert.deepStrictEqual(exports.__getInt16ArrayView(ref), arr);
    assert.deepStrictEqual(exports.__getArray(ref), [0, -1, -255]);
  }

  // should be able to distinguish between signed and unsigned for static array layout
  {
    let arr = [0, 0xFFFF, -0x00FF];
    let ref = exports.__newArray(exports.STATICARRAYI16_ID, arr);
    assert(exports.__instanceof(ref, exports.STATICARRAYI16_ID));
    assert.deepStrictEqual(exports.__getArray(ref), [0, -1, -255]);
  }

  // should be able to distinguish between signed and unsigned
  {
    let values = [1, -1 >>> 0, 0x80000000];
    let arr = new Uint32Array(values);
    let ref = exports.__newArray(exports.UINT32ARRAY_ID, arr);
    assert(exports.__instanceof(ref, exports.UINT32ARRAY_ID));
    assert.deepStrictEqual(exports.__getUint32Array(ref), arr);
    assert.deepStrictEqual(exports.__getUint32ArrayView(ref), arr);
    assert.deepStrictEqual(exports.__getArray(ref), values);
  }

  // should be able to distinguish between signed and unsigned with static array layout
  {
    let arr = [1, -1 >>> 0, 0x80000000];
    let ref = exports.__newArray(exports.STATICARRAYU32_ID, arr);
    assert(exports.__instanceof(ref, exports.STATICARRAYU32_ID));
    assert.deepStrictEqual(exports.__getArray(ref), arr);
  }

  // should be able to distinguish between integer and float
  {
    let values = [0.0, 1.5, 2.5];
    let arr = new Float32Array(values);
    let ref = exports.__newArray(exports.FLOAT32ARRAY_ID, arr);
    assert(exports.__instanceof(ref, exports.FLOAT32ARRAY_ID));
    assert.deepStrictEqual(exports.__getFloat32Array(ref), arr);
    assert.deepStrictEqual(exports.__getFloat32ArrayView(ref), arr);
    assert.deepStrictEqual(exports.__getArray(ref), values);
  }

  // should be able to distinguish between integer and float static arrays
  {
    let arr = [0.0, 1.5, 2.5];
    let ref = exports.__newArray(exports.STATICARRAYF32_ID, arr);
    assert(exports.__instanceof(ref, exports.STATICARRAYF32_ID));
    assert.deepStrictEqual(exports.__getArray(ref), arr);
  }

  // should be able to work with normal arrays
  {
    let arr = [1, 2, 3, 4, 5];
    let ref = exports.__newArray(exports.ARRAYI32_ID, arr);
    assert(exports.__instanceof(ref, exports.ARRAYI32_ID));
    exports.changeLength(ref, 3);
    assert.deepStrictEqual(exports.__getArray(ref), [1, 2, 3]);
  }

  // should be able to pin references externally
  {
    let ptr = exports.__newString("test");
    exports.__pin(ptr);
    try { exports.__pin(ptr); assert(false); } catch (e) { /* nop */ }
    exports.__unpin(ptr);
    try { exports.__unpin(ptr); assert(false); } catch (e) { /* nop */ }
  }

  // should be able to correctly call a function with variable arguments
  assert.strictEqual(exports.varadd(), 3);
  assert.strictEqual(exports.varadd(2, 3), 5);
  assert.strictEqual(exports.varadd(2), 4);

  // TBD: table is no more exported by default to allow more optimizations

  // should be able to get a function from the table and just call it with variable arguments
  // var fn = module.getFunction(module.varadd_ref);
  // assert.strictEqual(fn(), 3);
  // assert.strictEqual(fn(2, 3), 5);
  // assert.strictEqual(fn(2), 4);

  // should be able to create a new function and call it from WASM
  // ref = module.newFunction(module.varadd);
  // assert.strictEqual(module.calladd(ref, 2, 3), 5);

  // should be able to use a class
  var car = new exports.Car(5);
  assert.strictEqual(car.numDoors, 5);
  assert.strictEqual(car.isDoorsOpen, 0);
  car.openDoors();
  assert.strictEqual(car.isDoorsOpen, 1);
  car.closeDoors();
  assert.strictEqual(car.isDoorsOpen, 0);
  assert(typeof +car === "number"); // uses Car.prototype.valueOf to obtain `thisPtr`

  // should be able to use trace
  exports.dotrace(42);

  // should be able to mutate an array in place using getArrayView
  {
    let ptr = exports.__newArray(exports.FLOAT32ARRAY_ID, [1, 2, 3]);
    let view = exports.__getArrayView(ptr);
    assert.deepStrictEqual(view, new Float32Array([1, 2, 3]));
    exports.modifyFloat32Array(ptr, 0, 4);
    assert.deepStrictEqual(view, new Float32Array([4, 2, 3]));
  }

  // should be able to mutate an array in place using getFloat32Array
  {
    let ptr = exports.newFloat32Array(3);
    let view = exports.__getFloat32ArrayView(ptr);
    let arr = exports.__getFloat32Array(ptr);
    assert.deepStrictEqual(view, new Float32Array([0, 0, 0]));
    assert.deepStrictEqual(arr, new Float32Array([0, 0, 0]));
    exports.modifyFloat32Array(ptr, 0, 3);
    exports.modifyFloat32Array(ptr, 1, 2);
    exports.modifyFloat32Array(ptr, 2, 1);
    assert.deepStrictEqual(view, new Float32Array([3, 2, 1]));
    assert.deepStrictEqual(arr, new Float32Array([0, 0, 0]));
  }
}

function testInstantiate(file) {
  // should be able to instantiate from a buffer
  (async () => {
    const { exports, instance, module } = await loader.instantiate(fs.readFileSync(__dirname + "/build/" + file), {});
    assert(exports.memory);
    assert(instance && instance instanceof WebAssembly.Instance);
    assert(module   && module instanceof WebAssembly.Module);
  })();

  // should be able to instantiate from a wasm module
  (async () => {
    const wasmModule = new WebAssembly.Module(fs.readFileSync(__dirname + "/build/" + file));
    const { exports, instance, module } = await loader.instantiate(wasmModule, {});
    assert(exports.memory);
    assert(instance && instance instanceof WebAssembly.Instance);
    assert(module   && module instanceof WebAssembly.Module);
  })();

  // should be able to instantiate from a promise yielding a buffer
  (async () => {
    const { exports, instance, module } = await loader.instantiate(fs.promises.readFile(__dirname + "/build/" + file), {});
    assert(exports.memory);
    assert(instance && instance instanceof WebAssembly.Instance);
    assert(module   && module instanceof WebAssembly.Module);
  })();

  // should be able to mimic instantiateStreaming under node (for now)
  (async () => {
    const { exports, instance, module } = await loader.instantiateStreaming(fs.promises.readFile(__dirname + "/build/" + file), {});
    assert(exports.memory);
    assert(instance && instance instanceof WebAssembly.Instance);
    assert(module   && module instanceof WebAssembly.Module);
  })();
}

'''
'''--- lib/loader/tests/umd/index.js ---
const assert = require("assert");
const loader = require("../../umd");

assert(typeof loader.instantiate === "function");

'''
'''--- lib/loader/tests/umd/package.json ---
{
  "type": "commonjs"
}

'''
'''--- lib/loader/umd/index.d.ts ---
export * from "../index";

'''
'''--- lib/loader/umd/index.js ---
// GENERATED FILE. DO NOT EDIT.
var loader = (function(exports) {
  "use strict";
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.instantiate = instantiate;
  exports.instantiateSync = instantiateSync;
  exports.instantiateStreaming = instantiateStreaming;
  exports.demangle = demangle;
  exports.default = void 0;
  // Runtime header offsets
  const ID_OFFSET = -8;
  const SIZE_OFFSET = -4; // Runtime ids
  
  const ARRAYBUFFER_ID = 0;
  const STRING_ID = 1; // const ARRAYBUFFERVIEW_ID = 2;
  // Runtime type information
  
  const ARRAYBUFFERVIEW = 1 << 0;
  const ARRAY = 1 << 1;
  const STATICARRAY = 1 << 2; // const SET = 1 << 3;
  // const MAP = 1 << 4;
  
  const VAL_ALIGN_OFFSET = 6; // const VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;
  
  const VAL_SIGNED = 1 << 11;
  const VAL_FLOAT = 1 << 12; // const VAL_NULLABLE = 1 << 13;
  
  const VAL_MANAGED = 1 << 14; // const KEY_ALIGN_OFFSET = 15;
  // const KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;
  // const KEY_SIGNED = 1 << 20;
  // const KEY_FLOAT = 1 << 21;
  // const KEY_NULLABLE = 1 << 22;
  // const KEY_MANAGED = 1 << 23;
  // Array(BufferView) layout
  
  const ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;
  const ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;
  const ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;
  const ARRAYBUFFERVIEW_SIZE = 12;
  const ARRAY_LENGTH_OFFSET = 12;
  const ARRAY_SIZE = 16;
  const BIGINT = typeof BigUint64Array !== "undefined";
  const THIS = Symbol();
  const STRING_SMALLSIZE = 192; // break-even point in V8
  
  const STRING_CHUNKSIZE = 1024; // mitigate stack overflow
  
  const utf16 = new TextDecoder("utf-16le", {
    fatal: true
  }); // != wtf16
  
  /** Gets a string from memory. */
  
  function getStringImpl(buffer, ptr) {
    let len = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2] >>> 1;
    const wtf16 = new Uint16Array(buffer, ptr, len);
    if (len <= STRING_SMALLSIZE) return String.fromCharCode(...wtf16);
  
    try {
      return utf16.decode(wtf16);
    } catch {
      let str = "",
          off = 0;
  
      while (len - off > STRING_CHUNKSIZE) {
        str += String.fromCharCode(...wtf16.subarray(off, off += STRING_CHUNKSIZE));
      }
  
      return str + String.fromCharCode(...wtf16.subarray(off));
    }
  }
  /** Prepares the base module prior to instantiation. */
  
  
  function preInstantiate(imports) {
    const extendedExports = {};
  
    function getString(memory, ptr) {
      if (!memory) return "<yet unknown>";
      return getStringImpl(memory.buffer, ptr);
    } // add common imports used by stdlib for convenience
  
  
    const env = imports.env = imports.env || {};
  
    env.abort = env.abort || function abort(msg, file, line, colm) {
      const memory = extendedExports.memory || env.memory; // prefer exported, otherwise try imported
  
      throw Error(`abort: ${getString(memory, msg)} at ${getString(memory, file)}:${line}:${colm}`);
    };
  
    env.trace = env.trace || function trace(msg, n, ...args) {
      const memory = extendedExports.memory || env.memory;
      console.log(`trace: ${getString(memory, msg)}${n ? " " : ""}${args.slice(0, n).join(", ")}`);
    };
  
    env.seed = env.seed || Date.now;
    imports.Math = imports.Math || Math;
    imports.Date = imports.Date || Date;
    return extendedExports;
  }
  
  const E_NOEXPORTRUNTIME = "Operation requires compiling with --exportRuntime";
  
  const F_NOEXPORTRUNTIME = function () {
    throw Error(E_NOEXPORTRUNTIME);
  };
  /** Prepares the final module once instantiation is complete. */
  
  
  function postInstantiate(extendedExports, instance) {
    const exports = instance.exports;
    const memory = exports.memory;
    const table = exports.table;
  
    const __new = exports.__new || F_NOEXPORTRUNTIME;
  
    const __pin = exports.__pin || F_NOEXPORTRUNTIME;
  
    const __unpin = exports.__unpin || F_NOEXPORTRUNTIME;
  
    const __collect = exports.__collect || F_NOEXPORTRUNTIME;
  
    const __rtti_base = exports.__rtti_base;
    const getRttiCount = __rtti_base ? function (arr) {
      return arr[__rtti_base >>> 2];
    } : F_NOEXPORTRUNTIME;
    extendedExports.__new = __new;
    extendedExports.__pin = __pin;
    extendedExports.__unpin = __unpin;
    extendedExports.__collect = __collect;
    /** Gets the runtime type info for the given id. */
  
    function getInfo(id) {
      const U32 = new Uint32Array(memory.buffer);
      const count = getRttiCount(U32);
      if ((id >>>= 0) >= count) throw Error(`invalid id: ${id}`);
      return U32[(__rtti_base + 4 >>> 2) + id * 2];
    }
    /** Gets and validate runtime type info for the given id for array like objects */
  
  
    function getArrayInfo(id) {
      const info = getInfo(id);
      if (!(info & (ARRAYBUFFERVIEW | ARRAY | STATICARRAY))) throw Error(`not an array: ${id}, flags=${info}`);
      return info;
    }
    /** Gets the runtime base id for the given id. */
  
  
    function getBase(id) {
      const U32 = new Uint32Array(memory.buffer);
      const count = getRttiCount(U32);
      if ((id >>>= 0) >= count) throw Error(`invalid id: ${id}`);
      return U32[(__rtti_base + 4 >>> 2) + id * 2 + 1];
    }
    /** Gets the runtime alignment of a collection's values. */
  
  
    function getValueAlign(info) {
      return 31 - Math.clz32(info >>> VAL_ALIGN_OFFSET & 31); // -1 if none
    }
    /** Gets the runtime alignment of a collection's keys. */
    // function getKeyAlign(info) {
    //   return 31 - Math.clz32((info >>> KEY_ALIGN_OFFSET) & 31); // -1 if none
    // }
  
    /** Allocates a new string in the module's memory and returns its pointer. */
  
  
    function __newString(str) {
      if (str == null) return 0;
      const length = str.length;
  
      const ptr = __new(length << 1, STRING_ID);
  
      const U16 = new Uint16Array(memory.buffer);
  
      for (var i = 0, p = ptr >>> 1; i < length; ++i) U16[p + i] = str.charCodeAt(i);
  
      return ptr;
    }
  
    extendedExports.__newString = __newString;
    /** Reads a string from the module's memory by its pointer. */
  
    function __getString(ptr) {
      if (!ptr) return null;
      const buffer = memory.buffer;
      const id = new Uint32Array(buffer)[ptr + ID_OFFSET >>> 2];
      if (id !== STRING_ID) throw Error(`not a string: ${ptr}`);
      return getStringImpl(buffer, ptr);
    }
  
    extendedExports.__getString = __getString;
    /** Gets the view matching the specified alignment, signedness and floatness. */
  
    function getView(alignLog2, signed, float) {
      const buffer = memory.buffer;
  
      if (float) {
        switch (alignLog2) {
          case 2:
            return new Float32Array(buffer);
  
          case 3:
            return new Float64Array(buffer);
        }
      } else {
        switch (alignLog2) {
          case 0:
            return new (signed ? Int8Array : Uint8Array)(buffer);
  
          case 1:
            return new (signed ? Int16Array : Uint16Array)(buffer);
  
          case 2:
            return new (signed ? Int32Array : Uint32Array)(buffer);
  
          case 3:
            return new (signed ? BigInt64Array : BigUint64Array)(buffer);
        }
      }
  
      throw Error(`unsupported align: ${alignLog2}`);
    }
    /** Allocates a new array in the module's memory and returns its pointer. */
  
  
    function __newArray(id, values) {
      const info = getArrayInfo(id);
      const align = getValueAlign(info);
      const length = values.length;
  
      const buf = __new(length << align, info & STATICARRAY ? id : ARRAYBUFFER_ID);
  
      let result;
  
      if (info & STATICARRAY) {
        result = buf;
      } else {
        __pin(buf);
  
        const arr = __new(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);
  
        __unpin(buf);
  
        const U32 = new Uint32Array(memory.buffer);
        U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = buf;
        U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;
        U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length << align;
        if (info & ARRAY) U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length;
        result = arr;
      }
  
      const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);
  
      if (info & VAL_MANAGED) {
        for (let i = 0; i < length; ++i) {
          const value = values[i];
          view[(buf >>> align) + i] = value;
        }
      } else {
        view.set(values, buf >>> align);
      }
  
      return result;
    }
  
    extendedExports.__newArray = __newArray;
    /** Gets a live view on an array's values in the module's memory. Infers the array type from RTTI. */
  
    function __getArrayView(arr) {
      const U32 = new Uint32Array(memory.buffer);
      const id = U32[arr + ID_OFFSET >>> 2];
      const info = getArrayInfo(id);
      const align = getValueAlign(info);
      let buf = info & STATICARRAY ? arr : U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
      const length = info & ARRAY ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2] : U32[buf + SIZE_OFFSET >>> 2] >>> align;
      return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf >>>= align, buf + length);
    }
  
    extendedExports.__getArrayView = __getArrayView;
    /** Copies an array's values from the module's memory. Infers the array type from RTTI. */
  
    function __getArray(arr) {
      const input = __getArrayView(arr);
  
      const len = input.length;
      const out = new Array(len);
  
      for (let i = 0; i < len; i++) out[i] = input[i];
  
      return out;
    }
  
    extendedExports.__getArray = __getArray;
    /** Copies an ArrayBuffer's value from the module's memory. */
  
    function __getArrayBuffer(ptr) {
      const buffer = memory.buffer;
      const length = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2];
      return buffer.slice(ptr, ptr + length);
    }
  
    extendedExports.__getArrayBuffer = __getArrayBuffer;
    /** Copies a typed array's values from the module's memory. */
  
    function getTypedArray(Type, alignLog2, ptr) {
      return new Type(getTypedArrayView(Type, alignLog2, ptr));
    }
    /** Gets a live view on a typed array's values in the module's memory. */
  
  
    function getTypedArrayView(Type, alignLog2, ptr) {
      const buffer = memory.buffer;
      const U32 = new Uint32Array(buffer);
      const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
      return new Type(buffer, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);
    }
    /** Attach a set of get TypedArray and View functions to the exports. */
  
  
    function attachTypedArrayFunctions(ctor, name, align) {
      extendedExports[`__get${name}`] = getTypedArray.bind(null, ctor, align);
      extendedExports[`__get${name}View`] = getTypedArrayView.bind(null, ctor, align);
    }
  
    [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array].forEach(ctor => {
      attachTypedArrayFunctions(ctor, ctor.name, 31 - Math.clz32(ctor.BYTES_PER_ELEMENT));
    });
  
    if (BIGINT) {
      [BigUint64Array, BigInt64Array].forEach(ctor => {
        attachTypedArrayFunctions(ctor, ctor.name.slice(3), 3);
      });
    }
    /** Tests whether an object is an instance of the class represented by the specified base id. */
  
  
    function __instanceof(ptr, baseId) {
      const U32 = new Uint32Array(memory.buffer);
      let id = U32[ptr + ID_OFFSET >>> 2];
  
      if (id <= getRttiCount(U32)) {
        do {
          if (id == baseId) return true;
          id = getBase(id);
        } while (id);
      }
  
      return false;
    }
  
    extendedExports.__instanceof = __instanceof; // Pull basic exports to extendedExports so code in preInstantiate can use them
  
    extendedExports.memory = extendedExports.memory || memory;
    extendedExports.table = extendedExports.table || table; // Demangle exports and provide the usual utility on the prototype
  
    return demangle(exports, extendedExports);
  }
  
  function isResponse(src) {
    return typeof Response !== "undefined" && src instanceof Response;
  }
  
  function isModule(src) {
    return src instanceof WebAssembly.Module;
  }
  /** Asynchronously instantiates an AssemblyScript module from anything that can be instantiated. */
  
  
  async function instantiate(source, imports = {}) {
    if (isResponse(source = await source)) return instantiateStreaming(source, imports);
    const module = isModule(source) ? source : await WebAssembly.compile(source);
    const extended = preInstantiate(imports);
    const instance = await WebAssembly.instantiate(module, imports);
    const exports = postInstantiate(extended, instance);
    return {
      module,
      instance,
      exports
    };
  }
  /** Synchronously instantiates an AssemblyScript module from a WebAssembly.Module or binary buffer. */
  
  
  function instantiateSync(source, imports = {}) {
    const module = isModule(source) ? source : new WebAssembly.Module(source);
    const extended = preInstantiate(imports);
    const instance = new WebAssembly.Instance(module, imports);
    const exports = postInstantiate(extended, instance);
    return {
      module,
      instance,
      exports
    };
  }
  /** Asynchronously instantiates an AssemblyScript module from a response, i.e. as obtained by `fetch`. */
  
  
  async function instantiateStreaming(source, imports = {}) {
    if (!WebAssembly.instantiateStreaming) {
      return instantiate(isResponse(source = await source) ? source.arrayBuffer() : source, imports);
    }
  
    const extended = preInstantiate(imports);
    const result = await WebAssembly.instantiateStreaming(source, imports);
    const exports = postInstantiate(extended, result.instance);
    return { ...result,
      exports
    };
  }
  /** Demangles an AssemblyScript module's exports to a friendly object structure. */
  
  
  function demangle(exports, extendedExports = {}) {
    const setArgumentsLength = exports["__argumentsLength"] ? length => {
      exports["__argumentsLength"].value = length;
    } : exports["__setArgumentsLength"] || exports["__setargc"] || (() => {
      /* nop */
    });
  
    for (let internalName in exports) {
      if (!Object.prototype.hasOwnProperty.call(exports, internalName)) continue;
      const elem = exports[internalName];
      let parts = internalName.split(".");
      let curr = extendedExports;
  
      while (parts.length > 1) {
        let part = parts.shift();
        if (!Object.prototype.hasOwnProperty.call(curr, part)) curr[part] = {};
        curr = curr[part];
      }
  
      let name = parts[0];
      let hash = name.indexOf("#");
  
      if (hash >= 0) {
        const className = name.substring(0, hash);
        const classElem = curr[className];
  
        if (typeof classElem === "undefined" || !classElem.prototype) {
          const ctor = function (...args) {
            return ctor.wrap(ctor.prototype.constructor(0, ...args));
          };
  
          ctor.prototype = {
            valueOf() {
              return this[THIS];
            }
  
          };
  
          ctor.wrap = function (thisValue) {
            return Object.create(ctor.prototype, {
              [THIS]: {
                value: thisValue,
                writable: false
              }
            });
          };
  
          if (classElem) Object.getOwnPropertyNames(classElem).forEach(name => Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name)));
          curr[className] = ctor;
        }
  
        name = name.substring(hash + 1);
        curr = curr[className].prototype;
  
        if (/^(get|set):/.test(name)) {
          if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {
            let getter = exports[internalName.replace("set:", "get:")];
            let setter = exports[internalName.replace("get:", "set:")];
            Object.defineProperty(curr, name, {
              get() {
                return getter(this[THIS]);
              },
  
              set(value) {
                setter(this[THIS], value);
              },
  
              enumerable: true
            });
          }
        } else {
          if (name === 'constructor') {
            (curr[name] = (...args) => {
              setArgumentsLength(args.length);
              return elem(...args);
            }).original = elem;
          } else {
            // instance method
            (curr[name] = function (...args) {
              // !
              setArgumentsLength(args.length);
              return elem(this[THIS], ...args);
            }).original = elem;
          }
        }
      } else {
        if (/^(get|set):/.test(name)) {
          if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {
            Object.defineProperty(curr, name, {
              get: exports[internalName.replace("set:", "get:")],
              set: exports[internalName.replace("get:", "set:")],
              enumerable: true
            });
          }
        } else if (typeof elem === "function" && elem !== setArgumentsLength) {
          (curr[name] = (...args) => {
            setArgumentsLength(args.length);
            return elem(...args);
          }).original = elem;
        } else {
          curr[name] = elem;
        }
      }
    }
  
    return extendedExports;
  }
  
  var _default = {
    instantiate,
    instantiateSync,
    instantiateStreaming,
    demangle
  };
  exports.default = _default;
  return exports;
})({});
if (typeof define === 'function' && define.amd) define([], function() { return loader; });
else if (typeof module === 'object' && typeof exports==='object') module.exports = loader;

'''
'''--- lib/loader/umd/package.json ---
{
  "private": true,
  "type": "commonjs"
}

'''
'''--- lib/parse/README.md ---
# WebAssembly Parser

A WebAssembly binary parser in WebAssembly. Super small, super fast, with TypeScript support.

API
---

* **parse**(binary: `Uint8Array`, options?: `ParseOptions`): `void`<br />
  Parses the contents of a WebAssembly binary according to the specified options.

* **ParseOptions**<br />
  Options specified to the parser. The `onSection` callback determines the sections being evaluated in detail.

  * **onSection**?(id: `SectionId`, payloadOff: `number`, payloadLen: `number`, nameOff: `number`, nameLen: `number`): `boolean`<br />
    Called with each section in the binary. Returning `true` evaluates the section.

  * **onType**?(index: `number`, form: `number`): `void`<br />
    Called with each function type if the type section is evaluated.

  * **onTypeParam**?(index: `number`, paramIndex: `number`, paramType: `Type`): `void`<br />
    Called with each function parameter if the type section is evaluated.

  * **onTypeReturn**?(index: `number`, returnIndex: `number`, returnType: `Type`): `void`<br />
    Called with each function return type if the type section is evaluated.

  * **onImport**?(index: `number`, kind: `ExternalKind`, moduleOff: `number`, moduleLen: `number`, fieldOff: `number`, fieldLen: `number`): `void`<br />
    Called with each import if the import section is evaluated.

  * **onFunctionImport**?(index: `number`, type: `number`): `void`<br />
    Called with each function import if the import section is evaluated.

  * **onTableImport**?(index: `number`, type: `Type`, initial: `number`, maximum: `number`, flags: `number`): `void`<br />
    Called with each table import if the import section is evaluated.

  * **onMemoryImport**?(index: `number`, initial: `number`, maximum: `number`, flags: `number`): `void`<br />
    Called with each memory import if the import section is evaluated.

  * **onGlobalImport**?(index: `number`, type: `Type`, mutability: `number`): `void`<br />
    Called with each global import if the import section is evaluated.

  * **onMemory**?(index: `number`, initial: `number`, maximum: `number`, flags: `number`): `void`<br />
    Called with each memory if the memory section is evaluated.

  * **onFunction**?(index: `number`, typeIndex: `number`): `void`<br />
    Called with each function if the function section is evaluated.

  * **onGlobal**?(index: `number`, type: `Type`, mutability: `number`): `void`<br />
    Called with each global if the global section is evaluated.

  * **onStart**?(index: `number`): `void`<br />
    Called with the start function index if the start section is evaluated.

  * **onExport**?(index: `number`, kind: `ExternalKind`, kindIndex: `number`, nameOff: `number`, nameLen: `number`): `void`<br />
    Called with each export if the export section is evaluated.

  * **onSourceMappingURL**?(offset: `number`, length: `number`): `void`<br />
    Called with the source map URL if the 'sourceMappingURL' section is evaluated.

  * **onModuleName**?(offset: `number`, length: `number`): `void`<br />
    Called with the module name if present and the 'name' section is evaluated.

  * **onFunctionName**?(index: `number`, offset: `number`, length: `number`): `void`<br />
    Called with each function name if present and the 'name' section is evaluated.

  * **onLocalName**?(funcIndex: `number`, index: `number`, offset: `number`, length: `number`): `void`<br />
    Called with each local name if present and the 'name' section is evaluated.

* **Type**<br />
  A value or element type, depending on context.

  | Name    | Value
  |---------|-------
  | i32     | 0x7f
  | i64     | 0x7e
  | f32     | 0x7d
  | f64     | 0x7c
  | anyfunc | 0x70
  | func    | 0x60
  | none    | 0x40

* **SectionId**<br />
  Numerical id of the current section.

  | Name     | Value
  |----------|-------
  | Custom   | 0
  | Type     | 1
  | Import   | 2
  | Function | 3
  | Table    | 4
  | Memory   | 5
  | Global   | 6
  | Export   | 7
  | Start    | 8
  | Element  | 9
  | Code     | 10
  | Data     | 11

* **ExternalKind**<br />
  Kind of an export or import.

  | Name     | Value
  |----------|-------
  | Function | 0
  | Table    | 1
  | Memory   | 2
  | Global   | 3

'''
'''--- lib/parse/assembly/index.ts ---
/** A WebAssembly module that parses WebAssembly modules. */

// Common constants shared between AssemblyScript and TypeScript
import {
  SectionId,
  ExternalKind,
  NameType,
  MAX_PAGES,
  MAX_ELEMS,
  Opcode
} from "../src/common";

import * as opt from "./options";

/** Current offset in memory. */
var off: usize = 0;

/** Reads an unsigned integer from memory. */
function readUint<T>(): u32 {
  var pos = off;
  var val = <u32>load<T>(pos);
  off = pos + sizeof<T>();
  return val;
}

/** Reads an unsigned 64-bit integer from memory. */
function readUint64(): u64 {
  var pos = off;
  var val = load<u64>(pos);
  off = pos + 8;
  return val;
}

/** Reads a LEB128-encoded unsigned integer from memory. */
function readVaruint(size: u32): u32 {
  var val: u32 = 0;
  var shl: u32 = 0;
  var byt: u32;
  var pos = off;
  do {
    byt = load<u8>(pos++);
    val |= (byt & 0x7F) << shl;
    if (!(byt & 0x80)) break;
    shl += 7;
  } while (true);
  off = pos;
  return val;
}

/** Reads a LEB128-encoded signed integer from memory. */
function readVarint(size: u32): i32 {
  var val: u32 = 0;
  var shl: u32 = 0;
  var byt: u32;
  var pos = off;
  do {
    byt = load<u8>(pos++);
    val |= (byt & 0x7F) << shl;
    shl += 7;
  } while (byt & 0x80);
  off = pos;
  return select<u32>(val | (~0 << shl), val, shl < size && (byt & 0x40) != 0);
}

/** Reads a LEB128-encoded signed 64-bit integer from memory. */
function readVarint64(): i64 {
  var val: u64 = 0;
  var shl: u64 = 0;
  var byt: u64;
  var pos = off;
  do {
    byt = load<u8>(pos++);
    val |= (byt & 0x7F) << shl;
    shl += 7;
  } while (byt & 0x80);
  off = pos;
  return select<u64>(val | (~0 << shl), val, shl < 64 && (byt & 0x40) != 0);
}

function skipInitExpr(): void {
  var op = readUint<u8>();
  switch (op) {
    case Opcode.i32_const: {
      readVarint(32);
      break;
    }
    case Opcode.i64_const: {
      readVarint64();
      break;
    }
    case Opcode.f32_const: {
      readUint<u32>();
      break;
    }
    case Opcode.f64_const: {
      readUint64();
      break;
    }
    case Opcode.get_global: {
      readVaruint(32);
      break;
    }
    default: unreachable(); // MVP
  }
  if (readUint<u8>() != Opcode.end) unreachable();
}

/** Starts parsing the module that has been placed in memory. */
export function parse(begin: usize, end: usize): void {
  off = begin;
  var magic = readUint<u32>();
  if (magic != 0x6D736100) unreachable();
  var version = readUint<u32>();
  if (version != 1) unreachable();
  var fun_space_index: u32 = 0;
  var glo_space_index: u32 = 0;
  var mem_space_index: u32 = 0;
  var tbl_space_index: u32 = 0;
  while (off < end) {
    // let section_off = off;
    let id = readVaruint(7);
    let payload_len = readVaruint(32);
    let name_off = 0;
    let name_len = 0;
    if (!id) {
      let before = off;
      name_len = readVaruint(32);
      name_off = off;
      off += name_len;
      payload_len -= off - before;
    } else if (id > <u32>SectionId.Data) unreachable();
    let payload_off = off;
    if (opt.onSection(
      id,
      payload_off,
      payload_len,
      name_off,
      name_len
    )) {
      switch (id) {
        case SectionId.Type: {
          let count = readVaruint(32);
          for (let index: u32 = 0; index < count; ++index) {
            let form = readVarint(7) & 0x7f;
            opt.onType(
              index,
              form
            );
            let paramCount = readVaruint(32);
            for (let paramIndex: u32 = 0; paramIndex < paramCount; ++paramIndex) {
              let paramType = readVarint(7) & 0x7f;
              opt.onTypeParam(
                index,
                paramIndex,
                paramType
              );
            }
            let returnCount = readVaruint(1); // MVP
            for (let returnIndex: u32 = 0; returnIndex < returnCount; ++returnIndex) {
              let returnType = readVarint(7) & 0x7f;
              opt.onTypeReturn(
                index,
                returnIndex,
                returnType
              );
            }
          }
          break;
        }
        case SectionId.Import: {
          let count = readVaruint(32);
          for (let index: u32 = 0; index < count; ++index) {
            let module_len = readVaruint(32);
            let module_off = off;
            off += module_len;
            let field_len = readVaruint(32);
            let field_off = off;
            off += field_len;
            let kind = readUint<u8>();
            opt.onImport(
              index,
              kind,
              module_off,
              module_len,
              field_off,
              field_len
            );
            switch (kind) {
              case ExternalKind.Function: {
                let type = readVaruint(32);
                opt.onFunctionImport(
                  fun_space_index++,
                  type
                );
                break;
              }
              case ExternalKind.Table: {
                let type = readVarint(7) & 0x7f;
                let flags = readVaruint(1);
                let initial = readVaruint(32);
                let maximum = flags & 1 ? readVaruint(32) : <u32>MAX_ELEMS;
                opt.onTableImport(
                  tbl_space_index++,
                  type,
                  initial,
                  maximum,
                  flags
                );
                break;
              }
              case ExternalKind.Memory: {
                let flags = readVaruint(1);
                let initial = readVaruint(32);
                let maximum = flags & 1 ? readVaruint(32) : <u32>MAX_PAGES;
                opt.onMemoryImport(
                  mem_space_index++,
                  initial,
                  maximum,
                  flags
                );
                break;
              }
              case ExternalKind.Global: {
                let type = readVarint(7) & 0x7f;
                let mutability = readVaruint(1);
                opt.onGlobalImport(
                  glo_space_index++,
                  type,
                  mutability
                );
                break;
              }
              default: unreachable();
            }
          }
          break;
        }
        case SectionId.Function: {
          let count = readVaruint(32);
          for (let i: u32 = 0; i < count; ++i) {
            let typeIndex = readVaruint(32);
            opt.onFunction(
              fun_space_index++,
              typeIndex
            );
          }
          break;
        }
        case SectionId.Table: {
          let count = readVaruint(32);
          for (let index: u32 = 0; index < count; ++index) {
            let type = readVaruint(7) & 0x7f;
            let flags = readVaruint(1);
            let initial = readVaruint(32);
            let maximum = flags & 1 ? readVaruint(32) : <u32>MAX_ELEMS;
            opt.onTable(
              tbl_space_index++,
              type,
              initial,
              maximum,
              flags
            );
          }
          break;
        }
        case SectionId.Memory: {
          let count = readVaruint(32);
          for (let index: u32 = 0; index < count; ++index) {
            let flags = readVaruint(1);
            let initial = readVaruint(32);
            let maximum = flags & 1 ? readVaruint(32) : <u32>MAX_PAGES;
            opt.onMemory(
              mem_space_index++,
              initial,
              maximum,
              flags
            );
          }
          break;
        }
        case SectionId.Global: {
          let count = readVaruint(32);
          for (let i: u32 = 0; i < count; ++i) {
            let type = readVarint(7) & 0x7f;
            let mutability = readVaruint(1);
            skipInitExpr();
            opt.onGlobal(
              glo_space_index++,
              type,
              mutability
            );
          }
          break;
        }
        case SectionId.Export: {
          let count = readVaruint(32);
          for (let index: u32 = 0; index < count; ++index) {
            let field_len = readVaruint(32);
            let field_off = off;
            off += field_len;
            let kind = readUint<u8>();
            let kind_index = readVaruint(32);
            opt.onExport(
              index,
              kind,
              kind_index,
              field_off,
              field_len
            );
          }
          break;
        }
        case SectionId.Start: {
          let index = readVaruint(32);
          opt.onStart(
            index
          );
          break;
        }
        case SectionId.Custom: {
          if (
            name_len == 4 &&
            load<u32>(name_off) == 0x656D616E // "name"
          ) {
            let name_type = readVaruint(7);
            let name_payload_len = readVaruint(32);
            let name_payload_off = off;
            switch (name_type) {
              case NameType.Module: {
                let module_name_len = readVaruint(32);
                let module_name_off = off;
                opt.onModuleName(
                  module_name_off,
                  module_name_len
                );
                break;
              }
              case NameType.Function: {
                let count = readVaruint(32);
                for (let i: u32 = 0; i < count; ++i) {
                  let fn_index = readVaruint(32);
                  let fn_name_len = readVaruint(32);
                  let fn_name_off = off;
                  off += fn_name_len;
                  opt.onFunctionName(
                    fn_index,
                    fn_name_off,
                    fn_name_len
                  );
                }
                break;
              }
              case NameType.Local: {
                let count = readVaruint(32);
                for (let i: u32 = 0; i < count; ++i) {
                  let fn_index = readVaruint(32);
                  let lc_count = readVaruint(32);
                  for (let j: u32 = 0; j < lc_count; ++j) {
                    let lc_index = readVaruint(32);
                    let lc_name_len = readVaruint(32);
                    let lc_name_off = off;
                    off += lc_name_len;
                    opt.onLocalName(
                      fn_index,
                      lc_index,
                      lc_name_off,
                      lc_name_len
                    );
                  }
                }
                break;
              }
              default: unreachable();
            }
            off = name_payload_off + name_payload_len; // ignore errors
            break;
          } else if (
            name_len == 16 &&
            load<u64>(name_off    ) == 0x614D656372756F73 &&  // "sourceMa"
            load<u64>(name_off + 8) == 0x4C5255676E697070     // "ppingURL"
          ) {
            let url_len = readVaruint(32);
            let url_off = off;
            off += url_len;
            opt.onSourceMappingURL(
              url_off,
              url_len
            );
          }
          off = payload_off + payload_len; // ignore errors
          break;
        }
        case SectionId.Element:
        case SectionId.Code:
        case SectionId.Data: { // skip
          off += payload_len;
          break;
        }
        default: unreachable();
      }
    } else { // skip
      off += payload_len;
    }
  }
  if (off != end) unreachable();
}

'''
'''--- lib/parse/assembly/options.ts ---
// Imported callbacks
export declare function onSection(id: u32, offset: u32, length: u32, nameOffset: u32, nameLength: u32): bool;
export declare function onType(index: u32, form: u32): void;
export declare function onTypeParam(index: u32, paramIndex: u32, paramType: u32): void;
export declare function onTypeReturn(index: u32, returnIndex: u32, returnType: u32): void;
export declare function onImport(index: u32, kind: u32, moduleOff: u32, moduleLen: u32, fieldOff: u32, fieldLen: u32): void;
export declare function onFunctionImport(index: u32, type: u32): void;
export declare function onTableImport(index: u32, type: u32, initial: u32, maximum: u32, flags: u32): void;
export declare function onMemoryImport(index: u32, initial: u32, maximum: u32, flags: u32): void;
export declare function onGlobalImport(index: u32, type: u32, mutability: u32): void;
export declare function onMemory(index: u32, initial: u32, maximum: u32, flags: u32): void;
export declare function onFunction(index: u32, typeIndex: u32): void;
export declare function onTable(index: u32, type: u32, initial: u32, maximum: u32, flags: u32): void;
export declare function onGlobal(index: u32, type: u32, mutability: u32): void;
export declare function onExport(index: u32, kind: u32, kindIndex: u32, nameOffset: u32, nameLength: u32): void;
export declare function onStart(index: u32): void;
export declare function onSourceMappingURL(offset: u32, length: u32): void;
export declare function onModuleName(offset: u32, length: u32): void;
export declare function onFunctionName(index: u32, offset: u32, length: u32): void;
export declare function onLocalName(funcIndex: u32, index: u32, offset: u32, length: u32): void;

'''
'''--- lib/parse/assembly/tsconfig.json ---
{
  "extends": "../../../std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- lib/parse/index.d.ts ---
export * from "./src";

'''
'''--- lib/parse/index.js ---
!function(A,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.asparse=e():A.asparse=e()}("undefined"!=typeof self?self:this,function(){return function(A){var e={};function n(o){if(e[o])return e[o].exports;var Q=e[o]={i:o,l:!1,exports:{}};return A[o].call(Q.exports,Q,Q.exports,n),Q.l=!0,Q.exports}return n.m=A,n.c=e,n.d=function(A,e,o){n.o(A,e)||Object.defineProperty(A,e,{enumerable:!0,get:o})},n.r=function(A){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(A,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(A,"__esModule",{value:!0})},n.t=function(A,e){if(1&e&&(A=n(A)),8&e)return A;if(4&e&&"object"==typeof A&&A&&A.__esModule)return A;var o=Object.create(null);if(n.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:A}),2&e&&"string"!=typeof A)for(var Q in A)n.d(o,Q,function(e){return A[e]}.bind(null,Q));return o},n.n=function(A){var e=A&&A.__esModule?function(){return A.default}:function(){return A};return n.d(e,"a",e),e},n.o=function(A,e){return Object.prototype.hasOwnProperty.call(A,e)},n.p="",n(n.s=0)}([function(A,e,n){A.exports=n(1)},function(A,e,n){"use strict";e.__esModule=!0;var o=n(2);e.Type=o.Type,e.SectionId=o.SectionId,e.ExternalKind=o.ExternalKind;var Q=null;e.parse=function A(e,n){n||(n={}),Q||(Q=new WebAssembly.Module(function(A){var e=A.length;if(e){for(var n=0,o=e;--o%4>1&&61===A.charCodeAt(o);)++n;e=Math.ceil(3*e)/4-n}for(var Q=new Uint8Array(e),B=0,I=0,E=0,r=0,i=A.length;r<i;){var C=A.charCodeAt(r++);if(61===C&&B>1)break;if(void 0===(C=t[C]))throw Error();switch(B){case 0:E=C,B=1;break;case 1:Q[I++]=E<<2|(48&C)>>4,E=C,B=2;break;case 2:Q[I++]=(15&E)<<4|(60&C)>>2,E=C,B=3;break;case 3:Q[I++]=(3&E)<<6|C,B=0}}if(1===B)throw Error();return Q}("AGFzbQEAAAABPQpgAn9/AGABfwF/YAV/f39/fwF/YAN/f38AYAZ/f39/f38AYAV/f39/fwBgBH9/f38AYAAAYAF/AGAAAX8CrgMUB29wdGlvbnMJb25TZWN0aW9uAAIHb3B0aW9ucwZvblR5cGUAAAdvcHRpb25zC29uVHlwZVBhcmFtAAMHb3B0aW9ucwxvblR5cGVSZXR1cm4AAwdvcHRpb25zCG9uSW1wb3J0AAQHb3B0aW9ucxBvbkZ1bmN0aW9uSW1wb3J0AAAHb3B0aW9ucw1vblRhYmxlSW1wb3J0AAUHb3B0aW9ucw5vbk1lbW9yeUltcG9ydAAGB29wdGlvbnMOb25HbG9iYWxJbXBvcnQAAwdvcHRpb25zCm9uRnVuY3Rpb24AAAdvcHRpb25zB29uVGFibGUABQdvcHRpb25zCG9uTWVtb3J5AAYHb3B0aW9ucwhvbkdsb2JhbAADB29wdGlvbnMIb25FeHBvcnQABQdvcHRpb25zB29uU3RhcnQACAdvcHRpb25zDG9uTW9kdWxlTmFtZQAAB29wdGlvbnMOb25GdW5jdGlvbk5hbWUAAwdvcHRpb25zC29uTG9jYWxOYW1lAAYHb3B0aW9ucxJvblNvdXJjZU1hcHBpbmdVUkwAAANlbnYGbWVtb3J5AgAAAwcGCQEHBwAHBgYBfwFBAAsHEgIGbWVtb3J5AgAFcGFyc2UAFwrlDAY/AQR/IwAhAANAIAAiAUEBaiEAIAEtAAAiAUH/AHEgA3QgAnIhAiABQYABcQRAIANBB2ohAwwBCwsgACQAIAILVgEEfyMAIQQDQCAEIgNBAWohBCADLQAAIgNB/wBxIAF0IAJyIQIgAUEHaiEBIANBgAFxDQALIAQkAEF/IAF0IAJyIAIgA0HAAHFBAEdBACABIABJGxsLPwICfwN+IwAhAANAIAAiAUEBaiEAIAExAAAiBEL/AIMgAoYgA4QhAyACQgd8IQIgBEKAAYNCAFINAAsgACQAC5wBAQJ/IwAiAS0AACEAIAFBAWokAAJAAkACQAJAAkACQCAAQcEARwRAIABBwgBGDQEgAEHDAEYNAiAAQcQARg0DIABBI0YNBAwFC0EgEBQaDAULEBUMBAsjACIAKAIAGiAAQQRqJAAMAwsjACIAKQMAGiAAQQhqJAAMAgsQExoMAQsACyMAIgEtAAAhACABQQFqJAAgAEELRwRAAAsL6QkBDX8gACQAIwAiACgCACECIABBBGokACACQYDCzesGRwRAAAsjACIAKAIAIQIgAEEEaiQAIAJBAUcEQAALQQAhAANAIwAgAUkEQBATIQQQEyEDQQAhBUEAIQIgBARAIARBC0sEQAALBSMAIQYQEyICIwAiBWokACADIwAgBmtrIQMLIAQjACIGIAMgBSACEAAEQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBEEBRwRAIARBAkYNAQJAIAQODAkAAAMEBQYHCAoKCgALDAoLEBMhBEEAIQIDQCACIARJBEAgAkEHEBRB/wBxEAEQEyEFQQAhAwNAIAMgBUkEQCACIANBBxAUQf8AcRACIANBAWohAwwBCwsQEyEFQQAhAwNAIAMgBUkEQCACIANBBxAUQf8AcRADIANBAWohAwwBCwsgAkEBaiECDAELCwwKCxATIQdBACEEA0AgBCAHSQRAEBMiAyMAIgVqJAAQEyIGIwAiCGokACMAIgktAAAhAiAJQQFqJAAgBCACIAUgAyAIIAYQBAJAAkACQAJAAkAgAgRAIAJBAWsOAwECAwQLIAoiAkEBaiEKIAIQExAFDAQLQQcQFEH/AHEhAxATIQUgACICQQFqIQAgAiADEBMgBUEBcQR/EBMFQX8LIAUQBgwDCxATIQMgCyICQQFqIQsgAhATIANBAXEEfxATBUH//wMLIAMQBwwCCyAMIgJBAWohDCACQQcQFEH/AHEQExAIDAELAAsgBEEBaiEEDAELCwwJCxATIQRBACEDA0AgAyAESQRAIAoiAkEBaiEKIAIQExAJIANBAWohAwwBCwsMCAsQEyEHQQAhBANAIAQgB0kEQBATQf8AcSEDEBMhBSAAIgJBAWohACACIAMQEyAFQQFxBH8QEwVBfwsgBRAKIARBAWohBAwBCwsMBwsQEyEGQQAhAwNAIAMgBkkEQBATIQQgCyICQQFqIQsgAhATIARBAXEEfxATBUH//wMLIAQQCyADQQFqIQMMAQsLDAYLEBMhBEEAIQMDQCADIARJBEBBBxAUQf8AcSEFEBMhBhAWIAwiAkEBaiEMIAIgBSAGEAwgA0EBaiEDDAELCwwFCxATIQNBACECA0AgAiADSQRAEBMiBCMAIgVqJAAjACIGLQAAIQcgBkEBaiQAIAIgBxATIAUgBBANIAJBAWohAgwBCwsMBAsQExAODAMLIAJBBEYEfyAFKAIAQe7CtasGRgVBAAsEQBATIQIQEyEEIwAhBQJAAkACQAJAIAIEQCACQQFGDQEgAkECRg0CDAMLEBMhAiMAIAIQDwwDCxATIQJBACEDA0AgAyACSQRAEBMhBhATIgcjACIIaiQAIAYgCCAHEBAgA0EBaiEDDAELCwwCCxATIQZBACECA0AgAiAGSQRAEBMhBxATIQhBACEDA0AgAyAISQRAEBMhCRATIg0jACIOaiQAIAcgCSAOIA0QESADQQFqIQMMAQsLIAJBAWohAgwBCwsMAQsACyAEIAVqJAAMAwUgAkEQRgR/IAUpAwBC897Vk7es2abhAFEFQQALBH8gBUEIaikDAELw4KXz9qyVqcwAUQVBAAsEQBATIgIjACIEaiQAIAQgAhASCwsgAyAGaiQADAILIwAgA2okAAwBCwALBSMAIANqJAALDAELCyMAIAFHBEAACwsDAAELACAQc291cmNlTWFwcGluZ1VSTA5pbmRleC53YXNtLm1hcA==")));var o=e.length,B=(o+65535&-65536)>>16,I=new WebAssembly.Memory({initial:B}),E=new Uint8Array(I.buffer);E.set(e),A.readString=function(A,e){return function(A,e,n){if(n-e<1)return"";for(var o=null,Q=[],t=0,B=0;e<n;)(B=A[e++])<128?Q[t++]=B:B>191&&B<224?Q[t++]=(31&B)<<6|63&A[e++]:B>239&&B<365?(B=((7&B)<<18|(63&A[e++])<<12|(63&A[e++])<<6|63&A[e++])-65536,Q[t++]=55296+(B>>10),Q[t++]=56320+(1023&B)):Q[t++]=(15&B)<<12|(63&A[e++])<<6|63&A[e++],t>8191&&((o||(o=[])).push(String.fromCharCode.apply(String,Q)),t=0);return o?(t&&o.push(String.fromCharCode.apply(String,Q.slice(0,t))),o.join("")):String.fromCharCode.apply(String,Q.slice(0,t))}(E,A,A+e)};var r={env:{memory:I},options:{}};["onSection","onType","onTypeParam","onTypeReturn","onImport","onFunctionImport","onTableImport","onMemoryImport","onGlobalImport","onMemory","onFunction","onTable","onGlobal","onExport","onStart","onSourceMappingURL","onModuleName","onFunctionName","onLocalName"].forEach(function(A){return r.options[A]=n[A]||function(){}}),new WebAssembly.Instance(Q,r).exports.parse(0,o)};for(var t=new Array(123),B=0;B<64;)t[B<26?B+65:B<52?B+71:B<62?B-4:B-59|43]=B++},function(A,e,n){"use strict";e.__esModule=!0,function(A){A[A.i32=127]="i32",A[A.i64=126]="i64",A[A.f32=125]="f32",A[A.f64=124]="f64",A[A.anyfunc=112]="anyfunc",A[A.func=96]="func",A[A.none=64]="none"}(e.Type||(e.Type={})),function(A){A[A.Custom=0]="Custom",A[A.Type=1]="Type",A[A.Import=2]="Import",A[A.Function=3]="Function",A[A.Table=4]="Table",A[A.Memory=5]="Memory",A[A.Global=6]="Global",A[A.Export=7]="Export",A[A.Start=8]="Start",A[A.Element=9]="Element",A[A.Code=10]="Code",A[A.Data=11]="Data"}(e.SectionId||(e.SectionId={})),function(A){A[A.Function=0]="Function",A[A.Table=1]="Table",A[A.Memory=2]="Memory",A[A.Global=3]="Global"}(e.ExternalKind||(e.ExternalKind={})),function(A){A[A.Module=0]="Module",A[A.Function=1]="Function",A[A.Local=2]="Local"}(e.NameType||(e.NameType={})),e.MAX_PAGES=65535,e.MAX_ELEMS=4294967295,function(A){A[A.end=11]="end",A[A.get_global=35]="get_global",A[A.i32_const=65]="i32_const",A[A.i64_const=66]="i64_const",A[A.f32_const=67]="f32_const",A[A.f64_const=68]="f64_const"}(e.Opcode||(e.Opcode={}))}])});
//# sourceMappingURL=index.js.map
'''
'''--- lib/parse/package.json ---
{
  "name": "@assemblyscript/parse",
  "version": "1.0.0",
  "license": "Apache-2.0",
  "main": "index.js",
  "types": "index.d.ts",
  "scripts": {
    "asbuild": "asc assembly/index.ts -O3 -b build/index.wasm -t build/index.wat --importMemory --runtime none --sourceMap",
    "build": "npm run asbuild && webpack --mode production --display-modules",
    "test": "ts-node tests/"
  },
  "files": [
    "package.json",
    "index.d.ts",
    "index.js",
    "index.js.map",
    "src/",
    "README.md"
  ],
  "dependencies": {},
  "devDependencies": {
    "@types/webassembly-js-api": "0.0.1",
    "assemblyscript": "AssemblyScript/assemblyscript",
    "ts-loader": "^5.2.1",
    "ts-node": "^6.2.0",
    "typescript": "^3.1.2",
    "webpack": "^4.20.2",
    "webpack-cli": "^3.1.2"
  }
}

'''
'''--- lib/parse/src/common.ts ---
/** Common constants shared between AssemblyScript and TypeScript. */

/** WebAssembly types. */
export enum Type {
  i32 = 0x7f,
  i64 = 0x7e,
  f32 = 0x7d,
  f64 = 0x7c,
  anyfunc = 0x70,
  func = 0x60,
  none = 0x40
}

/** WebAssembly section ids. */
export enum SectionId {
  Custom = 0,
  Type = 1,
  Import = 2,
  Function = 3,
  Table = 4,
  Memory = 5,
  Global = 6,
  Export = 7,
  Start = 8,
  Element = 9,
  Code = 10,
  Data = 11
}

/** WebAssembly external kinds. */
export enum ExternalKind {
  Function = 0,
  Table = 1,
  Memory = 2,
  Global = 3
}

/** Name section types. */
export enum NameType {
  Module = 0,
  Function = 1,
  Local = 2
}

/** Maximum number of memory pages. */
export const MAX_PAGES = 0xffff;

/** Maximum number of table elements. */
export const MAX_ELEMS = 0xffffffff;

/** WebAssembly opcodes. */
export enum Opcode { // just a few of these are actually used
  // unreachable = 0x00,
  // nop = 0x01,
  // block = 0x02,
  // loop = 0x03,
  // if_ = 0x04,
  // else_ = 0x05,
  end = 0x0b,
  // br = 0x0c,
  // br_if = 0x0d,
  // br_table = 0x0e,
  // return_ = 0x0f,
  // call = 0x10,
  // call_indirect = 0x11,
  // drop = 0x1a,
  // select = 0x1b,
  // get_local = 0x20,
  // set_local = 0x21,
  // tee_local = 0x22,
  get_global = 0x23,
  // set_global = 0x24,
  // i32_load = 0x28,
  // i64_load = 0x29,
  // f32_load = 0x2a,
  // f64_load = 0x2b,
  // i32_load8_s = 0x2c,
  // i32_load8_u = 0x2d,
  // i32_load16_s = 0x2e,
  // i32_load16_u = 0x2f,
  // i64_load8_s = 0x30,
  // i64_load8_u = 0x31,
  // i64_load16_s = 0x32,
  // i64_load16_u = 0x33,
  // i64_load32_s = 0x34,
  // i64_load32_u = 0x35,
  // i32_store = 0x36,
  // i64_store = 0x37,
  // f32_store = 0x38,
  // f64_store = 0x39,
  // i32_store8 = 0x3a,
  // i32_store16 = 0x3b,
  // i64_store8 = 0x3c,
  // i64_store16 = 0x3d,
  // i64_store32 = 0x3e,
  // current_memory = 0x3f,
  // grow_memory = 0x40,
  i32_const = 0x41,
  i64_const = 0x42,
  f32_const = 0x43,
  f64_const = 0x44
  // i32_eqz = 0x45,
  // i32_eq = 0x46,
  // i32_ne = 0x47,
  // i32_lt_s = 0x48,
  // i32_lt_u = 0x49,
  // i32_gt_s = 0x4a,
  // i32_gt_u = 0x4b,
  // i32_le_s = 0x4c,
  // i32_le_u = 0x4d,
  // i32_ge_s = 0x4e,
  // i32_ge_u = 0x4f,
  // i64_eqz = 0x50,
  // i64_eq = 0x51,
  // i64_ne = 0x52,
  // i64_lt_s = 0x53,
  // i64_lt_u = 0x54,
  // i64_gt_s = 0x55,
  // i64_gt_u = 0x56,
  // i64_le_s = 0x57,
  // i64_le_u = 0x58,
  // i64_ge_s = 0x59,
  // i64_ge_u = 0x5a,
  // f32_eq = 0x5b,
  // f32_ne = 0x5c,
  // f32_lt = 0x5d,
  // f32_gt = 0x5e,
  // f32_le = 0x5f,
  // f32_ge = 0x60,
  // f64_eq = 0x61,
  // f64_ne = 0x62,
  // f64_lt = 0x63,
  // f64_gt = 0x64,
  // f64_le = 0x65,
  // f64_ge = 0x66,
  // i32_clz = 0x67,
  // i32_ctz = 0x68,
  // i32_popcnt = 0x69,
  // i32_add = 0x6a,
  // i32_sub = 0x6b,
  // i32_mul = 0x6c,
  // i32_div_s = 0x6d,
  // i32_div_u = 0x6e,
  // i32_rem_s = 0x6f,
  // i32_rem_u = 0x70,
  // i32_and = 0x71,
  // i32_or = 0x72,
  // i32_xor = 0x73,
  // i32_shl = 0x74,
  // i32_shr_s = 0x75,
  // i32_shr_u = 0x76,
  // i32_rotl = 0x77,
  // i32_rotr = 0x78,
  // i64_clz = 0x79,
  // i64_ctz = 0x7a,
  // i64_popcnt = 0x7b,
  // i64_add = 0x7c,
  // i64_sub = 0x7d,
  // i64_mul = 0x7e,
  // i64_div_s = 0x7f,
  // i64_div_u = 0x80,
  // i64_rem_s = 0x81,
  // i64_rem_u = 0x82,
  // i64_and = 0x83,
  // i64_or = 0x84,
  // i64_xor = 0x85,
  // i64_shl = 0x86,
  // i64_shr_s = 0x87,
  // i64_shr_u = 0x88,
  // i64_rotl = 0x89,
  // i64_rotr = 0x8a,
  // f32_abs = 0x8b,
  // f32_neg = 0x8c,
  // f32_ceil = 0x8d,
  // f32_floor = 0x8e,
  // f32_trunc = 0x8f,
  // f32_nearest = 0x90,
  // f32_sqrt = 0x91,
  // f32_add = 0x92,
  // f32_sub = 0x93,
  // f32_mul = 0x94,
  // f32_div = 0x95,
  // f32_min = 0x96,
  // f32_max = 0x97,
  // f32_copysign = 0x98,
  // f64_abs = 0x99,
  // f64_neg = 0x9a,
  // f64_ceil = 0x9b,
  // f64_floor = 0x9c,
  // f64_trunc = 0x9d,
  // f64_nearest = 0x9e,
  // f64_sqrt = 0x9f,
  // f64_add = 0xa0,
  // f64_sub = 0xa1,
  // f64_mul = 0xa2,
  // f64_div = 0xa3,
  // f64_min = 0xa4,
  // f64_max = 0xa5,
  // f64_copysign = 0xa6,
  // i32_wrap_i64 = 0xa7,
  // i32_trunc_s_f32 = 0xa8,
  // i32_trunc_u_f32 = 0xa9,
  // i32_trunc_s_f64 = 0xaa,
  // i32_trunc_u_f64 = 0xab,
  // i64_extend_s_i32 = 0xac,
  // i64_extend_u_i32 = 0xad,
  // i64_trunc_s_f32 = 0xae,
  // i64_trunc_u_f32 = 0xaf,
  // i64_trunc_s_f64 = 0xb0,
  // i64_trunc_u_f64 = 0xb1,
  // f32_convert_s_i32 = 0xb2,
  // f32_convert_u_i32 = 0xb3,
  // f32_convert_s_i64 = 0xb4,
  // f32_convert_u_i64 = 0xb5,
  // f32_demote_f64 = 0xb6,
  // f64_convert_s_i32 = 0xb7,
  // f64_convert_u_i32 = 0xb8,
  // f64_convert_s_i64 = 0xb9,
  // f64_convert_u_i64 = 0xba,
  // f64_promote_f32 = 0xbb,
  // i32_reinterpret_f32 = 0xbc,
  // i64_reinterpret_f64 = 0xbd,
  // f32_reinterpret_i32 = 0xbe,
  // f64_reinterpret_i64 = 0xbf
}

'''
'''--- lib/parse/src/index.ts ---
import { Type, SectionId, ExternalKind } from "./common";
export { Type, SectionId, ExternalKind };

/** Cached compiled parser. */
var compiled: WebAssembly.Module | null = null;

declare var WASM_DATA: string; // injected by webpack
if (typeof WASM_DATA !== "string") {
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  WASM_DATA = require("fs").readFileSync(__dirname + "/../build/index.wasm", "base64");
}

/** Options specified to the parser. The `onSection` callback determines the sections being evaluated in detail. */
export interface ParseOptions {
  /** Called with each section in the binary. Returning `true` evaluates the section. */
  onSection?(id: SectionId, payloadOff: number, payloadLen: number, nameOff: number, nameLen: number): boolean;
  /** Called with each function type if the type section is evaluated. */
  onType?(index: number, form: number): void;
  /** Called with each function parameter if the type section is evaluated. */
  onTypeParam?(index: number, paramIndex: number, paramType: Type): void;
  /** Called with each function return type if the type section is evaluated. */
  onTypeReturn?(index: number, returnIndex: number, returnType: Type): void;
  /** Called with each import if the import section is evaluated. */
  onImport?(index: number, kind: ExternalKind, moduleOff: number, moduleLen: number, fieldOff: number, fieldLen: number): void;
  /** Called with each function import if the import section is evaluated. */
  onFunctionImport?(index: number, type: number): void;
  /** Called with each table import if the import section is evaluated. */
  onTableImport?(index: number, type: Type, initial: number, maximum: number, flags: number): void;
  /** Called with each memory import if the import section is evaluated. */
  onMemoryImport?(index: number, initial: number, maximum: number, flags: number): void;
  /** Called with each global import if the import section is evaluated. */
  onGlobalImport?(index: number, type: Type, mutability: number): void;
  /** Called with each memory if the memory section is evaluated.*/
  onMemory?(index: number, initial: number, maximum: number, flags: number): void;
  /** Called with each function if the function section is evaluated. */
  onFunction?(index: number, typeIndex: number): void;
  /** Called with each table if the table section is evaluated.*/
  onTable?(index: number, type: Type, initial: number, maximum: number, flags: number): void;
  /** Called with each global if the global section is evaluated. */
  onGlobal?(index: number, type: Type, mutability: number): void;
  /** Called with the start function index if the start section is evaluated. */
  onStart?(index: number): void;
  /** Called with each export if the export section is evaluated. */
  onExport?(index: number, kind: ExternalKind, kindIndex: number, nameOff: number, nameLen: number): void;
  /** Called with the source map URL if the 'sourceMappingURL' section is evaluated. */
  onSourceMappingURL?(offset: number, length: number): void;
  /** Called with the module name if present and the 'name' section is evaluated. */
  onModuleName?(offset: number, length: number): void;
  /** Called with each function name if present and the 'name' section is evaluated. */
  onFunctionName?(index: number, offset: number, length: number): void;
  /** Called with each local name if present and the 'name' section is evaluated. */
  onLocalName?(funcIndex: number, index: number, offset: number, length: number): void;
}

/** Parses the contents of a WebAssembly binary according to the specified options. */
export function parse(binary: Uint8Array, options?: ParseOptions): void {
  if (!options) options = {};

  // compile the parser if not yet compiled
  if (!compiled) compiled = new WebAssembly.Module(base64_decode(WASM_DATA));

  // use the binary as the parser's memory
  var nBytes = binary.length;
  var nPages = ((nBytes + 0xffff) & ~0xffff) >> 16;
  var memory = new WebAssembly.Memory({ initial: nPages });
  var buffer = new Uint8Array(memory.buffer);
  buffer.set(binary);

  // provide a way to read strings from memory
  parse.readString = (offset: number, length: number): string => utf8_read(buffer, offset, offset + length);

  // instantiate the parser and return its exports
  var imports = {
    env: {
      memory
    },
    options: {}
  };
  [ "onSection",
    "onType",
    "onTypeParam",
    "onTypeReturn",
    "onImport",
    "onFunctionImport",
    "onTableImport",
    "onMemoryImport",
    "onGlobalImport",
    "onMemory",
    "onFunction",
    "onTable",
    "onGlobal",
    "onExport",
    "onStart",
    "onSourceMappingURL",
    "onModuleName",
    "onFunctionName",
    "onLocalName"
  ].forEach((name: string) => imports.options[name] = options[name] || function() { /* nop */ });
  var instance = new WebAssembly.Instance(compiled, imports);
  instance.exports.parse(0, nBytes);
}

export declare namespace parse {
  /** Utility function for reading an UTF8 encoded string from memory while parsing. */
  function readString(offset: number, length: number): string;
}

// see: https://github.com/dcodeIO/protobuf.js/tree/master/lib/utf8
function utf8_read(buffer: Uint8Array, start: number, end: number): string {
  var len = end - start;
  if (len < 1) return "";
  var parts: string[] | null = null, chunk: number[] = [];
  var i = 0, t = 0; // char offset and temporary
  while (start < end) {
    t = buffer[start++];
    if (t < 128) {
      chunk[i++] = t;
    } else if (t > 191 && t < 224) {
      chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
    } else if (t > 239 && t < 365) {
      t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
      chunk[i++] = 0xD800 + (t >> 10);
      chunk[i++] = 0xDC00 + (t & 1023);
    } else {
      chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
    }
    if (i > 8191) {
      (parts || (parts = [])).push(String.fromCharCode(...chunk));
      i = 0;
    }
  }
  if (parts) {
    if (i) parts.push(String.fromCharCode(...chunk.slice(0, i)));
    return parts.join("");
  }
  return String.fromCharCode(...chunk.slice(0, i));
}

// see: https://github.com/dcodeIO/protobuf.js/tree/master/lib/base64
function base64_decode(string: string): Uint8Array {
  var length = string.length;
  if (length) {
    let n = 0, p = length;
    while (--p % 4 > 1 && string.charCodeAt(p) === 61) ++n;
    length = Math.ceil(length * 3) / 4 - n;
  }
  var buffer = new Uint8Array(length);
  var j = 0, o = 0, t = 0;
  for (let i = 0, k = string.length; i < k;) {
    let c = string.charCodeAt(i++);
    if (c === 61 && j > 1) break;
    if ((c = s64[c]) === undefined) throw Error();
    switch (j) {
      case 0: { t = c; j = 1; break; }
      case 1: { buffer[o++] = t << 2 | (c & 48) >> 4; t = c; j = 2; break; }
      case 2: { buffer[o++] = (t & 15) << 4 | (c & 60) >> 2; t = c; j = 3; break; }
      case 3: { buffer[o++] = (t & 3) << 6 | c; j = 0; break; }
    }
  }
  if (j === 1) throw Error();
  return buffer;
}

var s64 = new Array(123);
for (let i = 0; i < 64;) s64[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

'''
'''--- lib/parse/src/tsconfig.json ---
{
  "compilerOptions": {
    "module": "commonjs"
  },
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- lib/parse/tests/index.ts ---
import * as fs from "fs";
import {
  Type,
  SectionId,
  ExternalKind,
  parse
} from "..";

function onSection(id: SectionId, offset: number, length: number, nameOffset: number, nameLength: number): boolean {
  var name = id == 0 ? "'" + parse.readString(nameOffset, nameLength) + "'" : SectionId[id];
  console.log(name + " section at " + offset + ".." + (offset + length));
  return true;
}

function onType(index: number, form: Type): void {
  console.log("- FunctionType[" + index + "]: " + Type[form]);
}

function onTypeParam(index: number, paramIndex: number, paramType: Type): void {
  console.log("  > param[" + paramIndex + "] -> " + Type[paramType]);
}

function onTypeReturn(index: number, returnIndex: number, returnType: Type): void {
  console.log("  > return[" + returnIndex + "] -> " + Type[returnType]);
}

function onImport(index: number, kind: ExternalKind, moduleOff: number, moduleLen: number, fieldOff: number, fieldLen: number): void {
  var moduleName = parse.readString(moduleOff, moduleLen);
  var fieldName = parse.readString(fieldOff, fieldLen);
  console.log("- Import[" + index + "]: '" + moduleName + "." + fieldName + "'");
}

function onFunctionImport(funIndex: number, type: number): void {
  console.log("  - Function[" + funIndex + "] -> FunctionType[" + type + "]");
}

function onTableImport(tblIndex: number, type: Type, initial: number, maximum: number, flags: number): void {
  console.log("  - Table[" + tblIndex + "] -> " + Type[type] + ": initial=" + initial + ", maximum=" + maximum);
}

function onMemoryImport(memIndex: number, initial: number, maximum: number, flags: number): void {
  console.log("  - Memory[" + memIndex + "]: initial=" + initial + ", maximum=" + maximum);
}

function onGlobalImport(gloIndex: number, type: Type, mutability: number): void {
  console.log("  - Global[" + gloIndex + "]: " + (mutability & 1 ? "mutable " : "const ") + Type[type]);
}

function onMemory(memIndex: number, initial: number, maximum: number, flags: number): void {
  console.log("- Memory[" + memIndex + "]: initial=" + initial + ", maximum=" + maximum);
}

function onFunction(funIndex: number, typeIndex: number): void {
  console.log("- Function[" + funIndex + "] -> FunctionType[" + typeIndex + "]");
}

function onTable(tblIndex: number, type: number, initial: number, maximum: number, flags: number): void {
  console.log("- Table[" + tblIndex + "] -> " + Type[type] + ": initial=" + initial + ", maximum=" + (maximum >>> 0));
}

function onGlobal(gloIndex: number, type: Type, mutability: number): void {
  console.log("- Global[" + gloIndex + "]: " + (mutability & 1 ? "mutable " : "const ") + Type[type]);
}

function onStart(index: number): void {
  console.log("- Start: Function[" + index + "]");
}

function onExport(index: number, kind: ExternalKind, kindIndex: number, fieldOffset: number, fieldLength: number): void {
  var field = parse.readString(fieldOffset, fieldLength);
  console.log("- Export[" + index + "], '" + field + "' -> " + ExternalKind[kind] + "[" + kindIndex + "]");
}

function onSourceMappingURL(offset: number, length: number): void {
  var url = parse.readString(offset, length);
  console.log("- sourceMap: " + url);
}

function onModuleName(offset: number, length: number): void {
  var name = parse.readString(offset, length);
  console.log("- moduleName: " + name);
}

function onFunctionName(index: number, offset: number, length: number): void {
  var name = parse.readString(offset, length);
  console.log(" - Function[" + index + "] name: " + name);
}

function onLocalName(funcIndex: number, index: number, offset: number, length: number): void {
  var name = parse.readString(offset, length);
  console.log("  - Function[" + funcIndex + "].local[" + index + "] name: " + name);
}

[ "../build/index.wasm",
  "libm.wasm"
].forEach((filename: string): void => {
  const binary: Uint8Array = fs.readFileSync(__dirname + "/" + filename);
  console.log("Testing '" + filename + "' ...");
  parse(binary, {
    onSection,
    onType,
    onTypeParam,
    onTypeReturn,
    onImport,
    onFunctionImport,
    onTableImport,
    onMemoryImport,
    onGlobalImport,
    onMemory,
    onFunction,
    onTable,
    onGlobal,
    onStart,
    onExport,
    onSourceMappingURL,
    onModuleName,
    onFunctionName,
    onLocalName
  });
  console.log();
});

'''
'''--- lib/parse/webpack.config.js ---
const fs = require("fs");
const webpack = require("webpack");

const wasmData = fs.readFileSync(__dirname + "/build/index.wasm");

module.exports = {
  entry: [ "./src/index.ts" ],
  module: {
    rules: [
      {
        test: /\.ts$/,
        use: "ts-loader",
        exclude: /node_modules/
      }
    ]
  },
  resolve: {
    extensions: [ ".ts", ".js" ]
  },
  node: {
    fs: false
  },
  output: {
    filename: "index.js",
    path: __dirname,
    library: "asparse",
    libraryTarget: "umd",
    globalObject: "typeof self !== 'undefined' ? self : this"
  },
  plugins: [
    new webpack.DefinePlugin({
      WASM_DATA: JSON.stringify(wasmData.toString("base64"))
    })
  ],
  devtool: "source-map"
};

'''
'''--- lib/rtrace/README.md ---
# AssemblyScript Rtrace

A tiny utility to sanitize the AssemblyScript runtime. Records allocations and frees performed by the runtime and emits an error if something is off. Also checks for leaks.

Instructions
------------

Compile your module that uses the full or half runtime with `-use ASC_RTRACE=1 --explicitStart` and include an instance of this module as the import named `rtrace`.

```js
const rtrace = new Rtrace({
  onerror(err, info) {
    // handle error
  },
  oninfo(msg) {
    // print message, optional
  },
  getMemory() {
    // obtain the module's memory,
    // e.g. with --explicitStart:
    return instance.exports.memory;
  }
});

const { module, instance } = await WebAssembly.instantiate(...,
  rtrace.install({
    ...imports...
  })
);
instance.exports._start();
...

if (rtrace.active) {
  let leakCount = rtr.check();
  if (leakCount) {
    // handle error
  }
}
```

Note that references in globals which are not cleared before collection is performed appear as leaks, including their inner members. A TypedArray would leak itself and its backing ArrayBuffer in this case for example. This is perfectly normal and clearing all globals avoids this.

'''
'''--- lib/rtrace/bin/rtplot.js ---
#!/usr/bin/env node

import process from "process";
import fs from "fs";
import path from "path";
import { gc } from "../plot.js";

if (process.argv.length < 3) {
  process.stderr.write(`Usage: ${path.basename(process.argv[1])} rtrace-gc-profile.json > profile.svg\n`);
  process.exit(1);
}

const data = JSON.parse(fs.readFileSync(process.argv[2]));
process.stdout.write(gc(data));

'''
'''--- lib/rtrace/index.d.ts ---
/** Block information. */
export declare interface BlockInfo {
  /** Pointer to the block. */
  ptr: number,
  /** Block size including overhead. */
  size: number,
  /** Memory manager info. */
  mmInfo: {
    tags: string,
    size: number
  },
  /** Garbage collector info. */
  gcInfo: {
    color: string,
    next: number,
    prev: number
  },
  /** Runtime id. */
  rtId: number,
  /** Runtime size. */
  rtSize: number
}

type ErrorCallback = (error: Error, info: BlockInfo) => void;
type InfoCallback = (msg: string) => void;

export declare interface RtraceOptions {
  /** Function being called when a problem is detected. */
  onerror?: ErrorCallback,
  /** Function being called with information messages. */
  oninfo?: InfoCallback,
  /** Obtains the module's memory instance. */
  getMemory(): WebAssembly.Memory;
}

/** Overhead between a pointer to a block and its unmanaged data. */
export declare const BLOCK_OVERHEAD;
/** Overhead between a pointer to a block's unmanaged data to its managed data. */
export declare const OBJECT_OVERHEAD;
/** Overhead between a pointer to a block and its managed data. */
export declare const TOTAL_OVERHEAD;

export declare class Rtrace  {
  /** Creates a new `Rtrace` instance. */
  constructor(options: RtraceOptions);

  /** Checks if rtrace is active, i.e. at least one event has occurred. */
  readonly active: boolean;
  /** Number of seen allocation events. */
  readonly allocCount: number;
  /** Number of seen resize events during realloc. */
  readonly resizeCount: number;
  /** Number of seens move events during realloc. */
  readonly moveCount: number;
  /** Number of seen free events. */
  readonly freeCount: number;
  /** Heap base offset reported by the module. */
  readonly heapBase: number;

  /** Installs Rtrace on the specified imports object. */
  install(imports: Record<string,Record<string,unknown>>): Record<string,Record<string,unknown>>;

  /** Checks if there are any leaks and emits them via `oninfo`. Returns the number of live blocks. */
  check(): number;

  /** Obtains information about a block. */
  getBlockInfo(ptr: number): BlockInfo;

  // Instrumentation

  /** Called upon runtime initialization. */
  oninit(heapBase: number): void;

  /** Called when a new block is allocated. */
  onalloc(ptr: number): void;

  /** Called when an existing block is resized. */
  onresize(ptr: number, oldSize: number): void;

  /** Called when an existing block is moved to a new allocation. */
  onmove(oldPtr: number, newPtr: number): void;

  /** Called when an object is visited by the GC. Returns `true` unless there is an error and the block should be skipped. */
  onvisit(ptr: number): boolean;

  /** Called when an existing block is freed.*/
  onfree(ptr: number): void;

  /** Called when a collection phase concludes. */
  oncollect(total: number): void;

  /** Called when a collection phase interrupts the program. */
  oninterrupt(total: number): void;

  /** Called when a collection phase yields from an interrupt. */
  onyield(total: number): void;

  /** Called when a value is stored to memory. */
  onstore(ptr: number, offset: number, bytes: number, isRT: boolean): void;

  /** Called when a value is loaded from memory. */
  onload(ptr: number, offset: number, bytes: number, isRT: boolean): void;

  // Reporting

  /** Error message callback. */
  onerror: ErrorCallback;

  /** Info message callback. */
  oninfo: InfoCallback;
}

'''
'''--- lib/rtrace/index.js ---
// WebAssembly pages are 65536 kb
const PAGE_SIZE_BITS = 16;
const PAGE_SIZE = 1 << PAGE_SIZE_BITS;
const PAGE_MASK = PAGE_SIZE - 1;

// Wasm32 pointer size is 4 bytes
const PTR_SIZE_BITS = 2;
const PTR_SIZE = 1 << PTR_SIZE_BITS;
const PTR_MASK = PTR_SIZE - 1;
const PTR_VIEW = Uint32Array;

export const BLOCK_OVERHEAD = PTR_SIZE;
export const OBJECT_OVERHEAD = 16;
export const TOTAL_OVERHEAD = BLOCK_OVERHEAD + OBJECT_OVERHEAD;

function assert(x) {
  if (!x) throw Error("assertion failed");
  return x;
}

Error.stackTraceLimit = 15;

function trimStacktrace(stack, levels) {
  return stack.split(/\r?\n/).slice(1 + levels);
}

const hrtime = typeof performance !== "undefined" && performance.now
  ? performance.now
  : typeof process !== "undefined" && process.hrtime
    ? () => { let t = process.hrtime(); return t[0] * 1e3 + t[1] / 1e6; }
    : Date.now;

const mmTagsToString = [
  "",
  "FREE",
  "LEFTFREE",
  "FREE+LEFTFREE"
];

const gcColorToString = [
  "BLACK/WHITE",
  "WHITE/BLACK",
  "GRAY",
  "INVALID"
];

export class Rtrace {

  constructor(options) {
    this.options = options || {};
    this.onerror = this.options.onerror || function() { /* nop */ };
    this.oninfo = this.options.oninfo || function() { /* nop */ };
    this.oncollect_ = this.options.oncollect || function() { /* nop */ };
    this.memory = null;
    this.shadow = null;
    this.shadowStart = 0x100000000;
    this.blocks = new Map();
    this.allocSites = new Map();
    this.freedBlocks = new Map();
    this.gcProfileStart = 0;
    this.gcProfile = [];

    this.allocCount = 0;
    this.resizeCount = 0;
    this.moveCount = 0;
    this.freeCount = 0;
    this.heapBase = 0x100000000;
  }

  install(imports) {
    if (!imports) imports = {};
    imports.rtrace = Object.assign(imports.rtrace || {}, {
      oninit: this.oninit.bind(this),
      onalloc: this.onalloc.bind(this),
      onresize: this.onresize.bind(this),
      onmove: this.onmove.bind(this),
      onvisit: this.onvisit.bind(this),
      onfree: this.onfree.bind(this),
      oninterrupt: this.oninterrupt.bind(this),
      onyield: this.onyield.bind(this),
      oncollect: this.oncollect.bind(this),
      onstore: this.onstore.bind(this),
      onload: this.onload.bind(this)
    });
    return imports;
  }

  /** Synchronizes the shadow memory with the module's memory. */
  syncShadow() {
    if (!this.memory) {
      this.memory = assert(this.options.getMemory());
      this.shadow = new WebAssembly.Memory({
        initial: ((this.memory.buffer.byteLength + PAGE_MASK) & ~PAGE_MASK) >>> PAGE_SIZE_BITS
      });
    } else {
      var diff = this.memory.buffer.byteLength - this.shadow.buffer.byteLength;
      if (diff > 0) this.shadow.grow(diff >>> 16);
    }
  }

  /** Marks a block's presence in shadow memory. */
  markShadow(info, oldSize = 0) {
    assert(this.shadow && this.shadow.byteLength == this.memory.byteLength);
    assert((info.size & PTR_MASK) == 0);
    if (info.ptr < this.shadowStart) {
      this.shadowStart = info.ptr;
    }
    var len = info.size >>> PTR_SIZE_BITS;
    var view = new PTR_VIEW(this.shadow.buffer, info.ptr, len);
    var errored = false;
    var start = oldSize >>> PTR_SIZE_BITS;
    for (let i = 0; i < start; ++i) {
      if (view[i] != info.ptr && !errored) {
        this.onerror(Error("shadow region mismatch: " + view[i] + " != " + info.ptr), info);
        errored = true;
      }
    }
    errored = false;
    for (let i = start; i < len; ++i) {
      if (view[i] != 0 && !errored) {
        this.onerror(Error("shadow region already in use: " + view[i] + " != 0"), info);
        errored = true;
      }
      view[i] = info.ptr;
    }
  }

  /** Unmarks a block's presence in shadow memory. */
  unmarkShadow(info, oldSize = info.size) {
    assert(this.shadow && this.shadow.byteLength == this.memory.byteLength);
    var len = oldSize >>> PTR_SIZE_BITS;
    var view = new PTR_VIEW(this.shadow.buffer, info.ptr, len);
    var errored = false;
    var start = 0;
    if (oldSize != info.size) {
      assert(oldSize > info.size);
      start = info.size >>> PTR_SIZE_BITS;
    }
    for (let i = 0; i < len; ++i) {
      if (view[i] != info.ptr && !errored) {
        this.onerror(Error("shadow region mismatch: " + view[i] + " != " + info.ptr), info);
        errored = true;
      }
      if (i >= start) view[i] = 0;
    }
  }

  /** Performs an access to shadow memory. */
  accessShadow(ptr, size, isLoad, isRT) {
    this.syncShadow();
    if (ptr < this.shadowStart) return;
    var value = new Uint32Array(this.shadow.buffer, ptr & ~PTR_MASK, 1)[0];
    if (value != 0) return;
    if (!isRT) {
      let stack = trimStacktrace(new Error().stack, 2);
      this.onerror(new Error("OOB " + (isLoad ? "load" : "store") + (8 * size) + " at address " + ptr + "\n" + stack.join("\n")));
    }
  }

  /** Obtains information about a block. */
  getBlockInfo(ptr) {
    const [
      mmInfo,
      gcInfo,
      gcInfo2,
      rtId,
      rtSize
    ] = new Uint32Array(this.memory.buffer, ptr, 5);
    const size = mmInfo & ~3;
    return {
      ptr,
      size: BLOCK_OVERHEAD + size, // total incl. overhead
      mmInfo: {
        tags: mmTagsToString[mmInfo & 3],
        size: size // as stored excl. overhead
      },
      gcInfo: {
        color: gcColorToString[gcInfo & 3],
        next: gcInfo & ~3,
        prev: gcInfo2
      },
      rtId,
      rtSize
    };
  }

  /** Checks if rtrace is active, i.e. at least one event has occurred. */
  get active() {
    return Boolean(this.allocCount || this.resizeCount || this.moveCount || this.freeCount);
  }

  /** Checks if there are any leaks and emits them via `oninfo`. Returns the number of live blocks. */
  check() {
    if (this.oninfo) {
      for (let [ptr, info] of this.blocks) {
        this.oninfo("LIVE " + ptr + "\n" + info.allocStack.join("\n"));
      }
    }
    return this.blocks.size;
  }

  // Runtime instrumentation

  oninit(heapBase) {
    this.heapBase = heapBase;
    this.gcProfileStart = 0;
    this.gcProfile.length = 0;
    this.oninfo("INIT heapBase=" + heapBase);
  }

  onalloc(ptr) {
    this.syncShadow();
    ++this.allocCount;
    var info = this.getBlockInfo(ptr);
    if (this.blocks.has(ptr)) {
      this.onerror(Error("duplicate alloc: " + ptr), info);
    } else {
      this.oninfo("ALLOC " + ptr + ".." + (ptr + info.size));
      this.markShadow(info);
      let allocStack = trimStacktrace(new Error().stack, 1); // strip onalloc
      this.blocks.set(ptr, Object.assign(info, { allocStack }));
    }
  }
  
  onresize(ptr, oldSize) {
    this.syncShadow();
    ++this.resizeCount;
    const info = this.getBlockInfo(ptr);
    if (!this.blocks.has(ptr)) {
      this.onerror(Error("orphaned resize: " + ptr), info);
    } else {
      const beforeInfo = this.blocks.get(ptr);
      if (beforeInfo.size != oldSize) {
        this.onerror(Error(`size mismatch upon resize: ${ptr} (${beforeInfo.size} != ${oldSize})`), info);
      }
      const newSize = info.size;
      this.oninfo("RESIZE " + ptr + ".." + (ptr + newSize) + " (" + oldSize + "->" + newSize + ")");
      this.blocks.set(ptr, Object.assign(info, { allocStack: beforeInfo.allocStack }));
      if (newSize > oldSize) {
        this.markShadow(info, oldSize);
      } else if (newSize < oldSize) {
        this.unmarkShadow(info, oldSize);
      }
    }
  }

  onmove(oldPtr, newPtr) {
    this.syncShadow();
    ++this.moveCount;
    var oldInfo = this.getBlockInfo(oldPtr);
    var newInfo = this.getBlockInfo(newPtr);
    if (!this.blocks.has(oldPtr)) {
      this.onerror(Error("orphaned move (old): " + oldPtr), oldInfo);
    } else {
      if (!this.blocks.has(newPtr)) {
        this.onerror(Error("orphaned move (new): " + newPtr), newInfo);
      } else {
        const beforeInfo = this.blocks.get(oldPtr);
        const oldSize = oldInfo.size;
        const newSize = newInfo.size;
        if (beforeInfo.size != oldSize) {
          this.onerror(Error(`size mismatch upon move: ${oldPtr} (${beforeInfo.size} != ${oldSize})`), oldInfo);
        }
        this.oninfo("MOVE " + oldPtr + ".." + (oldPtr + oldSize) + " -> " + newPtr + ".." + (newPtr + newSize));
        // calls new alloc before and old free after
      }
    }
  }

  onvisit(ptr) {
    // Indicates that a block has been freed but it still visited by the GC
    if (ptr > this.heapBase && !this.blocks.has(ptr)) {
      let err = Error("orphaned visit: " + ptr);
      let info = this.freedBlocks.get(ptr);
      if (info) {
        err.stack += "\n^ allocated at:\n" + info.allocStack.join("\n");
        err.stack += "\n^ freed at:\n" + info.freeStack.join("\n");
      }
      this.onerror(err, null);
      return false;
    }
    return true;
  }

  onfree(ptr) {
    this.syncShadow();
    ++this.freeCount;
    var info = this.getBlockInfo(ptr);
    if (!this.blocks.has(ptr)) {
      this.onerror(Error("orphaned free: " + ptr), info);
    } else {
      const oldInfo = this.blocks.get(ptr);
      if (info.size != oldInfo.size) {
        this.onerror(Error(`size mismatch upon free: ${ptr} (${oldInfo.size} != ${info.size})`), info);
      }
      this.oninfo("FREE " + ptr + ".." + (ptr + info.size));
      this.unmarkShadow(info);
      const allocInfo = this.blocks.get(ptr);
      this.blocks.delete(ptr);
      const allocStack = allocInfo.allocStack;
      const freeStack = trimStacktrace(new Error().stack, 1); // strip onfree
      // (not much) TODO: Maintaining these is essentially a memory leak
      this.freedBlocks.set(ptr, { allocStack, freeStack });
    }
  }

  oncollect(total) {
    this.oninfo(`COLLECT at ${total}`);
    this.plot(total);
    this.oncollect_();
  }

  // GC profiling

  plot(total, pause = 0) {
    if (!this.gcProfileStart) this.gcProfileStart = Date.now();
    this.gcProfile.push([ Date.now() - this.gcProfileStart, total, pause ]);
  }

  oninterrupt(total) {
    this.interruptStart = hrtime();
    this.plot(total);
  }

  onyield(total) {
    var pause = hrtime() - this.interruptStart;
    if (pause >= 1) console.log("interrupted for " + pause.toFixed(1) + "ms");
    this.plot(total, pause);
  }

  // Memory instrumentation

  onstore(ptr, offset, bytes, isRT) {
    this.accessShadow(ptr + offset, bytes, false, isRT);
    return ptr;
  }

  onload(ptr, offset, bytes, isRT) {
    this.accessShadow(ptr + offset, bytes, true, isRT);
    return ptr;
  }
}

export default {
  Rtrace
};

'''
'''--- lib/rtrace/package.json ---
{
  "name": "@assemblyscript/rtrace",
  "description": "A tiny utility to sanitize the AssemblyScript runtime.",
  "keywords": [
    "assemblyscript",
    "rtrace",
    "webassembly",
    "wasm"
  ],
  "version": "0.0.0",
  "author": "Daniel Wirtz <dcode+assemblyscript@dcode.io>",
  "license": "Apache-2.0",
  "homepage": "https://assemblyscript.org",
  "repository": {
    "type": "git",
    "url": "https://github.com/AssemblyScript/assemblyscript.git",
    "directory": "lib/rtrace"
  },
  "bugs": {
    "url": "https://github.com/AssemblyScript/assemblyscript/issues"
  },
  "type": "module",
  "main": "index.js",
  "types": "index.d.ts",
  "exports": {
    "import": "./index.js",
    "require": "./umd/index.js"
  },
  "bin": {
    "rtplot": "bin/rtplot.js"
  },
  "scripts": {
    "build": "npx esm2umd rtrace index.js > umd/index.js",
    "test": "node tests"
  },
  "dependencies": {
    "d3": "^6.3.1",
    "jsdom": "^16.4.0"
  },
  "files": [
    "index.d.ts",
    "index.js",
    "package.json",
    "umd/index.d.ts",
    "umd/index.js",
    "umd/package.json",
    "bin/rtplot.js",
    "README.md"
  ]
}

'''
'''--- lib/rtrace/plot.js ---
import * as d3 from "d3";
import { JSDOM } from "jsdom";

/** Creates a plot of a GC profile in `rtrace.gcProfile`. */
export function gc(data, width = 1280, height = 720) {
  const margin = { top: 20, right: 30, bottom: 30, left: 30 };
  const dom = new JSDOM("<!DOCTYPE html><body></body>");
  const body = d3.select(dom.window.document.querySelector("body"));

  const svg = body.append("svg")
    .attr("xmlns", "http://www.w3.org/2000/svg")
    .attr("viewBox", [0, 0, width, height]);

  const x = d3.scaleLinear()
    .domain([d3.min(data, d => d[0]), d3.max(data, d => d[0])])
    .range([margin.left, width - margin.right]);

  const xAxis = g => g
    .attr("transform", `translate(0,${height - margin.bottom})`)
    .call(d3.axisBottom(x).ticks(width / 80).tickSizeOuter(0));

  const y = d3.scaleLinear()
    .domain([0, d3.max(data, d => d[1])]).nice()
    .range([height - margin.bottom, margin.top]);

  const yAxis = g => g
    .attr("transform", `translate(${margin.left},0)`)
    .call(d3.axisLeft(y))
    .call(g => g.select(".domain").remove())
    .call(g => g.select(".tick:last-of-type text").clone()
      .attr("x", 3)
      .attr("text-anchor", "start")
      .attr("font-weight", "bold")
      .attr("color", "steelblue")
      .text("memory (b)")
    );

  const y2 = d3.scaleLinear()
    .domain([0, d3.max(data, d => d[2])]).nice()
    .range([height - margin.bottom, margin.top]);

  const y2Axis = g => g
    .attr("transform", `translate(${width - margin.right},0)`)
    .call(d3.axisRight(y2))
    .call(g => g.select(".domain").remove())
    .call(g => g.select(".tick:last-of-type text").clone()
      .attr("x", -3)
      .attr("text-anchor", "end")
      .attr("font-weight", "bold")
      .attr("color", "orange")
      .text("pause (ms)")
    );

  svg.append("g")
    .attr("fill", "orange")
    .selectAll("rect")
    .data(data)
    .join("rect")
    .attr("x", d => x(d[0]))
    .attr("y", d => y2(d[2]))
    .attr("height", d => y2(0) - y2(d[2]))
    .attr("width", 0.5);

  svg.append("g")
    .attr("fill", "orange")
    .selectAll("line")
    .data(data)
    .join("circle")
    .attr("cx", d => x(d[0]))
    .attr("cy", d => y2(d[2]))
    .attr("r", 1.5);

  const line = d3.line()
    .defined(d => !isNaN(d[1]))
    .x(d => x(d[0]))
    .y(d => y(d[1]));

  svg.append("path")
    .datum(data)
    .attr("fill", "none")
    .attr("stroke", "steelblue")
    .attr("stroke-width", 0.5)
    .attr("stroke-linejoin", "round")
    .attr("stroke-linecap", "round")
    .attr("d", line);

  svg.append("g")
    .attr("fill", "steelblue")
    .selectAll("circle")
    .data(data)
    .join("circle")
    .attr("cx", d => x(d[0]))
    .attr("cy", d => y(d[1]))
    .attr("r", 1.5);

  svg.append("g").call(xAxis);
  svg.append("g").call(yAxis);
  svg.append("g").call(y2Axis);
  
  return body.html();
}

export default {
  gc
};

'''
'''--- lib/rtrace/tests/index.js ---
// TODO

'''
'''--- lib/rtrace/tlsfvis.html ---
<script>
// Configuration - must match actual implementation
const AL_BITS = 4;
const SL_BITS = 4;
const OVERHEAD = 16;

const SL_SIZE = 1 << SL_BITS;
const SB_BITS = AL_BITS + SL_BITS;
const FL_BITS = 31 - SB_BITS;
const HL_SIZE = FL_BITS * SL_SIZE;

var exports;
var ROOT;
var U32;
fetch("untouched.wasm").then(result => 
  result.arrayBuffer()
).then(buffer =>
  WebAssembly.instantiate(buffer, {
    env: {
      abort: function(msg, file, line, column) {
        console.log("abort: " + getString(msg) + " at " + getString(file) + ":" + line + ":" + column);
      },
      trace: function(msg, n, ...args) {
        console.log("trace: " + getString(msg) + " " + args.slice(0, n).join(" "));
      }
    }
  })
).then(result => {
  exports = result.instance.exports;
  if (exports._start) exports._start();
  U32 = new Uint32Array(exports.memory.buffer);
  var first = exports.__alloc(255);
  exports.__free(first);
  ROOT = first - 17;
  while (!U32[ROOT >> 2]) --ROOT; // find tail
  ROOT -= (1 + FL_BITS + HL_SIZE) << 2;
  init();
  update();
});

function getString(ptr) {
  if (!ptr) return "null";
  var U32 = new Uint32Array(exports.memory.buffer);
  var U16 = new Uint16Array(exports.memory.buffer);
  var len16 = U32[(ptr - 12) >>> 2] >>> 1; // TODO: old header
  var ptr16 = ptr >>> 1;
  return String.fromCharCode.apply(String, U16.subarray(ptr16, ptr16 + len16));
}

var fl = [];
var sl = [];
var hl = [];

var flValue;
var slValue;
var hlValue;
var tailValue;

function toBits(n, l, radix = 2) {
  var s = n.toString(radix);
  while (s.length < l) s = "0" + s;
  return s;
}

function init() {
  document.getElementById("albits").innerText = AL_BITS;
  document.getElementById("flbits").innerText = FL_BITS;
  document.getElementById("slbits").innerText = SL_BITS;
  document.getElementById("overhead").innerText = OVERHEAD;

  var fls = document.getElementById("fl");
  var sls = document.getElementById("sl");
  var hls = document.getElementById("hl");

  for (let i = 0; i < FL_BITS; ++i) {
    let el = document.createElement("span");
    el.className = "fl";
    el.innerText = i;
    fls.appendChild(el);
    fl[i] = el;
    el.title = "< " + (1 << (8 + i));
    el = document.createElement("span");
    el.className = "sl";
    el.innerHTML = '<span class="num">' + i + '</span>' + " " + toBits(0, HL_SIZE / FL_BITS);
    sls.appendChild(el);
    sl[i] = el;
  }
  for (let i = 0; i <= HL_SIZE; ++i) { // sic: last is tail
    let el = document.createElement("span");
    el.className = "hl";
    el.innerHTML = '<span class="num">' + i + '</span> -';
    hl[i] = el;
    hls.appendChild(el);
  }
}

function update() {
  if (U32.buffer !== exports.memory.buffer) U32 = new Uint32Array(exports.memory.buffer);
  var flv = U32[ROOT >> 2];
  fl.forEach((el, i) => {
    var isset = (flv >>> i) & 1;
    el.className = isset ? "fl set" : "fl";
  });
  sl.forEach((el, i) => {
    var map = U32[(ROOT + 4 + i * 4) >> 2];
    el.className = map ? "sl set" : "sl";
    el.innerHTML = '<span class="num">' + i + '</span>' + " " + toBits(map, (hl.length - 1) / fl.length);
  });
  hl.forEach((el, i) => {
    var ptr = U32[(ROOT + 4 + fl.length * 4 + i * 4) >> 2];
    el.className = ptr ? "hl set" : "hl";
    el.innerHTML = '<span class="num">' + (i == hl.length - 1 ? "tail" : i) + '</span>' + " " + toBits(ptr, 6, 16);
  });
}

function allocate(size) {
  var ptr = exports.__alloc(size);
  if (!ptr) {
    alert("should not happen");
    return;
  }
  var el = document.createElement("div");
  el.className = "seg";
  var es = document.createElement("input");
  es.size = 10;
  es.value = size;
  el.appendChild(es);
  var er = document.createElement("button");
  er.innerText = "realloc";
  er.onclick = function() {
    ptr = exports.__realloc(ptr, es.value >>> 0);
    update();
  };
  el.appendChild(er);
  var ef = document.createElement("button");
  ef.innerText = "free";
  ef.className = "free";
  el.appendChild(ef);
  ef.onclick = function() {
    exports.__free(ptr);
    document.getElementById("segs").removeChild(el);
    update();
  };
  document.getElementById("segs").appendChild(el);
}
</script>

<style>
/* General */
body { font-family: sans-serif; font-size: 0.8em; margin: 0; padding: 1em; }
h1 { font-size: 1em; margin: -1em -1em 0 -1em; padding: 1em; background: #1578c8; color: #fff; }
h2 { background: #333; color: #ddd; font-size: 1em; padding: 0.5em; border-radius: 5px; }
input, button { border: 1px solid #999; border-radius: 0.2em; padding: 0.5em; }
button { cursor: pointer; background: #ddd; }
button:hover { background: #bbb; }
.clear { clear: both; }
/* Lists */
.fl, .sl, .hl, .seg { float: left; padding: 0.4em; margin: 0.2em; border: 1px solid #ddd; border-radius: 3px; }
.fl { min-width: 1.3em; text-align: center; }
.sl { min-width: 12em; }
.hl { min-width: 7em; font-size: 0.8em; }
.num { color: #fff; background: rgba(0, 0, 0, 0.3); padding: 0.4em; margin-left: -0.4em; border-radius: 0.2em; }
.set { background: #7f7; }
.seg { border-top: 0.3em solid #333; }
.seg button { margin-left: 0.5em; }
.sub { vertical-align: sub; font-size: 0.8em; }
.free { background: #f77; border-color: #c33; }
.free:hover { background: #c33; color: #fff; }
</style>

<h1>TLSF visualizer</h1>
<p>
  <strong>Notes:</strong>
  <ul>
    <li>It is expected that there is exactly one block on initialization. This is the remaining space (&lt; 64K) within the last page after static data.</li>
    <li>It is expected that if two adjacent blocks of size K are freed, the merged block doesn't go into the first level list for K*2 because its size is actually larger than that (K + OVERHEAD + K).</li>
    <li>It is expected that if memory grows beyond 1GB, that even if all blocks are free'd there are at least two (or even three if the largest block is in the middle) remaining blocks, because a single block must not be larger than 1GB.</li>
    <li>It is expected that after other operations have already been performed, being able to allocate 1GB can't be guaranteed anymore, even if there should be enough space left in absolute terms, if prior subdivision prevents it.</li>
    <li>It is expected that the second level 0 in first level 0 isn't ever used due to alignment guarantees. Smallest block is 32 bytes (16 bytes overhead + 16 bytes payload if used, respectively linking information if free) in this implementation.</li>
  </ul>
</p>
<p><strong>Implementation constants:</strong> <span id="albits">?</span> bits alignment, <span id="flbits">?</span> bits first level, <span id="slbits">?</span> bits second level, <span id="overhead">?</span> B overhead</p>

<h2>First level bitmap</h2>
<p>The first level map is a bitmap determining whether free blocks exist in at least one of its respective second levels. In this implementation, the first bit indicates whether a small block (&lt; 256B) exists. Each bit doubles the size.</p>
<div id="fl"></div>
<div class="clear"></div>

<h2>Second level maps</h2>
<p>Second level maps subdivide each first level into multiple lists of subsizes. Each one works similar to the first level bitmap.</p>
<div id="sl"></div>
<div class="clear"></div>

<h2>Heads</h2>
<p>The heads of the actual free lists, one per second level per first level. Values here are pointers into memory. Last item is the address of the special zero-size "used" tail block, which is usually the end of WASM memory minus block overhead.</p>
<div id="hl"></div>
<div class="clear"></div>

<h2>Allocator</h2>
<p>Chose a size to allocate. Annotated list indexes depend on implementation constants but match those of this implementation.</p>
<p>
  <input type="text" value="1" size="10" id="size" /> <button onclick="allocate(document.getElementById('size').value); update()">B</button> &nbsp;
</p>
<p>
  Small blocks:
  <button onclick="allocate(0); update()">0 B</button>
  <button onclick="allocate(16); update()">16 B <span class="sub">fl=0 sl=1</span></button>
  <button onclick="allocate(32); update()">32 B <span class="sub">fl=0 sl=2</span></button>
  <button onclick="allocate(48); update()">48 B <span class="sub">fl=0 sl=3</span></button>
  <button onclick="allocate(64); update()">64 B <span class="sub">fl=0 sl=4</span></button>
  ...
  <button onclick="allocate(256-OVERHEAD); update()">256 B - Î´ <span class="sub">fl=0 sl=MSB</span></button>
  (Î´ â‰™ block overhead)
</p>
<p>
  Common blocks:
  <button onclick="allocate(256); update()">256 B <span class="sub">fl=1 sl=0</span></button>
  <button onclick="allocate(512-OVERHEAD); update()">512 B - Î´ <span class="sub">fl=1 sl=MSB</span></button>
  <button onclick="allocate(1024-OVERHEAD); update()">1 KB - Î´ <span class="sub">fl=2 sl=MSB</span></button>
  <button onclick="allocate(2048-OVERHEAD); update()">2 KB - Î´  <span class="sub">fl=3 sl=MSB</span></button>
  <button onclick="allocate(4096-OVERHEAD); update()">4 KB - Î´  <span class="sub">fl=4 sl=MSB</span></button>
  (e.g. allocate 3, free middle, check second level)
</p>
<p>
  Large blocks:
  <button onclick="allocate(67108864-OVERHEAD); update()">64 MB - Î´ <span class="sub">fl=MSB-4 sl=MSB</span></button>
  <button onclick="allocate(134217728-OVERHEAD); update()">128 MB - Î´ <span class="sub">fl=MSB-3 sl=MSB</span></button>
  <button onclick="allocate(268435456-OVERHEAD); update()">256 MB - Î´ <span class="sub">fl=MSB-2 sl=MSB</span></button>
  <button onclick="allocate(536870912-OVERHEAD); update()">512 MB - Î´ <span class="sub">fl=MSB-1 sl=MSB</span></button>
  <button onclick="allocate(1073741824-OVERHEAD); update()">1 GB - Î´ <span class="sub">fl=MSB sl=MSB</span></button>
</p>
</p>

<h2>Segments</h2>
<p>Allocations performed above are tracked here so you can free them again. Note that TLSF alone does not keep track of used blocks (unless free'd and put in a free list again). It is expected that adjacent free blocks become merged automatically.</p>
<div id="segs"></div>
<div class="clear"></div>

'''
'''--- lib/rtrace/umd/index.d.ts ---
export * from "../index";

'''
'''--- lib/rtrace/umd/index.js ---
// GENERATED FILE. DO NOT EDIT.
var rtrace = (function(exports) {
  "use strict";
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = exports.Rtrace = exports.TOTAL_OVERHEAD = exports.OBJECT_OVERHEAD = exports.BLOCK_OVERHEAD = void 0;
  // WebAssembly pages are 65536 kb
  const PAGE_SIZE_BITS = 16;
  const PAGE_SIZE = 1 << PAGE_SIZE_BITS;
  const PAGE_MASK = PAGE_SIZE - 1; // Wasm32 pointer size is 4 bytes
  
  const PTR_SIZE_BITS = 2;
  const PTR_SIZE = 1 << PTR_SIZE_BITS;
  const PTR_MASK = PTR_SIZE - 1;
  const PTR_VIEW = Uint32Array;
  const BLOCK_OVERHEAD = PTR_SIZE;
  exports.BLOCK_OVERHEAD = BLOCK_OVERHEAD;
  const OBJECT_OVERHEAD = 16;
  exports.OBJECT_OVERHEAD = OBJECT_OVERHEAD;
  const TOTAL_OVERHEAD = BLOCK_OVERHEAD + OBJECT_OVERHEAD;
  exports.TOTAL_OVERHEAD = TOTAL_OVERHEAD;
  
  function assert(x) {
    if (!x) throw Error("assertion failed");
    return x;
  }
  
  Error.stackTraceLimit = 15;
  
  function trimStacktrace(stack, levels) {
    return stack.split(/\r?\n/).slice(1 + levels);
  }
  
  const hrtime = typeof performance !== "undefined" && performance.now ? performance.now : typeof process !== "undefined" && process.hrtime ? () => {
    let t = process.hrtime();
    return t[0] * 1e3 + t[1] / 1e6;
  } : Date.now;
  const mmTagsToString = ["", "FREE", "LEFTFREE", "FREE+LEFTFREE"];
  const gcColorToString = ["BLACK/WHITE", "WHITE/BLACK", "GRAY", "INVALID"];
  
  class Rtrace {
    constructor(options) {
      this.options = options || {};
  
      this.onerror = this.options.onerror || function () {
        /* nop */
      };
  
      this.oninfo = this.options.oninfo || function () {
        /* nop */
      };
  
      this.oncollect_ = this.options.oncollect || function () {
        /* nop */
      };
  
      this.memory = null;
      this.shadow = null;
      this.shadowStart = 0x100000000;
      this.blocks = new Map();
      this.allocSites = new Map();
      this.freedBlocks = new Map();
      this.gcProfileStart = 0;
      this.gcProfile = [];
      this.allocCount = 0;
      this.resizeCount = 0;
      this.moveCount = 0;
      this.freeCount = 0;
      this.heapBase = 0x100000000;
    }
  
    install(imports) {
      if (!imports) imports = {};
      imports.rtrace = Object.assign(imports.rtrace || {}, {
        oninit: this.oninit.bind(this),
        onalloc: this.onalloc.bind(this),
        onresize: this.onresize.bind(this),
        onmove: this.onmove.bind(this),
        onvisit: this.onvisit.bind(this),
        onfree: this.onfree.bind(this),
        oninterrupt: this.oninterrupt.bind(this),
        onyield: this.onyield.bind(this),
        oncollect: this.oncollect.bind(this),
        onstore: this.onstore.bind(this),
        onload: this.onload.bind(this)
      });
      return imports;
    }
    /** Synchronizes the shadow memory with the module's memory. */
  
  
    syncShadow() {
      if (!this.memory) {
        this.memory = assert(this.options.getMemory());
        this.shadow = new WebAssembly.Memory({
          initial: (this.memory.buffer.byteLength + PAGE_MASK & ~PAGE_MASK) >>> PAGE_SIZE_BITS
        });
      } else {
        var diff = this.memory.buffer.byteLength - this.shadow.buffer.byteLength;
        if (diff > 0) this.shadow.grow(diff >>> 16);
      }
    }
    /** Marks a block's presence in shadow memory. */
  
  
    markShadow(info, oldSize = 0) {
      assert(this.shadow && this.shadow.byteLength == this.memory.byteLength);
      assert((info.size & PTR_MASK) == 0);
  
      if (info.ptr < this.shadowStart) {
        this.shadowStart = info.ptr;
      }
  
      var len = info.size >>> PTR_SIZE_BITS;
      var view = new PTR_VIEW(this.shadow.buffer, info.ptr, len);
      var errored = false;
      var start = oldSize >>> PTR_SIZE_BITS;
  
      for (let i = 0; i < start; ++i) {
        if (view[i] != info.ptr && !errored) {
          this.onerror(Error("shadow region mismatch: " + view[i] + " != " + info.ptr), info);
          errored = true;
        }
      }
  
      errored = false;
  
      for (let i = start; i < len; ++i) {
        if (view[i] != 0 && !errored) {
          this.onerror(Error("shadow region already in use: " + view[i] + " != 0"), info);
          errored = true;
        }
  
        view[i] = info.ptr;
      }
    }
    /** Unmarks a block's presence in shadow memory. */
  
  
    unmarkShadow(info, oldSize = info.size) {
      assert(this.shadow && this.shadow.byteLength == this.memory.byteLength);
      var len = oldSize >>> PTR_SIZE_BITS;
      var view = new PTR_VIEW(this.shadow.buffer, info.ptr, len);
      var errored = false;
      var start = 0;
  
      if (oldSize != info.size) {
        assert(oldSize > info.size);
        start = info.size >>> PTR_SIZE_BITS;
      }
  
      for (let i = 0; i < len; ++i) {
        if (view[i] != info.ptr && !errored) {
          this.onerror(Error("shadow region mismatch: " + view[i] + " != " + info.ptr), info);
          errored = true;
        }
  
        if (i >= start) view[i] = 0;
      }
    }
    /** Performs an access to shadow memory. */
  
  
    accessShadow(ptr, size, isLoad, isRT) {
      this.syncShadow();
      if (ptr < this.shadowStart) return;
      var value = new Uint32Array(this.shadow.buffer, ptr & ~PTR_MASK, 1)[0];
      if (value != 0) return;
  
      if (!isRT) {
        let stack = trimStacktrace(new Error().stack, 2);
        this.onerror(new Error("OOB " + (isLoad ? "load" : "store") + 8 * size + " at address " + ptr + "\n" + stack.join("\n")));
      }
    }
    /** Obtains information about a block. */
  
  
    getBlockInfo(ptr) {
      const [mmInfo, gcInfo, gcInfo2, rtId, rtSize] = new Uint32Array(this.memory.buffer, ptr, 5);
      const size = mmInfo & ~3;
      return {
        ptr,
        size: BLOCK_OVERHEAD + size,
        // total incl. overhead
        mmInfo: {
          tags: mmTagsToString[mmInfo & 3],
          size: size // as stored excl. overhead
  
        },
        gcInfo: {
          color: gcColorToString[gcInfo & 3],
          next: gcInfo & ~3,
          prev: gcInfo2
        },
        rtId,
        rtSize
      };
    }
    /** Checks if rtrace is active, i.e. at least one event has occurred. */
  
  
    get active() {
      return Boolean(this.allocCount || this.resizeCount || this.moveCount || this.freeCount);
    }
    /** Checks if there are any leaks and emits them via `oninfo`. Returns the number of live blocks. */
  
  
    check() {
      if (this.oninfo) {
        for (let [ptr, info] of this.blocks) {
          this.oninfo("LIVE " + ptr + "\n" + info.allocStack.join("\n"));
        }
      }
  
      return this.blocks.size;
    } // Runtime instrumentation
  
  
    oninit(heapBase) {
      this.heapBase = heapBase;
      this.gcProfileStart = 0;
      this.gcProfile.length = 0;
      this.oninfo("INIT heapBase=" + heapBase);
    }
  
    onalloc(ptr) {
      this.syncShadow();
      ++this.allocCount;
      var info = this.getBlockInfo(ptr);
  
      if (this.blocks.has(ptr)) {
        this.onerror(Error("duplicate alloc: " + ptr), info);
      } else {
        this.oninfo("ALLOC " + ptr + ".." + (ptr + info.size));
        this.markShadow(info);
        let allocStack = trimStacktrace(new Error().stack, 1); // strip onalloc
  
        this.blocks.set(ptr, Object.assign(info, {
          allocStack
        }));
      }
    }
  
    onresize(ptr, oldSize) {
      this.syncShadow();
      ++this.resizeCount;
      const info = this.getBlockInfo(ptr);
  
      if (!this.blocks.has(ptr)) {
        this.onerror(Error("orphaned resize: " + ptr), info);
      } else {
        const beforeInfo = this.blocks.get(ptr);
  
        if (beforeInfo.size != oldSize) {
          this.onerror(Error(`size mismatch upon resize: ${ptr} (${beforeInfo.size} != ${oldSize})`), info);
        }
  
        const newSize = info.size;
        this.oninfo("RESIZE " + ptr + ".." + (ptr + newSize) + " (" + oldSize + "->" + newSize + ")");
        this.blocks.set(ptr, Object.assign(info, {
          allocStack: beforeInfo.allocStack
        }));
  
        if (newSize > oldSize) {
          this.markShadow(info, oldSize);
        } else if (newSize < oldSize) {
          this.unmarkShadow(info, oldSize);
        }
      }
    }
  
    onmove(oldPtr, newPtr) {
      this.syncShadow();
      ++this.moveCount;
      var oldInfo = this.getBlockInfo(oldPtr);
      var newInfo = this.getBlockInfo(newPtr);
  
      if (!this.blocks.has(oldPtr)) {
        this.onerror(Error("orphaned move (old): " + oldPtr), oldInfo);
      } else {
        if (!this.blocks.has(newPtr)) {
          this.onerror(Error("orphaned move (new): " + newPtr), newInfo);
        } else {
          const beforeInfo = this.blocks.get(oldPtr);
          const oldSize = oldInfo.size;
          const newSize = newInfo.size;
  
          if (beforeInfo.size != oldSize) {
            this.onerror(Error(`size mismatch upon move: ${oldPtr} (${beforeInfo.size} != ${oldSize})`), oldInfo);
          }
  
          this.oninfo("MOVE " + oldPtr + ".." + (oldPtr + oldSize) + " -> " + newPtr + ".." + (newPtr + newSize)); // calls new alloc before and old free after
        }
      }
    }
  
    onvisit(ptr) {
      // Indicates that a block has been freed but it still visited by the GC
      if (ptr > this.heapBase && !this.blocks.has(ptr)) {
        let err = Error("orphaned visit: " + ptr);
        let info = this.freedBlocks.get(ptr);
  
        if (info) {
          err.stack += "\n^ allocated at:\n" + info.allocStack.join("\n");
          err.stack += "\n^ freed at:\n" + info.freeStack.join("\n");
        }
  
        this.onerror(err, null);
        return false;
      }
  
      return true;
    }
  
    onfree(ptr) {
      this.syncShadow();
      ++this.freeCount;
      var info = this.getBlockInfo(ptr);
  
      if (!this.blocks.has(ptr)) {
        this.onerror(Error("orphaned free: " + ptr), info);
      } else {
        const oldInfo = this.blocks.get(ptr);
  
        if (info.size != oldInfo.size) {
          this.onerror(Error(`size mismatch upon free: ${ptr} (${oldInfo.size} != ${info.size})`), info);
        }
  
        this.oninfo("FREE " + ptr + ".." + (ptr + info.size));
        this.unmarkShadow(info);
        const allocInfo = this.blocks.get(ptr);
        this.blocks.delete(ptr);
        const allocStack = allocInfo.allocStack;
        const freeStack = trimStacktrace(new Error().stack, 1); // strip onfree
        // (not much) TODO: Maintaining these is essentially a memory leak
  
        this.freedBlocks.set(ptr, {
          allocStack,
          freeStack
        });
      }
    }
  
    oncollect(total) {
      this.oninfo(`COLLECT at ${total}`);
      this.plot(total);
      this.oncollect_();
    } // GC profiling
  
  
    plot(total, pause = 0) {
      if (!this.gcProfileStart) this.gcProfileStart = Date.now();
      this.gcProfile.push([Date.now() - this.gcProfileStart, total, pause]);
    }
  
    oninterrupt(total) {
      this.interruptStart = hrtime();
      this.plot(total);
    }
  
    onyield(total) {
      var pause = hrtime() - this.interruptStart;
      if (pause >= 1) console.log("interrupted for " + pause.toFixed(1) + "ms");
      this.plot(total, pause);
    } // Memory instrumentation
  
  
    onstore(ptr, offset, bytes, isRT) {
      this.accessShadow(ptr + offset, bytes, false, isRT);
      return ptr;
    }
  
    onload(ptr, offset, bytes, isRT) {
      this.accessShadow(ptr + offset, bytes, true, isRT);
      return ptr;
    }
  
  }
  
  exports.Rtrace = Rtrace;
  var _default = {
    Rtrace
  };
  exports.default = _default;
  return exports;
})({});
if (typeof define === 'function' && define.amd) define([], function() { return rtrace; });
else if (typeof module === 'object' && typeof exports==='object') module.exports = rtrace;

'''
'''--- lib/rtrace/umd/package.json ---
{
  "private": true,
  "type": "commonjs"
}
'''
'''--- lib/sdk/README.md ---
# Browser SDK

An SDK to use the AssemblyScript compiler on the web. This is built to distribution files using the exact versions of the compiler and its dependencies.

Expects [require.js](https://requirejs.org) (or compatible) on the web, primarily targeting [WebAssembly Studio](https://webassembly.studio). Note that consuming the source file in this directory directly does not solve any versioning issues - use `dist/sdk.js` instead. Do not try to bundle this.

Exports
-------

* **binaryen**<br />
  The version of binaryen required by the compiler.

* **long**<br />
  The version of long.js required by the compiler.

* **assemblyscript**<br />
  The AssemblyScript compiler as a library.

* **asc**<br />
  AssemblyScript compiler frontend that one will interact with
  ([see](https://github.com/AssemblyScript/assemblyscript/tree/main/cli)).

Example usage
-------------

```js
require(
  ["https://cdn.jsdelivr.net/npm/assemblyscript@latest/dist/sdk"],
  function(sdk) {
    const { asc } = sdk;
    asc.ready.then(() => {
      asc.main(...);
    });
  }
);
```

There is also the [SDK example](https://github.com/AssemblyScript/examples/tree/main/sdk) showing how to compile some actual code.

'''
'''--- lib/sdk/index.js ---
const BINARYEN_VERSION = "nightly";
const LONG_VERSION = "latest";
const ASSEMBLYSCRIPT_VERSION = "latest";

// AMD/require.js (browser)
if (typeof define === "function" && define.amd) {
  const paths = {
    "binaryen": "https://cdn.jsdelivr.net/npm/binaryen@" + BINARYEN_VERSION + "/index",
    "long": "https://cdn.jsdelivr.net/npm/long@" + LONG_VERSION + "/dist/long",
    "assemblyscript": "https://cdn.jsdelivr.net/npm/assemblyscript@" + ASSEMBLYSCRIPT_VERSION + "/dist/assemblyscript",
    "assemblyscript/cli/asc": "https://cdn.jsdelivr.net/npm/assemblyscript@" + ASSEMBLYSCRIPT_VERSION + "/dist/asc",
  };
  require.config({ paths });
  define(Object.keys(paths), (binaryen, long, assemblyscript, asc) => ({
    BINARYEN_VERSION,
    LONG_VERSION,
    ASSEMBLYSCRIPT_VERSION,
    binaryen,
    long,
    assemblyscript,
    asc
  }));

// CommonJS fallback (node)
} else if (typeof module === "object" && module.exports) {
  module.exports = {
    BINARYEN_VERSION,
    LONG_VERSION,
    ASSEMBLYSCRIPT_VERSION,
    binaryen: require("binaryen"),
    long: require("long"),
    assemblyscript: require("assemblyscript"),
    asc: require("assemblyscript/cli/asc")
  };
}

'''
'''--- lib/sdk/tests/index.html ---
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script>
<script>
function assert(x) {
  if (!x) throw Error("assertion failed");
}
require(["../index"], function(sdk) {
  const { BINARYEN_VERSION, LONG_VERSION, ASSEMBLYSCRIPT_VERSION, binaryen, long, assemblyscript, asc } = sdk;
  assert(typeof BINARYEN_VERSION === "string");
  assert(typeof LONG_VERSION === "string");
  assert(typeof ASSEMBLYSCRIPT_VERSION === "string");
  console.log("Binaryen@" + BINARYEN_VERSION);
  console.log("Long@" + LONG_VERSION);
  console.log("AssemblyScript@" + ASSEMBLYSCRIPT_VERSION);
  assert(typeof binaryen === "object" && binaryen && typeof binaryen._BinaryenTypeNone === "function");
  assert(typeof long === "function" && long && typeof long.fromInt === "function");
  assert(typeof assemblyscript === "object" && assemblyscript && typeof assemblyscript.parse === "function");
  assert(typeof asc === "object" && asc && typeof asc.main === "function");
  asc.ready.then(() => console.log("ready", sdk));
});
</script>

'''
'''--- lib/webpack/README.md ---
# Webpack loader

An experimental [webpack](https://webpack.js.org/) loader for [AssemblyScript](http://assemblyscript.org) modules.

Usage
-----

```js
import MyModule from "@assemblyscript/webpack!mymodule.wasm";

var myModule = new MyModule({ imports: { /* if any */ } });
```

TODO: Pipe .ts files through `asc`, accepting the usual options, but also keep raw .wasm support.

'''
'''--- lib/webpack/decode.js ---
var s64 = new Array(123);
for (var i = 0; i < 64;) s64[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

module.exports = function decode(string) {
  var length = string.length;
  if (length) {
    var n = 0, p = length;
    while (--p % 4 > 1 && string.charCodeAt(p) === 61) ++n;
    length = Math.ceil(length * 3) / 4 - n;
  }
  var buffer = new Uint8Array(length);
  var j = 0, o = 0, t;
  for (var i = 0, k = string.length; i < k;) {
    var c = string.charCodeAt(i++);
    if (c === 61 && j > 1) break;
    if ((c = s64[c]) === undefined) throw Error();
    switch (j) {
      case 0: t = c; j = 1; break;
      case 1: buffer[o++] = t << 2 | (c & 48) >> 4; t = c; j = 2; break;
      case 2: buffer[o++] = (t & 15) << 4 | (c & 60) >> 2; t = c; j = 3; break;
      case 3: buffer[o++] = (t & 3) << 6 | c; j = 0; break;
    }
  }
  if (j === 1) throw Error();
  return buffer;
};

'''
'''--- lib/webpack/index.js ---
const fs = require("fs");
const path = require("path");
const asc = require("assemblyscript/cli/asc.js");
const base64 = require("@protobufjs/base64");

const MAGIC = Buffer.from([ 0x00, 0x61, 0x73, 0x6D ]);

module.exports = loader;

function loader(buffer) {
  if (MAGIC.compare(buffer, 0, 4) !== 0)
    return compile.call(this);
  else
    return bundle.call(this, buffer);
}

loader.raw = true;

function compile() {
  const basePath = this.resourcePath.replace(/\.\w+$/, "");
  const args = [
    path.basename(this.resourcePath),
    "--baseDir", path.dirname(this.resourcePath),
    "--binaryFile", basePath + ".wasm",
    "--textFile", basePath + ".wat",
    "--optimize"
  ];
  if (this.sourceMap)
    args.push("--sourceMap");
  asc.main(args, err => {
    if (err)
      return this.callback(err);
    fs.readFile(basePath + ".wasm", (err, binary) => {
      if (err)
        return this.callback(err);
      if (!this.sourceMap)
        return this.callback(null, bundle(binary));
      fs.readFile(basePath + ".wasm.map", (err, sourceMap) => {
        if (err)
          return this.callback(err);
        return this.callback(null, bundle(binary), sourceMap.toString("utf8"));
      });
    });
  });
}

function bundle(binary) {
  const data = base64.encode(binary, 0, binary.wasm);
  return [
    'var data = "' + data + '", wasm;',
    'module.exports = function AssemblyScriptModule(options) {',
    '  if (!wasm)',
    '    wasm = new WebAssembly.Module(require("@assemblyscript/webpack/decode")(data));',
    '  return new WebAssembly.Instance(wasm, options && options.imports || {}).exports;',
    '};'
  ].join("\n") + "\n";
}

'''
'''--- lib/webpack/package.json ---
{
  "name": "@assemblyscript/webpack",
  "version": "0.5.0",
  "description": "webpack loader for AssemblyScript modules.",
  "license": "Apache-2.0",
  "dependencies": {
    "@protobufjs/base64": "^1.1.2"
  }
}

'''
'''--- media/architecture.svg ---
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="540px" height="323px" version="1.1"><defs/><g transform="translate(0.5,0.5)"><path d="M 20.39 201 L 95.9 201 C 98.72 201 101 203.24 101 206 L 101 256 C 101 258.76 98.72 261 95.9 261 L 6.1 261 C 3.28 261 1 258.76 1 256 L 1 221 L 20.39 201 Z" fill="#ffffff" stroke="#000000" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><g transform="translate(7.5,222.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="85" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 86px; white-space: nowrap; overflow-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">AssemblyScript</div></div></foreignObject><text x="43" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">AssemblyScript</text></switch></g><rect x="121" y="211" width="90" height="40" rx="2.69" ry="2.69" fill="#ffffff" stroke="#000000" stroke-width="2" pointer-events="none"/><path d="M 133.86 211 L 133.86 251" fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><path d="M 198.14 211 L 198.14 251" fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><g transform="translate(139.5,222.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="52" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 53px; white-space: nowrap; overflow-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">Tokenizer</div></div></foreignObject><text x="26" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">Tokenizer</text></switch></g><path d="M 12.36 5.98 C 12.36 4.66 12.96 3.39 14.03 2.46 C 15.09 1.52 16.54 1 18.05 1 L 95.32 1 C 96.83 1 98.27 1.52 99.34 2.46 C 100.4 3.39 101 4.66 101 5.98 L 101 45.79 C 86.84 40.54 70.85 40.54 56.68 45.79 C 42.52 51.05 26.53 51.05 12.36 45.79 Z" fill="#dae8fc" stroke="#6c8ebf" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><path d="M 6.68 10.95 C 6.68 8.2 9.23 5.98 12.36 5.98 L 89.64 5.98 C 92.77 5.98 95.32 8.2 95.32 10.95 L 95.32 50.77 C 81.15 45.51 65.16 45.51 51 50.77 C 36.84 56.02 20.85 56.02 6.68 50.77 Z" fill="#dae8fc" stroke="#6c8ebf" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><path d="M 1 15.93 C 1 14.61 1.6 13.34 2.66 12.41 C 3.73 11.48 5.17 10.95 6.68 10.95 L 83.95 10.95 C 85.46 10.95 86.91 11.48 87.97 12.41 C 89.04 13.34 89.64 14.61 89.64 15.93 L 89.64 55.74 C 75.47 50.49 59.48 50.49 45.32 55.74 C 31.15 61 15.16 61 1 55.74 Z" fill="#dae8fc" stroke="#6c8ebf" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><g transform="translate(16.5,22.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="68" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 69px; white-space: nowrap; overflow-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">TypeScriptÂ Â Â Â  </div></div></foreignObject><text x="34" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">[Not supported by viewer]</text></switch></g><rect x="221" y="211" width="90" height="40" rx="2.69" ry="2.69" fill="#ffffff" stroke="#000000" stroke-width="2" pointer-events="none"/><path d="M 233.86 211 L 233.86 251" fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><path d="M 298.14 211 L 298.14 251" fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><g transform="translate(246.5,222.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="37" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 38px; white-space: nowrap; overflow-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">Parser</div></div></foreignObject><text x="19" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">Parser</text></switch></g><rect x="325" y="211" width="87" height="40" rx="2.69" ry="2.69" fill="#ffffff" stroke="#000000" stroke-width="2" pointer-events="none"/><path d="M 337.43 211 L 337.43 251" fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><path d="M 399.57 211 L 399.57 251" fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><g transform="translate(343.5,222.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="48" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 49px; white-space: nowrap; overflow-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">Program</div></div></foreignObject><text x="24" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">Program</text></switch></g><rect x="421" y="211" width="90" height="40" rx="2.69" ry="2.69" fill="#ffffff" stroke="#000000" stroke-width="2" pointer-events="none"/><path d="M 433.86 211 L 433.86 251" fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><path d="M 498.14 211 L 498.14 251" fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><g transform="translate(439.5,222.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="51" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 52px; white-space: nowrap; overflow-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">Compiler</div></div></foreignObject><text x="26" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">Compiler</text></switch></g><path d="M 20.39 88 L 95.9 88 C 98.72 88 101 90.24 101 93 L 101 143 C 101 145.76 98.72 148 95.9 148 L 6.1 148 C 3.28 148 1 145.76 1 143 L 1 108 L 20.39 88 Z" fill="#ffffff" stroke="#000000" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><g transform="translate(2.5,94.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="96" height="41" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 96px; white-space: normal; overflow-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">Compiler frontend<br />(asc)</div></div></foreignObject><text x="48" y="27" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">Compiler frontend&lt;br&gt;(asc)</text></switch></g><path d="M 51.33 53.67 L 51.08 74.63" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 51.01 79.88 L 47.6 72.84 L 51.08 74.63 L 54.6 72.93 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 101.33 231.17 L 114.97 231.17" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 120.22 231.17 L 113.22 234.67 L 114.97 231.17 L 113.22 227.67 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 166.33 251.17 L 187.26 276.27" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 190.62 280.31 L 183.45 277.17 L 187.26 276.27 L 188.83 272.69 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 291.33 281.17 L 321.56 254.54" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 325.49 251.07 L 322.56 258.33 L 321.56 254.54 L 317.93 253.07 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 166.69 284.4 C 167.62 282.27 169.14 281.02 170.74 281.08 L 226.63 281.08 C 227.9 281.05 229.12 281.42 229.92 282.08 C 230.71 282.73 231 283.59 230.68 284.4 L 215.29 317.6 C 214.35 319.73 212.84 320.98 211.24 320.92 L 154.54 320.92 C 153.41 320.8 152.41 320.36 151.8 319.73 C 151.18 319.1 151 318.32 151.3 317.6 Z" fill="#ffffff" stroke="#000000" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><g transform="translate(170.5,292.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="40" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 41px; white-space: nowrap; overflow-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">Tokens</div></div></foreignObject><text x="20" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">Tokens</text></switch></g><path d="M 266.69 284.4 C 267.62 282.27 269.14 281.02 270.74 281.08 L 326.63 281.08 C 327.9 281.05 329.12 281.42 329.92 282.08 C 330.71 282.73 331 283.59 330.68 284.4 L 315.29 317.6 C 314.35 319.73 312.84 320.98 311.24 320.92 L 254.54 320.92 C 253.41 320.8 252.41 320.36 251.8 319.73 C 251.18 319.1 251 318.32 251.3 317.6 Z" fill="#ffffff" stroke="#000000" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><g transform="translate(279.5,292.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="22" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 23px; white-space: nowrap; overflow-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">AST</div></div></foreignObject><text x="11" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">AST</text></switch></g><path d="M 463.69 284.4 C 464.62 282.27 466.14 281.02 467.74 281.08 L 523.63 281.08 C 524.9 281.05 526.12 281.42 526.92 282.08 C 527.71 282.73 528 283.59 527.68 284.4 L 512.29 317.6 C 511.35 319.73 509.84 320.98 508.24 320.92 L 451.54 320.92 C 450.41 320.8 449.41 320.36 448.8 319.73 C 448.18 319.1 448 318.32 448.3 317.6 Z" fill="#ffffff" stroke="#000000" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><g transform="translate(467.5,292.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="40" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 41px; white-space: nowrap; overflow-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">Module</div></div></foreignObject><text x="20" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">Module</text></switch></g><path d="M 191.33 281.17 L 218.44 254.78" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 222.2 251.11 L 219.63 258.5 L 218.44 254.78 L 214.74 253.49 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 266.33 251.17 L 287.26 276.27" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 290.62 280.31 L 283.45 277.17 L 287.26 276.27 L 288.83 272.69 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 466.33 251.17 L 484.27 276" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 487.35 280.26 L 480.41 276.63 L 484.27 276 L 486.08 272.54 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 366.69 284.4 C 367.62 282.27 369.14 281.02 370.74 281.08 L 426.63 281.08 C 427.9 281.05 429.12 281.42 429.92 282.08 C 430.71 282.73 431 283.59 430.68 284.4 L 415.29 317.6 C 414.35 319.73 412.84 320.98 411.24 320.92 L 354.54 320.92 C 353.41 320.8 352.41 320.36 351.8 319.73 C 351.18 319.1 351 318.32 351.3 317.6 Z" fill="#ffffff" stroke="#000000" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><g transform="translate(384.5,292.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="12" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 13px; white-space: nowrap; overflow-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">IR</div></div></foreignObject><text x="6" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">IR</text></switch></g><path d="M 368.83 251.17 L 387.51 276.07" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 390.66 280.27 L 383.66 276.77 L 387.51 276.07 L 389.26 272.57 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 51.33 147.83 L 51.33 194.8" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 51.33 200.05 L 47.83 193.05 L 51.33 194.8 L 54.83 193.05 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 488 281.17 L 523.69 247.83 Q 531 241 531 231 L 531 134 Q 531 124 521 124 L 106.37 124" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 101.12 124 L 108.12 120.5 L 106.37 124 L 108.12 127.5 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 121 5.93 C 121 4.62 121.48 3.37 122.34 2.44 C 123.21 1.52 124.37 1 125.59 1 L 206.41 1 C 207.63 1 208.79 1.52 209.66 2.44 C 210.52 3.37 211 4.62 211 5.93 L 211 55.19 C 196.49 49.37 180.51 49.37 166 55.19 C 151.49 61 135.51 61 121 55.19 Z" fill="#e1d5e7" stroke="#9673a6" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><g transform="translate(125.5,14.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="79" height="27" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 80px; white-space: nowrap; overflow-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">WebAssembly<br />Binary</div></div></foreignObject><text x="40" y="20" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">WebAssembly&lt;br&gt;Binary</text></switch></g><path d="M 101.33 111.17 L 156 111.03 Q 166 111 166.06 101 L 166.3 61.7" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 166.33 56.45 L 169.78 63.47 L 166.3 61.7 L 162.78 63.43 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 225 5.93 C 225 3.21 226.96 1 229.39 1 L 306.61 1 C 309.04 1 311 3.21 311 5.93 L 311 55.19 C 297.13 49.37 281.87 49.37 268 55.19 C 254.13 61 238.87 61 225 55.19 Z" fill="#e1d5e7" stroke="#9673a6" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><g transform="translate(227.5,14.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="79" height="27" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 80px; white-space: nowrap; overflow-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">WebAssembly<br />Text</div></div></foreignObject><text x="40" y="20" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">WebAssembly&lt;br&gt;Text</text></switch></g><path d="M 323 5.93 C 323 4.62 323.3 3.37 323.84 2.44 C 324.37 1.52 325.1 1 325.86 1 L 376.14 1 C 376.9 1 377.63 1.52 378.16 2.44 C 378.7 3.37 379 4.62 379 5.93 L 379 55.19 C 369.97 49.37 360.03 49.37 351 55.19 C 341.97 61 332.03 61 323 55.19 Z" fill="#d5e8d4" stroke="#82b366" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><g transform="translate(331.5,22.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="38" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 39px; white-space: nowrap; overflow-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">asm.js</div></div></foreignObject><text x="19" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">asm.js</text></switch></g><path d="M 161 111 L 258 111 Q 268 111 268 101 L 268 61.7" fill="none" stroke="#000000" stroke-miterlimit="10" stroke-dasharray="3 3" pointer-events="none"/><path d="M 268 56.45 L 271.5 63.45 L 268 61.7 L 264.5 63.45 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 393 5.93 C 393 4.62 393.3 3.37 393.84 2.44 C 394.37 1.52 395.1 1 395.86 1 L 446.14 1 C 446.9 1 447.63 1.52 448.16 2.44 C 448.7 3.37 449 4.62 449 5.93 L 449 55.19 C 439.97 49.37 430.03 49.37 421 55.19 C 411.97 61 402.03 61 393 55.19 Z" fill="#f5f5f5" stroke="#666666" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><g transform="translate(398.5,22.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="44" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 45px; white-space: nowrap; overflow-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">WebIDL</div></div></foreignObject><text x="22" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">WebIDL</text></switch></g><path d="M 460 5.93 C 460 4.62 460.3 3.37 460.84 2.44 C 461.37 1.52 462.1 1 462.86 1 L 513.14 1 C 513.9 1 514.63 1.52 515.16 2.44 C 515.7 3.37 516 4.62 516 5.93 L 516 55.19 C 506.97 49.37 497.03 49.37 488 55.19 C 478.97 61 469.03 61 460 55.19 Z" fill="#f5f5f5" stroke="#666666" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><g transform="translate(475.5,22.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="24" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 25px; white-space: nowrap; overflow-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">DTS</div></div></foreignObject><text x="12" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">DTS</text></switch></g><path d="M 395.9 276.72 L 418.44 254.78" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 392.13 280.39 L 394.71 273 L 395.9 276.72 L 399.59 278.01 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 422.2 251.11 L 419.63 258.5 L 418.44 254.78 L 414.74 253.49 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 261 111 L 341 111 Q 351 111 351.06 101 L 351.3 61.7" fill="none" stroke="#000000" stroke-miterlimit="10" stroke-dasharray="3 3" pointer-events="none"/><path d="M 351.33 56.45 L 354.78 63.47 L 351.3 61.7 L 347.78 63.43 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 341 111 L 411 111 Q 421 111 421.06 101 L 421.3 61.7" fill="none" stroke="#000000" stroke-miterlimit="10" stroke-dasharray="3 3" pointer-events="none"/><path d="M 421.33 56.45 L 424.78 63.47 L 421.3 61.7 L 417.78 63.43 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 411 111 L 478 111 Q 488 111 488 101 L 488 61.37" fill="none" stroke="#000000" stroke-miterlimit="10" stroke-dasharray="3 3" pointer-events="none"/><path d="M 488 56.12 L 491.5 63.12 L 488 61.37 L 484.5 63.12 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 466.33 204.8 L 466.33 191.7" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 466.33 210.05 L 462.83 203.05 L 466.33 204.8 L 469.83 203.05 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 466.33 186.45 L 469.83 193.45 L 466.33 191.7 L 462.83 193.45 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 446.1 145 L 495.18 145 C 496.06 145 496.91 145.35 497.53 145.98 C 498.15 146.6 498.5 147.45 498.5 148.33 L 498.5 181.67 C 498.5 182.55 498.15 183.4 497.53 184.02 C 496.91 184.65 496.06 185 495.18 185 L 436.82 185 C 435.94 185 435.09 184.65 434.47 184.02 C 433.85 183.4 433.5 182.55 433.5 181.67 L 433.5 158.33 L 446.1 145 Z" fill="#ffffff" stroke="#000000" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><g transform="translate(441.5,156.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="48" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 49px; white-space: nowrap; overflow-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">Binaryen</div></div></foreignObject><text x="24" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">Binaryen</text></switch></g><path d="M 343.5 143.31 C 343.5 140.93 345.18 139 347.25 139 L 398.25 139 C 400.32 139 402 140.93 402 143.31 L 402 177.82 C 392.65 173.26 382.1 173.26 372.75 177.82 C 363.4 182.37 352.85 182.37 343.5 177.82 Z" fill="#ffffff" stroke="#000000" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><path d="M 339.75 147.63 C 339.75 145.24 341.43 143.31 343.5 143.31 L 394.5 143.31 C 396.57 143.31 398.25 145.24 398.25 147.63 L 398.25 182.13 C 388.9 177.58 378.35 177.58 369 182.13 C 359.65 186.69 349.1 186.69 339.75 182.13 Z" fill="#ffffff" stroke="#000000" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><path d="M 336 151.94 C 336 150.8 336.4 149.7 337.1 148.89 C 337.8 148.08 338.76 147.63 339.75 147.63 L 390.75 147.63 C 391.74 147.63 392.7 148.08 393.4 148.89 C 394.1 149.7 394.5 150.8 394.5 151.94 L 394.5 186.45 C 385.15 181.89 374.6 181.89 365.25 186.45 C 355.9 191 345.35 191 336 186.45 Z" fill="#ffffff" stroke="#000000" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><g transform="translate(346.5,156.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="43" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 44px; white-space: nowrap; overflow-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">builtinsÂ  </div></div></foreignObject><text x="22" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">builtinsÂ  </text></switch></g><path d="M 131.33 165.33 L 81 165.06 Q 71 165 70.84 159.18 L 70.68 153.37" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 70.53 148.12 L 74.22 155.02 L 70.68 153.37 L 67.23 155.21 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 138.95 143.31 C 138.95 142.17 139.37 141.07 140.12 140.26 C 140.87 139.45 141.88 139 142.93 139 L 197.02 139 C 198.08 139 199.09 139.45 199.84 140.26 C 200.58 141.07 201 142.17 201 143.31 L 201 177.82 C 191.09 173.26 179.89 173.26 169.98 177.82 C 160.06 182.37 148.87 182.37 138.95 177.82 Z" fill="#ffffff" stroke="#000000" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><path d="M 134.98 147.63 C 134.98 146.48 135.4 145.39 136.14 144.58 C 136.89 143.77 137.9 143.31 138.95 143.31 L 193.05 143.31 C 194.1 143.31 195.11 143.77 195.86 144.58 C 196.6 145.39 197.02 146.48 197.02 147.63 L 197.02 182.13 C 187.11 177.58 175.91 177.58 166 182.13 C 156.09 186.69 144.89 186.69 134.98 182.13 Z" fill="#ffffff" stroke="#000000" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><path d="M 131 151.94 C 131 150.8 131.42 149.7 132.16 148.89 C 132.91 148.08 133.92 147.63 134.98 147.63 L 189.07 147.63 C 190.12 147.63 191.13 148.08 191.88 148.89 C 192.63 149.7 193.05 150.8 193.05 151.94 L 193.05 186.45 C 183.13 181.89 171.94 181.89 162.02 186.45 C 152.11 191 140.91 191 131 186.45 Z" fill="#ffffff" stroke="#000000" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><g transform="translate(157.5,156.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="16" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 17px; white-space: nowrap; overflow-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">libÂ  </div></div></foreignObject><text x="8" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">[Not supported by viewer]</text></switch></g><path d="M 398 182 L 418.92 207.11" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 422.28 211.14 L 415.11 208 L 418.92 207.11 L 420.49 203.52 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 242.5 143.31 C 242.5 140.93 244.18 139 246.25 139 L 297.25 139 C 299.32 139 301 140.93 301 143.31 L 301 177.82 C 291.65 173.26 281.1 173.26 271.75 177.82 C 262.4 182.37 251.85 182.37 242.5 177.82 Z" fill="#ffffff" stroke="#000000" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><path d="M 238.75 147.63 C 238.75 145.24 240.43 143.31 242.5 143.31 L 293.5 143.31 C 295.57 143.31 297.25 145.24 297.25 147.63 L 297.25 182.13 C 287.9 177.58 277.35 177.58 268 182.13 C 258.65 186.69 248.1 186.69 238.75 182.13 Z" fill="#ffffff" stroke="#000000" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><path d="M 235 151.94 C 235 150.8 235.4 149.7 236.1 148.89 C 236.8 148.08 237.76 147.63 238.75 147.63 L 289.75 147.63 C 290.74 147.63 291.7 148.08 292.4 148.89 C 293.1 149.7 293.5 150.8 293.5 151.94 L 293.5 186.45 C 284.15 181.89 273.6 181.89 264.25 186.45 C 254.9 191 244.35 191 235 186.45 Z" fill="#ffffff" stroke="#000000" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><g transform="translate(251.5,156.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="32" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 33px; white-space: nowrap; overflow-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">typesÂ  </div></div></foreignObject><text x="16" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">typesÂ  </text></switch></g><path d="M 297.17 181.17 L 321.96 207.37" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 325.57 211.19 L 318.21 208.51 L 321.96 207.37 L 323.3 203.7 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"/><path d="M 31 284.34 C 37.45 287.68 44.55 287.68 51 284.34 C 57.45 281 64.55 281 71 284.34 L 71 312.65 C 64.55 309.31 57.45 309.31 51 312.65 C 44.55 316 37.45 316 31 312.65 L 31 284.34 Z" fill="#ffffff" stroke="#000000" stroke-width="2" stroke-miterlimit="10" pointer-events="none"/><g transform="translate(37.5,289.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="26" height="12" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; width: 27px; white-space: nowrap; overflow-wrap: normal; text-align: center;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;">Glue</div></div></foreignObject><text x="13" y="12" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">Glue</text></switch></g><path d="M 51.33 284.5 L 51.33 261.17" fill="none" stroke="#000000" stroke-miterlimit="10" stroke-dasharray="3 3" pointer-events="none"/></g></svg>
'''
'''--- media/architecture.xml ---
<mxfile userAgent="Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:59.0) Gecko/20100101 Firefox/59.0" version="8.4.7" editor="www.draw.io" type="device"><diagram id="2a57dd10-aaee-7421-e35c-428113cf0bf5" name="Page-1">7Vxbj5s4FP41kXYfNgJsbo9z6XYrbaXRZqS2T5UDTsIWYmScJtlfvyZcArYzDRkTksykDwVjjPnOdy4+x8wIPCSbjxSli88kxPHIMsLNCDyOLMs0PY//l7dsixYHwKJhTqOw7LRvmET/4bLRKFtXUYizVkdGSMyitN0YkOUSB6zVhigl63a3GYnbT03RHEsNkwDFcuuXKGSLotW2jX37XziaL8onA1hemKLgx5yS1bJ83MgCs92vuJygaqiyf7ZAIVk3msCHEXighLDiKNk84DiHtkKtuO/PA1fraVO8ZEfdAIo7fqJ4Vb76XZbhZBpvJwGNUlZOk20rZDJGyY8aFD7h+wVLYn5o8kP+OmneL9nMc16MZzFZBwtE2ThAlD/yfr2IGJ6kKMh7rXkf3jaL4viBxITuHlDhxQfbPalxxdj9+JVyzpgyvDn44mYNJ2cpJglmdMu7bNpEK/lZn6/30jaNsm3RkLRTtqGSYPN65D3K/KAEWg26LWH+zF90yZWA6oI7pTjEs2iJw+8pJQHOsgPg64ASCFhaMpa+AkqoAUpHhnKb4oq6Dkryd1xOs+JVu54busSRrLjp+iMkwSrZgXqMHoQIe7NApQdO4OHprBc9OKcaeJLsnhDNrlMHrAF1wJdxpISDkVwjkKAKFF4A0nP7AbIifwPJB5KkUXydnIQDctK0XoDSmFGyZJjHSJYT59ZwyhudeX70G8qC399IzOG757O1pmxsJZS5QO7y0JmfBTHKsihoA403EfvKj42xXZ59253xWL84fcI04jPDOXR7yHAohdoCYHwWZEUD3HDpMoYNlGwFSFUbxTFi0c/2E1XIlU94IhGfy15EfltGDmiPUEy0vKkZVwvjOIKoBREyROeYScPspFi/81GCteQA/mTBmi2x2gekymVHt1+bJ43++akeGlQrkwKqRuA8GDXaIoWimTyRGqBHbkAN3KilvRfwt6bwJXoorYSp1UTYMjUs950bnbghL0Jfww3DahsD3ztoDg64Ea0EqdYWTYb4QxIEiPkG7/IZ4koM2aUpMoknJ4ZnIWKox6yEgFTtg5sLiZ6iX8XS9m7yfB24iQw7J27VgqWB22cSrjheVwEdtN3hoDNv2p67sj33LsnhG5rMud2bOQfyivw1BLmcYFDh6t+50ZEbcgrxNrhRiaJJDmCM3snRgRxQdsqf/rkOhwwGjGWgXod8OTrlyyoF31Wqm0rdrL21ZHIUibxLIYeYTD+RHNA8jhxchGjb6JbmHbJX0sfWa1oasX0V7A8Z6w/rn6EvrOEgPI0wpuG3BjKBUErozBj1c2wo+DjbeHFeYv9qXns6FjM4mZxyQeILnlabiuSK3320RKVn1RFPdNpigc3Qxq6q7Oc7LkCOpkyUUIdV7LFQlWF1lP0cOXbT52jG/q/MRLugBDzQu7Oxh3U2oqQtTaGIOI4m22G6tnK+umyB09EWPOONtg2Hl2gJLGFzi8ISeE5PlkCuBaIsGf+rL5vfbXObjb0QqvD2rClwNOENqqTXYbztvvDWW1871vKGKFvgsLz/eLPaNKHOsCbUvS4Tarmucr7aTKi8w5Wb0E+Pfw+jtzM7/6fSW2f301RIMYbTW7nq+fg8uWmwHX8osN1Tw9OMay+70lpWtf5q5UjeE2idrKLbZ3K1X+8Kh5S0pcu71nuwy4FceJSou3pXMYGv27u61tXyaNBtsrVqv5ZHoJJAvzwSt8Jr55GOXbhn4tFgmVVLE2fEFK3TE2f8fiN799Qt+Z2CnxaVzCHjHlUt3ruJuAeKabSKOfoDH0+OmIsEOl5K5LmRr2YgtMYCvnap8Q2aVPkW3WV8T86bTVdRzKJ8H+xFfS96HmkAKMgCerIsFMtF29IgCzkX0t3LVpauVZr49bcuY8d3xWXkQb98moH0FQayqHFcTD3D9U+zkJ4wjpg80OSyxceU0aQuj+3LxjeOpm/SDJhiFVlhBlwVMTWYAV9vsC2mhwzziPSQD1v2wwOa97RChSm4iVjpfDkiX/bcbJvit+m2620sA7htv99PzY7TV+C3FdY85PJP9N0KhR30gzNoCvuYDEGSRy9uYDtDU39p0oPGyrWXj/mRJu1M+QX6ne0uX45mitu3FFuUoYImwNagmN0yEEuyxGLSqYekw9jw9aqm4tuhy9qTenG+lJ/u/wRZ0X3/Z97Ah/8B</diagram></mxfile>
'''
'''--- package-lock.json ---
{
  "name": "assemblyscript",
  "version": "0.0.0",
  "lockfileVersion": 2,
  "requires": true,
  "packages": {
    "": {
      "version": "0.0.0",
      "license": "Apache-2.0",
      "dependencies": {
        "binaryen": "101.0.0-nightly.20210723",
        "long": "^4.0.0",
        "source-map-support": "^0.5.19",
        "ts-node": "^6.2.0"
      },
      "bin": {
        "asc": "bin/asc",
        "asinit": "bin/asinit"
      },
      "devDependencies": {
        "@types/node": "^15.6.1",
        "@typescript-eslint/eslint-plugin": "^4.9.1",
        "@typescript-eslint/parser": "^4.9.1",
        "diff": "^5.0.0",
        "eslint": "^7.15.0",
        "glob": "^7.1.6",
        "physical-cpu-count": "^2.0.0",
        "source-map-support": "^0.5.19",
        "ts-loader": "^9.2.2",
        "ts-node": "^6.2.0",
        "typescript": "~4.2.4",
        "webpack": "^5.10.0",
        "webpack-cli": "^4.2.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/assemblyscript"
      }
    },
    "node_modules/@babel/code-frame": {
      "version": "7.12.11",
      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.12.11.tgz",
      "integrity": "sha512-Zt1yodBx1UcyiePMSkWnU4hPqhwq7hGi2nFL1LeA3EUl+q2LQx16MISgJ0+z7dnmgvP9QtIleuETGOiOH1RcIw==",
      "dev": true,
      "dependencies": {
        "@babel/highlight": "^7.10.4"
      }
    },
    "node_modules/@babel/helper-validator-identifier": {
      "version": "7.14.0",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.14.0.tgz",
      "integrity": "sha512-V3ts7zMSu5lfiwWDVWzRDGIN+lnCEUdaXgtVHJgLb1rGaA6jMrtB9EmE7L18foXJIE8Un/A/h6NJfGQp/e1J4A==",
      "dev": true
    },
    "node_modules/@babel/highlight": {
      "version": "7.14.0",
      "resolved": "https://registry.npmjs.org/@babel/highlight/-/highlight-7.14.0.tgz",
      "integrity": "sha512-YSCOwxvTYEIMSGaBQb5kDDsCopDdiUGsqpatp3fOlI4+2HQSkTmEVWnVuySdAC5EWCqSWWTv0ib63RjR7dTBdg==",
      "dev": true,
      "dependencies": {
        "@babel/helper-validator-identifier": "^7.14.0",
        "chalk": "^2.0.0",
        "js-tokens": "^4.0.0"
      }
    },
    "node_modules/@babel/highlight/node_modules/ansi-styles": {
      "version": "3.2.1",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-3.2.1.tgz",
      "integrity": "sha512-VT0ZI6kZRdTh8YyJw3SMbYm/u+NqfsAxEpWO0Pf9sq8/e94WxxOpPKx9FR1FlyCtOVDNOQ+8ntlqFxiRc+r5qA==",
      "dev": true,
      "dependencies": {
        "color-convert": "^1.9.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/@babel/highlight/node_modules/chalk": {
      "version": "2.4.2",
      "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
      "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
      "dev": true,
      "dependencies": {
        "ansi-styles": "^3.2.1",
        "escape-string-regexp": "^1.0.5",
        "supports-color": "^5.3.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/@babel/highlight/node_modules/color-convert": {
      "version": "1.9.3",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-1.9.3.tgz",
      "integrity": "sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg==",
      "dev": true,
      "dependencies": {
        "color-name": "1.1.3"
      }
    },
    "node_modules/@babel/highlight/node_modules/color-name": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.3.tgz",
      "integrity": "sha1-p9BVi9icQveV3UIyj3QIMcpTvCU=",
      "dev": true
    },
    "node_modules/@babel/highlight/node_modules/escape-string-regexp": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz",
      "integrity": "sha1-G2HAViGQqN/2rjuyzwIAyhMLhtQ=",
      "dev": true,
      "engines": {
        "node": ">=0.8.0"
      }
    },
    "node_modules/@babel/highlight/node_modules/has-flag": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz",
      "integrity": "sha1-tdRU3CGZriJWmfNGfloH87lVuv0=",
      "dev": true,
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/@babel/highlight/node_modules/supports-color": {
      "version": "5.5.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
      "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
      "dev": true,
      "dependencies": {
        "has-flag": "^3.0.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/@discoveryjs/json-ext": {
      "version": "0.5.3",
      "resolved": "https://registry.npmjs.org/@discoveryjs/json-ext/-/json-ext-0.5.3.tgz",
      "integrity": "sha512-Fxt+AfXgjMoin2maPIYzFZnQjAXjAL0PHscM5pRTtatFqB+vZxAM9tLp2Optnuw3QOQC40jTNeGYFOMvyf7v9g==",
      "dev": true,
      "engines": {
        "node": ">=10.0.0"
      }
    },
    "node_modules/@eslint/eslintrc": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-0.4.1.tgz",
      "integrity": "sha512-5v7TDE9plVhvxQeWLXDTvFvJBdH6pEsdnl2g/dAptmuFEPedQ4Erq5rsDsX+mvAM610IhNaO2W5V1dOOnDKxkQ==",
      "dev": true,
      "dependencies": {
        "ajv": "^6.12.4",
        "debug": "^4.1.1",
        "espree": "^7.3.0",
        "globals": "^12.1.0",
        "ignore": "^4.0.6",
        "import-fresh": "^3.2.1",
        "js-yaml": "^3.13.1",
        "minimatch": "^3.0.4",
        "strip-json-comments": "^3.1.1"
      },
      "engines": {
        "node": "^10.12.0 || >=12.0.0"
      }
    },
    "node_modules/@eslint/eslintrc/node_modules/globals": {
      "version": "12.4.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-12.4.0.tgz",
      "integrity": "sha512-BWICuzzDvDoH54NHKCseDanAhE3CeDorgDL5MT6LMXXj2WCnd9UC2szdk4AWLfjdgNBCXLUanXYcpBBKOSWGwg==",
      "dev": true,
      "dependencies": {
        "type-fest": "^0.8.1"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/@eslint/eslintrc/node_modules/type-fest": {
      "version": "0.8.1",
      "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-0.8.1.tgz",
      "integrity": "sha512-4dbzIzqvjtgiM5rw1k5rEHtBANKmdudhGyBEajN01fEyhaAIhsoKNy6y7+IN93IfpFtwY9iqi7kD+xwKhQsNJA==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/@nodelib/fs.scandir": {
      "version": "2.1.4",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.4.tgz",
      "integrity": "sha512-33g3pMJk3bg5nXbL/+CY6I2eJDzZAni49PfJnL5fghPTggPvBd/pFNSgJsdAgWptuFu7qq/ERvOYFlhvsLTCKA==",
      "dev": true,
      "dependencies": {
        "@nodelib/fs.stat": "2.0.4",
        "run-parallel": "^1.1.9"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.stat": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.4.tgz",
      "integrity": "sha512-IYlHJA0clt2+Vg7bccq+TzRdJvv19c2INqBSsoOLp1je7xjtr7J26+WXR72MCdvU9q1qTzIWDfhMf+DRvQJK4Q==",
      "dev": true,
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.walk": {
      "version": "1.2.6",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.6.tgz",
      "integrity": "sha512-8Broas6vTtW4GIXTAHDoE32hnN2M5ykgCpWGbuXHQ15vEMqr23pB76e/GZcYsZCHALv50ktd24qhEyKr6wBtow==",
      "dev": true,
      "dependencies": {
        "@nodelib/fs.scandir": "2.1.4",
        "fastq": "^1.6.0"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@types/eslint": {
      "version": "7.2.12",
      "resolved": "https://registry.npmjs.org/@types/eslint/-/eslint-7.2.12.tgz",
      "integrity": "sha512-HjikV/jX6e0Pg4DcB+rtOBKSrG6w5IaxWpmi3efL/eLxMz5lZTK+W1DKERrX5a+mNzL78axfsDNXu7JHFP4uLg==",
      "dev": true,
      "dependencies": {
        "@types/estree": "*",
        "@types/json-schema": "*"
      }
    },
    "node_modules/@types/eslint-scope": {
      "version": "3.7.0",
      "resolved": "https://registry.npmjs.org/@types/eslint-scope/-/eslint-scope-3.7.0.tgz",
      "integrity": "sha512-O/ql2+rrCUe2W2rs7wMR+GqPRcgB6UiqN5RhrR5xruFlY7l9YLMn0ZkDzjoHLeiFkR8MCQZVudUuuvQ2BLC9Qw==",
      "dev": true,
      "dependencies": {
        "@types/eslint": "*",
        "@types/estree": "*"
      }
    },
    "node_modules/@types/estree": {
      "version": "0.0.47",
      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-0.0.47.tgz",
      "integrity": "sha512-c5ciR06jK8u9BstrmJyO97m+klJrrhCf9u3rLu3DEAJBirxRqSCvDQoYKmxuYwQI5SZChAWu+tq9oVlGRuzPAg==",
      "dev": true
    },
    "node_modules/@types/json-schema": {
      "version": "7.0.7",
      "resolved": "https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.7.tgz",
      "integrity": "sha512-cxWFQVseBm6O9Gbw1IWb8r6OS4OhSt3hPZLkFApLjM8TEXROBuQGLAH2i2gZpcXdLBIrpXuTDhH7Vbm1iXmNGA==",
      "dev": true
    },
    "node_modules/@types/node": {
      "version": "15.6.1",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-15.6.1.tgz",
      "integrity": "sha512-7EIraBEyRHEe7CH+Fm1XvgqU6uwZN8Q7jppJGcqjROMT29qhAuuOxYB1uEY5UMYQKEmA5D+5tBnhdaPXSsLONA==",
      "dev": true
    },
    "node_modules/@typescript-eslint/eslint-plugin": {
      "version": "4.25.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/eslint-plugin/-/eslint-plugin-4.25.0.tgz",
      "integrity": "sha512-Qfs3dWkTMKkKwt78xp2O/KZQB8MPS1UQ5D3YW2s6LQWBE1074BE+Rym+b1pXZIX3M3fSvPUDaCvZLKV2ylVYYQ==",
      "dev": true,
      "dependencies": {
        "@typescript-eslint/experimental-utils": "4.25.0",
        "@typescript-eslint/scope-manager": "4.25.0",
        "debug": "^4.1.1",
        "functional-red-black-tree": "^1.0.1",
        "lodash": "^4.17.15",
        "regexpp": "^3.0.0",
        "semver": "^7.3.2",
        "tsutils": "^3.17.1"
      },
      "engines": {
        "node": "^10.12.0 || >=12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "@typescript-eslint/parser": "^4.0.0",
        "eslint": "^5.0.0 || ^6.0.0 || ^7.0.0"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/@typescript-eslint/experimental-utils": {
      "version": "4.25.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/experimental-utils/-/experimental-utils-4.25.0.tgz",
      "integrity": "sha512-f0doRE76vq7NEEU0tw+ajv6CrmPelw5wLoaghEHkA2dNLFb3T/zJQqGPQ0OYt5XlZaS13MtnN+GTPCuUVg338w==",
      "dev": true,
      "dependencies": {
        "@types/json-schema": "^7.0.3",
        "@typescript-eslint/scope-manager": "4.25.0",
        "@typescript-eslint/types": "4.25.0",
        "@typescript-eslint/typescript-estree": "4.25.0",
        "eslint-scope": "^5.0.0",
        "eslint-utils": "^2.0.0"
      },
      "engines": {
        "node": "^10.12.0 || >=12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "*"
      }
    },
    "node_modules/@typescript-eslint/parser": {
      "version": "4.25.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/parser/-/parser-4.25.0.tgz",
      "integrity": "sha512-OZFa1SKyEJpAhDx8FcbWyX+vLwh7OEtzoo2iQaeWwxucyfbi0mT4DijbOSsTgPKzGHr6GrF2V5p/CEpUH/VBxg==",
      "dev": true,
      "dependencies": {
        "@typescript-eslint/scope-manager": "4.25.0",
        "@typescript-eslint/types": "4.25.0",
        "@typescript-eslint/typescript-estree": "4.25.0",
        "debug": "^4.1.1"
      },
      "engines": {
        "node": "^10.12.0 || >=12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^5.0.0 || ^6.0.0 || ^7.0.0"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/@typescript-eslint/scope-manager": {
      "version": "4.25.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/scope-manager/-/scope-manager-4.25.0.tgz",
      "integrity": "sha512-2NElKxMb/0rya+NJG1U71BuNnp1TBd1JgzYsldsdA83h/20Tvnf/HrwhiSlNmuq6Vqa0EzidsvkTArwoq+tH6w==",
      "dev": true,
      "dependencies": {
        "@typescript-eslint/types": "4.25.0",
        "@typescript-eslint/visitor-keys": "4.25.0"
      },
      "engines": {
        "node": "^8.10.0 || ^10.13.0 || >=11.10.1"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@typescript-eslint/types": {
      "version": "4.25.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/types/-/types-4.25.0.tgz",
      "integrity": "sha512-+CNINNvl00OkW6wEsi32wU5MhHti2J25TJsJJqgQmJu3B3dYDBcmOxcE5w9cgoM13TrdE/5ND2HoEnBohasxRQ==",
      "dev": true,
      "engines": {
        "node": "^8.10.0 || ^10.13.0 || >=11.10.1"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree": {
      "version": "4.25.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-4.25.0.tgz",
      "integrity": "sha512-1B8U07TGNAFMxZbSpF6jqiDs1cVGO0izVkf18Q/SPcUAc9LhHxzvSowXDTvkHMWUVuPpagupaW63gB6ahTXVlg==",
      "dev": true,
      "dependencies": {
        "@typescript-eslint/types": "4.25.0",
        "@typescript-eslint/visitor-keys": "4.25.0",
        "debug": "^4.1.1",
        "globby": "^11.0.1",
        "is-glob": "^4.0.1",
        "semver": "^7.3.2",
        "tsutils": "^3.17.1"
      },
      "engines": {
        "node": "^10.12.0 || >=12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/@typescript-eslint/visitor-keys": {
      "version": "4.25.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-4.25.0.tgz",
      "integrity": "sha512-AmkqV9dDJVKP/TcZrbf6s6i1zYXt5Hl8qOLrRDTFfRNae4+LB8A4N3i+FLZPW85zIxRy39BgeWOfMS3HoH5ngg==",
      "dev": true,
      "dependencies": {
        "@typescript-eslint/types": "4.25.0",
        "eslint-visitor-keys": "^2.0.0"
      },
      "engines": {
        "node": "^8.10.0 || ^10.13.0 || >=11.10.1"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@webassemblyjs/ast": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/ast/-/ast-1.11.0.tgz",
      "integrity": "sha512-kX2W49LWsbthrmIRMbQZuQDhGtjyqXfEmmHyEi4XWnSZtPmxY0+3anPIzsnRb45VH/J55zlOfWvZuY47aJZTJg==",
      "dev": true,
      "dependencies": {
        "@webassemblyjs/helper-numbers": "1.11.0",
        "@webassemblyjs/helper-wasm-bytecode": "1.11.0"
      }
    },
    "node_modules/@webassemblyjs/floating-point-hex-parser": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/floating-point-hex-parser/-/floating-point-hex-parser-1.11.0.tgz",
      "integrity": "sha512-Q/aVYs/VnPDVYvsCBL/gSgwmfjeCb4LW8+TMrO3cSzJImgv8lxxEPM2JA5jMrivE7LSz3V+PFqtMbls3m1exDA==",
      "dev": true
    },
    "node_modules/@webassemblyjs/helper-api-error": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-api-error/-/helper-api-error-1.11.0.tgz",
      "integrity": "sha512-baT/va95eXiXb2QflSx95QGT5ClzWpGaa8L7JnJbgzoYeaA27FCvuBXU758l+KXWRndEmUXjP0Q5fibhavIn8w==",
      "dev": true
    },
    "node_modules/@webassemblyjs/helper-buffer": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-buffer/-/helper-buffer-1.11.0.tgz",
      "integrity": "sha512-u9HPBEl4DS+vA8qLQdEQ6N/eJQ7gT7aNvMIo8AAWvAl/xMrcOSiI2M0MAnMCy3jIFke7bEee/JwdX1nUpCtdyA==",
      "dev": true
    },
    "node_modules/@webassemblyjs/helper-numbers": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-numbers/-/helper-numbers-1.11.0.tgz",
      "integrity": "sha512-DhRQKelIj01s5IgdsOJMKLppI+4zpmcMQ3XboFPLwCpSNH6Hqo1ritgHgD0nqHeSYqofA6aBN/NmXuGjM1jEfQ==",
      "dev": true,
      "dependencies": {
        "@webassemblyjs/floating-point-hex-parser": "1.11.0",
        "@webassemblyjs/helper-api-error": "1.11.0",
        "@xtuc/long": "4.2.2"
      }
    },
    "node_modules/@webassemblyjs/helper-wasm-bytecode": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-wasm-bytecode/-/helper-wasm-bytecode-1.11.0.tgz",
      "integrity": "sha512-MbmhvxXExm542tWREgSFnOVo07fDpsBJg3sIl6fSp9xuu75eGz5lz31q7wTLffwL3Za7XNRCMZy210+tnsUSEA==",
      "dev": true
    },
    "node_modules/@webassemblyjs/helper-wasm-section": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-wasm-section/-/helper-wasm-section-1.11.0.tgz",
      "integrity": "sha512-3Eb88hcbfY/FCukrg6i3EH8H2UsD7x8Vy47iVJrP967A9JGqgBVL9aH71SETPx1JrGsOUVLo0c7vMCN22ytJew==",
      "dev": true,
      "dependencies": {
        "@webassemblyjs/ast": "1.11.0",
        "@webassemblyjs/helper-buffer": "1.11.0",
        "@webassemblyjs/helper-wasm-bytecode": "1.11.0",
        "@webassemblyjs/wasm-gen": "1.11.0"
      }
    },
    "node_modules/@webassemblyjs/ieee754": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/ieee754/-/ieee754-1.11.0.tgz",
      "integrity": "sha512-KXzOqpcYQwAfeQ6WbF6HXo+0udBNmw0iXDmEK5sFlmQdmND+tr773Ti8/5T/M6Tl/413ArSJErATd8In3B+WBA==",
      "dev": true,
      "dependencies": {
        "@xtuc/ieee754": "^1.2.0"
      }
    },
    "node_modules/@webassemblyjs/leb128": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/leb128/-/leb128-1.11.0.tgz",
      "integrity": "sha512-aqbsHa1mSQAbeeNcl38un6qVY++hh8OpCOzxhixSYgbRfNWcxJNJQwe2rezK9XEcssJbbWIkblaJRwGMS9zp+g==",
      "dev": true,
      "dependencies": {
        "@xtuc/long": "4.2.2"
      }
    },
    "node_modules/@webassemblyjs/utf8": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/utf8/-/utf8-1.11.0.tgz",
      "integrity": "sha512-A/lclGxH6SpSLSyFowMzO/+aDEPU4hvEiooCMXQPcQFPPJaYcPQNKGOCLUySJsYJ4trbpr+Fs08n4jelkVTGVw==",
      "dev": true
    },
    "node_modules/@webassemblyjs/wasm-edit": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-edit/-/wasm-edit-1.11.0.tgz",
      "integrity": "sha512-JHQ0damXy0G6J9ucyKVXO2j08JVJ2ntkdJlq1UTiUrIgfGMmA7Ik5VdC/L8hBK46kVJgujkBIoMtT8yVr+yVOQ==",
      "dev": true,
      "dependencies": {
        "@webassemblyjs/ast": "1.11.0",
        "@webassemblyjs/helper-buffer": "1.11.0",
        "@webassemblyjs/helper-wasm-bytecode": "1.11.0",
        "@webassemblyjs/helper-wasm-section": "1.11.0",
        "@webassemblyjs/wasm-gen": "1.11.0",
        "@webassemblyjs/wasm-opt": "1.11.0",
        "@webassemblyjs/wasm-parser": "1.11.0",
        "@webassemblyjs/wast-printer": "1.11.0"
      }
    },
    "node_modules/@webassemblyjs/wasm-gen": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-gen/-/wasm-gen-1.11.0.tgz",
      "integrity": "sha512-BEUv1aj0WptCZ9kIS30th5ILASUnAPEvE3tVMTrItnZRT9tXCLW2LEXT8ezLw59rqPP9klh9LPmpU+WmRQmCPQ==",
      "dev": true,
      "dependencies": {
        "@webassemblyjs/ast": "1.11.0",
        "@webassemblyjs/helper-wasm-bytecode": "1.11.0",
        "@webassemblyjs/ieee754": "1.11.0",
        "@webassemblyjs/leb128": "1.11.0",
        "@webassemblyjs/utf8": "1.11.0"
      }
    },
    "node_modules/@webassemblyjs/wasm-opt": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-opt/-/wasm-opt-1.11.0.tgz",
      "integrity": "sha512-tHUSP5F4ywyh3hZ0+fDQuWxKx3mJiPeFufg+9gwTpYp324mPCQgnuVKwzLTZVqj0duRDovnPaZqDwoyhIO8kYg==",
      "dev": true,
      "dependencies": {
        "@webassemblyjs/ast": "1.11.0",
        "@webassemblyjs/helper-buffer": "1.11.0",
        "@webassemblyjs/wasm-gen": "1.11.0",
        "@webassemblyjs/wasm-parser": "1.11.0"
      }
    },
    "node_modules/@webassemblyjs/wasm-parser": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-parser/-/wasm-parser-1.11.0.tgz",
      "integrity": "sha512-6L285Sgu9gphrcpDXINvm0M9BskznnzJTE7gYkjDbxET28shDqp27wpruyx3C2S/dvEwiigBwLA1cz7lNUi0kw==",
      "dev": true,
      "dependencies": {
        "@webassemblyjs/ast": "1.11.0",
        "@webassemblyjs/helper-api-error": "1.11.0",
        "@webassemblyjs/helper-wasm-bytecode": "1.11.0",
        "@webassemblyjs/ieee754": "1.11.0",
        "@webassemblyjs/leb128": "1.11.0",
        "@webassemblyjs/utf8": "1.11.0"
      }
    },
    "node_modules/@webassemblyjs/wast-printer": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/wast-printer/-/wast-printer-1.11.0.tgz",
      "integrity": "sha512-Fg5OX46pRdTgB7rKIUojkh9vXaVN6sGYCnEiJN1GYkb0RPwShZXp6KTDqmoMdQPKhcroOXh3fEzmkWmCYaKYhQ==",
      "dev": true,
      "dependencies": {
        "@webassemblyjs/ast": "1.11.0",
        "@xtuc/long": "4.2.2"
      }
    },
    "node_modules/@webpack-cli/configtest": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/@webpack-cli/configtest/-/configtest-1.0.3.tgz",
      "integrity": "sha512-WQs0ep98FXX2XBAfQpRbY0Ma6ADw8JR6xoIkaIiJIzClGOMqVRvPCWqndTxf28DgFopWan0EKtHtg/5W1h0Zkw==",
      "dev": true,
      "peerDependencies": {
        "webpack": "4.x.x || 5.x.x",
        "webpack-cli": "4.x.x"
      }
    },
    "node_modules/@webpack-cli/info": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@webpack-cli/info/-/info-1.2.4.tgz",
      "integrity": "sha512-ogE2T4+pLhTTPS/8MM3IjHn0IYplKM4HbVNMCWA9N4NrdPzunwenpCsqKEXyejMfRu6K8mhauIPYf8ZxWG5O6g==",
      "dev": true,
      "dependencies": {
        "envinfo": "^7.7.3"
      },
      "peerDependencies": {
        "webpack-cli": "4.x.x"
      }
    },
    "node_modules/@webpack-cli/serve": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/@webpack-cli/serve/-/serve-1.4.0.tgz",
      "integrity": "sha512-xgT/HqJ+uLWGX+Mzufusl3cgjAcnqYYskaB7o0vRcwOEfuu6hMzSILQpnIzFMGsTaeaX4Nnekl+6fadLbl1/Vg==",
      "dev": true,
      "peerDependencies": {
        "webpack-cli": "4.x.x"
      },
      "peerDependenciesMeta": {
        "webpack-dev-server": {
          "optional": true
        }
      }
    },
    "node_modules/@xtuc/ieee754": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/@xtuc/ieee754/-/ieee754-1.2.0.tgz",
      "integrity": "sha512-DX8nKgqcGwsc0eJSqYt5lwP4DH5FlHnmuWWBRy7X0NcaGR0ZtuyeESgMwTYVEtxmsNGY+qit4QYT/MIYTOTPeA==",
      "dev": true
    },
    "node_modules/@xtuc/long": {
      "version": "4.2.2",
      "resolved": "https://registry.npmjs.org/@xtuc/long/-/long-4.2.2.tgz",
      "integrity": "sha512-NuHqBY1PB/D8xU6s/thBgOAiAP7HOYDQ32+BFZILJ8ivkUkAHQnWfn6WhL79Owj1qmUnoN/YPhktdIoucipkAQ==",
      "dev": true
    },
    "node_modules/acorn": {
      "version": "7.4.1",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-7.4.1.tgz",
      "integrity": "sha512-nQyp0o1/mNdbTO1PO6kHkwSrmgZ0MT/jCCpNiwbUjGoRN4dlBhqJtoQuCnEOKzgTVwg0ZWiCoQy6SxMebQVh8A==",
      "dev": true,
      "bin": {
        "acorn": "bin/acorn"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/acorn-jsx": {
      "version": "5.3.1",
      "resolved": "https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.1.tgz",
      "integrity": "sha512-K0Ptm/47OKfQRpNQ2J/oIN/3QYiK6FwW+eJbILhsdxh2WTLdl+30o8aGdTbm5JbffpFFAg/g+zi1E+jvJha5ng==",
      "dev": true,
      "peerDependencies": {
        "acorn": "^6.0.0 || ^7.0.0 || ^8.0.0"
      }
    },
    "node_modules/ajv": {
      "version": "6.12.6",
      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
      "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
      "dev": true,
      "dependencies": {
        "fast-deep-equal": "^3.1.1",
        "fast-json-stable-stringify": "^2.0.0",
        "json-schema-traverse": "^0.4.1",
        "uri-js": "^4.2.2"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/epoberezkin"
      }
    },
    "node_modules/ajv-keywords": {
      "version": "3.5.2",
      "resolved": "https://registry.npmjs.org/ajv-keywords/-/ajv-keywords-3.5.2.tgz",
      "integrity": "sha512-5p6WTN0DdTGVQk6VjcEju19IgaHudalcfabD7yhDGeA6bcQnmL+CpveLJq/3hvfwd1aof6L386Ougkx6RfyMIQ==",
      "dev": true,
      "peerDependencies": {
        "ajv": "^6.9.1"
      }
    },
    "node_modules/ansi-colors": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/ansi-colors/-/ansi-colors-4.1.1.tgz",
      "integrity": "sha512-JoX0apGbHaUJBNl6yF+p6JAFYZ666/hhCGKN5t9QFjbJQKUU/g8MNbFDbvfrgKXvI1QpZplPOnwIo99lX/AAmA==",
      "dev": true,
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/ansi-regex": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.0.tgz",
      "integrity": "sha512-bY6fj56OUQ0hU1KjFNDQuJFezqKdrAyFdIevADiqrWHwSlbmBNMHp5ak2f40Pm8JTFyM2mqxkG6ngkHO11f/lg==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/ansi-styles": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
      "dev": true,
      "dependencies": {
        "color-convert": "^2.0.1"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/argparse": {
      "version": "1.0.10",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-1.0.10.tgz",
      "integrity": "sha512-o5Roy6tNG4SL/FOkCAN6RzjiakZS25RLYFrcMttJqbdd8BWrnA+fGz57iN5Pb06pvBGvl5gQ0B48dJlslXvoTg==",
      "dev": true,
      "dependencies": {
        "sprintf-js": "~1.0.2"
      }
    },
    "node_modules/array-union": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/array-union/-/array-union-2.1.0.tgz",
      "integrity": "sha512-HGyxoOTYUyCM6stUe6EJgnd4EoewAI7zMdfqO+kGjnlZmBDz/cR5pf8r/cR4Wq60sL/p0IkcjUEEPwS3GFrIyw==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/arrify": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/arrify/-/arrify-1.0.1.tgz",
      "integrity": "sha1-iYUI2iIm84DfkEcoRWhJwVAaSw0=",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/astral-regex": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/astral-regex/-/astral-regex-2.0.0.tgz",
      "integrity": "sha512-Z7tMw1ytTXt5jqMcOP+OQteU1VuNK9Y02uuJtKQ1Sv69jXQKKg5cibLwGJow8yzZP+eAc18EmLGPal0bp36rvQ==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "dev": true
    },
    "node_modules/binaryen": {
      "version": "101.0.0-nightly.20210723",
      "resolved": "https://registry.npmjs.org/binaryen/-/binaryen-101.0.0-nightly.20210723.tgz",
      "integrity": "sha512-eioJNqhHlkguVSbblHOtLqlhtC882SOEPKmNFZaDuz1hzQjolxZ+eu3/kaS10n3sGPONsIZsO7R9fR00UyhEUA==",
      "bin": {
        "wasm-opt": "bin/wasm-opt"
      }
    },
    "node_modules/brace-expansion": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz",
      "integrity": "sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==",
      "dev": true,
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/braces": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.2.tgz",
      "integrity": "sha512-b8um+L1RzM3WDSzvhm6gIz1yfTbBt6YTlcEKAvsmqCZZFw46z626lVj9j1yEPW33H5H+lBQpZMP1k8l+78Ha0A==",
      "dev": true,
      "dependencies": {
        "fill-range": "^7.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/browserslist": {
      "version": "4.16.6",
      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.16.6.tgz",
      "integrity": "sha512-Wspk/PqO+4W9qp5iUTJsa1B/QrYn1keNCcEP5OvP7WBwT4KaDly0uONYmC6Xa3Z5IqnUgS0KcgLYu1l74x0ZXQ==",
      "dev": true,
      "dependencies": {
        "caniuse-lite": "^1.0.30001219",
        "colorette": "^1.2.2",
        "electron-to-chromium": "^1.3.723",
        "escalade": "^3.1.1",
        "node-releases": "^1.1.71"
      },
      "bin": {
        "browserslist": "cli.js"
      },
      "engines": {
        "node": "^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/browserslist"
      }
    },
    "node_modules/buffer-from": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/buffer-from/-/buffer-from-1.1.1.tgz",
      "integrity": "sha512-MQcXEUbCKtEo7bhqEs6560Hyd4XaovZlO/k9V3hjVUF/zwW7KBVdSK4gIt/bzwS9MbR5qob+F5jusZsb0YQK2A=="
    },
    "node_modules/callsites": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz",
      "integrity": "sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==",
      "dev": true,
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/caniuse-lite": {
      "version": "1.0.30001230",
      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001230.tgz",
      "integrity": "sha512-5yBd5nWCBS+jWKTcHOzXwo5xzcj4ePE/yjtkZyUV1BTUmrBaA9MRGC+e7mxnqXSA90CmCA8L3eKLaSUkt099IQ==",
      "dev": true,
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/browserslist"
      }
    },
    "node_modules/chalk": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.1.tgz",
      "integrity": "sha512-diHzdDKxcU+bAsUboHLPEDQiw0qEe0qd7SYUn3HgcFlWgbDcfLGswOHYeGrHKzG9z6UYf01d9VFMfZxPM1xZSg==",
      "dev": true,
      "dependencies": {
        "ansi-styles": "^4.1.0",
        "supports-color": "^7.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/chalk?sponsor=1"
      }
    },
    "node_modules/chrome-trace-event": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/chrome-trace-event/-/chrome-trace-event-1.0.3.tgz",
      "integrity": "sha512-p3KULyQg4S7NIHixdwbGX+nFHkoBiA4YQmyWtjb8XngSKV124nJmRysgAeujbUVb15vh+RvFUfCPqU7rXk+hZg==",
      "dev": true,
      "engines": {
        "node": ">=6.0"
      }
    },
    "node_modules/clone-deep": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/clone-deep/-/clone-deep-4.0.1.tgz",
      "integrity": "sha512-neHB9xuzh/wk0dIHweyAXv2aPGZIVk3pLMe+/RNzINf17fe0OG96QroktYAUm7SM1PBnzTabaLboqqxDyMU+SQ==",
      "dev": true,
      "dependencies": {
        "is-plain-object": "^2.0.4",
        "kind-of": "^6.0.2",
        "shallow-clone": "^3.0.0"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/color-convert": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "dev": true,
      "dependencies": {
        "color-name": "~1.1.4"
      },
      "engines": {
        "node": ">=7.0.0"
      }
    },
    "node_modules/color-name": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
      "dev": true
    },
    "node_modules/colorette": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/colorette/-/colorette-1.2.2.tgz",
      "integrity": "sha512-MKGMzyfeuutC/ZJ1cba9NqcNpfeqMUcYmyF1ZFY6/Cn7CNSAKx6a+s48sqLqyAiZuaP2TcqMhoo+dlwFnVxT9w==",
      "dev": true
    },
    "node_modules/commander": {
      "version": "2.20.3",
      "resolved": "https://registry.npmjs.org/commander/-/commander-2.20.3.tgz",
      "integrity": "sha512-GpVkmM8vF2vQUkj2LvZmD35JxeJOLCwJ9cUkugyk2nuhbv3+mJvpLYYt+0+USMxE+oj+ey/lJEnhZw75x/OMcQ==",
      "dev": true
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha1-2Klr13/Wjfd5OnMDajug1UBdR3s=",
      "dev": true
    },
    "node_modules/cross-spawn": {
      "version": "7.0.3",
      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.3.tgz",
      "integrity": "sha512-iRDPJKUPVEND7dHPO8rkbOnPpyDygcDFtWjpeWNCgy8WP2rXcxXL8TskReQl6OrB2G7+UJrags1q15Fudc7G6w==",
      "dev": true,
      "dependencies": {
        "path-key": "^3.1.0",
        "shebang-command": "^2.0.0",
        "which": "^2.0.1"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/debug": {
      "version": "4.3.1",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.1.tgz",
      "integrity": "sha512-doEwdvm4PCeK4K3RQN2ZC2BYUBaxwLARCqZmMjtF8a51J2Rb0xpVloFRnCODwqjpwnAoao4pelN8l3RJdv3gRQ==",
      "dev": true,
      "dependencies": {
        "ms": "2.1.2"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/deep-is": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/deep-is/-/deep-is-0.1.3.tgz",
      "integrity": "sha1-s2nW+128E+7PUk+RsHD+7cNXzzQ=",
      "dev": true
    },
    "node_modules/diff": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/diff/-/diff-5.0.0.tgz",
      "integrity": "sha512-/VTCrvm5Z0JGty/BWHljh+BAiw3IK+2j87NGMu8Nwc/f48WoDAC395uomO9ZD117ZOBaHmkX1oyLvkVM/aIT3w==",
      "dev": true,
      "engines": {
        "node": ">=0.3.1"
      }
    },
    "node_modules/dir-glob": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/dir-glob/-/dir-glob-3.0.1.tgz",
      "integrity": "sha512-WkrWp9GR4KXfKGYzOLmTuGVi1UWFfws377n9cc55/tb6DuqyF6pcQ5AbiHEshaDpY9v6oaSr2XCDidGmMwdzIA==",
      "dev": true,
      "dependencies": {
        "path-type": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/doctrine": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/doctrine/-/doctrine-3.0.0.tgz",
      "integrity": "sha512-yS+Q5i3hBf7GBkd4KG8a7eBNNWNGLTaEwwYWUijIYM7zrlYDM0BFXHjjPWlWZ1Rg7UaddZeIDmi9jF3HmqiQ2w==",
      "dev": true,
      "dependencies": {
        "esutils": "^2.0.2"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/electron-to-chromium": {
      "version": "1.3.740",
      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.3.740.tgz",
      "integrity": "sha512-Mi2m55JrX2BFbNZGKYR+2ItcGnR4O5HhrvgoRRyZQlaMGQULqDhoGkLWHzJoshSzi7k1PUofxcDbNhlFrDZNhg==",
      "dev": true
    },
    "node_modules/emoji-regex": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
      "dev": true
    },
    "node_modules/enhanced-resolve": {
      "version": "5.8.2",
      "resolved": "https://registry.npmjs.org/enhanced-resolve/-/enhanced-resolve-5.8.2.tgz",
      "integrity": "sha512-F27oB3WuHDzvR2DOGNTaYy0D5o0cnrv8TeI482VM4kYgQd/FT9lUQwuNsJ0oOHtBUq7eiW5ytqzp7nBFknL+GA==",
      "dev": true,
      "dependencies": {
        "graceful-fs": "^4.2.4",
        "tapable": "^2.2.0"
      },
      "engines": {
        "node": ">=10.13.0"
      }
    },
    "node_modules/enquirer": {
      "version": "2.3.6",
      "resolved": "https://registry.npmjs.org/enquirer/-/enquirer-2.3.6.tgz",
      "integrity": "sha512-yjNnPr315/FjS4zIsUxYguYUPP2e1NK4d7E7ZOLiyYCcbFBiTMyID+2wvm2w6+pZ/odMA7cRkjhsPbltwBOrLg==",
      "dev": true,
      "dependencies": {
        "ansi-colors": "^4.1.1"
      },
      "engines": {
        "node": ">=8.6"
      }
    },
    "node_modules/envinfo": {
      "version": "7.8.1",
      "resolved": "https://registry.npmjs.org/envinfo/-/envinfo-7.8.1.tgz",
      "integrity": "sha512-/o+BXHmB7ocbHEAs6F2EnG0ogybVVUdkRunTT2glZU9XAaGmhqskrvKwqXuDfNjEO0LZKWdejEEpnq8aM0tOaw==",
      "dev": true,
      "bin": {
        "envinfo": "dist/cli.js"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/es-module-lexer": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/es-module-lexer/-/es-module-lexer-0.4.1.tgz",
      "integrity": "sha512-ooYciCUtfw6/d2w56UVeqHPcoCFAiJdz5XOkYpv/Txl1HMUozpXjz/2RIQgqwKdXNDPSF1W7mJCFse3G+HDyAA==",
      "dev": true
    },
    "node_modules/escalade": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.1.1.tgz",
      "integrity": "sha512-k0er2gUkLf8O0zKJiAhmkTnJlTvINGv7ygDNPbeIsX/TJjGJZHuh9B2UxbsaEkmlEo9MfhrSzmhIlhRlI2GXnw==",
      "dev": true,
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/escape-string-regexp": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
      "integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==",
      "dev": true,
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/eslint": {
      "version": "7.27.0",
      "resolved": "https://registry.npmjs.org/eslint/-/eslint-7.27.0.tgz",
      "integrity": "sha512-JZuR6La2ZF0UD384lcbnd0Cgg6QJjiCwhMD6eU4h/VGPcVGwawNNzKU41tgokGXnfjOOyI6QIffthhJTPzzuRA==",
      "dev": true,
      "dependencies": {
        "@babel/code-frame": "7.12.11",
        "@eslint/eslintrc": "^0.4.1",
        "ajv": "^6.10.0",
        "chalk": "^4.0.0",
        "cross-spawn": "^7.0.2",
        "debug": "^4.0.1",
        "doctrine": "^3.0.0",
        "enquirer": "^2.3.5",
        "escape-string-regexp": "^4.0.0",
        "eslint-scope": "^5.1.1",
        "eslint-utils": "^2.1.0",
        "eslint-visitor-keys": "^2.0.0",
        "espree": "^7.3.1",
        "esquery": "^1.4.0",
        "esutils": "^2.0.2",
        "fast-deep-equal": "^3.1.3",
        "file-entry-cache": "^6.0.1",
        "functional-red-black-tree": "^1.0.1",
        "glob-parent": "^5.0.0",
        "globals": "^13.6.0",
        "ignore": "^4.0.6",
        "import-fresh": "^3.0.0",
        "imurmurhash": "^0.1.4",
        "is-glob": "^4.0.0",
        "js-yaml": "^3.13.1",
        "json-stable-stringify-without-jsonify": "^1.0.1",
        "levn": "^0.4.1",
        "lodash.merge": "^4.6.2",
        "minimatch": "^3.0.4",
        "natural-compare": "^1.4.0",
        "optionator": "^0.9.1",
        "progress": "^2.0.0",
        "regexpp": "^3.1.0",
        "semver": "^7.2.1",
        "strip-ansi": "^6.0.0",
        "strip-json-comments": "^3.1.0",
        "table": "^6.0.9",
        "text-table": "^0.2.0",
        "v8-compile-cache": "^2.0.3"
      },
      "bin": {
        "eslint": "bin/eslint.js"
      },
      "engines": {
        "node": "^10.12.0 || >=12.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/eslint-scope": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-5.1.1.tgz",
      "integrity": "sha512-2NxwbF/hZ0KpepYN0cNbo+FN6XoK7GaHlQhgx/hIZl6Va0bF45RQOOwhLIy8lQDbuCiadSLCBnH2CFYquit5bw==",
      "dev": true,
      "dependencies": {
        "esrecurse": "^4.3.0",
        "estraverse": "^4.1.1"
      },
      "engines": {
        "node": ">=8.0.0"
      }
    },
    "node_modules/eslint-utils": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/eslint-utils/-/eslint-utils-2.1.0.tgz",
      "integrity": "sha512-w94dQYoauyvlDc43XnGB8lU3Zt713vNChgt4EWwhXAP2XkBvndfxF0AgIqKOOasjPIPzj9JqgwkwbCYD0/V3Zg==",
      "dev": true,
      "dependencies": {
        "eslint-visitor-keys": "^1.1.0"
      },
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/mysticatea"
      }
    },
    "node_modules/eslint-utils/node_modules/eslint-visitor-keys": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-1.3.0.tgz",
      "integrity": "sha512-6J72N8UNa462wa/KFODt/PJ3IU60SDpC3QXC1Hjc1BXXpfL2C9R5+AU7jhe0F6GREqVMh4Juu+NY7xn+6dipUQ==",
      "dev": true,
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/eslint-visitor-keys": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-2.1.0.tgz",
      "integrity": "sha512-0rSmRBzXgDzIsD6mGdJgevzgezI534Cer5L/vyMX0kHzT/jiB43jRhd9YUlMGYLQy2zprNmoT8qasCGtY+QaKw==",
      "dev": true,
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/espree": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/espree/-/espree-7.3.1.tgz",
      "integrity": "sha512-v3JCNCE64umkFpmkFGqzVKsOT0tN1Zr+ueqLZfpV1Ob8e+CEgPWa+OxCoGH3tnhimMKIaBm4m/vaRpJ/krRz2g==",
      "dev": true,
      "dependencies": {
        "acorn": "^7.4.0",
        "acorn-jsx": "^5.3.1",
        "eslint-visitor-keys": "^1.3.0"
      },
      "engines": {
        "node": "^10.12.0 || >=12.0.0"
      }
    },
    "node_modules/espree/node_modules/eslint-visitor-keys": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-1.3.0.tgz",
      "integrity": "sha512-6J72N8UNa462wa/KFODt/PJ3IU60SDpC3QXC1Hjc1BXXpfL2C9R5+AU7jhe0F6GREqVMh4Juu+NY7xn+6dipUQ==",
      "dev": true,
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/esprima": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/esprima/-/esprima-4.0.1.tgz",
      "integrity": "sha512-eGuFFw7Upda+g4p+QHvnW0RyTX/SVeJBDM/gCtMARO0cLuT2HcEKnTPvhjV6aGeqrCB/sbNop0Kszm0jsaWU4A==",
      "dev": true,
      "bin": {
        "esparse": "bin/esparse.js",
        "esvalidate": "bin/esvalidate.js"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/esquery": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/esquery/-/esquery-1.4.0.tgz",
      "integrity": "sha512-cCDispWt5vHHtwMY2YrAQ4ibFkAL8RbH5YGBnZBc90MolvvfkkQcJro/aZiAQUlQ3qgrYS6D6v8Gc5G5CQsc9w==",
      "dev": true,
      "dependencies": {
        "estraverse": "^5.1.0"
      },
      "engines": {
        "node": ">=0.10"
      }
    },
    "node_modules/esquery/node_modules/estraverse": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.2.0.tgz",
      "integrity": "sha512-BxbNGGNm0RyRYvUdHpIwv9IWzeM9XClbOxwoATuFdOE7ZE6wHL+HQ5T8hoPM+zHvmKzzsEqhgy0GrQ5X13afiQ==",
      "dev": true,
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/esrecurse": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz",
      "integrity": "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==",
      "dev": true,
      "dependencies": {
        "estraverse": "^5.2.0"
      },
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/esrecurse/node_modules/estraverse": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.2.0.tgz",
      "integrity": "sha512-BxbNGGNm0RyRYvUdHpIwv9IWzeM9XClbOxwoATuFdOE7ZE6wHL+HQ5T8hoPM+zHvmKzzsEqhgy0GrQ5X13afiQ==",
      "dev": true,
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/estraverse": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-4.3.0.tgz",
      "integrity": "sha512-39nnKffWz8xN1BU/2c79n9nB9HDzo0niYUqx6xyqUnyoAnQyyWpOTdZEeiCch8BBu515t4wp9ZmgVfVhn9EBpw==",
      "dev": true,
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/esutils": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
      "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==",
      "dev": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/events": {
      "version": "3.3.0",
      "resolved": "https://registry.npmjs.org/events/-/events-3.3.0.tgz",
      "integrity": "sha512-mQw+2fkQbALzQ7V0MY0IqdnXNOeTtP4r0lN9z7AAawCXgqea7bDii20AYrIBrFd/Hx0M2Ocz6S111CaFkUcb0Q==",
      "dev": true,
      "engines": {
        "node": ">=0.8.x"
      }
    },
    "node_modules/execa": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/execa/-/execa-5.0.0.tgz",
      "integrity": "sha512-ov6w/2LCiuyO4RLYGdpFGjkcs0wMTgGE8PrkTHikeUy5iJekXyPIKUjifk5CsE0pt7sMCrMZ3YNqoCj6idQOnQ==",
      "dev": true,
      "dependencies": {
        "cross-spawn": "^7.0.3",
        "get-stream": "^6.0.0",
        "human-signals": "^2.1.0",
        "is-stream": "^2.0.0",
        "merge-stream": "^2.0.0",
        "npm-run-path": "^4.0.1",
        "onetime": "^5.1.2",
        "signal-exit": "^3.0.3",
        "strip-final-newline": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sindresorhus/execa?sponsor=1"
      }
    },
    "node_modules/fast-deep-equal": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
      "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
      "dev": true
    },
    "node_modules/fast-glob": {
      "version": "3.2.5",
      "resolved": "https://registry.npmjs.org/fast-glob/-/fast-glob-3.2.5.tgz",
      "integrity": "sha512-2DtFcgT68wiTTiwZ2hNdJfcHNke9XOfnwmBRWXhmeKM8rF0TGwmC/Qto3S7RoZKp5cilZbxzO5iTNTQsJ+EeDg==",
      "dev": true,
      "dependencies": {
        "@nodelib/fs.stat": "^2.0.2",
        "@nodelib/fs.walk": "^1.2.3",
        "glob-parent": "^5.1.0",
        "merge2": "^1.3.0",
        "micromatch": "^4.0.2",
        "picomatch": "^2.2.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/fast-json-stable-stringify": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz",
      "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==",
      "dev": true
    },
    "node_modules/fast-levenshtein": {
      "version": "2.0.6",
      "resolved": "https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz",
      "integrity": "sha1-PYpcZog6FqMMqGQ+hR8Zuqd5eRc=",
      "dev": true
    },
    "node_modules/fastest-levenshtein": {
      "version": "1.0.12",
      "resolved": "https://registry.npmjs.org/fastest-levenshtein/-/fastest-levenshtein-1.0.12.tgz",
      "integrity": "sha512-On2N+BpYJ15xIC974QNVuYGMOlEVt4s0EOI3wwMqOmK1fdDY+FN/zltPV8vosq4ad4c/gJ1KHScUn/6AWIgiow==",
      "dev": true
    },
    "node_modules/fastq": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/fastq/-/fastq-1.11.0.tgz",
      "integrity": "sha512-7Eczs8gIPDrVzT+EksYBcupqMyxSHXXrHOLRRxU2/DicV8789MRBRR8+Hc2uWzUupOs4YS4JzBmBxjjCVBxD/g==",
      "dev": true,
      "dependencies": {
        "reusify": "^1.0.4"
      }
    },
    "node_modules/file-entry-cache": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-6.0.1.tgz",
      "integrity": "sha512-7Gps/XWymbLk2QLYK4NzpMOrYjMhdIxXuIvy2QBsLE6ljuodKvdkWs/cpyJJ3CVIVpH0Oi1Hvg1ovbMzLdFBBg==",
      "dev": true,
      "dependencies": {
        "flat-cache": "^3.0.4"
      },
      "engines": {
        "node": "^10.12.0 || >=12.0.0"
      }
    },
    "node_modules/fill-range": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.0.1.tgz",
      "integrity": "sha512-qOo9F+dMUmC2Lcb4BbVvnKJxTPjCm+RRpe4gDuGrzkL7mEVl/djYSu2OdQ2Pa302N4oqkSg9ir6jaLWJ2USVpQ==",
      "dev": true,
      "dependencies": {
        "to-regex-range": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/find-up": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/find-up/-/find-up-4.1.0.tgz",
      "integrity": "sha512-PpOwAdQ/YlXQ2vj8a3h8IipDuYRi3wceVQQGYWxNINccq40Anw7BlsEXCMbt1Zt+OLA6Fq9suIpIWD0OsnISlw==",
      "dev": true,
      "dependencies": {
        "locate-path": "^5.0.0",
        "path-exists": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/flat-cache": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/flat-cache/-/flat-cache-3.0.4.tgz",
      "integrity": "sha512-dm9s5Pw7Jc0GvMYbshN6zchCA9RgQlzzEZX3vylR9IqFfS8XciblUXOKfW6SiuJ0e13eDYZoZV5wdrev7P3Nwg==",
      "dev": true,
      "dependencies": {
        "flatted": "^3.1.0",
        "rimraf": "^3.0.2"
      },
      "engines": {
        "node": "^10.12.0 || >=12.0.0"
      }
    },
    "node_modules/flatted": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/flatted/-/flatted-3.1.1.tgz",
      "integrity": "sha512-zAoAQiudy+r5SvnSw3KJy5os/oRJYHzrzja/tBDqrZtNhUw8bt6y8OBzMWcjWr+8liV8Eb6yOhw8WZ7VFZ5ZzA==",
      "dev": true
    },
    "node_modules/fs.realpath": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
      "integrity": "sha1-FQStJSMVjKpA20onh8sBQRmU6k8=",
      "dev": true
    },
    "node_modules/function-bind": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.1.tgz",
      "integrity": "sha512-yIovAzMX49sF8Yl58fSCWJ5svSLuaibPxXQJFLmBObTuCr0Mf1KiPopGM9NiFjiYBCbfaa2Fh6breQ6ANVTI0A==",
      "dev": true
    },
    "node_modules/functional-red-black-tree": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/functional-red-black-tree/-/functional-red-black-tree-1.0.1.tgz",
      "integrity": "sha1-GwqzvVU7Kg1jmdKcDj6gslIHgyc=",
      "dev": true
    },
    "node_modules/get-stream": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/get-stream/-/get-stream-6.0.1.tgz",
      "integrity": "sha512-ts6Wi+2j3jQjqi70w5AlN8DFnkSwC+MqmxEzdEALB2qXZYV3X/b1CTfgPLGJNMeAWxdPfU8FO1ms3NUfaHCPYg==",
      "dev": true,
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/glob": {
      "version": "7.1.7",
      "resolved": "https://registry.npmjs.org/glob/-/glob-7.1.7.tgz",
      "integrity": "sha512-OvD9ENzPLbegENnYP5UUfJIirTg4+XwMWGaQfQTY0JenxNvvIKP3U3/tAQSPIu/lHxXYSZmpXlUHeqAIdKzBLQ==",
      "dev": true,
      "dependencies": {
        "fs.realpath": "^1.0.0",
        "inflight": "^1.0.4",
        "inherits": "2",
        "minimatch": "^3.0.4",
        "once": "^1.3.0",
        "path-is-absolute": "^1.0.0"
      },
      "engines": {
        "node": "*"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/glob-to-regexp": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/glob-to-regexp/-/glob-to-regexp-0.4.1.tgz",
      "integrity": "sha512-lkX1HJXwyMcprw/5YUZc2s7DrpAiHB21/V+E1rHUrVNokkvB6bqMzT0VfV6/86ZNabt1k14YOIaT7nDvOX3Iiw==",
      "dev": true
    },
    "node_modules/globals": {
      "version": "13.9.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-13.9.0.tgz",
      "integrity": "sha512-74/FduwI/JaIrr1H8e71UbDE+5x7pIPs1C2rrwC52SszOo043CsWOZEMW7o2Y58xwm9b+0RBKDxY5n2sUpEFxA==",
      "dev": true,
      "dependencies": {
        "type-fest": "^0.20.2"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/globby": {
      "version": "11.0.3",
      "resolved": "https://registry.npmjs.org/globby/-/globby-11.0.3.tgz",
      "integrity": "sha512-ffdmosjA807y7+lA1NM0jELARVmYul/715xiILEjo3hBLPTcirgQNnXECn5g3mtR8TOLCVbkfua1Hpen25/Xcg==",
      "dev": true,
      "dependencies": {
        "array-union": "^2.1.0",
        "dir-glob": "^3.0.1",
        "fast-glob": "^3.1.1",
        "ignore": "^5.1.4",
        "merge2": "^1.3.0",
        "slash": "^3.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/globby/node_modules/ignore": {
      "version": "5.1.8",
      "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.1.8.tgz",
      "integrity": "sha512-BMpfD7PpiETpBl/A6S498BaIJ6Y/ABT93ETbby2fP00v4EbvPBXWEoaR1UBPKs3iR53pJY7EtZk5KACI57i1Uw==",
      "dev": true,
      "engines": {
        "node": ">= 4"
      }
    },
    "node_modules/graceful-fs": {
      "version": "4.2.6",
      "resolved": "https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.2.6.tgz",
      "integrity": "sha512-nTnJ528pbqxYanhpDYsi4Rd8MAeaBA67+RZ10CM1m3bTAVFEDcd5AuA4a6W5YkGZ1iNXHzZz8T6TBKLeBuNriQ==",
      "dev": true
    },
    "node_modules/has": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/has/-/has-1.0.3.tgz",
      "integrity": "sha512-f2dvO0VU6Oej7RkWJGrehjbzMAjFp5/VKPp5tTpWIV4JHHZK1/BxbFRtf/siA2SWTe09caDmVtYYzWEIbBS4zw==",
      "dev": true,
      "dependencies": {
        "function-bind": "^1.1.1"
      },
      "engines": {
        "node": ">= 0.4.0"
      }
    },
    "node_modules/has-flag": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
      "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/human-signals": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/human-signals/-/human-signals-2.1.0.tgz",
      "integrity": "sha512-B4FFZ6q/T2jhhksgkbEW3HBvWIfDW85snkQgawt07S7J5QXTk6BkNV+0yAeZrM5QpMAdYlocGoljn0sJ/WQkFw==",
      "dev": true,
      "engines": {
        "node": ">=10.17.0"
      }
    },
    "node_modules/ignore": {
      "version": "4.0.6",
      "resolved": "https://registry.npmjs.org/ignore/-/ignore-4.0.6.tgz",
      "integrity": "sha512-cyFDKrqc/YdcWFniJhzI42+AzS+gNwmUzOSFcRCQYwySuBBBy/KjuxWLZ/FHEH6Moq1NizMOBWyTcv8O4OZIMg==",
      "dev": true,
      "engines": {
        "node": ">= 4"
      }
    },
    "node_modules/import-fresh": {
      "version": "3.3.0",
      "resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.0.tgz",
      "integrity": "sha512-veYYhQa+D1QBKznvhUHxb8faxlrwUnxseDAbAp457E0wLNio2bOSKnjYDhMj+YiAq61xrMGhQk9iXVk5FzgQMw==",
      "dev": true,
      "dependencies": {
        "parent-module": "^1.0.0",
        "resolve-from": "^4.0.0"
      },
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/import-local": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/import-local/-/import-local-3.0.2.tgz",
      "integrity": "sha512-vjL3+w0oulAVZ0hBHnxa/Nm5TAurf9YLQJDhqRZyqb+VKGOB6LU8t9H1Nr5CIo16vh9XfJTOoHwU0B71S557gA==",
      "dev": true,
      "dependencies": {
        "pkg-dir": "^4.2.0",
        "resolve-cwd": "^3.0.0"
      },
      "bin": {
        "import-local-fixture": "fixtures/cli.js"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/imurmurhash": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz",
      "integrity": "sha1-khi5srkoojixPcT7a21XbyMUU+o=",
      "dev": true,
      "engines": {
        "node": ">=0.8.19"
      }
    },
    "node_modules/inflight": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz",
      "integrity": "sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=",
      "dev": true,
      "dependencies": {
        "once": "^1.3.0",
        "wrappy": "1"
      }
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
      "dev": true
    },
    "node_modules/interpret": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/interpret/-/interpret-2.2.0.tgz",
      "integrity": "sha512-Ju0Bz/cEia55xDwUWEa8+olFpCiQoypjnQySseKtmjNrnps3P+xfpUmGr90T7yjlVJmOtybRvPXhKMbHr+fWnw==",
      "dev": true,
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/is-core-module": {
      "version": "2.4.0",
      "resolved": "https://registry.npmjs.org/is-core-module/-/is-core-module-2.4.0.tgz",
      "integrity": "sha512-6A2fkfq1rfeQZjxrZJGerpLCTHRNEBiSgnu0+obeJpEPZRUooHgsizvzv0ZjJwOz3iWIHdJtVWJ/tmPr3D21/A==",
      "dev": true,
      "dependencies": {
        "has": "^1.0.3"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha1-qIwCU1eR8C7TfHahueqXc8gz+MI=",
      "dev": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-fullwidth-code-point": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-glob": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.1.tgz",
      "integrity": "sha512-5G0tKtBTFImOqDnLB2hG6Bp2qcKEFduo4tZu9MT/H6NQv/ghhy30o55ufafxJ/LdH79LLs2Kfrn85TLKyA7BUg==",
      "dev": true,
      "dependencies": {
        "is-extglob": "^2.1.1"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-number": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
      "dev": true,
      "engines": {
        "node": ">=0.12.0"
      }
    },
    "node_modules/is-plain-object": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/is-plain-object/-/is-plain-object-2.0.4.tgz",
      "integrity": "sha512-h5PpgXkWitc38BBMYawTYMWJHFZJVnBquFE57xFpjB8pJFiF6gZ+bU+WyI/yqXiFR5mdLsgYNaPe8uao6Uv9Og==",
      "dev": true,
      "dependencies": {
        "isobject": "^3.0.1"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-stream": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-stream/-/is-stream-2.0.0.tgz",
      "integrity": "sha512-XCoy+WlUr7d1+Z8GgSuXmpuUFC9fOhRXglJMx+dwLKTkL44Cjd4W1Z5P+BQZpr+cR93aGP4S/s7Ftw6Nd/kiEw==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/isexe": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
      "integrity": "sha1-6PvzdNxVb/iUehDcsFctYz8s+hA=",
      "dev": true
    },
    "node_modules/isobject": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/isobject/-/isobject-3.0.1.tgz",
      "integrity": "sha1-TkMekrEalzFjaqH5yNHMvP2reN8=",
      "dev": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/jest-worker": {
      "version": "26.6.2",
      "resolved": "https://registry.npmjs.org/jest-worker/-/jest-worker-26.6.2.tgz",
      "integrity": "sha512-KWYVV1c4i+jbMpaBC+U++4Va0cp8OisU185o73T1vo99hqi7w8tSJfUXYswwqqrjzwxa6KpRK54WhPvwf5w6PQ==",
      "dev": true,
      "dependencies": {
        "@types/node": "*",
        "merge-stream": "^2.0.0",
        "supports-color": "^7.0.0"
      },
      "engines": {
        "node": ">= 10.13.0"
      }
    },
    "node_modules/js-tokens": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
      "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
      "dev": true
    },
    "node_modules/js-yaml": {
      "version": "3.14.1",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-3.14.1.tgz",
      "integrity": "sha512-okMH7OXXJ7YrN9Ok3/SXrnu4iX9yOk+25nqX4imS2npuvTYDmo/QEZoqwZkYaIDk3jVvBOTOIEgEhaLOynBS9g==",
      "dev": true,
      "dependencies": {
        "argparse": "^1.0.7",
        "esprima": "^4.0.0"
      },
      "bin": {
        "js-yaml": "bin/js-yaml.js"
      }
    },
    "node_modules/json-parse-better-errors": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/json-parse-better-errors/-/json-parse-better-errors-1.0.2.tgz",
      "integrity": "sha512-mrqyZKfX5EhL7hvqcV6WG1yYjnjeuYDzDhhcAAUrq8Po85NBQBJP+ZDUT75qZQ98IkUoBqdkExkukOU7Ts2wrw==",
      "dev": true
    },
    "node_modules/json-schema-traverse": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==",
      "dev": true
    },
    "node_modules/json-stable-stringify-without-jsonify": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz",
      "integrity": "sha1-nbe1lJatPzz+8wp1FC0tkwrXJlE=",
      "dev": true
    },
    "node_modules/kind-of": {
      "version": "6.0.3",
      "resolved": "https://registry.npmjs.org/kind-of/-/kind-of-6.0.3.tgz",
      "integrity": "sha512-dcS1ul+9tmeD95T+x28/ehLgd9mENa3LsvDTtzm3vyBEO7RPptvAD+t44WVXaUjTBRcrpFeFlC8WCruUR456hw==",
      "dev": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/levn": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/levn/-/levn-0.4.1.tgz",
      "integrity": "sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==",
      "dev": true,
      "dependencies": {
        "prelude-ls": "^1.2.1",
        "type-check": "~0.4.0"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/loader-runner": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/loader-runner/-/loader-runner-4.2.0.tgz",
      "integrity": "sha512-92+huvxMvYlMzMt0iIOukcwYBFpkYJdpl2xsZ7LrlayO7E8SOv+JJUEK17B/dJIHAOLMfh2dZZ/Y18WgmGtYNw==",
      "dev": true,
      "engines": {
        "node": ">=6.11.5"
      }
    },
    "node_modules/locate-path": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-5.0.0.tgz",
      "integrity": "sha512-t7hw9pI+WvuwNJXwk5zVHpyhIqzg2qTlklJOf0mVxGSbe3Fp2VieZcduNYjaLDoy6p9uGpQEGWG87WpMKlNq8g==",
      "dev": true,
      "dependencies": {
        "p-locate": "^4.1.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==",
      "dev": true
    },
    "node_modules/lodash.clonedeep": {
      "version": "4.5.0",
      "resolved": "https://registry.npmjs.org/lodash.clonedeep/-/lodash.clonedeep-4.5.0.tgz",
      "integrity": "sha1-4j8/nE+Pvd6HJSnBBxhXoIblzO8=",
      "dev": true
    },
    "node_modules/lodash.merge": {
      "version": "4.6.2",
      "resolved": "https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz",
      "integrity": "sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==",
      "dev": true
    },
    "node_modules/lodash.truncate": {
      "version": "4.4.2",
      "resolved": "https://registry.npmjs.org/lodash.truncate/-/lodash.truncate-4.4.2.tgz",
      "integrity": "sha1-WjUNoLERO4N+z//VgSy+WNbq4ZM=",
      "dev": true
    },
    "node_modules/long": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/long/-/long-4.0.0.tgz",
      "integrity": "sha512-XsP+KhQif4bjX1kbuSiySJFNAehNxgLb6hPRGJ9QsUr8ajHkuXGdrHmFUTUUXhDwVX2R5bY4JNZEwbUiMhV+MA=="
    },
    "node_modules/lru-cache": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz",
      "integrity": "sha512-Jo6dJ04CmSjuznwJSS3pUeWmd/H0ffTlkXXgwZi+eq1UCmqQwCh+eLsYOYCwY991i2Fah4h1BEMCx4qThGbsiA==",
      "dev": true,
      "dependencies": {
        "yallist": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/make-error": {
      "version": "1.3.6",
      "resolved": "https://registry.npmjs.org/make-error/-/make-error-1.3.6.tgz",
      "integrity": "sha512-s8UhlNe7vPKomQhC1qFelMokr/Sc3AgNbso3n74mVPA5LTZwkB9NlXf4XPamLxJE8h0gh73rM94xvwRT2CVInw=="
    },
    "node_modules/merge-stream": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/merge-stream/-/merge-stream-2.0.0.tgz",
      "integrity": "sha512-abv/qOcuPfk3URPfDzmZU1LKmuw8kT+0nIHvKrKgFrwifol/doWcdA4ZqsWQ8ENrFKkd67Mfpo/LovbIUsbt3w==",
      "dev": true
    },
    "node_modules/merge2": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
      "integrity": "sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==",
      "dev": true,
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/micromatch": {
      "version": "4.0.4",
      "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.4.tgz",
      "integrity": "sha512-pRmzw/XUcwXGpD9aI9q/0XOwLNygjETJ8y0ao0wdqprrzDa4YnxLcz7fQRZr8voh8V10kGhABbNcHVk5wHgWwg==",
      "dev": true,
      "dependencies": {
        "braces": "^3.0.1",
        "picomatch": "^2.2.3"
      },
      "engines": {
        "node": ">=8.6"
      }
    },
    "node_modules/mime-db": {
      "version": "1.47.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.47.0.tgz",
      "integrity": "sha512-QBmA/G2y+IfeS4oktet3qRZ+P5kPhCKRXxXnQEudYqUaEioAU1/Lq2us3D/t1Jfo4hE9REQPrbB7K5sOczJVIw==",
      "dev": true,
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "2.1.30",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.30.tgz",
      "integrity": "sha512-crmjA4bLtR8m9qLpHvgxSChT+XoSlZi8J4n/aIdn3z92e/U47Z0V/yl+Wh9W046GgFVAmoNR/fmdbZYcSSIUeg==",
      "dev": true,
      "dependencies": {
        "mime-db": "1.47.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mimic-fn": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/mimic-fn/-/mimic-fn-2.1.0.tgz",
      "integrity": "sha512-OqbOk5oEQeAZ8WXWydlu9HJjz9WVdEIvamMCcXmuqUYjTknH/sqsWvhQ3vgwKFRR1HpjvNBKQ37nbJgYzGqGcg==",
      "dev": true,
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/minimatch": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.0.4.tgz",
      "integrity": "sha512-yJHVQEhyqPLUTgt9B83PXu6W3rx4MvvHvSUvToogpwoGDOUQ+yDrR0HRot+yOCdCO7u4hX3pWft6kWBBcqh0UA==",
      "dev": true,
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/minimist": {
      "version": "1.2.5",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-1.2.5.tgz",
      "integrity": "sha512-FM9nNUYrRBAELZQT3xeZQ7fmMOBg6nWNmJKTcgsJeaLstP/UODVpGsr5OhXhhXg6f+qtJ8uiZ+PUxkDWcgIXLw=="
    },
    "node_modules/mkdirp": {
      "version": "0.5.5",
      "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.5.tgz",
      "integrity": "sha512-NKmAlESf6jMGym1++R0Ra7wvhV+wFW63FaSOFPwRahvea0gMUcGUhVeAg/0BC0wiv9ih5NYPB1Wn1UEI1/L+xQ==",
      "dependencies": {
        "minimist": "^1.2.5"
      },
      "bin": {
        "mkdirp": "bin/cmd.js"
      }
    },
    "node_modules/ms": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.2.tgz",
      "integrity": "sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w==",
      "dev": true
    },
    "node_modules/natural-compare": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz",
      "integrity": "sha1-Sr6/7tdUHywnrPspvbvRXI1bpPc=",
      "dev": true
    },
    "node_modules/neo-async": {
      "version": "2.6.2",
      "resolved": "https://registry.npmjs.org/neo-async/-/neo-async-2.6.2.tgz",
      "integrity": "sha512-Yd3UES5mWCSqR+qNT93S3UoYUkqAZ9lLg8a7g9rimsWmYGK8cVToA4/sF3RrshdyV3sAGMXVUmpMYOw+dLpOuw==",
      "dev": true
    },
    "node_modules/node-releases": {
      "version": "1.1.72",
      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-1.1.72.tgz",
      "integrity": "sha512-LLUo+PpH3dU6XizX3iVoubUNheF/owjXCZZ5yACDxNnPtgFuludV1ZL3ayK1kVep42Rmm0+R9/Y60NQbZ2bifw==",
      "dev": true
    },
    "node_modules/npm-run-path": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/npm-run-path/-/npm-run-path-4.0.1.tgz",
      "integrity": "sha512-S48WzZW777zhNIrn7gxOlISNAqi9ZC/uQFnRdbeIHhZhCA6UqpkOT8T1G7BvfdgP4Er8gF4sUbaS0i7QvIfCWw==",
      "dev": true,
      "dependencies": {
        "path-key": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
      "integrity": "sha1-WDsap3WWHUsROsF9nFC6753Xa9E=",
      "dev": true,
      "dependencies": {
        "wrappy": "1"
      }
    },
    "node_modules/onetime": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/onetime/-/onetime-5.1.2.tgz",
      "integrity": "sha512-kbpaSSGJTWdAY5KPVeMOKXSrPtr8C8C7wodJbcsd51jRnmD+GZu8Y0VoU6Dm5Z4vWr0Ig/1NKuWRKf7j5aaYSg==",
      "dev": true,
      "dependencies": {
        "mimic-fn": "^2.1.0"
      },
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/optionator": {
      "version": "0.9.1",
      "resolved": "https://registry.npmjs.org/optionator/-/optionator-0.9.1.tgz",
      "integrity": "sha512-74RlY5FCnhq4jRxVUPKDaRwrVNXMqsGsiW6AJw4XK8hmtm10wC0ypZBLw5IIp85NZMr91+qd1RvvENwg7jjRFw==",
      "dev": true,
      "dependencies": {
        "deep-is": "^0.1.3",
        "fast-levenshtein": "^2.0.6",
        "levn": "^0.4.1",
        "prelude-ls": "^1.2.1",
        "type-check": "^0.4.0",
        "word-wrap": "^1.2.3"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/p-limit": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-3.1.0.tgz",
      "integrity": "sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==",
      "dev": true,
      "dependencies": {
        "yocto-queue": "^0.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/p-locate": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-4.1.0.tgz",
      "integrity": "sha512-R79ZZ/0wAxKGu3oYMlz8jy/kbhsNrS7SKZ7PxEHBgJ5+F2mtFW2fK2cOtBh1cHYkQsbzFV7I+EoRKe6Yt0oK7A==",
      "dev": true,
      "dependencies": {
        "p-limit": "^2.2.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/p-locate/node_modules/p-limit": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-2.3.0.tgz",
      "integrity": "sha512-//88mFWSJx8lxCzwdAABTJL2MyWB12+eIY7MDL2SqLmAkeKU9qxRvWuSyTjm3FUmpBEMuFfckAIqEaVGUDxb6w==",
      "dev": true,
      "dependencies": {
        "p-try": "^2.0.0"
      },
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/p-try": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/p-try/-/p-try-2.2.0.tgz",
      "integrity": "sha512-R4nPAVTAU0B9D35/Gk3uJf/7XYbQcyohSKdvAxIRSNghFl4e71hVoGnBNQz9cWaXxO2I10KTC+3jMdvvoKw6dQ==",
      "dev": true,
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/parent-module": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
      "integrity": "sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==",
      "dev": true,
      "dependencies": {
        "callsites": "^3.0.0"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/path-exists": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz",
      "integrity": "sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-is-absolute": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz",
      "integrity": "sha1-F0uSaHNVNP+8es5r9TpanhtcX18=",
      "dev": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/path-key": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
      "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-parse": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz",
      "integrity": "sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==",
      "dev": true
    },
    "node_modules/path-type": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/path-type/-/path-type-4.0.0.tgz",
      "integrity": "sha512-gDKb8aZMDeD/tZWs9P6+q0J9Mwkdl6xMV8TjnGP3qJVJ06bdMgkbBlLU8IdfOsIsFz2BW1rNVT3XuNEl8zPAvw==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/physical-cpu-count": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/physical-cpu-count/-/physical-cpu-count-2.0.0.tgz",
      "integrity": "sha1-GN4vl+S/epVRrXURlCtUlverpmA=",
      "dev": true
    },
    "node_modules/picomatch": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.0.tgz",
      "integrity": "sha512-lY1Q/PiJGC2zOv/z391WOTD+Z02bCgsFfvxoXXf6h7kv9o+WmsmzYqrAwY63sNgOxE4xEdq0WyUnXfKeBrSvYw==",
      "dev": true,
      "engines": {
        "node": ">=8.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/pkg-dir": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/pkg-dir/-/pkg-dir-4.2.0.tgz",
      "integrity": "sha512-HRDzbaKjC+AOWVXxAU/x54COGeIv9eb+6CkDSQoNTt4XyWoIJvuPsXizxu/Fr23EiekbtZwmh1IcIG/l/a10GQ==",
      "dev": true,
      "dependencies": {
        "find-up": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/prelude-ls": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz",
      "integrity": "sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==",
      "dev": true,
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/progress": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/progress/-/progress-2.0.3.tgz",
      "integrity": "sha512-7PiHtLll5LdnKIMw100I+8xJXR5gW2QwWYkT6iJva0bXitZKa/XMrSbdmg3r2Xnaidz9Qumd0VPaMrZlF9V9sA==",
      "dev": true,
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/punycode": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.1.1.tgz",
      "integrity": "sha512-XRsRjdf+j5ml+y/6GKHPZbrF/8p2Yga0JPtdqTIY2Xe5ohJPD9saDJJLPvp9+NSBprVvevdXZybnj2cv8OEd0A==",
      "dev": true,
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/queue-microtask": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/queue-microtask/-/queue-microtask-1.2.3.tgz",
      "integrity": "sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ]
    },
    "node_modules/randombytes": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/randombytes/-/randombytes-2.1.0.tgz",
      "integrity": "sha512-vYl3iOX+4CKUWuxGi9Ukhie6fsqXqS9FE2Zaic4tNFD2N2QQaXOMFbuKK4QmDHC0JO6B1Zp41J0LpT0oR68amQ==",
      "dev": true,
      "dependencies": {
        "safe-buffer": "^5.1.0"
      }
    },
    "node_modules/rechoir": {
      "version": "0.7.0",
      "resolved": "https://registry.npmjs.org/rechoir/-/rechoir-0.7.0.tgz",
      "integrity": "sha512-ADsDEH2bvbjltXEP+hTIAmeFekTFK0V2BTxMkok6qILyAJEXV0AFfoWcAq4yfll5VdIMd/RVXq0lR+wQi5ZU3Q==",
      "dev": true,
      "dependencies": {
        "resolve": "^1.9.0"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/regexpp": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/regexpp/-/regexpp-3.1.0.tgz",
      "integrity": "sha512-ZOIzd8yVsQQA7j8GCSlPGXwg5PfmA1mrq0JP4nGhh54LaKN3xdai/vHUDu74pKwV8OxseMS65u2NImosQcSD0Q==",
      "dev": true,
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/mysticatea"
      }
    },
    "node_modules/require-from-string": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/require-from-string/-/require-from-string-2.0.2.tgz",
      "integrity": "sha512-Xf0nWe6RseziFMu+Ap9biiUbmplq6S9/p+7w7YXP/JBHhrUDDUhwa+vANyubuqfZWTveU//DYVGsDG7RKL/vEw==",
      "dev": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/resolve": {
      "version": "1.20.0",
      "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.20.0.tgz",
      "integrity": "sha512-wENBPt4ySzg4ybFQW2TT1zMQucPK95HSh/nq2CFTZVOGut2+pQvSsgtda4d26YrYcr067wjbmzOG8byDPBX63A==",
      "dev": true,
      "dependencies": {
        "is-core-module": "^2.2.0",
        "path-parse": "^1.0.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/resolve-cwd": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/resolve-cwd/-/resolve-cwd-3.0.0.tgz",
      "integrity": "sha512-OrZaX2Mb+rJCpH/6CpSqt9xFVpN++x01XnN2ie9g6P5/3xelLAkXWVADpdz1IHD/KFfEXyE6V0U01OQ3UO2rEg==",
      "dev": true,
      "dependencies": {
        "resolve-from": "^5.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/resolve-cwd/node_modules/resolve-from": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-5.0.0.tgz",
      "integrity": "sha512-qYg9KP24dD5qka9J47d0aVky0N+b4fTU89LN9iDnjB5waksiC49rvMB0PrUJQGoTmH50XPiqOvAjDfaijGxYZw==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/resolve-from": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz",
      "integrity": "sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==",
      "dev": true,
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/reusify": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/reusify/-/reusify-1.0.4.tgz",
      "integrity": "sha512-U9nH88a3fc/ekCF1l0/UP1IosiuIjyTh7hBvXVMHYgVcfGvt897Xguj2UOLDeI5BG2m7/uwyaLVT6fbtCwTyzw==",
      "dev": true,
      "engines": {
        "iojs": ">=1.0.0",
        "node": ">=0.10.0"
      }
    },
    "node_modules/rimraf": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-3.0.2.tgz",
      "integrity": "sha512-JZkJMZkAGFFPP2YqXZXPbMlMBgsxzE8ILs4lMIX/2o0L9UBw9O/Y3o6wFw/i9YLapcUJWwqbi3kdxIPdC62TIA==",
      "dev": true,
      "dependencies": {
        "glob": "^7.1.3"
      },
      "bin": {
        "rimraf": "bin.js"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/run-parallel": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/run-parallel/-/run-parallel-1.2.0.tgz",
      "integrity": "sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "dependencies": {
        "queue-microtask": "^1.2.2"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ]
    },
    "node_modules/schema-utils": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/schema-utils/-/schema-utils-3.0.0.tgz",
      "integrity": "sha512-6D82/xSzO094ajanoOSbe4YvXWMfn2A//8Y1+MUqFAJul5Bs+yn36xbK9OtNDcRVSBJ9jjeoXftM6CfztsjOAA==",
      "dev": true,
      "dependencies": {
        "@types/json-schema": "^7.0.6",
        "ajv": "^6.12.5",
        "ajv-keywords": "^3.5.2"
      },
      "engines": {
        "node": ">= 10.13.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/webpack"
      }
    },
    "node_modules/semver": {
      "version": "7.3.5",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.3.5.tgz",
      "integrity": "sha512-PoeGJYh8HK4BTO/a9Tf6ZG3veo/A7ZVsYrSA6J8ny9nb3B1VrpkuN+z9OE5wfE5p6H4LchYZsegiQgbJD94ZFQ==",
      "dev": true,
      "dependencies": {
        "lru-cache": "^6.0.0"
      },
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/serialize-javascript": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/serialize-javascript/-/serialize-javascript-5.0.1.tgz",
      "integrity": "sha512-SaaNal9imEO737H2c05Og0/8LUXG7EnsZyMa8MzkmuHoELfT6txuj0cMqRj6zfPKnmQ1yasR4PCJc8x+M4JSPA==",
      "dev": true,
      "dependencies": {
        "randombytes": "^2.1.0"
      }
    },
    "node_modules/shallow-clone": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/shallow-clone/-/shallow-clone-3.0.1.tgz",
      "integrity": "sha512-/6KqX+GVUdqPuPPd2LxDDxzX6CAbjJehAAOKlNpqqUpAqPM6HeL8f+o3a+JsyGjn2lv0WY8UsTgUJjU9Ok55NA==",
      "dev": true,
      "dependencies": {
        "kind-of": "^6.0.2"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/shebang-command": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
      "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
      "dev": true,
      "dependencies": {
        "shebang-regex": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/shebang-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
      "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/signal-exit": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-3.0.3.tgz",
      "integrity": "sha512-VUJ49FC8U1OxwZLxIbTTrDvLnf/6TDgxZcK8wxR8zs13xpx7xbG60ndBlhNrFi2EMuFRoeDoJO7wthSLq42EjA==",
      "dev": true
    },
    "node_modules/slash": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/slash/-/slash-3.0.0.tgz",
      "integrity": "sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/slice-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/slice-ansi/-/slice-ansi-4.0.0.tgz",
      "integrity": "sha512-qMCMfhY040cVHT43K9BFygqYbUPFZKHOg7K73mtTWJRb8pyP3fzf4Ixd5SzdEJQ6MRUg/WBnOLxghZtKKurENQ==",
      "dev": true,
      "dependencies": {
        "ansi-styles": "^4.0.0",
        "astral-regex": "^2.0.0",
        "is-fullwidth-code-point": "^3.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/slice-ansi?sponsor=1"
      }
    },
    "node_modules/source-list-map": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/source-list-map/-/source-list-map-2.0.1.tgz",
      "integrity": "sha512-qnQ7gVMxGNxsiL4lEuJwe/To8UnK7fAnmbGEEH8RpLouuKbeEm0lhbQVFIrNSuB+G7tVrAlVsZgETT5nljf+Iw==",
      "dev": true
    },
    "node_modules/source-map": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
      "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/source-map-support": {
      "version": "0.5.19",
      "resolved": "https://registry.npmjs.org/source-map-support/-/source-map-support-0.5.19.tgz",
      "integrity": "sha512-Wonm7zOCIJzBGQdB+thsPar0kYuCIzYvxZwlBa87yi/Mdjv7Tip2cyVbLj5o0cFPN4EVkuTwb3GDDyUx2DGnGw==",
      "dependencies": {
        "buffer-from": "^1.0.0",
        "source-map": "^0.6.0"
      }
    },
    "node_modules/sprintf-js": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/sprintf-js/-/sprintf-js-1.0.3.tgz",
      "integrity": "sha1-BOaSb2YolTVPPdAVIDYzuFcpfiw=",
      "dev": true
    },
    "node_modules/string-width": {
      "version": "4.2.2",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.2.tgz",
      "integrity": "sha512-XBJbT3N4JhVumXE0eoLU9DCjcaF92KLNqTmFCnG1pf8duUxFGwtP6AD6nkjw9a3IdiRtL3E2w3JDiE/xi3vOeA==",
      "dev": true,
      "dependencies": {
        "emoji-regex": "^8.0.0",
        "is-fullwidth-code-point": "^3.0.0",
        "strip-ansi": "^6.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-ansi": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.0.tgz",
      "integrity": "sha512-AuvKTrTfQNYNIctbR1K/YGTR1756GycPsg7b9bdV9Duqur4gv6aKqHXah67Z8ImS7WEz5QVcOtlfW2rZEugt6w==",
      "dev": true,
      "dependencies": {
        "ansi-regex": "^5.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-final-newline": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/strip-final-newline/-/strip-final-newline-2.0.0.tgz",
      "integrity": "sha512-BrpvfNAE3dcvq7ll3xVumzjKjZQ5tI1sEUIKr3Uoks0XUl45St3FlatVqef9prk4jRDzhW6WZg+3bk93y6pLjA==",
      "dev": true,
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/strip-json-comments": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
      "integrity": "sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==",
      "dev": true,
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/supports-color": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
      "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
      "dev": true,
      "dependencies": {
        "has-flag": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/table": {
      "version": "6.7.1",
      "resolved": "https://registry.npmjs.org/table/-/table-6.7.1.tgz",
      "integrity": "sha512-ZGum47Yi6KOOFDE8m223td53ath2enHcYLgOCjGr5ngu8bdIARQk6mN/wRMv4yMRcHnCSnHbCEha4sobQx5yWg==",
      "dev": true,
      "dependencies": {
        "ajv": "^8.0.1",
        "lodash.clonedeep": "^4.5.0",
        "lodash.truncate": "^4.4.2",
        "slice-ansi": "^4.0.0",
        "string-width": "^4.2.0",
        "strip-ansi": "^6.0.0"
      },
      "engines": {
        "node": ">=10.0.0"
      }
    },
    "node_modules/table/node_modules/ajv": {
      "version": "8.5.0",
      "resolved": "https://registry.npmjs.org/ajv/-/ajv-8.5.0.tgz",
      "integrity": "sha512-Y2l399Tt1AguU3BPRP9Fn4eN+Or+StUGWCUpbnFyXSo8NZ9S4uj+AG2pjs5apK+ZMOwYOz1+a+VKvKH7CudXgQ==",
      "dev": true,
      "dependencies": {
        "fast-deep-equal": "^3.1.1",
        "json-schema-traverse": "^1.0.0",
        "require-from-string": "^2.0.2",
        "uri-js": "^4.2.2"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/epoberezkin"
      }
    },
    "node_modules/table/node_modules/json-schema-traverse": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-1.0.0.tgz",
      "integrity": "sha512-NM8/P9n3XjXhIZn1lLhkFaACTOURQXjWhV4BA/RnOv8xvgqtqpAX9IO4mRQxSx1Rlo4tqzeqb0sOlruaOy3dug==",
      "dev": true
    },
    "node_modules/tapable": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/tapable/-/tapable-2.2.0.tgz",
      "integrity": "sha512-FBk4IesMV1rBxX2tfiK8RAmogtWn53puLOQlvO8XuwlgxcYbP4mVPS9Ph4aeamSyyVjOl24aYWAuc8U5kCVwMw==",
      "dev": true,
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/terser": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/terser/-/terser-5.7.0.tgz",
      "integrity": "sha512-HP5/9hp2UaZt5fYkuhNBR8YyRcT8juw8+uFbAme53iN9hblvKnLUTKkmwJG6ocWpIKf8UK4DoeWG4ty0J6S6/g==",
      "dev": true,
      "dependencies": {
        "commander": "^2.20.0",
        "source-map": "~0.7.2",
        "source-map-support": "~0.5.19"
      },
      "bin": {
        "terser": "bin/terser"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/terser-webpack-plugin": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/terser-webpack-plugin/-/terser-webpack-plugin-5.1.2.tgz",
      "integrity": "sha512-6QhDaAiVHIQr5Ab3XUWZyDmrIPCHMiqJVljMF91YKyqwKkL5QHnYMkrMBy96v9Z7ev1hGhSEw1HQZc2p/s5Z8Q==",
      "dev": true,
      "dependencies": {
        "jest-worker": "^26.6.2",
        "p-limit": "^3.1.0",
        "schema-utils": "^3.0.0",
        "serialize-javascript": "^5.0.1",
        "source-map": "^0.6.1",
        "terser": "^5.7.0"
      },
      "engines": {
        "node": ">= 10.13.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/webpack"
      },
      "peerDependencies": {
        "webpack": "^5.1.0"
      }
    },
    "node_modules/terser/node_modules/source-map": {
      "version": "0.7.3",
      "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.7.3.tgz",
      "integrity": "sha512-CkCj6giN3S+n9qrYiBTX5gystlENnRW5jZeNLHpe6aue+SrHcG5VYwujhW9s4dY31mEGsxBDrHR6oI69fTXsaQ==",
      "dev": true,
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/text-table": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
      "integrity": "sha1-f17oI66AUgfACvLfSoTsP8+lcLQ=",
      "dev": true
    },
    "node_modules/to-regex-range": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
      "dev": true,
      "dependencies": {
        "is-number": "^7.0.0"
      },
      "engines": {
        "node": ">=8.0"
      }
    },
    "node_modules/ts-loader": {
      "version": "9.2.2",
      "resolved": "https://registry.npmjs.org/ts-loader/-/ts-loader-9.2.2.tgz",
      "integrity": "sha512-hNIhGTQHtNKjOzR2ZtQ2OSVbXPykOae+zostf1IlHCf61Mt41GMJurKNqrYUbzHgpmj6UWRu8eBfb7q0XliV0g==",
      "dev": true,
      "dependencies": {
        "chalk": "^4.1.0",
        "enhanced-resolve": "^5.0.0",
        "micromatch": "^4.0.0",
        "semver": "^7.3.4"
      },
      "engines": {
        "node": ">=12.0.0"
      },
      "peerDependencies": {
        "typescript": "*",
        "webpack": "^5.0.0"
      }
    },
    "node_modules/ts-node": {
      "version": "6.2.0",
      "resolved": "https://registry.npmjs.org/ts-node/-/ts-node-6.2.0.tgz",
      "integrity": "sha512-ZNT+OEGfUNVMGkpIaDJJ44Zq3Yr0bkU/ugN1PHbU+/01Z7UV1fsELRiTx1KuQNvQ1A3pGh3y25iYF6jXgxV21A==",
      "dependencies": {
        "arrify": "^1.0.0",
        "buffer-from": "^1.1.0",
        "diff": "^3.1.0",
        "make-error": "^1.1.1",
        "minimist": "^1.2.0",
        "mkdirp": "^0.5.1",
        "source-map-support": "^0.5.6",
        "yn": "^2.0.0"
      },
      "bin": {
        "ts-node": "dist/bin.js"
      },
      "engines": {
        "node": ">=4.2.0"
      }
    },
    "node_modules/ts-node/node_modules/diff": {
      "version": "3.5.0",
      "resolved": "https://registry.npmjs.org/diff/-/diff-3.5.0.tgz",
      "integrity": "sha512-A46qtFgd+g7pDZinpnwiRJtxbC1hpgf0uzP3iG89scHk0AUC7A1TGxf5OiiOUv/JMZR8GOt8hL900hV0bOy5xA==",
      "engines": {
        "node": ">=0.3.1"
      }
    },
    "node_modules/tslib": {
      "version": "1.14.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-1.14.1.tgz",
      "integrity": "sha512-Xni35NKzjgMrwevysHTCArtLDpPvye8zV/0E4EyYn43P7/7qvQwPh9BGkHewbMulVntbigmcT7rdX3BNo9wRJg==",
      "dev": true
    },
    "node_modules/tsutils": {
      "version": "3.21.0",
      "resolved": "https://registry.npmjs.org/tsutils/-/tsutils-3.21.0.tgz",
      "integrity": "sha512-mHKK3iUXL+3UF6xL5k0PEhKRUBKPBCv/+RkEOpjRWxxx27KKRBmmA60A9pgOUvMi8GKhRMPEmjBRPzs2W7O1OA==",
      "dev": true,
      "dependencies": {
        "tslib": "^1.8.1"
      },
      "engines": {
        "node": ">= 6"
      },
      "peerDependencies": {
        "typescript": ">=2.8.0 || >= 3.2.0-dev || >= 3.3.0-dev || >= 3.4.0-dev || >= 3.5.0-dev || >= 3.6.0-dev || >= 3.6.0-beta || >= 3.7.0-dev || >= 3.7.0-beta"
      }
    },
    "node_modules/type-check": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz",
      "integrity": "sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==",
      "dev": true,
      "dependencies": {
        "prelude-ls": "^1.2.1"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/type-fest": {
      "version": "0.20.2",
      "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-0.20.2.tgz",
      "integrity": "sha512-Ne+eE4r0/iWnpAxD852z3A+N0Bt5RN//NjJwRd2VFHEmrywxf5vsZlh4R6lixl6B+wz/8d+maTSAkN1FIkI3LQ==",
      "dev": true,
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/typescript": {
      "version": "4.2.4",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-4.2.4.tgz",
      "integrity": "sha512-V+evlYHZnQkaz8TRBuxTA92yZBPotr5H+WhQ7bD3hZUndx5tGOa1fuCgeSjxAzM1RiN5IzvadIXTVefuuwZCRg==",
      "dev": true,
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=4.2.0"
      }
    },
    "node_modules/uri-js": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz",
      "integrity": "sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==",
      "dev": true,
      "dependencies": {
        "punycode": "^2.1.0"
      }
    },
    "node_modules/v8-compile-cache": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/v8-compile-cache/-/v8-compile-cache-2.3.0.tgz",
      "integrity": "sha512-l8lCEmLcLYZh4nbunNZvQCJc5pv7+RCwa8q/LdUx8u7lsWvPDKmpodJAJNwkAhJC//dFY48KuIEmjtd4RViDrA==",
      "dev": true
    },
    "node_modules/watchpack": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/watchpack/-/watchpack-2.2.0.tgz",
      "integrity": "sha512-up4YAn/XHgZHIxFBVCdlMiWDj6WaLKpwVeGQk2I5thdYxF/KmF0aaz6TfJZ/hfl1h/XlcDr7k1KH7ThDagpFaA==",
      "dev": true,
      "dependencies": {
        "glob-to-regexp": "^0.4.1",
        "graceful-fs": "^4.1.2"
      },
      "engines": {
        "node": ">=10.13.0"
      }
    },
    "node_modules/webpack": {
      "version": "5.37.1",
      "resolved": "https://registry.npmjs.org/webpack/-/webpack-5.37.1.tgz",
      "integrity": "sha512-btZjGy/hSjCAAVHw+cKG+L0M+rstlyxbO2C+BOTaQ5/XAnxkDrP5sVbqWhXgo4pL3X2dcOib6rqCP20Zr9PLow==",
      "dev": true,
      "dependencies": {
        "@types/eslint-scope": "^3.7.0",
        "@types/estree": "^0.0.47",
        "@webassemblyjs/ast": "1.11.0",
        "@webassemblyjs/wasm-edit": "1.11.0",
        "@webassemblyjs/wasm-parser": "1.11.0",
        "acorn": "^8.2.1",
        "browserslist": "^4.14.5",
        "chrome-trace-event": "^1.0.2",
        "enhanced-resolve": "^5.8.0",
        "es-module-lexer": "^0.4.0",
        "eslint-scope": "^5.1.1",
        "events": "^3.2.0",
        "glob-to-regexp": "^0.4.1",
        "graceful-fs": "^4.2.4",
        "json-parse-better-errors": "^1.0.2",
        "loader-runner": "^4.2.0",
        "mime-types": "^2.1.27",
        "neo-async": "^2.6.2",
        "schema-utils": "^3.0.0",
        "tapable": "^2.1.1",
        "terser-webpack-plugin": "^5.1.1",
        "watchpack": "^2.0.0",
        "webpack-sources": "^2.1.1"
      },
      "bin": {
        "webpack": "bin/webpack.js"
      },
      "engines": {
        "node": ">=10.13.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/webpack"
      },
      "peerDependenciesMeta": {
        "webpack-cli": {
          "optional": true
        }
      }
    },
    "node_modules/webpack-cli": {
      "version": "4.7.0",
      "resolved": "https://registry.npmjs.org/webpack-cli/-/webpack-cli-4.7.0.tgz",
      "integrity": "sha512-7bKr9182/sGfjFm+xdZSwgQuFjgEcy0iCTIBxRUeteJ2Kr8/Wz0qNJX+jw60LU36jApt4nmMkep6+W5AKhok6g==",
      "dev": true,
      "dependencies": {
        "@discoveryjs/json-ext": "^0.5.0",
        "@webpack-cli/configtest": "^1.0.3",
        "@webpack-cli/info": "^1.2.4",
        "@webpack-cli/serve": "^1.4.0",
        "colorette": "^1.2.1",
        "commander": "^7.0.0",
        "execa": "^5.0.0",
        "fastest-levenshtein": "^1.0.12",
        "import-local": "^3.0.2",
        "interpret": "^2.2.0",
        "rechoir": "^0.7.0",
        "v8-compile-cache": "^2.2.0",
        "webpack-merge": "^5.7.3"
      },
      "bin": {
        "webpack-cli": "bin/cli.js"
      },
      "engines": {
        "node": ">=10.13.0"
      },
      "peerDependencies": {
        "webpack": "4.x.x || 5.x.x"
      },
      "peerDependenciesMeta": {
        "@webpack-cli/generators": {
          "optional": true
        },
        "@webpack-cli/migrate": {
          "optional": true
        },
        "webpack-bundle-analyzer": {
          "optional": true
        },
        "webpack-dev-server": {
          "optional": true
        }
      }
    },
    "node_modules/webpack-cli/node_modules/commander": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/commander/-/commander-7.2.0.tgz",
      "integrity": "sha512-QrWXB+ZQSVPmIWIhtEO9H+gwHaMGYiF5ChvoJ+K9ZGHG/sVsa6yiesAD1GC/x46sET00Xlwo1u49RVVVzvcSkw==",
      "dev": true,
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/webpack-merge": {
      "version": "5.7.3",
      "resolved": "https://registry.npmjs.org/webpack-merge/-/webpack-merge-5.7.3.tgz",
      "integrity": "sha512-6/JUQv0ELQ1igjGDzHkXbVDRxkfA57Zw7PfiupdLFJYrgFqY5ZP8xxbpp2lU3EPwYx89ht5Z/aDkD40hFCm5AA==",
      "dev": true,
      "dependencies": {
        "clone-deep": "^4.0.1",
        "wildcard": "^2.0.0"
      },
      "engines": {
        "node": ">=10.0.0"
      }
    },
    "node_modules/webpack-sources": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/webpack-sources/-/webpack-sources-2.2.0.tgz",
      "integrity": "sha512-bQsA24JLwcnWGArOKUxYKhX3Mz/nK1Xf6hxullKERyktjNMC4x8koOeaDNTA2fEJ09BdWLbM/iTW0ithREUP0w==",
      "dev": true,
      "dependencies": {
        "source-list-map": "^2.0.1",
        "source-map": "^0.6.1"
      },
      "engines": {
        "node": ">=10.13.0"
      }
    },
    "node_modules/webpack/node_modules/acorn": {
      "version": "8.2.4",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.2.4.tgz",
      "integrity": "sha512-Ibt84YwBDDA890eDiDCEqcbwvHlBvzzDkU2cGBBDDI1QWT12jTiXIOn2CIw5KK4i6N5Z2HUxwYjzriDyqaqqZg==",
      "dev": true,
      "bin": {
        "acorn": "bin/acorn"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/which": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
      "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
      "dev": true,
      "dependencies": {
        "isexe": "^2.0.0"
      },
      "bin": {
        "node-which": "bin/node-which"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/wildcard": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/wildcard/-/wildcard-2.0.0.tgz",
      "integrity": "sha512-JcKqAHLPxcdb9KM49dufGXn2x3ssnfjbcaQdLlfZsL9rH9wgDQjUtDxbo8NE0F6SFvydeu1VhZe7hZuHsB2/pw==",
      "dev": true
    },
    "node_modules/word-wrap": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.3.tgz",
      "integrity": "sha512-Hz/mrNwitNRh/HUAtM/VT/5VH+ygD6DV7mYKZAtHOrbs8U7lvPS6xf7EJKMF0uW1KJCl0H701g3ZGus+muE5vQ==",
      "dev": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha1-tSQ9jz7BqjXxNkYFvA0QNuMKtp8=",
      "dev": true
    },
    "node_modules/yallist": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-4.0.0.tgz",
      "integrity": "sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A==",
      "dev": true
    },
    "node_modules/yn": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/yn/-/yn-2.0.0.tgz",
      "integrity": "sha1-5a2ryKz0CPY4X8dklWhMiOavaJo=",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/yocto-queue": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/yocto-queue/-/yocto-queue-0.1.0.tgz",
      "integrity": "sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==",
      "dev": true,
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    }
  },
  "dependencies": {
    "@babel/code-frame": {
      "version": "7.12.11",
      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.12.11.tgz",
      "integrity": "sha512-Zt1yodBx1UcyiePMSkWnU4hPqhwq7hGi2nFL1LeA3EUl+q2LQx16MISgJ0+z7dnmgvP9QtIleuETGOiOH1RcIw==",
      "dev": true,
      "requires": {
        "@babel/highlight": "^7.10.4"
      }
    },
    "@babel/helper-validator-identifier": {
      "version": "7.14.0",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.14.0.tgz",
      "integrity": "sha512-V3ts7zMSu5lfiwWDVWzRDGIN+lnCEUdaXgtVHJgLb1rGaA6jMrtB9EmE7L18foXJIE8Un/A/h6NJfGQp/e1J4A==",
      "dev": true
    },
    "@babel/highlight": {
      "version": "7.14.0",
      "resolved": "https://registry.npmjs.org/@babel/highlight/-/highlight-7.14.0.tgz",
      "integrity": "sha512-YSCOwxvTYEIMSGaBQb5kDDsCopDdiUGsqpatp3fOlI4+2HQSkTmEVWnVuySdAC5EWCqSWWTv0ib63RjR7dTBdg==",
      "dev": true,
      "requires": {
        "@babel/helper-validator-identifier": "^7.14.0",
        "chalk": "^2.0.0",
        "js-tokens": "^4.0.0"
      },
      "dependencies": {
        "ansi-styles": {
          "version": "3.2.1",
          "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-3.2.1.tgz",
          "integrity": "sha512-VT0ZI6kZRdTh8YyJw3SMbYm/u+NqfsAxEpWO0Pf9sq8/e94WxxOpPKx9FR1FlyCtOVDNOQ+8ntlqFxiRc+r5qA==",
          "dev": true,
          "requires": {
            "color-convert": "^1.9.0"
          }
        },
        "chalk": {
          "version": "2.4.2",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
          "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
          "dev": true,
          "requires": {
            "ansi-styles": "^3.2.1",
            "escape-string-regexp": "^1.0.5",
            "supports-color": "^5.3.0"
          }
        },
        "color-convert": {
          "version": "1.9.3",
          "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-1.9.3.tgz",
          "integrity": "sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg==",
          "dev": true,
          "requires": {
            "color-name": "1.1.3"
          }
        },
        "color-name": {
          "version": "1.1.3",
          "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.3.tgz",
          "integrity": "sha1-p9BVi9icQveV3UIyj3QIMcpTvCU=",
          "dev": true
        },
        "escape-string-regexp": {
          "version": "1.0.5",
          "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz",
          "integrity": "sha1-G2HAViGQqN/2rjuyzwIAyhMLhtQ=",
          "dev": true
        },
        "has-flag": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz",
          "integrity": "sha1-tdRU3CGZriJWmfNGfloH87lVuv0=",
          "dev": true
        },
        "supports-color": {
          "version": "5.5.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
          "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
          "dev": true,
          "requires": {
            "has-flag": "^3.0.0"
          }
        }
      }
    },
    "@discoveryjs/json-ext": {
      "version": "0.5.3",
      "resolved": "https://registry.npmjs.org/@discoveryjs/json-ext/-/json-ext-0.5.3.tgz",
      "integrity": "sha512-Fxt+AfXgjMoin2maPIYzFZnQjAXjAL0PHscM5pRTtatFqB+vZxAM9tLp2Optnuw3QOQC40jTNeGYFOMvyf7v9g==",
      "dev": true
    },
    "@eslint/eslintrc": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-0.4.1.tgz",
      "integrity": "sha512-5v7TDE9plVhvxQeWLXDTvFvJBdH6pEsdnl2g/dAptmuFEPedQ4Erq5rsDsX+mvAM610IhNaO2W5V1dOOnDKxkQ==",
      "dev": true,
      "requires": {
        "ajv": "^6.12.4",
        "debug": "^4.1.1",
        "espree": "^7.3.0",
        "globals": "^12.1.0",
        "ignore": "^4.0.6",
        "import-fresh": "^3.2.1",
        "js-yaml": "^3.13.1",
        "minimatch": "^3.0.4",
        "strip-json-comments": "^3.1.1"
      },
      "dependencies": {
        "globals": {
          "version": "12.4.0",
          "resolved": "https://registry.npmjs.org/globals/-/globals-12.4.0.tgz",
          "integrity": "sha512-BWICuzzDvDoH54NHKCseDanAhE3CeDorgDL5MT6LMXXj2WCnd9UC2szdk4AWLfjdgNBCXLUanXYcpBBKOSWGwg==",
          "dev": true,
          "requires": {
            "type-fest": "^0.8.1"
          }
        },
        "type-fest": {
          "version": "0.8.1",
          "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-0.8.1.tgz",
          "integrity": "sha512-4dbzIzqvjtgiM5rw1k5rEHtBANKmdudhGyBEajN01fEyhaAIhsoKNy6y7+IN93IfpFtwY9iqi7kD+xwKhQsNJA==",
          "dev": true
        }
      }
    },
    "@nodelib/fs.scandir": {
      "version": "2.1.4",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.4.tgz",
      "integrity": "sha512-33g3pMJk3bg5nXbL/+CY6I2eJDzZAni49PfJnL5fghPTggPvBd/pFNSgJsdAgWptuFu7qq/ERvOYFlhvsLTCKA==",
      "dev": true,
      "requires": {
        "@nodelib/fs.stat": "2.0.4",
        "run-parallel": "^1.1.9"
      }
    },
    "@nodelib/fs.stat": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.4.tgz",
      "integrity": "sha512-IYlHJA0clt2+Vg7bccq+TzRdJvv19c2INqBSsoOLp1je7xjtr7J26+WXR72MCdvU9q1qTzIWDfhMf+DRvQJK4Q==",
      "dev": true
    },
    "@nodelib/fs.walk": {
      "version": "1.2.6",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.6.tgz",
      "integrity": "sha512-8Broas6vTtW4GIXTAHDoE32hnN2M5ykgCpWGbuXHQ15vEMqr23pB76e/GZcYsZCHALv50ktd24qhEyKr6wBtow==",
      "dev": true,
      "requires": {
        "@nodelib/fs.scandir": "2.1.4",
        "fastq": "^1.6.0"
      }
    },
    "@types/eslint": {
      "version": "7.2.12",
      "resolved": "https://registry.npmjs.org/@types/eslint/-/eslint-7.2.12.tgz",
      "integrity": "sha512-HjikV/jX6e0Pg4DcB+rtOBKSrG6w5IaxWpmi3efL/eLxMz5lZTK+W1DKERrX5a+mNzL78axfsDNXu7JHFP4uLg==",
      "dev": true,
      "requires": {
        "@types/estree": "*",
        "@types/json-schema": "*"
      }
    },
    "@types/eslint-scope": {
      "version": "3.7.0",
      "resolved": "https://registry.npmjs.org/@types/eslint-scope/-/eslint-scope-3.7.0.tgz",
      "integrity": "sha512-O/ql2+rrCUe2W2rs7wMR+GqPRcgB6UiqN5RhrR5xruFlY7l9YLMn0ZkDzjoHLeiFkR8MCQZVudUuuvQ2BLC9Qw==",
      "dev": true,
      "requires": {
        "@types/eslint": "*",
        "@types/estree": "*"
      }
    },
    "@types/estree": {
      "version": "0.0.47",
      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-0.0.47.tgz",
      "integrity": "sha512-c5ciR06jK8u9BstrmJyO97m+klJrrhCf9u3rLu3DEAJBirxRqSCvDQoYKmxuYwQI5SZChAWu+tq9oVlGRuzPAg==",
      "dev": true
    },
    "@types/json-schema": {
      "version": "7.0.7",
      "resolved": "https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.7.tgz",
      "integrity": "sha512-cxWFQVseBm6O9Gbw1IWb8r6OS4OhSt3hPZLkFApLjM8TEXROBuQGLAH2i2gZpcXdLBIrpXuTDhH7Vbm1iXmNGA==",
      "dev": true
    },
    "@types/node": {
      "version": "15.6.1",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-15.6.1.tgz",
      "integrity": "sha512-7EIraBEyRHEe7CH+Fm1XvgqU6uwZN8Q7jppJGcqjROMT29qhAuuOxYB1uEY5UMYQKEmA5D+5tBnhdaPXSsLONA==",
      "dev": true
    },
    "@typescript-eslint/eslint-plugin": {
      "version": "4.25.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/eslint-plugin/-/eslint-plugin-4.25.0.tgz",
      "integrity": "sha512-Qfs3dWkTMKkKwt78xp2O/KZQB8MPS1UQ5D3YW2s6LQWBE1074BE+Rym+b1pXZIX3M3fSvPUDaCvZLKV2ylVYYQ==",
      "dev": true,
      "requires": {
        "@typescript-eslint/experimental-utils": "4.25.0",
        "@typescript-eslint/scope-manager": "4.25.0",
        "debug": "^4.1.1",
        "functional-red-black-tree": "^1.0.1",
        "lodash": "^4.17.15",
        "regexpp": "^3.0.0",
        "semver": "^7.3.2",
        "tsutils": "^3.17.1"
      }
    },
    "@typescript-eslint/experimental-utils": {
      "version": "4.25.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/experimental-utils/-/experimental-utils-4.25.0.tgz",
      "integrity": "sha512-f0doRE76vq7NEEU0tw+ajv6CrmPelw5wLoaghEHkA2dNLFb3T/zJQqGPQ0OYt5XlZaS13MtnN+GTPCuUVg338w==",
      "dev": true,
      "requires": {
        "@types/json-schema": "^7.0.3",
        "@typescript-eslint/scope-manager": "4.25.0",
        "@typescript-eslint/types": "4.25.0",
        "@typescript-eslint/typescript-estree": "4.25.0",
        "eslint-scope": "^5.0.0",
        "eslint-utils": "^2.0.0"
      }
    },
    "@typescript-eslint/parser": {
      "version": "4.25.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/parser/-/parser-4.25.0.tgz",
      "integrity": "sha512-OZFa1SKyEJpAhDx8FcbWyX+vLwh7OEtzoo2iQaeWwxucyfbi0mT4DijbOSsTgPKzGHr6GrF2V5p/CEpUH/VBxg==",
      "dev": true,
      "requires": {
        "@typescript-eslint/scope-manager": "4.25.0",
        "@typescript-eslint/types": "4.25.0",
        "@typescript-eslint/typescript-estree": "4.25.0",
        "debug": "^4.1.1"
      }
    },
    "@typescript-eslint/scope-manager": {
      "version": "4.25.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/scope-manager/-/scope-manager-4.25.0.tgz",
      "integrity": "sha512-2NElKxMb/0rya+NJG1U71BuNnp1TBd1JgzYsldsdA83h/20Tvnf/HrwhiSlNmuq6Vqa0EzidsvkTArwoq+tH6w==",
      "dev": true,
      "requires": {
        "@typescript-eslint/types": "4.25.0",
        "@typescript-eslint/visitor-keys": "4.25.0"
      }
    },
    "@typescript-eslint/types": {
      "version": "4.25.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/types/-/types-4.25.0.tgz",
      "integrity": "sha512-+CNINNvl00OkW6wEsi32wU5MhHti2J25TJsJJqgQmJu3B3dYDBcmOxcE5w9cgoM13TrdE/5ND2HoEnBohasxRQ==",
      "dev": true
    },
    "@typescript-eslint/typescript-estree": {
      "version": "4.25.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-4.25.0.tgz",
      "integrity": "sha512-1B8U07TGNAFMxZbSpF6jqiDs1cVGO0izVkf18Q/SPcUAc9LhHxzvSowXDTvkHMWUVuPpagupaW63gB6ahTXVlg==",
      "dev": true,
      "requires": {
        "@typescript-eslint/types": "4.25.0",
        "@typescript-eslint/visitor-keys": "4.25.0",
        "debug": "^4.1.1",
        "globby": "^11.0.1",
        "is-glob": "^4.0.1",
        "semver": "^7.3.2",
        "tsutils": "^3.17.1"
      }
    },
    "@typescript-eslint/visitor-keys": {
      "version": "4.25.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-4.25.0.tgz",
      "integrity": "sha512-AmkqV9dDJVKP/TcZrbf6s6i1zYXt5Hl8qOLrRDTFfRNae4+LB8A4N3i+FLZPW85zIxRy39BgeWOfMS3HoH5ngg==",
      "dev": true,
      "requires": {
        "@typescript-eslint/types": "4.25.0",
        "eslint-visitor-keys": "^2.0.0"
      }
    },
    "@webassemblyjs/ast": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/ast/-/ast-1.11.0.tgz",
      "integrity": "sha512-kX2W49LWsbthrmIRMbQZuQDhGtjyqXfEmmHyEi4XWnSZtPmxY0+3anPIzsnRb45VH/J55zlOfWvZuY47aJZTJg==",
      "dev": true,
      "requires": {
        "@webassemblyjs/helper-numbers": "1.11.0",
        "@webassemblyjs/helper-wasm-bytecode": "1.11.0"
      }
    },
    "@webassemblyjs/floating-point-hex-parser": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/floating-point-hex-parser/-/floating-point-hex-parser-1.11.0.tgz",
      "integrity": "sha512-Q/aVYs/VnPDVYvsCBL/gSgwmfjeCb4LW8+TMrO3cSzJImgv8lxxEPM2JA5jMrivE7LSz3V+PFqtMbls3m1exDA==",
      "dev": true
    },
    "@webassemblyjs/helper-api-error": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-api-error/-/helper-api-error-1.11.0.tgz",
      "integrity": "sha512-baT/va95eXiXb2QflSx95QGT5ClzWpGaa8L7JnJbgzoYeaA27FCvuBXU758l+KXWRndEmUXjP0Q5fibhavIn8w==",
      "dev": true
    },
    "@webassemblyjs/helper-buffer": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-buffer/-/helper-buffer-1.11.0.tgz",
      "integrity": "sha512-u9HPBEl4DS+vA8qLQdEQ6N/eJQ7gT7aNvMIo8AAWvAl/xMrcOSiI2M0MAnMCy3jIFke7bEee/JwdX1nUpCtdyA==",
      "dev": true
    },
    "@webassemblyjs/helper-numbers": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-numbers/-/helper-numbers-1.11.0.tgz",
      "integrity": "sha512-DhRQKelIj01s5IgdsOJMKLppI+4zpmcMQ3XboFPLwCpSNH6Hqo1ritgHgD0nqHeSYqofA6aBN/NmXuGjM1jEfQ==",
      "dev": true,
      "requires": {
        "@webassemblyjs/floating-point-hex-parser": "1.11.0",
        "@webassemblyjs/helper-api-error": "1.11.0",
        "@xtuc/long": "4.2.2"
      }
    },
    "@webassemblyjs/helper-wasm-bytecode": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-wasm-bytecode/-/helper-wasm-bytecode-1.11.0.tgz",
      "integrity": "sha512-MbmhvxXExm542tWREgSFnOVo07fDpsBJg3sIl6fSp9xuu75eGz5lz31q7wTLffwL3Za7XNRCMZy210+tnsUSEA==",
      "dev": true
    },
    "@webassemblyjs/helper-wasm-section": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-wasm-section/-/helper-wasm-section-1.11.0.tgz",
      "integrity": "sha512-3Eb88hcbfY/FCukrg6i3EH8H2UsD7x8Vy47iVJrP967A9JGqgBVL9aH71SETPx1JrGsOUVLo0c7vMCN22ytJew==",
      "dev": true,
      "requires": {
        "@webassemblyjs/ast": "1.11.0",
        "@webassemblyjs/helper-buffer": "1.11.0",
        "@webassemblyjs/helper-wasm-bytecode": "1.11.0",
        "@webassemblyjs/wasm-gen": "1.11.0"
      }
    },
    "@webassemblyjs/ieee754": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/ieee754/-/ieee754-1.11.0.tgz",
      "integrity": "sha512-KXzOqpcYQwAfeQ6WbF6HXo+0udBNmw0iXDmEK5sFlmQdmND+tr773Ti8/5T/M6Tl/413ArSJErATd8In3B+WBA==",
      "dev": true,
      "requires": {
        "@xtuc/ieee754": "^1.2.0"
      }
    },
    "@webassemblyjs/leb128": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/leb128/-/leb128-1.11.0.tgz",
      "integrity": "sha512-aqbsHa1mSQAbeeNcl38un6qVY++hh8OpCOzxhixSYgbRfNWcxJNJQwe2rezK9XEcssJbbWIkblaJRwGMS9zp+g==",
      "dev": true,
      "requires": {
        "@xtuc/long": "4.2.2"
      }
    },
    "@webassemblyjs/utf8": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/utf8/-/utf8-1.11.0.tgz",
      "integrity": "sha512-A/lclGxH6SpSLSyFowMzO/+aDEPU4hvEiooCMXQPcQFPPJaYcPQNKGOCLUySJsYJ4trbpr+Fs08n4jelkVTGVw==",
      "dev": true
    },
    "@webassemblyjs/wasm-edit": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-edit/-/wasm-edit-1.11.0.tgz",
      "integrity": "sha512-JHQ0damXy0G6J9ucyKVXO2j08JVJ2ntkdJlq1UTiUrIgfGMmA7Ik5VdC/L8hBK46kVJgujkBIoMtT8yVr+yVOQ==",
      "dev": true,
      "requires": {
        "@webassemblyjs/ast": "1.11.0",
        "@webassemblyjs/helper-buffer": "1.11.0",
        "@webassemblyjs/helper-wasm-bytecode": "1.11.0",
        "@webassemblyjs/helper-wasm-section": "1.11.0",
        "@webassemblyjs/wasm-gen": "1.11.0",
        "@webassemblyjs/wasm-opt": "1.11.0",
        "@webassemblyjs/wasm-parser": "1.11.0",
        "@webassemblyjs/wast-printer": "1.11.0"
      }
    },
    "@webassemblyjs/wasm-gen": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-gen/-/wasm-gen-1.11.0.tgz",
      "integrity": "sha512-BEUv1aj0WptCZ9kIS30th5ILASUnAPEvE3tVMTrItnZRT9tXCLW2LEXT8ezLw59rqPP9klh9LPmpU+WmRQmCPQ==",
      "dev": true,
      "requires": {
        "@webassemblyjs/ast": "1.11.0",
        "@webassemblyjs/helper-wasm-bytecode": "1.11.0",
        "@webassemblyjs/ieee754": "1.11.0",
        "@webassemblyjs/leb128": "1.11.0",
        "@webassemblyjs/utf8": "1.11.0"
      }
    },
    "@webassemblyjs/wasm-opt": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-opt/-/wasm-opt-1.11.0.tgz",
      "integrity": "sha512-tHUSP5F4ywyh3hZ0+fDQuWxKx3mJiPeFufg+9gwTpYp324mPCQgnuVKwzLTZVqj0duRDovnPaZqDwoyhIO8kYg==",
      "dev": true,
      "requires": {
        "@webassemblyjs/ast": "1.11.0",
        "@webassemblyjs/helper-buffer": "1.11.0",
        "@webassemblyjs/wasm-gen": "1.11.0",
        "@webassemblyjs/wasm-parser": "1.11.0"
      }
    },
    "@webassemblyjs/wasm-parser": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-parser/-/wasm-parser-1.11.0.tgz",
      "integrity": "sha512-6L285Sgu9gphrcpDXINvm0M9BskznnzJTE7gYkjDbxET28shDqp27wpruyx3C2S/dvEwiigBwLA1cz7lNUi0kw==",
      "dev": true,
      "requires": {
        "@webassemblyjs/ast": "1.11.0",
        "@webassemblyjs/helper-api-error": "1.11.0",
        "@webassemblyjs/helper-wasm-bytecode": "1.11.0",
        "@webassemblyjs/ieee754": "1.11.0",
        "@webassemblyjs/leb128": "1.11.0",
        "@webassemblyjs/utf8": "1.11.0"
      }
    },
    "@webassemblyjs/wast-printer": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/wast-printer/-/wast-printer-1.11.0.tgz",
      "integrity": "sha512-Fg5OX46pRdTgB7rKIUojkh9vXaVN6sGYCnEiJN1GYkb0RPwShZXp6KTDqmoMdQPKhcroOXh3fEzmkWmCYaKYhQ==",
      "dev": true,
      "requires": {
        "@webassemblyjs/ast": "1.11.0",
        "@xtuc/long": "4.2.2"
      }
    },
    "@webpack-cli/configtest": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/@webpack-cli/configtest/-/configtest-1.0.3.tgz",
      "integrity": "sha512-WQs0ep98FXX2XBAfQpRbY0Ma6ADw8JR6xoIkaIiJIzClGOMqVRvPCWqndTxf28DgFopWan0EKtHtg/5W1h0Zkw==",
      "dev": true,
      "requires": {}
    },
    "@webpack-cli/info": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@webpack-cli/info/-/info-1.2.4.tgz",
      "integrity": "sha512-ogE2T4+pLhTTPS/8MM3IjHn0IYplKM4HbVNMCWA9N4NrdPzunwenpCsqKEXyejMfRu6K8mhauIPYf8ZxWG5O6g==",
      "dev": true,
      "requires": {
        "envinfo": "^7.7.3"
      }
    },
    "@webpack-cli/serve": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/@webpack-cli/serve/-/serve-1.4.0.tgz",
      "integrity": "sha512-xgT/HqJ+uLWGX+Mzufusl3cgjAcnqYYskaB7o0vRcwOEfuu6hMzSILQpnIzFMGsTaeaX4Nnekl+6fadLbl1/Vg==",
      "dev": true,
      "requires": {}
    },
    "@xtuc/ieee754": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/@xtuc/ieee754/-/ieee754-1.2.0.tgz",
      "integrity": "sha512-DX8nKgqcGwsc0eJSqYt5lwP4DH5FlHnmuWWBRy7X0NcaGR0ZtuyeESgMwTYVEtxmsNGY+qit4QYT/MIYTOTPeA==",
      "dev": true
    },
    "@xtuc/long": {
      "version": "4.2.2",
      "resolved": "https://registry.npmjs.org/@xtuc/long/-/long-4.2.2.tgz",
      "integrity": "sha512-NuHqBY1PB/D8xU6s/thBgOAiAP7HOYDQ32+BFZILJ8ivkUkAHQnWfn6WhL79Owj1qmUnoN/YPhktdIoucipkAQ==",
      "dev": true
    },
    "acorn": {
      "version": "7.4.1",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-7.4.1.tgz",
      "integrity": "sha512-nQyp0o1/mNdbTO1PO6kHkwSrmgZ0MT/jCCpNiwbUjGoRN4dlBhqJtoQuCnEOKzgTVwg0ZWiCoQy6SxMebQVh8A==",
      "dev": true
    },
    "acorn-jsx": {
      "version": "5.3.1",
      "resolved": "https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.1.tgz",
      "integrity": "sha512-K0Ptm/47OKfQRpNQ2J/oIN/3QYiK6FwW+eJbILhsdxh2WTLdl+30o8aGdTbm5JbffpFFAg/g+zi1E+jvJha5ng==",
      "dev": true,
      "requires": {}
    },
    "ajv": {
      "version": "6.12.6",
      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
      "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
      "dev": true,
      "requires": {
        "fast-deep-equal": "^3.1.1",
        "fast-json-stable-stringify": "^2.0.0",
        "json-schema-traverse": "^0.4.1",
        "uri-js": "^4.2.2"
      }
    },
    "ajv-keywords": {
      "version": "3.5.2",
      "resolved": "https://registry.npmjs.org/ajv-keywords/-/ajv-keywords-3.5.2.tgz",
      "integrity": "sha512-5p6WTN0DdTGVQk6VjcEju19IgaHudalcfabD7yhDGeA6bcQnmL+CpveLJq/3hvfwd1aof6L386Ougkx6RfyMIQ==",
      "dev": true,
      "requires": {}
    },
    "ansi-colors": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/ansi-colors/-/ansi-colors-4.1.1.tgz",
      "integrity": "sha512-JoX0apGbHaUJBNl6yF+p6JAFYZ666/hhCGKN5t9QFjbJQKUU/g8MNbFDbvfrgKXvI1QpZplPOnwIo99lX/AAmA==",
      "dev": true
    },
    "ansi-regex": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.0.tgz",
      "integrity": "sha512-bY6fj56OUQ0hU1KjFNDQuJFezqKdrAyFdIevADiqrWHwSlbmBNMHp5ak2f40Pm8JTFyM2mqxkG6ngkHO11f/lg==",
      "dev": true
    },
    "ansi-styles": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
      "dev": true,
      "requires": {
        "color-convert": "^2.0.1"
      }
    },
    "argparse": {
      "version": "1.0.10",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-1.0.10.tgz",
      "integrity": "sha512-o5Roy6tNG4SL/FOkCAN6RzjiakZS25RLYFrcMttJqbdd8BWrnA+fGz57iN5Pb06pvBGvl5gQ0B48dJlslXvoTg==",
      "dev": true,
      "requires": {
        "sprintf-js": "~1.0.2"
      }
    },
    "array-union": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/array-union/-/array-union-2.1.0.tgz",
      "integrity": "sha512-HGyxoOTYUyCM6stUe6EJgnd4EoewAI7zMdfqO+kGjnlZmBDz/cR5pf8r/cR4Wq60sL/p0IkcjUEEPwS3GFrIyw==",
      "dev": true
    },
    "arrify": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/arrify/-/arrify-1.0.1.tgz",
      "integrity": "sha1-iYUI2iIm84DfkEcoRWhJwVAaSw0="
    },
    "astral-regex": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/astral-regex/-/astral-regex-2.0.0.tgz",
      "integrity": "sha512-Z7tMw1ytTXt5jqMcOP+OQteU1VuNK9Y02uuJtKQ1Sv69jXQKKg5cibLwGJow8yzZP+eAc18EmLGPal0bp36rvQ==",
      "dev": true
    },
    "balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "dev": true
    },
    "binaryen": {
      "version": "101.0.0-nightly.20210723",
      "resolved": "https://registry.npmjs.org/binaryen/-/binaryen-101.0.0-nightly.20210723.tgz",
      "integrity": "sha512-eioJNqhHlkguVSbblHOtLqlhtC882SOEPKmNFZaDuz1hzQjolxZ+eu3/kaS10n3sGPONsIZsO7R9fR00UyhEUA=="
    },
    "brace-expansion": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz",
      "integrity": "sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==",
      "dev": true,
      "requires": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "braces": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.2.tgz",
      "integrity": "sha512-b8um+L1RzM3WDSzvhm6gIz1yfTbBt6YTlcEKAvsmqCZZFw46z626lVj9j1yEPW33H5H+lBQpZMP1k8l+78Ha0A==",
      "dev": true,
      "requires": {
        "fill-range": "^7.0.1"
      }
    },
    "browserslist": {
      "version": "4.16.6",
      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.16.6.tgz",
      "integrity": "sha512-Wspk/PqO+4W9qp5iUTJsa1B/QrYn1keNCcEP5OvP7WBwT4KaDly0uONYmC6Xa3Z5IqnUgS0KcgLYu1l74x0ZXQ==",
      "dev": true,
      "requires": {
        "caniuse-lite": "^1.0.30001219",
        "colorette": "^1.2.2",
        "electron-to-chromium": "^1.3.723",
        "escalade": "^3.1.1",
        "node-releases": "^1.1.71"
      }
    },
    "buffer-from": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/buffer-from/-/buffer-from-1.1.1.tgz",
      "integrity": "sha512-MQcXEUbCKtEo7bhqEs6560Hyd4XaovZlO/k9V3hjVUF/zwW7KBVdSK4gIt/bzwS9MbR5qob+F5jusZsb0YQK2A=="
    },
    "callsites": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz",
      "integrity": "sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==",
      "dev": true
    },
    "caniuse-lite": {
      "version": "1.0.30001230",
      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001230.tgz",
      "integrity": "sha512-5yBd5nWCBS+jWKTcHOzXwo5xzcj4ePE/yjtkZyUV1BTUmrBaA9MRGC+e7mxnqXSA90CmCA8L3eKLaSUkt099IQ==",
      "dev": true
    },
    "chalk": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.1.tgz",
      "integrity": "sha512-diHzdDKxcU+bAsUboHLPEDQiw0qEe0qd7SYUn3HgcFlWgbDcfLGswOHYeGrHKzG9z6UYf01d9VFMfZxPM1xZSg==",
      "dev": true,
      "requires": {
        "ansi-styles": "^4.1.0",
        "supports-color": "^7.1.0"
      }
    },
    "chrome-trace-event": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/chrome-trace-event/-/chrome-trace-event-1.0.3.tgz",
      "integrity": "sha512-p3KULyQg4S7NIHixdwbGX+nFHkoBiA4YQmyWtjb8XngSKV124nJmRysgAeujbUVb15vh+RvFUfCPqU7rXk+hZg==",
      "dev": true
    },
    "clone-deep": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/clone-deep/-/clone-deep-4.0.1.tgz",
      "integrity": "sha512-neHB9xuzh/wk0dIHweyAXv2aPGZIVk3pLMe+/RNzINf17fe0OG96QroktYAUm7SM1PBnzTabaLboqqxDyMU+SQ==",
      "dev": true,
      "requires": {
        "is-plain-object": "^2.0.4",
        "kind-of": "^6.0.2",
        "shallow-clone": "^3.0.0"
      }
    },
    "color-convert": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "dev": true,
      "requires": {
        "color-name": "~1.1.4"
      }
    },
    "color-name": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
      "dev": true
    },
    "colorette": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/colorette/-/colorette-1.2.2.tgz",
      "integrity": "sha512-MKGMzyfeuutC/ZJ1cba9NqcNpfeqMUcYmyF1ZFY6/Cn7CNSAKx6a+s48sqLqyAiZuaP2TcqMhoo+dlwFnVxT9w==",
      "dev": true
    },
    "commander": {
      "version": "2.20.3",
      "resolved": "https://registry.npmjs.org/commander/-/commander-2.20.3.tgz",
      "integrity": "sha512-GpVkmM8vF2vQUkj2LvZmD35JxeJOLCwJ9cUkugyk2nuhbv3+mJvpLYYt+0+USMxE+oj+ey/lJEnhZw75x/OMcQ==",
      "dev": true
    },
    "concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha1-2Klr13/Wjfd5OnMDajug1UBdR3s=",
      "dev": true
    },
    "cross-spawn": {
      "version": "7.0.3",
      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.3.tgz",
      "integrity": "sha512-iRDPJKUPVEND7dHPO8rkbOnPpyDygcDFtWjpeWNCgy8WP2rXcxXL8TskReQl6OrB2G7+UJrags1q15Fudc7G6w==",
      "dev": true,
      "requires": {
        "path-key": "^3.1.0",
        "shebang-command": "^2.0.0",
        "which": "^2.0.1"
      }
    },
    "debug": {
      "version": "4.3.1",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.1.tgz",
      "integrity": "sha512-doEwdvm4PCeK4K3RQN2ZC2BYUBaxwLARCqZmMjtF8a51J2Rb0xpVloFRnCODwqjpwnAoao4pelN8l3RJdv3gRQ==",
      "dev": true,
      "requires": {
        "ms": "2.1.2"
      }
    },
    "deep-is": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/deep-is/-/deep-is-0.1.3.tgz",
      "integrity": "sha1-s2nW+128E+7PUk+RsHD+7cNXzzQ=",
      "dev": true
    },
    "diff": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/diff/-/diff-5.0.0.tgz",
      "integrity": "sha512-/VTCrvm5Z0JGty/BWHljh+BAiw3IK+2j87NGMu8Nwc/f48WoDAC395uomO9ZD117ZOBaHmkX1oyLvkVM/aIT3w==",
      "dev": true
    },
    "dir-glob": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/dir-glob/-/dir-glob-3.0.1.tgz",
      "integrity": "sha512-WkrWp9GR4KXfKGYzOLmTuGVi1UWFfws377n9cc55/tb6DuqyF6pcQ5AbiHEshaDpY9v6oaSr2XCDidGmMwdzIA==",
      "dev": true,
      "requires": {
        "path-type": "^4.0.0"
      }
    },
    "doctrine": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/doctrine/-/doctrine-3.0.0.tgz",
      "integrity": "sha512-yS+Q5i3hBf7GBkd4KG8a7eBNNWNGLTaEwwYWUijIYM7zrlYDM0BFXHjjPWlWZ1Rg7UaddZeIDmi9jF3HmqiQ2w==",
      "dev": true,
      "requires": {
        "esutils": "^2.0.2"
      }
    },
    "electron-to-chromium": {
      "version": "1.3.740",
      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.3.740.tgz",
      "integrity": "sha512-Mi2m55JrX2BFbNZGKYR+2ItcGnR4O5HhrvgoRRyZQlaMGQULqDhoGkLWHzJoshSzi7k1PUofxcDbNhlFrDZNhg==",
      "dev": true
    },
    "emoji-regex": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
      "dev": true
    },
    "enhanced-resolve": {
      "version": "5.8.2",
      "resolved": "https://registry.npmjs.org/enhanced-resolve/-/enhanced-resolve-5.8.2.tgz",
      "integrity": "sha512-F27oB3WuHDzvR2DOGNTaYy0D5o0cnrv8TeI482VM4kYgQd/FT9lUQwuNsJ0oOHtBUq7eiW5ytqzp7nBFknL+GA==",
      "dev": true,
      "requires": {
        "graceful-fs": "^4.2.4",
        "tapable": "^2.2.0"
      }
    },
    "enquirer": {
      "version": "2.3.6",
      "resolved": "https://registry.npmjs.org/enquirer/-/enquirer-2.3.6.tgz",
      "integrity": "sha512-yjNnPr315/FjS4zIsUxYguYUPP2e1NK4d7E7ZOLiyYCcbFBiTMyID+2wvm2w6+pZ/odMA7cRkjhsPbltwBOrLg==",
      "dev": true,
      "requires": {
        "ansi-colors": "^4.1.1"
      }
    },
    "envinfo": {
      "version": "7.8.1",
      "resolved": "https://registry.npmjs.org/envinfo/-/envinfo-7.8.1.tgz",
      "integrity": "sha512-/o+BXHmB7ocbHEAs6F2EnG0ogybVVUdkRunTT2glZU9XAaGmhqskrvKwqXuDfNjEO0LZKWdejEEpnq8aM0tOaw==",
      "dev": true
    },
    "es-module-lexer": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/es-module-lexer/-/es-module-lexer-0.4.1.tgz",
      "integrity": "sha512-ooYciCUtfw6/d2w56UVeqHPcoCFAiJdz5XOkYpv/Txl1HMUozpXjz/2RIQgqwKdXNDPSF1W7mJCFse3G+HDyAA==",
      "dev": true
    },
    "escalade": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.1.1.tgz",
      "integrity": "sha512-k0er2gUkLf8O0zKJiAhmkTnJlTvINGv7ygDNPbeIsX/TJjGJZHuh9B2UxbsaEkmlEo9MfhrSzmhIlhRlI2GXnw==",
      "dev": true
    },
    "escape-string-regexp": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
      "integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==",
      "dev": true
    },
    "eslint": {
      "version": "7.27.0",
      "resolved": "https://registry.npmjs.org/eslint/-/eslint-7.27.0.tgz",
      "integrity": "sha512-JZuR6La2ZF0UD384lcbnd0Cgg6QJjiCwhMD6eU4h/VGPcVGwawNNzKU41tgokGXnfjOOyI6QIffthhJTPzzuRA==",
      "dev": true,
      "requires": {
        "@babel/code-frame": "7.12.11",
        "@eslint/eslintrc": "^0.4.1",
        "ajv": "^6.10.0",
        "chalk": "^4.0.0",
        "cross-spawn": "^7.0.2",
        "debug": "^4.0.1",
        "doctrine": "^3.0.0",
        "enquirer": "^2.3.5",
        "escape-string-regexp": "^4.0.0",
        "eslint-scope": "^5.1.1",
        "eslint-utils": "^2.1.0",
        "eslint-visitor-keys": "^2.0.0",
        "espree": "^7.3.1",
        "esquery": "^1.4.0",
        "esutils": "^2.0.2",
        "fast-deep-equal": "^3.1.3",
        "file-entry-cache": "^6.0.1",
        "functional-red-black-tree": "^1.0.1",
        "glob-parent": "^5.0.0",
        "globals": "^13.6.0",
        "ignore": "^4.0.6",
        "import-fresh": "^3.0.0",
        "imurmurhash": "^0.1.4",
        "is-glob": "^4.0.0",
        "js-yaml": "^3.13.1",
        "json-stable-stringify-without-jsonify": "^1.0.1",
        "levn": "^0.4.1",
        "lodash.merge": "^4.6.2",
        "minimatch": "^3.0.4",
        "natural-compare": "^1.4.0",
        "optionator": "^0.9.1",
        "progress": "^2.0.0",
        "regexpp": "^3.1.0",
        "semver": "^7.2.1",
        "strip-ansi": "^6.0.0",
        "strip-json-comments": "^3.1.0",
        "table": "^6.0.9",
        "text-table": "^0.2.0",
        "v8-compile-cache": "^2.0.3"
      }
    },
    "eslint-scope": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-5.1.1.tgz",
      "integrity": "sha512-2NxwbF/hZ0KpepYN0cNbo+FN6XoK7GaHlQhgx/hIZl6Va0bF45RQOOwhLIy8lQDbuCiadSLCBnH2CFYquit5bw==",
      "dev": true,
      "requires": {
        "esrecurse": "^4.3.0",
        "estraverse": "^4.1.1"
      }
    },
    "eslint-utils": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/eslint-utils/-/eslint-utils-2.1.0.tgz",
      "integrity": "sha512-w94dQYoauyvlDc43XnGB8lU3Zt713vNChgt4EWwhXAP2XkBvndfxF0AgIqKOOasjPIPzj9JqgwkwbCYD0/V3Zg==",
      "dev": true,
      "requires": {
        "eslint-visitor-keys": "^1.1.0"
      },
      "dependencies": {
        "eslint-visitor-keys": {
          "version": "1.3.0",
          "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-1.3.0.tgz",
          "integrity": "sha512-6J72N8UNa462wa/KFODt/PJ3IU60SDpC3QXC1Hjc1BXXpfL2C9R5+AU7jhe0F6GREqVMh4Juu+NY7xn+6dipUQ==",
          "dev": true
        }
      }
    },
    "eslint-visitor-keys": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-2.1.0.tgz",
      "integrity": "sha512-0rSmRBzXgDzIsD6mGdJgevzgezI534Cer5L/vyMX0kHzT/jiB43jRhd9YUlMGYLQy2zprNmoT8qasCGtY+QaKw==",
      "dev": true
    },
    "espree": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/espree/-/espree-7.3.1.tgz",
      "integrity": "sha512-v3JCNCE64umkFpmkFGqzVKsOT0tN1Zr+ueqLZfpV1Ob8e+CEgPWa+OxCoGH3tnhimMKIaBm4m/vaRpJ/krRz2g==",
      "dev": true,
      "requires": {
        "acorn": "^7.4.0",
        "acorn-jsx": "^5.3.1",
        "eslint-visitor-keys": "^1.3.0"
      },
      "dependencies": {
        "eslint-visitor-keys": {
          "version": "1.3.0",
          "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-1.3.0.tgz",
          "integrity": "sha512-6J72N8UNa462wa/KFODt/PJ3IU60SDpC3QXC1Hjc1BXXpfL2C9R5+AU7jhe0F6GREqVMh4Juu+NY7xn+6dipUQ==",
          "dev": true
        }
      }
    },
    "esprima": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/esprima/-/esprima-4.0.1.tgz",
      "integrity": "sha512-eGuFFw7Upda+g4p+QHvnW0RyTX/SVeJBDM/gCtMARO0cLuT2HcEKnTPvhjV6aGeqrCB/sbNop0Kszm0jsaWU4A==",
      "dev": true
    },
    "esquery": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/esquery/-/esquery-1.4.0.tgz",
      "integrity": "sha512-cCDispWt5vHHtwMY2YrAQ4ibFkAL8RbH5YGBnZBc90MolvvfkkQcJro/aZiAQUlQ3qgrYS6D6v8Gc5G5CQsc9w==",
      "dev": true,
      "requires": {
        "estraverse": "^5.1.0"
      },
      "dependencies": {
        "estraverse": {
          "version": "5.2.0",
          "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.2.0.tgz",
          "integrity": "sha512-BxbNGGNm0RyRYvUdHpIwv9IWzeM9XClbOxwoATuFdOE7ZE6wHL+HQ5T8hoPM+zHvmKzzsEqhgy0GrQ5X13afiQ==",
          "dev": true
        }
      }
    },
    "esrecurse": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz",
      "integrity": "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==",
      "dev": true,
      "requires": {
        "estraverse": "^5.2.0"
      },
      "dependencies": {
        "estraverse": {
          "version": "5.2.0",
          "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.2.0.tgz",
          "integrity": "sha512-BxbNGGNm0RyRYvUdHpIwv9IWzeM9XClbOxwoATuFdOE7ZE6wHL+HQ5T8hoPM+zHvmKzzsEqhgy0GrQ5X13afiQ==",
          "dev": true
        }
      }
    },
    "estraverse": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-4.3.0.tgz",
      "integrity": "sha512-39nnKffWz8xN1BU/2c79n9nB9HDzo0niYUqx6xyqUnyoAnQyyWpOTdZEeiCch8BBu515t4wp9ZmgVfVhn9EBpw==",
      "dev": true
    },
    "esutils": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
      "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==",
      "dev": true
    },
    "events": {
      "version": "3.3.0",
      "resolved": "https://registry.npmjs.org/events/-/events-3.3.0.tgz",
      "integrity": "sha512-mQw+2fkQbALzQ7V0MY0IqdnXNOeTtP4r0lN9z7AAawCXgqea7bDii20AYrIBrFd/Hx0M2Ocz6S111CaFkUcb0Q==",
      "dev": true
    },
    "execa": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/execa/-/execa-5.0.0.tgz",
      "integrity": "sha512-ov6w/2LCiuyO4RLYGdpFGjkcs0wMTgGE8PrkTHikeUy5iJekXyPIKUjifk5CsE0pt7sMCrMZ3YNqoCj6idQOnQ==",
      "dev": true,
      "requires": {
        "cross-spawn": "^7.0.3",
        "get-stream": "^6.0.0",
        "human-signals": "^2.1.0",
        "is-stream": "^2.0.0",
        "merge-stream": "^2.0.0",
        "npm-run-path": "^4.0.1",
        "onetime": "^5.1.2",
        "signal-exit": "^3.0.3",
        "strip-final-newline": "^2.0.0"
      }
    },
    "fast-deep-equal": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
      "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
      "dev": true
    },
    "fast-glob": {
      "version": "3.2.5",
      "resolved": "https://registry.npmjs.org/fast-glob/-/fast-glob-3.2.5.tgz",
      "integrity": "sha512-2DtFcgT68wiTTiwZ2hNdJfcHNke9XOfnwmBRWXhmeKM8rF0TGwmC/Qto3S7RoZKp5cilZbxzO5iTNTQsJ+EeDg==",
      "dev": true,
      "requires": {
        "@nodelib/fs.stat": "^2.0.2",
        "@nodelib/fs.walk": "^1.2.3",
        "glob-parent": "^5.1.0",
        "merge2": "^1.3.0",
        "micromatch": "^4.0.2",
        "picomatch": "^2.2.1"
      }
    },
    "fast-json-stable-stringify": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz",
      "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==",
      "dev": true
    },
    "fast-levenshtein": {
      "version": "2.0.6",
      "resolved": "https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz",
      "integrity": "sha1-PYpcZog6FqMMqGQ+hR8Zuqd5eRc=",
      "dev": true
    },
    "fastest-levenshtein": {
      "version": "1.0.12",
      "resolved": "https://registry.npmjs.org/fastest-levenshtein/-/fastest-levenshtein-1.0.12.tgz",
      "integrity": "sha512-On2N+BpYJ15xIC974QNVuYGMOlEVt4s0EOI3wwMqOmK1fdDY+FN/zltPV8vosq4ad4c/gJ1KHScUn/6AWIgiow==",
      "dev": true
    },
    "fastq": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/fastq/-/fastq-1.11.0.tgz",
      "integrity": "sha512-7Eczs8gIPDrVzT+EksYBcupqMyxSHXXrHOLRRxU2/DicV8789MRBRR8+Hc2uWzUupOs4YS4JzBmBxjjCVBxD/g==",
      "dev": true,
      "requires": {
        "reusify": "^1.0.4"
      }
    },
    "file-entry-cache": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-6.0.1.tgz",
      "integrity": "sha512-7Gps/XWymbLk2QLYK4NzpMOrYjMhdIxXuIvy2QBsLE6ljuodKvdkWs/cpyJJ3CVIVpH0Oi1Hvg1ovbMzLdFBBg==",
      "dev": true,
      "requires": {
        "flat-cache": "^3.0.4"
      }
    },
    "fill-range": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.0.1.tgz",
      "integrity": "sha512-qOo9F+dMUmC2Lcb4BbVvnKJxTPjCm+RRpe4gDuGrzkL7mEVl/djYSu2OdQ2Pa302N4oqkSg9ir6jaLWJ2USVpQ==",
      "dev": true,
      "requires": {
        "to-regex-range": "^5.0.1"
      }
    },
    "find-up": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/find-up/-/find-up-4.1.0.tgz",
      "integrity": "sha512-PpOwAdQ/YlXQ2vj8a3h8IipDuYRi3wceVQQGYWxNINccq40Anw7BlsEXCMbt1Zt+OLA6Fq9suIpIWD0OsnISlw==",
      "dev": true,
      "requires": {
        "locate-path": "^5.0.0",
        "path-exists": "^4.0.0"
      }
    },
    "flat-cache": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/flat-cache/-/flat-cache-3.0.4.tgz",
      "integrity": "sha512-dm9s5Pw7Jc0GvMYbshN6zchCA9RgQlzzEZX3vylR9IqFfS8XciblUXOKfW6SiuJ0e13eDYZoZV5wdrev7P3Nwg==",
      "dev": true,
      "requires": {
        "flatted": "^3.1.0",
        "rimraf": "^3.0.2"
      }
    },
    "flatted": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/flatted/-/flatted-3.1.1.tgz",
      "integrity": "sha512-zAoAQiudy+r5SvnSw3KJy5os/oRJYHzrzja/tBDqrZtNhUw8bt6y8OBzMWcjWr+8liV8Eb6yOhw8WZ7VFZ5ZzA==",
      "dev": true
    },
    "fs.realpath": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
      "integrity": "sha1-FQStJSMVjKpA20onh8sBQRmU6k8=",
      "dev": true
    },
    "function-bind": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.1.tgz",
      "integrity": "sha512-yIovAzMX49sF8Yl58fSCWJ5svSLuaibPxXQJFLmBObTuCr0Mf1KiPopGM9NiFjiYBCbfaa2Fh6breQ6ANVTI0A==",
      "dev": true
    },
    "functional-red-black-tree": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/functional-red-black-tree/-/functional-red-black-tree-1.0.1.tgz",
      "integrity": "sha1-GwqzvVU7Kg1jmdKcDj6gslIHgyc=",
      "dev": true
    },
    "get-stream": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/get-stream/-/get-stream-6.0.1.tgz",
      "integrity": "sha512-ts6Wi+2j3jQjqi70w5AlN8DFnkSwC+MqmxEzdEALB2qXZYV3X/b1CTfgPLGJNMeAWxdPfU8FO1ms3NUfaHCPYg==",
      "dev": true
    },
    "glob": {
      "version": "7.1.7",
      "resolved": "https://registry.npmjs.org/glob/-/glob-7.1.7.tgz",
      "integrity": "sha512-OvD9ENzPLbegENnYP5UUfJIirTg4+XwMWGaQfQTY0JenxNvvIKP3U3/tAQSPIu/lHxXYSZmpXlUHeqAIdKzBLQ==",
      "dev": true,
      "requires": {
        "fs.realpath": "^1.0.0",
        "inflight": "^1.0.4",
        "inherits": "2",
        "minimatch": "^3.0.4",
        "once": "^1.3.0",
        "path-is-absolute": "^1.0.0"
      }
    },
    "glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "requires": {
        "is-glob": "^4.0.1"
      }
    },
    "glob-to-regexp": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/glob-to-regexp/-/glob-to-regexp-0.4.1.tgz",
      "integrity": "sha512-lkX1HJXwyMcprw/5YUZc2s7DrpAiHB21/V+E1rHUrVNokkvB6bqMzT0VfV6/86ZNabt1k14YOIaT7nDvOX3Iiw==",
      "dev": true
    },
    "globals": {
      "version": "13.9.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-13.9.0.tgz",
      "integrity": "sha512-74/FduwI/JaIrr1H8e71UbDE+5x7pIPs1C2rrwC52SszOo043CsWOZEMW7o2Y58xwm9b+0RBKDxY5n2sUpEFxA==",
      "dev": true,
      "requires": {
        "type-fest": "^0.20.2"
      }
    },
    "globby": {
      "version": "11.0.3",
      "resolved": "https://registry.npmjs.org/globby/-/globby-11.0.3.tgz",
      "integrity": "sha512-ffdmosjA807y7+lA1NM0jELARVmYul/715xiILEjo3hBLPTcirgQNnXECn5g3mtR8TOLCVbkfua1Hpen25/Xcg==",
      "dev": true,
      "requires": {
        "array-union": "^2.1.0",
        "dir-glob": "^3.0.1",
        "fast-glob": "^3.1.1",
        "ignore": "^5.1.4",
        "merge2": "^1.3.0",
        "slash": "^3.0.0"
      },
      "dependencies": {
        "ignore": {
          "version": "5.1.8",
          "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.1.8.tgz",
          "integrity": "sha512-BMpfD7PpiETpBl/A6S498BaIJ6Y/ABT93ETbby2fP00v4EbvPBXWEoaR1UBPKs3iR53pJY7EtZk5KACI57i1Uw==",
          "dev": true
        }
      }
    },
    "graceful-fs": {
      "version": "4.2.6",
      "resolved": "https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.2.6.tgz",
      "integrity": "sha512-nTnJ528pbqxYanhpDYsi4Rd8MAeaBA67+RZ10CM1m3bTAVFEDcd5AuA4a6W5YkGZ1iNXHzZz8T6TBKLeBuNriQ==",
      "dev": true
    },
    "has": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/has/-/has-1.0.3.tgz",
      "integrity": "sha512-f2dvO0VU6Oej7RkWJGrehjbzMAjFp5/VKPp5tTpWIV4JHHZK1/BxbFRtf/siA2SWTe09caDmVtYYzWEIbBS4zw==",
      "dev": true,
      "requires": {
        "function-bind": "^1.1.1"
      }
    },
    "has-flag": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
      "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
      "dev": true
    },
    "human-signals": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/human-signals/-/human-signals-2.1.0.tgz",
      "integrity": "sha512-B4FFZ6q/T2jhhksgkbEW3HBvWIfDW85snkQgawt07S7J5QXTk6BkNV+0yAeZrM5QpMAdYlocGoljn0sJ/WQkFw==",
      "dev": true
    },
    "ignore": {
      "version": "4.0.6",
      "resolved": "https://registry.npmjs.org/ignore/-/ignore-4.0.6.tgz",
      "integrity": "sha512-cyFDKrqc/YdcWFniJhzI42+AzS+gNwmUzOSFcRCQYwySuBBBy/KjuxWLZ/FHEH6Moq1NizMOBWyTcv8O4OZIMg==",
      "dev": true
    },
    "import-fresh": {
      "version": "3.3.0",
      "resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.0.tgz",
      "integrity": "sha512-veYYhQa+D1QBKznvhUHxb8faxlrwUnxseDAbAp457E0wLNio2bOSKnjYDhMj+YiAq61xrMGhQk9iXVk5FzgQMw==",
      "dev": true,
      "requires": {
        "parent-module": "^1.0.0",
        "resolve-from": "^4.0.0"
      }
    },
    "import-local": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/import-local/-/import-local-3.0.2.tgz",
      "integrity": "sha512-vjL3+w0oulAVZ0hBHnxa/Nm5TAurf9YLQJDhqRZyqb+VKGOB6LU8t9H1Nr5CIo16vh9XfJTOoHwU0B71S557gA==",
      "dev": true,
      "requires": {
        "pkg-dir": "^4.2.0",
        "resolve-cwd": "^3.0.0"
      }
    },
    "imurmurhash": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz",
      "integrity": "sha1-khi5srkoojixPcT7a21XbyMUU+o=",
      "dev": true
    },
    "inflight": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz",
      "integrity": "sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=",
      "dev": true,
      "requires": {
        "once": "^1.3.0",
        "wrappy": "1"
      }
    },
    "inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
      "dev": true
    },
    "interpret": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/interpret/-/interpret-2.2.0.tgz",
      "integrity": "sha512-Ju0Bz/cEia55xDwUWEa8+olFpCiQoypjnQySseKtmjNrnps3P+xfpUmGr90T7yjlVJmOtybRvPXhKMbHr+fWnw==",
      "dev": true
    },
    "is-core-module": {
      "version": "2.4.0",
      "resolved": "https://registry.npmjs.org/is-core-module/-/is-core-module-2.4.0.tgz",
      "integrity": "sha512-6A2fkfq1rfeQZjxrZJGerpLCTHRNEBiSgnu0+obeJpEPZRUooHgsizvzv0ZjJwOz3iWIHdJtVWJ/tmPr3D21/A==",
      "dev": true,
      "requires": {
        "has": "^1.0.3"
      }
    },
    "is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha1-qIwCU1eR8C7TfHahueqXc8gz+MI=",
      "dev": true
    },
    "is-fullwidth-code-point": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
      "dev": true
    },
    "is-glob": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.1.tgz",
      "integrity": "sha512-5G0tKtBTFImOqDnLB2hG6Bp2qcKEFduo4tZu9MT/H6NQv/ghhy30o55ufafxJ/LdH79LLs2Kfrn85TLKyA7BUg==",
      "dev": true,
      "requires": {
        "is-extglob": "^2.1.1"
      }
    },
    "is-number": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
      "dev": true
    },
    "is-plain-object": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/is-plain-object/-/is-plain-object-2.0.4.tgz",
      "integrity": "sha512-h5PpgXkWitc38BBMYawTYMWJHFZJVnBquFE57xFpjB8pJFiF6gZ+bU+WyI/yqXiFR5mdLsgYNaPe8uao6Uv9Og==",
      "dev": true,
      "requires": {
        "isobject": "^3.0.1"
      }
    },
    "is-stream": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-stream/-/is-stream-2.0.0.tgz",
      "integrity": "sha512-XCoy+WlUr7d1+Z8GgSuXmpuUFC9fOhRXglJMx+dwLKTkL44Cjd4W1Z5P+BQZpr+cR93aGP4S/s7Ftw6Nd/kiEw==",
      "dev": true
    },
    "isexe": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
      "integrity": "sha1-6PvzdNxVb/iUehDcsFctYz8s+hA=",
      "dev": true
    },
    "isobject": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/isobject/-/isobject-3.0.1.tgz",
      "integrity": "sha1-TkMekrEalzFjaqH5yNHMvP2reN8=",
      "dev": true
    },
    "jest-worker": {
      "version": "26.6.2",
      "resolved": "https://registry.npmjs.org/jest-worker/-/jest-worker-26.6.2.tgz",
      "integrity": "sha512-KWYVV1c4i+jbMpaBC+U++4Va0cp8OisU185o73T1vo99hqi7w8tSJfUXYswwqqrjzwxa6KpRK54WhPvwf5w6PQ==",
      "dev": true,
      "requires": {
        "@types/node": "*",
        "merge-stream": "^2.0.0",
        "supports-color": "^7.0.0"
      }
    },
    "js-tokens": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
      "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
      "dev": true
    },
    "js-yaml": {
      "version": "3.14.1",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-3.14.1.tgz",
      "integrity": "sha512-okMH7OXXJ7YrN9Ok3/SXrnu4iX9yOk+25nqX4imS2npuvTYDmo/QEZoqwZkYaIDk3jVvBOTOIEgEhaLOynBS9g==",
      "dev": true,
      "requires": {
        "argparse": "^1.0.7",
        "esprima": "^4.0.0"
      }
    },
    "json-parse-better-errors": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/json-parse-better-errors/-/json-parse-better-errors-1.0.2.tgz",
      "integrity": "sha512-mrqyZKfX5EhL7hvqcV6WG1yYjnjeuYDzDhhcAAUrq8Po85NBQBJP+ZDUT75qZQ98IkUoBqdkExkukOU7Ts2wrw==",
      "dev": true
    },
    "json-schema-traverse": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==",
      "dev": true
    },
    "json-stable-stringify-without-jsonify": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz",
      "integrity": "sha1-nbe1lJatPzz+8wp1FC0tkwrXJlE=",
      "dev": true
    },
    "kind-of": {
      "version": "6.0.3",
      "resolved": "https://registry.npmjs.org/kind-of/-/kind-of-6.0.3.tgz",
      "integrity": "sha512-dcS1ul+9tmeD95T+x28/ehLgd9mENa3LsvDTtzm3vyBEO7RPptvAD+t44WVXaUjTBRcrpFeFlC8WCruUR456hw==",
      "dev": true
    },
    "levn": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/levn/-/levn-0.4.1.tgz",
      "integrity": "sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==",
      "dev": true,
      "requires": {
        "prelude-ls": "^1.2.1",
        "type-check": "~0.4.0"
      }
    },
    "loader-runner": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/loader-runner/-/loader-runner-4.2.0.tgz",
      "integrity": "sha512-92+huvxMvYlMzMt0iIOukcwYBFpkYJdpl2xsZ7LrlayO7E8SOv+JJUEK17B/dJIHAOLMfh2dZZ/Y18WgmGtYNw==",
      "dev": true
    },
    "locate-path": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-5.0.0.tgz",
      "integrity": "sha512-t7hw9pI+WvuwNJXwk5zVHpyhIqzg2qTlklJOf0mVxGSbe3Fp2VieZcduNYjaLDoy6p9uGpQEGWG87WpMKlNq8g==",
      "dev": true,
      "requires": {
        "p-locate": "^4.1.0"
      }
    },
    "lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==",
      "dev": true
    },
    "lodash.clonedeep": {
      "version": "4.5.0",
      "resolved": "https://registry.npmjs.org/lodash.clonedeep/-/lodash.clonedeep-4.5.0.tgz",
      "integrity": "sha1-4j8/nE+Pvd6HJSnBBxhXoIblzO8=",
      "dev": true
    },
    "lodash.merge": {
      "version": "4.6.2",
      "resolved": "https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz",
      "integrity": "sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==",
      "dev": true
    },
    "lodash.truncate": {
      "version": "4.4.2",
      "resolved": "https://registry.npmjs.org/lodash.truncate/-/lodash.truncate-4.4.2.tgz",
      "integrity": "sha1-WjUNoLERO4N+z//VgSy+WNbq4ZM=",
      "dev": true
    },
    "long": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/long/-/long-4.0.0.tgz",
      "integrity": "sha512-XsP+KhQif4bjX1kbuSiySJFNAehNxgLb6hPRGJ9QsUr8ajHkuXGdrHmFUTUUXhDwVX2R5bY4JNZEwbUiMhV+MA=="
    },
    "lru-cache": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz",
      "integrity": "sha512-Jo6dJ04CmSjuznwJSS3pUeWmd/H0ffTlkXXgwZi+eq1UCmqQwCh+eLsYOYCwY991i2Fah4h1BEMCx4qThGbsiA==",
      "dev": true,
      "requires": {
        "yallist": "^4.0.0"
      }
    },
    "make-error": {
      "version": "1.3.6",
      "resolved": "https://registry.npmjs.org/make-error/-/make-error-1.3.6.tgz",
      "integrity": "sha512-s8UhlNe7vPKomQhC1qFelMokr/Sc3AgNbso3n74mVPA5LTZwkB9NlXf4XPamLxJE8h0gh73rM94xvwRT2CVInw=="
    },
    "merge-stream": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/merge-stream/-/merge-stream-2.0.0.tgz",
      "integrity": "sha512-abv/qOcuPfk3URPfDzmZU1LKmuw8kT+0nIHvKrKgFrwifol/doWcdA4ZqsWQ8ENrFKkd67Mfpo/LovbIUsbt3w==",
      "dev": true
    },
    "merge2": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
      "integrity": "sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==",
      "dev": true
    },
    "micromatch": {
      "version": "4.0.4",
      "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.4.tgz",
      "integrity": "sha512-pRmzw/XUcwXGpD9aI9q/0XOwLNygjETJ8y0ao0wdqprrzDa4YnxLcz7fQRZr8voh8V10kGhABbNcHVk5wHgWwg==",
      "dev": true,
      "requires": {
        "braces": "^3.0.1",
        "picomatch": "^2.2.3"
      }
    },
    "mime-db": {
      "version": "1.47.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.47.0.tgz",
      "integrity": "sha512-QBmA/G2y+IfeS4oktet3qRZ+P5kPhCKRXxXnQEudYqUaEioAU1/Lq2us3D/t1Jfo4hE9REQPrbB7K5sOczJVIw==",
      "dev": true
    },
    "mime-types": {
      "version": "2.1.30",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.30.tgz",
      "integrity": "sha512-crmjA4bLtR8m9qLpHvgxSChT+XoSlZi8J4n/aIdn3z92e/U47Z0V/yl+Wh9W046GgFVAmoNR/fmdbZYcSSIUeg==",
      "dev": true,
      "requires": {
        "mime-db": "1.47.0"
      }
    },
    "mimic-fn": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/mimic-fn/-/mimic-fn-2.1.0.tgz",
      "integrity": "sha512-OqbOk5oEQeAZ8WXWydlu9HJjz9WVdEIvamMCcXmuqUYjTknH/sqsWvhQ3vgwKFRR1HpjvNBKQ37nbJgYzGqGcg==",
      "dev": true
    },
    "minimatch": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.0.4.tgz",
      "integrity": "sha512-yJHVQEhyqPLUTgt9B83PXu6W3rx4MvvHvSUvToogpwoGDOUQ+yDrR0HRot+yOCdCO7u4hX3pWft6kWBBcqh0UA==",
      "dev": true,
      "requires": {
        "brace-expansion": "^1.1.7"
      }
    },
    "minimist": {
      "version": "1.2.5",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-1.2.5.tgz",
      "integrity": "sha512-FM9nNUYrRBAELZQT3xeZQ7fmMOBg6nWNmJKTcgsJeaLstP/UODVpGsr5OhXhhXg6f+qtJ8uiZ+PUxkDWcgIXLw=="
    },
    "mkdirp": {
      "version": "0.5.5",
      "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.5.tgz",
      "integrity": "sha512-NKmAlESf6jMGym1++R0Ra7wvhV+wFW63FaSOFPwRahvea0gMUcGUhVeAg/0BC0wiv9ih5NYPB1Wn1UEI1/L+xQ==",
      "requires": {
        "minimist": "^1.2.5"
      }
    },
    "ms": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.2.tgz",
      "integrity": "sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w==",
      "dev": true
    },
    "natural-compare": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz",
      "integrity": "sha1-Sr6/7tdUHywnrPspvbvRXI1bpPc=",
      "dev": true
    },
    "neo-async": {
      "version": "2.6.2",
      "resolved": "https://registry.npmjs.org/neo-async/-/neo-async-2.6.2.tgz",
      "integrity": "sha512-Yd3UES5mWCSqR+qNT93S3UoYUkqAZ9lLg8a7g9rimsWmYGK8cVToA4/sF3RrshdyV3sAGMXVUmpMYOw+dLpOuw==",
      "dev": true
    },
    "node-releases": {
      "version": "1.1.72",
      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-1.1.72.tgz",
      "integrity": "sha512-LLUo+PpH3dU6XizX3iVoubUNheF/owjXCZZ5yACDxNnPtgFuludV1ZL3ayK1kVep42Rmm0+R9/Y60NQbZ2bifw==",
      "dev": true
    },
    "npm-run-path": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/npm-run-path/-/npm-run-path-4.0.1.tgz",
      "integrity": "sha512-S48WzZW777zhNIrn7gxOlISNAqi9ZC/uQFnRdbeIHhZhCA6UqpkOT8T1G7BvfdgP4Er8gF4sUbaS0i7QvIfCWw==",
      "dev": true,
      "requires": {
        "path-key": "^3.0.0"
      }
    },
    "once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
      "integrity": "sha1-WDsap3WWHUsROsF9nFC6753Xa9E=",
      "dev": true,
      "requires": {
        "wrappy": "1"
      }
    },
    "onetime": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/onetime/-/onetime-5.1.2.tgz",
      "integrity": "sha512-kbpaSSGJTWdAY5KPVeMOKXSrPtr8C8C7wodJbcsd51jRnmD+GZu8Y0VoU6Dm5Z4vWr0Ig/1NKuWRKf7j5aaYSg==",
      "dev": true,
      "requires": {
        "mimic-fn": "^2.1.0"
      }
    },
    "optionator": {
      "version": "0.9.1",
      "resolved": "https://registry.npmjs.org/optionator/-/optionator-0.9.1.tgz",
      "integrity": "sha512-74RlY5FCnhq4jRxVUPKDaRwrVNXMqsGsiW6AJw4XK8hmtm10wC0ypZBLw5IIp85NZMr91+qd1RvvENwg7jjRFw==",
      "dev": true,
      "requires": {
        "deep-is": "^0.1.3",
        "fast-levenshtein": "^2.0.6",
        "levn": "^0.4.1",
        "prelude-ls": "^1.2.1",
        "type-check": "^0.4.0",
        "word-wrap": "^1.2.3"
      }
    },
    "p-limit": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-3.1.0.tgz",
      "integrity": "sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==",
      "dev": true,
      "requires": {
        "yocto-queue": "^0.1.0"
      }
    },
    "p-locate": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-4.1.0.tgz",
      "integrity": "sha512-R79ZZ/0wAxKGu3oYMlz8jy/kbhsNrS7SKZ7PxEHBgJ5+F2mtFW2fK2cOtBh1cHYkQsbzFV7I+EoRKe6Yt0oK7A==",
      "dev": true,
      "requires": {
        "p-limit": "^2.2.0"
      },
      "dependencies": {
        "p-limit": {
          "version": "2.3.0",
          "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-2.3.0.tgz",
          "integrity": "sha512-//88mFWSJx8lxCzwdAABTJL2MyWB12+eIY7MDL2SqLmAkeKU9qxRvWuSyTjm3FUmpBEMuFfckAIqEaVGUDxb6w==",
          "dev": true,
          "requires": {
            "p-try": "^2.0.0"
          }
        }
      }
    },
    "p-try": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/p-try/-/p-try-2.2.0.tgz",
      "integrity": "sha512-R4nPAVTAU0B9D35/Gk3uJf/7XYbQcyohSKdvAxIRSNghFl4e71hVoGnBNQz9cWaXxO2I10KTC+3jMdvvoKw6dQ==",
      "dev": true
    },
    "parent-module": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
      "integrity": "sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==",
      "dev": true,
      "requires": {
        "callsites": "^3.0.0"
      }
    },
    "path-exists": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz",
      "integrity": "sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==",
      "dev": true
    },
    "path-is-absolute": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz",
      "integrity": "sha1-F0uSaHNVNP+8es5r9TpanhtcX18=",
      "dev": true
    },
    "path-key": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
      "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
      "dev": true
    },
    "path-parse": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz",
      "integrity": "sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==",
      "dev": true
    },
    "path-type": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/path-type/-/path-type-4.0.0.tgz",
      "integrity": "sha512-gDKb8aZMDeD/tZWs9P6+q0J9Mwkdl6xMV8TjnGP3qJVJ06bdMgkbBlLU8IdfOsIsFz2BW1rNVT3XuNEl8zPAvw==",
      "dev": true
    },
    "physical-cpu-count": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/physical-cpu-count/-/physical-cpu-count-2.0.0.tgz",
      "integrity": "sha1-GN4vl+S/epVRrXURlCtUlverpmA=",
      "dev": true
    },
    "picomatch": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.0.tgz",
      "integrity": "sha512-lY1Q/PiJGC2zOv/z391WOTD+Z02bCgsFfvxoXXf6h7kv9o+WmsmzYqrAwY63sNgOxE4xEdq0WyUnXfKeBrSvYw==",
      "dev": true
    },
    "pkg-dir": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/pkg-dir/-/pkg-dir-4.2.0.tgz",
      "integrity": "sha512-HRDzbaKjC+AOWVXxAU/x54COGeIv9eb+6CkDSQoNTt4XyWoIJvuPsXizxu/Fr23EiekbtZwmh1IcIG/l/a10GQ==",
      "dev": true,
      "requires": {
        "find-up": "^4.0.0"
      }
    },
    "prelude-ls": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz",
      "integrity": "sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==",
      "dev": true
    },
    "progress": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/progress/-/progress-2.0.3.tgz",
      "integrity": "sha512-7PiHtLll5LdnKIMw100I+8xJXR5gW2QwWYkT6iJva0bXitZKa/XMrSbdmg3r2Xnaidz9Qumd0VPaMrZlF9V9sA==",
      "dev": true
    },
    "punycode": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.1.1.tgz",
      "integrity": "sha512-XRsRjdf+j5ml+y/6GKHPZbrF/8p2Yga0JPtdqTIY2Xe5ohJPD9saDJJLPvp9+NSBprVvevdXZybnj2cv8OEd0A==",
      "dev": true
    },
    "queue-microtask": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/queue-microtask/-/queue-microtask-1.2.3.tgz",
      "integrity": "sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==",
      "dev": true
    },
    "randombytes": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/randombytes/-/randombytes-2.1.0.tgz",
      "integrity": "sha512-vYl3iOX+4CKUWuxGi9Ukhie6fsqXqS9FE2Zaic4tNFD2N2QQaXOMFbuKK4QmDHC0JO6B1Zp41J0LpT0oR68amQ==",
      "dev": true,
      "requires": {
        "safe-buffer": "^5.1.0"
      }
    },
    "rechoir": {
      "version": "0.7.0",
      "resolved": "https://registry.npmjs.org/rechoir/-/rechoir-0.7.0.tgz",
      "integrity": "sha512-ADsDEH2bvbjltXEP+hTIAmeFekTFK0V2BTxMkok6qILyAJEXV0AFfoWcAq4yfll5VdIMd/RVXq0lR+wQi5ZU3Q==",
      "dev": true,
      "requires": {
        "resolve": "^1.9.0"
      }
    },
    "regexpp": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/regexpp/-/regexpp-3.1.0.tgz",
      "integrity": "sha512-ZOIzd8yVsQQA7j8GCSlPGXwg5PfmA1mrq0JP4nGhh54LaKN3xdai/vHUDu74pKwV8OxseMS65u2NImosQcSD0Q==",
      "dev": true
    },
    "require-from-string": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/require-from-string/-/require-from-string-2.0.2.tgz",
      "integrity": "sha512-Xf0nWe6RseziFMu+Ap9biiUbmplq6S9/p+7w7YXP/JBHhrUDDUhwa+vANyubuqfZWTveU//DYVGsDG7RKL/vEw==",
      "dev": true
    },
    "resolve": {
      "version": "1.20.0",
      "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.20.0.tgz",
      "integrity": "sha512-wENBPt4ySzg4ybFQW2TT1zMQucPK95HSh/nq2CFTZVOGut2+pQvSsgtda4d26YrYcr067wjbmzOG8byDPBX63A==",
      "dev": true,
      "requires": {
        "is-core-module": "^2.2.0",
        "path-parse": "^1.0.6"
      }
    },
    "resolve-cwd": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/resolve-cwd/-/resolve-cwd-3.0.0.tgz",
      "integrity": "sha512-OrZaX2Mb+rJCpH/6CpSqt9xFVpN++x01XnN2ie9g6P5/3xelLAkXWVADpdz1IHD/KFfEXyE6V0U01OQ3UO2rEg==",
      "dev": true,
      "requires": {
        "resolve-from": "^5.0.0"
      },
      "dependencies": {
        "resolve-from": {
          "version": "5.0.0",
          "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-5.0.0.tgz",
          "integrity": "sha512-qYg9KP24dD5qka9J47d0aVky0N+b4fTU89LN9iDnjB5waksiC49rvMB0PrUJQGoTmH50XPiqOvAjDfaijGxYZw==",
          "dev": true
        }
      }
    },
    "resolve-from": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz",
      "integrity": "sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==",
      "dev": true
    },
    "reusify": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/reusify/-/reusify-1.0.4.tgz",
      "integrity": "sha512-U9nH88a3fc/ekCF1l0/UP1IosiuIjyTh7hBvXVMHYgVcfGvt897Xguj2UOLDeI5BG2m7/uwyaLVT6fbtCwTyzw==",
      "dev": true
    },
    "rimraf": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-3.0.2.tgz",
      "integrity": "sha512-JZkJMZkAGFFPP2YqXZXPbMlMBgsxzE8ILs4lMIX/2o0L9UBw9O/Y3o6wFw/i9YLapcUJWwqbi3kdxIPdC62TIA==",
      "dev": true,
      "requires": {
        "glob": "^7.1.3"
      }
    },
    "run-parallel": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/run-parallel/-/run-parallel-1.2.0.tgz",
      "integrity": "sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==",
      "dev": true,
      "requires": {
        "queue-microtask": "^1.2.2"
      }
    },
    "safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "dev": true
    },
    "schema-utils": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/schema-utils/-/schema-utils-3.0.0.tgz",
      "integrity": "sha512-6D82/xSzO094ajanoOSbe4YvXWMfn2A//8Y1+MUqFAJul5Bs+yn36xbK9OtNDcRVSBJ9jjeoXftM6CfztsjOAA==",
      "dev": true,
      "requires": {
        "@types/json-schema": "^7.0.6",
        "ajv": "^6.12.5",
        "ajv-keywords": "^3.5.2"
      }
    },
    "semver": {
      "version": "7.3.5",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.3.5.tgz",
      "integrity": "sha512-PoeGJYh8HK4BTO/a9Tf6ZG3veo/A7ZVsYrSA6J8ny9nb3B1VrpkuN+z9OE5wfE5p6H4LchYZsegiQgbJD94ZFQ==",
      "dev": true,
      "requires": {
        "lru-cache": "^6.0.0"
      }
    },
    "serialize-javascript": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/serialize-javascript/-/serialize-javascript-5.0.1.tgz",
      "integrity": "sha512-SaaNal9imEO737H2c05Og0/8LUXG7EnsZyMa8MzkmuHoELfT6txuj0cMqRj6zfPKnmQ1yasR4PCJc8x+M4JSPA==",
      "dev": true,
      "requires": {
        "randombytes": "^2.1.0"
      }
    },
    "shallow-clone": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/shallow-clone/-/shallow-clone-3.0.1.tgz",
      "integrity": "sha512-/6KqX+GVUdqPuPPd2LxDDxzX6CAbjJehAAOKlNpqqUpAqPM6HeL8f+o3a+JsyGjn2lv0WY8UsTgUJjU9Ok55NA==",
      "dev": true,
      "requires": {
        "kind-of": "^6.0.2"
      }
    },
    "shebang-command": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
      "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
      "dev": true,
      "requires": {
        "shebang-regex": "^3.0.0"
      }
    },
    "shebang-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
      "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
      "dev": true
    },
    "signal-exit": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-3.0.3.tgz",
      "integrity": "sha512-VUJ49FC8U1OxwZLxIbTTrDvLnf/6TDgxZcK8wxR8zs13xpx7xbG60ndBlhNrFi2EMuFRoeDoJO7wthSLq42EjA==",
      "dev": true
    },
    "slash": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/slash/-/slash-3.0.0.tgz",
      "integrity": "sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==",
      "dev": true
    },
    "slice-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/slice-ansi/-/slice-ansi-4.0.0.tgz",
      "integrity": "sha512-qMCMfhY040cVHT43K9BFygqYbUPFZKHOg7K73mtTWJRb8pyP3fzf4Ixd5SzdEJQ6MRUg/WBnOLxghZtKKurENQ==",
      "dev": true,
      "requires": {
        "ansi-styles": "^4.0.0",
        "astral-regex": "^2.0.0",
        "is-fullwidth-code-point": "^3.0.0"
      }
    },
    "source-list-map": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/source-list-map/-/source-list-map-2.0.1.tgz",
      "integrity": "sha512-qnQ7gVMxGNxsiL4lEuJwe/To8UnK7fAnmbGEEH8RpLouuKbeEm0lhbQVFIrNSuB+G7tVrAlVsZgETT5nljf+Iw==",
      "dev": true
    },
    "source-map": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
      "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g=="
    },
    "source-map-support": {
      "version": "0.5.19",
      "resolved": "https://registry.npmjs.org/source-map-support/-/source-map-support-0.5.19.tgz",
      "integrity": "sha512-Wonm7zOCIJzBGQdB+thsPar0kYuCIzYvxZwlBa87yi/Mdjv7Tip2cyVbLj5o0cFPN4EVkuTwb3GDDyUx2DGnGw==",
      "requires": {
        "buffer-from": "^1.0.0",
        "source-map": "^0.6.0"
      }
    },
    "sprintf-js": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/sprintf-js/-/sprintf-js-1.0.3.tgz",
      "integrity": "sha1-BOaSb2YolTVPPdAVIDYzuFcpfiw=",
      "dev": true
    },
    "string-width": {
      "version": "4.2.2",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.2.tgz",
      "integrity": "sha512-XBJbT3N4JhVumXE0eoLU9DCjcaF92KLNqTmFCnG1pf8duUxFGwtP6AD6nkjw9a3IdiRtL3E2w3JDiE/xi3vOeA==",
      "dev": true,
      "requires": {
        "emoji-regex": "^8.0.0",
        "is-fullwidth-code-point": "^3.0.0",
        "strip-ansi": "^6.0.0"
      }
    },
    "strip-ansi": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.0.tgz",
      "integrity": "sha512-AuvKTrTfQNYNIctbR1K/YGTR1756GycPsg7b9bdV9Duqur4gv6aKqHXah67Z8ImS7WEz5QVcOtlfW2rZEugt6w==",
      "dev": true,
      "requires": {
        "ansi-regex": "^5.0.0"
      }
    },
    "strip-final-newline": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/strip-final-newline/-/strip-final-newline-2.0.0.tgz",
      "integrity": "sha512-BrpvfNAE3dcvq7ll3xVumzjKjZQ5tI1sEUIKr3Uoks0XUl45St3FlatVqef9prk4jRDzhW6WZg+3bk93y6pLjA==",
      "dev": true
    },
    "strip-json-comments": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
      "integrity": "sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==",
      "dev": true
    },
    "supports-color": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
      "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
      "dev": true,
      "requires": {
        "has-flag": "^4.0.0"
      }
    },
    "table": {
      "version": "6.7.1",
      "resolved": "https://registry.npmjs.org/table/-/table-6.7.1.tgz",
      "integrity": "sha512-ZGum47Yi6KOOFDE8m223td53ath2enHcYLgOCjGr5ngu8bdIARQk6mN/wRMv4yMRcHnCSnHbCEha4sobQx5yWg==",
      "dev": true,
      "requires": {
        "ajv": "^8.0.1",
        "lodash.clonedeep": "^4.5.0",
        "lodash.truncate": "^4.4.2",
        "slice-ansi": "^4.0.0",
        "string-width": "^4.2.0",
        "strip-ansi": "^6.0.0"
      },
      "dependencies": {
        "ajv": {
          "version": "8.5.0",
          "resolved": "https://registry.npmjs.org/ajv/-/ajv-8.5.0.tgz",
          "integrity": "sha512-Y2l399Tt1AguU3BPRP9Fn4eN+Or+StUGWCUpbnFyXSo8NZ9S4uj+AG2pjs5apK+ZMOwYOz1+a+VKvKH7CudXgQ==",
          "dev": true,
          "requires": {
            "fast-deep-equal": "^3.1.1",
            "json-schema-traverse": "^1.0.0",
            "require-from-string": "^2.0.2",
            "uri-js": "^4.2.2"
          }
        },
        "json-schema-traverse": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-1.0.0.tgz",
          "integrity": "sha512-NM8/P9n3XjXhIZn1lLhkFaACTOURQXjWhV4BA/RnOv8xvgqtqpAX9IO4mRQxSx1Rlo4tqzeqb0sOlruaOy3dug==",
          "dev": true
        }
      }
    },
    "tapable": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/tapable/-/tapable-2.2.0.tgz",
      "integrity": "sha512-FBk4IesMV1rBxX2tfiK8RAmogtWn53puLOQlvO8XuwlgxcYbP4mVPS9Ph4aeamSyyVjOl24aYWAuc8U5kCVwMw==",
      "dev": true
    },
    "terser": {
      "version": "5.7.0",
      "resolved": "https://registry.npmjs.org/terser/-/terser-5.7.0.tgz",
      "integrity": "sha512-HP5/9hp2UaZt5fYkuhNBR8YyRcT8juw8+uFbAme53iN9hblvKnLUTKkmwJG6ocWpIKf8UK4DoeWG4ty0J6S6/g==",
      "dev": true,
      "requires": {
        "commander": "^2.20.0",
        "source-map": "~0.7.2",
        "source-map-support": "~0.5.19"
      },
      "dependencies": {
        "source-map": {
          "version": "0.7.3",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.7.3.tgz",
          "integrity": "sha512-CkCj6giN3S+n9qrYiBTX5gystlENnRW5jZeNLHpe6aue+SrHcG5VYwujhW9s4dY31mEGsxBDrHR6oI69fTXsaQ==",
          "dev": true
        }
      }
    },
    "terser-webpack-plugin": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/terser-webpack-plugin/-/terser-webpack-plugin-5.1.2.tgz",
      "integrity": "sha512-6QhDaAiVHIQr5Ab3XUWZyDmrIPCHMiqJVljMF91YKyqwKkL5QHnYMkrMBy96v9Z7ev1hGhSEw1HQZc2p/s5Z8Q==",
      "dev": true,
      "requires": {
        "jest-worker": "^26.6.2",
        "p-limit": "^3.1.0",
        "schema-utils": "^3.0.0",
        "serialize-javascript": "^5.0.1",
        "source-map": "^0.6.1",
        "terser": "^5.7.0"
      }
    },
    "text-table": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
      "integrity": "sha1-f17oI66AUgfACvLfSoTsP8+lcLQ=",
      "dev": true
    },
    "to-regex-range": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
      "dev": true,
      "requires": {
        "is-number": "^7.0.0"
      }
    },
    "ts-loader": {
      "version": "9.2.2",
      "resolved": "https://registry.npmjs.org/ts-loader/-/ts-loader-9.2.2.tgz",
      "integrity": "sha512-hNIhGTQHtNKjOzR2ZtQ2OSVbXPykOae+zostf1IlHCf61Mt41GMJurKNqrYUbzHgpmj6UWRu8eBfb7q0XliV0g==",
      "dev": true,
      "requires": {
        "chalk": "^4.1.0",
        "enhanced-resolve": "^5.0.0",
        "micromatch": "^4.0.0",
        "semver": "^7.3.4"
      }
    },
    "ts-node": {
      "version": "6.2.0",
      "resolved": "https://registry.npmjs.org/ts-node/-/ts-node-6.2.0.tgz",
      "integrity": "sha512-ZNT+OEGfUNVMGkpIaDJJ44Zq3Yr0bkU/ugN1PHbU+/01Z7UV1fsELRiTx1KuQNvQ1A3pGh3y25iYF6jXgxV21A==",
      "requires": {
        "arrify": "^1.0.0",
        "buffer-from": "^1.1.0",
        "diff": "^3.1.0",
        "make-error": "^1.1.1",
        "minimist": "^1.2.0",
        "mkdirp": "^0.5.1",
        "source-map-support": "^0.5.6",
        "yn": "^2.0.0"
      },
      "dependencies": {
        "diff": {
          "version": "3.5.0",
          "resolved": "https://registry.npmjs.org/diff/-/diff-3.5.0.tgz",
          "integrity": "sha512-A46qtFgd+g7pDZinpnwiRJtxbC1hpgf0uzP3iG89scHk0AUC7A1TGxf5OiiOUv/JMZR8GOt8hL900hV0bOy5xA=="
        }
      }
    },
    "tslib": {
      "version": "1.14.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-1.14.1.tgz",
      "integrity": "sha512-Xni35NKzjgMrwevysHTCArtLDpPvye8zV/0E4EyYn43P7/7qvQwPh9BGkHewbMulVntbigmcT7rdX3BNo9wRJg==",
      "dev": true
    },
    "tsutils": {
      "version": "3.21.0",
      "resolved": "https://registry.npmjs.org/tsutils/-/tsutils-3.21.0.tgz",
      "integrity": "sha512-mHKK3iUXL+3UF6xL5k0PEhKRUBKPBCv/+RkEOpjRWxxx27KKRBmmA60A9pgOUvMi8GKhRMPEmjBRPzs2W7O1OA==",
      "dev": true,
      "requires": {
        "tslib": "^1.8.1"
      }
    },
    "type-check": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz",
      "integrity": "sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==",
      "dev": true,
      "requires": {
        "prelude-ls": "^1.2.1"
      }
    },
    "type-fest": {
      "version": "0.20.2",
      "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-0.20.2.tgz",
      "integrity": "sha512-Ne+eE4r0/iWnpAxD852z3A+N0Bt5RN//NjJwRd2VFHEmrywxf5vsZlh4R6lixl6B+wz/8d+maTSAkN1FIkI3LQ==",
      "dev": true
    },
    "typescript": {
      "version": "4.2.4",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-4.2.4.tgz",
      "integrity": "sha512-V+evlYHZnQkaz8TRBuxTA92yZBPotr5H+WhQ7bD3hZUndx5tGOa1fuCgeSjxAzM1RiN5IzvadIXTVefuuwZCRg==",
      "dev": true
    },
    "uri-js": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz",
      "integrity": "sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==",
      "dev": true,
      "requires": {
        "punycode": "^2.1.0"
      }
    },
    "v8-compile-cache": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/v8-compile-cache/-/v8-compile-cache-2.3.0.tgz",
      "integrity": "sha512-l8lCEmLcLYZh4nbunNZvQCJc5pv7+RCwa8q/LdUx8u7lsWvPDKmpodJAJNwkAhJC//dFY48KuIEmjtd4RViDrA==",
      "dev": true
    },
    "watchpack": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/watchpack/-/watchpack-2.2.0.tgz",
      "integrity": "sha512-up4YAn/XHgZHIxFBVCdlMiWDj6WaLKpwVeGQk2I5thdYxF/KmF0aaz6TfJZ/hfl1h/XlcDr7k1KH7ThDagpFaA==",
      "dev": true,
      "requires": {
        "glob-to-regexp": "^0.4.1",
        "graceful-fs": "^4.1.2"
      }
    },
    "webpack": {
      "version": "5.37.1",
      "resolved": "https://registry.npmjs.org/webpack/-/webpack-5.37.1.tgz",
      "integrity": "sha512-btZjGy/hSjCAAVHw+cKG+L0M+rstlyxbO2C+BOTaQ5/XAnxkDrP5sVbqWhXgo4pL3X2dcOib6rqCP20Zr9PLow==",
      "dev": true,
      "requires": {
        "@types/eslint-scope": "^3.7.0",
        "@types/estree": "^0.0.47",
        "@webassemblyjs/ast": "1.11.0",
        "@webassemblyjs/wasm-edit": "1.11.0",
        "@webassemblyjs/wasm-parser": "1.11.0",
        "acorn": "^8.2.1",
        "browserslist": "^4.14.5",
        "chrome-trace-event": "^1.0.2",
        "enhanced-resolve": "^5.8.0",
        "es-module-lexer": "^0.4.0",
        "eslint-scope": "^5.1.1",
        "events": "^3.2.0",
        "glob-to-regexp": "^0.4.1",
        "graceful-fs": "^4.2.4",
        "json-parse-better-errors": "^1.0.2",
        "loader-runner": "^4.2.0",
        "mime-types": "^2.1.27",
        "neo-async": "^2.6.2",
        "schema-utils": "^3.0.0",
        "tapable": "^2.1.1",
        "terser-webpack-plugin": "^5.1.1",
        "watchpack": "^2.0.0",
        "webpack-sources": "^2.1.1"
      },
      "dependencies": {
        "acorn": {
          "version": "8.2.4",
          "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.2.4.tgz",
          "integrity": "sha512-Ibt84YwBDDA890eDiDCEqcbwvHlBvzzDkU2cGBBDDI1QWT12jTiXIOn2CIw5KK4i6N5Z2HUxwYjzriDyqaqqZg==",
          "dev": true
        }
      }
    },
    "webpack-cli": {
      "version": "4.7.0",
      "resolved": "https://registry.npmjs.org/webpack-cli/-/webpack-cli-4.7.0.tgz",
      "integrity": "sha512-7bKr9182/sGfjFm+xdZSwgQuFjgEcy0iCTIBxRUeteJ2Kr8/Wz0qNJX+jw60LU36jApt4nmMkep6+W5AKhok6g==",
      "dev": true,
      "requires": {
        "@discoveryjs/json-ext": "^0.5.0",
        "@webpack-cli/configtest": "^1.0.3",
        "@webpack-cli/info": "^1.2.4",
        "@webpack-cli/serve": "^1.4.0",
        "colorette": "^1.2.1",
        "commander": "^7.0.0",
        "execa": "^5.0.0",
        "fastest-levenshtein": "^1.0.12",
        "import-local": "^3.0.2",
        "interpret": "^2.2.0",
        "rechoir": "^0.7.0",
        "v8-compile-cache": "^2.2.0",
        "webpack-merge": "^5.7.3"
      },
      "dependencies": {
        "commander": {
          "version": "7.2.0",
          "resolved": "https://registry.npmjs.org/commander/-/commander-7.2.0.tgz",
          "integrity": "sha512-QrWXB+ZQSVPmIWIhtEO9H+gwHaMGYiF5ChvoJ+K9ZGHG/sVsa6yiesAD1GC/x46sET00Xlwo1u49RVVVzvcSkw==",
          "dev": true
        }
      }
    },
    "webpack-merge": {
      "version": "5.7.3",
      "resolved": "https://registry.npmjs.org/webpack-merge/-/webpack-merge-5.7.3.tgz",
      "integrity": "sha512-6/JUQv0ELQ1igjGDzHkXbVDRxkfA57Zw7PfiupdLFJYrgFqY5ZP8xxbpp2lU3EPwYx89ht5Z/aDkD40hFCm5AA==",
      "dev": true,
      "requires": {
        "clone-deep": "^4.0.1",
        "wildcard": "^2.0.0"
      }
    },
    "webpack-sources": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/webpack-sources/-/webpack-sources-2.2.0.tgz",
      "integrity": "sha512-bQsA24JLwcnWGArOKUxYKhX3Mz/nK1Xf6hxullKERyktjNMC4x8koOeaDNTA2fEJ09BdWLbM/iTW0ithREUP0w==",
      "dev": true,
      "requires": {
        "source-list-map": "^2.0.1",
        "source-map": "^0.6.1"
      }
    },
    "which": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
      "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
      "dev": true,
      "requires": {
        "isexe": "^2.0.0"
      }
    },
    "wildcard": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/wildcard/-/wildcard-2.0.0.tgz",
      "integrity": "sha512-JcKqAHLPxcdb9KM49dufGXn2x3ssnfjbcaQdLlfZsL9rH9wgDQjUtDxbo8NE0F6SFvydeu1VhZe7hZuHsB2/pw==",
      "dev": true
    },
    "word-wrap": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.3.tgz",
      "integrity": "sha512-Hz/mrNwitNRh/HUAtM/VT/5VH+ygD6DV7mYKZAtHOrbs8U7lvPS6xf7EJKMF0uW1KJCl0H701g3ZGus+muE5vQ==",
      "dev": true
    },
    "wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha1-tSQ9jz7BqjXxNkYFvA0QNuMKtp8=",
      "dev": true
    },
    "yallist": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-4.0.0.tgz",
      "integrity": "sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A==",
      "dev": true
    },
    "yn": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/yn/-/yn-2.0.0.tgz",
      "integrity": "sha1-5a2ryKz0CPY4X8dklWhMiOavaJo="
    },
    "yocto-queue": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/yocto-queue/-/yocto-queue-0.1.0.tgz",
      "integrity": "sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==",
      "dev": true
    }
  }
}

'''
'''--- package.json ---
{
  "name": "assemblyscript",
  "description": "Definitely not a TypeScript to WebAssembly compiler.",
  "keywords": [
    "typescript",
    "webassembly",
    "compiler",
    "assemblyscript",
    "wasm"
  ],
  "version": "0.0.0",
  "author": "Daniel Wirtz <dcode+assemblyscript@dcode.io>",
  "contributors": [],
  "license": "Apache-2.0",
  "homepage": "https://assemblyscript.org",
  "repository": {
    "type": "git",
    "url": "https://github.com/AssemblyScript/assemblyscript.git"
  },
  "bugs": {
    "url": "https://github.com/AssemblyScript/assemblyscript/issues"
  },
  "dependencies": {
    "binaryen": "101.0.0-nightly.20210723",
    "long": "^4.0.0",
    "source-map-support": "^0.5.19",
    "ts-node": "^6.2.0"
  },
  "devDependencies": {
    "@types/node": "^15.6.1",
    "@typescript-eslint/eslint-plugin": "^4.9.1",
    "@typescript-eslint/parser": "^4.9.1",
    "diff": "^5.0.0",
    "eslint": "^7.15.0",
    "glob": "^7.1.6",
    "physical-cpu-count": "^2.0.0",
    "source-map-support": "^0.5.19",
    "ts-loader": "^9.2.2",
    "ts-node": "^6.2.0",
    "typescript": "~4.2.4",
    "webpack": "^5.10.0",
    "webpack-cli": "^4.2.0"
  },
  "type": "commonjs",
  "main": "index.js",
  "types": "index.d.ts",
  "exports": {
    ".": "./index.js",
    "./std/portable": "./std/portable/index.js",
    "./lib/loader": {
      "import": "./lib/loader/index.js",
      "require": "./lib/loader/umd/index.js"
    },
    "./lib/rtrace": {
      "import": "./lib/rtrace/index.js",
      "require": "./lib/rtrace/umd/index.js"
    },
    "./*": "./*.js",
    "./cli/asc": "./cli/asc.js",
    "./cli/transform": "./cli/transform.js",
    "./cli/util/options": "./cli/util/options.js",
    "./dist/assemblyscript": "./dist/assemblyscript.js",
    "./dist/asc": "./dist/asc.js"
  },
  "bin": {
    "asc": "bin/asc",
    "asinit": "bin/asinit"
  },
  "scripts": {
    "build": "npm run build:bundle && npm run build:dts && npm run build:sdk",
    "build:bundle": "webpack --config webpack.config.js",
    "build:dts": "node scripts/build-dts && tsc --noEmit --target ESNEXT --module commonjs --experimentalDecorators tests/require/index-release",
    "build:sdk": "node scripts/build-sdk",
    "clean": "node scripts/clean",
    "check": "npm run check:config && npm run check:require && npm run check:lint",
    "check:config": "tsc --noEmit -p src --diagnostics --listFiles",
    "check:require": "tsc --noEmit --target ESNEXT --module commonjs --experimentalDecorators tests/require/index",
    "check:lint": "eslint --max-warnings 0 --ext js . && eslint --max-warnings 0 --ext ts .",
    "test": "npm run test:parser && npm run test:compiler && npm run test:packages && npm run test:extension && npm run test:asconfig",
    "test:parser": "node tests/parser",
    "test:compiler": "node --experimental-wasi-unstable-preview1 tests/compiler",
    "test:packages": "cd tests/packages && npm run test",
    "test:extension": "cd tests/extension && npm run test",
    "test:asconfig": "cd tests/asconfig && npm run test",
    "make": "npm run clean && npm test && npm run build && npm test",
    "all": "npm run check && npm run make",
    "docs": "typedoc --tsconfig tsconfig-docs.json --mode modules --name \"AssemblyScript Compiler API\" --out ./docs/api --ignoreCompilerErrors --excludeNotExported --excludePrivate --excludeExternals --exclude **/std/** --includeDeclarations --readme src/README.md",
    "prepublishOnly": "node scripts/prepublish",
    "postpublish": "node scripts/postpublish",
    "asbuild": "npm run asbuild:untouched && npm run asbuild:optimized",
    "asbuild:untouched": "node bin/asc --config src/asconfig.json --target untouched",
    "asbuild:optimized": "node bin/asc --config src/asconfig.json --target optimized",
    "asbuild:rtraced": "node bin/asc --config src/asconfig.json --target rtraced",
    "bootstrap": "npm run bootstrap:untouched && npm run bootstrap:optimized",
    "bootstrap:untouched": "node bin/asc --config src/asconfig.json --target untouched && node bin/asc --config src/asconfig.json --target untouched-bootstrap --wasm out/assemblyscript.untouched.wasm && node bin/asc --config src/asconfig.json --target untouched-bootstrap --wasm out/assemblyscript.untouched-bootstrap.wasm && git --no-pager diff --no-index out/assemblyscript.untouched.wast out/assemblyscript.untouched-bootstrap.wast",
    "bootstrap:optimized": "node bin/asc --config src/asconfig.json --target optimized && node bin/asc --config src/asconfig.json --target optimized-bootstrap --wasm out/assemblyscript.optimized.wasm && node bin/asc --config src/asconfig.json --target optimized-bootstrap --wasm out/assemblyscript.optimized-bootstrap.wasm && git --no-pager diff --no-index out/assemblyscript.optimized.wast out/assemblyscript.optimized-bootstrap.wast",
    "bootstrap:rtraced": "node bin/asc --config src/asconfig.json --target rtraced && node bin/asc --config src/asconfig.json --target rtraced --wasm out/assemblyscript.rtraced.wasm",
    "astest": "ts-node tests/bootstrap"
  },
  "releaseFiles": [
    "lib/loader/index.d.ts",
    "lib/loader/index.js",
    "lib/loader/package.json",
    "lib/loader/umd/index.d.ts",
    "lib/loader/umd/index.js",
    "lib/loader/umd/package.json",
    "lib/loader/README.md",
    "lib/rtrace/index.d.ts",
    "lib/rtrace/index.js",
    "lib/rtrace/package.json",
    "lib/rtrace/umd/index.d.ts",
    "lib/rtrace/umd/index.js",
    "lib/rtrace/umd/package.json",
    "lib/rtrace/README.md",
    "bin/",
    "cli/",
    "dist/",
    "index.d.ts",
    "index.js",
    "LICENSE",
    "NOTICE",
    "package.json",
    "package-lock.json",
    "README.md",
    "std/",
    "tsconfig-base.json"
  ],
  "funding": {
    "type": "opencollective",
    "url": "https://opencollective.com/assemblyscript"
  }
}

'''
'''--- scripts/build-diagnostics.js ---
var fs = require("fs");

var messages = require(__dirname + "/../src/diagnosticMessages.json");

var header = `/**
 * @fileoverview Generated from diagnosticsMessages.json. Do not edit.
 * @license Apache-2.0
 */

`.replace(/\r\n/g, "\n");

var sb = [ header ];

function makeKey(text) {
  return text.replace(/[^\w]+/g, "_").replace(/_+$/, "");
}

sb.push("/** Enum of available diagnostic codes. */\n");
sb.push("export enum DiagnosticCode {\n");

var first = true;
Object.keys(messages).forEach(text => {
  var key = makeKey(text);
  if (first)
    first = false;
  else {
    sb.push(",\n");
  }
  sb.push("  " + key + " = " + messages[text]);
});

sb.push("\n}\n\n");
sb.push("/** Translates a diagnostic code to its respective string. */\n");
sb.push("export function diagnosticCodeToString(code: DiagnosticCode): string {\n  switch (code) {\n");

Object.keys(messages).forEach(text => {
  sb.push("    case " + messages[text] + ": return " + JSON.stringify(text) + ";\n");
});

sb.push("    default: return \"\";\n  }\n}\n");

fs.writeFileSync(__dirname + "/../src/diagnosticMessages.generated.ts", sb.join(""), { encoding: "utf8" });

'''
'''--- scripts/build-dts.js ---
// Â© 2015-2019 SitePen, Inc. New BSD License.
// see: https://github.com/SitePen/dts-generator
(function() {
  const fs = require("fs");
  const glob = require("glob");
  const mkdirp = require("mkdirp");
  const os = require("os");
  const pathUtil = require("path");
  const ts = require("typescript");

  // declare some constants so we don't have magic integers without explanation
  const DTSLEN = '.d.ts'.length;
  const filenameToMid = (function () {
    if (pathUtil.sep === '/') {
      return function (filename) {
        return filename;
      };
    }
    else {
      const separatorExpression = new RegExp(pathUtil.sep.replace('\\', '\\\\'), 'g');
      return function (filename) {
        return filename.replace(separatorExpression, '/');
      };
    }
  })();

  /**
   * A helper function that takes TypeScript diagnostic errors and returns an error
   * object.
   * @param diagnostics The array of TypeScript Diagnostic objects
   */
  function getError(diagnostics) {
    let message = 'Declaration generation failed';
    diagnostics.forEach(function (diagnostic) {
      // not all errors have an associated file: in particular, problems with a
      // the tsconfig.json don't; the messageText is enough to diagnose in those
      // cases.
      if (diagnostic.file) {
        const position = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);
        message +=
          `\n${diagnostic.file.fileName}(${position.line + 1},${position.character + 1}): ` +
          `error TS${diagnostic.code}: ${diagnostic.messageText}`;
      }
      else {
        message += `\nerror TS${diagnostic.code}: ${diagnostic.messageText}`;
      }
    });
    const error = new Error(message);
    error.name = 'EmitterError';
    return error;
  }
  function getFilenames(baseDir, files) {
    return files.map(function (filename) {
      const resolvedFilename = pathUtil.resolve(filename);
      if (resolvedFilename.indexOf(baseDir) === 0) {
        return resolvedFilename;
      }
      return pathUtil.resolve(baseDir, filename);
    });
  }
  function processTree(sourceFile, replacer) {
    let code = '';
    let cursorPosition = 0;
    function skip(node) {
      cursorPosition = node.end;
    }
    function readThrough(node) {
      code += sourceFile.text.slice(cursorPosition, node.pos);
      cursorPosition = node.pos;
    }
    function visit(node) {
      readThrough(node);
      const replacement = replacer(node);
      if (replacement != null) {
        code += replacement;
        skip(node);
      }
      else {
        ts.forEachChild(node, visit);
      }
    }
    visit(sourceFile);
    code += sourceFile.text.slice(cursorPosition);
    return code;
  }
  /**
   * Load and parse a TSConfig File
   * @param options The dts-generator options to load config into
   * @param fileName The path to the file
   */
  function getTSConfig(fileName) {
    // TODO this needs a better design than merging stuff into options.
    // the trouble is what to do when no tsconfig is specified...
    const configText = fs.readFileSync(fileName, { encoding: 'utf8' });
    const result = ts.parseConfigFileTextToJson(fileName, configText);
    if (result.error) {
      throw getError([result.error]);
    }
    const configObject = result.config;
    const configParseResult = ts.parseJsonConfigFileContent(configObject, ts.sys, pathUtil.dirname(fileName));
    if (configParseResult.errors && configParseResult.errors.length) {
      throw getError(configParseResult.errors);
    }
    return [
      configParseResult.fileNames,
      configParseResult.options
    ];
  }
  function isNodeKindImportDeclaration(value) {
    return value && value.kind === ts.SyntaxKind.ImportDeclaration;
  }
  function isNodeKindExternalModuleReference(value) {
    return value && value.kind === ts.SyntaxKind.ExternalModuleReference;
  }
  function isNodeKindStringLiteral(value) {
    return value && value.kind === ts.SyntaxKind.StringLiteral;
  }
  function isNodeKindExportDeclaration(value) {
    return value && value.kind === ts.SyntaxKind.ExportDeclaration;
  }
  function isNodeKindExportAssignment(value) {
    return value && value.kind === ts.SyntaxKind.ExportAssignment;
  }
  function isNodeKindModuleDeclaration(value) {
    return value && value.kind === ts.SyntaxKind.ModuleDeclaration;
  }
  function generate(options) {
    if (Boolean(options.main) !== Boolean(options.name)) {
      if (options.name) {
        // since options.name used to do double duty as the prefix, let's be
        // considerate and point out that name should be replaced with prefix.
        // TODO update this error message when we finalize which version this change
        // will be released in.
        throw new Error(`name and main must be used together.  Perhaps you want prefix instead of
        name? In dts-generator version 2.1, name did double duty as the option to
        use to prefix module names with, but in >=2.2 the name option was split
        into two; prefix is what is now used to prefix imports and module names
        in the output.`);
      }
      else {
        throw new Error('name and main must be used together.');
      }
    }
    const noop = function () { /* nop */ };
    const sendMessage = options.sendMessage || noop;
    const verboseMessage = options.verbose ? sendMessage : noop;
    let compilerOptions = {};
    let files = options.files;
    /* following tsc behaviour, if a project is specified, or if no files are specified then
      * attempt to load tsconfig.json */
    if (options.project || !options.files || options.files.length === 0) {
      verboseMessage(`project = "${options.project || options.baseDir}"`);
      // if project isn't specified, use baseDir.  If it is and it's a directory,
      // assume we want tsconfig.json in that directory.  If it is a file, though
      // use that as our tsconfig.json.  This allows for projects that have more
      // than one tsconfig.json file.
      let tsconfigFilename;
      if (options.project) {
        if (fs.lstatSync(options.project).isDirectory()) {
          tsconfigFilename = pathUtil.join(options.project, 'tsconfig.json');
        }
        else {
          // project isn't a diretory, it's a file
          tsconfigFilename = options.project;
        }
      }
      else {
        tsconfigFilename = pathUtil.join(options.baseDir, 'tsconfig.json');
      }
      if (fs.existsSync(tsconfigFilename)) {
        verboseMessage(`  parsing "${tsconfigFilename}"`);
        [files, compilerOptions] = getTSConfig(tsconfigFilename);
      }
      else {
        sendMessage(`No "tsconfig.json" found at "${tsconfigFilename}"!`);
        return new Promise(function (resolve, reject) {
          reject(new SyntaxError('Unable to resolve configuration.'));
        });
      }
    }
    const eol = options.eol || os.EOL;
    const nonEmptyLineStart = new RegExp(eol + '(?!' + eol + '|$)', 'g');
    const indent = options.indent === undefined ? '\t' : options.indent;
    // use input values if tsconfig leaves any of these undefined.
    // this is for backwards compatibility
    compilerOptions.declaration = true;
    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; // is this necessary?
    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;
    compilerOptions.outDir = compilerOptions.outDir || options.outDir;
    // TODO should compilerOptions.baseDir come into play?
    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);
    const outDir = compilerOptions.outDir;
    verboseMessage(`baseDir = "${baseDir}"`);
    verboseMessage(`target = ${compilerOptions.target}`);
    verboseMessage(`outDir = ${compilerOptions.outDir}`);
    verboseMessage(`rootDir = ${compilerOptions.rootDir}`);
    verboseMessage(`moduleResolution = ${compilerOptions.moduleResolution}`);
    const filenames = getFilenames(baseDir, files);
    verboseMessage('filenames:');
    filenames.forEach(name => { verboseMessage('  ' + name); });
    const excludesMap = {};
    options.exclude = options.exclude || ['node_modules/**/*.d.ts'];
    options.exclude && options.exclude.forEach(function (filename) {
      glob.sync(filename, { cwd: baseDir }).forEach(function (globFileName) {
        excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;
      });
    });
    if (options.exclude) {
      verboseMessage('exclude:');
      options.exclude.forEach(name => { verboseMessage('  ' + name); });
    }
    if (!options.stdout) mkdirp.sync(pathUtil.dirname(options.out));
    /* node.js typings are missing the optional mode in createWriteStream options and therefore
      * in TS 1.6 the strict object literal checking is throwing, therefore a hammer to the nut */
    const output = options.stdout || fs.createWriteStream(options.out, { mode: parseInt('644', 8) });
    const host = ts.createCompilerHost(compilerOptions);
    const program = ts.createProgram(filenames, compilerOptions, host);
    function writeFile(filename, data) {
      // Compiler is emitting the non-declaration file, which we do not care about
      if (filename.slice(-DTSLEN) !== '.d.ts') {
        return;
      }
      writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);
    }
    let declaredExternalModules = [];
    return new Promise(function (resolve, reject) {
      output.on('close', () => { resolve(undefined); });
      output.on('error', reject);
      if (options.externs) {
        options.externs.forEach(function (path) {
          sendMessage(`Writing external dependency ${path}`);
          output.write(`/// <reference path="${path}" />` + eol);
        });
      }
      if (options.types) {
        options.types.forEach(function (type) {
          sendMessage(`Writing external @types package dependency ${type}`);
          output.write(`/// <reference types="${type}" />` + eol);
        });
      }
      sendMessage('processing:');
      let mainExportDeclaration = false;
      let mainExportAssignment = false;
      let foundMain = false;
      program.getSourceFiles().forEach(function (sourceFile) {
        processTree(sourceFile, function (node) {
          if (isNodeKindModuleDeclaration(node)) {
            const name = node.name;
            if (isNodeKindStringLiteral(name)) {
              declaredExternalModules.push(name.text);
            }
          }
          return null;
        });
      });
      program.getSourceFiles().some(function (sourceFile) {
        // Source file is a default library, or other dependency from another project, that should not be included in
        // our bundled output
        if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir + pathUtil.sep) !== 0) {
          return;
        }
        if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {
          return;
        }
        sendMessage(`  ${sourceFile.fileName}`);
        // Source file is already a declaration file so should does not need to be pre-processed by the emitter
        if (sourceFile.fileName.slice(-DTSLEN) === '.d.ts') {
          writeDeclaration(sourceFile, false);
          return;
        }
        // We can optionally output the main module if there's something to export.
        if (options.main && options.main === (options.prefix + filenameToMid(sourceFile.fileName.slice(baseDir.length, -3)))) {
          foundMain = true;
          ts.forEachChild(sourceFile, function (node) {
            mainExportDeclaration = mainExportDeclaration || isNodeKindExportDeclaration(node);
            mainExportAssignment = mainExportAssignment || isNodeKindExportAssignment(node);
          });
        }
        const emitOutput = program.emit(sourceFile, writeFile);
        if (emitOutput.emitSkipped || emitOutput.diagnostics.length > 0) {
          reject(getError(emitOutput.diagnostics
            .concat(program.getSemanticDiagnostics(sourceFile))
            .concat(program.getSyntacticDiagnostics(sourceFile))
            .concat(program.getDeclarationDiagnostics(sourceFile))));
          return true;
        }
      });
      if (options.main && !foundMain) {
        throw new Error(`main module ${options.main} was not found`);
      }
      if (options.main) {
        output.write(`declare module '${options.name}' {` + eol + indent);
        if (compilerOptions.target >= ts.ScriptTarget.ES2015) {
          if (mainExportAssignment) {
            output.write(`export {default} from '${options.main}';` + eol + indent);
          }
          if (mainExportDeclaration) {
            output.write(`export * from '${options.main}';` + eol);
          }
        }
        else {
          output.write(`import main = require('${options.main}');` + eol + indent);
          output.write('export = main;' + eol);
        }
        output.write('}' + eol);
        sendMessage(`Aliased main module ${options.name} to ${options.main}`);
      }
      if (!options.stdout) {
        sendMessage(`output to "${options.out}"`);
        output.end();
      }
    });
    function writeDeclaration(declarationFile, isOutput) {
      // resolving is important for dealting with relative outDirs
      const filename = pathUtil.resolve(declarationFile.fileName);
      // use the outDir here, not the baseDir, because the declarationFiles are
      // outputs of the build process; baseDir points instead to the inputs.
      // However we have to account for .d.ts files in our inputs that this code
      // is also used for.  Also if no outDir is used, the compiled code ends up
      // alongside the source, so use baseDir in that case too.
      const outputDir = (isOutput && Boolean(outDir)) ? pathUtil.resolve(outDir) : baseDir;
      const sourceModuleId = filenameToMid(filename.slice(outputDir.length + 1, -DTSLEN));
      const currentModuleId = filenameToMid(filename.slice(outputDir.length + 1, -DTSLEN));
      function resolveModuleImport(moduleId) {
        const isDeclaredExternalModule = declaredExternalModules.indexOf(moduleId) !== -1;
        let resolved;
        if (options.resolveModuleImport) {
          resolved = options.resolveModuleImport({
            importedModuleId: moduleId,
            currentModuleId: currentModuleId,
            isDeclaredExternalModule: isDeclaredExternalModule
          });
        }
        if (!resolved) {
          // resolve relative imports relative to the current module id.
          if (moduleId.charAt(0) === '.') {
            resolved = filenameToMid(pathUtil.join(pathUtil.dirname(sourceModuleId), moduleId));
          }
          else {
            resolved = moduleId;
          }
          // prefix the import with options.prefix, so that both non-relative imports
          // and relative imports end up prefixed with options.prefix.  We only
          // do this when no resolveModuleImport function is given so that that
          // function has complete control of the imports that get outputed.
          // NOTE: we may want to revisit the isDeclaredExternalModule behavior.
          // discussion is on https://github.com/SitePen/dts-generator/pull/94
          // but currently there's no strong argument against this behavior.
          if (Boolean(options.prefix) && !isDeclaredExternalModule) {
            resolved = `${options.prefix}/${resolved}`;
          }
        }
        return resolved;
      }
      /* For some reason, SourceFile.externalModuleIndicator is missing from 1.6+, so having
        * to use a sledgehammer on the nut */
      if (declarationFile.externalModuleIndicator) {
        let resolvedModuleId = sourceModuleId;
        if (options.resolveModuleId) {
          const resolveModuleIdResult = options.resolveModuleId({
            currentModuleId: currentModuleId
          });
          if (resolveModuleIdResult) {
            resolvedModuleId = resolveModuleIdResult;
          }
          else if (options.prefix) {
            resolvedModuleId = `${options.prefix}/${resolvedModuleId}`;
          }
        }
        else if (options.prefix) {
          resolvedModuleId = `${options.prefix}/${resolvedModuleId}`;
        }
        output.write('declare module \'' + resolvedModuleId + '\' {' + eol + indent);
        const content = processTree(declarationFile, function (node) {
          if (isNodeKindExternalModuleReference(node)) {
            // TODO figure out if this branch is possible, and if so, write a test
            // that covers it.
            const expression = node.expression;
            // convert both relative and non-relative module names in import = require(...)
            // statements.
            const resolved = resolveModuleImport(expression.text);
            return ` require('${resolved}')`;
          }
          else if (node.kind === ts.SyntaxKind.DeclareKeyword) {
            return '';
          }
          else if (isNodeKindStringLiteral(node) && node.parent &&
            (isNodeKindExportDeclaration(node.parent) || isNodeKindImportDeclaration(node.parent))) {
            // This block of code is modifying the names of imported modules
            const text = node.text;
            const resolved = resolveModuleImport(text);
            if (resolved) {
              return ` '${resolved}'`;
            }
          }
        });
        output.write(content.replace(nonEmptyLineStart, '$&' + indent));
        output.write(eol + '}' + eol);
      }
      else {
        output.write(declarationFile.text);
      }
    }
  }
  exports.default = generate;
})();

const path = require("path");
const fs = require("fs");
const stream = require("stream");
const util = require("util");

function OutputStream(options) {
  stream.Writable.call(this, options);
  this.chunks = [];
}
util.inherits(OutputStream, stream.Writable);
OutputStream.prototype._write = function (chunk, enc, cb) {
  this.chunks.push(chunk);
  cb();
};
OutputStream.prototype.toBuffer = function () {
  return Buffer.concat(this.chunks);
};
OutputStream.prototype.toString = function () {
  return this.toBuffer().toString("utf8");
};

const stdout = new OutputStream();
stdout.write(`declare module 'assemblyscript' {
    export * from 'assemblyscript/src/index';
}
`);

module.exports.default({
  project: path.resolve(__dirname, "..", "src"),
  prefix: "assemblyscript",
  exclude: [
    "glue/**",
  ],
  verbose: true,
  sendMessage: console.log,
  stdout: stdout
});

stdout.write("\n");

module.exports.default({
  project: path.resolve(__dirname, "..", "std/assembly/shared"),
  prefix: "assemblyscript/std/assembly/shared",
  exclude: [],
  verbose: true,
  sendMessage: console.log,
  stdout: stdout
});

stdout.write("\n");

module.exports.default({
  project: path.resolve(__dirname, "..", "src/glue"),
  prefix: "assemblyscript/src/glue",
  exclude: [
    "js/index.ts",
    "js/node.d.ts"
  ],
  verbose: true,
  sendMessage: console.log,
  stdout: stdout
});

var source = stdout.toString().replace(/\/\/\/ <reference[^>]*>\r?\n/g, "");

const ts = require("typescript");
const sourceFile = ts.createSourceFile("assemblyscript.d.ts", source, ts.ScriptTarget.ESNext, false, ts.ScriptKind.TS);

console.log("transforming:");
var numReplaced = 0;
const result = ts.transform(sourceFile, [
  function (context) {
    const visit = node => {
      node = ts.visitEachChild(node, visit, context);
      if (ts.isTypeNode(node)) {
        const name = node.getText(sourceFile);
        switch (name) {
          // this is wrong, but works
          case "bool": ++numReplaced; return ts.createIdentifier("boolean");
          default: if (!/^(?:Binaryen|Relooper)/.test(name)) break;
          case "i8": case "i16": case "i32": case "isize":
          case "u8": case "u16": case "u32": case "usize":
          case "f32": case "f64": ++numReplaced; return ts.createIdentifier("number");
        }
      }
      return node;
    };
    return node => ts.visitNode(node, visit);
  }
]);
console.log("  replaced " + numReplaced + " AS types with JS types");

if (!fs.existsSync(path.join(__dirname, "..", "dist"))) {
  fs.mkdirSync(path.join(__dirname, "..", "dist"));
}
fs.writeFileSync(
  path.resolve(__dirname, "..", "dist", "assemblyscript.d.ts"),
  ts.createPrinter().printFile(result.transformed[0]),
  "utf8"
);

'''
'''--- scripts/build-sdk.js ---
const path = require("path");
const fs = require("fs");
const pkg = require("../package-lock.json");

fs.readFile(path.join(__dirname, "..", "lib", "sdk", "index.js"), "utf8", function(err, data) {
  if (err) throw err;
  data = data
    .replace(/BINARYEN_VERSION = "nightly"/, "BINARYEN_VERSION = " + JSON.stringify(pkg.dependencies.binaryen.version))
    .replace(/LONG_VERSION = "latest"/, "LONG_VERSION = " + JSON.stringify(pkg.dependencies.long.version))
    .replace(/ASSEMBLYSCRIPT_VERSION = "latest"/, "ASSEMBLYSCRIPT_VERSION = " + JSON.stringify(pkg.version));
  fs.writeFile(path.join(__dirname, "..", "dist", "sdk.js"), data, function(err) {
    if (err) throw err;
  });
});

'''
'''--- scripts/build.js ---
const webpack = require("webpack");
const config = require("../webpack.config.js");

webpack(config, err => {
  if (err) throw err;
});

'''
'''--- scripts/clean.js ---
var fs = require("fs");
var glob = require("glob");

glob("*", { cwd: __dirname + "/../dist" }, (err, matches) => {
  if (err)
    console.log("Failed to list files in 'dist/': " + err.message);
  else
    matches.forEach(match => {
      fs.unlink(__dirname + "/../dist/" + match, err => {
        if (err)
          console.log("Failed to delete 'dist/" + match + "': " + err.message);
        else
          console.log("Deleted 'dist/" + match + "'");
      });
    });
});

'''
'''--- scripts/hexfloat.html ---
<style>
  html, body { margin: 0; }
  body { font-family: sans-serif; border-top: 5px solid #0074C1; }
  form { margin: 10px; }
  label { cursor: pointer; }
</style>

<form onsubmit="convert(this); return false">
  <h1>Hexadecimal float to decimal float converter</h1>
  <p>
    <label for="f64"><input id="f64" name="precision" value="f64" type="radio" checked /> f64</label>
    <label for="f32"><input id="f32" name="precision" value="f32" type="radio" /> f32</label>
    <input id="pre" type="text" value="test(" />
    <input id="post" type="text" value=");" />
    <button>Convert</button>
  </p>
  <p><textarea cols="120" rows="20" id="input"></textarea></p>
  <p><textarea cols="120" rows="20" id="output" readonly></textarea></p>
</form>

<script src="hexfloat.js"></script>
<script>
function convert(form) {
  var isF64 = document.getElementById("f64").checked;
  var pre = document.getElementById("pre").value;
  var post = document.getElementById("post").value;
  var input = document.getElementById("input").value;
  document.getElementById("output").value = input
    .replace(/\b(\-?0x[0-9a-fA-F]*(?:\.[0-9a-fA-F]+)?[pP][+-]?[0-9]+\b)/g, ($0, $1) => {
      var val = parse($1);
      return val.toPrecision(isF64 ? 18 : 10);
    })
    .replace(/(\d\.[0-9])0+\b/g, "$1")
    .replace(/\bnan\b/g, "NaN")
    .replace(/\binf\b/g, "Infinity")
    .replace(/^T\(R\w, */mg, pre)
    .replace(/\);?$/mg, post)
    .replace(/ +/g, " ");
}
</script>

'''
'''--- scripts/hexfloat.js ---
/*
 MIT License

 Copyright (c) 2017 Mauro Bringolf

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*/
// see: https://github.com/maurobringolf/webassembly-floating-point-hex-parser
function parse(input) {
  input = input.toUpperCase();
  const splitIndex = input.indexOf('P');
  let mantissa, exponent;

  if (splitIndex !== -1) {
    mantissa = input.substring(0, splitIndex);
    exponent = parseInt(input.substring(splitIndex + 1));
  } else {
    mantissa = input;
    exponent = 0;
  }

  const dotIndex = mantissa.indexOf('.');

  if (dotIndex !== -1) {
    let integerPart = parseInt(mantissa.substring(0, dotIndex), 16);
    let sign = Math.sign(integerPart);
    integerPart = sign * integerPart;
    const fractionLength = mantissa.length - dotIndex - 1;
    const fractionalPart = parseInt(mantissa.substring(dotIndex + 1), 16);
    const fraction = fractionLength > 0 ? fractionalPart / Math.pow(16, fractionLength) : 0;
    if (sign === 0) {
      if (fraction === 0) {
        mantissa = sign;
      } else {
        if (Object.is(sign, -0)) {
          mantissa = - fraction;
        } else {
          mantissa = fraction;
        }
      }
    } else {
      mantissa = sign * (integerPart + fraction);
    }
  } else {
    mantissa = parseInt(mantissa, 16);
  }

  return mantissa * (splitIndex !== -1 ? Math.pow(2, exponent) : 1);
}

if (typeof process !== "undefined") {
  if (process.argv.length < 3) {
    console.error("Usage: hexfloat 0x1p1023");
    process.exit(1);
  }

  var output = parse(process.argv[2]);
  var double = output.toPrecision(18); // 17
  var single = output.toPrecision(10); // 9

  console.log("<f64>" + double);
  console.log("<f32>" + single);

  if (!(parseFloat(double) === output)) throw Error("double precision error");
  if (!(Math.fround(parseFloat(single)) === Math.fround(output))) throw Error("single precision error");
}

'''
'''--- scripts/postpublish-files.json ---
[
  "package.json",
  "index.js",
  "index.d.ts"
]

'''
'''--- scripts/postpublish.js ---
// Reconfigures the repository after publishing

const fs = require("fs");
const path = require("path");
const devFiles = require("./postpublish-files.json");

console.log("Restoring development files ...");

devFiles.forEach(originalName => {
  const backupName = originalName + ".backup";
  const backupPath = path.join(__dirname, "..", backupName);
  if (!fs.existsSync(backupPath)) {
    console.log("- " + backupName + " does not exist");
  } else {
    console.log("- " + backupName + " -> " + originalName);
    fs.copyFileSync(
      backupPath,
      path.join(__dirname, "..", originalName)
    );
    fs.unlinkSync(backupPath);
  }
});

'''
'''--- scripts/prepublish.js ---
// Reconfigures the repository before publishing

const fs = require("fs");
const path = require("path");
const pkg = require("../package.json");
const devFiles = require("./postpublish-files.json");

if (!pkg.releaseFiles) {
  console.log("Package has already been updated");
  return;
}

console.log("Backing up development files ...");

devFiles.forEach(originalName => {
  const backupName = originalName + ".backup";
  console.log("- " + originalName + " -> " + backupName);
  fs.copyFileSync(
    path.join(__dirname, "..", originalName),
    path.join(__dirname, "..", backupName)
  );
});

console.log("Updating package.json ...");

// Stuff we don't need in release
Object.keys(pkg.devDependencies).forEach(dep => delete pkg.dependencies[dep]);
delete pkg.devDependencies;
delete pkg.scripts;

// Stuff we want in release
pkg.files = pkg.releaseFiles;
delete pkg.releaseFiles;

// Copy contributors from NOTICE to .contributors
const notice = fs.readFileSync(path.join(__dirname, "..", "NOTICE"), "utf8");
const noticeRange = ["dcode.io>", "Portions of this software"];
const posStart = notice.indexOf(noticeRange[0]);
const posEnd = notice.indexOf(noticeRange[1], posStart);
if (posStart < 0 || posEnd < 0) throw Error("unexpected NOTICE format");
pkg.contributors = [];
for (let entry of notice.substring(posStart + noticeRange[0].length, posEnd).trim().matchAll(/^\* ([^<\n]+(?: <([^>\n]+)>))/mg)) {
  pkg.contributors.push(entry[1]);
}
if (!pkg.contributors.length) throw Error("missing contributors");
fs.writeFileSync(path.join(__dirname, "..", "package.json"), [
  JSON.stringify(pkg, null, 2), '\n'
].join(""));

console.log("Copying index.release.js -> index.js ...");
fs.copyFileSync(
  path.join(__dirname, "..", "index.release.js"),
  path.join(__dirname, "..", "index.js")
);

console.log("Copying index.release.d.ts -> index.d.ts ...");
fs.copyFileSync(
  path.join(__dirname, "..", "index.release.d.ts"),
  path.join(__dirname, "..", "index.d.ts")
);

// We are going to use these immediately, so, to be sure:
setTimeout(() => console.log("OK"), 2000);

'''
'''--- scripts/update-constants.js ---
// Updates the Binaryen constants in src/module.ts

const fs = require("fs");
const path = require("path");
const binaryen = require("binaryen");

const srcfile = path.join(__dirname, "..", "src", "module.ts");
var src = fs.readFileSync(srcfile, "utf8");

binaryen.ready.then(() => {
  src = src.replace(/(?:enum|namespace) (\w+) \{([^}]*)\}/g, function($0) {
    return $0.replace(/(\w+)[ ]+=[ ]+([^,;\n]+)/g, function($0, key, val) {
      var match = val.match(/\b(_(?:Binaryen|Relooper|ExpressionRunner)\w+)\b/);
      if (match) {
        let fn = match[1];
        if (typeof binaryen[fn] !== "function") throw Error("API mismatch on '" + fn + "': Is Binaryen up to date?");
        let id = binaryen[fn]();
        console.log(fn + " = " + id);
        return key + " = " + id + " /* " + fn + " */";
      }
      return $0;
    });
  });
  fs.writeFileSync(srcfile, src, "utf8");
});

'''
'''--- snap/README.md ---
Snaps are containerised software packages that are simple to create and install on all major Linux systems without modification. [Learn more](https://docs.snapcraft.io/).

[![Snap Status](https://build.snapcraft.io/badge/AssemblyScript/assemblyscript.svg)](https://snapcraft.io/assemblyscript)

'''
'''--- src/README.md ---
Compiler
========

Portable compiler sources that compile to both JavaScript using `tsc` and WebAssembly using `asc`.

Architecture
------------

![](https://raw.githubusercontent.com/AssemblyScript/assemblyscript/main/media/architecture.svg)

Usage
-----

Note that using the compiler as a library requires awaiting Binaryen ready state, like so:

```js
const binaryen = require("binaryen");
const assemblyscript = require("assemblyscript");
binaryen.ready.then(() => {
  // do something with assemblyscript
});
```

Building
--------

Note that building the compiler is not necessary if you only want to run it (in development). If not built, `ts-node` is used to run the sources directly.

### Building to JavaScript

To build the compiler to a JavaScript bundle, run:

```sh
npm run build
```

Uses webpack under the hood, building to `dist/`.

### Building to WebAssembly

To build the compiler to a WebAssembly binary, run:

```sh
npm run bootstrap
```

Uses the AssemblyScript compiler compiled to JavaScript to compile itself to WebAssembly, building to WebAssembly again using itself compiled to WebAssembly. Builds to `out/`. Performs a `git diff` to make sure that both the initial and the final artifacts are the same. Note that this builds the compiler as a library, while the `asc` frontend setting it up and feeding it source files is JavaScript for now.

Running `asc` with the WebAssembly variant:

```ts
asc [options...] --wasm out/assemblyscript.optimized-bootstrap.wasm
```

Running the compiler tests with the WebAssembly variant:

```ts
npm run test:compiler -- --wasm out/assemblyscript.optimized-bootstrap.wasm
```

'''
'''--- src/asconfig.json ---
{
  "entries": [
    "./glue/wasm/index.ts",
    "./index.ts"
  ],
  "options": {
    "explicitStart": true,
    "exportRuntime": true,
    "initialMemory": 768,
    "runtime": "incremental",
    "measure": true
  },
  "targets": {
    "untouched": {
      "binaryFile": "../out/assemblyscript.untouched.wasm",
      "textFile": "../out/assemblyscript.untouched.wast",
      "tsdFile": "../out/assemblyscript.d.ts",
      "debug": true
    },
    "optimized": {
      "binaryFile": "../out/assemblyscript.optimized.wasm",
      "textFile": "../out/assemblyscript.optimized.wast",
      "tsdFile": "../out/assemblyscript.d.ts",
      "optimizeLevel": 3,
      "shrinkLevel": 0
    },
    "rtraced": {
      "binaryFile": "../out/assemblyscript.rtraced.wasm",
      "textFile": "../out/assemblyscript.rtraced.wast",
      "tsdFile": "../out/assemblyscript.d.ts",
      "debug": true,
      "use": "ASC_RTRACE=1",
      "runPasses": []
    },
    "untouched-bootstrap": {
      "binaryFile": "../out/assemblyscript.untouched-bootstrap.wasm",
      "textFile": "../out/assemblyscript.untouched-bootstrap.wast",
      "tsdFile": "../out/assemblyscript.d.ts",
      "debug": true
    },
    "optimized-bootstrap": {
      "binaryFile": "../out/assemblyscript.optimized-bootstrap.wasm",
      "textFile": "../out/assemblyscript.optimized-bootstrap.wast",
      "tsdFile": "../out/assemblyscript.d.ts",
      "optimizeLevel": 3,
      "shrinkLevel": 0
    }
  }
}
'''
'''--- src/ast.ts ---
/**
 * @fileoverview Abstract syntax tree representing a source file once parsed.
 *
 * Each node in the AST is represented by an instance of a subclass of `Node`,
 * with its `Node#kind` represented by one of the `NodeKind` constants, which
 * dependent code typically switches over. The intended way to create a node
 * is to use the respective `Node.createX` method instead of its constructor.
 *
 * Note that the AST does not contain any type information except type names.
 *
 * @license Apache-2.0
 */

// TODO: Make the AST more easily serializable by refactoring `Node#range` so
// it doesn't reference the non-serializable `Source` object.

import {
  CommonFlags,
  PATH_DELIMITER,
  LIBRARY_PREFIX,
  LIBRARY_SUBST
} from "./common";

import {
  Token,
  Range
} from "./tokenizer";

import {
  normalizePath,
  resolvePath,
  CharCode,
  isTrivialAlphanum
} from "./util";

import {
  ExpressionRef
} from "./module";

import {
  Type
} from "./types";

/** Indicates the kind of a node. */
export enum NodeKind {

  SOURCE,

  // types
  NAMEDTYPE,
  FUNCTIONTYPE,
  TYPENAME,
  TYPEPARAMETER,
  PARAMETER,

  // expressions
  IDENTIFIER,
  ASSERTION,
  BINARY,
  CALL,
  CLASS,
  COMMA,
  ELEMENTACCESS,
  FALSE,
  FUNCTION,
  INSTANCEOF,
  LITERAL,
  NEW,
  NULL,
  OMITTED,
  PARENTHESIZED,
  PROPERTYACCESS,
  TERNARY,
  SUPER,
  THIS,
  TRUE,
  CONSTRUCTOR,
  UNARYPOSTFIX,
  UNARYPREFIX,
  COMPILED,

  // statements
  BLOCK,
  BREAK,
  CONTINUE,
  DO,
  EMPTY,
  EXPORT,
  EXPORTDEFAULT,
  EXPORTIMPORT,
  EXPRESSION,
  FOR,
  FOROF,
  IF,
  IMPORT,
  RETURN,
  SWITCH,
  THROW,
  TRY,
  VARIABLE,
  VOID,
  WHILE,

  // declaration statements
  CLASSDECLARATION,
  ENUMDECLARATION,
  ENUMVALUEDECLARATION,
  FIELDDECLARATION,
  FUNCTIONDECLARATION,
  IMPORTDECLARATION,
  INTERFACEDECLARATION,
  METHODDECLARATION,
  NAMESPACEDECLARATION,
  TYPEDECLARATION,
  VARIABLEDECLARATION,

  // special
  DECORATOR,
  EXPORTMEMBER,
  SWITCHCASE,
  INDEXSIGNATURE,
  COMMENT
}

/** Base class of all nodes. */
export abstract class Node {
  constructor(
    /** Kind of this node. */
    public kind: NodeKind,
    /** Source range. */
    public range: Range
  ) {}

  // types

  static createSimpleTypeName(
    name: string,
    range: Range
  ): TypeName {
    return new TypeName(Node.createIdentifierExpression(name, range), null, range);
  }

  static createNamedType(
    name: TypeName,
    typeArguments: TypeNode[] | null,
    isNullable: bool,
    range: Range
  ): NamedTypeNode {
    return new NamedTypeNode(name, typeArguments, isNullable, range);
  }

  static createFunctionType(
    parameters: ParameterNode[],
    returnType: TypeNode,
    explicitThisType: NamedTypeNode | null,
    isNullable: bool,
    range: Range
  ): FunctionTypeNode {
    return new FunctionTypeNode(parameters, returnType, explicitThisType, isNullable, range);
  }

  static createOmittedType(
    range: Range
  ): NamedTypeNode {
    return new NamedTypeNode(Node.createSimpleTypeName("", range), null, false, range);
  }

  static createTypeParameter(
    name: IdentifierExpression,
    extendsType: NamedTypeNode | null,
    defaultType: NamedTypeNode | null,
    range: Range
  ): TypeParameterNode {
    return new TypeParameterNode(name, extendsType, defaultType, range);
  }

  static createParameter(
    parameterKind: ParameterKind,
    name: IdentifierExpression,
    type: TypeNode,
    initializer: Expression | null,
    range: Range
  ): ParameterNode {
    return new ParameterNode(parameterKind, name, type, initializer, range);
  }

  // special

  static createDecorator(
    name: Expression,
    args: Expression[] | null,
    range: Range
  ): DecoratorNode {
    return new DecoratorNode(DecoratorKind.fromNode(name), name, args, range);
  }

  static createComment(
    commentKind: CommentKind,
    text: string,
    range: Range
  ): CommentNode {
    return new CommentNode(commentKind, text, range);
  }

  // expressions

  static createIdentifierExpression(
    text: string,
    range: Range,
    isQuoted: bool = false
  ): IdentifierExpression {
    return new IdentifierExpression(text, isQuoted, range);
  }

  static createEmptyIdentifierExpression(
    range: Range
  ): IdentifierExpression {
    return new IdentifierExpression("", false, range);
  }

  static createArrayLiteralExpression(
    elementExpressions: Expression[],
    range: Range
  ): ArrayLiteralExpression {
    return new ArrayLiteralExpression(elementExpressions, range);
  }

  static createAssertionExpression(
    assertionKind: AssertionKind,
    expression: Expression,
    toType: TypeNode | null,
    range: Range
  ): AssertionExpression {
    return new AssertionExpression(assertionKind, expression, toType, range);
  }

  static createBinaryExpression(
    operator: Token,
    left: Expression,
    right: Expression,
    range: Range
  ): BinaryExpression {
    return new BinaryExpression(operator, left, right, range);
  }

  static createCallExpression(
    expression: Expression,
    typeArguments: TypeNode[] | null,
    args: Expression[],
    range: Range
  ): CallExpression {
    return new CallExpression(expression, typeArguments, args, range);
  }

  static createClassExpression(
    declaration: ClassDeclaration
  ): ClassExpression {
    return new ClassExpression(declaration);
  }

  static createCommaExpression(
    expressions: Expression[],
    range: Range
  ): CommaExpression {
    return new CommaExpression(expressions, range);
  }

  static createConstructorExpression(
    range: Range
  ): ConstructorExpression {
    return new ConstructorExpression(range);
  }

  static createElementAccessExpression(
    expression: Expression,
    elementExpression: Expression,
    range: Range
  ): ElementAccessExpression {
    return new ElementAccessExpression(expression, elementExpression, range);
  }

  static createFalseExpression(
    range: Range
  ): FalseExpression {
    return new FalseExpression(range);
  }

  static createFloatLiteralExpression(
    value: f64,
    range: Range
  ): FloatLiteralExpression {
    return new FloatLiteralExpression(value, range);
  }

  static createFunctionExpression(
    declaration: FunctionDeclaration
  ): FunctionExpression {
    return new FunctionExpression(declaration);
  }

  static createInstanceOfExpression(
    expression: Expression,
    isType: TypeNode,
    range: Range
  ): InstanceOfExpression {
    return new InstanceOfExpression(expression, isType, range);
  }

  static createIntegerLiteralExpression(
    value: i64,
    range: Range
  ): IntegerLiteralExpression {
    return new IntegerLiteralExpression(value, range);
  }

  static createNewExpression(
    typeName: TypeName,
    typeArguments: TypeNode[] | null,
    args: Expression[],
    range: Range
  ): NewExpression {
    return new NewExpression(typeName, typeArguments, args, range);
  }

  static createNullExpression(
    range: Range
  ): NullExpression {
    return new NullExpression(range);
  }

  static createObjectLiteralExpression(
    names: IdentifierExpression[],
    values: Expression[],
    range: Range
  ): ObjectLiteralExpression {
    return new ObjectLiteralExpression(names, values, range);
  }

  static createOmittedExpression(
    range: Range
  ): OmittedExpression {
    return new OmittedExpression(range);
  }

  static createParenthesizedExpression(
    expression: Expression,
    range: Range
  ): ParenthesizedExpression {
    return new ParenthesizedExpression(expression, range);
  }

  static createPropertyAccessExpression(
    expression: Expression,
    property: IdentifierExpression,
    range: Range
  ): PropertyAccessExpression {
    return new PropertyAccessExpression(expression, property, range);
  }

  static createRegexpLiteralExpression(
    pattern: string,
    patternFlags: string,
    range: Range
  ): RegexpLiteralExpression {
    return new RegexpLiteralExpression(pattern, patternFlags, range);
  }

  static createTernaryExpression(
    condition: Expression,
    ifThen: Expression,
    ifElse: Expression,
    range: Range
  ): TernaryExpression {
    return new TernaryExpression(condition, ifThen, ifElse, range);
  }

  static createStringLiteralExpression(
    value: string,
    range: Range
  ): StringLiteralExpression {
    return new StringLiteralExpression(value, range);
  }

  static createSuperExpression(
    range: Range
  ): SuperExpression {
    return new SuperExpression(range);
  }

  static createTemplateLiteralExpression(
    tag: Expression | null,
    parts: string[],
    rawParts: string[],
    expressions: Expression[],
    range: Range
  ): TemplateLiteralExpression {
    return new TemplateLiteralExpression(tag, parts, rawParts, expressions, range);
  }

  static createThisExpression(
    range: Range
  ): ThisExpression {
    return new ThisExpression(range);
  }

  static createTrueExpression(
    range: Range
  ): TrueExpression {
    return new TrueExpression(range);
  }

  static createUnaryPostfixExpression(
    operator: Token,
    operand: Expression,
    range: Range
  ): UnaryPostfixExpression {
    return new UnaryPostfixExpression(operator, operand, range);
  }

  static createUnaryPrefixExpression(
    operator: Token,
    operand: Expression,
    range: Range
  ): UnaryPrefixExpression {
    return new UnaryPrefixExpression(operator, operand, range);
  }

  static createCompiledExpression(
    expr: ExpressionRef,
    type: Type,
    range: Range
  ): Expression {
    return new CompiledExpression(expr, type, range);
  }

  // statements

  static createBlockStatement(
    statements: Statement[],
    range: Range
  ): BlockStatement {
    return new BlockStatement(statements, range);
  }

  static createBreakStatement(
    label: IdentifierExpression | null,
    range: Range
  ): BreakStatement {
    return new BreakStatement(label, range);
  }

  static createClassDeclaration(
    name: IdentifierExpression,
    decorators: DecoratorNode[] | null,
    flags: CommonFlags,
    typeParameters: TypeParameterNode[] | null,
    extendsType: NamedTypeNode | null,
    implementsTypes: NamedTypeNode[] | null,
    members: DeclarationStatement[],
    range: Range
  ): ClassDeclaration {
    return new ClassDeclaration(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);
  }

  static createContinueStatement(
    label: IdentifierExpression | null,
    range: Range
  ): ContinueStatement {
    return new ContinueStatement(label, range);
  }

  static createDoStatement(
    statement: Statement,
    condition: Expression,
    range: Range
  ): DoStatement {
    return new DoStatement(statement, condition, range);
  }

  static createEmptyStatement(
    range: Range
  ): EmptyStatement {
    return new EmptyStatement(range);
  }

  static createEnumDeclaration(
    name: IdentifierExpression,
    decorators: DecoratorNode[] | null,
    flags: CommonFlags,
    values: EnumValueDeclaration[],
    range: Range
  ): EnumDeclaration {
    return new EnumDeclaration(name, decorators, flags, values, range);
  }

  static createEnumValueDeclaration(
    name: IdentifierExpression,
    flags: CommonFlags,
    initializer: Expression | null,
    range: Range
  ): EnumValueDeclaration {
    return new EnumValueDeclaration(name, flags, initializer, range);
  }

  static createExportStatement(
    members: ExportMember[] | null,
    path: StringLiteralExpression | null,
    isDeclare: bool,
    range: Range
  ): ExportStatement {
    return new ExportStatement(members, path, isDeclare, range);
  }

  static createExportDefaultStatement(
    declaration: DeclarationStatement,
    range: Range
  ): ExportDefaultStatement {
    return new ExportDefaultStatement(declaration, range);
  }

  static createExportImportStatement(
    name: IdentifierExpression,
    externalName: IdentifierExpression,
    range: Range
  ): ExportImportStatement {
    return new ExportImportStatement(name, externalName, range);
  }

  static createExportMember(
    localName: IdentifierExpression,
    exportedName: IdentifierExpression | null,
    range: Range
  ): ExportMember {
    if (!exportedName) exportedName = localName;
    return new ExportMember(localName, exportedName, range);
  }

  static createExpressionStatement(
    expression: Expression
  ): ExpressionStatement {
    return new ExpressionStatement(expression);
  }

  static createIfStatement(
    condition: Expression,
    ifTrue: Statement,
    ifFalse: Statement | null,
    range: Range
  ): IfStatement {
    return new IfStatement(condition, ifTrue, ifFalse, range);
  }

  static createImportStatement(
    declarations: ImportDeclaration[] | null,
    path: StringLiteralExpression,
    range: Range
  ): ImportStatement {
    return new ImportStatement(declarations, null, path, range);
  }

  static createWildcardImportStatement(
    namespaceName: IdentifierExpression,
    path: StringLiteralExpression,
    range: Range
  ): ImportStatement {
    return new ImportStatement(null, namespaceName, path, range);
  }

  static createImportDeclaration(
    foreignName: IdentifierExpression,
    name: IdentifierExpression | null,
    range: Range
  ): ImportDeclaration {
    if (!name) name = foreignName;
    return new ImportDeclaration(name, foreignName, range);
  }

  static createInterfaceDeclaration(
    name: IdentifierExpression,
    decorators: DecoratorNode[] | null,
    flags: CommonFlags,
    typeParameters: TypeParameterNode[] | null,
    extendsType: NamedTypeNode | null,
    implementsTypes: NamedTypeNode[] | null,
    members: DeclarationStatement[],
    range: Range
  ): InterfaceDeclaration {
    return new InterfaceDeclaration(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);
  }

  static createFieldDeclaration(
    name: IdentifierExpression,
    decorators: DecoratorNode[] | null,
    flags: CommonFlags,
    type: TypeNode | null,
    initializer: Expression | null,
    range: Range
  ): FieldDeclaration {
    return new FieldDeclaration(name, decorators, flags, type, initializer, -1, range);
  }

  static createForStatement(
    initializer: Statement | null,
    condition: Expression | null,
    incrementor: Expression | null,
    statement: Statement,
    range: Range
  ): ForStatement {
    return new ForStatement(initializer, condition, incrementor, statement, range);
  }

  static createForOfStatement(
    variable: Statement,
    iterable: Expression,
    statement: Statement,
    range: Range
  ): ForOfStatement {
    return new ForOfStatement(variable, iterable, statement, range);
  }

  static createFunctionDeclaration(
    name: IdentifierExpression,
    decorators: DecoratorNode[] | null,
    flags: CommonFlags,
    typeParameters: TypeParameterNode[] | null,
    signature: FunctionTypeNode,
    body: Statement | null,
    arrowKind: ArrowKind,
    range: Range
  ): FunctionDeclaration {
    return new FunctionDeclaration(name, decorators, flags, typeParameters, signature, body, arrowKind, range);
  }

  static createIndexSignature(
    keyType: NamedTypeNode,
    valueType: TypeNode,
    flags: CommonFlags,
    range: Range
  ): IndexSignatureNode {
    return new IndexSignatureNode(keyType, valueType, flags, range);
  }

  static createMethodDeclaration(
    name: IdentifierExpression,
    decorators: DecoratorNode[] | null,
    flags: CommonFlags,
    typeParameters: TypeParameterNode[] | null,
    signature: FunctionTypeNode,
    body: Statement | null,
    range: Range
  ): MethodDeclaration {
    return new MethodDeclaration(name, decorators, flags, typeParameters, signature, body, range);
  }

  static createNamespaceDeclaration(
    name: IdentifierExpression,
    decorators: DecoratorNode[] | null,
    flags: CommonFlags,
    members: Statement[],
    range: Range
  ): NamespaceDeclaration {
    return new NamespaceDeclaration(name, decorators, flags, members, range);
  }

  static createReturnStatement(
    value: Expression | null,
    range: Range
  ): ReturnStatement {
    return new ReturnStatement(value, range);
  }

  static createSwitchStatement(
    condition: Expression,
    cases: SwitchCase[],
    range: Range
  ): SwitchStatement {
    return new SwitchStatement(condition, cases, range);
  }

  static createSwitchCase(
    label: Expression | null,
    statements: Statement[],
    range: Range
  ): SwitchCase {
    return new SwitchCase(label, statements, range);
  }

  static createThrowStatement(
    value: Expression,
    range: Range
  ): ThrowStatement {
    return new ThrowStatement(value, range);
  }

  static createTryStatement(
    statements: Statement[],
    catchVariable: IdentifierExpression | null,
    catchStatements: Statement[] | null,
    finallyStatements: Statement[] | null,
    range: Range
  ): TryStatement {
    return new TryStatement(statements, catchVariable, catchStatements, finallyStatements, range);
  }

  static createTypeDeclaration(
    name: IdentifierExpression,
    decorators: DecoratorNode[] | null,
    flags: CommonFlags,
    typeParameters: TypeParameterNode[] | null,
    type: TypeNode,
    range: Range
  ): TypeDeclaration {
    return new TypeDeclaration(name, decorators, flags, typeParameters, type, range);
  }

  static createVariableStatement(
    decorators: DecoratorNode[] | null,
    declarations: VariableDeclaration[],
    range: Range
  ): VariableStatement {
    return new VariableStatement(decorators, declarations, range);
  }

  static createVariableDeclaration(
    name: IdentifierExpression,
    decorators: DecoratorNode[] | null,
    flags: CommonFlags,
    type: TypeNode | null,
    initializer: Expression | null,
    range: Range
  ): VariableDeclaration {
    return new VariableDeclaration(name, decorators, flags, type, initializer, range);
  }

  static createVoidStatement(
    expression: Expression,
    range: Range
  ): VoidStatement {
    return new VoidStatement(expression, range);
  }

  static createWhileStatement(
    condition: Expression,
    statement: Statement,
    range: Range
  ): WhileStatement {
    return new WhileStatement(condition, statement, range);
  }

  /** Tests if this node is a literal of the specified kind. */
  isLiteralKind(literalKind: LiteralKind): bool {
    return this.kind == NodeKind.LITERAL
        && (<LiteralExpression>changetype<Node>(this)).literalKind == literalKind; // TS
  }

  /** Tests if this node is a literal of a numeric kind (float or integer). */
  get isNumericLiteral(): bool {
    if (this.kind == NodeKind.LITERAL) {
      switch ((<LiteralExpression>changetype<Node>(this)).literalKind) { // TS
        case LiteralKind.FLOAT:
        case LiteralKind.INTEGER: return true;
      }
    }
    return false;
  }

  /** Tests whether this node is guaranteed to compile to a constant value. */
  get compilesToConst(): bool {
    switch (this.kind) {
      case NodeKind.LITERAL: {
        switch ((<LiteralExpression>changetype<Node>(this)).literalKind) { // TS
          case LiteralKind.FLOAT:
          case LiteralKind.INTEGER:
          case LiteralKind.STRING: return true;
        }
        break;
      }
      case NodeKind.NULL:
      case NodeKind.TRUE:
      case NodeKind.FALSE: return true;
    }
    return false;
  }

  private isAccessOn(kind: NodeKind): bool {
    let node = changetype<Node>(this);
    if (node.kind == NodeKind.CALL) {
      node = (<CallExpression>node).expression;
    }
    if (node.kind == NodeKind.PROPERTYACCESS) {
      let target = (<PropertyAccessExpression>node).expression;
      if (target.kind == kind) return true;
    }
    return false;
  }

  /** Checks if this node accesses a method or property on `this`. */
  get isAccessOnThis(): bool {
    return this.isAccessOn(NodeKind.THIS);
  }

  /** Checks if this node accesses a method or property on `super`. */
  get isAccessOnSuper(): bool {
    return this.isAccessOn(NodeKind.SUPER);
  }
}

// types

export abstract class TypeNode extends Node {
  constructor(
    /** Kind of the type node. */
    kind: NodeKind,
    /** Whether nullable or not. */
    public isNullable: bool,
    /** Source range. */
    range: Range
  ) {
    super(kind, range);
  }

  /** Tests if this type has a generic component matching one of the given type parameters. */
  hasGenericComponent(typeParameterNodes: TypeParameterNode[]): bool {
    if (this.kind == NodeKind.NAMEDTYPE) {
      let namedTypeNode = <NamedTypeNode>changetype<TypeNode>(this); // TS
      if (!namedTypeNode.name.next) {
        let typeArgumentNodes = namedTypeNode.typeArguments;
        if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {
          for (let i = 0, k = typeArgumentNodes.length; i < k; ++i) {
            if (typeArgumentNodes[i].hasGenericComponent(typeParameterNodes)) return true;
          }
        } else {
          let name = namedTypeNode.name.identifier.text;
          for (let i = 0, k = typeParameterNodes.length; i < k; ++i) {
            if (typeParameterNodes[i].name.text == name) return true;
          }
        }
      }
    } else if (this.kind == NodeKind.FUNCTIONTYPE) {
      let functionTypeNode = <FunctionTypeNode>changetype<TypeNode>(this); // TS
      let parameterNodes = functionTypeNode.parameters;
      for (let i = 0, k = parameterNodes.length; i < k; ++i) {
        if (parameterNodes[i].type.hasGenericComponent(typeParameterNodes)) return true;
      }
      if (functionTypeNode.returnType.hasGenericComponent(typeParameterNodes)) return true;
      let explicitThisType = functionTypeNode.explicitThisType;
      if (explicitThisType !== null && explicitThisType.hasGenericComponent(typeParameterNodes)) return true;
    } else {
      assert(false);
    }
    return false;
  }
}

/** Represents a type name. */
export class TypeName extends Node {
  constructor(
    /** Identifier of this part. */
    public identifier: IdentifierExpression,
    /** Next part of the type name or `null` if this is the last part. */
    public next: TypeName | null,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.TYPENAME, range);
  }
}

/** Represents a named type. */
export class NamedTypeNode extends TypeNode {
  constructor(
    /** Type name. */
    public name: TypeName,
    /** Type argument references. */
    public typeArguments: TypeNode[] | null,
    /** Whether nullable or not. */
    isNullable: bool,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.NAMEDTYPE, isNullable, range);
  }

  /** Checks if this type node has type arguments. */
  get hasTypeArguments(): bool {
    var typeArguments = this.typeArguments;
    return typeArguments !== null && typeArguments.length > 0;
  }
}

/** Represents a function type. */
export class FunctionTypeNode extends TypeNode {
  constructor(
    /** Function parameters. */
    public parameters: ParameterNode[],
    /** Return type. */
    public returnType: TypeNode,
    /** Explicitly provided this type, if any. */
    public explicitThisType: NamedTypeNode | null, // can't be a function
    /** Whether nullable or not. */
    isNullable: bool,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.FUNCTIONTYPE, isNullable, range);
  }
}

/** Represents a type parameter. */
export class TypeParameterNode extends Node {
  constructor(
    /** Identifier reference. */
    public name: IdentifierExpression,
    /** Extended type reference, if any. */
    public extendsType: NamedTypeNode | null, // can't be a function
    /** Default type if omitted, if any. */
    public defaultType: NamedTypeNode | null, // can't be a function
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.TYPEPARAMETER, range);
  }
}

/** Represents the kind of a parameter. */
export enum ParameterKind {
  /** No specific flags. */
  DEFAULT,
  /** Is an optional parameter. */
  OPTIONAL,
  /** Is a rest parameter. */
  REST
}

/** Represents a function parameter. */
export class ParameterNode extends Node {
  constructor(
    /** Parameter kind. */
    public parameterKind: ParameterKind,
    /** Parameter name. */
    public name: IdentifierExpression,
    /** Parameter type. */
    public type: TypeNode,
    /** Initializer expression, if any. */
    public initializer: Expression | null,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.PARAMETER, range);
  }

  /** Implicit field declaration, if applicable. */
  implicitFieldDeclaration: FieldDeclaration | null = null;
  /** Common flags indicating specific traits. */
  flags: CommonFlags = CommonFlags.NONE;

  /** Tests if this node has the specified flag or flags. */
  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }
  /** Tests if this node has one of the specified flags. */
  isAny(flag: CommonFlags): bool { return (this.flags & flag) != 0; }
  /** Sets a specific flag or flags. */
  set(flag: CommonFlags): void { this.flags |= flag; }
}

// special

/** Built-in decorator kinds. */
export enum DecoratorKind {
  CUSTOM,
  GLOBAL,
  OPERATOR,
  OPERATOR_BINARY,
  OPERATOR_PREFIX,
  OPERATOR_POSTFIX,
  UNMANAGED,
  FINAL,
  INLINE,
  EXTERNAL,
  BUILTIN,
  LAZY,
  UNSAFE
}

export namespace DecoratorKind {

  /** Returns the kind of the specified decorator name node. Defaults to {@link DecoratorKind.CUSTOM}. */
  export function fromNode(nameNode: Expression): DecoratorKind {
    if (nameNode.kind == NodeKind.IDENTIFIER) {
      let nameStr = (<IdentifierExpression>nameNode).text;
      assert(nameStr.length);
      switch (nameStr.charCodeAt(0)) {
        case CharCode.b: {
          if (nameStr == "builtin") return DecoratorKind.BUILTIN;
          break;
        }
        case CharCode.e: {
          if (nameStr == "external") return DecoratorKind.EXTERNAL;
          break;
        }
        case CharCode.f: {
          if (nameStr == "final") return DecoratorKind.FINAL;
          break;
        }
        case CharCode.g: {
          if (nameStr == "global") return DecoratorKind.GLOBAL;
          break;
        }
        case CharCode.i: {
          if (nameStr == "inline") return DecoratorKind.INLINE;
          break;
        }
        case CharCode.l: {
          if (nameStr == "lazy") return DecoratorKind.LAZY;
          break;
        }
        case CharCode.o: {
          if (nameStr == "operator") return DecoratorKind.OPERATOR;
          break;
        }
        case CharCode.u: {
          if (nameStr == "unmanaged") return DecoratorKind.UNMANAGED;
          if (nameStr == "unsafe") return DecoratorKind.UNSAFE;
          break;
        }
      }
    } else if (nameNode.kind == NodeKind.PROPERTYACCESS) {
      let propertyAccessNode = <PropertyAccessExpression>nameNode;
      let expression = propertyAccessNode.expression;
      if (expression.kind == NodeKind.IDENTIFIER) {
        let nameStr = (<IdentifierExpression>expression).text;
        assert(nameStr.length);
        let propStr = propertyAccessNode.property.text;
        assert(propStr.length);
        if (nameStr == "operator") {
          switch (propStr.charCodeAt(0)) {
            case CharCode.b: {
              if (propStr == "binary") return DecoratorKind.OPERATOR_BINARY;
              break;
            }
            case CharCode.p: {
              if (propStr == "prefix") return DecoratorKind.OPERATOR_PREFIX;
              if (propStr == "postfix") return DecoratorKind.OPERATOR_POSTFIX;
              break;
            }
          }
        }
      }
    }
    return DecoratorKind.CUSTOM;
  }
}

/** Represents a decorator. */
export class DecoratorNode extends Node {
  constructor(
    /** Built-in decorator kind, or custom. */
    public decoratorKind: DecoratorKind,
    /** Name expression. */
    public name: Expression,
    /** Argument expressions. */
    public args: Expression[] | null,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.DECORATOR, range);
  }
}

/** Comment kinds. */
export enum CommentKind {
  /** Line comment. */
  LINE,
  /** Triple-slash line comment. */
  TRIPLE,
  /** Block comment. */
  BLOCK
}

/** Represents a comment. */
export class CommentNode extends Node {
  constructor(
    /** Comment kind. */
    public commentKind: CommentKind,
    /** Comment text. */
    public text: string,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.COMMENT, range);
  }
}

// expressions

/** Base class of all expression nodes. */
export abstract class Expression extends Node { }

/** Represents an identifier expression. */
export class IdentifierExpression extends Expression {
  constructor(
    /** Textual name. */
    public text: string,
    /** Whether quoted or not. */
    public isQuoted: bool,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.IDENTIFIER, range);
  }
}

/** Indicates the kind of a literal. */
export enum LiteralKind {
  FLOAT,
  INTEGER,
  STRING,
  TEMPLATE,
  REGEXP,
  ARRAY,
  OBJECT
}

/** Base class of all literal expressions. */
export abstract class LiteralExpression extends Expression {
  constructor(
    /** Specific literal kind. */
    public literalKind: LiteralKind,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.LITERAL, range);
  }
}

/** Represents an `[]` literal expression. */
export class ArrayLiteralExpression extends LiteralExpression {
  constructor(
    /** Nested element expressions. */
    public elementExpressions: Expression[],
    /** Source range. */
    range: Range
  ) {
    super(LiteralKind.ARRAY, range);
  }
}

/** Indicates the kind of an assertion. */
export enum AssertionKind {
  /** A prefix assertion, i.e. `<T>expr`. */
  PREFIX,
  /** An as assertion, i.e. `expr as T`. */
  AS,
  /** A non-null assertion, i.e. `!expr`. */
  NONNULL,
  /** A const assertion, i.e. `expr as const`. */
  CONST
}

/** Represents an assertion expression. */
export class AssertionExpression extends Expression {
  constructor(
    /** Specific kind of this assertion. */
    public assertionKind: AssertionKind,
    /** Expression being asserted. */
    public expression: Expression,
    /** Target type, if applicable. */
    public toType: TypeNode | null,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.ASSERTION, range);
  }
}

/** Represents a binary expression. */
export class BinaryExpression extends Expression {
  constructor(
    /** Operator token. */
    public operator: Token,
    /** Left-hand side expression */
    public left: Expression,
    /** Right-hand side expression. */
    public right: Expression,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.BINARY, range);
  }
}

/** Represents a call expression. */
export class CallExpression extends Expression {
  constructor(
    /** Called expression. Usually an identifier or property access expression. */
    public expression: Expression,
    /** Provided type arguments. */
    public typeArguments: TypeNode[] | null,
    /** Provided arguments. */
    public args: Expression[],
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.CALL, range);
  }

  /** Gets the type arguments range for reporting. */
  get typeArgumentsRange(): Range {
    var typeArguments = this.typeArguments;
    var numTypeArguments: i32;
    if (typeArguments) {
      if (numTypeArguments = typeArguments.length) {
        return Range.join(typeArguments[0].range, typeArguments[numTypeArguments - 1].range);
      }
    }
    return this.expression.range;
  }

  /** Gets the arguments range for reporting. */
  get argumentsRange(): Range {
    var args = this.args;
    var numArguments = args.length;
    if (numArguments) {
      return Range.join(args[0].range, args[numArguments - 1].range);
    }
    return this.expression.range;
  }
}

/** Represents a class expression using the 'class' keyword. */
export class ClassExpression extends Expression {
  constructor(
    /** Inline class declaration. */
    public declaration: ClassDeclaration
  ) {
    super(NodeKind.CLASS, declaration.range);
  }
}

/** Represents a comma expression composed of multiple expressions. */
export class CommaExpression extends Expression {
  constructor(
    /** Sequential expressions. */
    public expressions: Expression[],
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.COMMA, range);
  }
}

/** Represents a `constructor` expression. */
export class ConstructorExpression extends IdentifierExpression {
  constructor(
    /** Source range. */
    range: Range
  ) {
    super("constructor", false, range);
    this.kind = NodeKind.CONSTRUCTOR;
  }
}

/** Represents an element access expression, e.g., array access. */
export class ElementAccessExpression extends Expression {
  constructor(
    /** Expression being accessed. */
    public expression: Expression,
    /** Element of the expression being accessed. */
    public elementExpression: Expression,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.ELEMENTACCESS, range);
  }
}

/** Represents a float literal expression. */
export class FloatLiteralExpression extends LiteralExpression {
  constructor(
    /** Float value. */
    public value: f64,
    /** Source range. */
    range: Range
  ) {
    super(LiteralKind.FLOAT, range);
  }
}

/** Represents a function expression using the 'function' keyword. */
export class FunctionExpression extends Expression {
  constructor(
    /** Inline function declaration. */
    public declaration: FunctionDeclaration
  ) {
    super(NodeKind.FUNCTION, declaration.range);
  }
}

/** Represents an `instanceof` expression. */
export class InstanceOfExpression extends Expression {
  constructor(
    /** Expression being asserted. */
    public expression: Expression,
    /** Type to test for. */
    public isType: TypeNode,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.INSTANCEOF, range);
  }
}

/** Represents an integer literal expression. */
export class IntegerLiteralExpression extends LiteralExpression {
  constructor(
    /** Integer value. */
    public value: i64,
    /** Source range. */
    range: Range
  ) {
    super(LiteralKind.INTEGER, range);
  }
}

/** Represents a `new` expression. Like a call but with its own kind. */
export class NewExpression extends Expression {
  constructor(
    /** Type being constructed. */
    public typeName: TypeName,
    /** Provided type arguments. */
    public typeArguments: TypeNode[] | null,
    /** Provided arguments. */
    public args: Expression[],
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.NEW, range);
  }

  /** Gets the type arguments range for reporting. */
  get typeArgumentsRange(): Range {
    var typeArguments = this.typeArguments;
    var numTypeArguments: i32;
    if (typeArguments !== null && (numTypeArguments = typeArguments.length) > 0) {
      return Range.join(typeArguments[0].range, typeArguments[numTypeArguments - 1].range);
    }
    return this.typeName.range;
  }

  /** Gets the arguments range for reporting. */
  get argumentsRange(): Range {
    var args = this.args;
    var numArguments = args.length;
    if (numArguments) {
      return Range.join(args[0].range, args[numArguments - 1].range);
    }
    return this.typeName.range;
  }
}

/** Represents a `null` expression. */
export class NullExpression extends IdentifierExpression {
  constructor(
    /** Source range. */
    range: Range
  ) {
    super("null", false, range);
    this.kind = NodeKind.NULL;
  }
}

/** Represents an object literal expression. */
export class ObjectLiteralExpression extends LiteralExpression {
  constructor(
    /** Field names. */
    public names: IdentifierExpression[],
    /** Field values. */
    public values: Expression[],
    /** Source range. */
    range: Range
  ) {
    super(LiteralKind.OBJECT, range);
  }
}

/** Represents an omitted expression, e.g. within an array literal. */
export class OmittedExpression extends Expression {
  constructor(
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.OMITTED, range);
  }
}

/** Represents a parenthesized expression. */
export class ParenthesizedExpression extends Expression {
  constructor(
    /** Expression in parenthesis. */
    public expression: Expression,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.PARENTHESIZED, range);
  }
}

/** Represents a property access expression. */
export class PropertyAccessExpression extends Expression {
  constructor(
    /** Expression being accessed. */
    public expression: Expression,
    /** Property of the expression being accessed. */
    public property: IdentifierExpression,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.PROPERTYACCESS, range);
  }
}

/** Represents a regular expression literal expression. */
export class RegexpLiteralExpression extends LiteralExpression {
  constructor(
    /** Regular expression pattern. */
    public pattern: string,
    /** Regular expression flags. */
    public patternFlags: string,
    /** Source range. */
    range: Range
  ) {
    super(LiteralKind.REGEXP, range);
  }
}

/** Represents a ternary expression, i.e., short if notation. */
export class TernaryExpression extends Expression {
  constructor(
    /** Condition expression. */
    public condition: Expression,
    /** Expression executed when condition is `true`. */
    public ifThen: Expression,
    /** Expression executed when condition is `false`. */
    public ifElse: Expression,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.TERNARY, range);
  }
}

/** Represents a string literal expression. */
export class StringLiteralExpression extends LiteralExpression {
  constructor(
    /** String value without quotes. */
    public value: string,
    /** Source range. */
    range: Range
  ) {
    super(LiteralKind.STRING, range);
  }
}

/** Represents a `super` expression. */
export class SuperExpression extends IdentifierExpression {
  constructor(
    /** Source range. */
    range: Range
  ) {
    super("super", false, range);
    this.kind = NodeKind.SUPER;
  }
}

/** Represents a template literal expression. */
export class TemplateLiteralExpression extends LiteralExpression {
  constructor(
    /** Tag expression, if any. */
    public tag: Expression | null,
    /** String parts. */
    public parts: string[],
    /** Raw string parts. */
    public rawParts: string[],
    /** Expression parts. */
    public expressions: Expression[],
    /** Source range. */
    range: Range
  ) {
    super(LiteralKind.TEMPLATE, range);
  }
}

/** Represents a `this` expression. */
export class ThisExpression extends IdentifierExpression {
  constructor(
    /** Source range. */
    range: Range
  ) {
    super("this", false, range);
    this.kind = NodeKind.THIS;
  }
}

/** Represents a `true` expression. */
export class TrueExpression extends IdentifierExpression {
  constructor(
    /** Source range. */
    range: Range
  ) {
    super("true", false, range);
    this.kind = NodeKind.TRUE;
  }
}

/** Represents a `false` expression. */
export class FalseExpression extends IdentifierExpression {
  constructor(
    /** Source range. */
    range: Range
  ) {
    super("false", false, range);
    this.kind = NodeKind.FALSE;
  }
}

/** Base class of all unary expressions. */
export abstract class UnaryExpression extends Expression {
  constructor(
    /** Unary expression kind. */
    kind: NodeKind,
    /** Operator token. */
    public operator: Token,
    /** Operand expression. */
    public operand: Expression,
    /** Source range. */
    range: Range
  ) {
    super(kind, range);
  }
}

/** Represents a unary postfix expression, e.g. a postfix increment. */
export class UnaryPostfixExpression extends UnaryExpression {
  constructor(
    /** Operator token. */
    operator: Token,
    /** Operand expression. */
    operand: Expression,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.UNARYPOSTFIX, operator, operand, range);
  }
}

/** Represents a unary prefix expression, e.g. a negation. */
export class UnaryPrefixExpression extends UnaryExpression {
  constructor(
    /** Operator token. */
    operator: Token,
    /** Operand expression. */
    operand: Expression,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.UNARYPREFIX, operator, operand, range);
  }
}

/** Represents a special pre-compiled expression. If the expression has side-effects, special care has to be taken. */
export class CompiledExpression extends Expression {
  constructor(
    /** Compiled expression. */
    public expr: ExpressionRef,
    /** Type of the compiled expression. */
    public type: Type,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.COMPILED, range);
  }
}

// statements

/** Base class of all statement nodes. */
export abstract class Statement extends Node { }

/** Indicates the specific kind of a source. */
export enum SourceKind {
  /** User-provided file. */
  USER = 0,
  /** User-provided entry file. */
  USER_ENTRY = 1,
  /** Library-provided file. */
  LIBRARY = 2,
  /** Library-provided entry file. */
  LIBRARY_ENTRY = 3
}

/** A top-level source node. */
export class Source extends Node {
  constructor(
    /** Source kind. */
    public sourceKind: SourceKind,
    /** Normalized path with file extension. */
    public normalizedPath: string,
    /** Full source text. */
    public text: string
  ) {
    super(NodeKind.SOURCE, new Range(0, text.length));
    var internalPath = mangleInternalPath(normalizedPath);
    this.internalPath = internalPath;
    var pos = internalPath.lastIndexOf(PATH_DELIMITER);
    this.simplePath = pos >= 0 ? internalPath.substring(pos + 1) : internalPath;
    this.range.source = this;
  }

  /** Path used internally. */
  internalPath: string;
  /** Simple path (last part without extension). */
  simplePath: string;
  /** Contained statements. */
  statements: Statement[] = new Array();
  /** Source map index. */
  debugInfoIndex: i32 = -1;
  /** Re-exported sources. */
  exportPaths: string[] | null = null;

  /** Checks if this source represents native code. */
  get isNative(): bool {
    return this.internalPath == LIBRARY_SUBST;
  }

  /** Checks if this source is part of the (standard) library. */
  get isLibrary(): bool {
    var kind = this.sourceKind;
    return kind == SourceKind.LIBRARY || kind == SourceKind.LIBRARY_ENTRY;
  }

  /** Cached line starts. */
  private lineCache: i32[] | null = null;

  /** Remembered column number. */
  private lineColumn: i32 = 1;

  /** Determines the line number at the specified position. Starts at `1`. */
  lineAt(pos: i32): i32 {
    assert(pos >= 0 && pos < 0x7fffffff);
    var lineCache = this.lineCache;
    if (!lineCache) {
      this.lineCache = lineCache = [0];
      let text = this.text;
      let off = 0;
      let end = text.length;
      while (off < end) {
        if (text.charCodeAt(off++) == CharCode.LINEFEED) lineCache.push(off);
      }
      lineCache.push(0x7fffffff);
    }
    var l = 0;
    var r = lineCache.length - 1;
    while (l < r) {
      let m = l + ((r - l) >> 1);
      let s = unchecked(lineCache[m]);
      if (pos < s) r = m;
      else if (pos < unchecked(lineCache[m + 1])) {
        this.lineColumn = pos - s + 1;
        return m + 1;
      }
      else l = m + 1;
    }
    return assert(0);
  }

  /** Gets the column number at the last position queried with `lineAt`. Starts at `1`. */
  columnAt(): i32 {
    return this.lineColumn;
  }
}

/** Base class of all declaration statements. */
export abstract class DeclarationStatement extends Statement {
  constructor(
    /** Declaration node kind. */
    kind: NodeKind,
    /** Simple name being declared. */
    public name: IdentifierExpression,
    /** Array of decorators, if any. */
    public decorators: DecoratorNode[] | null,
    /** Common flags indicating specific traits. */
    public flags: CommonFlags,
    /** Source range. */
    range: Range
  ) {
    super(kind, range);
  }

  /** Tests if this node has the specified flag or flags. */
  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }
  /** Tests if this node has one of the specified flags. */
  isAny(flag: CommonFlags): bool { return (this.flags & flag) != 0; }
  /** Sets a specific flag or flags. */
  set(flag: CommonFlags): void { this.flags |= flag; }
}

/** Represents an index signature. */
export class IndexSignatureNode extends Node {
  constructor(
    /** Key type. */
    public keyType: NamedTypeNode,
    /** Value type. */
    public valueType: TypeNode,
    /** Common flags indicating specific traits. */
    public flags: CommonFlags,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.INDEXSIGNATURE, range);
  }
}

/** Base class of all variable-like declaration statements. */
export abstract class VariableLikeDeclarationStatement extends DeclarationStatement {
  constructor(
    /** Variable-like declaration node kind. */
    kind: NodeKind,
    /** Simple name being declared. */
    name: IdentifierExpression,
    /** Array of decorators, if any. */
    decorators: DecoratorNode[] | null,
    /** Common flags indicating specific traits. */
    flags: CommonFlags,
    /** Annotated type node, if any. */
    public type: TypeNode | null,
    /** Initializer expression, if any. */
    public initializer: Expression | null,
    /** Source range. */
    range: Range
  ) {
    super(kind, name, decorators, flags, range);
  }
}

/** Represents a block statement. */
export class BlockStatement extends Statement {
  constructor(
    /** Contained statements. */
    public statements: Statement[],
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.BLOCK, range);
  }
}

/** Represents a `break` statement. */
export class BreakStatement extends Statement {
  constructor(
    /** Target label, if any. */
    public label: IdentifierExpression | null,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.BREAK, range);
  }
}

/** Represents a `class` declaration. */
export class ClassDeclaration extends DeclarationStatement {
  constructor(
    /** Simple name being declared. */
    name: IdentifierExpression,
    /** Array of decorators, if any. */
    decorators: DecoratorNode[] | null,
    /** Common flags indicating specific traits. */
    flags: CommonFlags,
    /** Accepted type parameters. */
    public typeParameters: TypeParameterNode[] | null,
    /** Base class type being extended, if any. */
    public extendsType: NamedTypeNode | null, // can't be a function
    /** Interface types being implemented, if any. */
    public implementsTypes: NamedTypeNode[] | null, // can't be functions
    /** Class member declarations. */
    public members: DeclarationStatement[],
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.CLASSDECLARATION, name, decorators, flags, range);
  }

  /** Index signature, if present. */
  indexSignature: IndexSignatureNode | null = null;

  get isGeneric(): bool {
    var typeParameters = this.typeParameters;
    return typeParameters != null && typeParameters.length > 0;
  }
}

/** Represents a `continue` statement. */
export class ContinueStatement extends Statement {
  constructor(
    /** Target label, if applicable. */
    public label: IdentifierExpression | null,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.CONTINUE, range);
  }
}

/** Represents a `do` statement. */
export class DoStatement extends Statement {
  constructor(
    /** Statement being looped over. */
    public statement: Statement,
    /** Condition when to repeat. */
    public condition: Expression,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.DO, range);
  }
}

/** Represents an empty statement, i.e., a semicolon terminating nothing. */
export class EmptyStatement extends Statement {
  constructor(
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.EMPTY, range);
  }
}

/** Represents an `enum` declaration. */
export class EnumDeclaration extends DeclarationStatement {
  constructor(
    /** Simple name being declared. */
    name: IdentifierExpression,
    /** Array of decorators, if any. */
    decorators: DecoratorNode[] | null,
    /** Common flags indicating specific traits. */
    flags: CommonFlags,
    /** Enum value declarations. */
    public values: EnumValueDeclaration[],
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.ENUMDECLARATION, name, decorators, flags, range);
  }
}

/** Represents a value of an `enum` declaration. */
export class EnumValueDeclaration extends VariableLikeDeclarationStatement {
  constructor(
    /** Simple name being declared. */
    name: IdentifierExpression,
    /** Common flags indicating specific traits. */
    flags: CommonFlags,
    /** Initializer expression, if any. */
    initializer: Expression | null,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.ENUMVALUEDECLARATION, name, null, flags, null, initializer, range);
  }
}

/** Represents an `export import` statement of an interface. */
export class ExportImportStatement extends Statement {
  constructor(
    /** Identifier being imported. */
    public name: IdentifierExpression,
    /** Identifier being exported. */
    public externalName: IdentifierExpression,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.EXPORTIMPORT, range);
  }
}

/** Represents a member of an `export` statement. */
export class ExportMember extends Node {
  constructor(
    /** Local identifier. */
    public localName: IdentifierExpression,
    /** Exported identifier. */
    public exportedName: IdentifierExpression,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.EXPORTMEMBER, range);
  }
}

/** Represents an `export` statement. */
export class ExportStatement extends Statement {
  constructor(
    /** Array of members if a set of named exports, or `null` if a file export. */
    public members: ExportMember[] | null,
    /** Path being exported from, if applicable. */
    public path: StringLiteralExpression | null,
    /** Whether this is a declared export. */
    public isDeclare: bool,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.EXPORT, range);
    if (path) {
      let normalizedPath = normalizePath(path.value);
      if (path.value.startsWith(".")) { // relative
        normalizedPath = resolvePath(normalizedPath, range.source.internalPath);
      } else { // absolute
        if (!normalizedPath.startsWith(LIBRARY_PREFIX)) normalizedPath = LIBRARY_PREFIX + normalizedPath;
      }
      this.internalPath = normalizedPath;
    } else {
      this.internalPath = null;
    }
  }

  /** Internal path being referenced, if `path` is set. */
  internalPath: string | null;
}

/** Represents an `export default` statement. */
export class ExportDefaultStatement extends Statement {
  constructor(
    /** Declaration being exported as default. */
    public declaration: DeclarationStatement,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.EXPORTDEFAULT, range);
  }
}

/** Represents an expression that is used as a statement. */
export class ExpressionStatement extends Statement {
  constructor(
    /** Expression being used as a statement.*/
    public expression: Expression
  ) {
    super(NodeKind.EXPRESSION, expression.range);
  }
}

/** Represents a field declaration within a `class`. */
export class FieldDeclaration extends VariableLikeDeclarationStatement {
  constructor(
    /** Simple name being declared. */
    name: IdentifierExpression,
    /** Array of decorators, if any. */
    decorators: DecoratorNode[] | null,
    /** Common flags indicating specific traits. */
    flags: CommonFlags,
    /** Annotated type node, if any. */
    type: TypeNode | null,
    /** Initializer expression, if any. */
    initializer: Expression | null,
    /** Parameter index if declared as a constructor parameter, otherwise `-1`. */
    public parameterIndex: i32,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.FIELDDECLARATION, name, decorators, flags, type, initializer, range);
  }
}

/** Represents a `for` statement. */
export class ForStatement extends Statement {
  constructor(
    /** Initializer statement, if present. Either a `VariableStatement` or `ExpressionStatement`. */
    public initializer: Statement | null,
    /** Condition expression, if present. */
    public condition: Expression | null,
    /** Incrementor expression, if present. */
    public incrementor: Expression | null,
    /** Statement being looped over. */
    public statement: Statement,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.FOR, range);
  }
}

/** Represents a `for..of` statement. */
export class ForOfStatement extends Statement {
  constructor(
    /** Variable statement. Either a `VariableStatement` or `ExpressionStatement` of `IdentifierExpression`. */
    public variable: Statement,
    /** Iterable expression being iterated. */
    public iterable: Expression,
    /** Statement being looped over. */
    public statement: Statement,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.FOROF, range);
  }
}

/** Indicates the kind of an array function. */
export const enum ArrowKind {
  /** Not an arrow function. */
  NONE,
  /** Parenthesized parameter list. */
  ARROW_PARENTHESIZED,
  /** Single parameter without parenthesis. */
  ARROW_SINGLE
}

/** Represents a `function` declaration. */
export class FunctionDeclaration extends DeclarationStatement {
  constructor(
    /** Simple name being declared. */
    name: IdentifierExpression,
    /** Array of decorators, if any. */
    decorators: DecoratorNode[] | null,
    /** Common flags indicating specific traits. */
    flags: CommonFlags,
    /** Type parameters, if any. */
    public typeParameters: TypeParameterNode[] | null,
    /** Function signature. */
    public signature: FunctionTypeNode,
    /** Body statement. Usually a block. */
    public body: Statement | null,
    /** Arrow function kind, if applicable. */
    public arrowKind: ArrowKind,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.FUNCTIONDECLARATION, name, decorators, flags, range);
  }

  /** Gets if this function is generic. */
  get isGeneric(): bool {
    var typeParameters = this.typeParameters;
    return typeParameters != null && typeParameters.length > 0;
  }

  /** Clones this function declaration. */
  clone(): FunctionDeclaration {
    return new FunctionDeclaration(
      this.name,
      this.decorators,
      this.flags,
      this.typeParameters,
      this.signature,
      this.body,
      this.arrowKind,
      this.range
    );
  }
}

/** Represents an `if` statement. */
export class IfStatement extends Statement {
  constructor(
    /** Condition. */
    public condition: Expression,
    /** Statement executed when condition is `true`. */
    public ifTrue: Statement,
    /** Statement executed when condition is `false`. */
    public ifFalse: Statement | null,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.IF, range);
  }
}

/** Represents an `import` declaration part of an {@link ImportStatement}. */
export class ImportDeclaration extends DeclarationStatement {
  constructor(
    /** Simple name being declared. */
    name: IdentifierExpression,
    /** Identifier being imported. */
    public foreignName: IdentifierExpression,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.IMPORTDECLARATION, name, null, CommonFlags.NONE, range);
  }
}

/** Represents an `import` statement. */
export class ImportStatement extends Statement {
  constructor(
    /** Array of member declarations or `null` if an asterisk import. */
    public declarations: ImportDeclaration[] | null,
    /** Name of the local namespace, if an asterisk import. */
    public namespaceName: IdentifierExpression | null,
    /** Path being imported from. */
    public path: StringLiteralExpression,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.IMPORT, range);
    var normalizedPath = normalizePath(path.value);
    if (path.value.startsWith(".")) { // relative in project
      normalizedPath = resolvePath(normalizedPath, range.source.internalPath);
    } else { // absolute in library
      if (!normalizedPath.startsWith(LIBRARY_PREFIX)) normalizedPath = LIBRARY_PREFIX + normalizedPath;
    }
    this.internalPath = normalizedPath;
  }

  /** Internal path being referenced. */
  internalPath: string;
}

/** Represents an `interfarce` declaration. */
export class InterfaceDeclaration extends ClassDeclaration {
  constructor(
    /** Simple name being declared. */
    name: IdentifierExpression,
    /** Array of decorators, if any. */
    decorators: DecoratorNode[] | null,
    /** Common flags indicating specific traits. */
    flags: CommonFlags,
    /** Accepted type parameters. */
    typeParameters: TypeParameterNode[] | null,
    /** Base class type being extended, if any. */
    extendsType: NamedTypeNode | null, // can't be a function
    /** Interface types being implemented, if any. */
    implementsTypes: NamedTypeNode[] | null, // can't be functions
    /** Class member declarations. */
    members: DeclarationStatement[],
    /** Source range. */
    range: Range
  ) {
    super(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);
    this.kind = NodeKind.INTERFACEDECLARATION;
  }
}

/** Represents a method declaration within a `class`. */
export class MethodDeclaration extends FunctionDeclaration {
  constructor(
    /** Simple name being declared. */
    name: IdentifierExpression,
    /** Array of decorators, if any. */
    decorators: DecoratorNode[] | null,
    /** Common flags indicating specific traits. */
    flags: CommonFlags,
    /** Type parameters, if any. */
    typeParameters: TypeParameterNode[] | null,
    /** Function signature. */
    signature: FunctionTypeNode,
    /** Body statement. Usually a block. */
    body: Statement | null,
    /** Source range. */
    range: Range
  ) {
    super(name, decorators, flags, typeParameters, signature, body, ArrowKind.NONE, range);
    this.kind = NodeKind.METHODDECLARATION;
  }
}

/** Represents a `namespace` declaration. */
export class NamespaceDeclaration extends DeclarationStatement {
  constructor(
    /** Simple name being declared. */
    name: IdentifierExpression,
    /** Array of decorators, if any. */
    decorators: DecoratorNode[] | null,
    /** Common flags indicating specific traits. */
    flags: CommonFlags,
    /** Array of namespace members. */
    public members: Statement[],
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.NAMESPACEDECLARATION, name, decorators, flags, range);
  }
}

/** Represents a `return` statement. */
export class ReturnStatement extends Statement {
  constructor(
    /** Value expression being returned, if present. */
    public value: Expression | null,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.RETURN, range);
  }
}

/** Represents a single `case` within a `switch` statement. */
export class SwitchCase extends Node {
  constructor(
    /** Label expression. `null` indicates the default case. */
    public label: Expression | null,
    /** Contained statements. */
    public statements: Statement[],
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.SWITCHCASE, range);
  }
}

/** Represents a `switch` statement. */
export class SwitchStatement extends Statement {
  constructor(
    /** Condition expression. */
    public condition: Expression,
    /** Contained cases. */
    public cases: SwitchCase[],
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.SWITCH, range);
  }
}

/** Represents a `throw` statement. */
export class ThrowStatement extends Statement {
  constructor(
    /** Value expression being thrown. */
    public value: Expression,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.THROW, range);
  }
}

/** Represents a `try` statement. */
export class TryStatement extends Statement {
  constructor(
    /** Contained statements. */
    public statements: Statement[],
    /** Exception variable name, if a `catch` clause is present. */
    public catchVariable: IdentifierExpression | null,
    /** Statements being executed on catch, if a `catch` clause is present. */
    public catchStatements: Statement[] | null,
    /** Statements being executed afterwards, if a `finally` clause is present. */
    public finallyStatements: Statement[] | null,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.TRY, range);
  }
}

/** Represents a `type` declaration. */
export class TypeDeclaration extends DeclarationStatement {
  constructor(
    /** Simple name being declared. */
    name: IdentifierExpression,
    /** Array of decorators, if any. */
    decorators: DecoratorNode[] | null,
    /** Common flags indicating specific traits. */
    flags: CommonFlags,
    /** Type parameters, if any. */
    public typeParameters: TypeParameterNode[] | null,
    /** Type being aliased. */
    public type: TypeNode,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.TYPEDECLARATION, name, decorators, flags, range);
  }
}

/** Represents a variable declaration part of a {@link VariableStatement}. */
export class VariableDeclaration extends VariableLikeDeclarationStatement {
  constructor(
    /** Simple name being declared. */
    name: IdentifierExpression,
    /** Array of decorators, if any. */
    decorators: DecoratorNode[] | null,
    /** Common flags indicating specific traits. */
    flags: CommonFlags,
    /** Annotated type node, if any. */
    type: TypeNode | null,
    /** Initializer expression, if any. */
    initializer: Expression | null,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.VARIABLEDECLARATION, name, decorators, flags, type, initializer, range);
  }
}

/** Represents a variable statement wrapping {@link VariableDeclaration}s. */
export class VariableStatement extends Statement {
  constructor(
    /** Array of decorators. */
    public decorators: DecoratorNode[] | null,
    /** Array of member declarations. */
    public declarations: VariableDeclaration[],
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.VARIABLE, range);
  }
}

/** Represents a void statement dropping an expression's value. */
export class VoidStatement extends Statement {
  constructor(
    /** Expression being dropped. */
    public expression: Expression,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.VOID, range);
  }
}

/** Represents a `while` statement. */
export class WhileStatement extends Statement {
  constructor(
    /** Condition expression. */
    public condition: Expression,
    /** Statement being looped over. */
    public statement: Statement,
    /** Source range. */
    range: Range
  ) {
    super(NodeKind.WHILE, range);
  }
}

/** Finds the first decorator matching the specified kind. */
export function findDecorator(kind: DecoratorKind, decorators: DecoratorNode[] | null): DecoratorNode | null {
  if (decorators) {
    for (let i = 0, k = decorators.length; i < k; ++i) {
      let decorator = decorators[i];
      if (decorator.decoratorKind == kind) return decorator;
    }
  }
  return null;
}

/** Mangles an external to an internal path. */
export function mangleInternalPath(path: string): string {
  var pos = path.lastIndexOf(".");
  var len = path.length;
  if (pos >= 0 && len - pos >= 2) { // at least one char plus dot
    let cur = pos;
    while (++cur < len) {
      if (!isTrivialAlphanum(path.charCodeAt(cur))) {
        assert(false); // not a valid external path
        return path;
      }
    }
    return path.substring(0, pos);
  }
  assert(false); // not an external path
  return path;
}

/** Tests if the specified type node represents an omitted type. */
export function isTypeOmitted(type: TypeNode): bool {
  if (type.kind == NodeKind.NAMEDTYPE) {
    let name = (<NamedTypeNode>type).name;
    return !(name.next !== null || name.identifier.text.length > 0);
  }
  return false;
}

'''
'''--- src/builtins.ts ---
/**
 * @fileoverview Built-in elements providing core WebAssembly functionality.
 *
 * Each builtin is linked to its definition in std/assembly/builtins.ts.
 * When its prototype is called, the compiler recognizes the `@builtin`
 * decorator, looks up the respective handler in the global builtins map
 * and executes it, with the handler directly emitting WebAssembly code
 * according to context.
 *
 * Builtins can be categorized into core builtins that typically are generic
 * and emit code directly and aliases calling core builtins with overridden
 * contexts. The latter is used by inline assembler aliases of WebAssembly
 * instructions, like `i64.load8_u` deferring to `<i64>load<u8>`.
 *
 * The `contextIsExact` modifier is used to force a specific instruction
 * family. A `i32.store8` deferring to `<i32>store<i8>` for example is
 * ambiguous in that the input can still be an i32 or an i64, leading to
 * either an `i32.store8` or an `i64.store8`, so `i32` is forced there.
 * This behavior is indicated by `from i32/i64` in the comments below.
 *
 * @license Apache-2.0
 */

// TODO: Add builtins for `i32.add` etc. that do not have a core builtin.

import {
  Compiler,
  Constraints,
  RuntimeFeatures
} from "./compiler";

import {
  DiagnosticCode,
  DiagnosticCategory
} from "./diagnostics";

import {
  Expression,
  LiteralKind,
  StringLiteralExpression,
  CallExpression,
  NodeKind,
  LiteralExpression,
  ArrayLiteralExpression
} from "./ast";

import {
  Type,
  TypeKind,
  TypeFlags
} from "./types";

import {
  BinaryOp,
  UnaryOp,
  AtomicRMWOp,
  SIMDExtractOp,
  SIMDReplaceOp,
  SIMDShiftOp,
  SIMDTernaryOp,
  SIMDLoadOp,
  SIMDLoadStoreLaneOp,
  RefIsOp,
  TypeRef,
  ExpressionRef,
  ExpressionId,
  getExpressionId,
  getExpressionType,
  getConstValueI64High,
  getConstValueI64Low,
  getConstValueI32,
  getConstValueF32,
  getConstValueF64,
  getLocalGetIndex,
  createType,
  ExpressionRunnerFlags
} from "./module";

import {
  ElementKind,
  FunctionPrototype,
  Field,
  Global,
  DecoratorFlags,
  ClassPrototype,
  Class
} from "./program";

import {
  findUsedLocals,
  FlowFlags,
  LocalFlags
} from "./flow";

import {
  ReportMode
} from "./resolver";

import {
  CommonFlags,
  Feature,
  featureToString,
  TypeinfoFlags
} from "./common";

import {
  writeI8,
  writeI16,
  writeI32,
  writeF32,
  writeF64,
  isPowerOf2
} from "./util";

/** Internal names of various compiler built-ins. */
export namespace BuiltinNames {

  // compiler-generated
  export const start = "~start";
  export const started = "~started";
  export const argumentsLength = "~argumentsLength";
  export const setArgumentsLength = "~setArgumentsLength";

  // std/builtins.ts
  export const abort = "~lib/builtins/abort";
  export const trace = "~lib/builtins/trace";
  export const seed = "~lib/builtins/seed";

  export const isInteger = "~lib/builtins/isInteger";
  export const isFloat = "~lib/builtins/isFloat";
  export const isBoolean = "~lib/builtins/isBoolean";
  export const isSigned = "~lib/builtins/isSigned";
  export const isReference = "~lib/builtins/isReference";
  export const isString = "~lib/builtins/isString";
  export const isArray = "~lib/builtins/isArray";
  export const isArrayLike = "~lib/builtins/isArrayLike";
  export const isFunction = "~lib/builtins/isFunction";
  export const isNullable = "~lib/builtins/isNullable";
  export const isDefined = "~lib/builtins/isDefined";
  export const isConstant = "~lib/builtins/isConstant";
  export const isManaged = "~lib/builtins/isManaged";
  export const isVoid = "~lib/builtins/isVoid";

  export const add = "~lib/builtins/add";
  export const sub = "~lib/builtins/sub";
  export const mul = "~lib/builtins/mul";
  export const div = "~lib/builtins/div";
  export const clz = "~lib/builtins/clz";
  export const ctz = "~lib/builtins/ctz";
  export const popcnt = "~lib/builtins/popcnt";
  export const rotl = "~lib/builtins/rotl";
  export const rotr = "~lib/builtins/rotr";
  export const abs = "~lib/builtins/abs";
  export const max = "~lib/builtins/max";
  export const min = "~lib/builtins/min";
  export const ceil = "~lib/builtins/ceil";
  export const floor = "~lib/builtins/floor";
  export const copysign = "~lib/builtins/copysign";
  export const nearest = "~lib/builtins/nearest";
  export const reinterpret = "~lib/builtins/reinterpret";
  export const sqrt = "~lib/builtins/sqrt";
  export const trunc = "~lib/builtins/trunc";
  export const load = "~lib/builtins/load";
  export const store = "~lib/builtins/store";
  export const atomic_load = "~lib/builtins/atomic.load";
  export const atomic_store = "~lib/builtins/atomic.store";
  export const atomic_add = "~lib/builtins/atomic.add";
  export const atomic_sub = "~lib/builtins/atomic.sub";
  export const atomic_and = "~lib/builtins/atomic.and";
  export const atomic_or = "~lib/builtins/atomic.or";
  export const atomic_xor = "~lib/builtins/atomic.xor";
  export const atomic_xchg = "~lib/builtins/atomic.xchg";
  export const atomic_cmpxchg = "~lib/builtins/atomic.cmpxchg";
  export const atomic_wait = "~lib/builtins/atomic.wait";
  export const atomic_notify = "~lib/builtins/atomic.notify";
  export const atomic_fence = "~lib/builtins/atomic.fence";

  export const sizeof = "~lib/builtins/sizeof";
  export const alignof = "~lib/builtins/alignof";
  export const offsetof = "~lib/builtins/offsetof";
  export const nameof = "~lib/builtins/nameof";
  export const lengthof = "~lib/builtins/lengthof";
  export const select = "~lib/builtins/select";
  export const unreachable = "~lib/builtins/unreachable";
  export const changetype = "~lib/builtins/changetype";
  export const assert = "~lib/builtins/assert";
  export const call_indirect = "~lib/builtins/call_indirect";
  export const unchecked = "~lib/builtins/unchecked";
  export const instantiate = "~lib/builtins/instantiate";
  export const idof = "~lib/builtins/idof";

  export const i8 = "~lib/builtins/i8";
  export const i16 = "~lib/builtins/i16";
  export const i32 = "~lib/builtins/i32";
  export const i64 = "~lib/builtins/i64";
  export const isize = "~lib/builtins/isize";
  export const u8 = "~lib/builtins/u8";
  export const u16 = "~lib/builtins/u16";
  export const u32 = "~lib/builtins/u32";
  export const u64 = "~lib/builtins/u64";
  export const usize = "~lib/builtins/usize";
  export const bool = "~lib/builtins/bool";
  export const f32 = "~lib/builtins/f32";
  export const f64 = "~lib/builtins/f64";
  export const v128 = "~lib/builtins/v128";

  export const i32_clz = "~lib/builtins/i32.clz";
  export const i64_clz = "~lib/builtins/i64.clz";
  export const i32_ctz = "~lib/builtins/i32.ctz";
  export const i64_ctz = "~lib/builtins/i64.ctz";
  export const i32_popcnt = "~lib/builtins/i32.popcnt";
  export const i64_popcnt = "~lib/builtins/i64.popcnt";
  export const i32_rotl = "~lib/builtins/i32.rotl";
  export const i64_rotl = "~lib/builtins/i64.rotl";
  export const i32_rotr = "~lib/builtins/i32.rotr";
  export const i64_rotr = "~lib/builtins/i64.rotr";

  export const f32_abs = "~lib/builtins/f32.abs";
  export const f64_abs = "~lib/builtins/f64.abs";
  export const f32_max = "~lib/builtins/f32.max";
  export const f64_max = "~lib/builtins/f64.max";
  export const f32_min = "~lib/builtins/f32.min";
  export const f64_min = "~lib/builtins/f64.min";
  export const f32_ceil = "~lib/builtins/f32.ceil";
  export const f64_ceil = "~lib/builtins/f64.ceil";
  export const f32_floor = "~lib/builtins/f32.floor";
  export const f64_floor = "~lib/builtins/f64.floor";
  export const f32_copysign = "~lib/builtins/f32.copysign";
  export const f64_copysign = "~lib/builtins/f64.copysign";
  export const f32_nearest = "~lib/builtins/f32.nearest";
  export const f64_nearest = "~lib/builtins/f64.nearest";
  export const i32_reinterpret_f32 = "~lib/builtins/i32.reinterpret_f32";
  export const i64_reinterpret_f64 = "~lib/builtins/i64.reinterpret_f64";
  export const f32_reinterpret_i32 = "~lib/builtins/f32.reinterpret_i32";
  export const f64_reinterpret_i64 = "~lib/builtins/f64.reinterpret_i64";
  export const f32_sqrt = "~lib/builtins/f32.sqrt";
  export const f64_sqrt = "~lib/builtins/f64.sqrt";
  export const f32_trunc = "~lib/builtins/f32.trunc";
  export const f64_trunc = "~lib/builtins/f64.trunc";

  export const i32_add = "~lib/builtins/i32.add";
  export const i64_add = "~lib/builtins/i64.add";
  export const f32_add = "~lib/builtins/f32.add";
  export const f64_add = "~lib/builtins/f64.add";
  export const i32_sub = "~lib/builtins/i32.sub";
  export const i64_sub = "~lib/builtins/i64.sub";
  export const f32_sub = "~lib/builtins/f32.sub";
  export const f64_sub = "~lib/builtins/f64.sub";
  export const i32_mul = "~lib/builtins/i32.mul";
  export const i64_mul = "~lib/builtins/i64.mul";
  export const f32_mul = "~lib/builtins/f32.mul";
  export const f64_mul = "~lib/builtins/f64.mul";
  export const i32_div_s = "~lib/builtins/i32.div_s";
  export const i32_div_u = "~lib/builtins/i32.div_u";
  export const i64_div_s = "~lib/builtins/i64.div_s";
  export const i64_div_u = "~lib/builtins/i64.div_u";
  export const f32_div = "~lib/builtins/f32.div";
  export const f64_div = "~lib/builtins/f64.div";

  export const i32_load8_s = "~lib/builtins/i32.load8_s";
  export const i32_load8_u = "~lib/builtins/i32.load8_u";
  export const i32_load16_s = "~lib/builtins/i32.load16_s";
  export const i32_load16_u = "~lib/builtins/i32.load16_u";
  export const i32_load = "~lib/builtins/i32.load";
  export const i64_load8_s = "~lib/builtins/i64.load8_s";
  export const i64_load8_u = "~lib/builtins/i64.load8_u";
  export const i64_load16_s = "~lib/builtins/i64.load16_s";
  export const i64_load16_u = "~lib/builtins/i64.load16_u";
  export const i64_load32_s = "~lib/builtins/i64.load32_s";
  export const i64_load32_u = "~lib/builtins/i64.load32_u";
  export const i64_load = "~lib/builtins/i64.load";
  export const f32_load = "~lib/builtins/f32.load";
  export const f64_load = "~lib/builtins/f64.load";
  export const i32_store8 = "~lib/builtins/i32.store8";
  export const i32_store16 = "~lib/builtins/i32.store16";
  export const i32_store = "~lib/builtins/i32.store";
  export const i64_store8 = "~lib/builtins/i64.store8";
  export const i64_store16 = "~lib/builtins/i64.store16";
  export const i64_store32 = "~lib/builtins/i64.store32";
  export const i64_store = "~lib/builtins/i64.store";
  export const f32_store = "~lib/builtins/f32.store";
  export const f64_store = "~lib/builtins/f64.store";

  export const i32_atomic_load8_u = "~lib/builtins/i32.atomic.load8_u";
  export const i32_atomic_load16_u = "~lib/builtins/i32.atomic.load16_u";
  export const i32_atomic_load = "~lib/builtins/i32.atomic.load";
  export const i64_atomic_load8_u = "~lib/builtins/i64.atomic.load8_u";
  export const i64_atomic_load16_u = "~lib/builtins/i64.atomic.load16_u";
  export const i64_atomic_load32_u = "~lib/builtins/i64.atomic.load32_u";
  export const i64_atomic_load = "~lib/builtins/i64.atomic.load";
  export const i32_atomic_store8 = "~lib/builtins/i32.atomic.store8";
  export const i32_atomic_store16 = "~lib/builtins/i32.atomic.store16";
  export const i32_atomic_store = "~lib/builtins/i32.atomic.store";
  export const i64_atomic_store8 = "~lib/builtins/i64.atomic.store8";
  export const i64_atomic_store16 = "~lib/builtins/i64.atomic.store16";
  export const i64_atomic_store32 = "~lib/builtins/i64.atomic.store32";
  export const i64_atomic_store = "~lib/builtins/i64.atomic.store";
  export const i32_atomic_rmw8_add_u = "~lib/builtins/i32.atomic.rmw8.add_u";
  export const i32_atomic_rmw16_add_u = "~lib/builtins/i32.atomic.rmw16.add_u";
  export const i32_atomic_rmw_add = "~lib/builtins/i32.atomic.rmw.add";
  export const i64_atomic_rmw8_add_u = "~lib/builtins/i64.atomic.rmw8.add_u";
  export const i64_atomic_rmw16_add_u = "~lib/builtins/i64.atomic.rmw16.add_u";
  export const i64_atomic_rmw32_add_u = "~lib/builtins/i64.atomic.rmw32.add_u";
  export const i64_atomic_rmw_add = "~lib/builtins/i64.atomic.rmw.add";
  export const i32_atomic_rmw8_sub_u = "~lib/builtins/i32.atomic.rmw8.sub_u";
  export const i32_atomic_rmw16_sub_u = "~lib/builtins/i32.atomic.rmw16.sub_u";
  export const i32_atomic_rmw_sub = "~lib/builtins/i32.atomic.rmw.sub";
  export const i64_atomic_rmw8_sub_u = "~lib/builtins/i64.atomic.rmw8.sub_u";
  export const i64_atomic_rmw16_sub_u = "~lib/builtins/i64.atomic.rmw16.sub_u";
  export const i64_atomic_rmw32_sub_u = "~lib/builtins/i64.atomic.rmw32.sub_u";
  export const i64_atomic_rmw_sub = "~lib/builtins/i64.atomic.rmw.sub";
  export const i32_atomic_rmw8_and_u = "~lib/builtins/i32.atomic.rmw8.and_u";
  export const i32_atomic_rmw16_and_u = "~lib/builtins/i32.atomic.rmw16.and_u";
  export const i32_atomic_rmw_and = "~lib/builtins/i32.atomic.rmw.and";
  export const i64_atomic_rmw8_and_u = "~lib/builtins/i64.atomic.rmw8.and_u";
  export const i64_atomic_rmw16_and_u = "~lib/builtins/i64.atomic.rmw16.and_u";
  export const i64_atomic_rmw32_and_u = "~lib/builtins/i64.atomic.rmw32.and_u";
  export const i64_atomic_rmw_and = "~lib/builtins/i64.atomic.rmw.and";
  export const i32_atomic_rmw8_or_u = "~lib/builtins/i32.atomic.rmw8.or_u";
  export const i32_atomic_rmw16_or_u = "~lib/builtins/i32.atomic.rmw16.or_u";
  export const i32_atomic_rmw_or = "~lib/builtins/i32.atomic.rmw.or";
  export const i64_atomic_rmw8_or_u = "~lib/builtins/i64.atomic.rmw8.or_u";
  export const i64_atomic_rmw16_or_u = "~lib/builtins/i64.atomic.rmw16.or_u";
  export const i64_atomic_rmw32_or_u = "~lib/builtins/i64.atomic.rmw32.or_u";
  export const i64_atomic_rmw_or = "~lib/builtins/i64.atomic.rmw.or";
  export const i32_atomic_rmw8_xor_u = "~lib/builtins/i32.atomic.rmw8.xor_u";
  export const i32_atomic_rmw16_xor_u = "~lib/builtins/i32.atomic.rmw16.xor_u";
  export const i32_atomic_rmw_xor = "~lib/builtins/i32.atomic.rmw.xor";
  export const i64_atomic_rmw8_xor_u = "~lib/builtins/i64.atomic.rmw8.xor_u";
  export const i64_atomic_rmw16_xor_u = "~lib/builtins/i64.atomic.rmw16.xor_u";
  export const i64_atomic_rmw32_xor_u = "~lib/builtins/i64.atomic.rmw32.xor_u";
  export const i64_atomic_rmw_xor = "~lib/builtins/i64.atomic.rmw.xor";
  export const i32_atomic_rmw8_xchg_u = "~lib/builtins/i32.atomic.rmw8.xchg_u";
  export const i32_atomic_rmw16_xchg_u = "~lib/builtins/i32.atomic.rmw16.xchg_u";
  export const i32_atomic_rmw_xchg = "~lib/builtins/i32.atomic.rmw.xchg";
  export const i64_atomic_rmw8_xchg_u = "~lib/builtins/i64.atomic.rmw8.xchg_u";
  export const i64_atomic_rmw16_xchg_u = "~lib/builtins/i64.atomic.rmw16.xchg_u";
  export const i64_atomic_rmw32_xchg_u = "~lib/builtins/i64.atomic.rmw32.xchg_u";
  export const i64_atomic_rmw_xchg = "~lib/builtins/i64.atomic.rmw.xchg";
  export const i32_atomic_rmw8_cmpxchg_u = "~lib/builtins/i32.atomic.rmw8.cmpxchg_u";
  export const i32_atomic_rmw16_cmpxchg_u = "~lib/builtins/i32.atomic.rmw16.cmpxchg_u";
  export const i32_atomic_rmw_cmpxchg = "~lib/builtins/i32.atomic.rmw.cmpxchg";
  export const i64_atomic_rmw8_cmpxchg_u = "~lib/builtins/i64.atomic.rmw8.cmpxchg_u";
  export const i64_atomic_rmw16_cmpxchg_u = "~lib/builtins/i64.atomic.rmw16.cmpxchg_u";
  export const i64_atomic_rmw32_cmpxchg_u = "~lib/builtins/i64.atomic.rmw32.cmpxchg_u";
  export const i64_atomic_rmw_cmpxchg = "~lib/builtins/i64.atomic.rmw.cmpxchg";
  export const i32_wait = "~lib/builtins/i32.wait";
  export const i64_wait = "~lib/builtins/i64.wait";

  export const v128_splat = "~lib/builtins/v128.splat";
  export const v128_extract_lane = "~lib/builtins/v128.extract_lane";
  export const v128_replace_lane = "~lib/builtins/v128.replace_lane";
  export const v128_shuffle = "~lib/builtins/v128.shuffle";
  export const v128_swizzle = "~lib/builtins/v128.swizzle";
  export const v128_load_splat = "~lib/builtins/v128.load_splat";
  export const v128_load_ext = "~lib/builtins/v128.load_ext";
  export const v128_load_zero = "~lib/builtins/v128.load_zero";
  export const v128_load_lane = "~lib/builtins/v128.load_lane";
  export const v128_store_lane = "~lib/builtins/v128.store_lane";
  export const v128_load = "~lib/builtins/v128.load";
  export const v128_load8x8_s = "~lib/builtins/v128.load8x8_s";
  export const v128_load8x8_u = "~lib/builtins/v128.load8x8_u";
  export const v128_load16x4_s = "~lib/builtins/v128.load16x4_s";
  export const v128_load16x4_u = "~lib/builtins/v128.load16x4_u";
  export const v128_load32x2_s = "~lib/builtins/v128.load32x2_s";
  export const v128_load32x2_u = "~lib/builtins/v128.load32x2_u";
  export const v128_load8_splat = "~lib/builtins/v128.load8_splat";
  export const v128_load16_splat = "~lib/builtins/v128.load16_splat";
  export const v128_load32_splat = "~lib/builtins/v128.load32_splat";
  export const v128_load64_splat = "~lib/builtins/v128.load64_splat";
  export const v128_load32_zero = "~lib/builtins/v128.load32_zero";
  export const v128_load64_zero = "~lib/builtins/v128.load64_zero";
  export const v128_load8_lane = "~lib/builtins/v128.load8_lane";
  export const v128_load16_lane = "~lib/builtins/v128.load16_lane";
  export const v128_load32_lane = "~lib/builtins/v128.load32_lane";
  export const v128_load64_lane = "~lib/builtins/v128.load64_lane";
  export const v128_store8_lane = "~lib/builtins/v128.store8_lane";
  export const v128_store16_lane = "~lib/builtins/v128.store16_lane";
  export const v128_store32_lane = "~lib/builtins/v128.store32_lane";
  export const v128_store64_lane = "~lib/builtins/v128.store64_lane";
  export const v128_store = "~lib/builtins/v128.store";
  export const v128_add = "~lib/builtins/v128.add";
  export const v128_sub = "~lib/builtins/v128.sub";
  export const v128_mul = "~lib/builtins/v128.mul";
  export const v128_div = "~lib/builtins/v128.div";
  export const v128_neg = "~lib/builtins/v128.neg";
  export const v128_add_sat = "~lib/builtins/v128.add_sat";
  export const v128_sub_sat = "~lib/builtins/v128.sub_sat";
  export const v128_shl = "~lib/builtins/v128.shl";
  export const v128_shr = "~lib/builtins/v128.shr";
  export const v128_and = "~lib/builtins/v128.and";
  export const v128_or = "~lib/builtins/v128.or";
  export const v128_xor = "~lib/builtins/v128.xor";
  export const v128_andnot = "~lib/builtins/v128.andnot";
  export const v128_not = "~lib/builtins/v128.not";
  export const v128_bitselect = "~lib/builtins/v128.bitselect";
  export const v128_any_true = "~lib/builtins/v128.any_true";
  export const v128_all_true = "~lib/builtins/v128.all_true";
  export const v128_bitmask = "~lib/builtins/v128.bitmask";
  export const v128_popcnt = "~lib/builtins/v128.popcnt";
  export const v128_min = "~lib/builtins/v128.min";
  export const v128_max = "~lib/builtins/v128.max";
  export const v128_pmin = "~lib/builtins/v128.pmin";
  export const v128_pmax = "~lib/builtins/v128.pmax";
  export const v128_dot = "~lib/builtins/v128.dot";
  export const v128_avgr = "~lib/builtins/v128.avgr";
  export const v128_abs = "~lib/builtins/v128.abs";
  export const v128_sqrt = "~lib/builtins/v128.sqrt";
  export const v128_ceil = "~lib/builtins/v128.ceil";
  export const v128_floor = "~lib/builtins/v128.floor";
  export const v128_trunc = "~lib/builtins/v128.trunc";
  export const v128_nearest = "~lib/builtins/v128.nearest";
  export const v128_eq = "~lib/builtins/v128.eq";
  export const v128_ne = "~lib/builtins/v128.ne";
  export const v128_lt = "~lib/builtins/v128.lt";
  export const v128_le = "~lib/builtins/v128.le";
  export const v128_gt = "~lib/builtins/v128.gt";
  export const v128_ge = "~lib/builtins/v128.ge";
  export const v128_convert = "~lib/builtins/v128.convert";
  export const v128_convert_low = "~lib/builtins/v128.convert_low";
  export const v128_trunc_sat = "~lib/builtins/v128.trunc_sat";
  export const v128_trunc_sat_zero = "~lib/builtins/v128.trunc_sat_zero";
  export const v128_narrow = "~lib/builtins/v128.narrow";
  export const v128_extend_low = "~lib/builtins/v128.extend_low";
  export const v128_extend_high = "~lib/builtins/v128.extend_high";
  export const v128_extadd_pairwise = "~lib/builtins/v128.extadd_pairwise";
  export const v128_demote_zero = "~lib/builtins/v128.demote_zero";
  export const v128_promote_low = "~lib/builtins/v128.promote_low";
  export const v128_q15mulr_sat = "~lib/builtins/v128.q15mulr_sat";
  export const v128_extmul_low = "~lib/builtins/v128.extmul_low";
  export const v128_extmul_high = "~lib/builtins/v128.extmul_high";

  export const i8x16 = "~lib/builtins/i8x16";
  export const i16x8 = "~lib/builtins/i16x8";
  export const i32x4 = "~lib/builtins/i32x4";
  export const i64x2 = "~lib/builtins/i64x2";
  export const f32x4 = "~lib/builtins/f32x4";
  export const f64x2 = "~lib/builtins/f64x2";

  export const i8x16_splat = "~lib/builtins/i8x16.splat";
  export const i8x16_extract_lane_s = "~lib/builtins/i8x16.extract_lane_s";
  export const i8x16_extract_lane_u = "~lib/builtins/i8x16.extract_lane_u";
  export const i8x16_replace_lane = "~lib/builtins/i8x16.replace_lane";
  export const i8x16_add = "~lib/builtins/i8x16.add";
  export const i8x16_sub = "~lib/builtins/i8x16.sub";
  export const i8x16_mul = "~lib/builtins/i8x16.mul";
  export const i8x16_min_s = "~lib/builtins/i8x16.min_s";
  export const i8x16_min_u = "~lib/builtins/i8x16.min_u";
  export const i8x16_max_s = "~lib/builtins/i8x16.max_s";
  export const i8x16_max_u = "~lib/builtins/i8x16.max_u";
  export const i8x16_avgr_u = "~lib/builtins/i8x16.avgr_u";
  export const i8x16_abs = "~lib/builtins/i8x16.abs";
  export const i8x16_neg = "~lib/builtins/i8x16.neg";
  export const i8x16_add_sat_s = "~lib/builtins/i8x16.add_sat_s";
  export const i8x16_add_sat_u = "~lib/builtins/i8x16.add_sat_u";
  export const i8x16_sub_sat_s = "~lib/builtins/i8x16.sub_sat_s";
  export const i8x16_sub_sat_u = "~lib/builtins/i8x16.sub_sat_u";
  export const i8x16_shl = "~lib/builtins/i8x16.shl";
  export const i8x16_shr_s = "~lib/builtins/i8x16.shr_s";
  export const i8x16_shr_u = "~lib/builtins/i8x16.shr_u";
  export const i8x16_all_true = "~lib/builtins/i8x16.all_true";
  export const i8x16_bitmask = "~lib/builtins/i8x16.bitmask";
  export const i8x16_popcnt = "~lib/builtins/i8x16.popcnt";
  export const i8x16_eq = "~lib/builtins/i8x16.eq";
  export const i8x16_ne = "~lib/builtins/i8x16.ne";
  export const i8x16_lt_s = "~lib/builtins/i8x16.lt_s";
  export const i8x16_lt_u = "~lib/builtins/i8x16.lt_u";
  export const i8x16_le_s = "~lib/builtins/i8x16.le_s";
  export const i8x16_le_u = "~lib/builtins/i8x16.le_u";
  export const i8x16_gt_s = "~lib/builtins/i8x16.gt_s";
  export const i8x16_gt_u = "~lib/builtins/i8x16.gt_u";
  export const i8x16_ge_s = "~lib/builtins/i8x16.ge_s";
  export const i8x16_ge_u = "~lib/builtins/i8x16.ge_u";
  export const i8x16_narrow_i16x8_s = "~lib/builtins/i8x16.narrow_i16x8_s";
  export const i8x16_narrow_i16x8_u = "~lib/builtins/i8x16.narrow_i16x8_u";
  export const i8x16_shuffle = "~lib/builtins/i8x16.shuffle";
  export const i8x16_swizzle = "~lib/builtins/i8x16.swizzle";

  export const i16x8_splat = "~lib/builtins/i16x8.splat";
  export const i16x8_extract_lane_s = "~lib/builtins/i16x8.extract_lane_s";
  export const i16x8_extract_lane_u = "~lib/builtins/i16x8.extract_lane_u";
  export const i16x8_replace_lane = "~lib/builtins/i16x8.replace_lane";
  export const i16x8_add = "~lib/builtins/i16x8.add";
  export const i16x8_sub = "~lib/builtins/i16x8.sub";
  export const i16x8_mul = "~lib/builtins/i16x8.mul";
  export const i16x8_min_s = "~lib/builtins/i16x8.min_s";
  export const i16x8_min_u = "~lib/builtins/i16x8.min_u";
  export const i16x8_max_s = "~lib/builtins/i16x8.max_s";
  export const i16x8_max_u = "~lib/builtins/i16x8.max_u";
  export const i16x8_avgr_u = "~lib/builtins/i16x8.avgr_u";
  export const i16x8_abs = "~lib/builtins/i16x8.abs";
  export const i16x8_neg = "~lib/builtins/i16x8.neg";
  export const i16x8_add_sat_s = "~lib/builtins/i16x8.add_sat_s";
  export const i16x8_add_sat_u = "~lib/builtins/i16x8.add_sat_u";
  export const i16x8_sub_sat_s = "~lib/builtins/i16x8.sub_sat_s";
  export const i16x8_sub_sat_u = "~lib/builtins/i16x8.sub_sat_u";
  export const i16x8_shl = "~lib/builtins/i16x8.shl";
  export const i16x8_shr_s = "~lib/builtins/i16x8.shr_s";
  export const i16x8_shr_u = "~lib/builtins/i16x8.shr_u";
  export const i16x8_all_true = "~lib/builtins/i16x8.all_true";
  export const i16x8_bitmask = "~lib/builtins/i16x8.bitmask";
  export const i16x8_eq = "~lib/builtins/i16x8.eq";
  export const i16x8_ne = "~lib/builtins/i16x8.ne";
  export const i16x8_lt_s = "~lib/builtins/i16x8.lt_s";
  export const i16x8_lt_u = "~lib/builtins/i16x8.lt_u";
  export const i16x8_le_s = "~lib/builtins/i16x8.le_s";
  export const i16x8_le_u = "~lib/builtins/i16x8.le_u";
  export const i16x8_gt_s = "~lib/builtins/i16x8.gt_s";
  export const i16x8_gt_u = "~lib/builtins/i16x8.gt_u";
  export const i16x8_ge_s = "~lib/builtins/i16x8.ge_s";
  export const i16x8_ge_u = "~lib/builtins/i16x8.ge_u";
  export const i16x8_narrow_i32x4_s = "~lib/builtins/i16x8.narrow_i32x4_s";
  export const i16x8_narrow_i32x4_u = "~lib/builtins/i16x8.narrow_i32x4_u";
  export const i16x8_extend_low_i8x16_s = "~lib/builtins/i16x8.extend_low_i8x16_s";
  export const i16x8_extend_low_i8x16_u = "~lib/builtins/i16x8.extend_low_i8x16_u";
  export const i16x8_extend_high_i8x16_s = "~lib/builtins/i16x8.extend_high_i8x16_s";
  export const i16x8_extend_high_i8x16_u = "~lib/builtins/i16x8.extend_high_i8x16_u";
  export const i16x8_extadd_pairwise_i8x16_s = "~lib/builtins/i16x8.extadd_pairwise_i8x16_s";
  export const i16x8_extadd_pairwise_i8x16_u = "~lib/builtins/i16x8.extadd_pairwise_i8x16_u";
  export const i16x8_q15mulr_sat_s = "~lib/builtins/i16x8.q15mulr_sat_s";
  export const i16x8_extmul_low_i8x16_s = "~lib/builtins/i16x8.extmul_low_i8x16_s";
  export const i16x8_extmul_low_i8x16_u = "~lib/builtins/i16x8.extmul_low_i8x16_u";
  export const i16x8_extmul_high_i8x16_s = "~lib/builtins/i16x8.extmul_high_i8x16_s";
  export const i16x8_extmul_high_i8x16_u = "~lib/builtins/i16x8.extmul_high_i8x16_u";

  export const i32x4_splat = "~lib/builtins/i32x4.splat";
  export const i32x4_extract_lane = "~lib/builtins/i32x4.extract_lane";
  export const i32x4_replace_lane = "~lib/builtins/i32x4.replace_lane";
  export const i32x4_add = "~lib/builtins/i32x4.add";
  export const i32x4_sub = "~lib/builtins/i32x4.sub";
  export const i32x4_mul = "~lib/builtins/i32x4.mul";
  export const i32x4_min_s = "~lib/builtins/i32x4.min_s";
  export const i32x4_min_u = "~lib/builtins/i32x4.min_u";
  export const i32x4_max_s = "~lib/builtins/i32x4.max_s";
  export const i32x4_max_u = "~lib/builtins/i32x4.max_u";
  export const i32x4_dot_i16x8_s = "~lib/builtins/i32x4.dot_i16x8_s";
  export const i32x4_abs = "~lib/builtins/i32x4.abs";
  export const i32x4_neg = "~lib/builtins/i32x4.neg";
  export const i32x4_shl = "~lib/builtins/i32x4.shl";
  export const i32x4_shr_s = "~lib/builtins/i32x4.shr_s";
  export const i32x4_shr_u = "~lib/builtins/i32x4.shr_u";
  export const i32x4_all_true = "~lib/builtins/i32x4.all_true";
  export const i32x4_bitmask = "~lib/builtins/i32x4.bitmask";
  export const i32x4_eq = "~lib/builtins/i32x4.eq";
  export const i32x4_ne = "~lib/builtins/i32x4.ne";
  export const i32x4_lt_s = "~lib/builtins/i32x4.lt_s";
  export const i32x4_lt_u = "~lib/builtins/i32x4.lt_u";
  export const i32x4_le_s = "~lib/builtins/i32x4.le_s";
  export const i32x4_le_u = "~lib/builtins/i32x4.le_u";
  export const i32x4_gt_s = "~lib/builtins/i32x4.gt_s";
  export const i32x4_gt_u = "~lib/builtins/i32x4.gt_u";
  export const i32x4_ge_s = "~lib/builtins/i32x4.ge_s";
  export const i32x4_ge_u = "~lib/builtins/i32x4.ge_u";
  export const i32x4_trunc_sat_f32x4_s = "~lib/builtins/i32x4.trunc_sat_f32x4_s";
  export const i32x4_trunc_sat_f32x4_u = "~lib/builtins/i32x4.trunc_sat_f32x4_u";
  export const i32x4_trunc_sat_f64x2_s_zero = "~lib/builtins/i32x4.trunc_sat_f64x2_s_zero";
  export const i32x4_trunc_sat_f64x2_u_zero = "~lib/builtins/i32x4.trunc_sat_f64x2_u_zero";
  export const i32x4_extend_low_i16x8_s = "~lib/builtins/i32x4.extend_low_i16x8_s";
  export const i32x4_extend_low_i16x8_u = "~lib/builtins/i32x4.extend_low_i16x8_u";
  export const i32x4_extend_high_i16x8_s = "~lib/builtins/i32x4.extend_high_i16x8_s";
  export const i32x4_extend_high_i16x8_u = "~lib/builtins/i32x4.extend_high_i16x8_u";
  export const i32x4_extadd_pairwise_i16x8_s = "~lib/builtins/i32x4.extadd_pairwise_i16x8_s";
  export const i32x4_extadd_pairwise_i16x8_u = "~lib/builtins/i32x4.extadd_pairwise_i16x8_u";
  export const i32x4_extmul_low_i16x8_s = "~lib/builtins/i32x4.extmul_low_i16x8_s";
  export const i32x4_extmul_low_i16x8_u = "~lib/builtins/i32x4.extmul_low_i16x8_u";
  export const i32x4_extmul_high_i16x8_s = "~lib/builtins/i32x4.extmul_high_i16x8_s";
  export const i32x4_extmul_high_i16x8_u = "~lib/builtins/i32x4.extmul_high_i16x8_u";

  export const i64x2_splat = "~lib/builtins/i64x2.splat";
  export const i64x2_extract_lane = "~lib/builtins/i64x2.extract_lane";
  export const i64x2_replace_lane = "~lib/builtins/i64x2.replace_lane";
  export const i64x2_add = "~lib/builtins/i64x2.add";
  export const i64x2_sub = "~lib/builtins/i64x2.sub";
  export const i64x2_mul = "~lib/builtins/i64x2.mul";
  export const i64x2_abs = "~lib/builtins/i64x2.abs";
  export const i64x2_neg = "~lib/builtins/i64x2.neg";
  export const i64x2_shl = "~lib/builtins/i64x2.shl";
  export const i64x2_shr_s = "~lib/builtins/i64x2.shr_s";
  export const i64x2_shr_u = "~lib/builtins/i64x2.shr_u";
  export const i64x2_all_true = "~lib/builtins/i64x2.all_true";
  export const i64x2_bitmask = "~lib/builtins/i64x2.bitmask";
  export const i64x2_eq = "~lib/builtins/i64x2.eq";
  export const i64x2_ne = "~lib/builtins/i64x2.ne";
  export const i64x2_lt_s = "~lib/builtins/i64x2.lt_s";
  export const i64x2_lt_u = "~lib/builtins/i64x2.lt_u";
  export const i64x2_le_s = "~lib/builtins/i64x2.le_s";
  export const i64x2_le_u = "~lib/builtins/i64x2.le_u";
  export const i64x2_gt_s = "~lib/builtins/i64x2.gt_s";
  export const i64x2_gt_u = "~lib/builtins/i64x2.gt_u";
  export const i64x2_ge_s = "~lib/builtins/i64x2.ge_s";
  export const i64x2_ge_u = "~lib/builtins/i64x2.ge_u";
  export const i64x2_extend_low_i32x4_s = "~lib/builtins/i64x2.extend_low_i32x4_s";
  export const i64x2_extend_low_i32x4_u = "~lib/builtins/i64x2.extend_low_i32x4_u";
  export const i64x2_extend_high_i32x4_s = "~lib/builtins/i64x2.extend_high_i32x4_s";
  export const i64x2_extend_high_i32x4_u = "~lib/builtins/i64x2.extend_high_i32x4_u";
  export const i64x2_extmul_low_i32x4_s = "~lib/builtins/i64x2.extmul_low_i32x4_s";
  export const i64x2_extmul_low_i32x4_u = "~lib/builtins/i64x2.extmul_low_i32x4_u";
  export const i64x2_extmul_high_i32x4_s = "~lib/builtins/i64x2.extmul_high_i32x4_s";
  export const i64x2_extmul_high_i32x4_u = "~lib/builtins/i64x2.extmul_high_i32x4_u";

  export const f32x4_splat = "~lib/builtins/f32x4.splat";
  export const f32x4_extract_lane = "~lib/builtins/f32x4.extract_lane";
  export const f32x4_replace_lane = "~lib/builtins/f32x4.replace_lane";
  export const f32x4_add = "~lib/builtins/f32x4.add";
  export const f32x4_sub = "~lib/builtins/f32x4.sub";
  export const f32x4_mul = "~lib/builtins/f32x4.mul";
  export const f32x4_div = "~lib/builtins/f32x4.div";
  export const f32x4_neg = "~lib/builtins/f32x4.neg";
  export const f32x4_min = "~lib/builtins/f32x4.min";
  export const f32x4_max = "~lib/builtins/f32x4.max";
  export const f32x4_pmin = "~lib/builtins/f32x4.pmin";
  export const f32x4_pmax = "~lib/builtins/f32x4.pmax";
  export const f32x4_abs = "~lib/builtins/f32x4.abs";
  export const f32x4_sqrt = "~lib/builtins/f32x4.sqrt";
  export const f32x4_ceil = "~lib/builtins/f32x4.ceil";
  export const f32x4_floor = "~lib/builtins/f32x4.floor";
  export const f32x4_trunc = "~lib/builtins/f32x4.trunc";
  export const f32x4_nearest = "~lib/builtins/f32x4.nearest";
  export const f32x4_eq = "~lib/builtins/f32x4.eq";
  export const f32x4_ne = "~lib/builtins/f32x4.ne";
  export const f32x4_lt = "~lib/builtins/f32x4.lt";
  export const f32x4_le = "~lib/builtins/f32x4.le";
  export const f32x4_gt = "~lib/builtins/f32x4.gt";
  export const f32x4_ge = "~lib/builtins/f32x4.ge";
  export const f32x4_convert_i32x4_s = "~lib/builtins/f32x4.convert_i32x4_s";
  export const f32x4_convert_i32x4_u = "~lib/builtins/f32x4.convert_i32x4_u";
  export const f32x4_demote_f64x2_zero = "~lib/builtins/f32x4.demote_f64x2_zero";

  export const f64x2_splat = "~lib/builtins/f64x2.splat";
  export const f64x2_extract_lane = "~lib/builtins/f64x2.extract_lane";
  export const f64x2_replace_lane = "~lib/builtins/f64x2.replace_lane";
  export const f64x2_add = "~lib/builtins/f64x2.add";
  export const f64x2_sub = "~lib/builtins/f64x2.sub";
  export const f64x2_mul = "~lib/builtins/f64x2.mul";
  export const f64x2_div = "~lib/builtins/f64x2.div";
  export const f64x2_neg = "~lib/builtins/f64x2.neg";
  export const f64x2_min = "~lib/builtins/f64x2.min";
  export const f64x2_max = "~lib/builtins/f64x2.max";
  export const f64x2_pmin = "~lib/builtins/f64x2.pmin";
  export const f64x2_pmax = "~lib/builtins/f64x2.pmax";
  export const f64x2_abs = "~lib/builtins/f64x2.abs";
  export const f64x2_sqrt = "~lib/builtins/f64x2.sqrt";
  export const f64x2_ceil = "~lib/builtins/f64x2.ceil";
  export const f64x2_floor = "~lib/builtins/f64x2.floor";
  export const f64x2_trunc = "~lib/builtins/f64x2.trunc";
  export const f64x2_nearest = "~lib/builtins/f64x2.nearest";
  export const f64x2_eq = "~lib/builtins/f64x2.eq";
  export const f64x2_ne = "~lib/builtins/f64x2.ne";
  export const f64x2_lt = "~lib/builtins/f64x2.lt";
  export const f64x2_le = "~lib/builtins/f64x2.le";
  export const f64x2_gt = "~lib/builtins/f64x2.gt";
  export const f64x2_ge = "~lib/builtins/f64x2.ge";
  export const f64x2_convert_low_i32x4_s = "~lib/builtins/f64x2.convert_low_i32x4_s";
  export const f64x2_convert_low_i32x4_u = "~lib/builtins/f64x2.convert_low_i32x4_u";
  export const f64x2_promote_low_f32x4 = "~lib/builtins/f64x2.promote_low_f32x4";

  export const i31_new = "~lib/builtins/i31.new";
  export const i31_get = "~lib/builtins/i31.get";

  // internals
  export const data_end = "~lib/memory/__data_end";
  export const stack_pointer = "~lib/memory/__stack_pointer";
  export const heap_base = "~lib/memory/__heap_base";
  export const rtti_base = "~lib/rt/__rtti_base";
  export const visit_globals = "~lib/rt/__visit_globals";
  export const visit_members = "~lib/rt/__visit_members";
  export const tostack = "~lib/rt/__tostack";

  // std/number.ts
  export const isNaN = "~lib/number/isNaN";
  export const isFinite = "~lib/number/isFinite";

  // std/diagnostics.ts
  export const ERROR = "~lib/diagnostics/ERROR";
  export const WARNING = "~lib/diagnostics/WARNING";
  export const INFO = "~lib/diagnostics/INFO";

  // std/function.ts
  export const Function = "~lib/function/Function";

  // std/memory.ts
  export const memory_size = "~lib/memory/memory.size";
  export const memory_grow = "~lib/memory/memory.grow";
  export const memory_copy = "~lib/memory/memory.copy";
  export const memory_fill = "~lib/memory/memory.fill";
  export const memory_data = "~lib/memory/memory.data";

  // std/typedarray.ts
  export const Int8Array = "~lib/typedarray/Int8Array";
  export const Uint8Array = "~lib/typedarray/Uint8Array";
  export const Uint8ClampedArray = "~lib/typedarray/Uint8ClampedArray";
  export const Int16Array = "~lib/typedarray/Int16Array";
  export const Uint16Array = "~lib/typedarray/Uint16Array";
  export const Int32Array = "~lib/typedarray/Int32Array";
  export const Uint32Array = "~lib/typedarray/Uint32Array";
  export const Int64Array = "~lib/typedarray/Int64Array";
  export const Uint64Array = "~lib/typedarray/Uint64Array";
  export const Float32Array = "~lib/typedarray/Float32Array";
  export const Float64Array = "~lib/typedarray/Float64Array";

  // std/string.ts
  export const String_raw = "~lib/string/String.raw";

  // std/bindings/wasi.ts
  export const wasiAbort = "~lib/wasi/index/abort";
  export const wasiTrace = "~lib/wasi/index/trace";
  export const wasiSeed = "~lib/wasi/index/seed";
}

/** Builtin compilation context. */
export class BuiltinContext {
  constructor(
    /** Compiler reference. */
    public compiler: Compiler,
    /** Prototype being called. */
    public prototype: FunctionPrototype,
    /** Provided type arguments. */
    public typeArguments: Type[] | null,
    /** Provided operands. */
    public operands: Expression[],
    /** Provided this operand, if any. */
    public thisOperand: Expression | null,
    /** Contextual type. */
    public contextualType: Type,
    /** Respective call expression. */
    public reportNode: CallExpression,
    /** Whether originating from inline assembly. */
    public contextIsExact: bool
  ) {}
}

/** Global builtins map. */
export const builtins = new Map<string,(ctx: BuiltinContext) => ExpressionRef>();

/** Function builtins map. */
export const function_builtins = new Map<string,(ctx: BuiltinContext) => ExpressionRef>();

// === Static type evaluation =================================================================

// isInteger<T!>() / isInteger<T?>(value: T) -> bool
function builtin_isInteger(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  var type = evaluateConstantType(ctx);
  compiler.currentType = Type.bool;
  if (!type) return module.unreachable();
  return module.i32(type.isIntegerValue ? 1 : 0);
}
builtins.set(BuiltinNames.isInteger, builtin_isInteger);

// isFloat<T!>() / isFloat<T?>(value: T) -> bool
function builtin_isFloat(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  var type = evaluateConstantType(ctx);
  compiler.currentType = Type.bool;
  if (!type) return module.unreachable();
  return module.i32(type.isFloatValue ? 1 : 0);
}
builtins.set(BuiltinNames.isFloat, builtin_isFloat);

// isBoolean<T!>() / isBoolean<T?>(value: T) -> bool
function builtin_isBoolean(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  var type = evaluateConstantType(ctx);
  compiler.currentType = Type.bool;
  if (!type) return module.unreachable();
  return module.i32(type.isBooleanValue ? 1 : 0);
}
builtins.set(BuiltinNames.isBoolean, builtin_isBoolean);

// isSigned<T!>() / isSigned<T?>(value: T) -> bool
function builtin_isSigned(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  var type = evaluateConstantType(ctx);
  compiler.currentType = Type.bool;
  if (!type) return module.unreachable();
  return module.i32(type.isSignedIntegerValue ? 1 : 0);
}
builtins.set(BuiltinNames.isSigned, builtin_isSigned);

// isReference<T!>() / isReference<T?>(value: T) -> bool
function builtin_isReference(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  var type = evaluateConstantType(ctx);
  compiler.currentType = Type.bool;
  if (!type) return module.unreachable();
  return module.i32(type.isReference ? 1 : 0);
}
builtins.set(BuiltinNames.isReference, builtin_isReference);

// isString<T!>() / isString<T?>(value: T) -> bool
function builtin_isString(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  var type = evaluateConstantType(ctx);
  compiler.currentType = Type.bool;
  if (!type) return module.unreachable();
  var classReference = type.getClass();
  return module.i32(
    classReference !== null && classReference.isAssignableTo(compiler.program.stringInstance)
      ? 1
      : 0
  );
}
builtins.set(BuiltinNames.isString, builtin_isString);

// isArray<T!>() / isArray<T?>(value: T) -> bool
function builtin_isArray(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  var type = evaluateConstantType(ctx);
  compiler.currentType = Type.bool;
  if (!type) return module.unreachable();
  var classReference = type.getClass();
  return module.i32(
    classReference !== null && classReference.extends(compiler.program.arrayPrototype)
      ? 1
      : 0
  );
}
builtins.set(BuiltinNames.isArray, builtin_isArray);

// isArrayLike<T!>() / isArrayLike<T?>(value: T) -> bool
function builtin_isArrayLike(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  var type = evaluateConstantType(ctx);
  compiler.currentType = Type.bool;
  if (!type) return module.unreachable();
  var classReference = type.getClass();
  return module.i32(
    classReference !== null && classReference.isArrayLike
      ? 1
      : 0
  );
}
builtins.set(BuiltinNames.isArrayLike, builtin_isArrayLike);

// isFunction<T!> / isFunction<T?>(value: T) -> bool
function builtin_isFunction(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  var type = evaluateConstantType(ctx);
  compiler.currentType = Type.bool;
  if (!type) return module.unreachable();
  return module.i32(type.isFunction ? 1 : 0);
}
builtins.set(BuiltinNames.isFunction, builtin_isFunction);

// isNullable<T!> / isNullable<T?>(value: T) -> bool
function builtin_isNullable(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  var type = evaluateConstantType(ctx);
  compiler.currentType = Type.bool;
  if (!type) return module.unreachable();
  return module.i32(type.isNullableReference ? 1 : 0);
}
builtins.set(BuiltinNames.isNullable, builtin_isNullable);

// isDefined(expression) -> bool
function builtin_isDefined(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  compiler.currentType = Type.bool;
  if (
    checkTypeAbsent(ctx) |
    checkArgsRequired(ctx, 1)
  ) return module.unreachable();
  var element = compiler.resolver.lookupExpression(
    ctx.operands[0],
    compiler.currentFlow,
    Type.auto,
    ReportMode.SWALLOW
  );
  return module.i32(element !== null ? 1 : 0);
}
builtins.set(BuiltinNames.isDefined, builtin_isDefined);

// isConstant(expression) -> bool
function builtin_isConstant(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  compiler.currentType = Type.bool;
  if (
    checkTypeAbsent(ctx) |
    checkArgsRequired(ctx, 1)
  ) return module.unreachable();
  var expr = compiler.compileExpression(ctx.operands[0], Type.auto);
  compiler.currentType = Type.bool;
  return module.i32(getExpressionId(expr) == ExpressionId.Const ? 1 : 0);
}
builtins.set(BuiltinNames.isConstant, builtin_isConstant);

// isManaged<T!>() -> bool
function builtin_isManaged(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  var type = evaluateConstantType(ctx);
  compiler.currentType = Type.bool;
  if (!type) return module.unreachable();
  return module.i32(type.isManaged ? 1 : 0);
}
builtins.set(BuiltinNames.isManaged, builtin_isManaged);

// isVoid<T!>() -> bool
function builtin_isVoid(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  var type = evaluateConstantType(ctx);
  compiler.currentType = Type.bool;
  if (!type) return module.unreachable();
  return module.i32(type.kind == TypeKind.VOID ? 1 : 0);
}
builtins.set(BuiltinNames.isVoid, builtin_isVoid);

// lengthof<T!>() -> i32
function builtin_lengthof(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  var type = evaluateConstantType(ctx);
  compiler.currentType = Type.i32;
  if (!type) return module.unreachable();
  var signatureReference = type.signatureReference;
  if (!signatureReference) {
    compiler.error(
      DiagnosticCode.Type_0_has_no_call_signatures,
      ctx.reportNode.range, type.toString()
    );
    return module.unreachable();
  }
  return module.i32(signatureReference.parameterTypes.length);
}
builtins.set(BuiltinNames.lengthof, builtin_lengthof);

// sizeof<T!>() -> usize*
function builtin_sizeof(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  compiler.currentType = compiler.options.usizeType;
  if (
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 0)
  ) return module.unreachable();
  var type = ctx.typeArguments![0];
  var byteSize = type.byteSize;
  if (!byteSize) {
    compiler.error(
      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
      ctx.reportNode.typeArgumentsRange, "sizeof", type.toString()
    );
    return module.unreachable();
  }
  return contextualUsize(compiler, i64_new(byteSize), ctx.contextualType);
}
builtins.set(BuiltinNames.sizeof, builtin_sizeof);

// alignof<T!>() -> usize*
function builtin_alignof(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  compiler.currentType = compiler.options.usizeType;
  if (
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 0)
  ) return module.unreachable();
  var type = ctx.typeArguments![0];
  var byteSize = type.byteSize;
  if (!isPowerOf2(byteSize)) { // implies == 0
    compiler.error(
      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
      ctx.reportNode.typeArgumentsRange, "alignof", type.toString()
    );
    return module.unreachable();
  }
  return contextualUsize(compiler, i64_new(ctz<i32>(byteSize)), ctx.contextualType);
}
builtins.set(BuiltinNames.alignof, builtin_alignof);

// offsetof<T!>(fieldName?: string) -> usize*
function builtin_offsetof(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  compiler.currentType = compiler.options.usizeType;
  if (
    checkTypeRequired(ctx) |
    checkArgsOptional(ctx, 0, 1)
  ) return module.unreachable();
  var operands = ctx.operands;
  var contextualType = ctx.contextualType;
  var type = ctx.typeArguments![0];
  var classReference = type.getClassOrWrapper(compiler.program);
  if (!classReference) {
    compiler.error(
      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
      ctx.reportNode.typeArgumentsRange, "offsetof", type.toString()
    );
    if (compiler.options.isWasm64) {
      if (contextualType.isIntegerValue && contextualType.size <= 32) {
        compiler.currentType = Type.u32;
      }
    } else {
      if (contextualType.isIntegerValue && contextualType.size == 64) {
        compiler.currentType = Type.u64;
      }
    }
    return module.unreachable();
  }
  if (operands.length) {
    let firstOperand = operands[0];
    if (!firstOperand.isLiteralKind(LiteralKind.STRING)) {
      compiler.error(
        DiagnosticCode.String_literal_expected,
        operands[0].range
      );
      return module.unreachable();
    }
    let fieldName = (<StringLiteralExpression>firstOperand).value;
    let classMembers = classReference.members;
    if (classMembers !== null && classMembers.has(fieldName)) {
      let member = assert(classMembers.get(fieldName));
      if (member.kind == ElementKind.FIELD) {
        return contextualUsize(compiler, i64_new((<Field>member).memoryOffset), contextualType);
      }
    }
    compiler.error(
      DiagnosticCode.Type_0_has_no_property_1,
      firstOperand.range, classReference.internalName, fieldName
    );
    return module.unreachable();
  }
  return contextualUsize(compiler, i64_new(classReference.nextMemoryOffset), contextualType);
}
builtins.set(BuiltinNames.offsetof, builtin_offsetof);

// nameof<T> -> string
function builtin_nameof(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  var resultType = evaluateConstantType(ctx);
  if (!resultType) {
    compiler.currentType = compiler.program.stringInstance.type;
    return module.unreachable();
  }
  var value: string;
  if (resultType.isInternalReference) {
    let classReference = resultType.getClass();
    if (classReference) {
      value = classReference.name;
    } else {
      assert(resultType.getSignature());
      value = "Function";
    }
  } else {
    value = resultType.toString();
  }
  return compiler.ensureStaticString(value);
}
builtins.set(BuiltinNames.nameof, builtin_nameof);

// idof<T> -> u32
function builtin_idof(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  var type = evaluateConstantType(ctx);
  compiler.currentType = Type.u32;
  if (!type) return module.unreachable();
  let signatureReference = type.getSignature();
  if (signatureReference) {
    return module.i32(signatureReference.id);
  }
  let classReference = type.getClassOrWrapper(compiler.program);
  if (classReference !== null && !classReference.hasDecorator(DecoratorFlags.UNMANAGED)) {
    return module.i32(classReference.id);
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "idof", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.idof, builtin_idof);

// === Math ===================================================================================

// clz<T?>(value: T) -> T
function builtin_clz(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeOptional(ctx, true) |
    checkArgsRequired(ctx, 1)
  ) return module.unreachable();
  var typeArguments = ctx.typeArguments;
  var arg0 = typeArguments
    ? compiler.compileExpression(ctx.operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)
    : compiler.compileExpression(ctx.operands[0], Type.i32, Constraints.MUST_WRAP);
  var type = compiler.currentType;
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.BOOL: // not wrapped
      case TypeKind.I8:
      case TypeKind.U8:
      case TypeKind.I16:
      case TypeKind.U16:
      case TypeKind.I32:
      case TypeKind.U32: return module.unary(UnaryOp.ClzI32, arg0);
      case TypeKind.USIZE:
      case TypeKind.ISIZE: {
        return module.unary(
          compiler.options.isWasm64
            ? UnaryOp.ClzI64
            : UnaryOp.ClzI32,
          arg0
        );
      }
      case TypeKind.I64:
      case TypeKind.U64: return module.unary(UnaryOp.ClzI64, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "clz", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.clz, builtin_clz);

// ctz<T?>(value: T) -> T
function builtin_ctz(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeOptional(ctx, true) |
    checkArgsRequired(ctx, 1)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var arg0 = typeArguments
    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)
    : compiler.compileExpression(operands[0], Type.i32, Constraints.MUST_WRAP);
  var type = compiler.currentType;
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.BOOL: // not wrapped
      case TypeKind.I8:
      case TypeKind.U8:
      case TypeKind.I16:
      case TypeKind.U16:
      case TypeKind.I32:
      case TypeKind.U32: return module.unary(UnaryOp.CtzI32, arg0);
      case TypeKind.USIZE:
      case TypeKind.ISIZE: {
        return module.unary(
          compiler.options.isWasm64
            ? UnaryOp.CtzI64
            : UnaryOp.CtzI32,
          arg0
        );
      }
      case TypeKind.I64:
      case TypeKind.U64: return module.unary(UnaryOp.CtzI64, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "ctz", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.ctz, builtin_ctz);

// popcnt<T?>(value: T) -> T
function builtin_popcnt(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeOptional(ctx, true) |
    checkArgsRequired(ctx, 1)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var arg0 = typeArguments
    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)
    : compiler.compileExpression(operands[0], Type.i32, Constraints.MUST_WRAP);
  var type = compiler.currentType;
  if (type.isValue) {
    switch (compiler.currentType.kind) {
      case TypeKind.BOOL: return arg0;
      case TypeKind.I8: // not wrapped
      case TypeKind.U8:
      case TypeKind.I16:
      case TypeKind.U16:
      case TypeKind.I32:
      case TypeKind.U32: return module.unary(UnaryOp.PopcntI32, arg0);
      case TypeKind.I64:
      case TypeKind.U64: return module.unary(UnaryOp.PopcntI64, arg0);
      case TypeKind.ISIZE:
      case TypeKind.USIZE: {
        return module.unary(
          compiler.options.isWasm64
            ? UnaryOp.PopcntI64
            : UnaryOp.PopcntI32,
          arg0
        );
      }
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "popcnt", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.popcnt, builtin_popcnt);

// rotl<T?>(value: T, shift: T) -> T
function builtin_rotl(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeOptional(ctx, true) |
    checkArgsRequired(ctx, 2)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var arg0 = typeArguments
    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)
    : compiler.compileExpression(operands[0], Type.i32, Constraints.MUST_WRAP);
  var type = compiler.currentType;
  if (type.isValue) {
    let arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);
    switch (type.kind) {
      case TypeKind.BOOL: return arg0;
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.U8:
      case TypeKind.U16: {
        // (value << (shift & mask)) | (value >>> ((0 - shift) & mask))
        let flow = compiler.currentFlow;
        let temp1 = flow.getTempLocal(type, findUsedLocals(arg1));
        flow.setLocalFlag(temp1.index, LocalFlags.WRAPPED);
        let temp2 = flow.getTempLocal(type);
        flow.setLocalFlag(temp2.index, LocalFlags.WRAPPED);

        let ret = module.binary(BinaryOp.OrI32,
          module.binary(
            BinaryOp.ShlI32,
            module.local_tee(temp1.index, arg0, false), // i32
            module.binary(
              BinaryOp.AndI32,
              module.local_tee(temp2.index, arg1, false), // i32
              module.i32(type.size - 1)
            )
          ),
          module.binary(
            BinaryOp.ShrU32,
            module.local_get(temp1.index, TypeRef.I32),
            module.binary(
              BinaryOp.AndI32,
              module.binary(
                BinaryOp.SubI32,
                module.i32(0),
                module.local_get(temp2.index, TypeRef.I32)
              ),
              module.i32(type.size - 1)
            )
          )
        );
        flow.freeTempLocal(temp2);
        flow.freeTempLocal(temp1);

        return ret;
      }
      case TypeKind.I32:
      case TypeKind.U32: return module.binary(BinaryOp.RotlI32, arg0, arg1);
      case TypeKind.USIZE:
      case TypeKind.ISIZE: {
        return module.binary(
          compiler.options.isWasm64
            ? BinaryOp.RotlI64
            : BinaryOp.RotlI32,
          arg0, arg1
        );
      }
      case TypeKind.I64:
      case TypeKind.U64: return module.binary(BinaryOp.RotlI64, arg0, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "rotl", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.rotl, builtin_rotl);

// rotr<T?>(value: T, shift: T) -> T
function builtin_rotr(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeOptional(ctx, true) |
    checkArgsRequired(ctx, 2)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var arg0 = typeArguments
    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)
    : compiler.compileExpression(operands[0], Type.i32, Constraints.MUST_WRAP);
  var type = compiler.currentType;
  if (type.isValue) {
    let arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);
    switch (type.kind) {
      case TypeKind.BOOL: return arg0;
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.U8:
      case TypeKind.U16: {
        // (value >>> (shift & mask)) | (value << ((0 - shift) & mask))
        let flow = compiler.currentFlow;
        let temp1 = flow.getTempLocal(type, findUsedLocals(arg1));
        flow.setLocalFlag(temp1.index, LocalFlags.WRAPPED);
        let temp2 = flow.getTempLocal(type);
        flow.setLocalFlag(temp2.index, LocalFlags.WRAPPED);

        let ret = module.binary(BinaryOp.OrI32,
          module.binary(
            BinaryOp.ShrU32,
            module.local_tee(temp1.index, arg0, false), // i32
            module.binary(
              BinaryOp.AndI32,
              module.local_tee(temp2.index, arg1, false), // i32
              module.i32(type.size - 1)
            )
          ),
          module.binary(
            BinaryOp.ShlI32,
            module.local_get(temp1.index, TypeRef.I32),
            module.binary(
              BinaryOp.AndI32,
              module.binary(
                BinaryOp.SubI32,
                module.i32(0),
                module.local_get(temp2.index, TypeRef.I32)
              ),
              module.i32(type.size - 1)
            )
          )
        );
        flow.freeTempLocal(temp2);
        flow.freeTempLocal(temp1);

        return ret;
      }
      case TypeKind.I32:
      case TypeKind.U32: return module.binary(BinaryOp.RotrI32, arg0, arg1);
      case TypeKind.USIZE:
      case TypeKind.ISIZE: {
        return module.binary(
          compiler.options.isWasm64
            ? BinaryOp.RotrI64
            : BinaryOp.RotrI32,
          arg0, arg1
        );
      }
      case TypeKind.I64:
      case TypeKind.U64: return module.binary(BinaryOp.RotrI64, arg0, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "rotr", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.rotr, builtin_rotr);

// abs<T?>(value: T) -> T
function builtin_abs(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeOptional(ctx, true) |
    checkArgsRequired(ctx, 1)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var arg0 = typeArguments
    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)
    : compiler.compileExpression(operands[0], Type.auto, Constraints.MUST_WRAP);
  var type = compiler.currentType;
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.I32: {
        let flow = compiler.currentFlow;

        // possibly overflows, e.g. abs<i8>(-128) == 128
        let temp1 = flow.getTempLocal(Type.i32);
        let temp2 = flow.getTempLocal(Type.i32);
        // (x + (x >> 31)) ^ (x >> 31)
        let ret = module.binary(BinaryOp.XorI32,
          module.binary(BinaryOp.AddI32,
            module.local_tee(
              temp2.index,
              module.binary(BinaryOp.ShrI32,
                module.local_tee(temp1.index, arg0, false), // i32
                module.i32(31)
              ),
              false // i32
            ),
            module.local_get(temp1.index, TypeRef.I32)
          ),
          module.local_get(temp2.index, TypeRef.I32)
        );
        flow.freeTempLocal(temp2);
        flow.freeTempLocal(temp1);
        return ret;
      }
      case TypeKind.ISIZE: {
        let options = compiler.options;
        let flow = compiler.currentFlow;
        let isWasm64 = options.isWasm64;

        let temp1 = flow.getTempLocal(options.usizeType);
        let temp2 = flow.getTempLocal(options.usizeType);
        let ret = module.binary(isWasm64 ? BinaryOp.XorI64 : BinaryOp.XorI32,
          module.binary(isWasm64 ? BinaryOp.AddI64 : BinaryOp.AddI32,
            module.local_tee(
              temp2.index,
              module.binary(isWasm64 ? BinaryOp.ShrI64 : BinaryOp.ShrI32,
                module.local_tee(temp1.index, arg0, false), // i32/i64
                isWasm64 ? module.i64(63) : module.i32(31)
              ),
              false // i32/i64
            ),
            module.local_get(temp1.index, options.sizeTypeRef)
          ),
          module.local_get(temp2.index, options.sizeTypeRef)
        );
        flow.freeTempLocal(temp2);
        flow.freeTempLocal(temp1);
        return ret;
      }
      case TypeKind.I64: {
        let flow = compiler.currentFlow;

        let temp1 = flow.getTempLocal(Type.i64);
        let temp2 = flow.getTempLocal(Type.i64);
        // (x + (x >> 63)) ^ (x >> 63)
        let ret = module.binary(BinaryOp.XorI64,
          module.binary(BinaryOp.AddI64,
            module.local_tee(
              temp2.index,
              module.binary(BinaryOp.ShrI64,
                module.local_tee(temp1.index, arg0, false), // i64
                module.i64(63)
              ),
              false // i64
            ),
            module.local_get(temp1.index, TypeRef.I64)
          ),
          module.local_get(temp2.index, TypeRef.I64)
        );
        flow.freeTempLocal(temp2);
        flow.freeTempLocal(temp1);
        return ret;
      }
      case TypeKind.USIZE:
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.U32:
      case TypeKind.U64:
      case TypeKind.BOOL: return arg0;
      case TypeKind.F32: return module.unary(UnaryOp.AbsF32, arg0);
      case TypeKind.F64: return module.unary(UnaryOp.AbsF64, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "abs", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.abs, builtin_abs);

// max<T?>(left: T, right: T) -> T
function builtin_max(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeOptional(ctx, true) |
    checkArgsRequired(ctx, 2)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var left = operands[0];
  var arg0 = typeArguments
    ? compiler.compileExpression(left, typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)
    : compiler.compileExpression(operands[0], Type.auto, Constraints.MUST_WRAP);
  var type = compiler.currentType;
  if (type.isValue) {
    let arg1: ExpressionRef;
    if (!typeArguments && left.isNumericLiteral) { // prefer right type
      arg1 = compiler.compileExpression(operands[1], type, Constraints.MUST_WRAP);
      if (compiler.currentType != type) {
        arg0 = compiler.compileExpression(left, type = compiler.currentType, Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP);
      }
    } else {
      arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP);
    }
    let op: BinaryOp = -1;
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.I32: { op = BinaryOp.GtI32; break; }
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.U32:
      case TypeKind.BOOL: { op = BinaryOp.GtU32; break; }
      case TypeKind.I64: { op = BinaryOp.GtI64; break; }
      case TypeKind.U64: { op = BinaryOp.GtU64; break; }
      case TypeKind.ISIZE: {
        op = compiler.options.isWasm64
          ? BinaryOp.GtI64
          : BinaryOp.GtI32;
        break;
      }
      case TypeKind.USIZE: {
        op = compiler.options.isWasm64
          ? BinaryOp.GtU64
          : BinaryOp.GtU32;
        break;
      }
      case TypeKind.F32: return module.binary(BinaryOp.MaxF32, arg0, arg1);
      case TypeKind.F64: return module.binary(BinaryOp.MaxF64, arg0, arg1);
    }
    if (op as i32 != -1) {
      let flow = compiler.currentFlow;
      let typeRef = type.toRef();
      let temp1 = flow.getTempLocal(type, findUsedLocals(arg1));
      flow.setLocalFlag(temp1.index, LocalFlags.WRAPPED);
      let temp2 = flow.getTempLocal(type);
      flow.setLocalFlag(temp2.index, LocalFlags.WRAPPED);
      let ret = module.select(
        module.local_tee(temp1.index, arg0, false), // numeric
        module.local_tee(temp2.index, arg1, false), // numeric
        module.binary(op,
          module.local_get(temp1.index, typeRef),
          module.local_get(temp2.index, typeRef)
        )
      );
      flow.freeTempLocal(temp2);
      flow.freeTempLocal(temp1);
      return ret;
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "max", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.max, builtin_max);

// min<T?>(left: T, right: T) -> T
function builtin_min(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeOptional(ctx, true) |
    checkArgsRequired(ctx, 2)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var left = operands[0];
  var arg0 = typeArguments
    ? compiler.compileExpression(left, typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)
    : compiler.compileExpression(operands[0], Type.auto, Constraints.MUST_WRAP);
  var type = compiler.currentType;
  if (type.isValue) {
    let arg1: ExpressionRef;
    if (!typeArguments && left.isNumericLiteral) { // prefer right type
      arg1 = compiler.compileExpression(operands[1], type, Constraints.MUST_WRAP);
      if (compiler.currentType != type) {
        arg0 = compiler.compileExpression(left, type = compiler.currentType, Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP);
      }
    } else {
      arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP);
    }
    let op: BinaryOp = -1;
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.I32: { op = BinaryOp.LtI32; break; }
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.U32:
      case TypeKind.BOOL: { op = BinaryOp.LtU32; break; }
      case TypeKind.I64:  { op = BinaryOp.LtI64; break; }
      case TypeKind.U64:  { op = BinaryOp.LtU64; break; }
      case TypeKind.ISIZE: {
        op = compiler.options.isWasm64
          ? BinaryOp.LtI64
          : BinaryOp.LtI32;
        break;
      }
      case TypeKind.USIZE: {
        op = compiler.options.isWasm64
          ? BinaryOp.LtU64
          : BinaryOp.LtU32;
        break;
      }
      case TypeKind.F32: return module.binary(BinaryOp.MinF32, arg0, arg1);
      case TypeKind.F64: return module.binary(BinaryOp.MinF64, arg0, arg1);
    }
    if (op as i32 != -1) {
      let flow = compiler.currentFlow;
      let typeRef = type.toRef();
      let temp1 = flow.getTempLocal(type, findUsedLocals(arg1));
      flow.setLocalFlag(temp1.index, LocalFlags.WRAPPED);
      let temp2 = flow.getTempLocal(type);
      flow.setLocalFlag(temp2.index, LocalFlags.WRAPPED);
      let ret = module.select(
        module.local_tee(temp1.index, arg0, false), // numeric
        module.local_tee(temp2.index, arg1, false), // numeric
        module.binary(op,
          module.local_get(temp1.index, typeRef),
          module.local_get(temp2.index, typeRef)
        )
      );
      flow.freeTempLocal(temp2);
      flow.freeTempLocal(temp1);
      return ret;
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "min", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.min, builtin_min);

// ceil<T?>(value: T) -> T
function builtin_ceil(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeOptional(ctx, true) |
    checkArgsRequired(ctx, 1)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var arg0 = typeArguments
    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)
    : compiler.compileExpression(operands[0], Type.auto, Constraints.NONE);
  var type = compiler.currentType;
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.I32:
      case TypeKind.I64:
      case TypeKind.ISIZE:
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.U32:
      case TypeKind.U64:
      case TypeKind.USIZE:
      case TypeKind.BOOL: return arg0; // considered rounded
      case TypeKind.F32: return module.unary(UnaryOp.CeilF32, arg0);
      case TypeKind.F64: return module.unary(UnaryOp.CeilF64, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "ceil", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.ceil, builtin_ceil);

// floor<T?>(value: T) -> T
function builtin_floor(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeOptional(ctx, true) |
    checkArgsRequired(ctx, 1)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var arg0 = typeArguments
    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)
    : compiler.compileExpression(operands[0], Type.auto, Constraints.NONE);
  var type = compiler.currentType;
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.I32:
      case TypeKind.I64:
      case TypeKind.ISIZE:
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.U32:
      case TypeKind.U64:
      case TypeKind.USIZE:
      case TypeKind.BOOL: return arg0; // considered rounded
      case TypeKind.F32: return module.unary(UnaryOp.FloorF32, arg0);
      case TypeKind.F64: return module.unary(UnaryOp.FloorF64, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "floor", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.floor, builtin_floor);

// copysign<T?>(left: T, right: T) -> T
function builtin_copysign(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeOptional(ctx, true) |
    checkArgsRequired(ctx, 2)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var arg0 = typeArguments
    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)
    : compiler.compileExpression(operands[0], Type.f64, Constraints.NONE);
  var type = compiler.currentType;
  if (type.isValue) {
    let arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);
    switch (type.kind) {
      // TODO: does an integer version make sense?
      case TypeKind.F32: return module.binary(BinaryOp.CopysignF32, arg0, arg1);
      case TypeKind.F64: return module.binary(BinaryOp.CopysignF64, arg0, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "copysign", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.copysign, builtin_copysign);

// nearest<T?>(value: T) -> T
function builtin_nearest(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeOptional(ctx, true) |
    checkArgsRequired(ctx, 1)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var arg0 = typeArguments
    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)
    : compiler.compileExpression(operands[0], Type.auto, Constraints.NONE);
  var type = compiler.currentType;
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.I32:
      case TypeKind.I64:
      case TypeKind.ISIZE:
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.U32:
      case TypeKind.U64:
      case TypeKind.USIZE:
      case TypeKind.BOOL: return arg0;
      case TypeKind.F32: return module.unary(UnaryOp.NearestF32, arg0);
      case TypeKind.F64: return module.unary(UnaryOp.NearestF64, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "nearest", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.nearest, builtin_nearest);

// reinterpret<T!>(value: *) -> T
function builtin_reinterpret(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeRequired(ctx, true) |
    checkArgsRequired(ctx, 1)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var type = typeArguments![0];
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I32:
      case TypeKind.U32: {
        let arg0 = compiler.compileExpression(operands[0], Type.f32, Constraints.CONV_IMPLICIT);
        compiler.currentType = type;
        return module.unary(UnaryOp.ReinterpretF32ToI32, arg0);
      }
      case TypeKind.I64:
      case TypeKind.U64: {
        let arg0 = compiler.compileExpression(operands[0], Type.f64, Constraints.CONV_IMPLICIT);
        compiler.currentType = type;
        return module.unary(UnaryOp.ReinterpretF64ToI64, arg0);
      }
      case TypeKind.ISIZE:
      case TypeKind.USIZE: {
        let arg0 = compiler.compileExpression(operands[0],
          compiler.options.isWasm64
            ? Type.f64
            : Type.f32,
          Constraints.CONV_IMPLICIT
        );
        compiler.currentType = type;
        return module.unary(
          compiler.options.isWasm64
            ? UnaryOp.ReinterpretF64ToI64
            : UnaryOp.ReinterpretF32ToI32,
          arg0
        );
      }
      case TypeKind.F32: {
        let arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.CONV_IMPLICIT);
        compiler.currentType = Type.f32;
        return module.unary(UnaryOp.ReinterpretI32ToF32, arg0);
      }
      case TypeKind.F64: {
        let arg0 = compiler.compileExpression(operands[0], Type.i64, Constraints.CONV_IMPLICIT);
        compiler.currentType = Type.f64;
        return module.unary(UnaryOp.ReinterpretI64ToF64, arg0);
      }
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "reinterpret", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.reinterpret, builtin_reinterpret);

// sqrt<T?>(value: T) -> T
function builtin_sqrt(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeOptional(ctx, true) |
    checkArgsRequired(ctx, 1)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var arg0 = typeArguments
    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)
    : compiler.compileExpression(operands[0], Type.f64, Constraints.NONE);
  var type = compiler.currentType;
  if (type.isValue) {
    switch (type.kind) {
      // TODO: integer versions (that return f64 or convert)?
      case TypeKind.F32: return module.unary(UnaryOp.SqrtF32, arg0);
      case TypeKind.F64: return module.unary(UnaryOp.SqrtF64, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "sqrt", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.sqrt, builtin_sqrt);

// trunc<T?>(value: T) -> T
function builtin_trunc(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeOptional(ctx, true) |
    checkArgsRequired(ctx, 1)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var arg0 = typeArguments
    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)
    : compiler.compileExpression(operands[0], Type.auto, Constraints.NONE);
  var type = compiler.currentType;
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.I32:
      case TypeKind.I64:
      case TypeKind.ISIZE:
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.U32:
      case TypeKind.U64:
      case TypeKind.USIZE:
      case TypeKind.BOOL: return arg0; // considered truncated
      case TypeKind.F32: return module.unary(UnaryOp.TruncF32, arg0);
      case TypeKind.F64: return module.unary(UnaryOp.TruncF64, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "trunc", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.trunc, builtin_trunc);

// isNaN<T?>(value: T) -> bool
function builtin_isNaN(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeOptional(ctx) |
    checkArgsRequired(ctx, 1)
  ) {
    compiler.currentType = Type.bool;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var arg0 = typeArguments
    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)
    : compiler.compileExpression(operands[0], Type.auto);
  var type = compiler.currentType;
  compiler.currentType = Type.bool;
  if (type.isValue) {
    switch (type.kind) {
      // never NaN
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.I32:
      case TypeKind.I64:
      case TypeKind.ISIZE:
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.U32:
      case TypeKind.U64:
      case TypeKind.USIZE: {
        return module.maybeDropCondition(arg0, module.i32(0));
      }
      // (t = arg0) != t
      case TypeKind.F32: {
        if (getExpressionId(arg0) == ExpressionId.LocalGet) {
          return module.binary(BinaryOp.NeF32,
            arg0,
            module.local_get(getLocalGetIndex(arg0), TypeRef.F32)
          );
        }
        let flow = compiler.currentFlow;
        let temp = flow.getTempLocal(Type.f32);
        let ret = module.binary(BinaryOp.NeF32,
          module.local_tee(temp.index, arg0, false), // f32
          module.local_get(temp.index, TypeRef.F32)
        );
        flow.freeTempLocal(temp);
        return ret;
      }
      case TypeKind.F64: {
        if (getExpressionId(arg0) == ExpressionId.LocalGet) {
          return module.binary(BinaryOp.NeF64,
            arg0,
            module.local_get(getLocalGetIndex(arg0), TypeRef.F64)
          );
        }
        let flow = compiler.currentFlow;
        let temp = flow.getTempLocal(Type.f64);
        let ret = module.binary(BinaryOp.NeF64,
          module.local_tee(temp.index, arg0, false), // f64
          module.local_get(temp.index, TypeRef.F64)
        );
        flow.freeTempLocal(temp);
        return ret;
      }
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "isNaN", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.isNaN, builtin_isNaN);

// isFinite<T?>(value: T) -> bool
function builtin_isFinite(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeOptional(ctx) |
    checkArgsRequired(ctx, 1)
  ) {
    compiler.currentType = Type.bool;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var arg0 = typeArguments
    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)
    : compiler.compileExpression(operands[0], Type.auto);
  var type = compiler.currentType;
  compiler.currentType = Type.bool;
  if (type.isValue) {
    switch (type.kind) {
      // always finite
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.I32:
      case TypeKind.I64:
      case TypeKind.ISIZE:
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.U32:
      case TypeKind.U64:
      case TypeKind.USIZE: {
        return module.maybeDropCondition(arg0, module.i32(1));
      }
      // (t = arg0) - t == 0
      case TypeKind.F32: {
        if (getExpressionId(arg0) == ExpressionId.LocalGet) {
          return module.binary(BinaryOp.EqF32,
            module.binary(BinaryOp.SubF32,
              arg0,
              module.local_get(getLocalGetIndex(arg0), TypeRef.F32)
            ),
            module.f32(0)
          );
        }
        let flow = compiler.currentFlow;
        let temp = flow.getTempLocal(Type.f32);
        let ret = module.binary(BinaryOp.EqF32,
          module.binary(BinaryOp.SubF32,
            module.local_tee(temp.index, arg0, false), // f32
            module.local_get(temp.index, TypeRef.F32)
          ),
          module.f32(0)
        );
        flow.freeTempLocal(temp);
        return ret;
      }
      case TypeKind.F64: {
        if (getExpressionId(arg0) == ExpressionId.LocalGet) {
          return module.binary(BinaryOp.EqF64,
            module.binary(BinaryOp.SubF64,
              arg0,
              module.local_get(getLocalGetIndex(arg0), TypeRef.F64)
            ),
            module.f64(0)
          );
        }
        let flow = compiler.currentFlow;
        let temp = flow.getTempLocal(Type.f64);
        let ret = module.binary(BinaryOp.EqF64,
          module.binary(BinaryOp.SubF64,
            module.local_tee(temp.index, arg0, false), // f64
            module.local_get(temp.index, TypeRef.F64)
          ),
          module.f64(0)
        );
        flow.freeTempLocal(temp);
        return ret;
      }
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "isFinite", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.isFinite, builtin_isFinite);

// === Memory access ==========================================================================

// load<T!>(offset: usize, immOffset?: usize, immAlign?: usize) -> T*
function builtin_load(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeRequired(ctx, true) |
    checkArgsOptional(ctx, 1, 3)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var contextualType = ctx.contextualType;
  var type = typeArguments![0];
  var outType = (
    contextualType != Type.auto &&
    type.isIntegerValue &&
    contextualType.isIntegerValue &&
    contextualType.size > type.size
  ) ? contextualType : type;
  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);
  var numOperands = operands.length;
  var immOffset = 0;
  var immAlign = type.byteSize;
  if (numOperands >= 2) {
    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports
    if (immOffset < 0) {
      compiler.currentType = outType;
      return module.unreachable();
    }
    if (numOperands == 3) {
      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports
      if (immAlign < 0) {
        compiler.currentType = outType;
        return module.unreachable();
      }
    }
  }
  compiler.currentType = outType;
  return module.load(
    type.byteSize,
    type.isSignedIntegerValue,
    arg0,
    outType.toRef(),
    immOffset,
    immAlign
  );
}
builtins.set(BuiltinNames.load, builtin_load);

// store<T!>(ptr: usize, value: T*, immOffset?: usize, immAlign?: usize) -> void
function builtin_store(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  compiler.currentType = Type.void;
  if (
    checkTypeRequired(ctx) |
    checkArgsOptional(ctx, 2, 4)
  ) return module.unreachable();
  var operands = ctx.operands;
  var numOperands = operands.length;
  var typeArguments = ctx.typeArguments;
  var contextualType = ctx.contextualType;
  var type = typeArguments![0];
  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);
  var arg1 = ctx.contextIsExact
    ? compiler.compileExpression(operands[1],
        contextualType,
        Constraints.CONV_IMPLICIT
      )
    : compiler.compileExpression(
        operands[1],
        type,
        type.isIntegerValue
          ? Constraints.NONE // no need to convert to small int (but now might result in a float)
          : Constraints.CONV_IMPLICIT
      );
  var inType = compiler.currentType;
  if (
    type.isIntegerValue &&
    (
      !inType.isIntegerValue || // float to int
      inType.size < type.size   // int to larger int (clear garbage bits)
    )
  ) {
    // either conversion or memory operation clears garbage bits
    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);
    inType = type;
  }
  var immOffset = 0;
  var immAlign = type.byteSize;
  if (numOperands >= 3) {
    immOffset = evaluateImmediateOffset(operands[2], compiler); // reports
    if (immOffset < 0) {
      compiler.currentType = Type.void;
      return module.unreachable();
    }
    if (numOperands == 4) {
      immAlign = evaluateImmediateAlign(operands[3], immAlign, compiler); // reports
      if (immAlign < 0) {
        compiler.currentType = Type.void;
        return module.unreachable();
      }
    }
  }
  compiler.currentType = Type.void;
  return module.store(type.byteSize, arg0, arg1, inType.toRef(), immOffset, immAlign);
}
builtins.set(BuiltinNames.store, builtin_store);

// add<T?>(left: T, right: T) -> T
function builtin_add(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var left = operands[0];
  var arg0 = typeArguments
    ? compiler.compileExpression(
        left,
        typeArguments[0],
        Constraints.CONV_IMPLICIT
      )
    : compiler.compileExpression(operands[0], Type.auto);
  var type = compiler.currentType;
  if (type.isValue) {
    let arg1: ExpressionRef;
    if (!typeArguments && left.isNumericLiteral) {
      // prefer right type
      arg1 = compiler.compileExpression(
        operands[1],
        type
      );
      if (compiler.currentType != type) {
        arg0 = compiler.compileExpression(
          left,
          (type = compiler.currentType),
          Constraints.CONV_IMPLICIT
        );
      }
    } else {
      arg1 = compiler.compileExpression(
        operands[1],
        type,
        Constraints.CONV_IMPLICIT
      );
    }
    if (type.isNumericValue) {
      return compiler.makeAdd(arg0, arg1, type);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange,
    "add",
    type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.add, builtin_add);

// sub<T?>(left: T, right: T) -> T
function builtin_sub(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var left = operands[0];
  var arg0 = typeArguments
    ? compiler.compileExpression(
        left,
        typeArguments[0],
        Constraints.CONV_IMPLICIT
      )
    : compiler.compileExpression(operands[0], Type.auto);
  var type = compiler.currentType;
  if (type.isValue) {
    let arg1: ExpressionRef;
    if (!typeArguments && left.isNumericLiteral) {
      // prefer right type
      arg1 = compiler.compileExpression(
        operands[1],
        type
      );
      if (compiler.currentType != type) {
        arg0 = compiler.compileExpression(
          left,
          (type = compiler.currentType),
          Constraints.CONV_IMPLICIT
        );
      }
    } else {
      arg1 = compiler.compileExpression(
        operands[1],
        type,
        Constraints.CONV_IMPLICIT
      );
    }
    if (type.isNumericValue) {
      return compiler.makeSub(arg0, arg1, type);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange,
    "sub",
    type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.sub, builtin_sub);

// mul<T?>(left: T, right: T) -> T
function builtin_mul(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var left = operands[0];
  var arg0 = typeArguments
    ? compiler.compileExpression(
        left,
        typeArguments[0],
        Constraints.CONV_IMPLICIT
      )
    : compiler.compileExpression(operands[0], Type.auto);
  var type = compiler.currentType;
  if (type.isValue) {
    let arg1: ExpressionRef;
    if (!typeArguments && left.isNumericLiteral) {
      // prefer right type
      arg1 = compiler.compileExpression(
        operands[1],
        type
      );
      if (compiler.currentType != type) {
        arg0 = compiler.compileExpression(
          left,
          (type = compiler.currentType),
          Constraints.CONV_IMPLICIT
        );
      }
    } else {
      arg1 = compiler.compileExpression(
        operands[1],
        type,
        Constraints.CONV_IMPLICIT
      );
    }
    if (type.isNumericValue) {
      return compiler.makeMul(arg0, arg1, type);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange,
    "mul",
    type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.mul, builtin_mul);

// div<T?>(left: T, right: T) -> T
function builtin_div(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var left = operands[0];
  var arg0 = typeArguments
    ? compiler.compileExpression(
        left,
        typeArguments[0],
        Constraints.CONV_IMPLICIT
      )
    : compiler.compileExpression(operands[0], Type.auto);
  var type = compiler.currentType;
  if (type.isValue) {
    let arg1: ExpressionRef;
    if (!typeArguments && left.isNumericLiteral) {
      // prefer right type
      arg1 = compiler.compileExpression(
        operands[1],
        type
      );
      if (compiler.currentType != type) {
        arg0 = compiler.compileExpression(
          left,
          (type = compiler.currentType),
          Constraints.CONV_IMPLICIT
        );
      }
    } else {
      arg1 = compiler.compileExpression(
        operands[1],
        type,
        Constraints.CONV_IMPLICIT
      );
    }
    if (type.isNumericValue) {
      return compiler.makeDiv(arg0, arg1, type);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange,
    "div",
    type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.div, builtin_div);

// === Atomics ================================================================================

// atomic.load<T!>(offset: usize, immOffset?: usize) -> T*
function builtin_atomic_load(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.THREADS) |
    checkTypeRequired(ctx, true) |
    checkArgsOptional(ctx, 1, 2)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var contextualType = ctx.contextualType;
  var type = typeArguments![0];
  var outType = (
    type.isIntegerValue &&
    contextualType.isIntegerValue &&
    contextualType.size > type.size
  ) ? contextualType : type;
  if (!type.isIntegerValue) {
    compiler.error(
      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
      ctx.reportNode.typeArgumentsRange, "atomic.load", type.toString()
    );
    compiler.currentType = outType;
    return module.unreachable();
  }
  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);
  var immOffset = operands.length == 2 ? evaluateImmediateOffset(operands[1], compiler) : 0; // reports
  if (immOffset < 0) {
    compiler.currentType = outType;
    return module.unreachable();
  }
  compiler.currentType = outType;
  return module.atomic_load(
    type.byteSize,
    arg0,
    outType.toRef(),
    immOffset
  );
}
builtins.set(BuiltinNames.atomic_load, builtin_atomic_load);

// atomic.store<T!>(offset: usize, value: T*, immOffset?: usize) -> void
function builtin_atomic_store(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.THREADS) |
    checkTypeRequired(ctx) |
    checkArgsOptional(ctx, 2, 3)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var contextualType = ctx.contextualType;
  var type = typeArguments![0];
  if (!type.isIntegerValue) {
    compiler.error(
      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
      ctx.reportNode.typeArgumentsRange, "atomic.store", type.toString()
    );
    compiler.currentType = Type.void;
    return module.unreachable();
  }
  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);
  var arg1 = ctx.contextIsExact
    ? compiler.compileExpression(
        operands[1],
        contextualType,
        Constraints.CONV_IMPLICIT
      )
    : compiler.compileExpression(
        operands[1],
        type,
        type.isIntegerValue
          ? Constraints.NONE // no need to convert to small int (but now might result in a float)
          : Constraints.CONV_IMPLICIT
      );
  var inType = compiler.currentType;
  if (
    type.isIntegerValue &&
    (
      !inType.isIntegerValue|| // float to int
      inType.size < type.size  // int to larger int (clear garbage bits)
    )
  ) {
    // either conversion or memory operation clears garbage bits
    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);
    inType = type;
  }
  var immOffset = operands.length == 3 ? evaluateImmediateOffset(operands[2], compiler) : 0; // reports
  if (immOffset < 0) {
    compiler.currentType = Type.void;
    return module.unreachable();
  }
  compiler.currentType = Type.void;
  return module.atomic_store(type.byteSize, arg0, arg1, inType.toRef(), immOffset);
}
builtins.set(BuiltinNames.atomic_store, builtin_atomic_store);

// any_atomic_binary<T!>(ptr, value: T, immOffset?: usize) -> T
function builtin_atomic_binary(ctx: BuiltinContext, op: AtomicRMWOp, opName: string): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.THREADS) |
    checkTypeRequired(ctx, true) |
    checkArgsOptional(ctx, 2, 3)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var contextualType = ctx.contextualType;
  var type = typeArguments![0];
  if (!type.isIntegerValue || type.size < 8) {
    compiler.error(
      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
      ctx.reportNode.typeArgumentsRange, opName, type.toString()
    );
    return module.unreachable();
  }
  var arg0 = compiler.compileExpression(operands[0],
    compiler.options.usizeType,
    Constraints.CONV_IMPLICIT
  );
  var arg1 = ctx.contextIsExact
    ? compiler.compileExpression(operands[1],
        contextualType,
        Constraints.CONV_IMPLICIT
      )
    : compiler.compileExpression(
        operands[1],
        type,
        type.isIntegerValue
          ? Constraints.NONE // no need to convert to small int (but now might result in a float)
          : Constraints.CONV_IMPLICIT
      );
  var inType = compiler.currentType;
  if (
    type.isIntegerValue &&
    (
      !inType.isIntegerValue || // float to int
      inType.size < type.size   // int to larger int (clear garbage bits)
    )
  ) {
    // either conversion or memory operation clears garbage bits
    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);
    inType = type;
  }
  var immOffset = operands.length == 3 ? evaluateImmediateOffset(operands[2], compiler) : 0; // reports
  if (immOffset < 0) {
    compiler.currentType = inType;
    return module.unreachable();
  }
  compiler.currentType = inType;
  return module.atomic_rmw(op, type.byteSize, immOffset, arg0, arg1, inType.toRef());
}

// atomic.add<T!>(ptr, value: T, immOffset?: usize) -> T
function builtin_atomic_add(ctx: BuiltinContext): ExpressionRef {
  return builtin_atomic_binary(ctx, AtomicRMWOp.Add, "atomic.add");
}
builtins.set(BuiltinNames.atomic_add, builtin_atomic_add);

// atomic.sub<T!>(ptr, value: T, immOffset?: usize) -> T
function builtin_atomic_sub(ctx: BuiltinContext): ExpressionRef {
  return builtin_atomic_binary(ctx, AtomicRMWOp.Sub, "atomic.sub");
}
builtins.set(BuiltinNames.atomic_sub, builtin_atomic_sub);

// atomic.and<T!>(ptr, value: T, immOffset?: usize) -> T
function builtin_atomic_and(ctx: BuiltinContext): ExpressionRef {
  return builtin_atomic_binary(ctx, AtomicRMWOp.And, "atomic.and");
}
builtins.set(BuiltinNames.atomic_and, builtin_atomic_and);

// atomic.or<T!>(ptr, value: T, immOffset?: usize) -> T
function builtin_atomic_or(ctx: BuiltinContext): ExpressionRef {
  return builtin_atomic_binary(ctx, AtomicRMWOp.Or, "atomic.or");
}
builtins.set(BuiltinNames.atomic_or, builtin_atomic_or);

// atomic.xor<T!>(ptr, value: T, immOffset?: usize) -> T
function builtin_atomic_xor(ctx: BuiltinContext): ExpressionRef {
  return builtin_atomic_binary(ctx, AtomicRMWOp.Xor, "atomic.xor");
}
builtins.set(BuiltinNames.atomic_xor, builtin_atomic_xor);

// atomic.xchg<T!>(ptr, value: T, immOffset?: usize) -> T
function builtin_atomic_xchg(ctx: BuiltinContext): ExpressionRef {
  return builtin_atomic_binary(ctx, AtomicRMWOp.Xchg, "atomic.xchg");
}
builtins.set(BuiltinNames.atomic_xchg, builtin_atomic_xchg);

// atomic.cmpxchg<T!>(ptr: usize, expected: T, replacement: T, off?: usize) -> T
function builtin_atomic_cmpxchg(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.THREADS) |
    checkTypeRequired(ctx, true) |
    checkArgsOptional(ctx, 3, 4)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var contextualType = ctx.contextualType;
  var type = typeArguments![0];
  if (!type.isIntegerValue || type.size < 8) {
    compiler.error(
      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
      ctx.reportNode.typeArgumentsRange, "atomic.cmpxchg", type.toString()
    );
    return module.unreachable();
  }
  var arg0 = compiler.compileExpression(operands[0],
    compiler.options.usizeType,
    Constraints.CONV_IMPLICIT
  );
  var arg1 = ctx.contextIsExact
    ? compiler.compileExpression(operands[1],
        contextualType,
        Constraints.CONV_IMPLICIT
      )
    : compiler.compileExpression(
        operands[1],
        type,
        type.isIntegerValue
          ? Constraints.NONE // no need to convert to small int (but now might result in a float)
          : Constraints.CONV_IMPLICIT
      );
  var inType = compiler.currentType;
  var arg2 = compiler.compileExpression(operands[2],
    inType,
    Constraints.CONV_IMPLICIT
  );
  if (
    type.isIntegerValue &&
    (
      !inType.isIntegerValue || // float to int
      inType.size < type.size   // int to larger int (clear garbage bits)
    )
  ) {
    // either conversion or memory operation clears garbage bits
    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);
    arg2 = compiler.convertExpression(arg2, inType, type, false, operands[2]);
    inType = type;
  }
  var immOffset = operands.length == 4 ? evaluateImmediateOffset(operands[3], compiler) : 0; // reports
  if (immOffset < 0) {
    compiler.currentType = inType;
    return module.unreachable();
  }
  compiler.currentType = inType;
  return module.atomic_cmpxchg(type.byteSize, immOffset, arg0, arg1, arg2, inType.toRef());
}
builtins.set(BuiltinNames.atomic_cmpxchg, builtin_atomic_cmpxchg);

// atomic.wait<T!>(ptr: usize, expected: T, timeout: i64) -> i32
function builtin_atomic_wait(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.THREADS) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 3)
  ) {
    compiler.currentType = Type.i32;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var type = typeArguments![0];
  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);
  var arg2 = compiler.compileExpression(operands[2], Type.i64, Constraints.CONV_IMPLICIT);
  compiler.currentType = Type.i32;
  switch (type.kind) {
    case TypeKind.I32:
    case TypeKind.I64:
    case TypeKind.ISIZE:
    case TypeKind.U32:
    case TypeKind.U64:
    case TypeKind.USIZE: return module.atomic_wait(arg0, arg1, arg2, type.toRef());
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "atomic.wait", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.atomic_wait, builtin_atomic_wait);

// atomic.notify(ptr: usize, count: i32) -> i32
function builtin_atomic_notify(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.THREADS) |
    checkTypeAbsent(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.i32;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.i32, Constraints.CONV_IMPLICIT);
  compiler.currentType = Type.i32;
  return module.atomic_notify(arg0, arg1);
}
builtins.set(BuiltinNames.atomic_notify, builtin_atomic_notify);

// atomic.fence() -> void
function builtin_atomic_fence(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  compiler.currentType = Type.void;
  if (
    checkFeatureEnabled(ctx, Feature.THREADS) |
    checkTypeAbsent(ctx) |
    checkArgsRequired(ctx, 0)
  ) return module.unreachable();
  return module.atomic_fence();
}
builtins.set(BuiltinNames.atomic_fence, builtin_atomic_fence);

// === Control flow ===========================================================================

// select<T?>(ifTrue: T, ifFalse: T, condition: bool) -> T
function builtin_select(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeOptional(ctx, true) |
    checkArgsRequired(ctx, 3)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var arg0 = typeArguments
    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)
    : compiler.compileExpression(operands[0], Type.auto);
  var type = compiler.currentType;
  if (!type.isAny(TypeFlags.VALUE | TypeFlags.REFERENCE)) {
    compiler.error(
      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
      ctx.reportNode.typeArgumentsRange, "select", type.toString()
    );
    return module.unreachable();
  }
  var arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);
  var arg2 = compiler.makeIsTrueish(
    compiler.compileExpression(operands[2], Type.bool),
    compiler.currentType, // ^
    operands[2]
  );
  compiler.currentType = type;
  return module.select(arg0, arg1, arg2);
}
builtins.set(BuiltinNames.select, builtin_select);

// unreachable() -> *
function builtin_unreachable(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  checkArgsRequired(ctx, 0);
  return ctx.compiler.module.unreachable();
}
builtins.set(BuiltinNames.unreachable, builtin_unreachable);

// === Memory =================================================================================

// memory.size() -> i32
function builtin_memory_size(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  compiler.currentType = Type.i32;
  if (
    checkTypeAbsent(ctx) |
    checkArgsRequired(ctx, 0)
  ) return module.unreachable();
  return module.memory_size();
}
builtins.set(BuiltinNames.memory_size, builtin_memory_size);

// memory.grow(pages: i32) -> i32
function builtin_memory_grow(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  compiler.currentType = Type.i32;
  if (
    checkTypeAbsent(ctx) |
    checkArgsRequired(ctx, 1)
  ) return module.unreachable();
  return module.memory_grow(compiler.compileExpression(ctx.operands[0], Type.i32, Constraints.CONV_IMPLICIT));
}
builtins.set(BuiltinNames.memory_grow, builtin_memory_grow);

// memory.copy(dest: usize, src: usize: n: usize) -> void
function builtin_memory_copy(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  compiler.currentType = Type.void;
  if (
    checkTypeAbsent(ctx) |
    checkArgsRequired(ctx, 3)
  ) return module.unreachable();
  var operands = ctx.operands;
  if (!compiler.options.hasFeature(Feature.BULK_MEMORY)) {
    // use stdlib alternative if not supported
    let instance = compiler.resolver.resolveFunction(ctx.prototype, null); // reports
    compiler.currentType = Type.void;
    if (!instance || !compiler.compileFunction(instance, true)) return module.unreachable();
    return compiler.compileCallDirect(instance, operands, ctx.reportNode);
  }
  var usizeType = compiler.options.usizeType;
  var arg0 = compiler.compileExpression(operands[0], usizeType, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], usizeType, Constraints.CONV_IMPLICIT);
  var arg2 = compiler.compileExpression(operands[2], usizeType, Constraints.CONV_IMPLICIT);
  compiler.currentType = Type.void;
  return module.memory_copy(arg0, arg1, arg2);
}
builtins.set(BuiltinNames.memory_copy, builtin_memory_copy);

// memory.fill(dest: usize, value: u8, n: usize) -> void
function builtin_memory_fill(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  compiler.currentType = Type.void;
  if (
    checkTypeAbsent(ctx) |
    checkArgsRequired(ctx, 3)
  ) return module.unreachable();
  var operands = ctx.operands;
  if (!compiler.options.hasFeature(Feature.BULK_MEMORY)) {
    // use stdlib alternative if not supported
    let instance = compiler.resolver.resolveFunction(ctx.prototype, null); // reports
    compiler.currentType = Type.void;
    if (!instance || !compiler.compileFunction(instance, true)) return module.unreachable();
    return compiler.compileCallDirect(instance, operands, ctx.reportNode);
  }
  var usizeType = compiler.options.usizeType;
  var arg0 = compiler.compileExpression(operands[0], usizeType, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.CONV_IMPLICIT);
  var arg2 = compiler.compileExpression(operands[2], usizeType, Constraints.CONV_IMPLICIT);
  compiler.currentType = Type.void;
  return module.memory_fill(arg0, arg1, arg2);
}
builtins.set(BuiltinNames.memory_fill, builtin_memory_fill);

// memory.data(size[, align]) -> usize
// memory.data<T>(values[, align]) -> usize
function builtin_memory_data(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  compiler.currentType = Type.i32;
  if (
    checkTypeOptional(ctx) |
    checkArgsOptional(ctx, 1, 2)
  ) return module.unreachable();
  var typeArguments = ctx.typeArguments;
  var operands = ctx.operands;
  var numOperands = operands.length;
  var usizeType = compiler.options.usizeType;
  var offset: i64;
  if (typeArguments !== null && typeArguments.length > 0) { // data<T>(values[, align])
    let elementType = typeArguments[0];
    if (!elementType.isValue) {
      compiler.error(
        DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
        ctx.reportNode.typeArgumentsRange, "memory.data", elementType.toString()
      );
      compiler.currentType = usizeType;
      return module.unreachable();
    }
    let valuesOperand = operands[0];
    if (valuesOperand.kind != NodeKind.LITERAL || (<LiteralExpression>valuesOperand).literalKind != LiteralKind.ARRAY) {
      compiler.error(
        DiagnosticCode.Array_literal_expected,
        operands[0].range
      );
      compiler.currentType = usizeType;
      return module.unreachable();
    }
    let expressions = (<ArrayLiteralExpression>valuesOperand).elementExpressions;
    let numElements = expressions.length;
    let exprs = new Array<ExpressionRef>(numElements);
    let isStatic = true;
    for (let i = 0; i < numElements; ++i) {
      let elementExpression = expressions[i];
      if (elementExpression.kind != NodeKind.OMITTED) {
        let expr = compiler.compileExpression(elementExpression, elementType, Constraints.CONV_IMPLICIT);
        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);
        if (precomp) {
          expr = precomp;
        } else {
          isStatic = false;
        }
        exprs[i] = expr;
      } else {
        exprs[i] = compiler.makeZero(elementType, elementExpression);
      }
    }
    if (!isStatic) {
      compiler.error(
        DiagnosticCode.Expression_must_be_a_compile_time_constant,
        valuesOperand.range
      );
      compiler.currentType = usizeType;
      return module.unreachable();
    }
    let align = elementType.byteSize;
    if (numOperands == 2) {
      align = evaluateImmediateAlign(operands[1], align, compiler); // reports
      if (align < 0) {
        compiler.currentType = usizeType;
        return module.unreachable();
      }
    }
    let buf = new Uint8Array(numElements * elementType.byteSize);
    assert(compiler.writeStaticBuffer(buf, 0, elementType, exprs) == buf.byteLength);
    offset = compiler.addAlignedMemorySegment(buf, align).offset;
  } else { // data(size[, align])
    let arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.CONV_IMPLICIT);
    let precomp = module.runExpression(arg0, ExpressionRunnerFlags.PreserveSideeffects);
    if (!precomp) {
      compiler.error(
        DiagnosticCode.Expression_must_be_a_compile_time_constant,
        operands[0].range
      );
      compiler.currentType = usizeType;
      return module.unreachable();
    }
    let size = getConstValueI32(precomp);
    if (size < 1) {
      compiler.error(
        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,
        operands[0].range, "1", i32.MAX_VALUE.toString()
      );
      compiler.currentType = usizeType;
      return module.unreachable();
    }
    let align = 16;
    if (numOperands == 2) {
      align = evaluateImmediateAlign(operands[1], align, compiler); // reports
      if (align < 0) {
        compiler.currentType = usizeType;
        return module.unreachable();
      }
    }
    offset = compiler.addAlignedMemorySegment(new Uint8Array(size), align).offset;
  }
  // FIXME: what if recompiles happen? recompiles are bad.
  compiler.currentType = usizeType;
  if (usizeType == Type.usize32) {
    assert(!i64_high(offset));
    return module.i32(i64_low(offset));
  } else {
    return module.i64(i64_low(offset), i64_high(offset));
  }
}
builtins.set(BuiltinNames.memory_data, builtin_memory_data);

// === GC =====================================================================================

function builtin_i31_new(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeAbsent(ctx) |
    checkArgsRequired(ctx, 1)
  ) return module.unreachable();
  var operands = ctx.operands;
  var arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.CONV_IMPLICIT);
  compiler.currentType = Type.i31ref;
  return module.i31_new(arg0);
}
builtins.set(BuiltinNames.i31_new, builtin_i31_new);

function builtin_i31_get(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeAbsent(ctx) |
    checkArgsRequired(ctx, 1)
  ) return module.unreachable();
  var operands = ctx.operands;
  var arg0 = compiler.compileExpression(operands[0], Type.i31ref, Constraints.CONV_IMPLICIT);
  if (ctx.contextualType.is(TypeFlags.UNSIGNED)) {
    compiler.currentType = Type.u32;
    return module.i31_get(arg0, false);
  } else {
    compiler.currentType = Type.i32;
    return module.i31_get(arg0, true);
  }
}
builtins.set(BuiltinNames.i31_get, builtin_i31_get);

// === Helpers ================================================================================

// changetype<T!>(value: *) -> T
function builtin_changetype(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeRequired(ctx, true) |
    checkArgsRequired(ctx, 1)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var toType = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.auto);
  var fromType = compiler.currentType;
  compiler.currentType = toType;
  if (!fromType.isChangeableTo(toType)) {
    compiler.error(
      DiagnosticCode.Type_0_cannot_be_changed_to_type_1,
      ctx.reportNode.range, fromType.toString(), toType.toString()
    );
    return module.unreachable();
  }
  return arg0;
}
builtins.set(BuiltinNames.changetype, builtin_changetype);

// assert<T?>(isTrueish: T, message?: string) -> T{!= null}
function builtin_assert(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  var typeArguments = ctx.typeArguments;
  if (
    checkTypeOptional(ctx, true) |
    checkArgsOptional(ctx, 1, 2)
  ) {
    if (typeArguments) {
      assert(typeArguments.length); // otherwise invalid, should not been set at all
      compiler.currentType = typeArguments[0].nonNullableType;
    }
    return module.unreachable();
  }
  var operands = ctx.operands;
  var contextualType = ctx.contextualType;
  var arg0 = typeArguments
    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)
    : compiler.compileExpression(operands[0], Type.bool, Constraints.MUST_WRAP);
  var type = compiler.currentType;
  compiler.currentType = type.nonNullableType;

  // omit if assertions are disabled
  if (compiler.options.noAssert) {
    return arg0;
  }

  // omit if the assertion can be proven statically
  var evaled = module.runExpression(arg0, ExpressionRunnerFlags.Default);
  if (evaled) {
    switch (<u32>getExpressionType(evaled)) {
      case <u32>TypeRef.I32: {
        if (getConstValueI32(evaled)) {
          return arg0;
        }
        break;
      }
      case <u32>TypeRef.I64: {
        if (getConstValueI64Low(evaled) | getConstValueI64High(evaled)) {
          return arg0;
        }
        break;
      }
      case <u32>TypeRef.F32: {
        if (getConstValueF32(evaled)) {
          return arg0;
        }
        break;
      }
      case <u32>TypeRef.F64: {
        if (getConstValueF64(evaled)) {
          return arg0;
        }
        break;
      }
    }
  }

  // otherwise call abort if the assertion is false-ish
  var abort = compiler.makeAbort(operands.length == 2 ? operands[1] : null, ctx.reportNode);
  compiler.currentType = type.nonNullableType;
  if (contextualType == Type.void) { // simplify if dropped anyway
    compiler.currentType = Type.void;
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.I32:
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.U32:
      case TypeKind.BOOL: return module.if(module.unary(UnaryOp.EqzI32, arg0), abort);
      case TypeKind.I64:
      case TypeKind.U64: return module.if(module.unary(UnaryOp.EqzI64, arg0), abort);
      case TypeKind.ISIZE:
      case TypeKind.USIZE: {
        return module.if(
          module.unary(
            compiler.options.isWasm64
              ? UnaryOp.EqzI64
              : UnaryOp.EqzI32,
            arg0
          ),
          abort
        );
      }
      // TODO: also check for NaN in float assertions, as in `Boolean(NaN) -> false`?
      case TypeKind.F32: return module.if(module.binary(BinaryOp.EqF32, arg0, module.f32(0)), abort);
      case TypeKind.F64: return module.if(module.binary(BinaryOp.EqF64, arg0, module.f64(0)), abort);
      case TypeKind.FUNCREF:
      case TypeKind.EXTERNREF:
      case TypeKind.ANYREF:
      case TypeKind.EQREF:
      case TypeKind.DATAREF:
      case TypeKind.I31REF: return module.if(module.ref_is(RefIsOp.RefIsNull, arg0), abort);

    }
  } else {
    compiler.currentType = type.nonNullableType;
    let flow = compiler.currentFlow;
    switch (compiler.currentType.kind) {
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.I32:
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.U32:
      case TypeKind.BOOL: {
        let temp = flow.getTempLocal(type);
        flow.setLocalFlag(temp.index, LocalFlags.WRAPPED); // arg0 is wrapped
        let ret = module.if(
          module.local_tee(temp.index, arg0, false), // numeric
          module.local_get(temp.index, TypeRef.I32),
          abort
        );
        flow.freeTempLocal(temp);
        return ret;
      }
      case TypeKind.I64:
      case TypeKind.U64: {
        let temp = flow.getTempLocal(Type.i64);
        let ret = module.if(
          module.unary(UnaryOp.EqzI64,
            module.local_tee(temp.index, arg0, false) // i64
          ),
          abort,
          module.local_get(temp.index, TypeRef.I64)
        );
        flow.freeTempLocal(temp);
        return ret;
      }
      case TypeKind.ISIZE:
      case TypeKind.USIZE: {
        let temp = flow.getTempLocal(compiler.options.usizeType);
        let ret = module.if(
          module.unary(
            compiler.options.isWasm64
              ? UnaryOp.EqzI64
              : UnaryOp.EqzI32,
            module.local_tee(temp.index, arg0, type.isManaged)
          ),
          abort,
          module.local_get(temp.index, compiler.options.sizeTypeRef)
        );
        flow.freeTempLocal(temp);
        return ret;
      }
      case TypeKind.F32: {
        let temp = flow.getTempLocal(Type.f32);
        let ret = module.if(
          module.binary(BinaryOp.EqF32,
            module.local_tee(temp.index, arg0, false), // f32
            module.f32(0)
          ),
          abort,
          module.local_get(temp.index, TypeRef.F32)
        );
        flow.freeTempLocal(temp);
        return ret;
      }
      case TypeKind.F64: {
        let temp = flow.getTempLocal(Type.f64);
        let ret = module.if(
          module.binary(BinaryOp.EqF64,
            module.local_tee(temp.index, arg0, false), // f64
            module.f64(0)
          ),
          abort,
          module.local_get(temp.index, TypeRef.F64)
        );
        flow.freeTempLocal(temp);
        return ret;
      }
      case TypeKind.FUNCREF:
      case TypeKind.EXTERNREF:
      case TypeKind.ANYREF:
      case TypeKind.EQREF:
      case TypeKind.DATAREF:
      case TypeKind.I31REF: {
        let temp = flow.getTempLocal(type);
        let ret = module.if(
          module.ref_is(RefIsOp.RefIsNull,
            module.local_tee(temp.index, arg0, false) // ref
          ),
          abort,
          module.local_get(temp.index, type.toRef())
        );
        flow.freeTempLocal(temp);
        return ret;
      }
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange,
    "assert", compiler.currentType.toString()
  );
  return abort;
}
builtins.set(BuiltinNames.assert, builtin_assert);

// unchecked(expr: *) -> *
function builtin_unchecked(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeAbsent(ctx) |
    checkArgsRequired(ctx, 1)
  ) return module.unreachable();
  var flow = compiler.currentFlow;
  var alreadyUnchecked = flow.is(FlowFlags.UNCHECKED_CONTEXT);
  flow.set(FlowFlags.UNCHECKED_CONTEXT);
  // eliminate unnecessary tees by preferring contextualType(=void)
  var expr = compiler.compileExpression(ctx.operands[0], ctx.contextualType);
  if (!alreadyUnchecked) flow.unset(FlowFlags.UNCHECKED_CONTEXT);
  return expr;
}
builtins.set(BuiltinNames.unchecked, builtin_unchecked);

// call_indirect<T?>(index: u32, ...args: *[]) -> T
function builtin_call_indirect(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeOptional(ctx, true) |
    checkArgsOptional(ctx, 1, i32.MAX_VALUE)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var returnType: Type;
  if (typeArguments) {
    assert(typeArguments.length);
    returnType = typeArguments[0];
  } else {
    returnType = ctx.contextualType;
  }
  var indexArg = compiler.compileExpression(operands[0], Type.u32, Constraints.CONV_IMPLICIT);
  var numOperands = operands.length - 1;
  var operandExprs = new Array<ExpressionRef>(numOperands);
  var paramTypeRefs = new Array<TypeRef>(numOperands);
  for (let i = 0; i < numOperands; ++i) {
    operandExprs[i] = compiler.compileExpression(operands[1 + i], Type.auto);
    paramTypeRefs[i] = compiler.currentType.toRef();
  }
  compiler.currentType = returnType;
  return module.call_indirect(indexArg, operandExprs, createType(paramTypeRefs), returnType.toRef());
}
builtins.set(BuiltinNames.call_indirect, builtin_call_indirect);

// instantiate<T!>(...args: *[]) -> T
function builtin_instantiate(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeRequired(ctx, true)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var typeArgument = typeArguments[0];
  var classInstance = typeArgument.getClass();
  if (!classInstance) {
    compiler.error(
      DiagnosticCode.This_expression_is_not_constructable,
      ctx.reportNode.expression.range
    );
    return module.unreachable();
  }
  compiler.currentType = classInstance.type;
  var ctor = compiler.ensureConstructor(classInstance, ctx.reportNode);
  compiler.checkFieldInitialization(classInstance, ctx.reportNode);
  return compiler.compileInstantiate(ctor, operands, Constraints.NONE, ctx.reportNode);
}
builtins.set(BuiltinNames.instantiate, builtin_instantiate);

// === User-defined diagnostics ===============================================================

function builtin_diagnostic(ctx: BuiltinContext, category: DiagnosticCategory): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  checkTypeAbsent(ctx);
  var operands = ctx.operands;
  var reportNode = ctx.reportNode;
  compiler.emitDiagnostic(
    DiagnosticCode.User_defined_0,
    category,
    reportNode.range,
    null,
    operands.length
      ? operands[0].range.toString()
      : reportNode.range.toString()
  );
  return category == DiagnosticCategory.ERROR
    ? module.unreachable()
    : module.nop();
}

// ERROR(message?)
function builtin_error(ctx: BuiltinContext): ExpressionRef {
  return builtin_diagnostic(ctx, DiagnosticCategory.ERROR);
}
builtins.set(BuiltinNames.ERROR, builtin_error);

// WARNING(message?)
function builtin_warning(ctx: BuiltinContext): ExpressionRef {
  return builtin_diagnostic(ctx, DiagnosticCategory.WARNING);
}
builtins.set(BuiltinNames.WARNING, builtin_warning);

// INFO(message?)
function builtin_info(ctx: BuiltinContext): ExpressionRef {
  return builtin_diagnostic(ctx, DiagnosticCategory.INFO);
}
builtins.set(BuiltinNames.INFO, builtin_info);

// === Function builtins ======================================================================

// Function<T>#call(thisArg: thisof<T> | null, ...args: *[]) -> returnof<T>
function builtin_function_call(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var parent = ctx.prototype.parent;
  assert(parent.kind == ElementKind.CLASS);
  var classInstance = <Class>parent;
  assert(classInstance.prototype == compiler.program.functionPrototype);
  var typeArguments = assert(classInstance.typeArguments);
  assert(typeArguments.length == 1);
  var ftype = typeArguments[0];
  var signature = assert(ftype.getSignature());
  var returnType = signature.returnType;
  if (
    checkTypeAbsent(ctx) |
    checkArgsOptional(ctx, 1 + signature.requiredParameters, 1 + signature.parameterTypes.length)
  ) {
    compiler.currentType = returnType;
    return compiler.module.unreachable();
  }
  var functionArg = compiler.compileExpression(assert(ctx.thisOperand), ftype, Constraints.CONV_IMPLICIT);
  var thisOperand = assert(ctx.operands.shift());
  var thisType = signature.thisType;
  var thisArg: usize = 0;
  if (thisType) {
    thisArg = compiler.compileExpression(thisOperand, thisType, Constraints.CONV_IMPLICIT);
  } else if (thisOperand.kind != NodeKind.NULL) {
    compiler.error(
      DiagnosticCode._this_cannot_be_referenced_in_current_location,
      thisOperand.range
    );
    return compiler.module.unreachable();
  }
  return compiler.compileCallIndirect(signature, functionArg, ctx.operands, ctx.reportNode, thisArg, ctx.contextualType == Type.void);
}
function_builtins.set("call", builtin_function_call);

// String.raw(parts: TemplateStringsArray, ...values: unknown[]): string
function builtin_string_raw(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  compiler.currentType = ctx.compiler.program.stringInstance.type;
  compiler.error(
    DiagnosticCode.Not_implemented_0,
    ctx.reportNode.range, "String.raw"
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.String_raw, builtin_string_raw);

// === Portable type conversions ==============================================================

function builtin_conversion(ctx: BuiltinContext, toType: Type): ExpressionRef {
  var compiler = ctx.compiler;
  if (
    checkTypeAbsent(ctx) |
    checkArgsRequired(ctx, 1)
  ) {
    compiler.currentType = toType;
    return compiler.module.unreachable();
  }
  return compiler.compileExpression(ctx.operands[0], toType, Constraints.CONV_EXPLICIT);
}

// i8(*) -> i8
function builtin_i8(ctx: BuiltinContext): ExpressionRef {
  return builtin_conversion(ctx, Type.i8);
}
builtins.set(BuiltinNames.i8, builtin_i8);

// i16(*) -> i16
function builtin_i16(ctx: BuiltinContext): ExpressionRef {
  return builtin_conversion(ctx, Type.i16);
}
builtins.set(BuiltinNames.i16, builtin_i16);

// i32(*) -> i32
function builtin_i32(ctx: BuiltinContext): ExpressionRef {
  return builtin_conversion(ctx, Type.i32);
}
builtins.set(BuiltinNames.i32, builtin_i32);

// i64(*) -> i64
function builtin_i64(ctx: BuiltinContext): ExpressionRef {
  return builtin_conversion(ctx, Type.i64);
}
builtins.set(BuiltinNames.i64, builtin_i64);

// isize(*) -> isize
function builtin_isize(ctx: BuiltinContext): ExpressionRef {
  return builtin_conversion(ctx, ctx.compiler.options.isizeType);
}
builtins.set(BuiltinNames.isize, builtin_isize);

// u8(*) -> u8
function builtin_u8(ctx: BuiltinContext): ExpressionRef {
  return builtin_conversion(ctx, Type.u8);
}
builtins.set(BuiltinNames.u8, builtin_u8);

// u16(*) -> u16
function builtin_u16(ctx: BuiltinContext): ExpressionRef {
  return builtin_conversion(ctx, Type.u16);
}
builtins.set(BuiltinNames.u16, builtin_u16);

// u32(*) -> u32
function builtin_u32(ctx: BuiltinContext): ExpressionRef {
  return builtin_conversion(ctx, Type.u32);
}
builtins.set(BuiltinNames.u32, builtin_u32);

// u64(*) -> u64
function builtin_u64(ctx: BuiltinContext): ExpressionRef {
  return builtin_conversion(ctx, Type.u64);
}
builtins.set(BuiltinNames.u64, builtin_u64);

// usize(*) -> usize
function builtin_usize(ctx: BuiltinContext): ExpressionRef {
  return builtin_conversion(ctx, ctx.compiler.options.usizeType);
}
builtins.set(BuiltinNames.usize, builtin_usize);

// bool(*) -> bool
function builtin_bool(ctx: BuiltinContext): ExpressionRef {
  return builtin_conversion(ctx, Type.bool);
}
builtins.set(BuiltinNames.bool, builtin_bool);

// f32(*) -> f32
function builtin_f32(ctx: BuiltinContext): ExpressionRef {
  return builtin_conversion(ctx, Type.f32);
}
builtins.set(BuiltinNames.f32, builtin_f32);

// f64(*) -> f64
function builtin_f64(ctx: BuiltinContext): ExpressionRef {
  return builtin_conversion(ctx, Type.f64);
}
builtins.set(BuiltinNames.f64, builtin_f64);

// TODO: alias for now, splat input integer perhaps?
function builtin_v128(ctx: BuiltinContext): ExpressionRef {
  return builtin_i8x16(ctx);
}
builtins.set(BuiltinNames.v128, builtin_v128);

// === SIMD ===================================================================================

// i8x16(...values: i8[16]) -> v128
function builtin_i8x16(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeAbsent(ctx) |
    checkArgsRequired(ctx, 16)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var bytes = new Uint8Array(16);
  for (let i = 0; i < 16; ++i) {
    let expr = compiler.compileExpression(operands[i], Type.i8, Constraints.CONV_IMPLICIT);
    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);
    if (precomp) {
      writeI8(getConstValueI32(precomp), bytes, i);
    } else {
      compiler.error(
        DiagnosticCode.Expression_must_be_a_compile_time_constant,
        operands[i].range
      );
    }
  }
  compiler.currentType = Type.v128;
  return module.v128(bytes);
}
builtins.set(BuiltinNames.i8x16, builtin_i8x16);

// i16x8(...values: i16[8]) -> v128
function builtin_i16x8(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeAbsent(ctx) |
    checkArgsRequired(ctx, 8)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var bytes = new Uint8Array(16);
  for (let i = 0; i < 8; ++i) {
    let expr = compiler.compileExpression(operands[i], Type.i16, Constraints.CONV_IMPLICIT);
    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);
    if (precomp) {
      writeI16(getConstValueI32(precomp), bytes, i << 1);
    } else {
      compiler.error(
        DiagnosticCode.Expression_must_be_a_compile_time_constant,
        operands[i].range
      );
    }
  }
  compiler.currentType = Type.v128;
  return module.v128(bytes);
}
builtins.set(BuiltinNames.i16x8, builtin_i16x8);

// i32x4(...values: i32[4]) -> v128
function builtin_i32x4(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeAbsent(ctx) |
    checkArgsRequired(ctx, 4)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var bytes = new Uint8Array(16);
  for (let i = 0; i < 4; ++i) {
    let expr = compiler.compileExpression(operands[i], Type.i32, Constraints.CONV_IMPLICIT);
    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);
    if (precomp) {
      writeI32(getConstValueI32(precomp), bytes, i << 2);
    } else {
      compiler.error(
        DiagnosticCode.Expression_must_be_a_compile_time_constant,
        operands[i].range
      );
    }
  }
  compiler.currentType = Type.v128;
  return module.v128(bytes);
}
builtins.set(BuiltinNames.i32x4, builtin_i32x4);

// i64x2(...values: i64[2]) -> v128
function builtin_i64x2(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeAbsent(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var bytes = new Uint8Array(16);
  for (let i = 0; i < 2; ++i) {
    let expr = compiler.compileExpression(operands[i], Type.i64, Constraints.CONV_IMPLICIT);
    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);
    if (precomp) {
      let off = i << 3;
      writeI32(getConstValueI64Low(precomp), bytes, off);
      writeI32(getConstValueI64High(precomp), bytes, off + 4);
    } else {
      compiler.error(
        DiagnosticCode.Expression_must_be_a_compile_time_constant,
        operands[i].range
      );
    }
  }
  compiler.currentType = Type.v128;
  return module.v128(bytes);
}
builtins.set(BuiltinNames.i64x2, builtin_i64x2);

// f32x4(...values: f32[4]) -> v128
function builtin_f32x4(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeAbsent(ctx) |
    checkArgsRequired(ctx, 4)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var bytes = new Uint8Array(16);
  for (let i = 0; i < 4; ++i) {
    let expr = compiler.compileExpression(operands[i], Type.f32, Constraints.CONV_IMPLICIT);
    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);
    if (precomp) {
      writeF32(getConstValueF32(precomp), bytes, i << 2);
    } else {
      compiler.error(
        DiagnosticCode.Expression_must_be_a_compile_time_constant,
        operands[i].range
      );
    }
  }
  compiler.currentType = Type.v128;
  return module.v128(bytes);
}
builtins.set(BuiltinNames.f32x4, builtin_f32x4);

// f64x2(...values: f64[2]) -> v128
function builtin_f64x2(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeAbsent(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var bytes = new Uint8Array(16);
  for (let i = 0; i < 2; ++i) {
    let expr = compiler.compileExpression(operands[i], Type.f64, Constraints.CONV_IMPLICIT);
    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);
    if (precomp) {
      writeF64(getConstValueF64(precomp), bytes, i << 3);
    } else {
      compiler.error(
        DiagnosticCode.Expression_must_be_a_compile_time_constant,
        operands[i].range
      );
    }
  }
  compiler.currentType = Type.v128;
  return module.v128(bytes);
}
builtins.set(BuiltinNames.f64x2, builtin_f64x2);

// v128.splat<T!>(x: T) -> v128
function builtin_v128_splat(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 1)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], type, Constraints.CONV_IMPLICIT);
  compiler.currentType = Type.v128;
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.U8: return module.unary(UnaryOp.SplatI8x16, arg0);
      case TypeKind.I16:
      case TypeKind.U16: return module.unary(UnaryOp.SplatI16x8, arg0);
      case TypeKind.I32:
      case TypeKind.U32: return module.unary(UnaryOp.SplatI32x4, arg0);
      case TypeKind.I64:
      case TypeKind.U64: return module.unary(UnaryOp.SplatI64x2, arg0);
      case TypeKind.ISIZE:
      case TypeKind.USIZE: {
        return module.unary(
          compiler.options.isWasm64
            ? UnaryOp.SplatI64x2
            : UnaryOp.SplatI32x4,
          arg0
        );
      }
      case TypeKind.F32: return module.unary(UnaryOp.SplatF32x4, arg0);
      case TypeKind.F64: return module.unary(UnaryOp.SplatF64x2, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.splat", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_splat, builtin_v128_splat);

// v128.extract_lane<T!>(x: v128, idx: u8) -> T
function builtin_v128_extract_lane(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx, true) |
    checkArgsRequired(ctx, 2)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.CONV_IMPLICIT);
  compiler.currentType = type;
  var idx = 0;
  var precomp = module.runExpression(arg1, ExpressionRunnerFlags.PreserveSideeffects);
  if (precomp) {
    idx = getConstValueI32(precomp);
  } else {
    compiler.error(
      DiagnosticCode.Expression_must_be_a_compile_time_constant,
      operands[1].range
    );
  }
  if (type.isValue) {
    let maxIdx = (16 / assert(type.byteSize)) - 1;
    if (idx < 0 || idx > maxIdx) {
      compiler.error(
        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,
        operands[1].range, "Lane index", "0", maxIdx.toString()
      );
      idx = 0;
    }
    switch (type.kind) {
      case TypeKind.I8: return module.simd_extract(SIMDExtractOp.ExtractLaneI8x16, arg0, <u8>idx);
      case TypeKind.U8: return module.simd_extract(SIMDExtractOp.ExtractLaneU8x16, arg0, <u8>idx);
      case TypeKind.I16: return module.simd_extract(SIMDExtractOp.ExtractLaneI16x8, arg0, <u8>idx);
      case TypeKind.U16: return module.simd_extract(SIMDExtractOp.ExtractLaneU16x8, arg0, <u8>idx);
      case TypeKind.I32:
      case TypeKind.U32: return module.simd_extract(SIMDExtractOp.ExtractLaneI32x4, arg0, <u8>idx);
      case TypeKind.I64:
      case TypeKind.U64: return module.simd_extract(SIMDExtractOp.ExtractLaneI64x2, arg0, <u8>idx);
      case TypeKind.ISIZE:
      case TypeKind.USIZE: {
        return module.simd_extract(
          compiler.options.isWasm64
            ? SIMDExtractOp.ExtractLaneI64x2
            : SIMDExtractOp.ExtractLaneI32x4,
          arg0, <u8>idx
        );
      }
      case TypeKind.F32: return module.simd_extract(SIMDExtractOp.ExtractLaneF32x4, arg0, <u8>idx);
      case TypeKind.F64: return module.simd_extract(SIMDExtractOp.ExtractLaneF64x2, arg0, <u8>idx);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.extract_lane", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_extract_lane, builtin_v128_extract_lane);

// v128.replace_lane<T!>(x: v128, idx: u8, value: T) -> v128
function builtin_v128_replace_lane(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 3)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.CONV_IMPLICIT);
  var arg2 = compiler.compileExpression(operands[2], type, Constraints.CONV_IMPLICIT);
  compiler.currentType = Type.v128;
  var idx = 0;
  var precomp = module.runExpression(arg1, ExpressionRunnerFlags.PreserveSideeffects);
  if (precomp) {
    idx = getConstValueI32(precomp);
  } else {
    compiler.error(
      DiagnosticCode.Expression_must_be_a_compile_time_constant,
      operands[1].range
    );
  }
  if (type.isValue) {
    let maxIdx = (16 / assert(type.byteSize)) - 1;
    if (idx < 0 || idx > maxIdx) {
      compiler.error(
        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,
        operands[1].range, "Lane index", "0", maxIdx.toString()
      );
      idx = 0;
    }
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.U8: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI8x16, arg0, <u8>idx, arg2);
      case TypeKind.I16:
      case TypeKind.U16: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI16x8, arg0, <u8>idx, arg2);
      case TypeKind.I32:
      case TypeKind.U32: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI32x4, arg0, <u8>idx, arg2);
      case TypeKind.I64:
      case TypeKind.U64: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI64x2, arg0, <u8>idx, arg2);
      case TypeKind.ISIZE:
      case TypeKind.USIZE: {
        return module.simd_replace(
          compiler.options.isWasm64
            ? SIMDReplaceOp.ReplaceLaneI64x2
            : SIMDReplaceOp.ReplaceLaneI32x4,
          arg0, <u8>idx, arg2
        );
      }
      case TypeKind.F32: return module.simd_replace(SIMDReplaceOp.ReplaceLaneF32x4, arg0, <u8>idx, arg2);
      case TypeKind.F64: return module.simd_replace(SIMDReplaceOp.ReplaceLaneF64x2, arg0, <u8>idx, arg2);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.replace_lane", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_replace_lane, builtin_v128_replace_lane);

// v128.shuffle<T!>(a: v128, b: v128, ...lanes: u8[]) -> v128
function builtin_v128_shuffle(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  if (type.isValue) {
    let laneWidth = type.byteSize;
    let laneCount = 16 / laneWidth;
    assert(isInteger(laneCount) && isPowerOf2(laneCount));
    if (
      checkArgsRequired(ctx, 2 + laneCount)
    ) {
      compiler.currentType = Type.v128;
      return module.unreachable();
    }
    let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
    let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.I32:
      case TypeKind.I64:
      case TypeKind.ISIZE:
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.U32:
      case TypeKind.U64:
      case TypeKind.USIZE:
      case TypeKind.F32:
      case TypeKind.F64: {
        let mask = new Uint8Array(16);
        let maxIdx = (laneCount << 1) - 1;
        for (let i = 0; i < laneCount; ++i) {
          let operand = operands[2 + i];
          let argN = compiler.compileExpression(operand, Type.u8, Constraints.CONV_IMPLICIT);
          let precomp = module.runExpression(argN, ExpressionRunnerFlags.PreserveSideeffects);
          let idx = 0;
          if (precomp) {
            idx = getConstValueI32(precomp);
            if (idx < 0 || idx > maxIdx) {
              compiler.error(
                DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,
                operand.range, "Lane index", "0", maxIdx.toString()
              );
              idx = 0;
            }
          } else {
            compiler.error(
              DiagnosticCode.Expression_must_be_a_compile_time_constant,
              operand.range
            );
          }
          switch (laneWidth) {
            case 1: {
              writeI8(idx, mask, i);
              break;
            }
            case 2: {
              let off8 = i << 1;
              let idx8 = idx << 1;
              writeI8(idx8    , mask, off8);
              writeI8(idx8 + 1, mask, off8 + 1);
              break;
            }
            case 4: {
              let off8 = i << 2;
              let idx8 = idx << 2;
              writeI8(idx8    , mask, off8);
              writeI8(idx8 + 1, mask, off8 + 1);
              writeI8(idx8 + 2, mask, off8 + 2);
              writeI8(idx8 + 3, mask, off8 + 3);
              break;
            }
            case 8: {
              let off8 = i << 3;
              let idx8 = idx << 3;
              writeI8(idx8    , mask, off8);
              writeI8(idx8 + 1, mask, off8 + 1);
              writeI8(idx8 + 2, mask, off8 + 2);
              writeI8(idx8 + 3, mask, off8 + 3);
              writeI8(idx8 + 4, mask, off8 + 4);
              writeI8(idx8 + 5, mask, off8 + 5);
              writeI8(idx8 + 6, mask, off8 + 6);
              writeI8(idx8 + 7, mask, off8 + 7);
              break;
            }
            default: assert(false);
          }
        }
        compiler.currentType = Type.v128;
        return module.simd_shuffle(arg0, arg1, mask);
      }
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.shuffle", type.toString()
  );
  compiler.currentType = Type.v128;
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_shuffle, builtin_v128_shuffle);

// v128.swizzle(a: v128, b: v128) -> v128
function builtin_v128_swizzle(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeAbsent(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  return module.binary(BinaryOp.SwizzleI8x16, arg0, arg1);
}
builtins.set(BuiltinNames.v128_swizzle, builtin_v128_swizzle);

// v128.load_splat<T!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128
function builtin_v128_load_splat(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx, true) |
    checkArgsOptional(ctx, 1, 3)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);
  var numOperands = operands.length;
  var immOffset = 0;
  var immAlign = type.byteSize;
  if (numOperands >= 2) {
    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports
    if (immOffset < 0) {
      compiler.currentType = Type.v128;
      return module.unreachable();
    }
    if (numOperands == 3) {
      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports
      if (immAlign < 0) {
        compiler.currentType = Type.v128;
        return module.unreachable();
      }
    }
  }
  compiler.currentType = Type.v128;
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.U8: {
        return module.simd_load(SIMDLoadOp.Load8Splat, arg0, immOffset, immAlign);
      }
      case TypeKind.I16:
      case TypeKind.U16: {
        return module.simd_load(SIMDLoadOp.Load16Splat, arg0, immOffset, immAlign);
      }
      case TypeKind.I32:
      case TypeKind.U32:
      case TypeKind.F32: {
        return module.simd_load(SIMDLoadOp.Load32Splat, arg0, immOffset, immAlign);
      }
      case TypeKind.ISIZE:
      case TypeKind.USIZE: {
        if (!compiler.options.isWasm64) {
          return module.simd_load(SIMDLoadOp.Load32Splat, arg0, immOffset, immAlign);
        }
        // fall-through
      }
      case TypeKind.I64:
      case TypeKind.U64:
      case TypeKind.F64: {
        return module.simd_load(SIMDLoadOp.Load64Splat, arg0, immOffset, immAlign);
      }
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.load_splat", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_load_splat, builtin_v128_load_splat);

// v128.load_ext<TFrom!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128
function builtin_v128_load_ext(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx, true) |
    checkArgsOptional(ctx, 1, 3)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);
  var numOperands = operands.length;
  var immOffset = 0;
  var immAlign = type.byteSize;
  if (numOperands >= 2) {
    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports
    if (immOffset < 0) {
      compiler.currentType = Type.v128;
      return module.unreachable();
    }
    if (numOperands == 3) {
      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports
      if (immAlign < 0) {
        compiler.currentType = Type.v128;
        return module.unreachable();
      }
    }
  }
  compiler.currentType = Type.v128;
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8: return module.simd_load(SIMDLoadOp.Load8x8S, arg0, immOffset, immAlign);
      case TypeKind.U8: return module.simd_load(SIMDLoadOp.Load8x8U, arg0, immOffset, immAlign);
      case TypeKind.I16: return module.simd_load(SIMDLoadOp.Load16x4S, arg0, immOffset, immAlign);
      case TypeKind.U16: return module.simd_load(SIMDLoadOp.Load16x4U, arg0, immOffset, immAlign);
      case TypeKind.ISIZE: {
        if (compiler.options.isWasm64) break;
        // fall-through
      }
      case TypeKind.I32: return module.simd_load(SIMDLoadOp.Load32x2S, arg0, immOffset, immAlign);
      case TypeKind.USIZE: {
        if (compiler.options.isWasm64) break;
        // fall-through
      }
      case TypeKind.U32: return module.simd_load(SIMDLoadOp.Load32x2U, arg0, immOffset, immAlign);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.load_ext", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_load_ext, builtin_v128_load_ext);

// v128.load_zero<TFrom!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128
function builtin_v128_load_zero(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx, true) |
    checkArgsOptional(ctx, 1, 3)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);
  var numOperands = operands.length;
  var immOffset = 0;
  var immAlign = type.byteSize;
  if (numOperands >= 2) {
    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports
    if (immOffset < 0) {
      compiler.currentType = Type.v128;
      return module.unreachable();
    }
    if (numOperands == 3) {
      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports
      if (immAlign < 0) {
        compiler.currentType = Type.v128;
        return module.unreachable();
      }
    }
  }
  compiler.currentType = Type.v128;
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I32:
      case TypeKind.U32:
      case TypeKind.F32: return module.simd_load(SIMDLoadOp.Load32Zero, arg0, immOffset, immAlign);
      case TypeKind.I64:
      case TypeKind.U64:
      case TypeKind.F64: return module.simd_load(SIMDLoadOp.Load64Zero, arg0, immOffset, immAlign);
      case TypeKind.ISIZE:
      case TypeKind.USIZE: return module.simd_load(compiler.options.isWasm64 ? SIMDLoadOp.Load64Zero : SIMDLoadOp.Load32Zero, arg0, immOffset, immAlign);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.load_zero", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_load_zero, builtin_v128_load_zero);

// v128.load_lane<TFrom!>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize) -> v128
function builtin_v128_load_lane(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx, true) |
    checkArgsOptional(ctx, 3, 5)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  var arg2 = compiler.compileExpression(operands[2], Type.u8, Constraints.CONV_IMPLICIT);
  var idx = 0;
  var precomp = module.runExpression(arg2, ExpressionRunnerFlags.PreserveSideeffects);
  if (precomp) {
    idx = getConstValueI32(precomp);
  } else {
    compiler.error(
      DiagnosticCode.Expression_must_be_a_compile_time_constant,
      operands[2].range
    );
  }
  var numOperands = operands.length;
  var immOffset = 0;
  var immAlign = type.byteSize;
  if (numOperands >= 4) {
    immOffset = evaluateImmediateOffset(operands[3], compiler); // reports
    if (immOffset < 0) {
      compiler.currentType = Type.v128;
      return module.unreachable();
    }
    if (numOperands == 5) {
      immAlign = evaluateImmediateAlign(operands[4], immAlign, compiler); // reports
      if (immAlign < 0) {
        compiler.currentType = Type.v128;
        return module.unreachable();
      }
    }
  }
  compiler.currentType = Type.v128;
  if (type.isValue) {
    let maxIdx = (16 / assert(type.byteSize)) - 1;
    if (idx < 0 || idx > maxIdx) {
      compiler.error(
        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,
        operands[1].range, "Lane index", "0", maxIdx.toString()
      );
      idx = 0;
    }
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.U8: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load8Lane, arg0, immOffset, immAlign, <u8>idx, arg1);
      case TypeKind.I16:
      case TypeKind.U16: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load16Lane, arg0, immOffset, immAlign, <u8>idx, arg1);
      case TypeKind.I32:
      case TypeKind.U32:
      case TypeKind.F32: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load32Lane, arg0, immOffset, immAlign, <u8>idx, arg1);
      case TypeKind.I64:
      case TypeKind.U64:
      case TypeKind.F64: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load64Lane, arg0, immOffset, immAlign, <u8>idx, arg1);
      case TypeKind.ISIZE:
      case TypeKind.USIZE: return module.simd_loadstorelane(compiler.options.isWasm64 ? SIMDLoadStoreLaneOp.Load64Lane : SIMDLoadStoreLaneOp.Load32Lane, arg0, immOffset, immAlign, <u8>idx, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.load_lane", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_load_lane, builtin_v128_load_lane);

// v128.store_lane<TFrom!>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize) -> v128
function builtin_v128_store_lane(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx, true) |
    checkArgsOptional(ctx, 3, 5)
  ) return module.unreachable();
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  var arg2 = compiler.compileExpression(operands[2], Type.u8, Constraints.CONV_IMPLICIT);
  var idx = 0;
  var precomp = module.runExpression(arg2, ExpressionRunnerFlags.PreserveSideeffects);
  if (precomp) {
    idx = getConstValueI32(precomp);
  } else {
    compiler.error(
      DiagnosticCode.Expression_must_be_a_compile_time_constant,
      operands[2].range
    );
  }
  var numOperands = operands.length;
  var immOffset = 0;
  var immAlign = type.byteSize;
  if (numOperands >= 4) {
    immOffset = evaluateImmediateOffset(operands[3], compiler); // reports
    if (immOffset < 0) {
      compiler.currentType = Type.v128;
      return module.unreachable();
    }
    if (numOperands == 5) {
      immAlign = evaluateImmediateAlign(operands[4], immAlign, compiler); // reports
      if (immAlign < 0) {
        compiler.currentType = Type.v128;
        return module.unreachable();
      }
    }
  }
  compiler.currentType = Type.v128;
  if (type.isValue) {
    let maxIdx = (16 / assert(type.byteSize)) - 1;
    if (idx < 0 || idx > maxIdx) {
      compiler.error(
        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,
        operands[1].range, "Lane index", "0", maxIdx.toString()
      );
      idx = 0;
    }
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.U8: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store8Lane, arg0, immOffset, immAlign, <u8>idx, arg1);
      case TypeKind.I16:
      case TypeKind.U16: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store16Lane, arg0, immOffset, immAlign, <u8>idx, arg1);
      case TypeKind.I32:
      case TypeKind.U32:
      case TypeKind.F32: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store32Lane, arg0, immOffset, immAlign, <u8>idx, arg1);
      case TypeKind.I64:
      case TypeKind.U64:
      case TypeKind.F64: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store64Lane, arg0, immOffset, immAlign, <u8>idx, arg1);
      case TypeKind.ISIZE:
      case TypeKind.USIZE: return module.simd_loadstorelane(compiler.options.isWasm64 ? SIMDLoadStoreLaneOp.Store64Lane : SIMDLoadStoreLaneOp.Store32Lane, arg0, immOffset, immAlign, <u8>idx, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.store_lane", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_store_lane, builtin_v128_store_lane);

// v128.add<T!>(a: v128, b: v128) -> v128
function builtin_v128_add(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.U8: return module.binary(BinaryOp.AddI8x16, arg0, arg1);
      case TypeKind.I16:
      case TypeKind.U16: return module.binary(BinaryOp.AddI16x8, arg0, arg1);
      case TypeKind.I32:
      case TypeKind.U32: return module.binary(BinaryOp.AddI32x4, arg0, arg1);
      case TypeKind.I64:
      case TypeKind.U64: return module.binary(BinaryOp.AddI64x2, arg0, arg1);
      case TypeKind.ISIZE:
      case TypeKind.USIZE: {
        return module.binary(
          compiler.options.isWasm64
            ? BinaryOp.AddI64x2
            : BinaryOp.AddI32x4,
          arg0, arg1
        );
      }
      case TypeKind.F32: return module.binary(BinaryOp.AddF32x4, arg0, arg1);
      case TypeKind.F64: return module.binary(BinaryOp.AddF64x2, arg0, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.add", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_add, builtin_v128_add);

// v128.sub<T!>(a: v128, b: v128) -> v128
function builtin_v128_sub(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.U8: return module.binary(BinaryOp.SubI8x16, arg0, arg1);
      case TypeKind.I16:
      case TypeKind.U16: return module.binary(BinaryOp.SubI16x8, arg0, arg1);
      case TypeKind.I32:
      case TypeKind.U32: return module.binary(BinaryOp.SubI32x4, arg0, arg1);
      case TypeKind.I64:
      case TypeKind.U64: return module.binary(BinaryOp.SubI64x2, arg0, arg1);
      case TypeKind.ISIZE:
      case TypeKind.USIZE: {
        return module.binary(
          compiler.options.isWasm64
            ? BinaryOp.SubI64x2
            : BinaryOp.SubI32x4,
          arg0, arg1
        );
      }
      case TypeKind.F32: return module.binary(BinaryOp.SubF32x4, arg0, arg1);
      case TypeKind.F64: return module.binary(BinaryOp.SubF64x2, arg0, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.sub", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_sub, builtin_v128_sub);

// v128.mul<T!>(a: v128, b: v128) -> v128
function builtin_v128_mul(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I16:
      case TypeKind.U16: return module.binary(BinaryOp.MulI16x8, arg0, arg1);
      case TypeKind.I32:
      case TypeKind.U32: return module.binary(BinaryOp.MulI32x4, arg0, arg1);
      case TypeKind.I64:
      case TypeKind.U64: return module.binary(BinaryOp.MulI64x2, arg0, arg1);
      case TypeKind.ISIZE:
      case TypeKind.USIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.MulI64x2 : BinaryOp.MulI32x4, arg0, arg1);
      case TypeKind.F32: return module.binary(BinaryOp.MulF32x4, arg0, arg1);
      case TypeKind.F64: return module.binary(BinaryOp.MulF64x2, arg0, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.mul", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_mul, builtin_v128_mul);

// v128.div<T!>(a: v128, b: v128) -> v128
function builtin_v128_div(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.F32: return module.binary(BinaryOp.DivF32x4, arg0, arg1);
      case TypeKind.F64: return module.binary(BinaryOp.DivF64x2, arg0, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.div", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_div, builtin_v128_div);

// v128.add_sat<T!>(a: v128, b: v128) -> v128
function builtin_v128_add_sat(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8: return module.binary(BinaryOp.AddSatI8x16, arg0, arg1);
      case TypeKind.U8: return module.binary(BinaryOp.AddSatU8x16, arg0, arg1);
      case TypeKind.I16: return module.binary(BinaryOp.AddSatI16x8, arg0, arg1);
      case TypeKind.U16: return module.binary(BinaryOp.AddSatU16x8, arg0, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.add_sat", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_add_sat, builtin_v128_add_sat);

// v128.sub_sat<T!>(a: v128, b: v128) -> v128
function builtin_v128_sub_sat(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8: return module.binary(BinaryOp.SubSatI8x16, arg0, arg1);
      case TypeKind.U8: return module.binary(BinaryOp.SubSatU8x16, arg0, arg1);
      case TypeKind.I16: return module.binary(BinaryOp.SubSatI16x8, arg0, arg1);
      case TypeKind.U16: return module.binary(BinaryOp.SubSatU16x8, arg0, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.sub_sat", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_sub_sat, builtin_v128_sub_sat);

// v128.min<T!>(a: v128, b: v128) -> v128
function builtin_v128_min(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8: return module.binary(BinaryOp.MinI8x16, arg0, arg1);
      case TypeKind.U8: return module.binary(BinaryOp.MinU8x16, arg0, arg1);
      case TypeKind.I16: return module.binary(BinaryOp.MinI16x8, arg0, arg1);
      case TypeKind.U16: return module.binary(BinaryOp.MinU16x8, arg0, arg1);
      case TypeKind.ISIZE: {
        if (compiler.options.isWasm64) break;
        // fall-through
      }
      case TypeKind.I32: return module.binary(BinaryOp.MinI32x4, arg0, arg1);
      case TypeKind.USIZE: {
        if (compiler.options.isWasm64) break;
        // fall-through
      }
      case TypeKind.U32: return module.binary(BinaryOp.MinU32x4, arg0, arg1);
      case TypeKind.F32: return module.binary(BinaryOp.MinF32x4, arg0, arg1);
      case TypeKind.F64: return module.binary(BinaryOp.MinF64x2, arg0, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.min", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_min, builtin_v128_min);

// v128.max<T!>(a: v128, b: v128) -> v128
function builtin_v128_max(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8: return module.binary(BinaryOp.MaxI8x16, arg0, arg1);
      case TypeKind.U8: return module.binary(BinaryOp.MaxU8x16, arg0, arg1);
      case TypeKind.I16: return module.binary(BinaryOp.MaxI16x8, arg0, arg1);
      case TypeKind.U16: return module.binary(BinaryOp.MaxU16x8, arg0, arg1);
      case TypeKind.ISIZE: {
        if (compiler.options.isWasm64) break;
        // fall-through
      }
      case TypeKind.I32: return module.binary(BinaryOp.MaxI32x4, arg0, arg1);
      case TypeKind.USIZE: {
        if (compiler.options.isWasm64) break;
        // fall-through
      }
      case TypeKind.U32: return module.binary(BinaryOp.MaxU32x4, arg0, arg1);
      case TypeKind.F32: return module.binary(BinaryOp.MaxF32x4, arg0, arg1);
      case TypeKind.F64: return module.binary(BinaryOp.MaxF64x2, arg0, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.max", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_max, builtin_v128_max);

// v128.pmin<T!>(a: v128, b: v128) -> v128
function builtin_v128_pmin(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.F32: return module.binary(BinaryOp.PminF32x4, arg0, arg1);
      case TypeKind.F64: return module.binary(BinaryOp.PminF64x2, arg0, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.pmin", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_pmin, builtin_v128_pmin);

// v128.pmax<T!>(a: v128, b: v128) -> v128
function builtin_v128_pmax(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.F32: return module.binary(BinaryOp.PmaxF32x4, arg0, arg1);
      case TypeKind.F64: return module.binary(BinaryOp.PmaxF64x2, arg0, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.pmax", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_pmax, builtin_v128_pmax);

// v128.dot<T!>(a: v128, b: v128) -> v128
function builtin_v128_dot(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I16: return module.binary(BinaryOp.DotI16x8, arg0, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.dot", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_dot, builtin_v128_dot);

// v128.avgr<T!>(a: v128, b: v128) -> v128
function builtin_v128_avgr(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.U8:  return module.binary(BinaryOp.AvgrU8x16, arg0, arg1);
      case TypeKind.U16: return module.binary(BinaryOp.AvgrU16x8, arg0, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.avgr", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_avgr, builtin_v128_avgr);

// v128.eq<T!>(a: v128, b: v128) -> v128
function builtin_v128_eq(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.U8: return module.binary(BinaryOp.EqI8x16, arg0, arg1);
      case TypeKind.I16:
      case TypeKind.U16: return module.binary(BinaryOp.EqI16x8, arg0, arg1);
      case TypeKind.I32:
      case TypeKind.U32: return module.binary(BinaryOp.EqI32x4, arg0, arg1);
      case TypeKind.I64:
      case TypeKind.U64: return module.binary(BinaryOp.EqI64x2, arg0, arg1);
      case TypeKind.ISIZE:
      case TypeKind.USIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.EqI64x2 : BinaryOp.EqI32x4, arg0, arg1);
      case TypeKind.F32: return module.binary(BinaryOp.EqF32x4, arg0, arg1);
      case TypeKind.F64: return module.binary(BinaryOp.EqF64x2, arg0, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.eq", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_eq, builtin_v128_eq);

// v128.ne<T!>(a: v128, b: v128) -> v128
function builtin_v128_ne(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.U8: return module.binary(BinaryOp.NeI8x16, arg0, arg1);
      case TypeKind.I16:
      case TypeKind.U16: return module.binary(BinaryOp.NeI16x8, arg0, arg1);
      case TypeKind.I32:
      case TypeKind.U32: return module.binary(BinaryOp.NeI32x4, arg0, arg1);
      case TypeKind.I64:
      case TypeKind.U64: return module.binary(BinaryOp.NeI64x2, arg0, arg1);
      case TypeKind.ISIZE:
      case TypeKind.USIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.NeI64x2 : BinaryOp.NeI32x4, arg0, arg1);
      case TypeKind.F32: return module.binary(BinaryOp.NeF32x4, arg0, arg1);
      case TypeKind.F64: return module.binary(BinaryOp.NeF64x2, arg0, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.ne", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_ne, builtin_v128_ne);

// v128.lt<T!>(a: v128, b: v128) -> v128
function builtin_v128_lt(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8: return module.binary(BinaryOp.LtI8x16, arg0, arg1);
      case TypeKind.U8: return module.binary(BinaryOp.LtU8x16, arg0, arg1);
      case TypeKind.I16: return module.binary(BinaryOp.LtI16x8, arg0, arg1);
      case TypeKind.U16: return module.binary(BinaryOp.LtU16x8, arg0, arg1);
      case TypeKind.I32: return module.binary(BinaryOp.LtI32x4, arg0, arg1);
      case TypeKind.U32: return module.binary(BinaryOp.LtU32x4, arg0, arg1);
      case TypeKind.I64: return module.binary(BinaryOp.LtI64x2, arg0, arg1);
      // no LtU64x2
      case TypeKind.ISIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.LtI64x2 : BinaryOp.LtI32x4, arg0, arg1);
      case TypeKind.USIZE: {
        if (compiler.options.isWasm64) break;
        return module.binary(BinaryOp.LtU32x4, arg0, arg1);
      }
      case TypeKind.F32: return module.binary(BinaryOp.LtF32x4, arg0, arg1);
      case TypeKind.F64: return module.binary(BinaryOp.LtF64x2, arg0, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.lt", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_lt, builtin_v128_lt);

// v128.le<T!>(a: v128, b: v128) -> v128
function builtin_v128_le(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8: return module.binary(BinaryOp.LeI8x16, arg0, arg1);
      case TypeKind.U8: return module.binary(BinaryOp.LeU8x16, arg0, arg1);
      case TypeKind.I16: return module.binary(BinaryOp.LeI16x8, arg0, arg1);
      case TypeKind.U16: return module.binary(BinaryOp.LeU16x8, arg0, arg1);
      case TypeKind.I32: return module.binary(BinaryOp.LeI32x4, arg0, arg1);
      case TypeKind.U32: return module.binary(BinaryOp.LeU32x4, arg0, arg1);
      case TypeKind.I64: return module.binary(BinaryOp.LeI64x2, arg0, arg1);
      // no LeU64x2
      case TypeKind.ISIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.LeI64x2 : BinaryOp.LeI32x4, arg0, arg1);
      case TypeKind.USIZE: {
        if (compiler.options.isWasm64) break;
        return module.binary(BinaryOp.LeU32x4, arg0, arg1);
      }
      case TypeKind.F32: return module.binary(BinaryOp.LeF32x4, arg0, arg1);
      case TypeKind.F64: return module.binary(BinaryOp.LeF64x2, arg0, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.le", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_le, builtin_v128_le);

// v128.gt<T!>(a: v128, b: v128) -> v128
function builtin_v128_gt(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8: return module.binary(BinaryOp.GtI8x16, arg0, arg1);
      case TypeKind.U8: return module.binary(BinaryOp.GtU8x16, arg0, arg1);
      case TypeKind.I16: return module.binary(BinaryOp.GtI16x8, arg0, arg1);
      case TypeKind.U16: return module.binary(BinaryOp.GtU16x8, arg0, arg1);
      case TypeKind.I32: return module.binary(BinaryOp.GtI32x4, arg0, arg1);
      case TypeKind.U32: return module.binary(BinaryOp.GtU32x4, arg0, arg1);
      case TypeKind.I64: return module.binary(BinaryOp.GtI64x2, arg0, arg1);
      // no GtU64x2
      case TypeKind.ISIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.GtI64x2 : BinaryOp.GtI32x4, arg0, arg1);
      case TypeKind.USIZE: {
        if (compiler.options.isWasm64) break;
        return module.binary(BinaryOp.GtU32x4, arg0, arg1);
      }
      case TypeKind.F32: return module.binary(BinaryOp.GtF32x4, arg0, arg1);
      case TypeKind.F64: return module.binary(BinaryOp.GtF64x2, arg0, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.gt", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_gt, builtin_v128_gt);

// v128.ge<T!>(a: v128, b: v128) -> v128
function builtin_v128_ge(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8: return module.binary(BinaryOp.GeI8x16, arg0, arg1);
      case TypeKind.U8: return module.binary(BinaryOp.GeU8x16, arg0, arg1);
      case TypeKind.I16: return module.binary(BinaryOp.GeI16x8, arg0, arg1);
      case TypeKind.U16: return module.binary(BinaryOp.GeU16x8, arg0, arg1);
      case TypeKind.I32: return module.binary(BinaryOp.GeI32x4, arg0, arg1);
      case TypeKind.U32: return module.binary(BinaryOp.GeU32x4, arg0, arg1);
      case TypeKind.I64: return module.binary(BinaryOp.GeI64x2, arg0, arg1);
      // no GeU64x2
      case TypeKind.ISIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.GeI64x2 : BinaryOp.GeI32x4, arg0, arg1);
      case TypeKind.USIZE: {
        if (compiler.options.isWasm64) break;
        return module.binary(BinaryOp.GeU32x4, arg0, arg1);
      }
      case TypeKind.F32: return module.binary(BinaryOp.GeF32x4, arg0, arg1);
      case TypeKind.F64: return module.binary(BinaryOp.GeF64x2, arg0, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.ge", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_ge, builtin_v128_ge);

// v128.narrow<T!>(a: v128, b: v128) -> v128
function builtin_v128_narrow(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I16: return module.binary(BinaryOp.NarrowI16x8ToI8x16, arg0, arg1);
      case TypeKind.U16: return module.binary(BinaryOp.NarrowU16x8ToU8x16, arg0, arg1);
      case TypeKind.I32: return module.binary(BinaryOp.NarrowI32x4ToI16x8, arg0, arg1);
      case TypeKind.U32: return module.binary(BinaryOp.NarrowU32x4ToU16x8, arg0, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.narrow", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_narrow, builtin_v128_narrow);

// v128.neg<T!>(a: v128) -> v128
function builtin_v128_neg(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 1)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.U8: return module.unary(UnaryOp.NegI8x16, arg0);
      case TypeKind.I16:
      case TypeKind.U16: return module.unary(UnaryOp.NegI16x8, arg0);
      case TypeKind.I32:
      case TypeKind.U32: return module.unary(UnaryOp.NegI32x4, arg0);
      case TypeKind.I64:
      case TypeKind.U64: return module.unary(UnaryOp.NegI64x2, arg0);
      case TypeKind.ISIZE:
      case TypeKind.USIZE: {
        return module.unary(
          compiler.options.isWasm64
            ? UnaryOp.NegI64x2
            : UnaryOp.NegI32x4,
          arg0
        );
      }
      case TypeKind.F32: return module.unary(UnaryOp.NegF32x4, arg0);
      case TypeKind.F64: return module.unary(UnaryOp.NegF64x2, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.neg", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_neg, builtin_v128_neg);

// v128.abs<T!>(a: v128) -> v128
function builtin_v128_abs(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 1)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8: return module.unary(UnaryOp.AbsI8x16, arg0);
      case TypeKind.I16: return module.unary(UnaryOp.AbsI16x8, arg0);
      case TypeKind.I32: return module.unary(UnaryOp.AbsI32x4, arg0);
      case TypeKind.I64: return module.unary(UnaryOp.AbsI64x2, arg0);
      case TypeKind.ISIZE: return module.unary(compiler.options.isWasm64 ? UnaryOp.AbsI64x2 : UnaryOp.AbsI32x4, arg0);
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.U32:
      case TypeKind.U64:
      case TypeKind.USIZE: return arg0;
      case TypeKind.F32: return module.unary(UnaryOp.AbsF32x4, arg0);
      case TypeKind.F64: return module.unary(UnaryOp.AbsF64x2, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.abs", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_abs, builtin_v128_abs);

// v128.sqrt<T!>(a: v128) -> v128
function builtin_v128_sqrt(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 1)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.F32: return module.unary(UnaryOp.SqrtF32x4, arg0);
      case TypeKind.F64: return module.unary(UnaryOp.SqrtF64x2, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.sqrt", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_sqrt, builtin_v128_sqrt);

// v128.ceil<T!>(a: v128) -> v128
function builtin_v128_ceil(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 1)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.F32: return module.unary(UnaryOp.CeilF32x4, arg0);
      case TypeKind.F64: return module.unary(UnaryOp.CeilF64x2, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.ceil", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_ceil, builtin_v128_ceil);

// v128.floor<T!>(a: v128) -> v128
function builtin_v128_floor(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 1)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.F32: return module.unary(UnaryOp.FloorF32x4, arg0);
      case TypeKind.F64: return module.unary(UnaryOp.FloorF64x2, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.floor", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_floor, builtin_v128_floor);

// v128.trunc<T!>(a: v128) -> v128
function builtin_v128_trunc(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 1)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.F32: return module.unary(UnaryOp.TruncF32x4, arg0);
      case TypeKind.F64: return module.unary(UnaryOp.TruncF64x2, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.trunc", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_trunc, builtin_v128_trunc);

// v128.nearest<T!>(a: v128) -> v128
function builtin_v128_nearest(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 1)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.F32: return module.unary(UnaryOp.NearestF32x4, arg0);
      case TypeKind.F64: return module.unary(UnaryOp.NearestF64x2, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.nearest", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_nearest, builtin_v128_nearest);

// v128.convert<T!>(a: v128) -> v128
function builtin_v128_convert(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 1)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.ISIZE: {
        if (compiler.options.isWasm64) break;
        // fall-through
      }
      case TypeKind.I32: return module.unary(UnaryOp.ConvertI32x4ToF32x4, arg0);
      case TypeKind.USIZE: {
        if (compiler.options.isWasm64) break;
        // fall-through
      }
      case TypeKind.U32: return module.unary(UnaryOp.ConvertU32x4ToF32x4, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.convert", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_convert, builtin_v128_convert);

// v128.convert_low<T!>(a: v128) -> v128
function builtin_v128_convert_low(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 1)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.ISIZE: {
        if (compiler.options.isWasm64) break;
        // fall-through
      }
      case TypeKind.I32: return module.unary(UnaryOp.ConvertLowI32x4ToF64x2, arg0);
      case TypeKind.USIZE: {
        if (compiler.options.isWasm64) break;
        // fall-through
      }
      case TypeKind.U32: return module.unary(UnaryOp.ConvertLowU32x4ToF64x2, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.convert_low", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_convert_low, builtin_v128_convert_low);

// v128.trunc_sat<T!>(a: v128) -> v128
function builtin_v128_trunc_sat(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 1)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.ISIZE: {
        if (compiler.options.isWasm64) break;
        // fall-through
      }
      case TypeKind.I32: return module.unary(UnaryOp.TruncSatF32x4ToI32x4, arg0);
      case TypeKind.USIZE: {
        if (compiler.options.isWasm64) break;
        // fall-through
      }
      case TypeKind.U32: return module.unary(UnaryOp.TruncSatF32x4ToU32x4, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.trunc_sat", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_trunc_sat, builtin_v128_trunc_sat);

// v128.trunc_sat_zero<T!>(a: v128) -> v128
function builtin_v128_trunc_sat_zero(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 1)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.ISIZE: {
        if (compiler.options.isWasm64) break;
        // fall-through
      }
      case TypeKind.I32: return module.unary(UnaryOp.TruncSatF64x2ToI32x4Zero, arg0);
      case TypeKind.USIZE: {
        if (compiler.options.isWasm64) break;
        // fall-through
      }
      case TypeKind.U32: return module.unary(UnaryOp.TruncSatF64x2ToU32x4Zero, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.trunc_sat_zero", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_trunc_sat_zero, builtin_v128_trunc_sat_zero);

// v128.extend_low<T!>(a: v128) -> v128
function builtin_v128_extend_low(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 1)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8: return module.unary(UnaryOp.ExtendLowI8x16ToI16x8, arg0);
      case TypeKind.U8: return module.unary(UnaryOp.ExtendLowU8x16ToU16x8, arg0);
      case TypeKind.I16: return module.unary(UnaryOp.ExtendLowI16x8ToI32x4, arg0);
      case TypeKind.U16: return module.unary(UnaryOp.ExtendLowU16x8ToU32x4, arg0);
      case TypeKind.ISIZE: {
        if (compiler.options.isWasm64) break;
        // fall-through
      }
      case TypeKind.I32: return module.unary(UnaryOp.ExtendLowI32x4ToI64x2, arg0);
      case TypeKind.USIZE: {
        if (compiler.options.isWasm64) break;
        // fall-through
      }
      case TypeKind.U32: return module.unary(UnaryOp.ExtendLowU32x4ToU64x2, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.extend_low", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_extend_low, builtin_v128_extend_low);

// v128.extend_high<T!>(a: v128) -> v128
function builtin_v128_extend_high(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 1)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8: return module.unary(UnaryOp.ExtendHighI8x16ToI16x8, arg0);
      case TypeKind.U8: return module.unary(UnaryOp.ExtendHighU8x16ToU16x8, arg0);
      case TypeKind.I16: return module.unary(UnaryOp.ExtendHighI16x8ToI32x4, arg0);
      case TypeKind.U16: return module.unary(UnaryOp.ExtendHighU16x8ToU32x4, arg0);
      case TypeKind.ISIZE: {
        if (compiler.options.isWasm64) break;
        // fall-through
      }
      case TypeKind.I32: return module.unary(UnaryOp.ExtendHighI32x4ToI64x2, arg0);
      case TypeKind.USIZE: {
        if (compiler.options.isWasm64) break;
        // fall-through
      }
      case TypeKind.U32: return module.unary(UnaryOp.ExtendHighU32x4ToU64x2, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.extend_high", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_extend_high, builtin_v128_extend_high);

// v128.shl<T!>(a: v128, b: i32) -> v128
function builtin_v128_shl(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var type = ctx.typeArguments![0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.i32, Constraints.CONV_IMPLICIT);
  compiler.currentType = Type.v128;
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.U8: return module.simd_shift(SIMDShiftOp.ShlI8x16, arg0, arg1);
      case TypeKind.I16:
      case TypeKind.U16: return module.simd_shift(SIMDShiftOp.ShlI16x8, arg0, arg1);
      case TypeKind.I32:
      case TypeKind.U32: return module.simd_shift(SIMDShiftOp.ShlI32x4, arg0, arg1);
      case TypeKind.I64:
      case TypeKind.U64: return module.simd_shift(SIMDShiftOp.ShlI64x2, arg0, arg1);
      case TypeKind.ISIZE:
      case TypeKind.USIZE: {
        return module.simd_shift(
          compiler.options.isWasm64
            ? SIMDShiftOp.ShlI64x2
            : SIMDShiftOp.ShlI32x4,
          arg0, arg1
        );
      }
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.shl", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_shl, builtin_v128_shl);

// v128.shr<T!>(a: v128, b: i32) -> v128
function builtin_v128_shr(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var type = ctx.typeArguments![0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.i32, Constraints.CONV_IMPLICIT);
  compiler.currentType = Type.v128;
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8: return module.simd_shift(SIMDShiftOp.ShrI8x16, arg0, arg1);
      case TypeKind.U8: return module.simd_shift(SIMDShiftOp.ShrU8x16, arg0, arg1);
      case TypeKind.I16: return module.simd_shift(SIMDShiftOp.ShrI16x8, arg0, arg1);
      case TypeKind.U16: return module.simd_shift(SIMDShiftOp.ShrU16x8, arg0, arg1);
      case TypeKind.I32: return module.simd_shift(SIMDShiftOp.ShrI32x4, arg0, arg1);
      case TypeKind.U32: return module.simd_shift(SIMDShiftOp.ShrU32x4, arg0, arg1);
      case TypeKind.I64: return module.simd_shift(SIMDShiftOp.ShrI64x2, arg0, arg1);
      case TypeKind.U64: return module.simd_shift(SIMDShiftOp.ShrU64x2, arg0, arg1);
      case TypeKind.ISIZE: {
        return module.simd_shift(
          compiler.options.isWasm64
            ? SIMDShiftOp.ShrI64x2
            : SIMDShiftOp.ShrI32x4,
          arg0, arg1
        );
      }
      case TypeKind.USIZE: {
        return module.simd_shift(
          compiler.options.isWasm64
            ? SIMDShiftOp.ShrU64x2
            : SIMDShiftOp.ShrU32x4,
          arg0, arg1
        );
      }
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.shr", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_shr, builtin_v128_shr);

function builtin_v128_bitwise_binary(ctx: BuiltinContext, op: BinaryOp): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeAbsent(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  return module.binary(op, arg0, arg1);
}

// v128.and(a: v128, b: v128) -> v128
function builtin_v128_and(ctx: BuiltinContext): ExpressionRef {
  return builtin_v128_bitwise_binary(ctx, BinaryOp.AndV128);
}
builtins.set(BuiltinNames.v128_and, builtin_v128_and);

// v128.or(a: v128, b: v128) -> v128
function builtin_v128_or(ctx: BuiltinContext): ExpressionRef {
  return builtin_v128_bitwise_binary(ctx, BinaryOp.OrV128);
}
builtins.set(BuiltinNames.v128_or, builtin_v128_or);

// v128.xor(a: v128, b: v128) -> v128
function builtin_v128_xor(ctx: BuiltinContext): ExpressionRef {
  return builtin_v128_bitwise_binary(ctx, BinaryOp.XorV128);
}
builtins.set(BuiltinNames.v128_xor, builtin_v128_xor);

// v128.andnot(a: v128, b: v128) -> v128
function builtin_v128_andnot(ctx: BuiltinContext): ExpressionRef {
  return builtin_v128_bitwise_binary(ctx, BinaryOp.AndnotV128);
}
builtins.set(BuiltinNames.v128_andnot, builtin_v128_andnot);

function builtin_v128_bitwise_unary(ctx: BuiltinContext, op: UnaryOp): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeAbsent(ctx) |
    checkArgsRequired(ctx, 1)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  return module.unary(op, arg0);
}

// v128.not(a: v128) -> v128
function builtin_v128_not(ctx: BuiltinContext): ExpressionRef {
  return builtin_v128_bitwise_unary(ctx, UnaryOp.NotV128);
}
builtins.set(BuiltinNames.v128_not, builtin_v128_not);

function builtin_v128_bitwise_ternary(ctx: BuiltinContext, op: SIMDTernaryOp): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeAbsent(ctx) |
    checkArgsRequired(ctx, 3)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  var arg2 = compiler.compileExpression(operands[2], Type.v128, Constraints.CONV_IMPLICIT);
  return module.simd_ternary(op, arg0, arg1, arg2);
}

// v128.bitselect(v1: v128, v2: v128, c: v128) -> v128
function builtin_v128_bitselect(ctx: BuiltinContext): ExpressionRef {
  return builtin_v128_bitwise_ternary(ctx, SIMDTernaryOp.Bitselect);
}
builtins.set(BuiltinNames.v128_bitselect, builtin_v128_bitselect);

// v128.any_true(a: v128) -> bool
function builtin_v128_any_true(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeAbsent(ctx) |
    checkArgsRequired(ctx, 1)
  ) {
    compiler.currentType = Type.bool;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  compiler.currentType = Type.bool;
  return module.unary(UnaryOp.AnyTrueV128, arg0);
}
builtins.set(BuiltinNames.v128_any_true, builtin_v128_any_true);

// v128.all_true<T!>(a: v128) -> bool
function builtin_v128_all_true(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 1)
  ) {
    compiler.currentType = Type.bool;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var type = ctx.typeArguments![0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  compiler.currentType = Type.bool;
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.U8: return module.unary(UnaryOp.AllTrueI8x16, arg0);
      case TypeKind.I16:
      case TypeKind.U16: return module.unary(UnaryOp.AllTrueI16x8, arg0);
      case TypeKind.I32:
      case TypeKind.U32: return module.unary(UnaryOp.AllTrueI32x4, arg0);
      case TypeKind.I64:
      case TypeKind.U64: return module.unary(UnaryOp.AllTrueI64x2, arg0);
      case TypeKind.ISIZE:
      case TypeKind.USIZE: {
        return module.unary(compiler.options.isWasm64 ? UnaryOp.AllTrueI64x2 : UnaryOp.AllTrueI32x4, arg0);
      }
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.all_true", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_all_true, builtin_v128_all_true);

// v128.bitmask<T!>(a: v128) -> i32
function builtin_v128_bitmask(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 1)
  ) {
    compiler.currentType = Type.i32;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var type = ctx.typeArguments![0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  compiler.currentType = Type.i32;
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.U8: return module.unary(UnaryOp.BitmaskI8x16, arg0);
      case TypeKind.I16:
      case TypeKind.U16: return module.unary(UnaryOp.BitmaskI16x8, arg0);
      case TypeKind.I32:
      case TypeKind.U32: return module.unary(UnaryOp.BitmaskI32x4, arg0);
      case TypeKind.I64:
      case TypeKind.U64: return module.unary(UnaryOp.BitmaskI64x2, arg0);
      case TypeKind.ISIZE:
      case TypeKind.USIZE: return module.unary(compiler.options.isWasm64 ? UnaryOp.BitmaskI64x2 : UnaryOp.BitmaskI32x4, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.bitmask", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_bitmask, builtin_v128_bitmask);

// v128.popcnt<T!>(a: v128) -> v128
function builtin_v128_popcnt(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 1)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var type = ctx.typeArguments![0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  compiler.currentType = Type.v128;
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.U8: return module.unary(UnaryOp.PopcntI8x16, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.popcnt", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_popcnt, builtin_v128_popcnt);

// v128.extadd_pairwise<T!>(a: v128) -> v128
function builtin_v128_extadd_pairwise(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 1)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var type = ctx.typeArguments![0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  compiler.currentType = Type.v128;
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8: return module.unary(UnaryOp.ExtaddPairwiseI8x16ToI16x8, arg0);
      case TypeKind.U8: return module.unary(UnaryOp.ExtaddPairwiseU8x16ToU16x8, arg0);
      case TypeKind.I16: return module.unary(UnaryOp.ExtaddPairwiseI16x8ToI32x4, arg0);
      case TypeKind.U16: return module.unary(UnaryOp.ExtaddPairwiseU16x8ToU32x4, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.extadd_pairwise", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_extadd_pairwise, builtin_v128_extadd_pairwise);

// v128.demote_zero<T?>(a: v128) -> v128
function builtin_v128_demote_zero(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeOptional(ctx) |
    checkArgsRequired(ctx, 1)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var type = typeArguments ? typeArguments[0] : Type.f64;
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  compiler.currentType = Type.v128;
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.F64: return module.unary(UnaryOp.DemoteZeroF64x2ToF32x4, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.demote_zero", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_demote_zero, builtin_v128_demote_zero);

// v128.promote_low<T?>(a: v128) -> v128
function builtin_v128_promote_low(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeOptional(ctx) |
    checkArgsRequired(ctx, 1)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  var type = typeArguments ? typeArguments[0] : Type.f32;
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  compiler.currentType = Type.v128;
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.F32: return module.unary(UnaryOp.PromoteLowF32x4ToF64x2, arg0);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.promote_low", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_promote_low, builtin_v128_promote_low);

// v128.q15mulr_sat<T!>(a: v128, b: v128) -> v128
function builtin_v128_q15mulr_sat(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I16: return module.binary(BinaryOp.Q15mulrSatI16x8, arg0, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.q15mulr_sat", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_q15mulr_sat, builtin_v128_q15mulr_sat);

// v128.extmul_low<T!>(a: v128, b: v128) -> v128
function builtin_v128_extmul_low(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8: return module.binary(BinaryOp.ExtmulLowI16x8, arg0, arg1);
      case TypeKind.U8: return module.binary(BinaryOp.ExtmulLowU16x8, arg0, arg1);
      case TypeKind.I16: return module.binary(BinaryOp.ExtmulLowI32x4, arg0, arg1);
      case TypeKind.U16: return module.binary(BinaryOp.ExtmulLowU32x4, arg0, arg1);
      case TypeKind.I32: return module.binary(BinaryOp.ExtmulLowI64x2, arg0, arg1);
      case TypeKind.U32: return module.binary(BinaryOp.ExtmulLowU64x2, arg0, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.extmul_low", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_extmul_low, builtin_v128_extmul_low);

// v128.extmul_high<T!>(a: v128, b: v128) -> v128
function builtin_v128_extmul_high(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkFeatureEnabled(ctx, Feature.SIMD) |
    checkTypeRequired(ctx) |
    checkArgsRequired(ctx, 2)
  ) {
    compiler.currentType = Type.v128;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments!;
  var type = typeArguments[0];
  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);
  if (type.isValue) {
    switch (type.kind) {
      case TypeKind.I8: return module.binary(BinaryOp.ExtmulHighI16x8, arg0, arg1);
      case TypeKind.U8: return module.binary(BinaryOp.ExtmulHighU16x8, arg0, arg1);
      case TypeKind.I16: return module.binary(BinaryOp.ExtmulHighI32x4, arg0, arg1);
      case TypeKind.U16: return module.binary(BinaryOp.ExtmulHighU32x4, arg0, arg1);
      case TypeKind.I32: return module.binary(BinaryOp.ExtmulHighI64x2, arg0, arg1);
      case TypeKind.U32: return module.binary(BinaryOp.ExtmulHighU64x2, arg0, arg1);
    }
  }
  compiler.error(
    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
    ctx.reportNode.typeArgumentsRange, "v128.extmul_high", type.toString()
  );
  return module.unreachable();
}
builtins.set(BuiltinNames.v128_extmul_high, builtin_v128_extmul_high);

// === Internal runtime =======================================================================

// __visit_globals(cookie: u32) -> void
function builtin_visit_globals(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeAbsent(ctx) |
    checkArgsRequired(ctx, 1) // cookie
  ) {
    compiler.currentType = Type.void;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var arg0 = compiler.compileExpression(operands[0], Type.u32, Constraints.CONV_IMPLICIT);
  compiler.runtimeFeatures |= RuntimeFeatures.visitGlobals;
  compiler.currentType = Type.void;
  return module.call(BuiltinNames.visit_globals, [ arg0 ], TypeRef.None);
}
builtins.set(BuiltinNames.visit_globals, builtin_visit_globals);

// __visit_members(ref: usize, cookie: u32) -> void
function builtin_visit_members(ctx: BuiltinContext): ExpressionRef {
  var compiler = ctx.compiler;
  var module = compiler.module;
  if (
    checkTypeAbsent(ctx) |
    checkArgsRequired(ctx, 2) // ref, cookie
  ) {
    compiler.currentType = Type.void;
    return module.unreachable();
  }
  var operands = ctx.operands;
  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);
  var arg1 = compiler.compileExpression(operands[1], Type.u32, Constraints.CONV_IMPLICIT);
  compiler.runtimeFeatures |= RuntimeFeatures.visitMembers;
  compiler.currentType = Type.void;
  return module.call(BuiltinNames.visit_members, [ arg0, arg1 ], TypeRef.None);
}
builtins.set(BuiltinNames.visit_members, builtin_visit_members);

// === Inline assembler =======================================================================

// TODO: Operators can't be just deferred (don't have a corresponding generic built-in)
//   add, sub, mul, div_s, div_u, rem_s, rem_u
//   and, or, xor, shl, shr_u, shr_s
//   eq, eqz, ne, lt_s, lt_u, le_s, le_u, gt_s, gt_u, ge_s, ge_u

// i32.clz -> clz<i32>
function builtin_i32_clz(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i32;
  return builtin_clz(ctx);
}
builtins.set(BuiltinNames.i32_clz, builtin_i32_clz);

// i64.clz -> clz<i64>
function builtin_i64_clz(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.i64;
  return builtin_clz(ctx);
}
builtins.set(BuiltinNames.i64_clz, builtin_i64_clz);

// i32.ctz -> ctz<i32>
function builtin_i32_ctz(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i32;
  return builtin_ctz(ctx);
}
builtins.set(BuiltinNames.i32_ctz, builtin_i32_ctz);

// i64.ctz -> ctz<i64>
function builtin_i64_ctz(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.i64;
  return builtin_ctz(ctx);
}
builtins.set(BuiltinNames.i64_ctz, builtin_i64_ctz);

// i32.popcnt -> popcnt<i32>
function builtin_i32_popcnt(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i32;
  return builtin_popcnt(ctx);
}
builtins.set(BuiltinNames.i32_popcnt, builtin_i32_popcnt);

// i64.popcnt -> popcnt<i64>
function builtin_i64_popcnt(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.i64;
  return builtin_popcnt(ctx);
}
builtins.set(BuiltinNames.i64_popcnt, builtin_i64_popcnt);

// i32.rotl -> rotl<i32>
function builtin_i32_rotl(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i32;
  return builtin_rotl(ctx);
}
builtins.set(BuiltinNames.i32_rotl, builtin_i32_rotl);

// i64.rotl -> rotl<i64>
function builtin_i64_rotl(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.i64;
  return builtin_rotl(ctx);
}
builtins.set(BuiltinNames.i64_rotl, builtin_i64_rotl);

// i32.rotr -> rotr<i32>
function builtin_i32_rotr(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i32;
  return builtin_rotr(ctx);
}
builtins.set(BuiltinNames.i32_rotr, builtin_i32_rotr);

// i64.rotr -> rotr<i64>
function builtin_i64_rotr(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.i64;
  return builtin_rotr(ctx);
}
builtins.set(BuiltinNames.i64_rotr, builtin_i64_rotr);

// f32.abs -> abs<f32>
function builtin_f32_abs(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.f32;
  return builtin_abs(ctx);
}
builtins.set(BuiltinNames.f32_abs, builtin_f32_abs);

// f64.abs -> abs<f64>
function builtin_f64_abs(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.f64;
  return builtin_abs(ctx);
}
builtins.set(BuiltinNames.f64_abs, builtin_f64_abs);

// f32.max -> max<f32>
function builtin_f32_max(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.f32;
  return builtin_max(ctx);
}
builtins.set(BuiltinNames.f32_max, builtin_f32_max);

// f64.max -> max<f64>
function builtin_f64_max(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.f64;
  return builtin_max(ctx);
}
builtins.set(BuiltinNames.f64_max, builtin_f64_max);

// f32.min -> min<f32>
function builtin_f32_min(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.f32;
  return builtin_min(ctx);
}
builtins.set(BuiltinNames.f32_min, builtin_f32_min);

// f64.min -> min<f64>
function builtin_f64_min(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.f64;
  return builtin_min(ctx);
}
builtins.set(BuiltinNames.f64_min, builtin_f64_min);

// f32.ceil -> ceil<f32>
function builtin_f32_ceil(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.f32;
  return builtin_ceil(ctx);
}
builtins.set(BuiltinNames.f32_ceil, builtin_f32_ceil);

// f64.ceil -> ceil<f64>
function builtin_f64_ceil(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.f64;
  return builtin_ceil(ctx);
}
builtins.set(BuiltinNames.f64_ceil, builtin_f64_ceil);

// f32.floor -> floor<f32>
function builtin_f32_floor(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.f32;
  return builtin_floor(ctx);
}
builtins.set(BuiltinNames.f32_floor, builtin_f32_floor);

// f64.floor -> floor<f64>
function builtin_f64_floor(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.f64;
  return builtin_floor(ctx);
}
builtins.set(BuiltinNames.f64_floor, builtin_f64_floor);

// f32.copysign -> copysign<f32>
function builtin_f32_copysign(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.f32;
  return builtin_copysign(ctx);
}
builtins.set(BuiltinNames.f32_copysign, builtin_f32_copysign);

// f64.copysign -> copysign<f64>
function builtin_f64_copysign(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.f64;
  return builtin_copysign(ctx);
}
builtins.set(BuiltinNames.f64_copysign, builtin_f64_copysign);

// f32.nearest -> nearest<f32>
function builtin_f32_nearest(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.f32;
  return builtin_nearest(ctx);
}
builtins.set(BuiltinNames.f32_nearest, builtin_f32_nearest);

// f64.nearest -> nearest<f64>
function builtin_f64_nearest(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.f64;
  return builtin_nearest(ctx);
}
builtins.set(BuiltinNames.f64_nearest, builtin_f64_nearest);

// i32.reinterpret_f32 -> reinterpret<i32>
function builtin_i32_reinterpret_f32(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.f32;
  return builtin_reinterpret(ctx);
}
builtins.set(BuiltinNames.i32_reinterpret_f32, builtin_i32_reinterpret_f32);

// i64.reinterpret_f64 -> reinterpret<i64>
function builtin_i64_reinterpret_f64(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.f64;
  return builtin_reinterpret(ctx);
}
builtins.set(BuiltinNames.i64_reinterpret_f64, builtin_i64_reinterpret_f64);

// f32.reinterpret_i32 -> reinterpret<f32>
function builtin_f32_reinterpret_i32(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.i32;
  return builtin_reinterpret(ctx);
}
builtins.set(BuiltinNames.f32_reinterpret_i32, builtin_f32_reinterpret_i32);

// f64.reinterpret_i64 -> reinterpret<f64>
function builtin_f64_reinterpret_i64(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.i64;
  return builtin_reinterpret(ctx);
}
builtins.set(BuiltinNames.f64_reinterpret_i64, builtin_f64_reinterpret_i64);

// f32.sqrt -> sqrt<f32>
function builtin_f32_sqrt(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.f32;
  return builtin_sqrt(ctx);
}
builtins.set(BuiltinNames.f32_sqrt, builtin_f32_sqrt);

// f64.sqrt -> sqrt<f64>
function builtin_f64_sqrt(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.f64;
  return builtin_sqrt(ctx);
}
builtins.set(BuiltinNames.f64_sqrt, builtin_f64_sqrt);

// f32.trunc -> trunc<f32>
function builtin_f32_trunc(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.f32;
  return builtin_trunc(ctx);
}
builtins.set(BuiltinNames.f32_trunc, builtin_f32_trunc);

// f64.trunc -> trunc<f64>
function builtin_f64_trunc(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.f64;
  return builtin_trunc(ctx);
}
builtins.set(BuiltinNames.f64_trunc, builtin_f64_trunc);

// i32.add -> add<i32>
function builtin_i32_add(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i32;
  return builtin_add(ctx);
}
builtins.set(BuiltinNames.i32_add, builtin_i32_add);

// i64.add -> add<i64>
function builtin_i64_add(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.i64;
  return builtin_add(ctx);
}
builtins.set(BuiltinNames.i64_add, builtin_i64_add);

// f32.add -> add<f32>
function builtin_f32_add(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.f32;
  return builtin_add(ctx);
}
builtins.set(BuiltinNames.f32_add, builtin_f32_add);

// f64.add -> add<f64>
function builtin_f64_add(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.f64;
  return builtin_add(ctx);
}
builtins.set(BuiltinNames.f64_add, builtin_f64_add);

// i32.sub -> sub<i32>
function builtin_i32_sub(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i32;
  return builtin_sub(ctx);
}
builtins.set(BuiltinNames.i32_sub, builtin_i32_sub);

// i64.sub -> sub<i64>
function builtin_i64_sub(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.i64;
  return builtin_sub(ctx);
}
builtins.set(BuiltinNames.i64_sub, builtin_i64_sub);

// f32.sub -> sub<f32>
function builtin_f32_sub(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.f32;
  return builtin_sub(ctx);
}
builtins.set(BuiltinNames.f32_sub, builtin_f32_sub);

// f64.sub -> sub<f64>
function builtin_f64_sub(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.f64;
  return builtin_sub(ctx);
}
builtins.set(BuiltinNames.f64_sub, builtin_f64_sub);

// i32.mul -> mul<i32>
function builtin_i32_mul(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i32;
  return builtin_mul(ctx);
}
builtins.set(BuiltinNames.i32_mul, builtin_i32_mul);

// i64.mul -> mul<i64>
function builtin_i64_mul(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.i64;
  return builtin_mul(ctx);
}
builtins.set(BuiltinNames.i64_mul, builtin_i64_mul);

// f32.mul -> mul<f32>
function builtin_f32_mul(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.f32;
  return builtin_mul(ctx);
}
builtins.set(BuiltinNames.f32_mul, builtin_f32_mul);

// f64.mul -> mul<f64>
function builtin_f64_mul(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.f64;
  return builtin_mul(ctx);
}
builtins.set(BuiltinNames.f64_mul, builtin_f64_mul);

// i32.div_s -> div<i32>
function builtin_i32_div_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i32;
  return builtin_div(ctx);
}
builtins.set(BuiltinNames.i32_div_s, builtin_i32_div_s);

// i32.div_u -> div<u32>
function builtin_i32_div_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.u32;
  return builtin_div(ctx);
}
builtins.set(BuiltinNames.i32_div_u, builtin_i32_div_u);

// i64.div_s -> div_s<i64>
function builtin_i64_div_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.i64;
  return builtin_div(ctx);
}
builtins.set(BuiltinNames.i64_div_s, builtin_i64_div_s);

// i64.div_u -> div_u<u64>
function builtin_i64_div_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u64 ];
  ctx.contextualType = Type.u64;
  return builtin_div(ctx);
}
builtins.set(BuiltinNames.i64_div_u, builtin_i64_div_u);

// f32.div -> div<f32>
function builtin_f32_div(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.f32;
  return builtin_div(ctx);
}
builtins.set(BuiltinNames.f32_div, builtin_f32_div);

// f64.div -> div<f64>
function builtin_f64_div(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.f64;
  return builtin_div(ctx);
}
builtins.set(BuiltinNames.f64_div, builtin_f64_div);

// i32.load8_s -> <i32>load<i8>
function builtin_i32_load8_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.i32;
  return builtin_load(ctx);
}
builtins.set(BuiltinNames.i32_load8_s, builtin_i32_load8_s);

// i32.load8_u -> <i32>load<u8>
function builtin_i32_load8_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.i32;
  return builtin_load(ctx);
}
builtins.set(BuiltinNames.i32_load8_u, builtin_i32_load8_u);

// i32.load16_s -> <i32>load<i16>
function builtin_i32_load16_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.i32;
  return builtin_load(ctx);
}
builtins.set(BuiltinNames.i32_load16_s, builtin_i32_load16_s);

// i32.load16_u -> <i32>load<u16>
function builtin_i32_load16_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.i32;
  return builtin_load(ctx);
}
builtins.set(BuiltinNames.i32_load16_u, builtin_i32_load16_u);

// i32.load -> <i32>load<i32>
function builtin_i32_load(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i32;
  return builtin_load(ctx);
}
builtins.set(BuiltinNames.i32_load, builtin_i32_load);

// i64.load8_s -> <i64>load<i8>
function builtin_i64_load8_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.i64;
  return builtin_load(ctx);
}
builtins.set(BuiltinNames.i64_load8_s, builtin_i64_load8_s);

// i64.load8_u -> <i64>load<u8>
function builtin_i64_load8_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.i64;
  return builtin_load(ctx);
}
builtins.set(BuiltinNames.i64_load8_u, builtin_i64_load8_u);

// i64.load16_s -> <i64>load<i16>
function builtin_i64_load16_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.i64;
  return builtin_load(ctx);
}
builtins.set(BuiltinNames.i64_load16_s, builtin_i64_load16_s);

// i64.load16_u -> <i64>load<u16>
function builtin_i64_load16_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.i64;
  return builtin_load(ctx);
}
builtins.set(BuiltinNames.i64_load16_u, builtin_i64_load16_u);

// i64.load32_s -> <i64>load<i32>
function builtin_i64_load32_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i64;
  return builtin_load(ctx);
}
builtins.set(BuiltinNames.i64_load32_s, builtin_i64_load32_s);

// i64.load32_u -> <i64>load<u32>
function builtin_i64_load32_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.i64;
  return builtin_load(ctx);
}
builtins.set(BuiltinNames.i64_load32_u, builtin_i64_load32_u);

// i64.load -> <i64>load<i64>
function builtin_i64_load(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.i64;
  return builtin_load(ctx);
}
builtins.set(BuiltinNames.i64_load, builtin_i64_load);

// f32.load -> <f32>load<f32>
function builtin_f32_load(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.f32;
  return builtin_load(ctx);
}
builtins.set(BuiltinNames.f32_load, builtin_f32_load);

// f64.load -> <f64>load<f64>
function builtin_f64_load(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.f64;
  return builtin_load(ctx);
}
builtins.set(BuiltinNames.f64_load, builtin_f64_load);

// i32.store8 -> store<i8 from i32>
function builtin_i32_store8(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_store(ctx);
}
builtins.set(BuiltinNames.i32_store8, builtin_i32_store8);

// i32.store16 -> store<i16 from i32>
function builtin_i32_store16(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_store(ctx);
}
builtins.set(BuiltinNames.i32_store16, builtin_i32_store16);

// i32.store -> store<i32 from i32>
function builtin_i32_store(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_store(ctx);
}
builtins.set(BuiltinNames.i32_store, builtin_i32_store);

// i64.store8 -> store<i8 from i64>
function builtin_i64_store8(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_store(ctx);
}
builtins.set(BuiltinNames.i64_store8, builtin_i64_store8);

// i64.store16 -> store<i16 from i64>
function builtin_i64_store16(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_store(ctx);
}
builtins.set(BuiltinNames.i64_store16, builtin_i64_store16);

// i64.store32 -> store<i32 from i64>
function builtin_i64_store32(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_store(ctx);
}
builtins.set(BuiltinNames.i64_store32, builtin_i64_store32);

// i64.store -> store<i64 from i64>
function builtin_i64_store(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_store(ctx);
}
builtins.set(BuiltinNames.i64_store, builtin_i64_store);

// f32.store -> store<f32 from f64>
function builtin_f32_store(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.f32;
  ctx.contextIsExact = true;
  return builtin_store(ctx);
}
builtins.set(BuiltinNames.f32_store, builtin_f32_store);

// f64.store -> store<f64 from f64>
function builtin_f64_store(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.f64;
  ctx.contextIsExact = true;
  return builtin_store(ctx);
}
builtins.set(BuiltinNames.f64_store, builtin_f64_store);

// i32.atomic.load8_u -> <i32>atomic.load<u8>
function builtin_i32_atomic_load8_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.i32;
  return builtin_atomic_load(ctx);
}
builtins.set(BuiltinNames.i32_atomic_load8_u, builtin_i32_atomic_load8_u);

// i32.atomic.load16_u -> <i32>atomic.load<u16>
function builtin_i32_atomic_load16_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.i32;
  return builtin_atomic_load(ctx);
}
builtins.set(BuiltinNames.i32_atomic_load16_u, builtin_i32_atomic_load16_u);

// i32.atomic.load -> <i32>atomic.load<i32>
function builtin_i32_atomic_load(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i32;
  return builtin_atomic_load(ctx);
}
builtins.set(BuiltinNames.i32_atomic_load, builtin_i32_atomic_load);

// i64.atomic.load8_u -> <i64>atomic.load<u8>
function builtin_i64_atomic_load8_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.i64;
  return builtin_atomic_load(ctx);
}
builtins.set(BuiltinNames.i64_atomic_load8_u, builtin_i64_atomic_load8_u);

// i64.atomic.load16_u -> <i64>atomic.load<u16>
function builtin_i64_atomic_load16_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.i64;
  return builtin_atomic_load(ctx);
}
builtins.set(BuiltinNames.i64_atomic_load16_u, builtin_i64_atomic_load16_u);

// i64.atomic.load32_u -> <i64>atomic.load<u32>
function builtin_i64_atomic_load32_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.i64;
  return builtin_atomic_load(ctx);
}
builtins.set(BuiltinNames.i64_atomic_load32_u, builtin_i64_atomic_load32_u);

// i64.atomic.load -> <i64>atomic.load<i64>
function builtin_i64_atomic_load(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.i64;
  return builtin_atomic_load(ctx);
}
builtins.set(BuiltinNames.i64_atomic_load, builtin_i64_atomic_load);

// i32.atomic.store8 -> atomic.store<i8 from i32>
function builtin_i32_atomic_store8(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_atomic_store(ctx);
}
builtins.set(BuiltinNames.i32_atomic_store8, builtin_i32_atomic_store8);

// i32.atomic.store16 -> atomic.store<i16 from i32>
function builtin_i32_atomic_store16(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_atomic_store(ctx);
}
builtins.set(BuiltinNames.i32_atomic_store16, builtin_i32_atomic_store16);

// i32.atomic.store -> atomic.store<i32 from i32>
function builtin_i32_atomic_store(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_atomic_store(ctx);
}
builtins.set(BuiltinNames.i32_atomic_store, builtin_i32_atomic_store);

// i64.atomic.store8 -> atomic.store<i8 from i64>
function builtin_i64_atomic_store8(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_store(ctx);
}
builtins.set(BuiltinNames.i64_atomic_store8, builtin_i64_atomic_store8);

// i64.atomic.store16 -> atomic.store<i16 from i64>
function builtin_i64_atomic_store16(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_store(ctx);
}
builtins.set(BuiltinNames.i64_atomic_store16, builtin_i64_atomic_store16);

// i64.atomic.store32 -> atomic.store<i32 from i64>
function builtin_i64_atomic_store32(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_store(ctx);
}
builtins.set(BuiltinNames.i64_atomic_store32, builtin_i64_atomic_store32);

// i64.atomic.store -> atomic.store<i64 from i64>
function builtin_i64_atomic_store(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_store(ctx);
}
builtins.set(BuiltinNames.i64_atomic_store, builtin_i64_atomic_store);

// i32.atomic.rmw8.add_u -> <i32>atomic.add<u8 from i32>
function builtin_i32_atomic_rmw8_add_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_atomic_add(ctx);
}
builtins.set(BuiltinNames.i32_atomic_rmw8_add_u, builtin_i32_atomic_rmw8_add_u);

// i32.atomic.rmw16.add_u -> <i32>atomic.add<u16 from i32>
function builtin_i32_atomic_rmw16_add_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_atomic_add(ctx);
}
builtins.set(BuiltinNames.i32_atomic_rmw16_add_u, builtin_i32_atomic_rmw16_add_u);

// i32.atomic.rmw.add -> <i32>atomic.add<i32 from i32>
function builtin_i32_atomic_rmw_add(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_atomic_add(ctx);
}
builtins.set(BuiltinNames.i32_atomic_rmw_add, builtin_i32_atomic_rmw_add);

// i64.atomic.rmw8.add_u -> <i64>atomic.add<u8 from i64>
function builtin_i64_atomic_rmw8_add_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_add(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw8_add_u, builtin_i64_atomic_rmw8_add_u);

// i64.atomic.rmw16.add_u -> <i64>atomic.add<u16 from i64>
function builtin_i64_atomic_rmw16_add_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_add(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw16_add_u, builtin_i64_atomic_rmw16_add_u);

// i64.atomic.rmw32.add_u -> <i64>atomic.add<u32 from i64>
function builtin_i64_atomic_rmw32_add_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_add(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw32_add_u, builtin_i64_atomic_rmw32_add_u);

// i64.atomic.rmw.add -> <i64>atomic.add<i64 from i64>
function builtin_i64_atomic_rmw_add(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_add(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw_add, builtin_i64_atomic_rmw_add);

// i32.atomic.rmw8.sub_u -> <i32>atomic.sub<u8 from i32>
function builtin_i32_atomic_rmw8_sub_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_atomic_sub(ctx);
}
builtins.set(BuiltinNames.i32_atomic_rmw8_sub_u, builtin_i32_atomic_rmw8_sub_u);

// i32.atomic.rmw16.sub_u -> <i32>atomic.sub<u16 from i32>
function builtin_i32_atomic_rmw16_sub_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_atomic_sub(ctx);
}
builtins.set(BuiltinNames.i32_atomic_rmw16_sub_u, builtin_i32_atomic_rmw16_sub_u);

// i32.atomic.rmw.sub -> <i32>atomic.sub<i32 from i32>
function builtin_i32_atomic_rmw_sub(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_atomic_sub(ctx);
}
builtins.set(BuiltinNames.i32_atomic_rmw_sub, builtin_i32_atomic_rmw_sub);

// i64.atomic.rmw8.sub_u -> <i64>atomic.sub<u8 from i64>
function builtin_i64_atomic_rmw8_sub_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_sub(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw8_sub_u, builtin_i64_atomic_rmw8_sub_u);

// i64.atomic.rmw16.sub_u -> <i64>atomic.sub<u16 from i64>
function builtin_i64_atomic_rmw16_sub_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_sub(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw16_sub_u, builtin_i64_atomic_rmw16_sub_u);

// i64.atomic.rmw32.sub_u -> <i64>atomic.sub<u32 from i64>
function builtin_i64_atomic_rmw32_sub_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_sub(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw32_sub_u, builtin_i64_atomic_rmw32_sub_u);

// i64.atomic.rmw.sub -> <i64>atomic.sub<i64 from i64>
function builtin_i64_atomic_rmw_sub(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_sub(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw_sub, builtin_i64_atomic_rmw_sub);

// i32.atomic.rmw8.and_u -> <i32>atomic.and<u8 from i32>
function builtin_i32_atomic_rmw8_and_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_atomic_and(ctx);
}
builtins.set(BuiltinNames.i32_atomic_rmw8_and_u, builtin_i32_atomic_rmw8_and_u);

// i32.atomic.rmw16.and_u -> <i32>atomic.and<u16 from i32>
function builtin_i32_atomic_rmw16_and_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_atomic_and(ctx);
}
builtins.set(BuiltinNames.i32_atomic_rmw16_and_u, builtin_i32_atomic_rmw16_and_u);

// i32.atomic.rmw.and -> <i32>atomic.and<i32 from i32>
function builtin_i32_atomic_rmw_and(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_atomic_and(ctx);
}
builtins.set(BuiltinNames.i32_atomic_rmw_and, builtin_i32_atomic_rmw_and);

// i64.atomic.rmw8.and_u -> <i64>atomic.and<u8 from i64>
function builtin_i64_atomic_rmw8_and_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_and(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw8_and_u, builtin_i64_atomic_rmw8_and_u);

// i64.atomic.rmw16.and_u -> <i64>atomic.and<u16 from i64>
function builtin_i64_atomic_rmw16_and_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_and(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw16_and_u, builtin_i64_atomic_rmw16_and_u);

// i64.atomic.rmw32.and_u -> <i64>atomic.and<u32 from i64>
function builtin_i64_atomic_rmw32_and_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_and(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw32_and_u, builtin_i64_atomic_rmw32_and_u);

// i64.atomic.rmw.and -> <i64>atomic.and<i64 from i64>
function builtin_i64_atomic_rmw_and(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_and(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw_and, builtin_i64_atomic_rmw_and);

// i32.atomic.rmw8.or_u -> <i32>atomic.or<u8 from i32>
function builtin_i32_atomic_rmw8_or_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_atomic_or(ctx);
}
builtins.set(BuiltinNames.i32_atomic_rmw8_or_u, builtin_i32_atomic_rmw8_or_u);

// i32.atomic.rmw16.or_u -> <i32atomic.or<u16 from i32>
function builtin_i32_atomic_rmw16_or_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_atomic_or(ctx);
}
builtins.set(BuiltinNames.i32_atomic_rmw16_or_u, builtin_i32_atomic_rmw16_or_u);

// i32.atomic.rmw.or -> <i32>atomic.or<i32 from i32>
function builtin_i32_atomic_rmw_or(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_atomic_or(ctx);
}
builtins.set(BuiltinNames.i32_atomic_rmw_or, builtin_i32_atomic_rmw_or);

// i64.atomic.rmw8.or_u -> <i64>atomic.or<u8 from i64>
function builtin_i64_atomic_rmw8_or_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_or(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw8_or_u, builtin_i64_atomic_rmw8_or_u);

// i64.atomic.rmw16.or_u -> <i64>atomic.or<u16 from i64>
function builtin_i64_atomic_rmw16_or_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_or(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw16_or_u, builtin_i64_atomic_rmw16_or_u);

// i64.atomic.rmw32.or_u -> <i64>atomic.or<u32 from i64>
function builtin_i64_atomic_rmw32_or_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_or(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw32_or_u, builtin_i64_atomic_rmw32_or_u);

// i64.atomic.rmw.or -> <i64>atomic.or<i64 from i64>
function builtin_i64_atomic_rmw_or(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_or(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw_or, builtin_i64_atomic_rmw_or);

// i32.atomic.rmw8.xor_u -> <i32>atomic.xor<u8 from i32>
function builtin_i32_atomic_rmw8_xor_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_atomic_xor(ctx);
}
builtins.set(BuiltinNames.i32_atomic_rmw8_xor_u, builtin_i32_atomic_rmw8_xor_u);

// i32.atomic.rmw16.xor_u -> <i32>atomic.xor<u16 from i32>
function builtin_i32_atomic_rmw16_xor_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_atomic_xor(ctx);
}
builtins.set(BuiltinNames.i32_atomic_rmw16_xor_u, builtin_i32_atomic_rmw16_xor_u);

// i32.atomic.rmw.xor -> <i32>atomic.xor<i32 from i32>
function builtin_i32_atomic_rmw_xor(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_atomic_xor(ctx);
}
builtins.set(BuiltinNames.i32_atomic_rmw_xor, builtin_i32_atomic_rmw_xor);

// i64.atomic.rmw8.xor_u -> <i64>atomic.xor<u8 from i64>
function builtin_i64_atomic_rmw8_xor_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_xor(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw8_xor_u, builtin_i64_atomic_rmw8_xor_u);

// i64.atomic.rmw16.xor_u -> <i64>atomic.xor<u16 from i64>
function builtin_i64_atomic_rmw16_xor_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_xor(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw16_xor_u, builtin_i64_atomic_rmw16_xor_u);

// i64.atomic.rmw32.xor_u -> <i64>atomic.xor<u32 from i64>
function builtin_i64_atomic_rmw32_xor_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_xor(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw32_xor_u, builtin_i64_atomic_rmw32_xor_u);

// i64.atomic.rmw.xor -> <i64>atomic.xor<i64 from i64>
function builtin_i64_atomic_rmw_xor(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_xor(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw_xor, builtin_i64_atomic_rmw_xor);

// i32.atomic.rmw8.xchg_u -> <i32>atomic.xchg<u8 from i32>
function builtin_i32_atomic_rmw8_xchg_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_atomic_xchg(ctx);
}
builtins.set(BuiltinNames.i32_atomic_rmw8_xchg_u, builtin_i32_atomic_rmw8_xchg_u);

// i32.atomic.rmw16.xchg_u -> <i32>atomic.xchg<u16 from i32>
function builtin_i32_atomic_rmw16_xchg_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_atomic_xchg(ctx);
}
builtins.set(BuiltinNames.i32_atomic_rmw16_xchg_u, builtin_i32_atomic_rmw16_xchg_u);

// i32.atomic.rmw.xchg -> <i32>atomic.xchg<i32 from i32>
function builtin_i32_atomic_rmw_xchg(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_atomic_xchg(ctx);
}
builtins.set(BuiltinNames.i32_atomic_rmw_xchg, builtin_i32_atomic_rmw_xchg);

// i64.atomic.rmw8.xchg_u -> <i64>atomic.xchg<u8 from i64>
function builtin_i64_atomic_rmw8_xchg_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_xchg(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw8_xchg_u, builtin_i64_atomic_rmw8_xchg_u);

// i64.atomic.rmw16.xchg_u -> <i64>atomic.xchg<u16 from i64>
function builtin_i64_atomic_rmw16_xchg_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_xchg(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw16_xchg_u, builtin_i64_atomic_rmw16_xchg_u);

// i64.atomic.rmw32.xchg_u -> <i64>atomic.xchg<u32 from i64>
function builtin_i64_atomic_rmw32_xchg_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_xchg(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw32_xchg_u, builtin_i64_atomic_rmw32_xchg_u);

// i64.atomic.rmw.xchg -> <i64>atomic.xchg<i64 from i64>
function builtin_i64_atomic_rmw_xchg(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_xchg(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw_xchg, builtin_i64_atomic_rmw_xchg);

// i32.atomic.rmw8.cmpxchg_u -> <i32>atomic.cmpxchg<u8 from i32>
function builtin_i32_atomic_rmw8_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_atomic_cmpxchg(ctx);
}
builtins.set(BuiltinNames.i32_atomic_rmw8_cmpxchg_u, builtin_i32_atomic_rmw8_cmpxchg_u);

// i32.atomic.rmw16.cmpxchg_u -> <i32>atomic.cmpxchg<u16 from i32>
function builtin_i32_atomic_rmw16_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_atomic_cmpxchg(ctx);
}
builtins.set(BuiltinNames.i32_atomic_rmw16_cmpxchg_u, builtin_i32_atomic_rmw16_cmpxchg_u);

// i32.atomic.rmw.cmpxchg -> <i32>atomic.cmpxchg<i32 from i32>
function builtin_i32_atomic_rmw_cmpxchg(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i32;
  ctx.contextIsExact = true;
  return builtin_atomic_cmpxchg(ctx);
}
builtins.set(BuiltinNames.i32_atomic_rmw_cmpxchg, builtin_i32_atomic_rmw_cmpxchg);

// i64.atomic.rmw8.cmpxchg_u -> <i64>atomic.cmpxchg<u8 from i64>
function builtin_i64_atomic_rmw8_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_cmpxchg(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw8_cmpxchg_u, builtin_i64_atomic_rmw8_cmpxchg_u);

// i64.atomic.rmw16.cmpxchg_u -> <i64>atomic.cmpxchg<u16 from i64>
function builtin_i64_atomic_rmw16_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_cmpxchg(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw16_cmpxchg_u, builtin_i64_atomic_rmw16_cmpxchg_u);

// i64.atomic.rmw32.cmpxchg_u -> <i64>atomic.cmpxchg<u32 from i64>
function builtin_i64_atomic_rmw32_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_cmpxchg(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw32_cmpxchg_u, builtin_i64_atomic_rmw32_cmpxchg_u);

// i64.atomic.rmw.cmpxchg -> <i64>atomic.cmpxchg<i64 from i64>
function builtin_i64_atomic_rmw_cmpxchg(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.i64;
  ctx.contextIsExact = true;
  return builtin_atomic_cmpxchg(ctx);
}
builtins.set(BuiltinNames.i64_atomic_rmw_cmpxchg, builtin_i64_atomic_rmw_cmpxchg);

// i32.wait -> atomic.wait<i32>
function builtin_i32_wait(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  return builtin_atomic_wait(ctx);
}
builtins.set(BuiltinNames.i32_wait, builtin_i32_wait);

// i64.wait -> atomic.wait<i64>
function builtin_i64_wait(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.i32;
  return builtin_atomic_wait(ctx);
}
builtins.set(BuiltinNames.i64_wait, builtin_i64_wait);

// v128.load -> load<v128>
function builtin_v128_load(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.v128 ];
  ctx.contextualType = Type.v128;
  return builtin_load(ctx);
}
builtins.set(BuiltinNames.v128_load, builtin_v128_load);

// v128.load8x8_s -> v128.load_ext<i8>
function builtin_v128_load8x8_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_load_ext(ctx);
}
builtins.set(BuiltinNames.v128_load8x8_s, builtin_v128_load8x8_s);

// v128.load8x8_u -> v128.load_ext<u8>
function builtin_v128_load8x8_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_load_ext(ctx);
}
builtins.set(BuiltinNames.v128_load8x8_u, builtin_v128_load8x8_u);

// v128.load16x4_s -> v128.load_ext<i16>
function builtin_v128_load16x4_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_load_ext(ctx);
}
builtins.set(BuiltinNames.v128_load16x4_s, builtin_v128_load16x4_s);

// v128.load16x4_u -> v128.load_ext<u16>
function builtin_v128_load16x4_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_load_ext(ctx);
}
builtins.set(BuiltinNames.v128_load16x4_u, builtin_v128_load16x4_u);

// v128.load32x2_s -> v128.load_ext<i32>
function builtin_v128_load32x2_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_load_ext(ctx);
}
builtins.set(BuiltinNames.v128_load32x2_s, builtin_v128_load32x2_s);

// v128.load32x2_u -> v128.load_ext<u32>
function builtin_v128_load32x2_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_load_ext(ctx);
}
builtins.set(BuiltinNames.v128_load32x2_u, builtin_v128_load32x2_u);

// v128.load8_splat -> v128.load_splat<u8>
function builtin_v128_load8_splat(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_load_splat(ctx);
}
builtins.set(BuiltinNames.v128_load8_splat, builtin_v128_load8_splat);

// v128.load16_splat -> v128.load_splat<u16>
function builtin_v128_load16_splat(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_load_splat(ctx);
}
builtins.set(BuiltinNames.v128_load16_splat, builtin_v128_load16_splat);

// v128.load32_splat -> v128.load_splat<u32>
function builtin_v128_load32_splat(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_load_splat(ctx);
}
builtins.set(BuiltinNames.v128_load32_splat, builtin_v128_load32_splat);

// v128.load64_splat -> v128.load_splat<u64>
function builtin_v128_load64_splat(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_load_splat(ctx);
}
builtins.set(BuiltinNames.v128_load64_splat, builtin_v128_load64_splat);

// v128.load32_zero -> v128.load_zero<u32>
function builtin_v128_load32_zero(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_load_zero(ctx);
}
builtins.set(BuiltinNames.v128_load32_zero, builtin_v128_load32_zero);

// v128.load64_zero -> v128.load_zero<u64>
function builtin_v128_load64_zero(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_load_zero(ctx);
}
builtins.set(BuiltinNames.v128_load64_zero, builtin_v128_load64_zero);

// v128.load8_lane -> v128.load_lane<u8>
function builtin_v128_load8_lane(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_load_lane(ctx);
}
builtins.set(BuiltinNames.v128_load8_lane, builtin_v128_load8_lane);

// v128.load16_lane -> v128.load_lane<u16>
function builtin_v128_load16_lane(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_load_lane(ctx);
}
builtins.set(BuiltinNames.v128_load16_lane, builtin_v128_load16_lane);

// v128.load32_lane -> v128.load_lane<u32>
function builtin_v128_load32_lane(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_load_lane(ctx);
}
builtins.set(BuiltinNames.v128_load32_lane, builtin_v128_load32_lane);

// v128.load64_lane -> v128.load_lane<u64>
function builtin_v128_load64_lane(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_load_lane(ctx);
}
builtins.set(BuiltinNames.v128_load64_lane, builtin_v128_load64_lane);

// v128.store8_lane -> v128.store_lane<u8>
function builtin_v128_store8_lane(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_store_lane(ctx);
}
builtins.set(BuiltinNames.v128_store8_lane, builtin_v128_store8_lane);

// v128.store16_lane -> v128.store_lane<u16>
function builtin_v128_store16_lane(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_store_lane(ctx);
}
builtins.set(BuiltinNames.v128_store16_lane, builtin_v128_store16_lane);

// v128.store32_lane -> v128.store_lane<u32>
function builtin_v128_store32_lane(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_store_lane(ctx);
}
builtins.set(BuiltinNames.v128_store32_lane, builtin_v128_store32_lane);

// v128.store64_lane -> v128.store_lane<u64>
function builtin_v128_store64_lane(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_store_lane(ctx);
}
builtins.set(BuiltinNames.v128_store64_lane, builtin_v128_store64_lane);

// v128.store -> store<v128 from v128>
function builtin_v128_store(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.v128 ];
  ctx.contextualType = Type.v128;
  ctx.contextIsExact = true;
  return builtin_store(ctx);
}
builtins.set(BuiltinNames.v128_store, builtin_v128_store);

// i8x16_splat -> v128.splat<i8>
function builtin_i8x16_splat(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_splat(ctx);
}
builtins.set(BuiltinNames.i8x16_splat, builtin_i8x16_splat);

// i8x16.extract_lane_s -> <i32>v128.extract_lane<i8>
function builtin_i8x16_extract_lane_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.i32;
  return builtin_v128_extract_lane(ctx);
}
builtins.set(BuiltinNames.i8x16_extract_lane_s, builtin_i8x16_extract_lane_s);

// i8x16.extract_lane_u -> <i32>v128.extract_lane<u8>
function builtin_i8x16_extract_lane_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.i32;
  return builtin_v128_extract_lane(ctx);
}
builtins.set(BuiltinNames.i8x16_extract_lane_u, builtin_i8x16_extract_lane_u);

// i8x16.replace_lane -> v128.replace_lane<i8>
function builtin_i8x16_replace_lane(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_replace_lane(ctx);
}
builtins.set(BuiltinNames.i8x16_replace_lane, builtin_i8x16_replace_lane);

// i8x16.add -> v128.add<i8>
function builtin_i8x16_add(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_add(ctx);
}
builtins.set(BuiltinNames.i8x16_add, builtin_i8x16_add);

// i8x16.sub -> v128.sub<i8>
function builtin_i8x16_sub(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_sub(ctx);
}
builtins.set(BuiltinNames.i8x16_sub, builtin_i8x16_sub);

// i8x16.min_s -> v128.min<i8>
function builtin_i8x16_min_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_min(ctx);
}
builtins.set(BuiltinNames.i8x16_min_s, builtin_i8x16_min_s);

// i8x16.min_u -> v128.min<u8>
function builtin_i8x16_min_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_min(ctx);
}
builtins.set(BuiltinNames.i8x16_min_u, builtin_i8x16_min_u);

// i8x16.max_s -> v128.max<i8>
function builtin_i8x16_max_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_max(ctx);
}
builtins.set(BuiltinNames.i8x16_max_s, builtin_i8x16_max_s);

// i8x16.max_u -> v128.max<u8>
function builtin_i8x16_max_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_max(ctx);
}
builtins.set(BuiltinNames.i8x16_max_u, builtin_i8x16_max_u);

// i8x16.avgr_u -> v128.avgr<u8>
function builtin_i8x16_avgr_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_avgr(ctx);
}
builtins.set(BuiltinNames.i8x16_avgr_u, builtin_i8x16_avgr_u);

// i8x16.abs -> v128.abs<i8>
function builtin_i8x16_abs(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_abs(ctx);
}
builtins.set(BuiltinNames.i8x16_abs, builtin_i8x16_abs);

// i8x16.neg -> v128.neg<i8>
function builtin_i8x16_neg(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_neg(ctx);
}
builtins.set(BuiltinNames.i8x16_neg, builtin_i8x16_neg);

// i8x16.add_sat_s -> v128.add_sat<i8>
function builtin_i8x16_add_sat_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_add_sat(ctx);
}
builtins.set(BuiltinNames.i8x16_add_sat_s, builtin_i8x16_add_sat_s);

// i8x16.add_sat_u -> v128.add_sat<u8>
function builtin_i8x16_add_sat_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_add_sat(ctx);
}
builtins.set(BuiltinNames.i8x16_add_sat_u, builtin_i8x16_add_sat_u);

// i8x16.sub_sat_s -> v128.sub_sat<i8>
function builtin_i8x16_sub_sat_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_sub_sat(ctx);
}
builtins.set(BuiltinNames.i8x16_sub_sat_s, builtin_i8x16_sub_sat_s);

// i8x16.sub_sat_u -> v128.sub_sat<u8>
function builtin_i8x16_sub_sat_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_sub_sat(ctx);
}
builtins.set(BuiltinNames.i8x16_sub_sat_u, builtin_i8x16_sub_sat_u);

// i8x16.shl -> v128.shl<i8>
function builtin_i8x16_shl(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_shl(ctx);
}
builtins.set(BuiltinNames.i8x16_shl, builtin_i8x16_shl);

// i8x16.shr_s -> v128.shr<i8>
function builtin_i8x16_shr_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_shr(ctx);
}
builtins.set(BuiltinNames.i8x16_shr_s, builtin_i8x16_shr_s);

// i8x16.shr_u -> v128.shr<u8>
function builtin_i8x16_shr_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_shr(ctx);
}
builtins.set(BuiltinNames.i8x16_shr_u, builtin_i8x16_shr_u);

// i8x16.all_true -> v128.all_true<i8>
function builtin_i8x16_all_true(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.i32;
  return builtin_v128_all_true(ctx);
}
builtins.set(BuiltinNames.i8x16_all_true, builtin_i8x16_all_true);

// i8x16.bitmask -> v128.bitmask<i8>
function builtin_i8x16_bitmask(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.i32;
  return builtin_v128_bitmask(ctx);
}
builtins.set(BuiltinNames.i8x16_bitmask, builtin_i8x16_bitmask);

// i8x16.popcnt -> v128.popcnt<i8>
function builtin_i8x16_popcnt(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_popcnt(ctx);
}
builtins.set(BuiltinNames.i8x16_popcnt, builtin_i8x16_popcnt);

// i8x16.eq -> v128.eq<i8>
function builtin_i8x16_eq(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_eq(ctx);
}
builtins.set(BuiltinNames.i8x16_eq, builtin_i8x16_eq);

// i8x16.ne -> v128.ne<i8>
function builtin_i8x16_ne(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_ne(ctx);
}
builtins.set(BuiltinNames.i8x16_ne, builtin_i8x16_ne);

// i8x16.lt_s -> v128.lt<i8>
function builtin_i8x16_lt_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_lt(ctx);
}
builtins.set(BuiltinNames.i8x16_lt_s, builtin_i8x16_lt_s);

// i8x16.lt_u -> v128.lt<u8>
function builtin_i8x16_lt_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_lt(ctx);
}
builtins.set(BuiltinNames.i8x16_lt_u, builtin_i8x16_lt_u);

// i8x16.le_s -> v128.le<i8>
function builtin_i8x16_le_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_le(ctx);
}
builtins.set(BuiltinNames.i8x16_le_s, builtin_i8x16_le_s);

// i8x16.le_u -> v128.le<u8>
function builtin_i8x16_le_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_le(ctx);
}
builtins.set(BuiltinNames.i8x16_le_u, builtin_i8x16_le_u);

// i8x16.gt_s -> v128.gt<i8>
function builtin_i8x16_gt_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_gt(ctx);
}
builtins.set(BuiltinNames.i8x16_gt_s, builtin_i8x16_gt_s);

// i8x16.gt_u -> v128.gt<u8>
function builtin_i8x16_gt_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_gt(ctx);
}
builtins.set(BuiltinNames.i8x16_gt_u, builtin_i8x16_gt_u);

// i8x16.ge_s -> v128.ge<i8>
function builtin_i8x16_ge_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_ge(ctx);
}
builtins.set(BuiltinNames.i8x16_ge_s, builtin_i8x16_ge_s);

// i8x16.ge_u -> v128.ge<u8>
function builtin_i8x16_ge_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_ge(ctx);
}
builtins.set(BuiltinNames.i8x16_ge_u, builtin_i8x16_ge_u);

// i8x16.narrow_i16x8_s -> v128.narrow<i16>
function builtin_i8x16_narrow_i16x8_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_narrow(ctx);
}
builtins.set(BuiltinNames.i8x16_narrow_i16x8_s, builtin_i8x16_narrow_i16x8_s);

// i8x16.narrow_i16x8_u -> v128.narrow<u16>
function builtin_i8x16_narrow_i16x8_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_narrow(ctx);
}
builtins.set(BuiltinNames.i8x16_narrow_i16x8_u, builtin_i8x16_narrow_i16x8_u);

// i8x16.shuffle -> v128.shuffle<i8>
function builtin_i8x16_shuffle(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_shuffle(ctx);
}
builtins.set(BuiltinNames.i8x16_shuffle, builtin_i8x16_shuffle);

// i8x16.swizzle -> v128.swizzle
function builtin_i8x16_swizzle(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = null;
  ctx.contextualType = Type.v128;
  return builtin_v128_swizzle(ctx);
}
builtins.set(BuiltinNames.i8x16_swizzle, builtin_i8x16_swizzle);

// i16x8.splat -> v128.splat<i16>
function builtin_i16x8_splat(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_splat(ctx);
}
builtins.set(BuiltinNames.i16x8_splat, builtin_i16x8_splat);

// i16x8.extract_lane_s -> v128.extract_lane<i16>
function builtin_i16x8_extract_lane_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.i32;
  return builtin_v128_extract_lane(ctx);
}
builtins.set(BuiltinNames.i16x8_extract_lane_s, builtin_i16x8_extract_lane_s);

// i16x8..extract_lane_u -> v128.extract_lane<u16>
function builtin_i16x8_extract_lane_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.i32;
  return builtin_v128_extract_lane(ctx);
}
builtins.set(BuiltinNames.i16x8_extract_lane_u, builtin_i16x8_extract_lane_u);

// i16x8.replace_lane -> v128.replace_lane<i16>
function builtin_i16x8_replace_lane(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_replace_lane(ctx);
}
builtins.set(BuiltinNames.i16x8_replace_lane, builtin_i16x8_replace_lane);

// i16x8.add -> v128.add<i16>
function builtin_i16x8_add(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_add(ctx);
}
builtins.set(BuiltinNames.i16x8_add, builtin_i16x8_add);

// i16x8.sub -> v128.sub<i16>
function builtin_i16x8_sub(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_sub(ctx);
}
builtins.set(BuiltinNames.i16x8_sub, builtin_i16x8_sub);

// i16x8.mul -> v128.mul<i16>
function builtin_i16x8_mul(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_mul(ctx);
}
builtins.set(BuiltinNames.i16x8_mul, builtin_i16x8_mul);

// i16x8.min_s -> v128.min<i16>
function builtin_i16x8_min_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_min(ctx);
}
builtins.set(BuiltinNames.i16x8_min_s, builtin_i16x8_min_s);

// i16x8.min_u -> v128.min<u16>
function builtin_i16x8_min_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_min(ctx);
}
builtins.set(BuiltinNames.i16x8_min_u, builtin_i16x8_min_u);

// i16x8.max_s -> v128.max<i16>
function builtin_i16x8_max_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_max(ctx);
}
builtins.set(BuiltinNames.i16x8_max_s, builtin_i16x8_max_s);

// i16x8.max_u -> v128.max<u16>
function builtin_i16x8_max_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_max(ctx);
}
builtins.set(BuiltinNames.i16x8_max_u, builtin_i16x8_max_u);

// i16x8.avgr_u -> v128.avgr<u16>
function builtin_i16x8_avgr_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_avgr(ctx);
}
builtins.set(BuiltinNames.i16x8_avgr_u, builtin_i16x8_avgr_u);

// i16x8.abs -> v128.abs<i16>
function builtin_i16x8_abs(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_abs(ctx);
}
builtins.set(BuiltinNames.i16x8_abs, builtin_i16x8_abs);

// i16x8.neg -> v128.neg<i16>
function builtin_i16x8_neg(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_neg(ctx);
}
builtins.set(BuiltinNames.i16x8_neg, builtin_i16x8_neg);

// i16x8.add_sat_s -> v128.add_sat<i16>
function builtin_i16x8_add_sat_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_add_sat(ctx);
}
builtins.set(BuiltinNames.i16x8_add_sat_s, builtin_i16x8_add_sat_s);

// i16x8.add_sat_u -> v128.add_sat<u16>
function builtin_i16x8_add_sat_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_add_sat(ctx);
}
builtins.set(BuiltinNames.i16x8_add_sat_u, builtin_i16x8_add_sat_u);

// i16x8.sub_sat_s -> v128.sub_sat<i16>
function builtin_i16x8_sub_sat_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_sub_sat(ctx);
}
builtins.set(BuiltinNames.i16x8_sub_sat_s, builtin_i16x8_sub_sat_s);

// i16x8.sub_sat_u -> v128.sub_sat<u16>
function builtin_i16x8_sub_sat_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_sub_sat(ctx);
}
builtins.set(BuiltinNames.i16x8_sub_sat_u, builtin_i16x8_sub_sat_u);

// i16x8.shl -> v128.shl<i16>
function builtin_i16x8_shl(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_shl(ctx);
}
builtins.set(BuiltinNames.i16x8_shl, builtin_i16x8_shl);

// i16x8.shr_s -> v128.shr<i16>
function builtin_i16x8_shr_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_shr(ctx);
}
builtins.set(BuiltinNames.i16x8_shr_s, builtin_i16x8_shr_s);

// i16x8.shr_u -> v128.shr<u16>
function builtin_i16x8_shr_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_shr(ctx);
}
builtins.set(BuiltinNames.i16x8_shr_u, builtin_i16x8_shr_u);

// i16x8.all_true -> v128.all_true<i16>
function builtin_i16x8_all_true(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.i32;
  return builtin_v128_all_true(ctx);
}
builtins.set(BuiltinNames.i16x8_all_true, builtin_i16x8_all_true);

// i16x8.bitmask -> v128.bitmask<i16>
function builtin_i16x8_bitmask(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.i32;
  return builtin_v128_bitmask(ctx);
}
builtins.set(BuiltinNames.i16x8_bitmask, builtin_i16x8_bitmask);

// i16x8.eq -> v128.eq<i16>
function builtin_i16x8_eq(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_eq(ctx);
}
builtins.set(BuiltinNames.i16x8_eq, builtin_i16x8_eq);

// i16x8.ne -> v128.ne<i16>
function builtin_i16x8_ne(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_ne(ctx);
}
builtins.set(BuiltinNames.i16x8_ne, builtin_i16x8_ne);

// i16x8.lt_s -> v128.lt<i16>
function builtin_i16x8_lt_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_lt(ctx);
}
builtins.set(BuiltinNames.i16x8_lt_s, builtin_i16x8_lt_s);

// i16x8.lt_u -> v128.lt<u16>
function builtin_i16x8_lt_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_lt(ctx);
}
builtins.set(BuiltinNames.i16x8_lt_u, builtin_i16x8_lt_u);

// i16x8.le_s -> v128.le<i16>
function builtin_i16x8_le_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_le(ctx);
}
builtins.set(BuiltinNames.i16x8_le_s, builtin_i16x8_le_s);

// i16x8.le_u -> v128.le<u16>
function builtin_i16x8_le_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_le(ctx);
}
builtins.set(BuiltinNames.i16x8_le_u, builtin_i16x8_le_u);

// i16x8.gt_s -> v128.gt<i16>
function builtin_i16x8_gt_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_gt(ctx);
}
builtins.set(BuiltinNames.i16x8_gt_s, builtin_i16x8_gt_s);

// i16x8.gt_u -> v128.gt<u16>
function builtin_i16x8_gt_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_gt(ctx);
}
builtins.set(BuiltinNames.i16x8_gt_u, builtin_i16x8_gt_u);

// i16x8.ge_s -> v128.ge<i16>
function builtin_i16x8_ge_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_ge(ctx);
}
builtins.set(BuiltinNames.i16x8_ge_s, builtin_i16x8_ge_s);

// i16x8.ge_u -> v128.ge<u16>
function builtin_i16x8_ge_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_ge(ctx);
}
builtins.set(BuiltinNames.i16x8_ge_u, builtin_i16x8_ge_u);

// i16x8.narrow_i32x4_s -> v128.narrow<i32>
function builtin_i16x8_narrow_i32x4_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_narrow(ctx);
}
builtins.set(BuiltinNames.i16x8_narrow_i32x4_s, builtin_i16x8_narrow_i32x4_s);

// i16x8.narrow_i32x4_u -> v128.narrow<u32>
function builtin_i16x8_narrow_i32x4_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_narrow(ctx);
}
builtins.set(BuiltinNames.i16x8_narrow_i32x4_u, builtin_i16x8_narrow_i32x4_u);

// i16x8.extend_low_i8x16_s -> v128.extend_low<i8>
function builtin_i16x8_extend_low_i8x16_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extend_low(ctx);
}
builtins.set(BuiltinNames.i16x8_extend_low_i8x16_s, builtin_i16x8_extend_low_i8x16_s);

// i16x8.extend_low_i8x16_u -> v128.extend_low<u8>
function builtin_i16x8_extend_low_i8x16_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extend_low(ctx);
}
builtins.set(BuiltinNames.i16x8_extend_low_i8x16_u, builtin_i16x8_extend_low_i8x16_u);

// i16x8.extend_high_i8x16_s -> v128.extend_high<i8>
function builtin_i16x8_extend_high_i8x16_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extend_high(ctx);
}
builtins.set(BuiltinNames.i16x8_extend_high_i8x16_s, builtin_i16x8_extend_high_i8x16_s);

// i16x8.extend_high_i8x16_u -> v128.extend_high<u8>
function builtin_i16x8_extend_high_i8x16_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extend_high(ctx);
}
builtins.set(BuiltinNames.i16x8_extend_high_i8x16_u, builtin_i16x8_extend_high_i8x16_u);

// i16x8.extadd_pairwise_i8x16_s -> v128.extadd_pairwise<i8>
function builtin_i16x8_extadd_pairwise_i8x16_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extadd_pairwise(ctx);
}
builtins.set(BuiltinNames.i16x8_extadd_pairwise_i8x16_s, builtin_i16x8_extadd_pairwise_i8x16_s);

// i16x8.extadd_pairwise_i8x16_u -> v128.extadd_pairwise<u8>
function builtin_i16x8_extadd_pairwise_i8x16_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extadd_pairwise(ctx);
}
builtins.set(BuiltinNames.i16x8_extadd_pairwise_i8x16_u, builtin_i16x8_extadd_pairwise_i8x16_u);

// i16x8.q15mulr_sat_s -> v128.q15mulr_sat<i16>
function builtin_i16x8_q15mulr_sat_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_q15mulr_sat(ctx);
}
builtins.set(BuiltinNames.i16x8_q15mulr_sat_s, builtin_i16x8_q15mulr_sat_s);

// i16x8.extmul_low_i8x16_s -> v128.extmul_low<i16>
function builtin_i16x8_extmul_low_i8x16_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extmul_low(ctx);
}
builtins.set(BuiltinNames.i16x8_extmul_low_i8x16_s, builtin_i16x8_extmul_low_i8x16_s);

// i16x8.extmul_low_i8x16_u -> v128.extmul_low<u16>
function builtin_i16x8_extmul_low_i8x16_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extmul_low(ctx);
}
builtins.set(BuiltinNames.i16x8_extmul_low_i8x16_u, builtin_i16x8_extmul_low_i8x16_u);

// i16x8.extmul_high_i8x16_s -> v128.extmul_high<i16>
function builtin_i16x8_extmul_high_i8x16_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extmul_high(ctx);
}
builtins.set(BuiltinNames.i16x8_extmul_high_i8x16_s, builtin_i16x8_extmul_high_i8x16_s);

// i16x8.extmul_high_i8x16_u -> v128.extmul_high<u16>
function builtin_i16x8_extmul_high_i8x16_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u8 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extmul_high(ctx);
}
builtins.set(BuiltinNames.i16x8_extmul_high_i8x16_u, builtin_i16x8_extmul_high_i8x16_u);

// i32x4.splat -> v128.splat<i32>
function builtin_i32x4_splat(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_splat(ctx);
}
builtins.set(BuiltinNames.i32x4_splat, builtin_i32x4_splat);

// i32x4.extract_lane -> <i32>v128.extract_lane<i32>
function builtin_i32x4_extract_lane(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i32;
  return builtin_v128_extract_lane(ctx);
}
builtins.set(BuiltinNames.i32x4_extract_lane, builtin_i32x4_extract_lane);

// i32x4.replace_lane -> v128.replace_lane<i32>
function builtin_i32x4_replace_lane(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_replace_lane(ctx);
}
builtins.set(BuiltinNames.i32x4_replace_lane, builtin_i32x4_replace_lane);

// i32x4.add -> v128.add<i32>
function builtin_i32x4_add(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_add(ctx);
}
builtins.set(BuiltinNames.i32x4_add, builtin_i32x4_add);

// i32x4.sub -> v128.sub<i32>
function builtin_i32x4_sub(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_sub(ctx);
}
builtins.set(BuiltinNames.i32x4_sub, builtin_i32x4_sub);

// i32x4.mul -> v128.mul<i32>
function builtin_i32x4_mul(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_mul(ctx);
}
builtins.set(BuiltinNames.i32x4_mul, builtin_i32x4_mul);

// i32x4.min_s -> v128.min<i32>
function builtin_i32x4_min_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_min(ctx);
}
builtins.set(BuiltinNames.i32x4_min_s, builtin_i32x4_min_s);

// i32x4.min_u -> v128.min<u32>
function builtin_i32x4_min_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_min(ctx);
}
builtins.set(BuiltinNames.i32x4_min_u, builtin_i32x4_min_u);

// i32x4.max_s -> v128.max<i32>
function builtin_i32x4_max_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_max(ctx);
}
builtins.set(BuiltinNames.i32x4_max_s, builtin_i32x4_max_s);

// i32x4.max_u -> v128.max<u32>
function builtin_i32x4_max_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_max(ctx);
}
builtins.set(BuiltinNames.i32x4_max_u, builtin_i32x4_max_u);

// i32x4.dot_i16x8_s -> v128.dot<i16>
function builtin_i32x4_dot_i16x8_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_dot(ctx);
}
builtins.set(BuiltinNames.i32x4_dot_i16x8_s, builtin_i32x4_dot_i16x8_s);

// i32x4.abs -> v128.abs<i32>
function builtin_i32x4_abs(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_abs(ctx);
}
builtins.set(BuiltinNames.i32x4_abs, builtin_i32x4_abs);

// i32x4.neg -> v128.neg<i32>
function builtin_i32x4_neg(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_neg(ctx);
}
builtins.set(BuiltinNames.i32x4_neg, builtin_i32x4_neg);

// i32x4.shl -> v128.shl<i32>
function builtin_i32x4_shl(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_shl(ctx);
}
builtins.set(BuiltinNames.i32x4_shl, builtin_i32x4_shl);

// i32x4.shr_s -> v128.shr<i32>
function builtin_i32x4_shr_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_shr(ctx);
}
builtins.set(BuiltinNames.i32x4_shr_s, builtin_i32x4_shr_s);

// i32x4.shr_u -> v128.shr<u32>
function builtin_i32x4_shr_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_shr(ctx);
}
builtins.set(BuiltinNames.i32x4_shr_u, builtin_i32x4_shr_u);

// i32x4.all_true -> v128.all_true<i32>
function builtin_i32x4_all_true(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i32;
  return builtin_v128_all_true(ctx);
}
builtins.set(BuiltinNames.i32x4_all_true, builtin_i32x4_all_true);

// i32x4.bitmask -> v128.bitmask<i32>
function builtin_i32x4_bitmask(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.i32;
  return builtin_v128_bitmask(ctx);
}
builtins.set(BuiltinNames.i32x4_bitmask, builtin_i32x4_bitmask);

// i32x4.eq -> v128.eq<i32>
function builtin_i32x4_eq(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_eq(ctx);
}
builtins.set(BuiltinNames.i32x4_eq, builtin_i32x4_eq);

// i32x4.ne -> v128.ne<i32>
function builtin_i32x4_ne(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_ne(ctx);
}
builtins.set(BuiltinNames.i32x4_ne, builtin_i32x4_ne);

// i32x4.lt_s -> v128.lt<i32>
function builtin_i32x4_lt_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_lt(ctx);
}
builtins.set(BuiltinNames.i32x4_lt_s, builtin_i32x4_lt_s);

// i32x4.lt_u -> v128.lt<u32>
function builtin_i32x4_lt_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_lt(ctx);
}
builtins.set(BuiltinNames.i32x4_lt_u, builtin_i32x4_lt_u);

// i32x4.le_s -> v128.le<i32>
function builtin_i32x4_le_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_le(ctx);
}
builtins.set(BuiltinNames.i32x4_le_s, builtin_i32x4_le_s);

// i32x4.le_u -> v128.le<u32>
function builtin_i32x4_le_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_le(ctx);
}
builtins.set(BuiltinNames.i32x4_le_u, builtin_i32x4_le_u);

// i32x4.gt_s -> v128.gt<i32>
function builtin_i32x4_gt_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_gt(ctx);
}
builtins.set(BuiltinNames.i32x4_gt_s, builtin_i32x4_gt_s);

// i32x4.gt_u -> v128.gt<u32>
function builtin_i32x4_gt_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_gt(ctx);
}
builtins.set(BuiltinNames.i32x4_gt_u, builtin_i32x4_gt_u);

// i32x4.ge_s -> v128.ge<i32>
function builtin_i32x4_ge_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_ge(ctx);
}
builtins.set(BuiltinNames.i32x4_ge_s, builtin_i32x4_ge_s);

// i32x4.ge_u -> v128.ge<u32>
function builtin_i32x4_ge_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_ge(ctx);
}
builtins.set(BuiltinNames.i32x4_ge_u, builtin_i32x4_ge_u);

// i32x4.trunc_sat_f32x4_s -> v128.trunc_sat<i32>
function builtin_i32x4_trunc_sat_f32x4_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_trunc_sat(ctx);
}
builtins.set(BuiltinNames.i32x4_trunc_sat_f32x4_s, builtin_i32x4_trunc_sat_f32x4_s);

// i32x4.trunc_sat_f32x4_u -> v128.trunc_sat<u32>
function builtin_i32x4_trunc_sat_f32x4_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_trunc_sat(ctx);
}
builtins.set(BuiltinNames.i32x4_trunc_sat_f32x4_u, builtin_i32x4_trunc_sat_f32x4_u);

// i32x4.trunc_sat_f64x2_s_zero -> v128.trunc_sat_zero<i32>
function builtin_i32x4_trunc_sat_f64x2_s_zero(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_trunc_sat_zero(ctx);
}
builtins.set(BuiltinNames.i32x4_trunc_sat_f64x2_s_zero, builtin_i32x4_trunc_sat_f64x2_s_zero);

// i32x4.trunc_sat_f64x2_u_zero -> v128.trunc_sat_zero<u32>
function builtin_i32x4_trunc_sat_f64x2_u_zero(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_trunc_sat_zero(ctx);
}
builtins.set(BuiltinNames.i32x4_trunc_sat_f64x2_u_zero, builtin_i32x4_trunc_sat_f64x2_u_zero);

// i32x4.extend_low_i16x8_s -> // v128.extend_low<i16>
function builtin_i32x4_extend_low_i16x8_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extend_low(ctx);
}
builtins.set(BuiltinNames.i32x4_extend_low_i16x8_s, builtin_i32x4_extend_low_i16x8_s);

// i32x4.extend_low_i16x8_u -> v128.extend_low<u16>
function builtin_i32x4_extend_low_i16x8_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extend_low(ctx);
}
builtins.set(BuiltinNames.i32x4_extend_low_i16x8_u, builtin_i32x4_extend_low_i16x8_u);

// i32x4.extend_high_i16x8_s -> v128.extend_high<i16>
function builtin_i32x4_extend_high_i16x8_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extend_high(ctx);
}
builtins.set(BuiltinNames.i32x4_extend_high_i16x8_s, builtin_i32x4_extend_high_i16x8_s);

// i32x4.extend_high_i16x8_u -> v128.extend_high<u16>
function builtin_i32x4_extend_high_i16x8_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extend_high(ctx);
}
builtins.set(BuiltinNames.i32x4_extend_high_i16x8_u, builtin_i32x4_extend_high_i16x8_u);

// i32x4.extadd_pairwise_i16x8_s -> v128.extadd_pairwise<i16>
function builtin_i32x4_extadd_pairwise_i16x8_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extadd_pairwise(ctx);
}
builtins.set(BuiltinNames.i32x4_extadd_pairwise_i16x8_s, builtin_i32x4_extadd_pairwise_i16x8_s);

// i32x4.extadd_pairwise_i16x8_u -> v128.extadd_pairwise<u16>
function builtin_i32x4_extadd_pairwise_i16x8_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extadd_pairwise(ctx);
}
builtins.set(BuiltinNames.i32x4_extadd_pairwise_i16x8_u, builtin_i32x4_extadd_pairwise_i16x8_u);

// i32x4.extmul_low_i16x8_s -> v128.extmul_low<i16>
function builtin_i32x4_extmul_low_i16x8_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extmul_low(ctx);
}
builtins.set(BuiltinNames.i32x4_extmul_low_i16x8_s, builtin_i32x4_extmul_low_i16x8_s);

// i32x4.extmul_low_i16x8_u -> v128.extmul_low<u16>
function builtin_i32x4_extmul_low_i16x8_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extmul_low(ctx);
}
builtins.set(BuiltinNames.i32x4_extmul_low_i16x8_u, builtin_i32x4_extmul_low_i16x8_u);

// i32x4.extmul_high_i16x8_s -> v128.extmul_high<i16>
function builtin_i32x4_extmul_high_i16x8_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extmul_high(ctx);
}
builtins.set(BuiltinNames.i32x4_extmul_high_i16x8_s, builtin_i32x4_extmul_high_i16x8_s);

// i32x4.extmul_high_i16x8_u -> v128.extmul_high<u16>
function builtin_i32x4_extmul_high_i16x8_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u16 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extmul_high(ctx);
}
builtins.set(BuiltinNames.i32x4_extmul_high_i16x8_u, builtin_i32x4_extmul_high_i16x8_u);

// i64x2.splat -> v128.splat<i64>
function builtin_i64x2_splat(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_splat(ctx);
}
builtins.set(BuiltinNames.i64x2_splat, builtin_i64x2_splat);

// i64x2.extract_lane -> <i64>v128.extract_lane<i64>
function builtin_i64x2_extract_lane(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.i64;
  return builtin_v128_extract_lane(ctx);
}
builtins.set(BuiltinNames.i64x2_extract_lane, builtin_i64x2_extract_lane);

// i64x2.replace_lane -> v128.replace_lane<i64>
function builtin_i64x2_replace_lane(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_replace_lane(ctx);
}
builtins.set(BuiltinNames.i64x2_replace_lane, builtin_i64x2_replace_lane);

// i64x2.add -> v128.add<i64>
function builtin_i64x2_add(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_add(ctx);
}
builtins.set(BuiltinNames.i64x2_add, builtin_i64x2_add);

// i64x2.sub -> v128.sub<i64>
function builtin_i64x2_sub(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_sub(ctx);
}
builtins.set(BuiltinNames.i64x2_sub, builtin_i64x2_sub);

// i64x2.mul -> v128.mul<i64>
function builtin_i64x2_mul(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_mul(ctx);
}
builtins.set(BuiltinNames.i64x2_mul, builtin_i64x2_mul);

// i64x2.abs -> v128.abs<i64>
function builtin_i64x2_abs(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_abs(ctx);
}
builtins.set(BuiltinNames.i64x2_abs, builtin_i64x2_abs);

// i64x2.neg -> v128.neg<i64>
function builtin_i64x2_neg(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_neg(ctx);
}
builtins.set(BuiltinNames.i64x2_neg, builtin_i64x2_neg);

// i64x2.shl -> v128.shl<i64>
function builtin_i64x2_shl(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_shl(ctx);
}
builtins.set(BuiltinNames.i64x2_shl, builtin_i64x2_shl);

// i64x2.shr_s -> v128.shr<i64>
function builtin_i64x2_shr_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_shr(ctx);
}
builtins.set(BuiltinNames.i64x2_shr_s, builtin_i64x2_shr_s);

// i64x2.shr_u -> v128.shr<u64>
function builtin_i64x2_shr_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_shr(ctx);
}
builtins.set(BuiltinNames.i64x2_shr_u, builtin_i64x2_shr_u);

// i64x2.all_true -> v128.all_true<i64>
function builtin_i64x2_all_true(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.i32;
  return builtin_v128_all_true(ctx);
}
builtins.set(BuiltinNames.i64x2_all_true, builtin_i64x2_all_true);

// i64x2.bitmask -> v128.bitmask<i64>
function builtin_i64x2_bitmask(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.i32;
  return builtin_v128_bitmask(ctx);
}
builtins.set(BuiltinNames.i64x2_bitmask, builtin_i64x2_bitmask);

// i64x2.eq -> v128.eq<i64>
function builtin_i64x2_eq(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_eq(ctx);
}
builtins.set(BuiltinNames.i64x2_eq, builtin_i64x2_eq);

// i64x2.ne -> v128.ne<i64>
function builtin_i64x2_ne(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_ne(ctx);
}
builtins.set(BuiltinNames.i64x2_ne, builtin_i64x2_ne);

// i64x2.lt_s -> v128.lt<i64>
function builtin_i64x2_lt_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_lt(ctx);
}
builtins.set(BuiltinNames.i64x2_lt_s, builtin_i64x2_lt_s);

// i64x2.le_s -> v128.le<i64>
function builtin_i64x2_le_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_le(ctx);
}
builtins.set(BuiltinNames.i64x2_le_s, builtin_i64x2_le_s);

// i64x2.gt_s -> v128.gt<i64>
function builtin_i64x2_gt_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_gt(ctx);
}
builtins.set(BuiltinNames.i64x2_gt_s, builtin_i64x2_gt_s);

// i64x2.ge_s -> v128.ge<i64>
function builtin_i64x2_ge_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_ge(ctx);
}
builtins.set(BuiltinNames.i64x2_ge_s, builtin_i64x2_ge_s);

// i64x2.extend_low_i32x4_s -> // v128.extend_low<i32>
function builtin_i64x2_extend_low_i32x4_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extend_low(ctx);
}
builtins.set(BuiltinNames.i64x2_extend_low_i32x4_s, builtin_i64x2_extend_low_i32x4_s);

// i64x2.extend_low_i32x4_u -> v128.extend_low<u32>
function builtin_i64x2_extend_low_i32x4_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extend_low(ctx);
}
builtins.set(BuiltinNames.i64x2_extend_low_i32x4_u, builtin_i64x2_extend_low_i32x4_u);

// i64x2.extend_high_i32x4_s -> v128.extend_high<i32>
function builtin_i64x2_extend_high_i32x4_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extend_high(ctx);
}
builtins.set(BuiltinNames.i64x2_extend_high_i32x4_s, builtin_i64x2_extend_high_i32x4_s);

// i64x2.extend_high_i32x4_u -> v128.extend_high<u32>
function builtin_i64x2_extend_high_i32x4_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extend_high(ctx);
}
builtins.set(BuiltinNames.i64x2_extend_high_i32x4_u, builtin_i64x2_extend_high_i32x4_u);

// i64x2.extmul_low_i32x4_s -> v128.extmul_low<i32>
function builtin_i64x2_extmul_low_i32x4_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extmul_low(ctx);
}
builtins.set(BuiltinNames.i64x2_extmul_low_i32x4_s, builtin_i64x2_extmul_low_i32x4_s);

// i64x2.extmul_low_i32x4_u -> v128.extmul_low<u32>
function builtin_i64x2_extmul_low_i32x4_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extmul_low(ctx);
}
builtins.set(BuiltinNames.i64x2_extmul_low_i32x4_u, builtin_i64x2_extmul_low_i32x4_u);

// i64x2.extmul_high_i32x4_s -> v128.extmul_high<i32>
function builtin_i64x2_extmul_high_i32x4_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extmul_high(ctx);
}
builtins.set(BuiltinNames.i64x2_extmul_high_i32x4_s, builtin_i64x2_extmul_high_i32x4_s);

// i64x2.extmul_high_i32x4_u -> v128.extmul_high<u32>
function builtin_i64x2_extmul_high_i32x4_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_extmul_high(ctx);
}
builtins.set(BuiltinNames.i64x2_extmul_high_i32x4_u, builtin_i64x2_extmul_high_i32x4_u);

// f32x4.splat -> v128.splat<f32>
function builtin_f32x4_splat(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_splat(ctx);
}
builtins.set(BuiltinNames.f32x4_splat, builtin_f32x4_splat);

// f32x4.extract_lane -> <f32>v128.extract_lane<f32>
function builtin_f32x4_extract_lane(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.f32;
  return builtin_v128_extract_lane(ctx);
}
builtins.set(BuiltinNames.f32x4_extract_lane, builtin_f32x4_extract_lane);

// f32x4.replace_lane -> v128.replace_lane<f32>
function builtin_f32x4_replace_lane(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_replace_lane(ctx);
}
builtins.set(BuiltinNames.f32x4_replace_lane, builtin_f32x4_replace_lane);

// f32x4.add -> v128.add<f32>
function builtin_f32x4_add(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_add(ctx);
}
builtins.set(BuiltinNames.f32x4_add, builtin_f32x4_add);

// f32x4.sub -> v128.sub<f32>
function builtin_f32x4_sub(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_sub(ctx);
}
builtins.set(BuiltinNames.f32x4_sub, builtin_f32x4_sub);

// f32x4.mul -> v128.mul<f32>
function builtin_f32x4_mul(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_mul(ctx);
}
builtins.set(BuiltinNames.f32x4_mul, builtin_f32x4_mul);

// f32x4.div -> v128.div<f32>
function builtin_f32x4_div(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_div(ctx);
}
builtins.set(BuiltinNames.f32x4_div, builtin_f32x4_div);

// f32x4.neg -> v128.neg<f32>
function builtin_f32x4_neg(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_neg(ctx);
}
builtins.set(BuiltinNames.f32x4_neg, builtin_f32x4_neg);

// f32x4.min -> v128.min<f32>
function builtin_f32x4_min(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_min(ctx);
}
builtins.set(BuiltinNames.f32x4_min, builtin_f32x4_min);

// f32x4.max -> v128.max<f32>
function builtin_f32x4_max(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_max(ctx);
}
builtins.set(BuiltinNames.f32x4_max, builtin_f32x4_max);

// f32x4.pmin -> v128.pmin<f32>
function builtin_f32x4_pmin(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_pmin(ctx);
}
builtins.set(BuiltinNames.f32x4_pmin, builtin_f32x4_pmin);

// f32x4.pmax -> v128.pmax<f32>
function builtin_f32x4_pmax(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_pmax(ctx);
}
builtins.set(BuiltinNames.f32x4_pmax, builtin_f32x4_pmax);

// f32x4.abs -> v128.abs<f32>
function builtin_f32x4_abs(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_abs(ctx);
}
builtins.set(BuiltinNames.f32x4_abs, builtin_f32x4_abs);

// f32x4.sqrt -> v128.sqrt<f32>
function builtin_f32x4_sqrt(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_sqrt(ctx);
}
builtins.set(BuiltinNames.f32x4_sqrt, builtin_f32x4_sqrt);

// f32x4.ceil -> v128.ceil<f32>
function builtin_f32x4_ceil(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_ceil(ctx);
}
builtins.set(BuiltinNames.f32x4_ceil, builtin_f32x4_ceil);

// f32x4.floor -> v128.floor<f32>
function builtin_f32x4_floor(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_floor(ctx);
}
builtins.set(BuiltinNames.f32x4_floor, builtin_f32x4_floor);

// f32x4.trunc -> v128.trunc<f32>
function builtin_f32x4_trunc(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_trunc(ctx);
}
builtins.set(BuiltinNames.f32x4_trunc, builtin_f32x4_trunc);

// f32x4.nearest -> v128.nearest<f32>
function builtin_f32x4_nearest(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_nearest(ctx);
}
builtins.set(BuiltinNames.f32x4_nearest, builtin_f32x4_nearest);

// f32x4.eq -> v128.eq<f32>
function builtin_f32x4_eq(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_eq(ctx);
}
builtins.set(BuiltinNames.f32x4_eq, builtin_f32x4_eq);

// f32x4.ne -> v128.ne<f32>
function builtin_f32x4_ne(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_ne(ctx);
}
builtins.set(BuiltinNames.f32x4_ne, builtin_f32x4_ne);

// f32x4.lt -> v128.lt<f32>
function builtin_f32x4_lt(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_lt(ctx);
}
builtins.set(BuiltinNames.f32x4_lt, builtin_f32x4_lt);

// f32x4.le -> v128.le<f32>
function builtin_f32x4_le(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_le(ctx);
}
builtins.set(BuiltinNames.f32x4_le, builtin_f32x4_le);

// f32x4.gt -> v128.gt<f32>
function builtin_f32x4_gt(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_gt(ctx);
}
builtins.set(BuiltinNames.f32x4_gt, builtin_f32x4_gt);

// f32x4.ge -> v128.ge<f32>
function builtin_f32x4_ge(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_ge(ctx);
}
builtins.set(BuiltinNames.f32x4_ge, builtin_f32x4_ge);

// f32x4.convert_i32x4_s -> v128.convert<i32>
function builtin_f32x4_convert_i32x4_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_convert(ctx);
}
builtins.set(BuiltinNames.f32x4_convert_i32x4_s, builtin_f32x4_convert_i32x4_s);

// f32x4.convert_i32x4_u -> v128.convert<u32>
function builtin_f32x4_convert_i32x4_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_convert(ctx);
}
builtins.set(BuiltinNames.f32x4_convert_i32x4_u, builtin_f32x4_convert_i32x4_u);

// f32x4.demote_f64x2_zero -> v128.demote_zero<f64>
function builtin_f32x4_demote_f64x2_zero(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_demote_zero(ctx);
}
builtins.set(BuiltinNames.f32x4_demote_f64x2_zero, builtin_f32x4_demote_f64x2_zero);

// f64x2.splat -> v128.splat<f64>
function builtin_f64x2_splat(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_splat(ctx);
}
builtins.set(BuiltinNames.f64x2_splat, builtin_f64x2_splat);

// f64x2.extract_lane -> <f64>v128.extract_lane<f64>
function builtin_f64x2_extract_lane(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.f64;
  return builtin_v128_extract_lane(ctx);
}
builtins.set(BuiltinNames.f64x2_extract_lane, builtin_f64x2_extract_lane);

// f64x2.replace_lane -> v128.replace_lane
function builtin_f64x2_replace_lane(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_replace_lane(ctx);
}
builtins.set(BuiltinNames.f64x2_replace_lane, builtin_f64x2_replace_lane);

// f64x2.add -> v128.add<f64>
function builtin_f64x2_add(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_add(ctx);
}
builtins.set(BuiltinNames.f64x2_add, builtin_f64x2_add);

// f64x2.sub -> v128.sub<f64>
function builtin_f64x2_sub(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_sub(ctx);
}
builtins.set(BuiltinNames.f64x2_sub, builtin_f64x2_sub);

// f64x2.mul -> v128.mul<f64>
function builtin_f64x2_mul(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_mul(ctx);
}
builtins.set(BuiltinNames.f64x2_mul, builtin_f64x2_mul);

// f64x2.div -> v128.div<f64>
function builtin_f64x2_div(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_div(ctx);
}
builtins.set(BuiltinNames.f64x2_div, builtin_f64x2_div);

// f64x2.neg -> v128.neg<f64>
function builtin_f64x2_neg(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_neg(ctx);
}
builtins.set(BuiltinNames.f64x2_neg, builtin_f64x2_neg);

// f64x2.min -> v128.min<f64>
function builtin_f64x2_min(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_min(ctx);
}
builtins.set(BuiltinNames.f64x2_min, builtin_f64x2_min);

// f64x2.max -> v128.max<f64>
function builtin_f64x2_max(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_max(ctx);
}
builtins.set(BuiltinNames.f64x2_max, builtin_f64x2_max);

// f64x2.pmin -> v128.pmin<f64>
function builtin_f64x2_pmin(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_pmin(ctx);
}
builtins.set(BuiltinNames.f64x2_pmin, builtin_f64x2_pmin);

// f64x2.pmax -> v128.pmax<f64>
function builtin_f64x2_pmax(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_pmax(ctx);
}
builtins.set(BuiltinNames.f64x2_pmax, builtin_f64x2_pmax);

// f64x2.abs -> v128.abs<f64>
function builtin_f64x2_abs(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_abs(ctx);
}
builtins.set(BuiltinNames.f64x2_abs, builtin_f64x2_abs);

// f64x2.sqrt -> v128.sqrt<f64>
function builtin_f64x2_sqrt(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_sqrt(ctx);
}
builtins.set(BuiltinNames.f64x2_sqrt, builtin_f64x2_sqrt);

// f64x2.ceil -> v128.ceil<f64>
function builtin_f64x2_ceil(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_ceil(ctx);
}
builtins.set(BuiltinNames.f64x2_ceil, builtin_f64x2_ceil);

// f64x2.floor -> v128.floor<f64>
function builtin_f64x2_floor(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_floor(ctx);
}
builtins.set(BuiltinNames.f64x2_floor, builtin_f64x2_floor);

// f64x2.trunc -> v128.trunc<f64>
function builtin_f64x2_trunc(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_trunc(ctx);
}
builtins.set(BuiltinNames.f64x2_trunc, builtin_f64x2_trunc);

// f64x2.nearest -> v128.nearest<f64>
function builtin_f64x2_nearest(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_nearest(ctx);
}
builtins.set(BuiltinNames.f64x2_nearest, builtin_f64x2_nearest);

// f64x2.eq -> v128.eq<f64>
function builtin_f64x2_eq(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_eq(ctx);
}
builtins.set(BuiltinNames.f64x2_eq, builtin_f64x2_eq);

// f64x2.ne -> v128.ne<f64>
function builtin_f64x2_ne(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_ne(ctx);
}
builtins.set(BuiltinNames.f64x2_ne, builtin_f64x2_ne);

// f64x2.lt -> v128.lt<f64>
function builtin_f64x2_lt(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_lt(ctx);
}
builtins.set(BuiltinNames.f64x2_lt, builtin_f64x2_lt);

// f64x2.le -> v128.le<f64>
function builtin_f64x2_le(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_le(ctx);
}
builtins.set(BuiltinNames.f64x2_le, builtin_f64x2_le);

// f64x2.gt -> v128.gt<f64>
function builtin_f64x2_gt(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_gt(ctx);
}
builtins.set(BuiltinNames.f64x2_gt, builtin_f64x2_gt);

// f64x2.ge -> v128.ge<f64>
function builtin_f64x2_ge(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f64 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_ge(ctx);
}
builtins.set(BuiltinNames.f64x2_ge, builtin_f64x2_ge);

// f64x2.convert_low_i32x4_s -> v128.convert_low<i32>
function builtin_f64x2_convert_low_i32x4_s(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.i32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_convert_low(ctx);
}
builtins.set(BuiltinNames.f64x2_convert_low_i32x4_s, builtin_f64x2_convert_low_i32x4_s);

// f64x2.convert_low_i32x4_u -> v128.convert_low<u32>
function builtin_f64x2_convert_low_i32x4_u(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.u32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_convert_low(ctx);
}
builtins.set(BuiltinNames.f64x2_convert_low_i32x4_u, builtin_f64x2_convert_low_i32x4_u);

// f64x2.promote_low_f32x4 -> v128.promote_low<f32>
function builtin_f64x4_promote_low_f32x4(ctx: BuiltinContext): ExpressionRef {
  checkTypeAbsent(ctx);
  ctx.typeArguments = [ Type.f32 ];
  ctx.contextualType = Type.v128;
  return builtin_v128_promote_low(ctx);
}
builtins.set(BuiltinNames.f64x2_promote_low_f32x4, builtin_f64x4_promote_low_f32x4);

// === Internal helpers =======================================================================

/** Compiles the `visit_globals` function. */
export function compileVisitGlobals(compiler: Compiler): void {
  var module = compiler.module;
  var exprs = new Array<ExpressionRef>();
  var sizeTypeRef = compiler.options.sizeTypeRef;
  var visitInstance = assert(compiler.program.visitInstance);

  // this function is @lazy: make sure it exists
  compiler.compileFunction(visitInstance, true);

  // TODO: for (let element of compiler.program.elementsByName.values()) {
  for (let _values = Map_values(compiler.program.elementsByName), i = 0, k = _values.length; i < k; ++i) {
    let element = unchecked(_values[i]);
    if (element.kind != ElementKind.GLOBAL) continue;
    let global = <Global>element;
    let globalType = global.type;
    let classReference = globalType.getClass();
    if (
      classReference !== null &&
      !classReference.hasDecorator(DecoratorFlags.UNMANAGED) &&
      global.is(CommonFlags.COMPILED)
    ) {
      if (global.is(CommonFlags.INLINED)) {
        let value = global.constantIntegerValue;
        if (i64_low(value) || i64_high(value)) {
          exprs.push(
            module.call(visitInstance.internalName, [
              compiler.options.isWasm64
                ? module.i64(i64_low(value), i64_high(value))
                : module.i32(i64_low(value)),
              module.local_get(0, TypeRef.I32) // cookie
            ], TypeRef.None)
          );
        }
      } else {
        exprs.push(
          module.if(
            module.local_tee(1,
              module.global_get(global.internalName, sizeTypeRef),
              false // internal
            ),
            module.call(visitInstance.internalName, [
              module.local_get(1, sizeTypeRef), // tempRef != null
              module.local_get(0, TypeRef.I32) // cookie
            ], TypeRef.None)
          )
        );
      }
    }
  }
  module.addFunction(BuiltinNames.visit_globals,
    TypeRef.I32,  // cookie
    TypeRef.None, // => void
    [ sizeTypeRef ],
    exprs.length
      ? module.block(null, exprs)
      : module.nop()
  );
}

/** Ensures that the visitor function of the specified class is compiled. */
function ensureVisitMembersOf(compiler: Compiler, instance: Class): void {
  assert(instance.type.isManaged);
  if (instance.visitRef) return;

  var program = compiler.program;
  var module = compiler.module;
  var usizeType = program.options.usizeType;
  var sizeTypeRef = usizeType.toRef();
  var sizeTypeSize = usizeType.byteSize;
  var visitInstance = assert(program.visitInstance);
  var body = new Array<ExpressionRef>();

  // If the class has a base class, call its visitor first
  var base = instance.base;
  if (base) {
    body.push(
      module.call(base.internalName + "~visit", [
        module.local_get(0, sizeTypeRef), // this
        module.local_get(1, TypeRef.I32)  // cookie
      ], TypeRef.None)
    );
  }

  // Some standard library components provide a custom visitor implementation,
  // for example to visit all members of a collection, e.g. arrays and maps.
  var hasVisitImpl = false;
  if (instance.isDeclaredInLibrary) {
    let visitPrototype = instance.lookupInSelf("__visit");
    if (visitPrototype) {
      assert(visitPrototype.kind == ElementKind.FUNCTION_PROTOTYPE);
      let visitInstance = program.resolver.resolveFunction(<FunctionPrototype>visitPrototype, null);
      if (!visitInstance || !compiler.compileFunction(visitInstance)) {
        body.push(
          module.unreachable()
        );
      } else {
        let visitSignature = visitInstance.signature;
        let visitThisType = assert(visitSignature.thisType);
        assert(
          visitSignature.parameterTypes.length == 1 &&
          visitSignature.parameterTypes[0] == Type.u32 &&
          visitSignature.returnType == Type.void &&
          instance.type.isStrictlyAssignableTo(visitThisType) // incl. implemented on super
        );
        body.push(
          module.call(visitInstance.internalName, [
            module.local_get(0, sizeTypeRef), // this
            module.local_get(1, TypeRef.I32)  // cookie
          ], TypeRef.None)
        );
      }
      hasVisitImpl = true;
    }
  }

  // Otherwise, if there is no custom visitor, generate a visitor function
  // according to class layout, visiting all _own_ managed members.
  var needsTempValue = false;
  if (!hasVisitImpl) {
    let members = instance.members;
    if (members) {
      // TODO: for (let member of members.values()) {
      for (let _values = Map_values(members), j = 0, l = _values.length; j < l; ++j) {
        let member = unchecked(_values[j]);
        if (member.kind == ElementKind.FIELD) {
          if ((<Field>member).parent === instance) {
            let fieldType = (<Field>member).type;
            if (fieldType.isManaged) {
              let fieldOffset = (<Field>member).memoryOffset;
              assert(fieldOffset >= 0);
              needsTempValue = true;
              body.push(
                // if ($2 = value) __visit($2, $1)
                module.if(
                  module.local_tee(2,
                    module.load(sizeTypeSize, false,
                      module.local_get(0, sizeTypeRef),
                      sizeTypeRef, fieldOffset
                    ),
                    false // internal
                  ),
                  module.call(visitInstance.internalName, [
                    module.local_get(2, sizeTypeRef), // value
                    module.local_get(1, TypeRef.I32)  // cookie
                  ], TypeRef.None)
                )
              );
            }
          }
        }
      }
    }
  }

  // Create the visitor function
  instance.visitRef = module.addFunction(instance.internalName + "~visit",
    createType([sizeTypeRef, TypeRef.I32]),
    TypeRef.None,
    needsTempValue ? [ sizeTypeRef ] : null,
    module.flatten(body, TypeRef.None)
  );

  // And make sure the base visitor function exists
  if (base) ensureVisitMembersOf(compiler, base);
}

/** Compiles the `__visit_members` function. */
export function compileVisitMembers(compiler: Compiler): void {
  var program = compiler.program;
  var module = compiler.module;
  var usizeType = program.options.usizeType;
  var sizeTypeRef = usizeType.toRef();
  var managedClasses = program.managedClasses;
  var visitInstance = assert(program.visitInstance);
  compiler.compileFunction(visitInstance, true); // is lazy, make sure it is compiled

  // Prepare a mapping of class names to visitor calls. Each name corresponds to
  // the respective sequential (0..N) class id.
  var names = new Array<string>();
  var cases = new Array<ExpressionRef>();
  var nextId = 0;
  for (let _keys = Map_keys(managedClasses), i = 0, k = _keys.length; i < k; ++i) {
    let instanceId = _keys[i];
    assert(instanceId == nextId++);
    let instance = assert(managedClasses.get(instanceId));
    names[i] = instance.internalName;
    if (instance.isPointerfree) {
      cases[i] = module.return();
    } else {
      cases[i] = module.block(null, [
        module.call(instance.internalName + "~visit", [
          module.local_get(0, sizeTypeRef), // this
          module.local_get(1, TypeRef.I32)  // cookie
        ], TypeRef.None),
        module.return()
      ], TypeRef.None);
      ensureVisitMembersOf(compiler, instance);
    }
  }

  // Make a br_table of the mapping, calling visitor functions by unique class id
  var current = module.block(names[0], [
    module.switch(names, "invalid",
      // load<u32>(changetype<usize>(this) - 8)
      module.load(4, false,
        sizeTypeRef == TypeRef.I64
          ? module.binary(BinaryOp.SubI64,
              module.local_get(0, sizeTypeRef),
              module.i64(8)
            )
          : module.binary(BinaryOp.SubI32,
              module.local_get(0, sizeTypeRef),
              module.i32(8) // rtId is at -8
            ),
        TypeRef.I32, 0
      )
    )
  ], TypeRef.None);

  // Wrap blocks in order
  for (let i = 0, k = names.length - 1; i < k; ++i) {
    current = module.block(names[i + 1], [
      current,
      cases[i]
    ], TypeRef.None);
  }

  // Wrap the last id in an 'invalid' block to break out of on invalid ids
  current = module.block("invalid", [
    current,
    cases[names.length - 1]
  ], TypeRef.None);

  // Add the function, executing an unreachable if breaking to 'invalid'
  module.addFunction(BuiltinNames.visit_members,
    createType([ sizeTypeRef, TypeRef.I32 ]), // this, cookie
    TypeRef.None, // => void
    null,
    module.flatten([
      current,
      module.unreachable()
    ])
  );
}

function typeToRuntimeFlags(type: Type): TypeinfoFlags {
  var flags = TypeinfoFlags.VALUE_ALIGN_0 * (1 << type.alignLog2);
  if (type.is(TypeFlags.SIGNED)) flags |= TypeinfoFlags.VALUE_SIGNED;
  if (type.is(TypeFlags.FLOAT)) flags |= TypeinfoFlags.VALUE_FLOAT;
  if (type.is(TypeFlags.NULLABLE)) flags |= TypeinfoFlags.VALUE_NULLABLE;
  if (type.isManaged) flags |= TypeinfoFlags.VALUE_MANAGED;
  return flags / TypeinfoFlags.VALUE_ALIGN_0;
}

/** Compiles runtime type information for use by stdlib. */
export function compileRTTI(compiler: Compiler): void {
  var program = compiler.program;
  var module = compiler.module;
  var managedClasses = program.managedClasses;
  var count = managedClasses.size;
  var size = 4 + 8 * count;
  var data = new Uint8Array(size);
  writeI32(count, data, 0);
  var off = 4;
  var abvInstance = program.arrayBufferViewInstance;
  var abvPrototype = abvInstance.prototype;
  var arrayPrototype = program.arrayPrototype;
  var setPrototype = program.setPrototype;
  var mapPrototype = program.mapPrototype;
  var staticArrayPrototype = program.staticArrayPrototype;
  var lastId = 0;
  // TODO: for (let [instanceId, instance] of managedClasses) {
  for (let _keys = Map_keys(managedClasses), i = 0, k = _keys.length; i < k; ++i) {
    let instanceId = unchecked(_keys[i]);
    let instance = assert(managedClasses.get(instanceId));
    assert(instanceId == lastId++);
    let flags: TypeinfoFlags = 0;
    if (instance.isPointerfree) flags |= TypeinfoFlags.POINTERFREE;
    if (instance !== abvInstance && instance.extends(abvPrototype)) {
      let valueType = instance.getArrayValueType();
      flags |= TypeinfoFlags.ARRAYBUFFERVIEW;
      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);
    } else if (instance.extends(arrayPrototype)) {
      let valueType = instance.getArrayValueType();
      flags |= TypeinfoFlags.ARRAY;
      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);
    } else if (instance.extends(setPrototype)) {
      let typeArguments = assert(instance.getTypeArgumentsTo(setPrototype));
      assert(typeArguments.length == 1);
      flags |= TypeinfoFlags.SET;
      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(typeArguments[0]);
    } else if (instance.extends(mapPrototype)) {
      let typeArguments = assert(instance.getTypeArgumentsTo(mapPrototype));
      assert(typeArguments.length == 2);
      flags |= TypeinfoFlags.MAP;
      flags |= TypeinfoFlags.KEY_ALIGN_0 * typeToRuntimeFlags(typeArguments[0]);
      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(typeArguments[1]);
    } else if (instance.extends(staticArrayPrototype)) {
      let valueType = instance.getArrayValueType();
      flags |= TypeinfoFlags.STATICARRAY;
      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);
    }
    writeI32(flags, data, off); off += 4;
    instance.rttiFlags = flags;
    let base = instance.base;
    writeI32(base ? base.id : 0, data, off); off += 4;
  }
  assert(off == size);
  var usizeType = program.options.usizeType;
  var segment = compiler.addAlignedMemorySegment(data);
  if (usizeType.size == 8) {
    let offset = segment.offset;
    module.addGlobal(BuiltinNames.rtti_base, TypeRef.I64, false, module.i64(i64_low(offset), i64_high(offset)));
  } else {
    module.addGlobal(BuiltinNames.rtti_base, TypeRef.I32, false, module.i32(i64_low(segment.offset)));
  }
}

/** Compiles a class-specific instanceof helper, checking a ref against all concrete instances. */
export function compileClassInstanceOf(compiler: Compiler, prototype: ClassPrototype): void {
  var module = compiler.module;
  var sizeTypeRef = compiler.options.sizeTypeRef;
  var instanceofInstance = assert(prototype.program.instanceofInstance);
  compiler.compileFunction(instanceofInstance);

  var stmts = new Array<ExpressionRef>();

  // if (!ref) return false
  stmts.push(
    module.if(
      module.unary(
        sizeTypeRef == TypeRef.I64
          ? UnaryOp.EqzI64
          : UnaryOp.EqzI32,
        module.local_get(0, sizeTypeRef)
      ),
      module.return(
        module.i32(0)
      )
    )
  );

  // if (__instanceof(ref, ID[i])) return true
  var instances = prototype.instances;
  if (instances !== null && instances.size > 0) {
    // TODO: for (let instance of instances.values()) {
    for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {
      let instance = unchecked(_values[i]);
      stmts.push(
        module.if(
          module.call(instanceofInstance.internalName, [
            module.local_get(0, sizeTypeRef),
            module.i32(instance.id)
          ], TypeRef.I32),
          module.return(
            module.i32(1)
          )
        )
      );
    }
  }

  // return false
  stmts.push(
    module.return(
      module.i32(0)
    )
  );

  module.addFunction(prototype.internalName + "~instanceof", sizeTypeRef, TypeRef.I32, null, module.flatten(stmts));
}

// Helpers

/** Evaluates the constant type of a type argument *or* expression. */
function evaluateConstantType(ctx: BuiltinContext): Type | null {
  var compiler = ctx.compiler;
  var operands = ctx.operands;
  var typeArguments = ctx.typeArguments;
  if (operands.length == 0) { // requires type argument
    if (!typeArguments || typeArguments.length != 1) {
      compiler.error(
        DiagnosticCode.Expected_0_type_arguments_but_got_1,
        ctx.reportNode.typeArgumentsRange, "1", typeArguments ? typeArguments.length.toString() : "0"
      );
      return null;
    }
    return typeArguments[0];
  }
  if (operands.length == 1) { // optional type argument
    if (typeArguments !== null && typeArguments.length > 0) {
      if (typeArguments.length > 1) {
        compiler.error(
          DiagnosticCode.Expected_0_type_arguments_but_got_1,
          ctx.reportNode.typeArgumentsRange, "1", typeArguments.length.toString()
        );
        return null;
      }
      compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT);
    } else {
      compiler.compileExpression(operands[0], Type.auto);
    }
    return compiler.currentType;
  }
  if (typeArguments !== null && typeArguments.length > 1) {
    compiler.error(
      DiagnosticCode.Expected_0_type_arguments_but_got_1,
      ctx.reportNode.typeArgumentsRange, "1", typeArguments.length.toString()
    );
  }
  compiler.error(
    DiagnosticCode.Expected_0_arguments_but_got_1,
    ctx.reportNode.argumentsRange, "1", operands.length.toString()
  );
  return null;
}

/** Evaluates a compile-time constant immediate offset argument.*/
function evaluateImmediateOffset(expression: Expression, compiler: Compiler): i32 {
  var module = compiler.module;
  var value: i32;
  if (compiler.options.isWasm64) {
    let expr = compiler.compileExpression(expression, Type.usize64, Constraints.CONV_IMPLICIT);
    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);
    if (precomp) {
      assert(getConstValueI64High(precomp) == 0); // TODO
      value = getConstValueI64Low(precomp);
    } else {
      compiler.error(
        DiagnosticCode.Expression_must_be_a_compile_time_constant,
        expression.range
      );
      value = -1;
    }
  } else {
    let expr = compiler.compileExpression(expression, Type.usize32, Constraints.CONV_IMPLICIT);
    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);
    if (precomp) {
      value = getConstValueI32(precomp);
    } else {
      compiler.error(
        DiagnosticCode.Expression_must_be_a_compile_time_constant,
        expression.range
      );
      value = -1;
    }
  }
  return value;
}

/** Evaluates a compile-time constant immediate align argument. */
function evaluateImmediateAlign(expression: Expression, naturalAlign: i32, compiler: Compiler): i32 {
  var align = evaluateImmediateOffset(expression, compiler);
  if (align < 0) return align;
  if (align < 1 || naturalAlign > 16) {
    compiler.error(
      DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,
      expression.range, "Alignment", "1", naturalAlign.toString()
    );
    return -1;
  }
  if (!isPowerOf2(align)) {
    compiler.error(
      DiagnosticCode._0_must_be_a_power_of_two,
      expression.range, "Alignment"
    );
    return -1;
  }
  return align;
}

/** Checks that the specified feature is enabled. */
function checkFeatureEnabled(ctx: BuiltinContext, feature: Feature): i32 {
  var compiler = ctx.compiler;
  if (!compiler.options.hasFeature(feature)) {
    compiler.error(
      DiagnosticCode.Feature_0_is_not_enabled,
      ctx.reportNode.range, featureToString(feature)
    );
    return 1;
  }
  return 0;
}

/** Checks a call with a single required type argument. Returns `1` on error. */
function checkTypeRequired(ctx: BuiltinContext, setCurrentTypeOnError: bool = false): i32 {
  var compiler = ctx.compiler;
  var typeArguments = ctx.typeArguments;
  if (typeArguments) {
    let numTypeArguments = typeArguments.length;
    if (numTypeArguments == 1) return 0;
    assert(numTypeArguments); // invalid if 0, must not be set at all instead
    if (setCurrentTypeOnError) compiler.currentType = typeArguments[0];
    compiler.error(
      DiagnosticCode.Expected_0_type_arguments_but_got_1,
      ctx.reportNode.typeArgumentsRange, "1", numTypeArguments.toString()
    );
  } else {
    compiler.error(
      DiagnosticCode.Expected_0_type_arguments_but_got_1,
      ctx.reportNode.range, "1", "0"
    );
  }
  return 1;
}

/** Checks a call with a single optional type argument. Returns `1` on error. */
function checkTypeOptional(ctx: BuiltinContext, setCurrentTypeOnError: bool = false): i32 {
  var typeArguments = ctx.typeArguments;
  if (typeArguments) {
    let compiler = ctx.compiler;
    let numTypeArguments = typeArguments.length;
    if (numTypeArguments == 1) return 0;
    assert(numTypeArguments); // invalid if 0, must not be set at all instead
    if (setCurrentTypeOnError) compiler.currentType = typeArguments[0];
    compiler.error(
      DiagnosticCode.Expected_0_type_arguments_but_got_1,
      ctx.reportNode.typeArgumentsRange, "1", numTypeArguments.toString()
    );
    return 1;
  }
  return 0;
}

/** Checks a call that is not generic. Returns `1` on error. */
function checkTypeAbsent(ctx: BuiltinContext): i32 {
  var typeArguments = ctx.typeArguments;
  if (typeArguments) {
    let prototype = ctx.prototype;
    prototype.program.error(
      DiagnosticCode.Type_0_is_not_generic,
      ctx.reportNode.typeArgumentsRange, prototype.internalName
    );
    return 1;
  }
  return 0;
}

/** Checks a call that requires a fixed number of arguments. Returns `1` on error. */
function checkArgsRequired(ctx: BuiltinContext, expected: i32): i32 {
  var operands = ctx.operands;
  if (operands.length != expected) {
    ctx.compiler.error(
      DiagnosticCode.Expected_0_arguments_but_got_1,
      ctx.reportNode.range, expected.toString(), operands.length.toString()
    );
    return 1;
  }
  return 0;
}

/** Checks a call that requires a variable number of arguments. Returns `1` on error. */
function checkArgsOptional(ctx: BuiltinContext, expectedMinimum: i32, expectedMaximum: i32): i32 {
  var operands = ctx.operands;
  var numOperands = operands.length;
  if (numOperands < expectedMinimum) {
    ctx.compiler.error(
      DiagnosticCode.Expected_at_least_0_arguments_but_got_1,
      ctx.reportNode.range, expectedMinimum.toString(), numOperands.toString()
    );
    return 1;
  } else if (numOperands > expectedMaximum) {
    ctx.compiler.error(
      DiagnosticCode.Expected_0_arguments_but_got_1,
      ctx.reportNode.range, expectedMaximum.toString(), numOperands.toString()
    );
    return 1;
  }
  return 0;
}

/** Makes an usize constant matching contextual type if reasonable. */
function contextualUsize(compiler: Compiler, value: i64, contextualType: Type): ExpressionRef {
  var module = compiler.module;
  // Check if contextual type fits
  if (contextualType != Type.auto && contextualType.isIntegerValue) {
    switch (contextualType.kind) {
      case TypeKind.I32: {
        if (i64_is_i32(value)) {
          compiler.currentType = Type.i32;
          return module.i32(i64_low(value));
        }
        break;
      }
      case TypeKind.U32: {
        if (i64_is_u32(value)) {
          compiler.currentType = Type.u32;
          return module.i32(i64_low(value));
        }
        break;
      }
      case TypeKind.I64:
      case TypeKind.U64: {
        compiler.currentType = contextualType;
        return module.i64(i64_low(value), i64_high(value));
      }
      // isize/usize falls through
      // small int is probably not intended
    }
  }
  // Default to usize
  if (compiler.options.isWasm64) {
    compiler.currentType = Type.usize64;
    return module.i64(i64_low(value), i64_high(value));
  } else {
    compiler.currentType = Type.usize32;
    assert(!i64_high(value));
    return module.i32(i64_low(value));
  }
}

'''
'''--- src/common.ts ---
/**
 * @fileoverview Common constants used by various parts of the compiler.
 * @license Apache-2.0
 */

/** Indicates traits of a {@link Node} or {@link Element}. */
export enum CommonFlags {
  /** No flags set. */
  NONE = 0,

  // Basic modifiers

  /** Has an `import` modifier. */
  IMPORT = 1 << 0,
  /** Has an `export` modifier. */
  EXPORT = 1 << 1,
  /** Has a `declare` modifier. */
  DECLARE = 1 << 2,
  /** Has a `const` modifier. */
  CONST = 1 << 3,
  /** Has a `let` modifier. */
  LET = 1 << 4,
  /** Has a `static` modifier. */
  STATIC = 1 << 5,
  /** Has a `readonly` modifier. */
  READONLY = 1 << 6,
  /** Has an `abstract` modifier. */
  ABSTRACT = 1 << 7,
  /** Has a `public` modifier. */
  PUBLIC = 1 << 8,
  /** Has a `private` modifier. */
  PRIVATE = 1 << 9,
  /** Has a `protected` modifier. */
  PROTECTED = 1 << 10,
  /** Has a `get` modifier. */
  GET = 1 << 11,
  /** Has a `set` modifier. */
  SET = 1 << 12,
  /** Has a definite assignment assertion `!` as in `x!: i32;`. */
  DEFINITELY_ASSIGNED = 1 << 13,

  // Extended modifiers usually derived from basic modifiers

  /** Is ambient, that is either declared or nested in a declared element. */
  AMBIENT = 1 << 14,
  /** Is generic. */
  GENERIC = 1 << 15,
  /** Is part of a generic context. */
  GENERIC_CONTEXT = 1 << 16,
  /** Is an instance member. */
  INSTANCE = 1 << 17,
  /** Is a constructor. */
  CONSTRUCTOR = 1 << 18,
  /** Is a module export. */
  MODULE_EXPORT = 1 << 19,
  /** Is a module import. */
  MODULE_IMPORT = 1 << 20,

  // Compilation states

  /** Is resolved. */
  RESOLVED = 1 << 21,
  /** Is compiled. */
  COMPILED = 1 << 22,
  /** Did error. */
  ERRORED = 1 << 23,
  /** Has a constant value and is therefore inlined. */
  INLINED = 1 << 24,
  /** Is scoped. */
  SCOPED = 1 << 25,
  /** Is a stub. */
  STUB = 1 << 26,
  /** Is a virtual method. */
  VIRTUAL = 1 << 27,
  /** Is (part of) a closure. */
  CLOSURE = 1 << 28,

  // Other

  /** Is quoted. */
  QUOTED = 1 << 29
}

/** Path delimiter inserted between file system levels. */
export const PATH_DELIMITER = "/";
/** Substitution used to indicate the parent directory. */
export const PARENT_SUBST = "..";
/** Function name prefix used for getters. */
export const GETTER_PREFIX = "get:";
/** Function name prefix used for setters. */
export const SETTER_PREFIX = "set:";
/** Delimiter used between class names and instance members. */
export const INSTANCE_DELIMITER = "#";
/** Delimiter used between class and namespace names and static members. */
export const STATIC_DELIMITER = ".";
/** Delimiter used between a function and its inner elements. */
export const INNER_DELIMITER = "~";
/** Substitution used to indicate a library directory. */
export const LIBRARY_SUBST = "~lib";
/** Library directory prefix. */
export const LIBRARY_PREFIX = LIBRARY_SUBST + PATH_DELIMITER;
/** Path index suffix. */
export const INDEX_SUFFIX = PATH_DELIMITER + "index";
/** Stub function delimiter. */
export const STUB_DELIMITER = "@";

/** Common names. */
export namespace CommonNames {
  // special
  export const EMPTY = "";
  // types
  export const i8 = "i8";
  export const i16 = "i16";
  export const i32 = "i32";
  export const i64 = "i64";
  export const isize = "isize";
  export const u8 = "u8";
  export const u16 = "u16";
  export const u32 = "u32";
  export const u64 = "u64";
  export const usize = "usize";
  export const bool = "bool";
  export const f32 = "f32";
  export const f64 = "f64";
  export const v128 = "v128";
  export const funcref = "funcref";
  export const externref = "externref";
  export const anyref = "anyref";
  export const eqref = "eqref";
  export const i31ref = "i31ref";
  export const dataref = "dataref";
  export const i8x16 = "i8x16";
  export const u8x16 = "u8x16";
  export const i16x8 = "i16x8";
  export const u16x8 = "u16x8";
  export const i32x4 = "i32x4";
  export const u32x4 = "u32x4";
  export const i64x2 = "i64x2";
  export const u64x2 = "u64x2";
  export const f32x4 = "f32x4";
  export const f64x2 = "f64x2";
  export const void_ = "void";
  export const number = "number";
  export const boolean = "boolean";
  export const string = "string";
  export const native = "native";
  export const indexof = "indexof";
  export const valueof = "valueof";
  export const returnof = "returnof";
  export const nonnull = "nonnull";
  // aliases
  export const null_ = "null";
  export const true_ = "true";
  export const false_ = "false";
  // objects
  export const this_ = "this";
  export const super_ = "super";
  export const constructor = "constructor";
  // constants
  export const ASC_TARGET = "ASC_TARGET";
  export const ASC_NO_TREESHAKING = "ASC_NO_TREESHAKING";
  export const ASC_NO_ASSERT = "ASC_NO_ASSERT";
  export const ASC_MEMORY_BASE = "ASC_MEMORY_BASE";
  export const ASC_TABLE_BASE = "ASC_TABLE_BASE";
  export const ASC_OPTIMIZE_LEVEL = "ASC_OPTIMIZE_LEVEL";
  export const ASC_SHRINK_LEVEL = "ASC_SHRINK_LEVEL";
  export const ASC_LOW_MEMORY_LIMIT = "ASC_LOW_MEMORY_LIMIT";
  export const ASC_EXPORT_RUNTIME = "ASC_EXPORT_RUNTIME";
  export const ASC_WASI = "ASC_WASI";
  export const ASC_FEATURE_SIGN_EXTENSION = "ASC_FEATURE_SIGN_EXTENSION";
  export const ASC_FEATURE_MUTABLE_GLOBALS = "ASC_FEATURE_MUTABLE_GLOBALS";
  export const ASC_FEATURE_NONTRAPPING_F2I = "ASC_FEATURE_NONTRAPPING_F2I";
  export const ASC_FEATURE_BULK_MEMORY = "ASC_FEATURE_BULK_MEMORY";
  export const ASC_FEATURE_SIMD = "ASC_FEATURE_SIMD";
  export const ASC_FEATURE_THREADS = "ASC_FEATURE_THREADS";
  export const ASC_FEATURE_EXCEPTION_HANDLING = "ASC_FEATURE_EXCEPTION_HANDLING";
  export const ASC_FEATURE_TAIL_CALLS = "ASC_FEATURE_TAIL_CALLS";
  export const ASC_FEATURE_REFERENCE_TYPES = "ASC_FEATURE_REFERENCE_TYPES";
  export const ASC_FEATURE_MULTI_VALUE = "ASC_FEATURE_MULTI_VALUE";
  export const ASC_FEATURE_GC = "ASC_FEATURE_GC";
  export const ASC_FEATURE_MEMORY64 = "ASC_FEATURE_MEMORY64";
  export const ASC_VERSION_MAJOR = "ASC_VERSION_MAJOR";
  export const ASC_VERSION_MINOR = "ASC_VERSION_MINOR";
  export const ASC_VERSION_PATCH = "ASC_VERSION_PATCH";
  // classes
  export const I8 = "I8";
  export const I16 = "I16";
  export const I32 = "I32";
  export const I64 = "I64";
  export const Isize = "Isize";
  export const U8 = "U8";
  export const U16 = "U16";
  export const U32 = "U32";
  export const U64 = "U64";
  export const Usize = "Usize";
  export const Bool = "Bool";
  export const F32 = "F32";
  export const F64 = "F64";
  export const V128 = "V128";
  export const Funcref = "Funcref";
  export const Externref = "Externref";
  export const Anyref = "Anyref";
  export const Eqref = "Eqref";
  export const I31ref = "I31ref";
  export const Dataref = "Dataref";
  export const String = "String";
  export const Object = "Object";
  export const Array = "Array";
  export const StaticArray = "StaticArray";
  export const Set = "Set";
  export const Map = "Map";
  export const Function = "Function";
  export const ArrayBufferView = "ArrayBufferView";
  export const ArrayBuffer = "ArrayBuffer";
  export const Math = "Math";
  export const Mathf = "Mathf";
  export const NativeMath = "NativeMath";
  export const NativeMathf = "NativeMathf";
  export const Int8Array = "Int8Array";
  export const Int16Array = "Int16Array";
  export const Int32Array = "Int32Array";
  export const Int64Array = "Int64Array";
  export const Uint8Array = "Uint8Array";
  export const Uint8ClampedArray = "Uint8ClampedArray";
  export const Uint16Array = "Uint16Array";
  export const Uint32Array = "Uint32Array";
  export const Uint64Array = "Uint64Array";
  export const Float32Array = "Float32Array";
  export const Float64Array = "Float64Array";
  export const TemplateStringsArray = "TemplateStringsArray";
  export const Error = "Error";
  // runtime
  export const abort = "abort";
  export const trace = "trace";
  export const seed = "seed";
  export const pow = "pow";
  export const ipow32 = "ipow32";
  export const ipow64 = "ipow64";
  export const mod = "mod";
  export const alloc = "__alloc";
  export const realloc = "__realloc";
  export const free = "__free";
  export const new_ = "__new";
  export const renew = "__renew";
  export const link = "__link";
  export const collect = "__collect";
  export const typeinfo = "__typeinfo";
  export const instanceof_ = "__instanceof";
  export const visit = "__visit";
  export const newBuffer = "__newBuffer";
  export const newArray = "__newArray";
  export const BLOCK = "~lib/rt/common/BLOCK";
  export const OBJECT = "~lib/rt/common/OBJECT";
}

// shared
export { Feature, featureToString } from "../std/assembly/shared/feature";
export { Target } from "../std/assembly/shared/target";
export { Typeinfo, TypeinfoFlags } from "../std/assembly/shared/typeinfo";

'''
'''--- src/compiler.ts ---
/**
 * @fileoverview The AssemblyScript compiler.
 * @license Apache-2.0
 */

import {
  BuiltinNames,
  BuiltinContext,
  builtins,
  function_builtins,
  compileVisitGlobals,
  compileVisitMembers,
  compileRTTI,
  compileClassInstanceOf
} from "./builtins";

import {
  DiagnosticCode,
  DiagnosticEmitter
} from "./diagnostics";

import {
  Module,
  MemorySegment,
  ExpressionRef,
  UnaryOp,
  BinaryOp,
  RefIsOp,
  TypeRef,
  FunctionRef,
  ExpressionId,
  GlobalRef,
  FeatureFlags,
  Index,
  getExpressionId,
  getExpressionType,
  getConstValueI32,
  getConstValueI64Low,
  getConstValueI64High,
  getConstValueF32,
  getConstValueF64,
  getBlockChildCount,
  getBlockChildAt,
  getBlockName,
  needsExplicitUnreachable,
  getLocalSetValue,
  getGlobalGetName,
  isGlobalMutable,
  createType,
  getSideEffects,
  SideEffects,
  SwitchBuilder,
  ExpressionRunnerFlags,
  isConstZero
} from "./module";

import {
  CommonFlags,
  INSTANCE_DELIMITER,
  STATIC_DELIMITER,
  GETTER_PREFIX,
  SETTER_PREFIX,
  INDEX_SUFFIX,
  CommonNames,
  Feature,
  Target,
  featureToString
} from "./common";

import {
  Program,
  ClassPrototype,
  Class,
  Element,
  ElementKind,
  Enum,
  Field,
  FunctionPrototype,
  Function,
  Global,
  Local,
  EnumValue,
  Property,
  VariableLikeElement,
  ConstantValueKind,
  OperatorKind,
  DecoratorFlags,
  PropertyPrototype,
  IndexSignature,
  File,
  mangleInternalName,
  DeclaredElement
} from "./program";

import {
  FlowFlags,
  Flow,
  LocalFlags,
  FieldFlags,
  ConditionKind,
  findUsedLocals
} from "./flow";

import {
  Resolver,
  ReportMode
} from "./resolver";

import {
  Token,
  Range,
  operatorTokenToString
} from "./tokenizer";

import {
  Node,
  NodeKind,
  DecoratorKind,
  AssertionKind,
  SourceKind,
  FunctionTypeNode,

  Statement,
  BlockStatement,
  BreakStatement,
  ClassDeclaration,
  ContinueStatement,
  DeclarationStatement,
  DoStatement,
  EmptyStatement,
  EnumDeclaration,
  ExportDefaultStatement,
  ExportStatement,
  ExpressionStatement,
  FieldDeclaration,
  ForStatement,
  ForOfStatement,
  FunctionDeclaration,
  IfStatement,
  ImportStatement,
  InstanceOfExpression,
  NamespaceDeclaration,
  ReturnStatement,
  SwitchStatement,
  ThrowStatement,
  TryStatement,
  VariableStatement,
  VoidStatement,
  WhileStatement,

  Expression,
  AssertionExpression,
  BinaryExpression,
  CallExpression,
  CommaExpression,
  ElementAccessExpression,
  FloatLiteralExpression,
  FunctionExpression,
  IdentifierExpression,
  IntegerLiteralExpression,
  LiteralExpression,
  LiteralKind,
  NewExpression,
  ObjectLiteralExpression,
  ParenthesizedExpression,
  PropertyAccessExpression,
  TernaryExpression,
  ArrayLiteralExpression,
  StringLiteralExpression,
  TemplateLiteralExpression,
  UnaryPostfixExpression,
  UnaryPrefixExpression,
  CompiledExpression,

  TypeNode,
  NamedTypeNode,

  findDecorator,
  isTypeOmitted
} from "./ast";

import {
  Type,
  TypeKind,
  TypeFlags,
  Signature,
  typesToRefs
} from "./types";

import {
  writeI8,
  writeI16,
  writeI32,
  writeI64,
  writeF32,
  writeF64,
  uniqueMap,
  isPowerOf2,
  v128_zero,
  readI32
} from "./util";

import {
  RtraceMemory
} from "./passes/rtrace";

import {
  ShadowStackPass
} from "./passes/shadowstack";

/** Compiler options. */
export class Options {

  /** WebAssembly target. Defaults to {@link Target.WASM32}. */
  target: Target = Target.WASM32;
  /** If true, replaces assertions with nops. */
  noAssert: bool = false;
  /** It true, exports the memory to the embedder. */
  exportMemory: bool = true;
  /** If true, imports the memory provided by the embedder. */
  importMemory: bool = false;
  /** Initial memory size, in pages. */
  initialMemory: u32 = 0;
  /** Maximum memory size, in pages. */
  maximumMemory: u32 = 0;
  /** If true, memory is declared as shared. */
  sharedMemory: bool = false;
  /** If true, imports the function table provided by the embedder. */
  importTable: bool = false;
  /** If true, exports the function table. */
  exportTable: bool = false;
  /** If true, generates information necessary for source maps. */
  sourceMap: bool = false;
  /** If true, generates an explicit start function. */
  explicitStart: bool = false;
  /** Static memory start offset. */
  memoryBase: u32 = 0;
  /** Static table start offset. */
  tableBase: u32 = 0;
  /** Global aliases, mapping alias names as the key to internal names to be aliased as the value. */
  globalAliases: Map<string,string> | null = null;
  /** Features to activate by default. These are the finished proposals. */
  features: Feature = Feature.MUTABLE_GLOBALS | Feature.SIGN_EXTENSION;
  /** If true, disallows unsafe features in user code. */
  noUnsafe: bool = false;
  /** If true, enables pedantic diagnostics. */
  pedantic: bool = false;
  /** Indicates a very low (<64k) memory limit. */
  lowMemoryLimit: u32 = 0;
  /** If true, exports the runtime helpers. */
  exportRuntime: bool = false;
  /** Stack size in bytes, if using a stack. */
  stackSize: i32 = 0;
  /** Semantic major bundle version from root package.json */
  bundleMajorVersion: i32 = 0;
  /** Semantic minor bundle version from root package.json */
  bundleMinorVersion: i32 = 0;
  /** Semantic patch bundle version from root package.json */
  bundlePatchVersion: i32 = 0;

  /** Hinted optimize level. Not applied by the compiler itself. */
  optimizeLevelHint: i32 = 0;
  /** Hinted shrink level. Not applied by the compiler itself. */
  shrinkLevelHint: i32 = 0;

  /** Tests if the target is WASM64 or, otherwise, WASM32. */
  get isWasm64(): bool {
    return this.target == Target.WASM64;
  }

  /** Gets the unsigned size type matching the target. */
  get usizeType(): Type {
    return this.target == Target.WASM64 ? Type.usize64 : Type.usize32;
  }

  /** Gets the signed size type matching the target. */
  get isizeType(): Type {
    return this.target == Target.WASM64 ? Type.isize64 : Type.isize32;
  }

  /** Gets the size type reference matching the target. */
  get sizeTypeRef(): TypeRef {
    return this.target == Target.WASM64 ? TypeRef.I64 : TypeRef.I32;
  }

  /** Gets if any optimizations will be performed. */
  get willOptimize(): bool {
    return this.optimizeLevelHint > 0 || this.shrinkLevelHint > 0;
  }

  /** Tests if a specific feature is activated. */
  hasFeature(feature: Feature): bool {
    return (this.features & feature) != 0;
  }
}

/** Various constraints in expression compilation. */
export const enum Constraints {
  NONE = 0,

  /** Must implicitly convert to the target type. */
  CONV_IMPLICIT = 1 << 0,
  /** Must explicitly convert to the target type. */
  CONV_EXPLICIT = 1 << 1,
  /** Must wrap small integer values to match the target type. */
  MUST_WRAP = 1 << 2,

  /** Indicates that the value will be dropped immediately. */
  WILL_DROP = 1 << 3,
  /** Indicates that static data is preferred. */
  PREFER_STATIC = 1 << 4,
  /** Indicates that the value will become `this` of a property access or instance call. */
  IS_THIS = 1 << 5
}

/** Runtime features to be activated by the compiler. */
export const enum RuntimeFeatures {
  NONE = 0,
  /** Requires data setup. */
  DATA = 1 << 0,
  /** Requires a stack. */
  STACK = 1 << 1,
  /** Requires heap setup. */
  HEAP = 1 << 2,
  /** Requires runtime type information setup. */
  RTTI = 1 << 3,
  /** Requires the built-in globals visitor. */
  visitGlobals = 1 << 4,
  /** Requires the built-in members visitor. */
  visitMembers = 1 << 5,
  /** Requires the setArgumentsLength export. */
  setArgumentsLength = 1 << 6
}

/** Exported names of compiler-generated elements. */
export namespace ExportNames {
  /** Name of the explicit start function, if applicable. */
  export const start = "_start"; // match WASI
  /** Name of the argumentsLength varargs helper global. */
  export const argumentsLength = "__argumentsLength";
  /** Name of the alternative argumentsLength setter function. */
  export const setArgumentsLength = "__setArgumentsLength";
  /** Name of the memory instance, if exported. */
  export const memory = "memory";
  /** Name of the table instance, if exported. */
  export const table = "table";
}

/** Functions to export if `--exportRuntime` is set. */
const runtimeFunctions = [ "__new", "__pin", "__unpin", "__collect" ];
/** Globals to export if `--exportRuntime` is set. */
const runtimeGlobals = [ "__rtti_base" ];

/** Compiler interface. */
export class Compiler extends DiagnosticEmitter {

  /** Program reference. */
  program: Program;
  /** Resolver reference. */
  get resolver(): Resolver { return this.program.resolver; }
  /** Provided options. */
  get options(): Options { return this.program.options; }
  /** Module instance being compiled. */
  module: Module;

  /** Current control flow. */
  currentFlow: Flow;
  /** Current parent element if not a function, i.e. an enum or namespace. */
  currentParent: Element | null = null;
  /** Current type in compilation. */
  currentType: Type = Type.void;
  /** Start function statements. */
  currentBody: ExpressionRef[];
  /** Counting memory offset. */
  memoryOffset: i64;
  /** Memory segments being compiled. */
  memorySegments: MemorySegment[] = [];
  /** Map of already compiled static string segments. */
  stringSegments: Map<string,MemorySegment> = new Map();
  /** Function table being compiled. First elem is blank. */
  functionTable: Function[] = [];
  /** Arguments length helper global. */
  builtinArgumentsLength: GlobalRef = 0;
  /** Requires runtime features. */
  runtimeFeatures: RuntimeFeatures = RuntimeFeatures.NONE;
  /** Current inline functions stack. */
  inlineStack: Function[] = [];
  /** Lazily compiled functions. */
  lazyFunctions: Set<Function> = new Set();
  /** Pending class-specific instanceof helpers. */
  pendingClassInstanceOf: Set<ClassPrototype> = new Set();
  /** Functions potentially involving a virtual call. */
  virtualCalls: Set<Function> = new Set();
  /** Elements currently undergoing compilation. */
  pendingElements: Set<Element> = new Set();
  /** Elements, that are module exports, already processed */
  doneModuleExports: Set<Element> = new Set();
  /** Shadow stack reference. */
  shadowStack!: ShadowStackPass;

  /** Compiles a {@link Program} to a {@link Module} using the specified options. */
  static compile(program: Program): Module {
    return new Compiler(program).compile();
  }

  /** Constructs a new compiler for a {@link Program} using the specified options. */
  constructor(program: Program) {
    super(program.diagnostics);
    this.program = program;
    var options = program.options;
    var module = Module.create(options.stackSize > 0, options.sizeTypeRef);
    this.module = module;
    if (options.memoryBase) {
      this.memoryOffset = i64_new(options.memoryBase);
      module.setLowMemoryUnused(false);
    } else {
      if (!options.lowMemoryLimit && options.optimizeLevelHint >= 2) {
        this.memoryOffset = i64_new(1024);
        module.setLowMemoryUnused(true);
      } else {
        this.memoryOffset = i64_new(8);
        module.setLowMemoryUnused(false);
      }
    }
    var featureFlags: FeatureFlags = 0;
    if (options.hasFeature(Feature.SIGN_EXTENSION)) featureFlags |= FeatureFlags.SignExt;
    if (options.hasFeature(Feature.MUTABLE_GLOBALS)) featureFlags |= FeatureFlags.MutableGloabls;
    if (options.hasFeature(Feature.NONTRAPPING_F2I)) featureFlags |= FeatureFlags.NontrappingFPToInt;
    if (options.hasFeature(Feature.BULK_MEMORY)) featureFlags |= FeatureFlags.BulkMemory;
    if (options.hasFeature(Feature.SIMD)) featureFlags |= FeatureFlags.SIMD128;
    if (options.hasFeature(Feature.THREADS)) featureFlags |= FeatureFlags.Atomics;
    if (options.hasFeature(Feature.EXCEPTION_HANDLING)) featureFlags |= FeatureFlags.ExceptionHandling;
    if (options.hasFeature(Feature.TAIL_CALLS)) featureFlags |= FeatureFlags.TailCall;
    if (options.hasFeature(Feature.REFERENCE_TYPES)) featureFlags |= FeatureFlags.ReferenceTypes;
    if (options.hasFeature(Feature.MULTI_VALUE)) featureFlags |= FeatureFlags.MultiValue;
    if (options.hasFeature(Feature.GC)) featureFlags |= FeatureFlags.GC;
    if (options.hasFeature(Feature.MEMORY64)) featureFlags |= FeatureFlags.Memory64;
    module.setFeatures(featureFlags);

    // set up the main start function
    var startFunctionInstance = program.makeNativeFunction(BuiltinNames.start, new Signature(program, [], Type.void));
    startFunctionInstance.internalName = BuiltinNames.start;
    this.currentFlow = startFunctionInstance.flow;
    this.currentBody = new Array<ExpressionRef>();
    this.shadowStack = new ShadowStackPass(this);
  }

  /** Performs compilation of the underlying {@link Program} to a {@link Module}. */
  compile(): Module {
    var options = this.options;
    var module = this.module;
    var program = this.program;
    var hasShadowStack = options.stackSize > 0; // implies runtime=incremental

    // initialize lookup maps, built-ins, imports, exports, etc.
    this.program.initialize();

    // obtain the main start function
    var startFunctionInstance = this.currentFlow.actualFunction;
    assert(startFunctionInstance.internalName == BuiltinNames.start);
    var startFunctionBody = this.currentBody;
    assert(startFunctionBody.length == 0);

    // add mutable data, heap and rtti offset dummies
    if (options.isWasm64) {
      module.addGlobal(BuiltinNames.data_end, TypeRef.I64, true, module.i64(0));
      module.addGlobal(BuiltinNames.heap_base, TypeRef.I64, true, module.i64(0));
      module.addGlobal(BuiltinNames.rtti_base, TypeRef.I64, true, module.i64(0));
    } else {
      module.addGlobal(BuiltinNames.data_end, TypeRef.I32, true, module.i32(0));
      module.addGlobal(BuiltinNames.heap_base, TypeRef.I32, true, module.i32(0));
      module.addGlobal(BuiltinNames.rtti_base, TypeRef.I32, true, module.i32(0));
    }

    // compile entry file(s) while traversing reachable elements
    var files = program.filesByName;
    // TODO: for (let file of files.values()) {
    for (let _values = Map_values(files), i = 0, k = _values.length; i < k; ++i) {
      let file = unchecked(_values[i]);
      if (file.source.sourceKind == SourceKind.USER_ENTRY) {
        this.compileFile(file);
        this.compileExports(file);
      }
    }

    // set up module exports
    // TODO: for (let file of this.program.filesByName.values()) {
    for (let _values = Map_values(this.program.filesByName), i = 0, k = _values.length; i < k; ++i) {
      let file = unchecked(_values[i]);
      if (file.source.sourceKind == SourceKind.USER_ENTRY) this.ensureModuleExports(file);
    }

    // compile and export runtime if requested
    if (this.options.exportRuntime) {
      for (let i = 0, k = runtimeFunctions.length; i < k; ++i) {
        let name = runtimeFunctions[i];
        let instance = program.requireFunction(name);
        if (this.compileFunction(instance) && !module.hasExport(name)) {
          module.addFunctionExport(instance.internalName, name);
        }
      }
      for (let i = 0, k = runtimeGlobals.length; i < k; ++i) {
        let name = runtimeGlobals[i];
        let instance = program.requireGlobal(name);
        if (this.compileGlobal(instance) && !module.hasExport(name)) {
          module.addGlobalExport(instance.internalName, name);
        }
      }
    }

    // compile lazy functions
    var lazyFunctions = this.lazyFunctions;
    do {
      let functionsToCompile = new Array<Function>();
      // TODO: for (let instance of lazyLibraryFunctions) {
      for (let _values = Set_values(lazyFunctions), i = 0, k = _values.length; i < k; ++i) {
        let instance = unchecked(_values[i]);
        functionsToCompile.push(instance);
      }
      lazyFunctions.clear();
      for (let i = 0, k = functionsToCompile.length; i < k; ++i) {
        this.compileFunction(unchecked(functionsToCompile[i]), true);
      }
    } while (lazyFunctions.size);

    // compile pending class-specific instanceof helpers
    // TODO: for (let prototype of this.pendingClassInstanceOf.values()) {
    for (let _values = Set_values(this.pendingClassInstanceOf), i = 0, k = _values.length; i < k; ++i) {
      let prototype = unchecked(_values[i]);
      compileClassInstanceOf(this, prototype);
    }

    // set up virtual lookup tables
    var functionTable = this.functionTable;
    for (let i = 0, k = functionTable.length; i < k; ++i) {
      let instance = functionTable[i];
      if (instance.is(CommonFlags.VIRTUAL)) {
        assert(instance.is(CommonFlags.INSTANCE));
        functionTable[i] = this.ensureVirtualStub(instance); // incl. varargs
        this.finalizeVirtualStub(instance);
      } else if (instance.signature.requiredParameters < instance.signature.parameterTypes.length) {
        functionTable[i] = this.ensureVarargsStub(instance);
      }
    }
    var virtualCalls = this.virtualCalls;
    while (virtualCalls.size) {
      // finalizing a stub may discover more virtual calls, so do this in a loop
      for (let _values = Set_values(virtualCalls), i = 0, k = _values.length; i < k; ++i) {
        let instance = unchecked(_values[i]);
        this.finalizeVirtualStub(instance);
        virtualCalls.delete(instance);
      }
    }

    // finalize runtime features
    module.removeGlobal(BuiltinNames.rtti_base);
    if (this.runtimeFeatures & RuntimeFeatures.RTTI) compileRTTI(this);
    if (this.runtimeFeatures & RuntimeFeatures.visitGlobals) compileVisitGlobals(this);
    if (this.runtimeFeatures & RuntimeFeatures.visitMembers) compileVisitMembers(this);

    var memoryOffset = i64_align(this.memoryOffset, options.usizeType.byteSize);

    // finalize data
    module.removeGlobal(BuiltinNames.data_end);
    if ((this.runtimeFeatures & RuntimeFeatures.DATA) != 0 || hasShadowStack) {
      if (options.isWasm64) {
        module.addGlobal(BuiltinNames.data_end, TypeRef.I64, false,
          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))
        );
      } else {
        module.addGlobal(BuiltinNames.data_end, TypeRef.I32, false,
          module.i32(i64_low(memoryOffset))
        );
      }
    }

    // finalize stack (grows down from __heap_base to __data_end)
    module.removeGlobal(BuiltinNames.stack_pointer);
    if ((this.runtimeFeatures & RuntimeFeatures.STACK) != 0 || hasShadowStack) {
      memoryOffset = i64_align(
        i64_add(memoryOffset, i64_new(options.stackSize)),
        options.usizeType.byteSize
      );
      if (options.isWasm64) {
        module.addGlobal(BuiltinNames.stack_pointer, TypeRef.I64, true,
          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))
        );
      } else {
        module.addGlobal(BuiltinNames.stack_pointer, TypeRef.I32, true,
          module.i32(i64_low(memoryOffset))
        );
      }
    }

    // finalize heap
    module.removeGlobal(BuiltinNames.heap_base);
    if ((this.runtimeFeatures & RuntimeFeatures.HEAP) != 0 || hasShadowStack) {
      if (options.isWasm64) {
        module.addGlobal(BuiltinNames.heap_base, TypeRef.I64, false,
          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))
        );
      } else {
        module.addGlobal(BuiltinNames.heap_base, TypeRef.I32, false,
          module.i32(i64_low(memoryOffset))
        );
      }
    }

    this.memoryOffset = memoryOffset;

    // check that we didn't exceed lowMemoryLimit already
    var lowMemoryLimit32 = this.options.lowMemoryLimit;
    if (lowMemoryLimit32) {
      let lowMemoryLimit = i64_new(lowMemoryLimit32 & ~15);
      if (i64_gt(memoryOffset, lowMemoryLimit)) {
        this.error(
          DiagnosticCode.Low_memory_limit_exceeded_by_static_data_0_1,
          null, i64_to_string(memoryOffset), i64_to_string(lowMemoryLimit)
        );
      }
    }

    // set up memory
    var initialPages: u32 = 0;
    if (this.options.memoryBase /* is specified */ || this.memorySegments.length) {
      initialPages = u32(i64_low(i64_shr_u(i64_align(memoryOffset, 0x10000), i64_new(16))));
    }
    if (options.initialMemory) {
      if (options.initialMemory < initialPages) {
        this.error(
          DiagnosticCode.Module_requires_at_least_0_pages_of_initial_memory,
          null,
          initialPages.toString()
        );
      } else {
        initialPages = options.initialMemory;
      }
    }
    var maximumPages = Module.UNLIMITED_MEMORY;
    if (options.maximumMemory) {
      if (options.maximumMemory < initialPages) {
        this.error(
          DiagnosticCode.Module_requires_at_least_0_pages_of_maximum_memory,
          null,
          initialPages.toString()
        );
      } else {
        maximumPages = options.maximumMemory;
      }
    }
    var isSharedMemory = false;
    if (options.sharedMemory) {
      isSharedMemory = true;
      if (!options.maximumMemory) {
        this.error(
          DiagnosticCode.Shared_memory_requires_maximum_memory_to_be_defined,
          null
        );
        isSharedMemory = false;
      }
      if (!options.hasFeature(Feature.THREADS)) {
        this.error(
          DiagnosticCode.Shared_memory_requires_feature_threads_to_be_enabled,
          null
        );
        isSharedMemory = false;
      }
    }
    module.setMemory(
      initialPages,
      maximumPages,
      this.memorySegments,
      options.target,
      options.exportMemory ? ExportNames.memory : null,
      isSharedMemory
    );

    // import memory if requested (default memory is named '0' by Binaryen)
    if (options.importMemory) module.addMemoryImport("0", "env", "memory", isSharedMemory);

    // import and/or export table if requested (default table is named '0' by Binaryen)
    if (options.importTable) {
      module.addTableImport("0", "env", "table");
      if (options.pedantic && options.willOptimize) {
        this.pedantic(
          DiagnosticCode.Importing_the_table_disables_some_indirect_call_optimizations,
          null
        );
      }
    }
    if (options.exportTable) {
      module.addTableExport("0", ExportNames.table);
      if (options.pedantic && options.willOptimize) {
        this.pedantic(
          DiagnosticCode.Exporting_the_table_disables_some_indirect_call_optimizations,
          null
        );
      }
    }

    // set up function table (first elem is blank)
    var tableBase = this.options.tableBase;
    if (!tableBase) tableBase = 1; // leave first elem blank
    var functionTableNames = new Array<string>(functionTable.length);
    for (let i = 0, k = functionTable.length; i < k; ++i) {
      functionTableNames[i] = functionTable[i].internalName;
    }
    module.addFunctionTable("0", tableBase + functionTable.length, Module.UNLIMITED_TABLE, functionTableNames, module.i32(tableBase));

    // expose the arguments length helper if there are varargs exports
    if (this.runtimeFeatures & RuntimeFeatures.setArgumentsLength) {
      module.addFunction(BuiltinNames.setArgumentsLength, TypeRef.I32, TypeRef.None, null,
        module.global_set(this.ensureArgumentsLength(), module.local_get(0, TypeRef.I32))
      );
      module.addFunctionExport(BuiltinNames.setArgumentsLength, ExportNames.setArgumentsLength);
    }

    // NOTE: no more element compiles from here. may go to the start function!

    // compile the start function if not empty or if explicitly requested
    var startIsEmpty = !startFunctionBody.length;
    var explicitStart = program.isWasi || options.explicitStart;
    if (!startIsEmpty || explicitStart) {
      let signature = startFunctionInstance.signature;
      if (!startIsEmpty && explicitStart) {
        module.addGlobal(BuiltinNames.started, TypeRef.I32, true, module.i32(0));
        startFunctionBody.unshift(
          module.global_set(BuiltinNames.started, module.i32(1))
        );
        startFunctionBody.unshift(
          module.if(
            module.global_get(BuiltinNames.started, TypeRef.I32),
            module.return()
          )
        );
      }
      let funcRef = module.addFunction(
        startFunctionInstance.internalName,
        signature.paramRefs,
        signature.resultRefs,
        typesToRefs(startFunctionInstance.additionalLocals),
        module.flatten(startFunctionBody)
      );
      startFunctionInstance.finalize(module, funcRef);
      if (!explicitStart) module.setStart(funcRef);
      else module.addFunctionExport(startFunctionInstance.internalName, ExportNames.start);
    }

    // Run custom passes
    if (hasShadowStack) {
      this.shadowStack.walkModule();
    }
    if (program.lookup("ASC_RTRACE") != null) {
      new RtraceMemory(this).walkModule();
    }

    return module;
  }

  // === Exports ==================================================================================

  /** Applies the respective module exports for the specified file. */
  private ensureModuleExports(file: File): void {
    var exports = file.exports;
    if (exports) {
      // TODO: for (let [elementName, element] of exports) {
      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {
        let elementName = unchecked(_keys[i]);
        let element = assert(exports.get(elementName));
        this.ensureModuleExport(elementName, element);
      }
    }
    var exportsStar = file.exportsStar;
    if (exportsStar)  {
      for (let i = 0, k = exportsStar.length; i < k; ++i) {
        this.ensureModuleExports(exportsStar[i]);
      }
    }
  }

  /** Applies the respective module export(s) for the specified element. */
  private ensureModuleExport(name: string, element: Element, prefix: string = ""): void {
    var module = this.module;
    switch (element.kind) {

      // traverse instances
      case ElementKind.FUNCTION_PROTOTYPE: {
        let functionPrototype = <FunctionPrototype>element;
        let functionInstances = functionPrototype.instances;
        if (functionInstances !== null && functionInstances.size > 0) {
          // TODO: for (let instance of instances.values()) {
          for (let _values = Map_values(functionInstances), i = 0, k = _values.length; i < k; ++i) {
            let instance = unchecked(_values[i]);
            let instanceName = name;
            if (instance.is(CommonFlags.GENERIC)) {
              let fullName = instance.internalName;
              instanceName += fullName.substring(fullName.lastIndexOf("<"));
            }
            this.ensureModuleExport(instanceName, instance, prefix);
          }
        } else if (functionPrototype.is(CommonFlags.GENERIC)) {
          if (this.options.pedantic) {
            this.pedantic(
              DiagnosticCode.Exported_generic_function_or_class_has_no_concrete_instances,
              functionPrototype.identifierNode.range
            );
          }
        }
        break;
      }
      case ElementKind.CLASS_PROTOTYPE: {
        let classPrototype = <ClassPrototype>element;
        let classInstances = classPrototype.instances;
        if (classInstances !== null && classInstances.size > 0) {
          // TODO: for (let instance of instances.values()) {
          for (let _values = Map_values(classInstances), i = 0, k = _values.length; i < k; ++i) {
            let instance = unchecked(_values[i]);
            let instanceName = name;
            if (instance.is(CommonFlags.GENERIC)) {
              let fullName = instance.internalName;
              instanceName += fullName.substring(fullName.lastIndexOf("<"));
            }
            this.ensureModuleExport(instanceName, instance, prefix);
          }
        } else if (classPrototype.is(CommonFlags.GENERIC)) {
          if (this.options.pedantic) {
            this.pedantic(
              DiagnosticCode.Exported_generic_function_or_class_has_no_concrete_instances,
              classPrototype.identifierNode.range
            );
          }
        }
        break;
      }
      case ElementKind.PROPERTY_PROTOTYPE: {
        let propertyInstance = (<PropertyPrototype>element).instance;
        if (propertyInstance) this.ensureModuleExport(name, propertyInstance, prefix);
        break;
      }

      // export concrete elements
      case ElementKind.GLOBAL: {
        let global = <Global>element;
        let isConst = global.is(CommonFlags.CONST) || global.is(CommonFlags.STATIC | CommonFlags.READONLY);
        if (!isConst && !this.options.hasFeature(Feature.MUTABLE_GLOBALS)) {
          this.error(
            DiagnosticCode.Cannot_export_a_mutable_global,
            global.identifierNode.range
          );
        } else if (global.is(CommonFlags.COMPILED)) {
          let exportName = prefix + name;
          if (!module.hasExport(exportName)) {
            module.addGlobalExport(element.internalName, exportName);
          }
        }
        break;
      }
      case ElementKind.ENUMVALUE: {
        let enumValue = <EnumValue>element;
        if (!enumValue.isImmutable && !this.options.hasFeature(Feature.MUTABLE_GLOBALS)) {
          this.error(
            DiagnosticCode.Cannot_export_a_mutable_global,
            enumValue.identifierNode.range
          );
        } else if (enumValue.is(CommonFlags.COMPILED)) {
          let exportName = prefix + name;
          if (!module.hasExport(exportName)) {
            module.addGlobalExport(element.internalName, exportName);
          }
        }
        break;
      }
      case ElementKind.FUNCTION: {
        let functionInstance = <Function>element;
        if (!functionInstance.hasDecorator(DecoratorFlags.BUILTIN)) {
          let signature = functionInstance.signature;
          if (signature.requiredParameters < signature.parameterTypes.length) {
            // utilize varargs stub to fill in omitted arguments
            functionInstance = this.ensureVarargsStub(functionInstance);
            this.runtimeFeatures |= RuntimeFeatures.setArgumentsLength;
          }
          if (functionInstance.is(CommonFlags.COMPILED)) {
            let exportName = prefix + name;
            if (!module.hasExport(exportName)) {
              module.addFunctionExport(functionInstance.internalName, exportName);
              if (signature.hasManagedOperands) {
                this.shadowStack.noteExport(exportName, signature.getManagedOperandIndices());
              }
            }
          }
        }
        break;
      }
      case ElementKind.PROPERTY: {
        let propertyInstance = <Property>element;
        let getterInstance = propertyInstance.getterInstance;
        if (getterInstance) this.ensureModuleExport(GETTER_PREFIX + name, getterInstance, prefix);
        let setterInstance = propertyInstance.setterInstance;
        if (setterInstance) this.ensureModuleExport(SETTER_PREFIX + name, setterInstance, prefix);
        break;
      }
      case ElementKind.FIELD: {
        let fieldInstance = <Field>element;
        if (element.is(CommonFlags.COMPILED)) {
          let getterExportName = prefix + GETTER_PREFIX + name;
          if (this.compileFieldGetter(fieldInstance) && !module.hasExport(getterExportName)) {
            module.addFunctionExport(fieldInstance.internalGetterName, getterExportName);
            let signature = fieldInstance.internalGetterSignature;
            if (signature.hasManagedOperands) {
              this.shadowStack.noteExport(getterExportName, signature.getManagedOperandIndices());
            }
          }
          if (!element.is(CommonFlags.READONLY)) {
            let setterExportName = prefix + SETTER_PREFIX + name;
            if (this.compileFieldSetter(fieldInstance) && !module.hasExport(setterExportName)) {
              module.addFunctionExport(fieldInstance.internalSetterName, setterExportName);
              let signature = fieldInstance.internalSetterSignature;
              if (signature.hasManagedOperands) {
                this.shadowStack.noteExport(setterExportName, signature.getManagedOperandIndices());
              }
            }
          }
        }
        break;
      }
      case ElementKind.CLASS: {
        let classInstance = <Class>element;
        // make the class name itself represent its runtime id
        if (!classInstance.type.isUnmanaged) {
          let module = this.module;
          let internalName = classInstance.internalName;

          if (!this.doneModuleExports.has(element)) {
            module.addGlobal(internalName, TypeRef.I32, false, module.i32(classInstance.id));
            this.doneModuleExports.add(element);
          }
          module.addGlobalExport(internalName, prefix + name);
        }
        break;
      }

      // just traverse members below
      case ElementKind.ENUM:
      case ElementKind.INTERFACE_PROTOTYPE:
      case ElementKind.NAMESPACE:
      case ElementKind.TYPEDEFINITION:
      case ElementKind.INDEXSIGNATURE: break;

      default: assert(false); // unexpected module export
    }

    // traverse members
    var members = element.members;
    if (members) {
      let subPrefix = prefix + name + (element.kind == ElementKind.CLASS
        ? INSTANCE_DELIMITER
        : STATIC_DELIMITER
      );
      if (element.kind == ElementKind.NAMESPACE) {
        let implicitExport = element.is(CommonFlags.SCOPED);
        // TODO: for (let [memberName, member] of members) {
        for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {
          let memberName = unchecked(_keys[i]);
          let member = assert(members.get(memberName));
          if (implicitExport || member.is(CommonFlags.EXPORT)) {
            this.ensureModuleExport(memberName, member, subPrefix);
          }
        }
      } else {
        // TODO: for (let [memberName, member] of members) {
        for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {
          let memberName = unchecked(_keys[i]);
          let member = assert(members.get(memberName));
          if (!member.is(CommonFlags.PRIVATE)) {
            this.ensureModuleExport(memberName, member, subPrefix);
          }
        }
      }
    }
  }

  // === Elements =================================================================================

  /** Compiles any element. */
  compileElement(element: Element, compileMembers: bool = true): void {
    switch (element.kind) {
      case ElementKind.GLOBAL: {
        this.compileGlobal(<Global>element);
        break;
      }
      case ElementKind.ENUM: {
        this.compileEnum(<Enum>element);
        break;
      }
      case ElementKind.FUNCTION_PROTOTYPE: {
        if (!element.is(CommonFlags.GENERIC)) {
          let functionInstance = this.resolver.resolveFunction(<FunctionPrototype>element, null);
          if (functionInstance) this.compileFunction(functionInstance);
        }
        break;
      }
      case ElementKind.CLASS_PROTOTYPE: {
        if (!element.is(CommonFlags.GENERIC)) {
          let classInstance = this.resolver.resolveClass(<ClassPrototype>element, null);
          if (classInstance) this.compileClass(classInstance);
        }
        break;
      }
      case ElementKind.PROPERTY_PROTOTYPE: {
        let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>element);
        if (propertyInstance) this.compileProperty(propertyInstance);
        break;
      }
      case ElementKind.INTERFACE_PROTOTYPE:
      case ElementKind.NAMESPACE:
      case ElementKind.TYPEDEFINITION:
      case ElementKind.ENUMVALUE:
      case ElementKind.INDEXSIGNATURE: break;
      default: assert(false);
    }
    if (compileMembers) {
      let members = element.members;
      if (members) {
        // TODO: for (let element of members.values()) {
        for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {
          let element = unchecked(_values[i]);
          this.compileElement(element);
        }
      }
    }
  }

  /** Compiles a file's exports. */
  compileExports(file: File): void {
    var exports = file.exports;
    if (exports) {
      // TODO: for (let element of exports.values()) {
      for (let _values = Map_values(exports), i = 0, k = _values.length; i < k; ++i) {
        let element = unchecked(_values[i]);
        if (!element.hasDecorator(DecoratorFlags.LAZY)) this.compileElement(element);
      }
    }
    var exportsStar = file.exportsStar;
    if (exportsStar) {
      for (let i = 0, k = exportsStar.length; i < k; ++i) {
        let exportStar = unchecked(exportsStar[i]);
        this.compileFile(exportStar);
        this.compileExports(exportStar);
      }
    }
  }

  // files

  /** Compiles the file matching the specified path. */
  compileFileByPath(normalizedPathWithoutExtension: string, reportNode: Node): void {
    var file: File;
    var filesByName = this.program.filesByName;
    var pathWithIndex: string;
    if (filesByName.has(normalizedPathWithoutExtension)) {
      file = assert(filesByName.get(normalizedPathWithoutExtension));
    } else if (filesByName.has(pathWithIndex = normalizedPathWithoutExtension + INDEX_SUFFIX)) {
      file = assert(filesByName.get(pathWithIndex));
    } else {
      this.error(
        DiagnosticCode.File_0_not_found,
        reportNode.range, normalizedPathWithoutExtension
      );
      return;
    }
    this.compileFile(file);
  }

  /** Compiles the specified file. */
  compileFile(file: File): void {
    if (file.is(CommonFlags.COMPILED)) return;
    file.set(CommonFlags.COMPILED);

    // compile top-level statements within the file's start function
    var startFunction = file.startFunction;
    var startSignature = startFunction.signature;
    var previousBody = this.currentBody;
    var startFunctionBody = new Array<ExpressionRef>();
    this.currentBody = startFunctionBody;

    // compile top-level statements
    var previousFlow = this.currentFlow;
    var flow = startFunction.flow;
    this.currentFlow = flow;
    for (let statements = file.source.statements, i = 0, k = statements.length; i < k; ++i) {
      this.compileTopLevelStatement(statements[i], startFunctionBody);
    }
    // no need to insert unreachable since last statement should have done that
    this.currentFlow = previousFlow;
    this.currentBody = previousBody;

    // if top-level statements are present, make the per-file start function and call it in start
    if (startFunctionBody.length) {
      let module = this.module;
      let locals = startFunction.localsByIndex;
      let numLocals = locals.length;
      let varTypes = new Array<TypeRef>(numLocals);
      for (let i = 0; i < numLocals; ++i) varTypes[i] = locals[i].type.toRef();
      module.addFunction(
        startFunction.internalName,
        startSignature.paramRefs,
        startSignature.resultRefs,
        varTypes,
        module.flatten(startFunctionBody)
      );
      previousBody.push(
        module.call(startFunction.internalName, null, TypeRef.None)
      );
    }
  }

  // === Globals ==================================================================================

  /** Compiles a global variable. */
  compileGlobal(global: Global): bool {
    if (global.is(CommonFlags.COMPILED)) return !global.is(CommonFlags.ERRORED);
    global.set(CommonFlags.COMPILED);

    var pendingElements = this.pendingElements;
    pendingElements.add(global);

    var module = this.module;
    var initExpr: ExpressionRef = 0;
    var typeNode = global.typeNode;
    var initializerNode = global.initializerNode;

    if (!global.is(CommonFlags.RESOLVED)) {

      // Resolve type if annotated
      if (typeNode) {
        let resolvedType = this.resolver.resolveType(typeNode, global.parent); // reports
        if (!resolvedType) {
          global.set(CommonFlags.ERRORED);
          pendingElements.delete(global);
          return false;
        }
        if (resolvedType == Type.void) {
          this.error(
            DiagnosticCode.Type_expected,
            typeNode.range
          );
          global.set(CommonFlags.ERRORED);
          pendingElements.delete(global);
          return false;
        }
        global.setType(resolvedType);
        this.checkTypeSupported(global.type, typeNode);

      // Otherwise infer type from initializer
      } else if (initializerNode) {
        let previousFlow = this.currentFlow;
        if (global.hasDecorator(DecoratorFlags.LAZY)) {
          this.currentFlow = global.file.startFunction.flow;
        }
        initExpr = this.compileExpression(initializerNode, Type.auto, // reports
          Constraints.MUST_WRAP | Constraints.PREFER_STATIC
        );
        this.currentFlow = previousFlow;
        if (this.currentType == Type.void) {
          this.error(
            DiagnosticCode.Type_0_is_not_assignable_to_type_1,
            initializerNode.range, this.currentType.toString(), "<auto>"
          );
          global.set(CommonFlags.ERRORED);
          pendingElements.delete(global);
          return false;
        }
        global.setType(this.currentType);

      // Error if there's neither a type nor an initializer
      } else {
        this.error(
          DiagnosticCode.Type_expected,
          global.identifierNode.range.atEnd
        );
        global.set(CommonFlags.ERRORED);
        pendingElements.delete(global);
        return false;
      }
    }

    // Handle ambient builtins like '__heap_base' that need to be resolved but are added explicitly
    if (global.is(CommonFlags.AMBIENT) && global.hasDecorator(DecoratorFlags.BUILTIN)) {
      let internalName = global.internalName;
      if (internalName == BuiltinNames.data_end) this.runtimeFeatures |= RuntimeFeatures.DATA;
      else if (internalName == BuiltinNames.stack_pointer) this.runtimeFeatures |= RuntimeFeatures.STACK;
      else if (internalName == BuiltinNames.heap_base) this.runtimeFeatures |= RuntimeFeatures.HEAP;
      else if (internalName == BuiltinNames.rtti_base) this.runtimeFeatures |= RuntimeFeatures.RTTI;
      pendingElements.delete(global);
      return true;
    }

    var type = global.type;
    var typeRef = type.toRef();
    var isDeclaredConstant = global.is(CommonFlags.CONST) || global.is(CommonFlags.STATIC | CommonFlags.READONLY);
    var isDeclaredInline = global.hasDecorator(DecoratorFlags.INLINE);

    // Handle imports
    if (global.is(CommonFlags.AMBIENT)) {

      // Constant global or mutable globals enabled
      if (isDeclaredConstant || this.options.hasFeature(Feature.MUTABLE_GLOBALS)) {
        global.set(CommonFlags.MODULE_IMPORT);
        mangleImportName(global, global.declaration);
        module.addGlobalImport(
          global.internalName,
          mangleImportName_moduleName,
          mangleImportName_elementName,
          typeRef,
          !isDeclaredConstant
        );
        pendingElements.delete(global);
        return true;
      }

      // Importing mutable globals is not supported in the MVP
      this.error(
        DiagnosticCode.Feature_0_is_not_enabled,
        global.declaration.range, "mutable-globals"
      );
      global.set(CommonFlags.ERRORED);
      pendingElements.delete(global);
      return false;
    }

    // The MVP does not yet support initializer expressions other than constants and gets of
    // imported immutable globals, hence such initializations must be performed in the start.
    var initializeInStart = false;

    // Evaluate initializer if present
    if (initializerNode) {
      if (!initExpr) {
        let previousFlow = this.currentFlow;
        if (global.hasDecorator(DecoratorFlags.LAZY)) {
          this.currentFlow = global.file.startFunction.flow;
        }
        initExpr = this.compileExpression(initializerNode, type,
          Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP | Constraints.PREFER_STATIC
        );
        this.currentFlow = previousFlow;
      }

      // If not a constant, attempt to precompute
      if (getExpressionId(initExpr) != ExpressionId.Const) {
        if (isDeclaredConstant) {
          if (getExpressionId(initExpr) != ExpressionId.Const) {
            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);
            if (precomp) {
              initExpr = precomp;
            } else {
              initializeInStart = true;
            }
          }
        } else {
          initializeInStart = true;
        }
      }

      // Handle special case of initializing from imported immutable global
      if (initializeInStart && getExpressionId(initExpr) == ExpressionId.GlobalGet) {
        let fromName = assert(getGlobalGetName(initExpr));
        if (!isGlobalMutable(module.getGlobal(fromName))) {
          let elementsByName = this.program.elementsByName;
          if (elementsByName.has(fromName)) {
            let global = assert(elementsByName.get(fromName));
            if (global.is(CommonFlags.AMBIENT)) initializeInStart = false;
          }
        }
      }

      // Explicitly inline if annotated
      if (isDeclaredInline) {
        if (initializeInStart) {
          this.warning(
            DiagnosticCode.Mutable_value_cannot_be_inlined,
            initializerNode.range
          );
        } else {
          assert(getExpressionId(initExpr) == ExpressionId.Const);
          let exprType = getExpressionType(initExpr);
          switch (<u32>exprType) {
            case <u32>TypeRef.I32: {
              global.constantValueKind = ConstantValueKind.INTEGER;
              global.constantIntegerValue = i64_new(getConstValueI32(initExpr), 0);
              break;
            }
            case <u32>TypeRef.I64: {
              global.constantValueKind = ConstantValueKind.INTEGER;
              global.constantIntegerValue = i64_new(
                getConstValueI64Low(initExpr),
                getConstValueI64High(initExpr)
              );
              break;
            }
            case <u32>TypeRef.F32: {
              global.constantValueKind = ConstantValueKind.FLOAT;
              global.constantFloatValue = getConstValueF32(initExpr);
              break;
            }
            case <u32>TypeRef.F64: {
              global.constantValueKind = ConstantValueKind.FLOAT;
              global.constantFloatValue = getConstValueF64(initExpr);
              break;
            }
            default: {
              assert(false);
              global.set(CommonFlags.ERRORED);
              pendingElements.delete(global);
              return false;
            }
          }
          global.set(CommonFlags.INLINED); // inline the value from now on
        }
      }

    // Initialize to zero if there's no initializer
    } else {
      if (global.is(CommonFlags.INLINED)) {
        initExpr = this.compileInlineConstant(global, global.type, Constraints.PREFER_STATIC);
      } else {
        initExpr = this.makeZero(type, global.declaration);
      }
    }

    var internalName = global.internalName;

    if (initializeInStart) { // initialize to mutable zero and set the actual value in start
      if (isDeclaredInline) {
        this.error(
          DiagnosticCode.Decorator_0_is_not_valid_here,
          findDecorator(DecoratorKind.INLINE, global.decoratorNodes)!.range, "inline"
        );
      }
      module.addGlobal(internalName, typeRef, true, this.makeZero(type, global.declaration));
      this.currentBody.push(
        module.global_set(internalName, initExpr)
      );
    } else if (!isDeclaredInline) { // compile normally
      module.addGlobal(internalName, typeRef, !isDeclaredConstant, initExpr);
    }
    pendingElements.delete(global);
    return true;
  }

  // === Enums ====================================================================================

  /** Compiles an enum. */
  compileEnum(element: Enum): bool {
    if (element.is(CommonFlags.COMPILED)) return !element.is(CommonFlags.ERRORED);
    element.set(CommonFlags.COMPILED);

    var pendingElements = this.pendingElements;
    pendingElements.add(element);

    var module = this.module;
    var previousParent = this.currentParent;
    this.currentParent = element;
    var previousValue: EnumValue | null = null;
    var previousValueIsMut = false;
    var isInline = element.is(CommonFlags.CONST) || element.hasDecorator(DecoratorFlags.INLINE);

    var members = element.members;
    if (members) {
      // TODO: for (let member of element.members.values()) {
      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {
        let member = unchecked(_values[i]);
        if (member.kind != ElementKind.ENUMVALUE) continue; // happens if an enum is also a namespace
        let initInStart = false;
        let enumValue = <EnumValue>member;
        let valueNode = enumValue.valueNode;
        enumValue.set(CommonFlags.COMPILED);
        let previousFlow = this.currentFlow;
        if (element.hasDecorator(DecoratorFlags.LAZY)) {
          this.currentFlow = element.file.startFunction.flow;
        }
        let initExpr: ExpressionRef;
        if (valueNode) {
          initExpr = this.compileExpression(valueNode, Type.i32,
            Constraints.CONV_IMPLICIT
          );
          if (getExpressionId(initExpr) != ExpressionId.Const) {
            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);
            if (precomp) {
              initExpr = precomp;
            } else {
              if (element.is(CommonFlags.CONST)) {
                this.error(
                  DiagnosticCode.In_const_enum_declarations_member_initializer_must_be_constant_expression,
                  valueNode.range
                );
              }
              initInStart = true;
            }
          }
        } else if (previousValue == null) {
          initExpr = module.i32(0);
        } else {
          if (previousValueIsMut) {
            this.error(
              DiagnosticCode.Enum_member_must_have_initializer,
              enumValue.identifierNode.range.atEnd
            );
          }
          if (isInline) {
            let value = i64_add(previousValue.constantIntegerValue, i64_new(1));
            assert(!i64_high(value));
            initExpr = module.i32(i64_low(value));
          } else {
            initExpr = module.binary(BinaryOp.AddI32,
              module.global_get(previousValue.internalName, TypeRef.I32),
              module.i32(1)
            );
            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);
            if (precomp) {
              initExpr = precomp;
            } else {
              if (element.is(CommonFlags.CONST)) {
                this.error(
                  DiagnosticCode.In_const_enum_declarations_member_initializer_must_be_constant_expression,
                  member.declaration.range
                );
              }
              initInStart = true;
            }
          }
        }
        this.currentFlow = previousFlow;
        if (initInStart) {
          module.addGlobal(enumValue.internalName, TypeRef.I32, true, module.i32(0));
          this.currentBody.push(
            this.makeGlobalAssignment(enumValue, initExpr, Type.i32, false)
          );
          previousValueIsMut = true;
        } else {
          if (isInline) {
            enumValue.setConstantIntegerValue(i64_new(getConstValueI32(initExpr)), Type.i32);
            if (enumValue.is(CommonFlags.MODULE_EXPORT)) {
              module.addGlobal(enumValue.internalName, TypeRef.I32, false, initExpr);
            }
          } else {
            module.addGlobal(enumValue.internalName, TypeRef.I32, false, initExpr);
          }
          enumValue.isImmutable = true;
          previousValueIsMut = false;
        }
        previousValue = enumValue;
      }
    }
    this.currentParent = previousParent;
    pendingElements.delete(element);
    return true;
  }

  // === Functions ================================================================================

  /** Compiles a priorly resolved function. */
  compileFunction(
    /** Function to compile. */
    instance: Function,
    /** Force compilation of stdlib alternative if a builtin. */
    forceStdAlternative: bool = false
  ): bool {
    if (instance.is(CommonFlags.COMPILED)) return !instance.is(CommonFlags.ERRORED);

    if (!forceStdAlternative) {
      if (instance.hasDecorator(DecoratorFlags.BUILTIN)) return true;
      if (instance.hasDecorator(DecoratorFlags.LAZY)) {
        this.lazyFunctions.add(instance);
        return true;
      }
    }

    // ensure the function hasn't duplicate parameters
    var parameters = instance.prototype.functionTypeNode.parameters;
    var numParameters = parameters.length;
    if (numParameters >= 2) {
      let visited = new Set<string>();
      visited.add(parameters[0].name.text);
      for (let i = 1; i < numParameters; i++) {
        let paramIdentifier = parameters[i].name;
        let paramName = paramIdentifier.text;
        if (!visited.has(paramName)) {
          visited.add(paramName);
        } else {
          this.error(
            DiagnosticCode.Duplicate_identifier_0,
            paramIdentifier.range, paramName
          );
        }
      }
    }

    instance.set(CommonFlags.COMPILED);
    var pendingElements = this.pendingElements;
    pendingElements.add(instance);

    var previousType = this.currentType;
    var module = this.module;
    var signature = instance.signature;
    var bodyNode = instance.prototype.bodyNode;
    var declarationNode = instance.declaration;
    assert(declarationNode.kind == NodeKind.FUNCTIONDECLARATION || declarationNode.kind == NodeKind.METHODDECLARATION);
    this.checkSignatureSupported(instance.signature, (<FunctionDeclaration>declarationNode).signature);

    var funcRef: FunctionRef;

    // concrete function
    if (bodyNode) {

      // must not be ambient
      if (instance.is(CommonFlags.AMBIENT)) {
        this.error(
          DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,
          instance.identifierNode.range
        );
      }

      // cannot have an annotated external name
      if (instance.hasDecorator(DecoratorFlags.EXTERNAL)) {
        let decoratorNodes = instance.decoratorNodes;
        let decorator = assert(findDecorator(DecoratorKind.EXTERNAL, decoratorNodes));
        this.error(
          DiagnosticCode.Decorator_0_is_not_valid_here,
          decorator.range, "external"
        );
      }

      // compile body in this function's context
      let previousFlow = this.currentFlow;
      let flow = instance.flow;
      this.currentFlow = flow;
      let stmts = new Array<ExpressionRef>();

      if (!this.compileFunctionBody(instance, stmts)) {
        stmts.push(module.unreachable());
      }

      this.currentFlow = previousFlow;

      // create the function
      funcRef = module.addFunction(
        instance.internalName,
        signature.paramRefs,
        signature.resultRefs,
        typesToRefs(instance.additionalLocals),
        module.flatten(stmts, instance.signature.returnType.toRef())
      );

    // imported function
    } else if (instance.is(CommonFlags.AMBIENT)) {
      instance.set(CommonFlags.MODULE_IMPORT);
      mangleImportName(instance, declarationNode); // TODO: check for duplicates
      module.addFunctionImport(
        instance.internalName,
        mangleImportName_moduleName,
        mangleImportName_elementName,
        signature.paramRefs,
        signature.resultRefs
      );
      funcRef = module.getFunction(instance.internalName);

    // abstract or interface function
    } else if (instance.is(CommonFlags.ABSTRACT) || instance.parent.kind == ElementKind.INTERFACE) {
      funcRef = module.addFunction(
        instance.internalName,
        signature.paramRefs,
        signature.resultRefs,
        null,
        module.unreachable()
      );
    } else {
      this.error(
        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,
        instance.identifierNode.range
      );
      funcRef = 0; // TODO?
      instance.set(CommonFlags.ERRORED);
    }

    instance.finalize(module, funcRef);
    this.currentType = previousType;
    pendingElements.delete(instance);
    return true;
  }

  /** Compiles the body of a function within the specified flow. */
  private compileFunctionBody(
    /** Function to compile. */
    instance: Function,
    /** Target array of statements also being returned. Creates a new array if omitted. */
    stmts: ExpressionRef[]
  ): bool {
    var module = this.module;
    var bodyNode = assert(instance.prototype.bodyNode);
    var returnType = instance.signature.returnType;
    var flow = this.currentFlow;
    var thisLocal = instance.signature.thisType
      ? assert(flow.lookupLocal(CommonNames.this_))
      : null;
    var bodyStartIndex = stmts.length;

    // compile statements
    if (bodyNode.kind == NodeKind.BLOCK) {
      stmts = this.compileStatements((<BlockStatement>bodyNode).statements, true, stmts);
    } else {
      // must be an expression statement if not a block
      assert(bodyNode.kind == NodeKind.EXPRESSION);

      // must be an arrow function
      assert(instance.prototype.arrowKind);

      // none of the following can be an arrow function
      assert(!instance.isAny(CommonFlags.CONSTRUCTOR | CommonFlags.GET | CommonFlags.SET));

      let expr = this.compileExpression((<ExpressionStatement>bodyNode).expression, returnType, Constraints.CONV_IMPLICIT);
      if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.RETURNS_WRAPPED);
      if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.RETURNS_NONNULL);

      if (!stmts) stmts = [ expr ];
      else stmts.push(expr);

      if (!flow.is(FlowFlags.TERMINATES)) {
        if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.RETURNS_WRAPPED);
        if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.RETURNS_NONNULL);
        flow.set(FlowFlags.RETURNS | FlowFlags.TERMINATES);
      }
    }

    // Make constructors return their instance pointer, and prepend a conditional
    // allocation if any code path accesses `this`.
    if (instance.is(CommonFlags.CONSTRUCTOR)) {
      assert(instance.is(CommonFlags.INSTANCE));
      thisLocal = assert(thisLocal);
      let parent = assert(instance.parent);
      assert(parent.kind == ElementKind.CLASS);
      let classInstance = <Class>parent;

      if (flow.isAny(FlowFlags.ACCESSES_THIS | FlowFlags.CONDITIONALLY_ACCESSES_THIS) || !flow.is(FlowFlags.TERMINATES)) {

        // Allocate `this` if not a super call, and initialize fields
        let allocStmts = new Array<ExpressionRef>();
        allocStmts.push(
          this.makeConditionalAllocation(classInstance, thisLocal.index)
        );
        this.makeFieldInitializationInConstructor(classInstance, allocStmts);

        // Insert right before the body
        for (let i = stmts.length - 1; i >= bodyStartIndex; --i) {
          stmts[i + 1] = stmts[i];
        }
        stmts[bodyStartIndex] = module.flatten(allocStmts, TypeRef.None);

        // Just prepended allocation is dropped when returning non-'this'
        if (flow.is(FlowFlags.MAY_RETURN_NONTHIS)) {
          if (this.options.pedantic) {
            this.pedantic(
              DiagnosticCode.Explicitly_returning_constructor_drops_this_allocation,
              instance.identifierNode.range
            );
          }
        }
      }

      // Returning something else than 'this' would break 'super()' calls
      if (flow.is(FlowFlags.MAY_RETURN_NONTHIS) && !classInstance.hasDecorator(DecoratorFlags.FINAL)) {
        this.error(
          DiagnosticCode.A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final,
          classInstance.identifierNode.range
        );
      }

      // Implicitly return `this` if the flow falls through
      if (!flow.is(FlowFlags.TERMINATES)) {
        stmts.push(
          module.local_get(thisLocal.index, this.options.sizeTypeRef)
        );
        flow.set(FlowFlags.RETURNS | FlowFlags.RETURNS_NONNULL | FlowFlags.TERMINATES);
      }

      // check that super has been called if this is a derived class
      if (classInstance.base !== null && !flow.is(FlowFlags.CALLS_SUPER)) {
        this.error(
          DiagnosticCode.Constructors_for_derived_classes_must_contain_a_super_call,
          instance.prototype.declaration.range
        );
      }

    // if this is a normal function, make sure that all branches terminate
    } else if (returnType != Type.void && !flow.is(FlowFlags.TERMINATES)) {
      this.error(
        DiagnosticCode.A_function_whose_declared_type_is_not_void_must_return_a_value,
        instance.prototype.functionTypeNode.returnType.range
      );
      return false; // not recoverable
    }

    return true;
  }

  // === Classes ==================================================================================

  /** Compiles a priorly resolved class. */
  compileClass(instance: Class): bool {
    if (instance.is(CommonFlags.COMPILED)) return true;
    instance.set(CommonFlags.COMPILED);
    var prototype = instance.prototype;
    var staticMembers = (<ClassPrototype>prototype).members;
    if (staticMembers) {
      // TODO: for (let element of staticMembers.values()) {
      for (let _values = Map_values(staticMembers), i = 0, k = _values.length; i < k; ++i) {
        let element = unchecked(_values[i]);
        switch (element.kind) {
          case ElementKind.GLOBAL: {
            this.compileGlobal(<Global>element);
            break;
          }
          case ElementKind.FUNCTION_PROTOTYPE: {
            if (element.is(CommonFlags.GENERIC)) break;
            let functionInstance = this.resolver.resolveFunction(<FunctionPrototype>element, null);
            if (!functionInstance) break;
            element = functionInstance;
            // fall-through
          }
          case ElementKind.FUNCTION: {
            this.compileFunction(<Function>element);
            break;
          }
          case ElementKind.PROPERTY_PROTOTYPE: {
            let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>element);
            if (!propertyInstance) break;
            element = propertyInstance;
            // fall-through
          }
          case ElementKind.PROPERTY: {
            this.compileProperty(<Property>element);
            break;
          }
        }
      }
    }
    this.ensureConstructor(instance, instance.identifierNode);
    this.checkFieldInitialization(instance);

    var instanceMembers = instance.members;
    if (instanceMembers) {
      // TODO: for (let element of instanceMembers.values()) {
      for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {
        let element = unchecked(_values[i]);
        switch (element.kind) {
          case ElementKind.FUNCTION_PROTOTYPE: {
            if (element.is(CommonFlags.GENERIC)) break;
            let functionInstance = this.resolver.resolveFunction(<FunctionPrototype>element, null);
            if (!functionInstance) break;
            element = functionInstance;
            // fall-through
          }
          case ElementKind.FUNCTION: {
            this.compileFunction(<Function>element);
            break;
          }
          case ElementKind.FIELD: {
            this.compileField(<Field>element);
            break;
          }
          case ElementKind.PROPERTY_PROTOTYPE: {
            let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>element);
            if (!propertyInstance) break;
            element = propertyInstance;
            // fall-through
          }
          case ElementKind.PROPERTY: {
            this.compileProperty(<Property>element);
            break;
          }
        }
      }
    }
    return true;
  }

  /** Compiles an instance field to a getter and a setter. */
  compileField(instance: Field): bool {
    this.compileFieldGetter(instance);
    this.compileFieldSetter(instance);
    return instance.is(CommonFlags.COMPILED);
  }

  /** Compiles the getter of the specified instance field. */
  compileFieldGetter(instance: Field): bool {
    if (instance.getterRef) return true;
    var module = this.module;
    var valueType = instance.type;
    var valueTypeRef = valueType.toRef();
    var thisTypeRef = this.options.sizeTypeRef;
    // return this.field
    instance.getterRef = module.addFunction(instance.internalGetterName, thisTypeRef, valueTypeRef, null,
      module.load(valueType.byteSize, valueType.isSignedIntegerValue,
        module.local_get(0, thisTypeRef),
        valueTypeRef, instance.memoryOffset
      )
    );
    if (instance.setterRef) {
      instance.set(CommonFlags.COMPILED);
    } else {
      let typeNode = instance.typeNode;
      if (typeNode) this.checkTypeSupported(instance.type, typeNode);
    }
    return true;
  }

  /** Compiles the setter of the specified instance field. */
  compileFieldSetter(instance: Field): bool {
    if (instance.setterRef) return true;
    var type = instance.type;
    var thisTypeRef = this.options.sizeTypeRef;
    var valueTypeRef = type.toRef();
    var module = this.module;
    // void(this.field = value)
    var bodyExpr = module.store(type.byteSize,
      module.local_get(0, thisTypeRef),
      module.local_get(1, valueTypeRef),
      valueTypeRef, instance.memoryOffset
    );
    if (type.isManaged) {
      let parent = instance.parent;
      assert(parent.kind == ElementKind.CLASS);
      if ((<Class>parent).type.isManaged) {
        let linkInstance = this.program.linkInstance;
        this.compileFunction(linkInstance);
        bodyExpr = module.block(null, [
          bodyExpr,
          module.call(linkInstance.internalName, [
            module.local_get(0, thisTypeRef),
            module.local_get(1, valueTypeRef),
            module.i32(0)
          ], TypeRef.None)
        ], TypeRef.None);
      }
    }
    instance.setterRef = module.addFunction(instance.internalSetterName, createType([ thisTypeRef, valueTypeRef ]), TypeRef.None, null,
      bodyExpr
    );
    if (instance.getterRef) {
      instance.set(CommonFlags.COMPILED);
    } else {
      let typeNode = instance.typeNode;
      if (typeNode) this.checkTypeSupported(instance.type, typeNode);
    }
    return true;
  }

  /** Compiles a property to a getter and potentially a setter. */
  compileProperty(instance: Property): bool {
    this.compilePropertyGetter(instance);
    this.compilePropertySetter(instance);
    return instance.is(CommonFlags.COMPILED);
  }

  /* Compiles the getter of the specified property. */
  compilePropertyGetter(instance: Property): bool {
    var getterInstance = instance.getterInstance;
    if (getterInstance) {
      let ret = this.compileFunction(getterInstance);
      let setterInstance = instance.setterInstance;
      if (getterInstance.is(CommonFlags.COMPILED) && (!setterInstance || setterInstance.is(CommonFlags.COMPILED))) {
        instance.set(CommonFlags.COMPILED);
      }
      return ret;
    }
    return false;
  }

  /** Compiles the setter of the specified property. */
  compilePropertySetter(instance: Property): bool {
    var setterInstance = instance.setterInstance;
    if (setterInstance) {
      let ret = this.compileFunction(setterInstance);
      let getterInstance = instance.getterInstance;
      if (getterInstance !== null && getterInstance.is(CommonFlags.COMPILED) && setterInstance.is(CommonFlags.COMPILED)) {
        instance.set(CommonFlags.COMPILED);
      }
      return ret;
    }
    return false;
  }

  // === Memory ===================================================================================

  /** Adds a static memory segment with the specified data. */
  addAlignedMemorySegment(buffer: Uint8Array, alignment: i32 = 16): MemorySegment {
    assert(isPowerOf2(alignment));
    var memoryOffset = i64_align(this.memoryOffset, alignment);
    var segment = new MemorySegment(buffer, memoryOffset);
    this.memorySegments.push(segment);
    this.memoryOffset = i64_add(memoryOffset, i64_new(buffer.length));
    return segment;
  }

  /** Adds a static memory segment representing a runtime object. */
  addRuntimeMemorySegment(buffer: Uint8Array): MemorySegment {
    var memoryOffset = this.program.computeBlockStart64(this.memoryOffset);
    var segment = new MemorySegment(buffer, memoryOffset);
    this.memorySegments.push(segment);
    this.memoryOffset = i64_add(memoryOffset, i64_new(buffer.length));
    return segment;
  }

  /** Ensures that a string exists in static memory and returns a pointer expression. Deduplicates. */
  ensureStaticString(stringValue: string): ExpressionRef {
    var ptr = this.ensureStaticStringPtr(stringValue);
    this.currentType = this.program.stringInstance.type;
    return this.module.usize(ptr);
  }

  /** Ensures that a string exists in static memory and returns a pointer to it. Deduplicates. */
  ensureStaticStringPtr(stringValue: string): i64 {
    var program = this.program;
    var totalOverhead = program.totalOverhead;
    var stringInstance = assert(program.stringInstance);
    var stringSegment: MemorySegment;
    var segments = this.stringSegments;
    if (segments.has(stringValue)) {
      stringSegment = assert(segments.get(stringValue)); // reuse
    } else {
      let len = stringValue.length;
      let buf = stringInstance.createBuffer(len << 1);
      for (let i = 0; i < len; ++i) {
        writeI16(stringValue.charCodeAt(i), buf, totalOverhead + (i << 1));
      }
      stringSegment = this.addRuntimeMemorySegment(buf);
      segments.set(stringValue, stringSegment);
    }
    return i64_add(stringSegment.offset, i64_new(totalOverhead));
  }

  /** Writes a series of static values of the specified type to a buffer. */
  writeStaticBuffer(buf: Uint8Array, pos: i32, elementType: Type, values: ExpressionRef[]): i32 {
    var length = values.length;
    var byteSize = elementType.byteSize;
    var elementTypeRef = elementType.toRef();
    switch (<u32>elementTypeRef) {
      case <u32>TypeRef.I32: {
        switch (byteSize) {
          case 1: {
            for (let i = 0; i < length; ++i) {
              let value = values[i];
              assert(getExpressionType(value) == elementTypeRef);
              assert(getExpressionId(value) == ExpressionId.Const);
              writeI8(getConstValueI32(value), buf, pos);
              pos += 1;
            }
            break;
          }
          case 2: {
            for (let i = 0; i < length; ++i) {
              let value = values[i];
              assert(getExpressionType(value) == elementTypeRef);
              assert(getExpressionId(value) == ExpressionId.Const);
              writeI16(getConstValueI32(value), buf, pos);
              pos += 2;
            }
            break;
          }
          case 4: {
            for (let i = 0; i < length; ++i) {
              let value = values[i];
              assert(getExpressionType(value) == elementTypeRef);
              assert(getExpressionId(value) == ExpressionId.Const);
              writeI32(getConstValueI32(value), buf, pos);
              pos += 4;
            }
            break;
          }
          default: assert(false);
        }
        break;
      }
      case <u32>TypeRef.I64: {
        for (let i = 0; i < length; ++i) {
          let value = values[i];
          assert(getExpressionType(value) == elementTypeRef);
          assert(getExpressionId(value) == ExpressionId.Const);
          writeI64(i64_new(getConstValueI64Low(value), getConstValueI64High(value)), buf, pos);
          pos += 8;
        }
        break;
      }
      case <u32>TypeRef.F32: {
        for (let i = 0; i < length; ++i) {
          let value = values[i];
          assert(getExpressionType(value) == elementTypeRef);
          assert(getExpressionId(value) == ExpressionId.Const);
          writeF32(getConstValueF32(value), buf, pos);
          pos += 4;
        }
        break;
      }
      case <u32>TypeRef.F64: {
        for (let i = 0; i < length; ++i) {
          let value = values[i];
          assert(getExpressionType(value) == elementTypeRef);
          assert(getExpressionId(value) == ExpressionId.Const);
          writeF64(getConstValueF64(value), buf, pos);
          pos += 8;
        }
        break;
      }
      default: assert(false);
    }
    return pos;
  }

  /** Adds a buffer to static memory and returns the created segment. */
  addStaticBuffer(elementType: Type, values: ExpressionRef[], id: u32 = this.program.arrayBufferInstance.id): MemorySegment {
    var program = this.program;
    var arrayBufferInstance = program.arrayBufferInstance;
    var buf = arrayBufferInstance.createBuffer(values.length * elementType.byteSize);
    this.program.OBJECTInstance.writeField("rtId", id, buf, 0); // use specified rtId
    this.writeStaticBuffer(buf, program.totalOverhead, elementType, values);
    return this.addRuntimeMemorySegment(buf);
  }

  /** Adds an array header to static memory and returns the created segment. */
  private addStaticArrayHeader(
    elementType: Type,
    bufferSegment: MemorySegment,
    /** Optional array instance override. */
    arrayInstance: Class | null = null
  ): MemorySegment {
    var program = this.program;
    if (!arrayInstance) {
      arrayInstance = assert(this.resolver.resolveClass(this.program.arrayPrototype, [ elementType ]));
    }
    var bufferLength = readI32(bufferSegment.buffer, program.OBJECTInstance.offsetof("rtSize"));
    var arrayLength = i32(bufferLength / elementType.byteSize);
    var bufferAddress = i64_add(bufferSegment.offset, i64_new(program.totalOverhead));
    var buf = arrayInstance.createBuffer();
    assert(arrayInstance.writeField("buffer", bufferAddress, buf));
    assert(arrayInstance.writeField("dataStart", bufferAddress, buf));
    assert(arrayInstance.writeField("byteLength", bufferLength, buf));
    assert(arrayInstance.writeField("length_", arrayLength, buf));
    return this.addRuntimeMemorySegment(buf);
  }

  // === Table ====================================================================================

  /** Ensures that a runtime counterpart of the specified function exists and returns its address. */
  ensureRuntimeFunction(instance: Function): i64 {
    assert(instance.is(CommonFlags.COMPILED) && !instance.is(CommonFlags.STUB));
    var program = this.program;
    var memorySegment = instance.memorySegment;
    if (!memorySegment) {

      // Add to the function table
      let functionTable = this.functionTable;
      let tableBase = this.options.tableBase;
      if (!tableBase) tableBase = 1; // leave first elem blank
      let index = tableBase + functionTable.length;
      functionTable.push(instance);

      // Create runtime function
      let rtInstance = assert(this.resolver.resolveClass(program.functionPrototype, [ instance.type ]));
      let buf = rtInstance.createBuffer();
      assert(rtInstance.writeField("_index", index, buf));
      assert(rtInstance.writeField("_env", 0, buf));
      instance.memorySegment = memorySegment = this.addRuntimeMemorySegment(buf);
    }
    return i64_add(memorySegment.offset, i64_new(program.totalOverhead));
  }

  // === Statements ===============================================================================

  /** Compiles a top level statement (incl. function declarations etc.) to the specified body. */
  compileTopLevelStatement(statement: Statement, body: ExpressionRef[]): void {
    switch (statement.kind) {
      case NodeKind.CLASSDECLARATION: {
        let memberStatements = (<ClassDeclaration>statement).members;
        for (let i = 0, k = memberStatements.length; i < k; ++i) {
          this.compileTopLevelStatement(memberStatements[i], body);
        }
        break;
      }
      case NodeKind.ENUMDECLARATION: {
        let element = this.program.getElementByDeclaration(<EnumDeclaration>statement);
        if (element) {
          assert(element.kind == ElementKind.ENUM);
          if (!element.hasDecorator(DecoratorFlags.LAZY)) this.compileEnum(<Enum>element);
        }
        break;
      }
      case NodeKind.NAMESPACEDECLARATION: {
        let declaration = <NamespaceDeclaration>statement;
        let element = this.program.getElementByDeclaration(declaration);
        if (element) {
          // any potentiall merged element
          let previousParent = this.currentParent;
          this.currentParent = element;
          let memberStatements = declaration.members;
          for (let i = 0, k = memberStatements.length; i < k; ++i) {
            this.compileTopLevelStatement(memberStatements[i], body);
          }
          this.currentParent = previousParent;
        }
        break;
      }
      case NodeKind.VARIABLE: {
        let declarations = (<VariableStatement>statement).declarations;
        for (let i = 0, k = declarations.length; i < k; ++i) {
          let element = this.program.getElementByDeclaration(declarations[i]);
          if (element) {
            assert(element.kind == ElementKind.GLOBAL);
            if (
              !element.is(CommonFlags.AMBIENT) && // delay imports
              !element.hasDecorator(DecoratorFlags.LAZY)
            ) this.compileGlobal(<Global>element);
          }
        }
        break;
      }
      case NodeKind.FIELDDECLARATION: {
        let element = this.program.getElementByDeclaration(<FieldDeclaration>statement);
        if (element !== null && element.kind == ElementKind.GLOBAL) { // static
          if (!element.hasDecorator(DecoratorFlags.LAZY)) this.compileGlobal(<Global>element);
        }
        break;
      }
      case NodeKind.EXPORT: {
        let exportStatement = <ExportStatement>statement;
        let internalPath = exportStatement.internalPath;
        if (internalPath !== null) {
          this.compileFileByPath(internalPath, assert(exportStatement.path));
        }
        break;
      }
      case NodeKind.EXPORTDEFAULT: {
        this.compileTopLevelStatement((<ExportDefaultStatement>statement).declaration, body);
        break;
      }
      case NodeKind.IMPORT: {
        let importStatement = <ImportStatement>statement;
        this.compileFileByPath(importStatement.internalPath, importStatement.path);
        break;
      }
      case NodeKind.FUNCTIONDECLARATION:
      case NodeKind.METHODDECLARATION:
      case NodeKind.INTERFACEDECLARATION:
      case NodeKind.INDEXSIGNATURE:
      case NodeKind.TYPEDECLARATION: break;
      default: { // otherwise a top-level statement that is part of the start function's body
        let stmt = this.compileStatement(statement);
        if (getExpressionId(stmt) != ExpressionId.Nop) body.push(stmt);
        break;
      }
    }
  }

  /** Compiles a statement. */
  compileStatement(
    /** Statement to compile. */
    statement: Statement,
    /** Whether this is the last statement of the body, if known. */
    isLastInBody: bool = false
  ): ExpressionRef {
    var module = this.module;
    var stmt: ExpressionRef;
    switch (statement.kind) {
      case NodeKind.BLOCK: {
        stmt = this.compileBlockStatement(<BlockStatement>statement);
        break;
      }
      case NodeKind.BREAK: {
        stmt = this.compileBreakStatement(<BreakStatement>statement);
        break;
      }
      case NodeKind.CONTINUE: {
        stmt = this.compileContinueStatement(<ContinueStatement>statement);
        break;
      }
      case NodeKind.DO: {
        stmt = this.compileDoStatement(<DoStatement>statement);
        break;
      }
      case NodeKind.EMPTY: {
        stmt = this.compileEmptyStatement(<EmptyStatement>statement);
        break;
      }
      case NodeKind.EXPRESSION: {
        stmt = this.compileExpressionStatement(<ExpressionStatement>statement);
        break;
      }
      case NodeKind.FOR: {
        stmt = this.compileForStatement(<ForStatement>statement);
        break;
      }
      case NodeKind.FOROF: {
        stmt = this.compileForOfStatement(<ForOfStatement>statement);
        break;
      }
      case NodeKind.IF: {
        stmt = this.compileIfStatement(<IfStatement>statement);
        break;
      }
      case NodeKind.RETURN: {
        stmt = this.compileReturnStatement(<ReturnStatement>statement, isLastInBody);
        break;
      }
      case NodeKind.SWITCH: {
        stmt = this.compileSwitchStatement(<SwitchStatement>statement);
        break;
      }
      case NodeKind.THROW: {
        stmt = this.compileThrowStatement(<ThrowStatement>statement);
        break;
      }
      case NodeKind.TRY: {
        stmt = this.compileTryStatement(<TryStatement>statement);
        break;
      }
      case NodeKind.VARIABLE: {
        stmt = this.compileVariableStatement(<VariableStatement>statement);
        if (!stmt) stmt = module.nop();
        break;
      }
      case NodeKind.VOID: {
        stmt = this.compileVoidStatement(<VoidStatement>statement);
        break;
      }
      case NodeKind.WHILE: {
        stmt = this.compileWhileStatement(<WhileStatement>statement);
        break;
      }
      case NodeKind.TYPEDECLARATION: {
        // TODO: integrate inner type declaration into flow
        this.error(
          DiagnosticCode.Not_implemented_0,
          statement.range,
          "Inner type alias"
        );
        stmt = module.unreachable();
        break;
      }
      default: {
        assert(false);
        stmt = module.unreachable();
      }
    }
    if (this.options.sourceMap) this.addDebugLocation(stmt, statement.range);
    return stmt;
  }

  /** Compiles a series of statements. */
  compileStatements(
    /** Statements to compile. */
    statements: Statement[],
    /** Whether this is an immediate body statement. */
    isBody: bool = false,
    /** Statements to append to that is also returned. Created if omitted. */
    stmts: ExpressionRef[] | null = null
  ): ExpressionRef[] {
    var numStatements = statements.length;
    if (!stmts) {
      stmts = new Array<ExpressionRef>(numStatements);
      stmts.length = 0;
    }
    var module = this.module;
    var flow = this.currentFlow;
    for (let i = 0; i < numStatements; ++i) {
      let stmt = this.compileStatement(statements[i], isBody && i == numStatements - 1);
      switch (getExpressionId(stmt)) {
        case ExpressionId.Block: {
          if (!getBlockName(stmt)) {
            for (let j: Index = 0, k = getBlockChildCount(stmt); j < k; ++j) stmts.push(getBlockChildAt(stmt, j));
            break;
          }
          // fall-through
        }
        default: stmts.push(stmt);
        case ExpressionId.Nop:
      }
      if (flow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)) {
        if (needsExplicitUnreachable(stmt)) stmts.push(module.unreachable());
        break;
      }
    }
    return stmts;
  }

  private compileBlockStatement(
    statement: BlockStatement
  ): ExpressionRef {
    var statements = statement.statements;
    var outerFlow = this.currentFlow;
    var innerFlow = outerFlow.fork();
    this.currentFlow = innerFlow;

    var stmts = this.compileStatements(statements);
    innerFlow.freeScopedLocals();
    outerFlow.inherit(innerFlow);
    this.currentFlow = outerFlow;
    return this.module.flatten(stmts);
  }

  private compileBreakStatement(
    statement: BreakStatement
  ): ExpressionRef {
    var module = this.module;
    var labelNode = statement.label;
    if (labelNode) {
      this.error(
        DiagnosticCode.Not_implemented_0,
        labelNode.range,
        "Break label"
      );
      return module.unreachable();
    }
    var flow = this.currentFlow;
    var breakLabel = flow.breakLabel;
    if (breakLabel == null) {
      this.error(
        DiagnosticCode.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement,
        statement.range
      );
      return module.unreachable();
    }
    flow.freeScopedLocals();
    flow.set(FlowFlags.BREAKS);
    return module.br(breakLabel);
  }

  private compileContinueStatement(
    statement: ContinueStatement
  ): ExpressionRef {
    var module = this.module;
    var label = statement.label;
    if (label) {
      this.error(
        DiagnosticCode.Not_implemented_0,
        label.range,
        "Continue label"
      );
      return module.unreachable();
    }
    // Check if 'continue' is allowed here
    var flow = this.currentFlow;
    var continueLabel = flow.continueLabel;
    if (continueLabel == null) {
      this.error(
        DiagnosticCode.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement,
        statement.range
      );
      return module.unreachable();
    }
    flow.set(FlowFlags.CONTINUES | FlowFlags.TERMINATES);
    flow.freeScopedLocals();
    return module.br(continueLabel);
  }

  private compileDoStatement(
    /** Statement to compile. */
    statement: DoStatement
  ): ExpressionRef {
    return this.doCompileDoStatement(statement, null);
  }

  private doCompileDoStatement(
    /** Statement to compile. */
    statement: DoStatement,
    /** If recompiling, the flow with differing local flags that triggered it. */
    flowAfter: Flow | null
  ): ExpressionRef {
    var module = this.module;
    var outerFlow = this.currentFlow;

    // (block $break                          â””â–ºâ” flow
    //  (loop $continue                         â”œâ—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” recompile?
    //   (body)                                 â””â”€â” bodyFlow â”‚
    //                                          â”Œâ”€â”˜          â”‚
    //                                        â”Œâ—„â”¼â–ºâ•¢          â”‚ breaks or terminates?
    //   (local.set $tcond (condition))       â”‚ â””â”€â” condFlow â”‚
    //                                        â”‚ â”Œâ”€â”˜          â”‚
    //   (br_if (local.get $tcond) $continue) â”œâ—„â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ condition?
    //  )                                     â””â”€â”
    // )                                      â”Œâ”€â”˜

    var label = outerFlow.pushBreakLabel();
    var flow = outerFlow.fork(/* resetBreakContext */ true);
    if (flowAfter) flow.unifyLocalFlags(flowAfter);
    var flowBefore = flow.fork();
    this.currentFlow = flow;

    var breakLabel = "do-break|" + label;
    flow.breakLabel = breakLabel;
    var continueLabel = "do-continue|" + label;
    flow.continueLabel = continueLabel;

    // Compile the body (always executes)
    var bodyFlow = flow.fork();
    this.currentFlow = bodyFlow;
    var bodyStmts = new Array<ExpressionRef>();
    var body = statement.statement;
    if (body.kind == NodeKind.BLOCK) {
      this.compileStatements((<BlockStatement>body).statements, false, bodyStmts);
    } else {
      bodyStmts.push(this.compileStatement(body));
    }

    // Shortcut if body never falls through
    if (bodyFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)) {
      bodyStmts.push(
        module.unreachable()
      );
      flow.inherit(bodyFlow);

    // Otherwise evaluate the condition
    } else {
      let condFlow = flow.fork();
      this.currentFlow = condFlow;
      let condExpr = this.makeIsTrueish(
        this.compileExpression(statement.condition, Type.i32),
        this.currentType,
        statement.condition
      );
      let condKind = this.evaluateCondition(condExpr);

      // Shortcut if condition is always false
      if (condKind == ConditionKind.FALSE) {
        bodyStmts.push(
          module.drop(condExpr)
        );
        flow.inherit(bodyFlow);

      // Terminate if condition is always true and body never breaks
      } else if (condKind == ConditionKind.TRUE && !bodyFlow.isAny(FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS)) {
        bodyStmts.push(
          module.drop(condExpr)
        );
        bodyStmts.push(
          module.br(continueLabel)
        );
        flow.set(FlowFlags.TERMINATES);

      } else {
        let tcond = condFlow.getTempLocal(Type.bool);
        bodyStmts.push(
          module.local_set(tcond.index, condExpr, false) // bool
        );
        bodyStmts.push(
          module.br(continueLabel,
            module.local_get(tcond.index, TypeRef.I32)
          )
        );
        condFlow.freeTempLocal(tcond);
        flow.inherit(condFlow);

        // Detect if local flags are incompatible before and after looping, and
        // if so recompile by unifying local flags between iterations. Note that
        // this may be necessary multiple times where locals depend on each other.
        if (Flow.hasIncompatibleLocalStates(flowBefore, flow)) {
          outerFlow.popBreakLabel();
          this.currentFlow = outerFlow;
          return this.doCompileDoStatement(statement, flow);
        }
      }
    }

    // Finalize
    assert(!flow.hasScopedLocals);
    outerFlow.inherit(flow);
    outerFlow.popBreakLabel();
    this.currentFlow = outerFlow;
    var expr = module.block(breakLabel, [
      module.loop(continueLabel,
        module.flatten(bodyStmts)
      )
    ]);
    if (outerFlow.is(FlowFlags.TERMINATES)) {
      expr = module.block(null, [ expr, module.unreachable() ]);
    }
    return expr;
  }

  private compileEmptyStatement(
    statement: EmptyStatement
  ): ExpressionRef {
    return this.module.nop();
  }

  private compileExpressionStatement(
    statement: ExpressionStatement
  ): ExpressionRef {
    return this.compileExpression(statement.expression, Type.void, Constraints.CONV_IMPLICIT);
  }

  private compileForStatement(
    /** Statement to compile. */
    statement: ForStatement
  ): ExpressionRef {
    return this.doCompileForStatement(statement, null);
  }

  private doCompileForStatement(
    /** Statement to compile. */
    statement: ForStatement,
    /** If recompiling, the flow with differing local flags that triggered it. */
    flowAfter: Flow | null
  ): ExpressionRef {
    var module = this.module;
    var outerFlow = this.currentFlow;

    // (initializer)                  â””â–ºâ” flow
    // (block $break                    â”‚
    //  (loop $loop                     â”œâ—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” recompile?
    //   (local.set $tcond (condition)) â””â”€â” condFlow â”‚
    //                                  â”Œâ”€â”˜          â”‚
    //   (if (local.get $tcond)       â”Œâ—„â”¤            â”‚ condition?
    //    (block $continue            â”‚ â”‚            â”‚
    //     (body)                     â”‚ â””â”€â” bodyFlow â”‚
    //                                â”‚ â”Œâ”€â”˜          â”‚
    //    )                           â”œâ—„â”¼â–ºâ•¢          â”‚ breaks or terminates?
    //    (incrementor)               â”‚ â””â”€â” incrFlow â”‚
    //                                â”‚ â”Œâ”€â”˜          â”‚
    //                                â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    //    (br $loop)                  â””â”€â”
    //   )                              â”‚
    //  )                               â”‚
    // )                                â”‚
    //                                â”Œâ”€â”˜

    var label = outerFlow.pushBreakLabel();
    var stmts = new Array<ExpressionRef>();
    var flow = outerFlow.fork(/* resetBreakContext */ true);
    this.currentFlow = flow;

    var breakLabel = "for-break" + label;
    flow.breakLabel = breakLabel;
    var continueLabel = "for-continue|" + label;
    flow.continueLabel = continueLabel;
    var loopLabel = "for-loop|" + label;

    // Compile initializer if present
    var initializer = statement.initializer;
    if (initializer) {
      assert(
        initializer.kind == NodeKind.EXPRESSION ||
        initializer.kind == NodeKind.VARIABLE
      );
      stmts.push(this.compileStatement(initializer));
    }

    if (flowAfter) flow.unifyLocalFlags(flowAfter);
    var flowBefore = flow.fork();

    // Precompute the condition
    var condFlow = flow.fork();
    this.currentFlow = condFlow;
    var condExpr: ExpressionRef;
    var condKind: ConditionKind;
    var condition = statement.condition;
    if (condition) {
      condExpr = this.makeIsTrueish(
        this.compileExpression(condition, Type.bool),
        this.currentType,
        condition
      );
      condKind = this.evaluateCondition(condExpr);

      // Shortcut if condition is always false (body never runs)
      if (condKind == ConditionKind.FALSE) {
        stmts.push(
          module.drop(condExpr)
        );
        condFlow.freeScopedLocals();
        flow.inherit(condFlow);
        flow.freeScopedLocals();
        outerFlow.inherit(flow);
        outerFlow.popBreakLabel();
        this.currentFlow = outerFlow;
        return module.flatten(stmts);
      }
    } else {
      condExpr = module.i32(1);
      condKind = ConditionKind.TRUE;
    }

    // From here on condition is either always true or unknown

    // Store condition result in a temp
    var tcond = flow.getTempLocal(Type.bool);
    var loopStmts = new Array<ExpressionRef>();
    loopStmts.push(
      module.local_set(tcond.index, condExpr, false) // bool
    );
    condFlow.freeScopedLocals();

    flow.inherit(condFlow); // always executes
    this.currentFlow = flow;

    // Compile the body assuming the condition turned out true
    var bodyFlow = flow.fork();
    bodyFlow.inheritNonnullIfTrue(condExpr);
    this.currentFlow = bodyFlow;
    var bodyStmts = new Array<ExpressionRef>();
    var body = statement.statement;
    if (body.kind == NodeKind.BLOCK) {
      this.compileStatements((<BlockStatement>body).statements, false, bodyStmts);
    } else {
      bodyStmts.push(this.compileStatement(body));
    }

    // Check if body terminates
    if (bodyFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)) {
      bodyStmts.push(module.unreachable());
    }
    if (condKind == ConditionKind.TRUE) flow.inherit(bodyFlow);
    else flow.inheritBranch(bodyFlow);
    bodyFlow.freeScopedLocals();

    var ifStmts = new Array<ExpressionRef>();
    ifStmts.push(
      module.block(continueLabel, bodyStmts)
    );

    // Compile the incrementor if it runs
    // Can still fall through to here if body continues, hence is already known to terminate
    if (!bodyFlow.is(FlowFlags.TERMINATES) || bodyFlow.isAny(FlowFlags.CONTINUES | FlowFlags.CONDITIONALLY_CONTINUES)) {
      let incrementor = statement.incrementor;
      if (incrementor) {
        let incrFlow = flow.fork();
        this.currentFlow = incrFlow;
        ifStmts.push(
          this.compileExpression(incrementor, Type.void, Constraints.CONV_IMPLICIT | Constraints.WILL_DROP)
        );
        incrFlow.freeScopedLocals();
        flow.inherit(incrFlow); // mostly local flags, also covers late termination by throwing
        this.currentFlow = flow;
      }

      ifStmts.push(
        module.br(loopLabel)
      );

      // Detect if local flags are incompatible before and after looping, and if
      // so recompile by unifying local flags between iterations. Note that this
      // may be necessary multiple times where locals depend on each other.
      if (Flow.hasIncompatibleLocalStates(flowBefore, flow)) {
        assert(!bodyFlow.hasScopedLocals);
        flow.freeScopedLocals();
        outerFlow.popBreakLabel();
        this.currentFlow = outerFlow;
        return this.doCompileForStatement(statement, flow);
      }
    }
    loopStmts.push(
      module.if(module.local_get(tcond.index, TypeRef.I32),
        module.flatten(ifStmts)
      )
    );

    stmts.push(
      module.block(breakLabel, [
        module.loop(loopLabel,
          module.flatten(loopStmts)
        )
      ])
    );
    flow.freeTempLocal(tcond);
    this.currentFlow = flow;

    // Finalize
    flow.freeScopedLocals();
    outerFlow.inherit(flow);
    outerFlow.popBreakLabel();
    if (outerFlow.is(FlowFlags.TERMINATES)) {
      stmts.push(module.unreachable());
    }
    this.currentFlow = outerFlow;
    return module.flatten(stmts);
  }

  private compileForOfStatement(
    statement: ForOfStatement
  ): ExpressionRef {
    this.error(
      DiagnosticCode.Not_implemented_0,
      statement.range,
      "Iterators"
    );
    return this.module.unreachable();
  }

  private compileIfStatement(
    statement: IfStatement
  ): ExpressionRef {
    var module = this.module;
    var ifTrue = statement.ifTrue;
    var ifFalse = statement.ifFalse;

    // (if              â””â–ºâ” flow
    //  (condition)      â”Œâ”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” condition?
    //  (block           â”‚            â”‚
    //   (ifTrue)        â””â–ºâ” thenFlow â”‚
    //                   â”Œâ”€â”˜          â”‚
    //  )                â”œâ”€â•¢          â”‚
    //  (block           â”‚          â”Œâ—„â”¤ present?
    //   (ifFalse)       â”‚          â”‚ â””â–ºâ” elseFlow
    //                   â”‚          â”‚ â”Œâ”€â”˜
    //  )                â”‚          â”‚ â”œâ”€â•¢
    // )                 â””â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”˜
    // ...              â”Œâ—„â”˜

    // Precompute the condition (always executes)
    var condExpr = this.makeIsTrueish(
      this.compileExpression(statement.condition, Type.bool),
      this.currentType,
      statement.condition
    );
    var condKind = this.evaluateCondition(condExpr);

    // Shortcut if the condition is constant
    switch (condKind) {
      case ConditionKind.TRUE: {
        return module.block(null, [
          module.drop(condExpr),
          this.compileStatement(ifTrue)
        ]);
      }
      case ConditionKind.FALSE: {
        return ifFalse
          ? module.block(null, [
              module.drop(condExpr),
              this.compileStatement(ifFalse)
            ])
          : module.drop(condExpr);
      }
    }

    // From here on condition is always unknown

    var flow = this.currentFlow;

    // Compile ifTrue assuming the condition turned out true
    var thenStmts = new Array<ExpressionRef>();
    var thenFlow = flow.fork();
    this.currentFlow = thenFlow;
    thenFlow.inheritNonnullIfTrue(condExpr);
    if (ifTrue.kind == NodeKind.BLOCK) {
      this.compileStatements((<BlockStatement>ifTrue).statements, false, thenStmts);
    } else {
      thenStmts.push(this.compileStatement(ifTrue));
    }
    var thenTerminates = thenFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS);
    if (thenTerminates) {
      thenStmts.push(module.unreachable());
    }
    thenFlow.freeScopedLocals();
    this.currentFlow = flow;

    // Compile ifFalse assuming the condition turned out false, if present
    if (ifFalse) {
      let elseStmts = new Array<ExpressionRef>();
      let elseFlow = flow.fork();
      this.currentFlow = elseFlow;
      elseFlow.inheritNonnullIfFalse(condExpr);
      if (ifFalse.kind == NodeKind.BLOCK) {
        this.compileStatements((<BlockStatement>ifFalse).statements, false, elseStmts);
      } else {
        elseStmts.push(this.compileStatement(ifFalse));
      }
      let elseTerminates = elseFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS);
      if (elseTerminates) {
        elseStmts.push(module.unreachable());
      }
      elseFlow.freeScopedLocals();
      this.currentFlow = flow;
      flow.inheritMutual(thenFlow, elseFlow);
      return module.if(condExpr,
        module.flatten(thenStmts),
        module.flatten(elseStmts)
      );
    } else {
      flow.inheritBranch(thenFlow);
      flow.inheritNonnullIfFalse(condExpr,
        thenFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)
          ? null     // thenFlow terminates: just inherit
          : thenFlow // must become nonnull in thenFlow otherwise
      );
      return module.if(condExpr,
        module.flatten(thenStmts)
      );
    }
  }

  private compileReturnStatement(
    statement: ReturnStatement,
    isLastInBody: bool
  ): ExpressionRef {
    var module = this.module;
    var expr: ExpressionRef = 0;
    var flow = this.currentFlow;
    var returnType = flow.returnType;

    var valueExpression = statement.value;
    if (valueExpression) {
      if (returnType == Type.void) {
        this.error(
          DiagnosticCode.Type_0_is_not_assignable_to_type_1,
          valueExpression.range, this.currentType.toString(), returnType.toString()
        );
        this.currentType = Type.void;
        return module.unreachable();
      }
      let constraints = Constraints.CONV_IMPLICIT;
      if (flow.actualFunction.is(CommonFlags.MODULE_EXPORT)) constraints |= Constraints.MUST_WRAP;

      expr = this.compileExpression(valueExpression, returnType, constraints);
      if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.RETURNS_WRAPPED);
      if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.RETURNS_NONNULL);
      if (flow.actualFunction.is(CommonFlags.CONSTRUCTOR) && valueExpression.kind != NodeKind.THIS) {
        flow.set(FlowFlags.MAY_RETURN_NONTHIS);
      }
    } else if (returnType != Type.void) {
      this.error(
        DiagnosticCode.Type_0_is_not_assignable_to_type_1,
        statement.range, "void", returnType.toString()
      );
      this.currentType = returnType;
      return module.unreachable();
    }
    flow.freeScopedLocals();

    // Remember that this flow returns
    flow.set(FlowFlags.RETURNS | FlowFlags.TERMINATES);

    // Handle inline return
    if (flow.isInline) {
      return isLastInBody && expr != 0
        ? expr
        : module.br(assert(flow.inlineReturnLabel), 0, expr);
    }

    // Otherwise emit a normal return
    return isLastInBody && expr != 0
      ? expr
      : module.return(expr);
  }

  private compileSwitchStatement(
    statement: SwitchStatement
  ): ExpressionRef {
    var module = this.module;

    var cases = statement.cases;
    var numCases = cases.length;
    if (!numCases) {
      return this.compileExpression(statement.condition, Type.void,
        Constraints.CONV_IMPLICIT
      );
    }

    // Everything within a switch uses the same break context
    var outerFlow = this.currentFlow;
    var context = outerFlow.pushBreakLabel();

    // introduce a local for evaluating the condition (exactly once)
    var tempLocal = outerFlow.getTempLocal(Type.u32);
    var tempLocalIndex = tempLocal.index;

    // Prepend initializer to inner block. Does not initiate a new branch, yet.
    var breaks = new Array<ExpressionRef>(1 + numCases);
    breaks[0] = module.local_set( // initializer
      tempLocalIndex,
      this.compileExpression(statement.condition, Type.u32,
        Constraints.CONV_IMPLICIT
      ),
      false // u32
    );

    // make one br_if per (possibly dynamic) labeled case (binaryen optimizes to br_table where possible)
    var breakIndex = 1;
    var defaultIndex = -1;
    for (let i = 0; i < numCases; ++i) {
      let case_ = cases[i];
      let label = case_.label;
      if (label) {
        breaks[breakIndex++] = module.br("case" + i.toString() + "|" + context,
          module.binary(BinaryOp.EqI32,
            module.local_get(tempLocalIndex, TypeRef.I32),
            this.compileExpression(label, Type.u32,
              Constraints.CONV_IMPLICIT
            )
          )
        );
      } else {
        defaultIndex = i;
      }
    }

    outerFlow.freeTempLocal(tempLocal);

    // otherwise br to default respectively out of the switch if there is no default case
    breaks[breakIndex] = module.br((defaultIndex >= 0
      ? "case" + defaultIndex.toString()
      : "break"
    ) + "|" + context);

    // nest blocks in order
    var currentBlock = module.block("case0|" + context, breaks, TypeRef.None);
    var commonCategorical = FlowFlags.ANY_CATEGORICAL;
    var commonConditional = 0;
    for (let i = 0; i < numCases; ++i) {
      let case_ = cases[i];
      let statements = case_.statements;
      let numStatements = statements.length;

      // Each switch case initiates a new branch
      let innerFlow = outerFlow.fork();
      this.currentFlow = innerFlow;
      let breakLabel = "break|" + context;
      innerFlow.breakLabel = breakLabel;

      let isLast = i == numCases - 1;
      let nextLabel = isLast ? breakLabel : "case" + (i + 1).toString() + "|" + context;
      let stmts = new Array<ExpressionRef>(1 + numStatements);
      stmts[0] = currentBlock;
      let count = 1;
      let terminates = false;
      for (let j = 0; j < numStatements; ++j) {
        let stmt = this.compileStatement(statements[j]);
        if (getExpressionId(stmt) != ExpressionId.Nop) {
          stmts[count++] = stmt;
        }
        if (innerFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)) {
          if (innerFlow.is(FlowFlags.TERMINATES)) terminates = true;
          break;
        }
      }
      stmts.length = count;
      if (terminates || isLast || innerFlow.isAny(FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS)) {
        commonCategorical &= innerFlow.flags;
      }
      commonConditional |= innerFlow.flags & FlowFlags.ANY_CONDITIONAL;

      // Switch back to the parent flow
      innerFlow.unset(
        FlowFlags.BREAKS |
        FlowFlags.CONDITIONALLY_BREAKS
      );
      innerFlow.freeScopedLocals();
      this.currentFlow = outerFlow;
      currentBlock = module.block(nextLabel, stmts, TypeRef.None); // must be a labeled block
    }
    outerFlow.popBreakLabel();

    // If the switch has a default (guaranteed to handle any value), propagate common flags
    if (defaultIndex >= 0) outerFlow.flags |= commonCategorical & ~FlowFlags.BREAKS;
    outerFlow.flags |= commonConditional & ~FlowFlags.CONDITIONALLY_BREAKS;
    // TODO: what about local states?
    return currentBlock;
  }

  private compileThrowStatement(
    statement: ThrowStatement
  ): ExpressionRef {
    // TODO: requires exception-handling spec.
    var flow = this.currentFlow;

    // Remember that this branch throws
    flow.set(FlowFlags.THROWS | FlowFlags.TERMINATES);

    var stmts = new Array<ExpressionRef>();
    var value = statement.value;
    var message: Expression | null = null;
    if (value.kind == NodeKind.NEW) {
      let newArgs = (<NewExpression>value).args;
      if (newArgs.length) message = newArgs[0]; // FIXME: naively assumes type string
    }
    stmts.push(
      this.makeAbort(message, statement)
    );
    flow.freeScopedLocals();
    return this.module.flatten(stmts);
  }

  private compileTryStatement(
    statement: TryStatement
  ): ExpressionRef {
    // TODO: can't yet support something like: try { return ... } finally { ... }
    // worthwhile to investigate lowering returns to block results (here)?
    this.error(
      DiagnosticCode.Not_implemented_0,
      statement.range,
      "Exceptions"
    );
    return this.module.unreachable();
  }

  /** Compiles a variable statement. Returns `0` if an initializer is not necessary. */
  private compileVariableStatement(
    statement: VariableStatement
  ): ExpressionRef {
    var module = this.module;
    var declarations = statement.declarations;
    var numDeclarations = declarations.length;
    var flow = this.currentFlow;
    var initializers = new Array<ExpressionRef>();
    var resolver = this.resolver;

    for (let i = 0; i < numDeclarations; ++i) {
      let declaration = declarations[i];
      let name = declaration.name.text;
      let type: Type | null = null;
      let initExpr: ExpressionRef = 0;

      // Resolve type if annotated
      let typeNode = declaration.type;
      let initializerNode = declaration.initializer;
      if (typeNode) {
        type = resolver.resolveType( // reports
          typeNode,
          flow.actualFunction,
          uniqueMap(flow.contextualTypeArguments)
        );
        if (!type) continue;
        this.checkTypeSupported(type, typeNode);

        if (initializerNode) {
          let pendingElements = this.pendingElements;
          let dummy = flow.addScopedDummyLocal(name, type, statement); // pending dummy
          pendingElements.add(dummy);
          initExpr = this.compileExpression(initializerNode, type, // reports
            Constraints.CONV_IMPLICIT
          );
          pendingElements.delete(dummy);
          flow.freeScopedDummyLocal(name);
        }

      // Otherwise infer type from initializer
      } else if (initializerNode) {
        let pendingElements = this.pendingElements;
        let temp = flow.addScopedDummyLocal(name, Type.auto, statement); // pending dummy
        pendingElements.add(temp);
        initExpr = this.compileExpression(initializerNode, Type.auto); // reports
        pendingElements.delete(temp);
        flow.freeScopedDummyLocal(name);

        if (this.currentType == Type.void) {
          this.error(
            DiagnosticCode.Type_0_is_not_assignable_to_type_1,
            declaration.range, this.currentType.toString(), "<auto>"
          );
          continue;
        }
        type = this.currentType;

      // Error if there's neither a type nor an initializer
      } else {
        this.error(
          DiagnosticCode.Type_expected,
          declaration.name.range.atEnd
        );
        continue;
      }

      // Handle constants, and try to inline if value is static
      let isConst = declaration.is(CommonFlags.CONST);
      let isStatic = false;
      if (isConst) {
        if (initExpr) {
          let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);
          if (precomp) {
            initExpr = precomp; // always use precomputed initExpr
            let local: Local | null = null;
            switch (<u32>getExpressionType(initExpr)) {
              case <u32>TypeRef.I32: {
                local = new Local(name, -1, type, flow.parentFunction);
                local.setConstantIntegerValue(
                  i64_new(
                    getConstValueI32(initExpr),
                    0
                  ),
                  type
                );
                break;
              }
              case <u32>TypeRef.I64: {
                local = new Local(name, -1, type, flow.parentFunction);
                local.setConstantIntegerValue(
                  i64_new(
                    getConstValueI64Low(initExpr),
                    getConstValueI64High(initExpr)
                  ),
                  type
                );
                break;
              }
              case <u32>TypeRef.F32: {
                local = new Local(name, -1, type, flow.parentFunction);
                local.setConstantFloatValue(<f64>getConstValueF32(initExpr), type);
                break;
              }
              case <u32>TypeRef.F64: {
                local = new Local(name, -1, type, flow.parentFunction);
                local.setConstantFloatValue(getConstValueF64(initExpr), type);
                break;
              }
            }
            if (local) {
              // Add as a virtual local that doesn't actually exist in WebAssembly
              let scopedLocals = flow.scopedLocals;
              if (!scopedLocals) flow.scopedLocals = scopedLocals = new Map();
              else if (scopedLocals.has(name)) {
                let existing = assert(scopedLocals.get(name));
                this.errorRelated(
                  DiagnosticCode.Duplicate_identifier_0,
                  declaration.name.range,
                  existing.declaration.name.range,
                  name
                );
                return this.module.unreachable();
              }
              scopedLocals.set(name, local);
              isStatic = true;
            }
          }
        } else {
          this.error(
            DiagnosticCode._const_declarations_must_be_initialized,
            declaration.range
          );
        }
      }

      // Otherwise compile as mutable
      if (!isStatic) {
        let local: Local;
        if (
          declaration.isAny(CommonFlags.LET | CommonFlags.CONST) ||
          flow.isInline
        ) { // here: not top-level
          let existingLocal = flow.getScopedLocal(name);
          if (existingLocal) {
            if (!existingLocal.declaration.range.source.isNative) {
              this.errorRelated(
                DiagnosticCode.Duplicate_identifier_0,
                declaration.name.range,
                existingLocal.declaration.name.range,
                name
              );
            } else { // scoped locals are shared temps that don't track declarations
              this.error(
                DiagnosticCode.Duplicate_identifier_0,
                declaration.name.range, name
              );
            }
            local = existingLocal;
          } else {
            local = flow.addScopedLocal(name, type);
          }
          if (isConst) flow.setLocalFlag(local.index, LocalFlags.CONSTANT);
        } else {
          let existing = flow.lookupLocal(name);
          if (existing) {
            this.errorRelated(
              DiagnosticCode.Duplicate_identifier_0,
              declaration.name.range,
              existing.declaration.name.range,
              name
            );
            continue;
          }
          local = flow.parentFunction.addLocal(type, name, declaration);
          if (isConst) flow.setLocalFlag(local.index, LocalFlags.CONSTANT);
        }
        if (initExpr) {
          initializers.push(
            this.makeLocalAssignment(local, initExpr, type, false)
          );
        } else {
          // no need to assign zero
          if (local.type.isShortIntegerValue) {
            flow.setLocalFlag(local.index, LocalFlags.WRAPPED);
          }
        }
      }
    }
    this.currentType = Type.void;
    return initializers.length == 0
      ? 0
      : module.flatten(initializers);
  }

  private compileVoidStatement(
    statement: VoidStatement
  ): ExpressionRef {
    return this.compileExpression(statement.expression, Type.void,
      Constraints.CONV_EXPLICIT | Constraints.WILL_DROP
    );
  }

  private compileWhileStatement(
    /** Statement to compile. */
    statement: WhileStatement
  ): ExpressionRef {
    return this.doCompileWhileStatement(statement, null);
  }

  private doCompileWhileStatement(
    /** Statement to compile. */
    statement: WhileStatement,
    /** If recompiling, the flow with differing local flags that triggered it. */
    flowAfter: Flow | null
  ): ExpressionRef {
    var module = this.module;
    var outerFlow = this.currentFlow;

    // (block $break                  â””â–ºâ” flow
    //  (loop $continue                 â”œâ—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” recompile?
    //   (local.set $tcond (condition)) â””â”€â” condFlow â”‚
    //                                  â”Œâ”€â”˜          â”‚
    //   (if (local.get $tcond)       â”Œâ—„â”¤            â”‚ condition?
    //    (body)                      â”‚ â””â”€â” bodyFlow â”‚
    //                                â”‚ â”Œâ”€â”˜          â”‚
    //                                â”œâ—„â”¼â–ºâ•¢          â”‚ breaks or terminates?
    //    (br $continue)              â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    //   )                            â””â”€â”
    //  )                               â”‚
    // )                              â”Œâ”€â”˜

    var label = outerFlow.pushBreakLabel();
    var stmts = new Array<ExpressionRef>();
    var flow = outerFlow.fork(/* resetBreakContext */ true);
    if (flowAfter) flow.unifyLocalFlags(flowAfter);
    var flowBefore = flow.fork();
    this.currentFlow = flow;

    var breakLabel = "while-break|" + label;
    flow.breakLabel = breakLabel;
    var continueLabel = "while-continue|" + label;
    flow.continueLabel = continueLabel;

    // Precompute the condition
    var condFlow = flow.fork();
    this.currentFlow = condFlow;
    var condExpr = this.makeIsTrueish(
      this.compileExpression(statement.condition, Type.bool),
      this.currentType,
      statement.condition
    );
    var condKind = this.evaluateCondition(condExpr);

    // Shortcut if condition is always false (body never runs)
    if (condKind == ConditionKind.FALSE) {
      stmts.push(
        module.drop(condExpr)
      );
      assert(!flow.hasScopedLocals);
      outerFlow.popBreakLabel();
      this.currentFlow = outerFlow;
      return module.flatten(stmts);
    }

    // From here on condition is either always true or unknown

    // Store condition result in a temp
    var tcond = flow.getTempLocal(Type.bool);
    stmts.push(
      module.local_set(tcond.index, condExpr, false) // bool
    );
    condFlow.freeScopedLocals();

    flow.inherit(condFlow); // always executes
    this.currentFlow = flow;

    // Compile the body assuming the condition turned out true
    var bodyFlow = flow.fork();
    bodyFlow.inheritNonnullIfTrue(condExpr);
    this.currentFlow = bodyFlow;
    var bodyStmts = new Array<ExpressionRef>();
    var body = statement.statement;
    if (body.kind == NodeKind.BLOCK) {
      this.compileStatements((<BlockStatement>body).statements, false, bodyStmts);
    } else {
      bodyStmts.push(this.compileStatement(body));
    }

    // Simplify if body always terminates
    if (bodyFlow.is(FlowFlags.TERMINATES)) {
      bodyStmts.push(
        module.unreachable()
      );
      if (condKind == ConditionKind.TRUE) flow.inherit(bodyFlow);
      else flow.inheritBranch(bodyFlow);

    // Terminate if condition is always true and body never breaks
    } else if (condKind == ConditionKind.TRUE && !bodyFlow.isAny(FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS)) {
      bodyStmts.push(
        module.br(continueLabel)
      );
      flow.set(FlowFlags.TERMINATES);

    } else {
      let breaks = bodyFlow.is(FlowFlags.BREAKS);
      if (breaks) {
        bodyStmts.push(
          module.unreachable()
        );
      } else {
        bodyStmts.push(
          module.br(continueLabel)
        );
      }
      if (condKind == ConditionKind.TRUE) flow.inherit(bodyFlow);
      else flow.inheritBranch(bodyFlow);

      // Detect if local flags are incompatible before and after looping, and
      // if so recompile by unifying local flags between iterations. Note that
      // this may be necessary multiple times where locals depend on each other.
      // Here: Only relevant if flow does not always break.
      if (!breaks && Flow.hasIncompatibleLocalStates(flowBefore, flow)) {
        flow.freeTempLocal(tcond);
        outerFlow.popBreakLabel();
        this.currentFlow = outerFlow;
        return this.doCompileWhileStatement(statement, flow);
      }
    }
    stmts.push(
      module.if(module.local_get(tcond.index, TypeRef.I32),
        module.flatten(bodyStmts)
      )
    );
    flow.freeTempLocal(tcond);
    this.currentFlow = flow;

    // Finalize
    assert(!flow.hasScopedLocals);
    outerFlow.inherit(flow);
    outerFlow.popBreakLabel();
    this.currentFlow = outerFlow;
    var expr = module.block(breakLabel, [
      module.loop(continueLabel,
        module.flatten(stmts)
      )
    ]);
    if (condKind == ConditionKind.TRUE && outerFlow.is(FlowFlags.TERMINATES)) {
      expr = module.block(null, [ expr, module.unreachable() ]);
    }
    return expr;
  }

  // === Expressions ==============================================================================

  /** Compiles the value of an inlined constant element. */
  compileInlineConstant(
    element: VariableLikeElement,
    contextualType: Type,
    constraints: Constraints
  ): ExpressionRef {
    assert(element.is(CommonFlags.INLINED | CommonFlags.RESOLVED));
    var type = element.type;
    switch (
      !(constraints & (Constraints.CONV_IMPLICIT | Constraints.CONV_EXPLICIT)) &&
      type.isIntegerValue &&
      contextualType.isIntegerValue &&
      type.size < contextualType.size
        ? (this.currentType = contextualType).kind // essentially precomputes a (sign-)extension
        : (this.currentType = type).kind
    ) {
      case TypeKind.I8:
      case TypeKind.I16: {
        let shift = type.computeSmallIntegerShift(Type.i32);
        return this.module.i32(
          element.constantValueKind == ConstantValueKind.INTEGER
            ? i64_low(element.constantIntegerValue) << shift >> shift
            : 0
        ); // recognized by canOverflow
      }
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.BOOL: {
        let mask = element.type.computeSmallIntegerMask(Type.i32);
        return this.module.i32(
          element.constantValueKind == ConstantValueKind.INTEGER
            ? i64_low(element.constantIntegerValue) & mask
            : 0
        ); // recognized by canOverflow
      }
      case TypeKind.I32:
      case TypeKind.U32: {
        return this.module.i32(
          element.constantValueKind == ConstantValueKind.INTEGER
            ? i64_low(element.constantIntegerValue)
            : 0
        );
      }
      case TypeKind.ISIZE:
      case TypeKind.USIZE: {
        if (!element.program.options.isWasm64) {
          return this.module.i32(
            element.constantValueKind == ConstantValueKind.INTEGER
              ? i64_low(element.constantIntegerValue)
              : 0
          );
        }
        // fall-through
      }
      case TypeKind.I64:
      case TypeKind.U64: {
        return element.constantValueKind == ConstantValueKind.INTEGER
          ? this.module.i64(
              i64_low(element.constantIntegerValue),
              i64_high(element.constantIntegerValue)
            )
          : this.module.i64(0);
      }
      case TypeKind.F64: {
        // monkey-patch for converting built-in floats to f32 implicitly
        if (!(element.hasDecorator(DecoratorFlags.BUILTIN) && contextualType == Type.f32)) {
          return this.module.f64(element.constantFloatValue);
        }
        // otherwise fall-through: basically precomputes f32.demote/f64 of NaN / Infinity
        this.currentType = Type.f32;
      }
      case TypeKind.F32: {
        return this.module.f32(<f32>element.constantFloatValue);
      }
      default: {
        assert(false);
        return this.module.unreachable();
      }
    }
  }

  compileExpression(
    expression: Expression,
    contextualType: Type,
    constraints: Constraints = Constraints.NONE
  ): ExpressionRef {
    while (expression.kind == NodeKind.PARENTHESIZED) { // skip
      expression = (<ParenthesizedExpression>expression).expression;
    }
    this.currentType = contextualType;
    if (contextualType == Type.void) constraints |= Constraints.WILL_DROP;
    var expr: ExpressionRef;
    switch (expression.kind) {
      case NodeKind.ASSERTION: {
        expr = this.compileAssertionExpression(<AssertionExpression>expression, contextualType, constraints);
        break;
      }
      case NodeKind.BINARY: {
        expr = this.compileBinaryExpression(<BinaryExpression>expression, contextualType, constraints);
        break;
      }
      case NodeKind.CALL: {
        expr = this.compileCallExpression(<CallExpression>expression, contextualType, constraints);
        break;
      }
      case NodeKind.COMMA: {
        expr = this.compileCommaExpression(<CommaExpression>expression, contextualType, constraints);
        break;
      }
      case NodeKind.ELEMENTACCESS: {
        expr = this.compileElementAccessExpression(<ElementAccessExpression>expression, contextualType, constraints);
        break;
      }
      case NodeKind.FUNCTION: {
        expr = this.compileFunctionExpression(<FunctionExpression>expression, contextualType, constraints);
        break;
      }
      case NodeKind.IDENTIFIER:
      case NodeKind.FALSE:
      case NodeKind.NULL:
      case NodeKind.THIS:
      case NodeKind.SUPER:
      case NodeKind.TRUE: {
        expr = this.compileIdentifierExpression(<IdentifierExpression>expression, contextualType, constraints);
        break;
      }
      case NodeKind.INSTANCEOF: {
        expr = this.compileInstanceOfExpression(<InstanceOfExpression>expression, contextualType, constraints);
        break;
      }
      case NodeKind.LITERAL: {
        expr = this.compileLiteralExpression(<LiteralExpression>expression, contextualType, constraints);
        break;
      }
      case NodeKind.NEW: {
        expr = this.compileNewExpression(<NewExpression>expression, contextualType, constraints);
        break;
      }
      case NodeKind.PROPERTYACCESS: {
        expr = this.compilePropertyAccessExpression(<PropertyAccessExpression>expression, contextualType, constraints);
        break;
      }
      case NodeKind.TERNARY: {
        expr = this.compileTernaryExpression(<TernaryExpression>expression, contextualType, constraints);
        break;
      }
      case NodeKind.UNARYPOSTFIX: {
        expr = this.compileUnaryPostfixExpression(<UnaryPostfixExpression>expression, contextualType, constraints);
        break;
      }
      case NodeKind.UNARYPREFIX: {
        expr = this.compileUnaryPrefixExpression(<UnaryPrefixExpression>expression, contextualType, constraints);
        break;
      }
      case NodeKind.COMPILED: {
        let compiled = <CompiledExpression>expression;
        expr = compiled.expr;
        this.currentType = compiled.type;
        break;
      }
      case NodeKind.CLASS: {
        // TODO: compile as class expression
        this.error(
          DiagnosticCode.Not_implemented_0,
          expression.range,
          "Block-scoped class declarations or expressions"
        );
        expr = this.module.unreachable();
        break;
      }
      default: {
        assert(false);
        expr = this.module.unreachable();
      }
    }
    // ensure conversion and wrapping in case the respective function doesn't on its own
    var currentType = this.currentType;
    var wrap = (constraints & Constraints.MUST_WRAP) != 0;
    if (currentType != contextualType.nonNullableType) { // allow assigning non-nullable to nullable
      if (constraints & Constraints.CONV_EXPLICIT) {
        expr = this.convertExpression(expr, currentType, contextualType, true, expression);
        this.currentType = currentType = contextualType;
      } else if (constraints & Constraints.CONV_IMPLICIT) {
        expr = this.convertExpression(expr, currentType, contextualType, false, expression);
        this.currentType = currentType = contextualType;
      }
    }
    if (wrap) expr = this.ensureSmallIntegerWrap(expr, currentType);
    // debug location is added here so the caller doesn't have to. means: compilation of an expression
    // must go through this function, with the respective per-kind functions not being used directly.
    if (this.options.sourceMap) this.addDebugLocation(expr, expression.range);
    return expr;
  }

  /** Converts an expression's result from one type to another. */
  convertExpression(
    expr: ExpressionRef,
    /** Original type. */
    fromType: Type,
    /** New type. */
    toType: Type,
    /** Whether the conversion is explicit. */
    explicit: bool,
    /** Report node. */
    reportNode: Node
  ): ExpressionRef {
    var module = this.module;

    // void to any
    if (fromType.kind == TypeKind.VOID) {
      assert(toType.kind != TypeKind.VOID); // convertExpression should not be called with void -> void
      this.error(
        DiagnosticCode.Type_0_is_not_assignable_to_type_1,
        reportNode.range, fromType.toString(), toType.toString()
      );
      return module.unreachable();
    }

    // any to void
    if (toType.kind == TypeKind.VOID) return module.drop(expr);

    // reference involved
    if (fromType.isReference || toType.isReference) {
      if (this.currentFlow.isNonnull(expr, fromType)) {
        fromType = fromType.nonNullableType;
      } else if (explicit && fromType.isNullableReference && !toType.isNullableReference) {
        // explicit conversion from nullable to non-nullable requires a runtime
        // check here because nonnull state above already didn't know better
        if (!this.options.noAssert) {
          expr = this.makeRuntimeNonNullCheck(expr, fromType, reportNode);
        }
        fromType = fromType.nonNullableType;
      }
      if (fromType.isAssignableTo(toType)) { // downcast or same
        assert(toType.isExternalReference || fromType.kind == toType.kind);
        this.currentType = toType;
        return expr;
      }
      if (explicit && toType.nonNullableType.isAssignableTo(fromType)) { // upcast
        // <Cat | null>(<Animal>maybeCat)
        if (toType.isExternalReference) {
          this.error(
            DiagnosticCode.Not_implemented_0,
            reportNode.range,
            "ref.cast"
          );
          this.currentType = toType;
          return module.unreachable();
        }
        assert(fromType.kind == toType.kind);
        if (!this.options.noAssert) {
          expr = this.makeRuntimeUpcastCheck(expr, fromType, toType, reportNode);
        }
        this.currentType = toType;
        return expr;
      }
      this.error(
        DiagnosticCode.Type_0_is_not_assignable_to_type_1,
        reportNode.range, fromType.toString(), toType.toString()
      );
      this.currentType = toType;
      return module.unreachable();
    }

    // not dealing with references from here on
    assert(!fromType.isReference && !toType.isReference);

    if (!fromType.isAssignableTo(toType)) {
      if (!explicit) {
        this.error(
          DiagnosticCode.Conversion_from_type_0_to_1_requires_an_explicit_cast,
          reportNode.range, fromType.toString(), toType.toString()
        ); // recoverable
      }
    }

    if (fromType.isFloatValue) {

      // float to float
      if (toType.isFloatValue) {
        if (fromType.kind == TypeKind.F32) {

          // f32 to f64
          if (toType.kind == TypeKind.F64) {
            expr = module.unary(UnaryOp.PromoteF32ToF64, expr);
          }

          // otherwise f32 to f32

        // f64 to f32
        } else if (toType.kind == TypeKind.F32) {
          expr = module.unary(UnaryOp.DemoteF64ToF32, expr);
        }

        // otherwise f64 to f64

      // float to int
      } else if (toType.isIntegerValue) {

        // f32 to int
        if (fromType.kind == TypeKind.F32) {
          if (toType.isBooleanValue) {
            expr = this.makeIsTrueish(expr, Type.f32, reportNode);
          } else if (toType.isSignedIntegerValue) {
            let saturating = this.options.hasFeature(Feature.NONTRAPPING_F2I);
            if (toType.isLongIntegerValue) {
              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToI64 : UnaryOp.TruncF32ToI64, expr);
            } else {
              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToI32 : UnaryOp.TruncF32ToI32, expr);
            }
          } else {
            let saturating = this.options.hasFeature(Feature.NONTRAPPING_F2I);
            if (toType.isLongIntegerValue) {
              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToU64 : UnaryOp.TruncF32ToU64, expr);
            } else {
              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToU32 : UnaryOp.TruncF32ToU32, expr);
            }
          }

        // f64 to int
        } else {
          if (toType.isBooleanValue) {
            expr = this.makeIsTrueish(expr, Type.f64, reportNode);
          } else if (toType.isSignedIntegerValue) {
            let saturating = this.options.hasFeature(Feature.NONTRAPPING_F2I);
            if (toType.isLongIntegerValue) {
              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToI64 : UnaryOp.TruncF64ToI64, expr);
            } else {
              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToI32 : UnaryOp.TruncF64ToI32, expr);
            }
          } else {
            let saturating = this.options.hasFeature(Feature.NONTRAPPING_F2I);
            if (toType.isLongIntegerValue) {
              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToU64 : UnaryOp.TruncF64ToU64, expr);
            } else {
              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToU32 : UnaryOp.TruncF64ToU32, expr);
            }
          }
        }

      // float to void
      } else {
        assert(toType.flags == TypeFlags.NONE, "void type expected");
        expr = module.drop(expr);
      }

    // int to float
    } else if (fromType.isIntegerValue && toType.isFloatValue) {

      // int to f32
      if (toType.kind == TypeKind.F32) {
        if (fromType.isLongIntegerValue) {
          expr = module.unary(
            fromType.isSignedIntegerValue
              ? UnaryOp.ConvertI64ToF32
              : UnaryOp.ConvertU64ToF32,
            expr
          );
        } else {
          expr = module.unary(
            fromType.isSignedIntegerValue
              ? UnaryOp.ConvertI32ToF32
              : UnaryOp.ConvertU32ToF32,
            expr
          );
        }

      // int to f64
      } else {
        if (fromType.isLongIntegerValue) {
          expr = module.unary(
            fromType.isSignedIntegerValue
              ? UnaryOp.ConvertI64ToF64
              : UnaryOp.ConvertU64ToF64,
            expr
          );
        } else {
          expr = module.unary(
            fromType.isSignedIntegerValue
              ? UnaryOp.ConvertI32ToF64
              : UnaryOp.ConvertU32ToF64,
            expr
          );
        }
      }

    // int to int
    } else {
      // i64 to ...
      if (fromType.isLongIntegerValue) {

        // i64 to i32 or smaller
        if (toType.isBooleanValue) {
          expr = module.binary(BinaryOp.NeI64, expr, module.i64(0));
        } else if (!toType.isLongIntegerValue) {
          expr = module.unary(UnaryOp.WrapI64ToI32, expr); // discards upper bits
        }

      // i32 or smaller to i64
      } else if (toType.isLongIntegerValue) {
        expr = module.unary(
          fromType.isSignedIntegerValue ? UnaryOp.ExtendI32ToI64 : UnaryOp.ExtendU32ToU64,
          this.ensureSmallIntegerWrap(expr, fromType) // must clear garbage bits
        );

      // i32 to i32
      } else {
        // small i32 to ...
        if (fromType.isShortIntegerValue) {
          // small i32 to larger i32
          if (fromType.size < toType.size) {
            expr = this.ensureSmallIntegerWrap(expr, fromType); // must clear garbage bits
          }
        // same size
        } else {
          if (!explicit && !this.options.isWasm64 && fromType.isVaryingIntegerValue && !toType.isVaryingIntegerValue) {
            this.warning(
              DiagnosticCode.Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit,
              reportNode.range, fromType.toString(), toType.toString()
            );
          }
        }
      }
    }

    this.currentType = toType;
    return expr;
  }

  private compileAssertionExpression(
    expression: AssertionExpression,
    contextualType: Type,
    constraints: Constraints
  ): ExpressionRef {
    var inheritedConstraints = constraints & ~(Constraints.CONV_IMPLICIT | Constraints.CONV_EXPLICIT);
    switch (expression.assertionKind) {
      case AssertionKind.PREFIX:
      case AssertionKind.AS: {
        let flow = this.currentFlow;
        let toType = this.resolver.resolveType( // reports
          assert(expression.toType),
          flow.actualFunction,
          uniqueMap(flow.contextualTypeArguments)
        );
        if (!toType) return this.module.unreachable();
        return this.compileExpression(expression.expression, toType, inheritedConstraints | Constraints.CONV_EXPLICIT);
      }
      case AssertionKind.NONNULL: {
        assert(!expression.toType);
        let expr = this.compileExpression(expression.expression, contextualType.exceptVoid, inheritedConstraints);
        let type = this.currentType;
        if (this.currentFlow.isNonnull(expr, type)) {
          this.info(
            DiagnosticCode.Expression_is_never_null,
            expression.expression.range
          );
        } else if (!this.options.noAssert) {
          expr = this.makeRuntimeNonNullCheck(expr, type, expression);
        }
        this.currentType = type.nonNullableType;
        return expr;
      }
      case AssertionKind.CONST: {
        // TODO: decide on the layout of ReadonlyArray first
        // let operand = expression.expression;
        // if (operand.kind == NodeKind.LITERAL && (<LiteralExpression>operand).literalKind == LiteralKind.ARRAY) {
        //   let element = this.resolver.lookupExpression(expression /* ! */, this.currentFlow, contextualType);
        //   if (!element) return this.module.unreachable();
        //   if (element.kind == ElementKind.CLASS) {
        //     let arrayInstance = <Class>element;
        //     if (arrayInstance.extends(this.program.readonlyArrayPrototype)) {
        //       return this.compileStaticArrayLiteral(<ArrayLiteralExpression>operand, arrayInstance.type, constraints);
        //     }
        //   }
        // }
        this.error(
          DiagnosticCode.Not_implemented_0,
          expression.range,
          "Const assertion"
        );
        return this.module.unreachable();
      }
      default: assert(false);
    }
    return this.module.unreachable();
  }

  private f32ModInstance: Function | null = null;
  private f64ModInstance: Function | null = null;
  private f32PowInstance: Function | null = null;
  private f64PowInstance: Function | null = null;
  private i32PowInstance: Function | null = null;
  private i64PowInstance: Function | null = null;

  private compileBinaryExpression(
    expression: BinaryExpression,
    contextualType: Type,
    constraints: Constraints
  ): ExpressionRef {
    var module = this.module;
    var left = expression.left;
    var right = expression.right;

    var leftExpr: ExpressionRef;
    var leftType: Type;
    var rightExpr: ExpressionRef;
    var rightType: Type;
    var commonType: Type | null;

    var expr: ExpressionRef;
    var compound = false;

    var operator = expression.operator;
    switch (operator) {
      case Token.LESSTHAN: {
        leftExpr = this.compileExpression(left, contextualType);
        leftType = this.currentType;

        // check operator overload
        let classReference = leftType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.LT);
          if (overload) {
            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
            break;
          }
        }

        rightExpr = this.compileExpression(right, leftType);
        rightType = this.currentType;
        commonType = Type.commonDenominator(leftType, rightType, true);
        if (!commonType || !commonType.isNumericValue) {
          this.error(
            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,
            expression.range, "<", leftType.toString(), rightType.toString()
          );
          this.currentType = contextualType;
          return module.unreachable();
        }

        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);
        leftType = commonType;
        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);
        rightType = commonType;

        expr = this.makeLt(leftExpr, rightExpr, commonType);
        this.currentType = Type.bool;
        break;
      }
      case Token.GREATERTHAN: {
        leftExpr = this.compileExpression(left, contextualType);
        leftType = this.currentType;

        // check operator overload
        let classReference = leftType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.GT);
          if (overload) {
            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
            break;
          }
        }

        rightExpr = this.compileExpression(right, leftType);
        rightType = this.currentType;
        commonType = Type.commonDenominator(leftType, rightType, true);
        if (!commonType || !commonType.isNumericValue) {
          this.error(
            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,
            expression.range, ">", leftType.toString(), rightType.toString()
          );
          this.currentType = contextualType;
          return module.unreachable();
        }

        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);
        leftType = commonType;
        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);
        rightType = commonType;

        expr = this.makeGt(leftExpr, rightExpr, commonType);
        this.currentType = Type.bool;
        break;
      }
      case Token.LESSTHAN_EQUALS: {
        leftExpr = this.compileExpression(left, contextualType);
        leftType = this.currentType;

        // check operator overload
        let classReference = leftType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.LE);
          if (overload) {
            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
            break;
          }
        }

        rightExpr = this.compileExpression(right, leftType);
        rightType = this.currentType;
        commonType = Type.commonDenominator(leftType, rightType, true);
        if (!commonType || !commonType.isNumericValue) {
          this.error(
            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,
            expression.range, "<=", leftType.toString(), rightType.toString()
          );
          this.currentType = contextualType;
          return module.unreachable();
        }

        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);
        leftType = commonType;
        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);
        rightType = commonType;

        expr = this.makeLe(leftExpr, rightExpr, commonType);
        this.currentType = Type.bool;
        break;
      }
      case Token.GREATERTHAN_EQUALS: {
        leftExpr = this.compileExpression(left, contextualType);
        leftType = this.currentType;

        // check operator overload
        let classReference = leftType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.GE);
          if (overload) {
            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
            break;
          }
        }

        rightExpr = this.compileExpression(right, leftType);
        rightType = this.currentType;
        commonType = Type.commonDenominator(leftType, rightType, true);
        if (!commonType || !commonType.isNumericValue) {
          this.error(
            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,
            expression.range, ">=", leftType.toString(), rightType.toString()
          );
          this.currentType = contextualType;
          return module.unreachable();
        }

        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);
        leftType = commonType;
        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);
        rightType = commonType;

        expr = this.makeGe(leftExpr, rightExpr, commonType);
        this.currentType = Type.bool;
        break;
      }

      case Token.EQUALS_EQUALS_EQUALS:
      case Token.EQUALS_EQUALS: {
        leftExpr = this.compileExpression(left, contextualType);
        leftType = this.currentType;

        // check operator overload
        if (operator == Token.EQUALS_EQUALS) { // can't overload '==='
          let classReference = leftType.getClassOrWrapper(this.program);
          if (classReference) {
            let overload = classReference.lookupOverload(OperatorKind.EQ);
            if (overload) {
              expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
              break;
            }
          }
          // fall back to compare by value
        }

        rightExpr = this.compileExpression(right, leftType);
        rightType = this.currentType;
        commonType = Type.commonDenominator(leftType, rightType, false);
        if (!commonType) {
          this.error(
            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,
            expression.range, operatorTokenToString(expression.operator), leftType.toString(), rightType.toString()
          );
          this.currentType = contextualType;
          return module.unreachable();
        }

        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);
        leftType = commonType;
        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);
        rightType = commonType;

        expr = this.makeEq(leftExpr, rightExpr, commonType, expression);
        this.currentType = Type.bool;
        break;
      }
      case Token.EXCLAMATION_EQUALS_EQUALS:
      case Token.EXCLAMATION_EQUALS: {
        leftExpr = this.compileExpression(left, contextualType);
        leftType = this.currentType;

        // check operator overload
        if (operator == Token.EXCLAMATION_EQUALS) { // can't overload '!=='
          let classReference = leftType.getClass();
          if (classReference) {
            let overload = classReference.lookupOverload(OperatorKind.NE);
            if (overload) {
              expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
              break;
            }
          }
          // fall back to compare by value
        }

        rightExpr = this.compileExpression(right, leftType);
        rightType = this.currentType;
        commonType = Type.commonDenominator(leftType, rightType, false);
        if (!commonType) {
          this.error(
            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,
            expression.range, operatorTokenToString(expression.operator), leftType.toString(), rightType.toString()
          );
          this.currentType = contextualType;
          return module.unreachable();
        }

        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);
        leftType = commonType;
        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);
        rightType = commonType;

        expr = this.makeNe(leftExpr, rightExpr, commonType, expression);
        this.currentType = Type.bool;
        break;
      }
      case Token.EQUALS: {
        return this.compileAssignment(left, right, contextualType);
      }
      case Token.PLUS_EQUALS: compound = true;
      case Token.PLUS: {
        leftExpr = this.compileExpression(left, contextualType);
        leftType = this.currentType;

        // check operator overload
        let classReference = leftType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.ADD);
          if (overload) {
            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
            break;
          }
        }
        if (compound) {
          if (!leftType.isNumericValue) {
            this.error(
              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
              expression.range, "+", leftType.toString()
            );
            return module.unreachable();
          }
          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);
          rightType = commonType = this.currentType;
        } else {
          rightExpr = this.compileExpression(right, leftType);
          rightType = this.currentType;
          commonType = Type.commonDenominator(leftType, rightType, false);
          if (!commonType || !commonType.isNumericValue) {
            this.error(
              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,
              expression.range, "+", leftType.toString(), rightType.toString()
            );
            this.currentType = contextualType;
            return module.unreachable();
          }
          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);
          leftType = commonType;
          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);
          rightType = commonType;
        }
        expr = this.makeAdd(leftExpr, rightExpr, commonType);
        break;
      }
      case Token.MINUS_EQUALS: compound = true;
      case Token.MINUS: {
        leftExpr = this.compileExpression(left, contextualType);
        leftType = this.currentType;

        // check operator overload
        let classReference = leftType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.SUB);
          if (overload) {
            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
            break;
          }
        }

        if (compound) {
          if (!leftType.isNumericValue) {
            this.error(
              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
              expression.range, "-", leftType.toString()
            );
            return module.unreachable();
          }
          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);
          rightType = commonType = this.currentType;
        } else {
          rightExpr = this.compileExpression(right, leftType);
          rightType = this.currentType;
          commonType = Type.commonDenominator(leftType, rightType, false);
          if (!commonType || !leftType.isNumericValue) {
            this.error(
              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,
              expression.range, "-", leftType.toString(), rightType.toString()
            );
            this.currentType = contextualType;
            return module.unreachable();
          }
          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);
          leftType = commonType;
          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);
          rightType = commonType;
        }
        expr = this.makeSub(leftExpr, rightExpr, commonType);
        break;
      }
      case Token.ASTERISK_EQUALS: compound = true;
      case Token.ASTERISK: {
        leftExpr = this.compileExpression(left, contextualType);
        leftType = this.currentType;

        // check operator overload
        let classReference = leftType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.MUL);
          if (overload) {
            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
            break;
          }
        }

        if (compound) {
          if (!leftType.isNumericValue) {
            this.error(
              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
              expression.range, "*", leftType.toString()
            );
            return module.unreachable();
          }
          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);
          rightType = commonType = this.currentType;
        } else {
          rightExpr = this.compileExpression(right, leftType);
          rightType = this.currentType;
          commonType = Type.commonDenominator(leftType, rightType, false);
          if (!commonType || !commonType.isNumericValue) {
            this.error(
              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,
              expression.range, "*", leftType.toString(), rightType.toString()
            );
            this.currentType = contextualType;
            return module.unreachable();
          }
          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);
          leftType = commonType;
          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);
          rightType = commonType;
        }
        expr = this.makeMul(leftExpr, rightExpr, commonType);
        break;
      }
      case Token.ASTERISK_ASTERISK_EQUALS: compound = true;
      case Token.ASTERISK_ASTERISK: {
        leftExpr = this.compileExpression(left, contextualType);
        leftType = this.currentType;

        // check operator overload
        let classReference = leftType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.POW);
          if (overload) {
            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
            break;
          }
        }

        if (compound) {
          if (!leftType.isNumericValue) {
            this.error(
              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
              expression.range, "**", leftType.toString()
            );
            return module.unreachable();
          }
          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);
          rightType = commonType = this.currentType;
        } else {
          rightExpr = this.compileExpression(right, leftType);
          rightType = this.currentType;
          commonType = Type.commonDenominator(leftType, rightType, false);
          if (!commonType || !commonType.isNumericValue) {
            this.error(
              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,
              expression.range, "**", leftType.toString(), rightType.toString()
            );
            this.currentType = contextualType;
            return module.unreachable();
          }
          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);
          leftType = commonType;
          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);
          rightType = commonType;
        }
        expr = this.makePow(leftExpr, rightExpr, commonType, expression);
        break;
      }
      case Token.SLASH_EQUALS: compound = true;
      case Token.SLASH: {
        leftExpr = this.compileExpression(left, contextualType);
        leftType = this.currentType;

        // check operator overload
        let classReference = leftType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.DIV);
          if (overload) {
            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
            break;
          }
        }

        if (compound) {
          if (!leftType.isNumericValue) {
            this.error(
              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
              expression.range, "/", leftType.toString()
            );
            return module.unreachable();
          }
          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);
          rightType = commonType = this.currentType;
        } else {
          rightExpr = this.compileExpression(right, leftType);
          rightType = this.currentType;
          commonType = Type.commonDenominator(leftType, rightType, false);
          if (!commonType || !commonType.isNumericValue) {
            this.error(
              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,
              expression.range, "/", leftType.toString(), rightType.toString()
            );
            this.currentType = contextualType;
            return module.unreachable();
          }
          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);
          leftType = commonType;
          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);
          rightType = commonType;
        }
        expr = this.makeDiv(leftExpr, rightExpr, commonType);
        break;
      }
      case Token.PERCENT_EQUALS: compound = true;
      case Token.PERCENT: {
        leftExpr = this.compileExpression(left, contextualType);
        leftType = this.currentType;

        // check operator overload
        let classReference = leftType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.REM);
          if (overload) {
            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
            break;
          }
        }

        if (compound) {
          if (!leftType.isNumericValue) {
            this.error(
              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
              expression.range, "%", leftType.toString()
            );
            return module.unreachable();
          }
          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);
          rightType = commonType = this.currentType;
        } else {
          rightExpr = this.compileExpression(right, leftType);
          rightType = this.currentType;
          commonType = Type.commonDenominator(leftType, rightType, false);
          if (!commonType || !commonType.isNumericValue) {
            this.error(
              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,
              expression.range, "%", leftType.toString(), rightType.toString()
            );
            this.currentType = contextualType;
            return module.unreachable();
          }
          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);
          leftType = commonType;
          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);
          rightType = commonType;
        }
        expr = this.makeRem(leftExpr, rightExpr, commonType, expression);
        break;
      }
      case Token.LESSTHAN_LESSTHAN_EQUALS: compound = true;
      case Token.LESSTHAN_LESSTHAN: {
        leftExpr = this.compileExpression(left, contextualType.intType);
        leftType = this.currentType;

        // check operator overload
        let classReference = leftType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.BITWISE_SHL);
          if (overload) {
            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
            break;
          }
        }
        if (!leftType.isIntegerValue) {
          this.error(
            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
            expression.range, "<<", leftType.toString()
          );
          return module.unreachable();
        }
        rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);
        rightType = this.currentType;

        expr = this.makeShl(leftExpr, rightExpr, rightType);
        break;
      }
      case Token.GREATERTHAN_GREATERTHAN_EQUALS: compound = true;
      case Token.GREATERTHAN_GREATERTHAN: {
        leftExpr = this.compileExpression(left, contextualType.intType);
        leftType = this.currentType;

        // check operator overload
        let classReference = leftType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.BITWISE_SHR);
          if (overload) {
            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
            break;
          }
        }
        if (!leftType.isIntegerValue) {
          this.error(
            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
            expression.range, ">>", leftType.toString()
          );
          return this.module.unreachable();
        }

        rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);
        rightType = this.currentType;

        expr = this.makeShr(leftExpr, rightExpr, rightType);
        break;
      }
      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS: compound = true;
      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: {
        leftExpr = this.compileExpression(left, contextualType.intType);
        leftType = this.currentType;

        // check operator overload
        let classReference = leftType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.BITWISE_SHR_U);
          if (overload) {
            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
            break;
          }
        }
        if (!leftType.isIntegerValue) {
          this.error(
            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
            expression.range, ">>>", leftType.toString()
          );
          return module.unreachable();
        }
        rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);
        rightType = this.currentType;

        expr = this.makeShru(leftExpr, rightExpr, rightType);
        break;
      }
      case Token.AMPERSAND_EQUALS: compound = true;
      case Token.AMPERSAND: {
        leftExpr = this.compileExpression(left, contextualType.intType);
        leftType = this.currentType;

        // check operator overloadd
        let classReference = leftType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.BITWISE_AND);
          if (overload) {
            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
            break;
          }
        }

        if (compound) {
          if (!leftType.isIntegerValue) {
            this.error(
              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
              expression.range, "&", leftType.toString()
            );
            return module.unreachable();
          }
          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);
          rightType = commonType = this.currentType;
        } else {
          rightExpr = this.compileExpression(right, leftType);
          rightType = this.currentType;
          commonType = Type.commonDenominator(leftType, rightType, false);
          if (!commonType || !commonType.isIntegerValue) {
            this.error(
              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,
              expression.range, "&", leftType.toString(), rightType.toString()
            );
            this.currentType = contextualType;
            return module.unreachable();
          }
          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);
          leftType = commonType;
          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);
          rightType = commonType;
        }
        expr = this.makeAnd(leftExpr, rightExpr, commonType);
        break;
      }
      case Token.BAR_EQUALS: compound = true;
      case Token.BAR: {
        leftExpr = this.compileExpression(left, contextualType.intType);
        leftType = this.currentType;

        // check operator overload
        let classReference = leftType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.BITWISE_OR);
          if (overload) {
            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
            break;
          }
        }

        if (compound) {
          if (!leftType.isIntegerValue) {
            this.error(
              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
              expression.range, "|", leftType.toString()
            );
            return module.unreachable();
          }
          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);
          rightType = commonType = this.currentType;
        } else {
          rightExpr = this.compileExpression(right, leftType);
          rightType = this.currentType;
          commonType = Type.commonDenominator(leftType, rightType, false);
          if (!commonType || !commonType.isIntegerValue) {
            this.error(
              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,
              expression.range, "|", leftType.toString(), rightType.toString()
            );
            this.currentType = contextualType;
            return module.unreachable();
          }
          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);
          leftType = commonType;
          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);
          rightType = commonType;
        }
        expr = this.makeOr(leftExpr, rightExpr, commonType);
        break;
      }
      case Token.CARET_EQUALS: compound = true;
      case Token.CARET: {
        leftExpr = this.compileExpression(left, contextualType.intType);
        leftType = this.currentType;

        // check operator overload
        let classReference = leftType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.BITWISE_XOR);
          if (overload) {
            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
            break;
          }
        }

        if (compound) {
          if (!leftType.isIntegerValue) {
            this.error(
              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
              expression.range, "^", leftType.toString()
            );
            return module.unreachable();
          }
          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);
          rightType = commonType = this.currentType;
        } else {
          rightExpr = this.compileExpression(right, leftType);
          rightType = this.currentType;
          commonType = Type.commonDenominator(leftType, rightType, false);
          if (!commonType || !commonType.isIntegerValue) {
            this.error(
              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,
              expression.range, "^", leftType.toString(), rightType.toString()
            );
            this.currentType = contextualType;
            return module.unreachable();
          }
          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);
          leftType = commonType;
          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);
          rightType = commonType;
        }
        expr = this.makeXor(leftExpr, rightExpr, commonType);
        break;
      }

      // logical (no overloading)

      case Token.AMPERSAND_AMPERSAND: { // left && right -> (t = left) ? right : t
        let flow = this.currentFlow;
        let inheritedConstraints = constraints & Constraints.MUST_WRAP;
        leftExpr = this.compileExpression(left, contextualType.exceptVoid, inheritedConstraints);
        leftType = this.currentType;

        let rightFlow = flow.fork();
        this.currentFlow = rightFlow;
        rightFlow.inheritNonnullIfTrue(leftExpr);

        // simplify if only interested in true or false
        if (contextualType == Type.bool || contextualType == Type.void) {
          leftExpr = this.makeIsTrueish(leftExpr, leftType, left);

          // shortcut if lhs is always false
          let condKind = this.evaluateCondition(leftExpr);
          if (condKind == ConditionKind.FALSE) {
            expr = leftExpr;
          } else {
            rightExpr = this.compileExpression(right, leftType, inheritedConstraints);
            rightType = this.currentType;
            rightFlow.freeScopedLocals();
            rightExpr = this.makeIsTrueish(rightExpr, rightType, right);

            // simplify if lhs is always true
            if (condKind == ConditionKind.TRUE) {
              expr = rightExpr;
            } else {
              expr = module.if(leftExpr, rightExpr, module.i32(0));
            }
          }
          this.currentFlow = flow;
          this.currentType = Type.bool;

        } else {
          rightExpr = this.compileExpression(right, leftType, inheritedConstraints | Constraints.CONV_IMPLICIT);
          rightType = this.currentType;
          rightFlow.freeScopedLocals();
          this.currentFlow = flow;

          // simplify if cloning left without side effects is possible
          if (expr = module.cloneExpression(leftExpr, true, 0)) {
            expr = module.if(
              this.makeIsTrueish(leftExpr, this.currentType, left),
              rightExpr,
              expr
            );

          // if not possible, tee left to a temp
          } else {
            let tempLocal = flow.getTempLocal(leftType);
            if (!flow.canOverflow(leftExpr, leftType)) flow.setLocalFlag(tempLocal.index, LocalFlags.WRAPPED);
            if (flow.isNonnull(leftExpr, leftType)) flow.setLocalFlag(tempLocal.index, LocalFlags.NONNULL);
            expr = module.if(
              this.makeIsTrueish(module.local_tee(tempLocal.index, leftExpr, leftType.isManaged), leftType, left),
              rightExpr,
              module.local_get(tempLocal.index, leftType.toRef())
            );
            flow.freeTempLocal(tempLocal);
          }
          this.currentType = leftType;
        }
        break;
      }
      case Token.BAR_BAR: { // left || right -> ((t = left) ? t : right)
        let flow = this.currentFlow;
        let inheritedConstraints = constraints & Constraints.MUST_WRAP;
        leftExpr = this.compileExpression(left, contextualType.exceptVoid, inheritedConstraints);
        leftType = this.currentType;

        let rightFlow = flow.fork();
        this.currentFlow = rightFlow;
        rightFlow.inheritNonnullIfFalse(leftExpr);

        // simplify if only interested in true or false
        if (contextualType == Type.bool || contextualType == Type.void) {
          leftExpr = this.makeIsTrueish(leftExpr, leftType, left);

          // shortcut if lhs is always true
          let condKind = this.evaluateCondition(leftExpr);
          if (condKind == ConditionKind.TRUE) {
            expr = leftExpr;
          } else {
            rightExpr = this.compileExpression(right, leftType, inheritedConstraints);
            rightType = this.currentType;
            rightFlow.freeScopedLocals();
            rightExpr = this.makeIsTrueish(rightExpr, rightType, right);

            // simplify if lhs is always false
            if (condKind == ConditionKind.FALSE) {
              expr = rightExpr;
            } else {
              expr = module.if(leftExpr, module.i32(1), rightExpr);
            }
          }
          this.currentFlow = flow;
          this.currentType = Type.bool;

        } else {
          rightExpr = this.compileExpression(right, leftType, inheritedConstraints | Constraints.CONV_IMPLICIT);
          rightType = this.currentType;
          rightFlow.freeScopedLocals();
          this.currentFlow = flow;

          // simplify if cloning left without side effects is possible
          if (expr = module.cloneExpression(leftExpr, true, 0)) {
            expr = module.if(
              this.makeIsTrueish(leftExpr, leftType, left),
              expr,
              rightExpr
            );

          // if not possible, tee left to a temp. local
          } else {
            let temp = flow.getTempLocal(leftType);
            if (!flow.canOverflow(leftExpr, leftType)) flow.setLocalFlag(temp.index, LocalFlags.WRAPPED);
            if (flow.isNonnull(leftExpr, leftType)) flow.setLocalFlag(temp.index, LocalFlags.NONNULL);
            expr = module.if(
              this.makeIsTrueish(module.local_tee(temp.index, leftExpr, leftType.isManaged), leftType, left),
              module.local_get(temp.index, leftType.toRef()),
              rightExpr
            );
            flow.freeTempLocal(temp);
          }
          this.currentType = leftType;
        }
        break;
      }
      default: {
        assert(false);
        expr = this.module.unreachable();
      }
    }
    if (!compound) return expr;
    var resolver = this.resolver;
    var target = resolver.lookupExpression(left, this.currentFlow);
    if (!target) return module.unreachable();
    var targetType = resolver.getTypeOfElement(target);
    if (!targetType) targetType = Type.void;
    if (!this.currentType.isStrictlyAssignableTo(targetType)) {
      this.error(
        DiagnosticCode.Type_0_is_not_assignable_to_type_1,
        expression.range, this.currentType.toString(), targetType.toString()
      );
      return module.unreachable();
    }
    return this.makeAssignment(
      target,
      expr,
      this.currentType,
      right,
      resolver.currentThisExpression,
      resolver.currentElementExpression,
      contextualType != Type.void
    );
  }

  makeLt(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {
    // Cares about garbage bits and signedness
    var module = this.module;
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.I16: {
        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);
        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);
        // falls through
      }
      case TypeKind.I32: {
        return module.binary(BinaryOp.LtI32, leftExpr, rightExpr);
      }
      case TypeKind.I64: {
        return module.binary(BinaryOp.LtI64, leftExpr, rightExpr);
      }
      case TypeKind.ISIZE: {
        return module.binary(
          this.options.isWasm64
            ? BinaryOp.LtI64
            : BinaryOp.LtI32,
          leftExpr,
          rightExpr
        );
      }
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.BOOL: {
        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);
        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);
        // falls through
      }
      case TypeKind.U32: {
        return module.binary(BinaryOp.LtU32, leftExpr, rightExpr);
      }
      case TypeKind.USIZE: {
        return module.binary(
          this.options.isWasm64
            ? BinaryOp.LtU64
            : BinaryOp.LtU32,
          leftExpr,
          rightExpr
        );
      }
      case TypeKind.U64: {
        return module.binary(BinaryOp.LtU64, leftExpr, rightExpr);
      }
      case TypeKind.F32: {
        return module.binary(BinaryOp.LtF32, leftExpr, rightExpr);
      }
      case TypeKind.F64: {
        return module.binary(BinaryOp.LtF64, leftExpr, rightExpr);
      }
    }
    assert(false);
    return module.unreachable();
  }

  makeGt(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {
    // Cares about garbage bits and signedness
    var module = this.module;
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.I16: {
        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);
        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);
        // falls through
      }
      case TypeKind.I32: {
        return module.binary(BinaryOp.GtI32, leftExpr, rightExpr);
      }
      case TypeKind.ISIZE: {
        return module.binary(
          this.options.isWasm64
            ? BinaryOp.GtI64
            : BinaryOp.GtI32,
          leftExpr,
          rightExpr
        );
      }
      case TypeKind.I64: {
        return module.binary(BinaryOp.GtI64, leftExpr, rightExpr);
      }
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.BOOL: {
        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);
        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);
        // falls through
      }
      case TypeKind.U32: {
        return module.binary(BinaryOp.GtU32, leftExpr, rightExpr);
      }
      case TypeKind.USIZE: {
        return module.binary(
          this.options.isWasm64
            ? BinaryOp.GtU64
            : BinaryOp.GtU32,
          leftExpr,
          rightExpr
        );
      }
      case TypeKind.U64: {
        return module.binary(BinaryOp.GtU64, leftExpr, rightExpr);
      }
      case TypeKind.F32: {
        return module.binary(BinaryOp.GtF32, leftExpr, rightExpr);
      }
      case TypeKind.F64: {
        return module.binary(BinaryOp.GtF64, leftExpr, rightExpr);
      }
    }
    assert(false);
    return module.unreachable();
  }

  makeLe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {
    // Cares about garbage bits and signedness
    var module = this.module;
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.I16: {
        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);
        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);
        // falls through
      }
      case TypeKind.I32: {
        return module.binary(BinaryOp.LeI32, leftExpr, rightExpr);
      }
      case TypeKind.ISIZE: {
        return module.binary(
          this.options.isWasm64
            ? BinaryOp.LeI64
            : BinaryOp.LeI32,
          leftExpr,
          rightExpr
        );
      }
      case TypeKind.I64: {
        return module.binary(BinaryOp.LeI64, leftExpr, rightExpr);
      }
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.BOOL: {
        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);
        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);
        // falls through
      }
      case TypeKind.U32: {
        return module.binary(BinaryOp.LeU32, leftExpr, rightExpr);
      }
      case TypeKind.USIZE: {
        return module.binary(
          this.options.isWasm64
            ? BinaryOp.LeU64
            : BinaryOp.LeU32,
          leftExpr,
          rightExpr
        );
      }
      case TypeKind.U64: {
        return module.binary(BinaryOp.LeU64, leftExpr, rightExpr);
      }
      case TypeKind.F32: {
        return module.binary(BinaryOp.LeF32, leftExpr, rightExpr);
      }
      case TypeKind.F64: {
        return module.binary(BinaryOp.LeF64, leftExpr, rightExpr);
      }
    }
    assert(false);
    return module.unreachable();
  }

  makeGe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {
    // Cares about garbage bits and signedness
    var module = this.module;
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.I16: {
        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);
        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);
        // falls through
      }
      case TypeKind.I32: {
        return module.binary(BinaryOp.GeI32, leftExpr, rightExpr);
      }
      case TypeKind.ISIZE: {
        return module.binary(
          this.options.isWasm64
            ? BinaryOp.GeI64
            : BinaryOp.GeI32,
          leftExpr,
          rightExpr
        );
      }
      case TypeKind.I64: {
        return module.binary(BinaryOp.GeI64, leftExpr, rightExpr);
      }
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.BOOL: {
        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);
        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);
        // falls through
      }
      case TypeKind.U32: {
        return module.binary(BinaryOp.GeU32, leftExpr, rightExpr);
      }
      case TypeKind.USIZE: {
        return module.binary(
          this.options.isWasm64
            ? BinaryOp.GeU64
            : BinaryOp.GeU32,
          leftExpr,
          rightExpr
        );
      }
      case TypeKind.U64: {
        return module.binary(BinaryOp.GeU64, leftExpr, rightExpr);
      }
      case TypeKind.F32: {
        return module.binary(BinaryOp.GeF32, leftExpr, rightExpr);
      }
      case TypeKind.F64: {
        return module.binary(BinaryOp.GeF64, leftExpr, rightExpr);
      }
    }
    assert(false);
    return module.unreachable();
  }

  makeEq(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {
    // Cares about garbage bits
    var module = this.module;
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.BOOL: {
        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);
        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);
        // falls through
      }
      case TypeKind.I32:
      case TypeKind.U32: {
        return module.binary(BinaryOp.EqI32, leftExpr, rightExpr);
      }
      case TypeKind.ISIZE:
      case TypeKind.USIZE: {
        return module.binary(
          this.options.isWasm64
            ? BinaryOp.EqI64
            : BinaryOp.EqI32,
          leftExpr,
          rightExpr
        );
      }
      case TypeKind.I64:
      case TypeKind.U64: {
        return module.binary(BinaryOp.EqI64, leftExpr, rightExpr);
      }
      case TypeKind.F32: {
        return module.binary(BinaryOp.EqF32, leftExpr, rightExpr);
      }
      case TypeKind.F64: {
        return module.binary(BinaryOp.EqF64, leftExpr, rightExpr);
      }
      case TypeKind.V128: {
        return module.unary(UnaryOp.AllTrueI8x16,
          module.binary(BinaryOp.EqI8x16, leftExpr, rightExpr)
        );
      }
      case TypeKind.EQREF:
      case TypeKind.I31REF:
      case TypeKind.DATAREF: {
        return module.ref_eq(leftExpr, rightExpr);
      }
      case TypeKind.FUNCREF:
      case TypeKind.EXTERNREF:
      case TypeKind.ANYREF: {
        this.error(
          DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
          reportNode.range,
          "ref.eq",
          type.toString()
        );
        return module.unreachable();
      }
    }
    assert(false);
    return module.unreachable();
  }

  makeNe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {
    // Cares about garbage bits
    var module = this.module;
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.BOOL: {
        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);
        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);
        // falls through
      }
      case TypeKind.I32:
      case TypeKind.U32: {
        return module.binary(BinaryOp.NeI32, leftExpr, rightExpr);
      }
      case TypeKind.USIZE:
      case TypeKind.ISIZE: {
        return module.binary(
          this.options.isWasm64
            ? BinaryOp.NeI64
            : BinaryOp.NeI32,
          leftExpr,
          rightExpr
        );
      }
      case TypeKind.I64:
      case TypeKind.U64: {
        return module.binary(BinaryOp.NeI64, leftExpr, rightExpr);
      }
      case TypeKind.F32: {
        return module.binary(BinaryOp.NeF32, leftExpr, rightExpr);
      }
      case TypeKind.F64: {
        return module.binary(BinaryOp.NeF64, leftExpr, rightExpr);
      }
      case TypeKind.V128: {
        return module.unary(UnaryOp.AnyTrueV128,
          module.binary(BinaryOp.NeI8x16, leftExpr, rightExpr)
        );
      }
      case TypeKind.EQREF:
      case TypeKind.I31REF:
      case TypeKind.DATAREF: {
        return module.unary(UnaryOp.EqzI32,
          module.ref_eq(leftExpr, rightExpr)
        );
      }
      case TypeKind.FUNCREF:
      case TypeKind.EXTERNREF:
      case TypeKind.ANYREF: {
        this.error(
          DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,
          reportNode.range,
          "ref.eq",
          type.toString()
        );
        return module.unreachable();
      }
    }
    assert(false);
    return module.unreachable();
  }

  makeAdd(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {
    // Does not care about garbage bits or signedness
    var module = this.module;
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.BOOL:
      case TypeKind.I32:
      case TypeKind.U32: {
        return module.binary(BinaryOp.AddI32, leftExpr, rightExpr);
      }
      case TypeKind.USIZE:
      case TypeKind.ISIZE: {
        return module.binary(
          this.options.isWasm64
            ? BinaryOp.AddI64
            : BinaryOp.AddI32,
          leftExpr,
          rightExpr
        );
      }
      case TypeKind.I64:
      case TypeKind.U64: {
        return module.binary(BinaryOp.AddI64, leftExpr, rightExpr);
      }
      case TypeKind.F32: {
        return module.binary(BinaryOp.AddF32, leftExpr, rightExpr);
      }
      case TypeKind.F64: {
        return module.binary(BinaryOp.AddF64, leftExpr, rightExpr);
      }
    }
    assert(false);
    return module.unreachable();
  }

  makeSub(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {
    // Does not care about garbage bits or signedness
    var module = this.module;
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.BOOL:
      case TypeKind.I32:
      case TypeKind.U32: {
        return module.binary(BinaryOp.SubI32, leftExpr, rightExpr);
      }
      case TypeKind.USIZE:
      case TypeKind.ISIZE: {
        return module.binary(
          this.options.isWasm64
            ? BinaryOp.SubI64
            : BinaryOp.SubI32,
          leftExpr,
          rightExpr
        );
      }
      case TypeKind.I64:
      case TypeKind.U64: {
        return module.binary(BinaryOp.SubI64, leftExpr, rightExpr);
      }
      case TypeKind.F32: {
        return module.binary(BinaryOp.SubF32, leftExpr, rightExpr);
      }
      case TypeKind.F64: {
        return module.binary(BinaryOp.SubF64, leftExpr, rightExpr);
      }
    }
    assert(false);
    return module.unreachable();
  }

  makeMul(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {
    // Does not care about garbage bits or signedness
    var module = this.module;
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.BOOL:
      case TypeKind.I32:
      case TypeKind.U32: {
        return module.binary(BinaryOp.MulI32, leftExpr, rightExpr);
      }
      case TypeKind.USIZE:
      case TypeKind.ISIZE: {
        return module.binary(
          this.options.isWasm64
            ? BinaryOp.MulI64
            : BinaryOp.MulI32,
          leftExpr,
          rightExpr
        );
      }
      case TypeKind.I64:
      case TypeKind.U64: {
        return module.binary(BinaryOp.MulI64, leftExpr, rightExpr);
      }
      case TypeKind.F32: {
        return module.binary(BinaryOp.MulF32, leftExpr, rightExpr);
      }
      case TypeKind.F64: {
        return module.binary(BinaryOp.MulF64, leftExpr, rightExpr);
      }
    }
    assert(false);
    return module.unreachable();
  }

  makePow(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {
    // Cares about garbage bits
    let module = this.module;
    switch (type.kind) {
      case TypeKind.BOOL: {
        return module.select(
          module.i32(1),
          module.binary(BinaryOp.EqI32, rightExpr, module.i32(0)),
          leftExpr
        );
      }
      case TypeKind.I8:
      case TypeKind.U8:
      case TypeKind.I16:
      case TypeKind.U16: {
        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);
        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);
        // falls through
      }
      case TypeKind.I32:
      case TypeKind.U32: {
        let instance = this.i32PowInstance;
        if (!instance) {
          let prototype = this.program.lookup(CommonNames.ipow32);
          if (!prototype) {
            this.error(
              DiagnosticCode.Cannot_find_name_0,
              reportNode.range, "ipow32"
            );
            return module.unreachable();
          }
          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);
          this.i32PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);
        }
        if (!instance || !this.compileFunction(instance)) {
          return module.unreachable();
        }
        let expr = this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);
        if (type.size < 32) {
          // TODO: this is necessary because i32PowInstance is generic, and deals with 32-bit integers,
          // so its flow does not indicate whether returned SMIs are wrapped. worth to avoid?
          expr = this.ensureSmallIntegerWrap(expr, type);
        }
        return expr;
      }
      case TypeKind.I64:
      case TypeKind.U64: {
        let instance = this.i64PowInstance;
        if (!instance) {
          let prototype = this.program.lookup(CommonNames.ipow64);
          if (!prototype) {
            this.error(
              DiagnosticCode.Cannot_find_name_0,
              reportNode.range, "ipow64"
            );
            return module.unreachable();
          }
          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);
          this.i64PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);
        }
        if (!instance || !this.compileFunction(instance)) {
          return module.unreachable();
        }
        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);
      }
      case TypeKind.ISIZE:
      case TypeKind.USIZE: {
        let isWasm64 = this.options.isWasm64;
        let instance = isWasm64 ? this.i64PowInstance : this.i32PowInstance;
        if (!instance) {
          let prototype = this.program.lookup(isWasm64 ? CommonNames.ipow64 : CommonNames.ipow32);
          if (!prototype) {
            this.error(
              DiagnosticCode.Cannot_find_name_0,
              reportNode.range, isWasm64 ? "ipow64" : "ipow32"
            );
            return module.unreachable();
          }
          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);
          instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);
          if (isWasm64) {
            this.i64PowInstance = instance;
          } else {
            this.i32PowInstance = instance;
          }
        }
        if (!instance || !this.compileFunction(instance)) {
          return module.unreachable();
        }
        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);
      }
      case TypeKind.F32: {
        let instance = this.f32PowInstance;
        if (!instance) {
          let namespace = this.program.lookup(CommonNames.Mathf);
          if (!namespace) {
            this.error(
              DiagnosticCode.Cannot_find_name_0,
              reportNode.range, "Mathf"
            );
            return module.unreachable();
          }
          let namespaceMembers = namespace.members;
          if (!namespaceMembers || !namespaceMembers.has(CommonNames.pow)) {
            this.error(
              DiagnosticCode.Cannot_find_name_0,
              reportNode.range, "Mathf.pow"
            );
            return module.unreachable();
          }
          let prototype = assert(namespaceMembers.get(CommonNames.pow));
          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);
          this.f32PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);
        }
        if (!instance || !this.compileFunction(instance)) {
          return module.unreachable();
        }
        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);
      }
      // Math.pow otherwise (result is f64)
      case TypeKind.F64: {
        let instance = this.f64PowInstance;
        if (!instance) {
          let namespace = this.program.lookup(CommonNames.Math);
          if (!namespace) {
            this.error(
              DiagnosticCode.Cannot_find_name_0,
              reportNode.range, "Math"
            );
            return module.unreachable();
          }
          let namespaceMembers = namespace.members;
          if (!namespaceMembers || !namespaceMembers.has(CommonNames.pow)) {
            this.error(
              DiagnosticCode.Cannot_find_name_0,
              reportNode.range, "Math.pow"
            );
            return module.unreachable();
          }
          let prototype = assert(namespaceMembers.get(CommonNames.pow));
          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);
          this.f64PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);
        }
        if (!instance || !this.compileFunction(instance)) {
          return module.unreachable();
        }
        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);
      }
    }
    assert(false);
    return module.unreachable();
  }

  makeDiv(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {
    // Cares about garbage bits and signedness
    var module = this.module;
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.I16: {
        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);
        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);
        // falls through
      }
      case TypeKind.I32: {
        return module.binary(BinaryOp.DivI32, leftExpr, rightExpr);
      }
      case TypeKind.ISIZE: {
        return module.binary(
          this.options.isWasm64
            ? BinaryOp.DivI64
            : BinaryOp.DivI32,
          leftExpr,
          rightExpr
        );
      }
      case TypeKind.I64: {
        return module.binary(BinaryOp.DivI64, leftExpr, rightExpr);
      }
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.BOOL: {
        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);
        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);
        // falls through
      }
      case TypeKind.U32: {
        return module.binary(BinaryOp.DivU32, leftExpr, rightExpr);
      }
      case TypeKind.USIZE: {
        return module.binary(
          this.options.isWasm64
            ? BinaryOp.DivU64
            : BinaryOp.DivU32,
          leftExpr,
          rightExpr
        );
      }
      case TypeKind.U64: {
        return module.binary(BinaryOp.DivU64, leftExpr, rightExpr);
      }
      case TypeKind.F32: {
        return module.binary(BinaryOp.DivF32, leftExpr, rightExpr);
      }
      case TypeKind.F64: {
        return module.binary(BinaryOp.DivF64, leftExpr, rightExpr);
      }
    }
    assert(false);
    return module.unreachable();
  }

  makeRem(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {
    // Cares about garbage bits and signedness
    var module = this.module;
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.I16: {
        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);
        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);
        // falls through
      }
      case TypeKind.I32: {
        return module.binary(BinaryOp.RemI32, leftExpr, rightExpr);
      }
      case TypeKind.ISIZE: {
        return module.binary(
          this.options.isWasm64
            ? BinaryOp.RemI64
            : BinaryOp.RemI32,
          leftExpr,
          rightExpr
        );
      }
      case TypeKind.I64: {
        return module.binary(BinaryOp.RemI64, leftExpr, rightExpr);
      }
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.BOOL: {
        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);
        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);
        // falls through
      }
      case TypeKind.U32: {
        return module.binary(BinaryOp.RemU32, leftExpr, rightExpr);
      }
      case TypeKind.USIZE: {
        return module.binary(
          this.options.isWasm64
            ? BinaryOp.RemU64
            : BinaryOp.RemU32,
          leftExpr,
          rightExpr
        );
      }
      case TypeKind.U64: {
        return module.binary(BinaryOp.RemU64, leftExpr, rightExpr);
      }
      case TypeKind.F32: {
        let instance = this.f32ModInstance;
        if (!instance) {
          let namespace = this.program.lookup(CommonNames.Mathf);
          if (!namespace) {
            this.error(
              DiagnosticCode.Cannot_find_name_0,
              reportNode.range, "Mathf"
            );
            return module.unreachable();
          }
          let namespaceMembers = namespace.members;
          if (!namespaceMembers || !namespaceMembers.has(CommonNames.mod)) {
            this.error(
              DiagnosticCode.Cannot_find_name_0,
              reportNode.range, "Mathf.mod"
            );
            return module.unreachable();
          }
          let prototype = assert(namespaceMembers.get(CommonNames.mod));
          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);
          this.f32ModInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);
        }
        if (!instance || !this.compileFunction(instance)) {
          return module.unreachable();
        }
        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);
      }
      case TypeKind.F64: {
        let instance = this.f64ModInstance;
        if (!instance) {
          let namespace = this.program.lookup(CommonNames.Math);
          if (!namespace) {
            this.error(
              DiagnosticCode.Cannot_find_name_0,
              reportNode.range, "Math"
            );
            return module.unreachable();
          }
          let namespaceMembers = namespace.members;
          if (!namespaceMembers || !namespaceMembers.has(CommonNames.mod)) {
            this.error(
              DiagnosticCode.Cannot_find_name_0,
              reportNode.range, "Math.mod"
            );
            return module.unreachable();
          }
          let prototype = assert(namespaceMembers.get(CommonNames.mod));
          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);
          this.f64ModInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);
        }
        if (!instance || !this.compileFunction(instance)) {
          return module.unreachable();
        }
        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);
      }
    }
    assert(false);
    return module.unreachable();
  }

  makeShl(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {
    // Cares about garbage bits on the RHS, but only for types smaller than 5 bits
    var module = this.module;
    switch (type.kind) {
      case TypeKind.BOOL: return leftExpr;
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.U8:
      case TypeKind.U16: {
        // leftExpr << (rightExpr & (7|15))
        return module.binary(
          BinaryOp.ShlI32,
          leftExpr,
          module.binary(BinaryOp.AndI32, rightExpr, module.i32(type.size - 1))
        );
      }
      case TypeKind.I32:
      case TypeKind.U32: {
        return module.binary(BinaryOp.ShlI32, leftExpr, rightExpr);
      }
      case TypeKind.I64:
      case TypeKind.U64: {
        return module.binary(BinaryOp.ShlI64, leftExpr, rightExpr);
      }
      case TypeKind.USIZE:
      case TypeKind.ISIZE: {
        return module.binary(
          this.options.isWasm64
            ? BinaryOp.ShlI64
            : BinaryOp.ShlI32,
          leftExpr,
          rightExpr
        );
      }
    }
    assert(false);
    return module.unreachable();
  }

  makeShr(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {
    // Cares about garbage bits on the LHS, but on the RHS only for types smaller than 5 bits,
    // and signedness
    var module = this.module;
    switch (type.kind) {
      case TypeKind.BOOL: return leftExpr;
      case TypeKind.I8:
      case TypeKind.I16: {
        // leftExpr >> (rightExpr & (7|15))
        return module.binary(
          BinaryOp.ShrI32,
          this.ensureSmallIntegerWrap(leftExpr, type),
          module.binary(BinaryOp.AndI32, rightExpr, module.i32(type.size - 1))
        );
      }
      case TypeKind.U8:
      case TypeKind.U16: {
        // leftExpr >>> (rightExpr & (7|15))
        return module.binary(
          BinaryOp.ShrU32,
          this.ensureSmallIntegerWrap(leftExpr, type),
          module.binary(BinaryOp.AndI32, rightExpr, module.i32(type.size - 1))
        );
      }
      case TypeKind.I32: {
        return module.binary(BinaryOp.ShrI32, leftExpr, rightExpr);
      }
      case TypeKind.I64: {
        return module.binary(BinaryOp.ShrI64, leftExpr, rightExpr);
      }
      case TypeKind.ISIZE: {
        return module.binary(
          this.options.isWasm64
            ? BinaryOp.ShrI64
            : BinaryOp.ShrI32,
          leftExpr,
          rightExpr
        );
      }
      case TypeKind.U32: {
        return module.binary(BinaryOp.ShrU32, leftExpr, rightExpr);
      }
      case TypeKind.U64: {
        return module.binary(BinaryOp.ShrU64, leftExpr, rightExpr);
      }
      case TypeKind.USIZE: {
        return module.binary(
          this.options.isWasm64
            ? BinaryOp.ShrU64
            : BinaryOp.ShrU32,
          leftExpr,
          rightExpr
        );
      }
    }
    assert(false);
    return module.unreachable();
  }

  makeShru(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {
    // Cares about garbage bits on the LHS, but on the RHS only for types smaller than 5 bits
    var module = this.module;
    switch (type.kind) {
      case TypeKind.BOOL: return leftExpr;
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.U8:
      case TypeKind.U16: {
        // leftExpr >>> (rightExpr & (7|15))
        return module.binary(
          BinaryOp.ShrU32,
          this.ensureSmallIntegerWrap(leftExpr, type),
          module.binary(BinaryOp.AndI32, rightExpr, module.i32(type.size - 1))
        );
      }
      case TypeKind.I32:
      case TypeKind.U32: {
        return module.binary(BinaryOp.ShrU32, leftExpr, rightExpr);
      }
      case TypeKind.I64:
      case TypeKind.U64: {
        return module.binary(BinaryOp.ShrU64, leftExpr, rightExpr);
      }
      case TypeKind.USIZE:
      case TypeKind.ISIZE: {
        return module.binary(
          this.options.isWasm64
            ? BinaryOp.ShrU64
            : BinaryOp.ShrU32,
          leftExpr,
          rightExpr
        );
      }
    }
    assert(false);
    return module.unreachable();
  }

  makeAnd(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {
    // Does not care about garbage bits or signedness
    var module = this.module;
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.I32:
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.BOOL:
      case TypeKind.U32: {
        return module.binary(BinaryOp.AndI32, leftExpr, rightExpr);
      }
      case TypeKind.I64:
      case TypeKind.U64: {
        return module.binary(BinaryOp.AndI64, leftExpr, rightExpr);
      }
      case TypeKind.USIZE:
      case TypeKind.ISIZE: {
        return module.binary(
          this.options.isWasm64
            ? BinaryOp.AndI64
            : BinaryOp.AndI32,
          leftExpr,
          rightExpr
        );
      }
    }
    assert(false);
    return module.unreachable();
  }

  makeOr(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {
    // Does not care about garbage bits or signedness
    var module = this.module;
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.BOOL: {
        return module.binary(BinaryOp.OrI32, leftExpr, rightExpr);
      }
      case TypeKind.I32:
      case TypeKind.U32: {
        return module.binary(BinaryOp.OrI32, leftExpr, rightExpr);
      }
      case TypeKind.I64:
      case TypeKind.U64: {
        return module.binary(BinaryOp.OrI64, leftExpr, rightExpr);
      }
      case TypeKind.USIZE:
      case TypeKind.ISIZE: {
        return module.binary(
          this.options.isWasm64
            ? BinaryOp.OrI64
            : BinaryOp.OrI32,
          leftExpr,
          rightExpr
        );
      }
    }
    assert(false);
    return module.unreachable();
  }

  makeXor(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {
    // Does not care about garbage bits or signedness
    var module = this.module;
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.BOOL: {
        return module.binary(BinaryOp.XorI32, leftExpr, rightExpr);
      }
      case TypeKind.I32:
      case TypeKind.U32: {
        return module.binary(BinaryOp.XorI32, leftExpr, rightExpr);
      }
      case TypeKind.I64:
      case TypeKind.U64: {
        return module.binary(BinaryOp.XorI64, leftExpr, rightExpr);
      }
      case TypeKind.ISIZE:
      case TypeKind.USIZE: {
        return module.binary(
          this.options.isWasm64
            ? BinaryOp.XorI64
            : BinaryOp.XorI32,
          leftExpr,
          rightExpr
        );
      }
    }
    assert(false);
    return module.unreachable();
  }

  private compileUnaryOverload(
    operatorInstance: Function,
    value: Expression,
    valueExpr: ExpressionRef,
    reportNode: Node
  ): ExpressionRef {
    // FIXME: see comment in compileBinaryOverload below why recompiling on type mismatch
    // is a bad idea currently. so this assumes that the type matches.
    return this.makeCallDirect(operatorInstance, [ valueExpr ], reportNode, false);
  }

  private compileBinaryOverload(
    operatorInstance: Function,
    left: Expression,
    leftExpr: ExpressionRef,
    right: Expression,
    reportNode: Node
  ): ExpressionRef {
    var rightType: Type;
    if (operatorInstance.is(CommonFlags.INSTANCE)) {
      let classInstance = assert(operatorInstance.parent); assert(classInstance.kind == ElementKind.CLASS);
      rightType = operatorInstance.signature.parameterTypes[0];
    } else {
      // FIXME: if LHS type differs we can't recompile left because that'd completely confuse
      // local states, like having local flags that actually do not even exist, possibly
      // releasing something random in that local before and evil things like that. Hence this
      // assumes that LHS type matches, which in turn means that static overloads must be
      // guaranteed to never mismatch LHS type, which in turn means that we can't have shiny
      // things like multiple static overloads for different combinations of LHS/RHS types.
      // We might want that at some point of course, but requires to complete the resolver so
      // it can actually resolve every kind of expression without ever having to recompile.
      rightType = operatorInstance.signature.parameterTypes[1];
    }
    var rightExpr = this.compileExpression(right, rightType, Constraints.CONV_IMPLICIT);
    return this.makeCallDirect(operatorInstance, [ leftExpr, rightExpr ], reportNode);
  }

  private compileAssignment(
    expression: Expression,
    valueExpression: Expression,
    contextualType: Type
  ): ExpressionRef {
    var program = this.program;
    var resolver = program.resolver;
    var flow = this.currentFlow;
    var target = resolver.lookupExpression(expression, flow); // reports
    if (!target) return this.module.unreachable();
    var thisExpression = resolver.currentThisExpression;
    var elementExpression = resolver.currentElementExpression;

    // to compile just the value, we need to know the target's type
    var targetType: Type;
    switch (target.kind) {
      case ElementKind.GLOBAL: {
        // not yet compiled if a static field compiled as a global
        if (!this.compileGlobal(<Global>target)) return this.module.unreachable(); // reports
        // fall-through
      }
      case ElementKind.LOCAL:
      case ElementKind.FIELD: {
        if (this.pendingElements.has(target)) {
          this.error(
            DiagnosticCode.Variable_0_used_before_its_declaration,
            expression.range,
            target.internalName
          );
          return this.module.unreachable();
        }
        targetType = (<VariableLikeElement>target).type;
        if (target.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);
        break;
      }
      case ElementKind.PROPERTY_PROTOTYPE: {
        let propertyPrototype = <PropertyPrototype>target;
        let propertyInstance = resolver.resolveProperty(propertyPrototype);
        if (!propertyInstance) return this.module.unreachable();
        target = propertyInstance;
        // fall-through
      }
      case ElementKind.PROPERTY: {
        let propertyInstance = <Property>target;
        let setterInstance = propertyInstance.setterInstance;
        if (!setterInstance) {
          this.error(
            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,
            expression.range, propertyInstance.internalName
          );
          return this.module.unreachable();
        }
        assert(setterInstance.signature.parameterTypes.length == 1); // parser must guarantee this
        targetType = setterInstance.signature.parameterTypes[0];
        if (setterInstance.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);
        break;
      }
      case ElementKind.INDEXSIGNATURE: {
        let parent = (<IndexSignature>target).parent;
        assert(parent.kind == ElementKind.CLASS);
        let classInstance = <Class>parent;
        let isUnchecked = flow.is(FlowFlags.UNCHECKED_CONTEXT);
        let indexedSet = classInstance.lookupOverload(OperatorKind.INDEXED_SET, isUnchecked);
        if (!indexedSet) {
          let indexedGet = classInstance.lookupOverload(OperatorKind.INDEXED_GET, isUnchecked);
          if (!indexedGet) {
            this.error(
              DiagnosticCode.Index_signature_is_missing_in_type_0,
              expression.range, classInstance.internalName
            );
          } else {
            this.error(
              DiagnosticCode.Index_signature_in_type_0_only_permits_reading,
              expression.range, classInstance.internalName
            );
          }
          return this.module.unreachable();
        }
        assert(indexedSet.signature.parameterTypes.length == 2); // parser must guarantee this
        targetType = indexedSet.signature.parameterTypes[1];     // 2nd parameter is the element
        if (indexedSet.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);
        if (!isUnchecked && this.options.pedantic) {
          this.pedantic(
            DiagnosticCode.Indexed_access_may_involve_bounds_checking,
            expression.range
          );
        }
        break;
      }
      default: {
        this.error(
          DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,
          expression.range, target.internalName
        );
        return this.module.unreachable();
      }
    }

    // compile the value and do the assignment
    assert(targetType != Type.void);
    var valueExpr = this.compileExpression(valueExpression, targetType);
    var valueType = this.currentType;
    return this.makeAssignment(
      target,
      this.convertExpression(valueExpr, valueType, targetType, false, valueExpression),
      valueType,
      valueExpression,
      thisExpression,
      elementExpression,
      contextualType != Type.void
    );
  }

  /** Makes an assignment expression or block, assigning a value to a target. */
  makeAssignment(
    /** Target element, e.g. a Local. */
    target: Element,
    /** Value expression that has been compiled in a previous step already. */
    valueExpr: ExpressionRef,
    /** Value expression type. */
    valueType: Type,
    /** Expression reference. Has already been compiled to `valueExpr`. */
    valueExpression: Expression,
    /** `this` expression reference if a field or property set. */
    thisExpression: Expression | null,
    /** Index expression reference if an indexed set. */
    indexExpression: Expression | null,
    /** Whether to tee the value. */
    tee: bool
  ): ExpressionRef {
    var module = this.module;
    var flow = this.currentFlow;

    switch (target.kind) {
      case ElementKind.LOCAL: {
        let local = <Local>target;
        if (flow.isLocalFlag(local.index, LocalFlags.CONSTANT, true)) {
          this.error(
            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,
            valueExpression.range, target.internalName
          );
          this.currentType = tee ? local.type : Type.void;
          return module.unreachable();
        }
        return this.makeLocalAssignment(local, valueExpr, valueType, tee);
      }
      case ElementKind.GLOBAL: {
        let global = <Global>target;
        if (!this.compileGlobal(global)) return module.unreachable();
        if (target.isAny(CommonFlags.CONST | CommonFlags.READONLY)) {
          this.error(
            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,
            valueExpression.range,
            target.internalName
          );
          this.currentType = tee ? global.type : Type.void;
          return module.unreachable();
        }
        return this.makeGlobalAssignment(global, valueExpr, valueType, tee);
      }
      case ElementKind.FIELD: {
        let fieldInstance = <Field>target;
        let initializerNode = fieldInstance.initializerNode;
        let isConstructor = flow.actualFunction.is(CommonFlags.CONSTRUCTOR);

        // Cannot assign to readonly fields except in constructors if there's no initializer
        if (fieldInstance.is(CommonFlags.READONLY)) {
          if (!isConstructor || initializerNode !== null) {
            this.error(
              DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,
              valueExpression.range, fieldInstance.internalName
            );
            return module.unreachable();
          }
        }

        // Mark initialized fields in constructors
        thisExpression = assert(thisExpression);
        if (isConstructor && thisExpression.kind == NodeKind.THIS) {
          flow.setThisFieldFlag(fieldInstance, FieldFlags.INITIALIZED);
        }

        let fieldParent = fieldInstance.parent;
        assert(fieldParent.kind == ElementKind.CLASS);
        return this.makeFieldAssignment(fieldInstance,
          valueExpr,
          valueType,
          this.compileExpression(
            thisExpression,
            (<Class>fieldParent).type,
            Constraints.CONV_IMPLICIT | Constraints.IS_THIS
          ),
          tee
        );
      }
      case ElementKind.PROPERTY: {
        let propertyInstance = <Property>target;
        let setterInstance = propertyInstance.setterInstance;
        if (!setterInstance) {
          this.error(
            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,
            valueExpression.range, target.internalName
          );
          return module.unreachable();
        }
        assert(setterInstance.signature.parameterTypes.length == 1);
        if (propertyInstance.is(CommonFlags.INSTANCE)) {
          let thisType = assert(setterInstance.signature.thisType);
          let thisExpr = this.compileExpression(
            assert(thisExpression),
            thisType,
            Constraints.CONV_IMPLICIT | Constraints.IS_THIS
          );
          if (!tee) return this.makeCallDirect(setterInstance, [ thisExpr, valueExpr ], valueExpression);
          let getterInstance = assert((<Property>target).getterInstance);
          assert(getterInstance.signature.thisType == thisType);
          let returnType = getterInstance.signature.returnType;
          let returnTypeRef = returnType.toRef();
          let tempThis = flow.getTempLocal(returnType);
          let ret = module.block(null, [
            this.makeCallDirect(setterInstance, [
              module.local_tee(tempThis.index, thisExpr, returnType.isManaged),
              valueExpr
            ], valueExpression),
            this.makeCallDirect(getterInstance, [
              module.local_get(tempThis.index, returnTypeRef)
            ], valueExpression)
          ], returnTypeRef);
          flow.freeTempLocal(tempThis);
          return ret;
        } else {
          if (!tee) return this.makeCallDirect(setterInstance, [ valueExpr ], valueExpression);
          let getterInstance = assert((<Property>target).getterInstance);
          return module.block(null, [
            this.makeCallDirect(setterInstance, [ valueExpr ], valueExpression),
            this.makeCallDirect(getterInstance, null, valueExpression)
          ], getterInstance.signature.returnType.toRef());
        }
      }
      case ElementKind.INDEXSIGNATURE: {
        let indexSignature = <IndexSignature>target;
        let parent = indexSignature.parent;
        assert(parent.kind == ElementKind.CLASS);
        let classInstance = <Class>parent;
        assert(classInstance.kind == ElementKind.CLASS);
        let isUnchecked = flow.is(FlowFlags.UNCHECKED_CONTEXT);
        let getterInstance = classInstance.lookupOverload(OperatorKind.INDEXED_GET, isUnchecked);
        if (!getterInstance) {
          this.error(
            DiagnosticCode.Index_signature_is_missing_in_type_0,
            valueExpression.range, classInstance.internalName
          );
          return module.unreachable();
        }
        let setterInstance = classInstance.lookupOverload(OperatorKind.INDEXED_SET, isUnchecked);
        if (!setterInstance) {
          this.error(
            DiagnosticCode.Index_signature_in_type_0_only_permits_reading,
            valueExpression.range, classInstance.internalName
          );
          this.currentType = tee ? getterInstance.signature.returnType : Type.void;
          return module.unreachable();
        }
        assert(setterInstance.signature.parameterTypes.length == 2);
        let thisType = classInstance.type;
        let thisExpr = this.compileExpression(
          assert(thisExpression),
          thisType,
          Constraints.CONV_IMPLICIT | Constraints.IS_THIS
        );
        let elementExpr = this.compileExpression(assert(indexExpression), Type.i32, Constraints.CONV_IMPLICIT);
        let elementType = this.currentType;
        if (tee) {
          let tempTarget = flow.getTempLocal(thisType);
          let tempElement = flow.getTempLocal(elementType);
          let returnType = getterInstance.signature.returnType;
          let ret = module.block(null, [
            this.makeCallDirect(setterInstance, [
              module.local_tee(tempTarget.index, thisExpr, thisType.isManaged),
              module.local_tee(tempElement.index, elementExpr, elementType.isManaged),
              valueExpr
            ], valueExpression),
            this.makeCallDirect(getterInstance, [
              module.local_get(tempTarget.index, tempTarget.type.toRef()),
              module.local_get(tempElement.index, tempElement.type.toRef())
            ], valueExpression)
          ], returnType.toRef());
          flow.freeTempLocal(tempElement);
          flow.freeTempLocal(tempTarget);
          return ret;
        } else {
          return this.makeCallDirect(setterInstance, [
            thisExpr,
            elementExpr,
            valueExpr
          ], valueExpression);
        }
      }
    }
    assert(false);
    return module.unreachable();
  }

  /** Makes an assignment to a local, keeping track of wrap and null states. */
  private makeLocalAssignment(
    /** Local to assign to. */
    local: Local,
    /** Value to assign. */
    valueExpr: ExpressionRef,
    /** Value type. */
    valueType: Type,
    /** Whether to tee the value. */
    tee: bool
  ): ExpressionRef {
    var module = this.module;
    var flow = this.currentFlow;
    var type = local.type;
    assert(type != Type.void);
    var localIndex = local.index;

    if (type.isNullableReference) {
      if (!valueType.isNullableReference || flow.isNonnull(valueExpr, type)) flow.setLocalFlag(localIndex, LocalFlags.NONNULL);
      else flow.unsetLocalFlag(localIndex, LocalFlags.NONNULL);
    }
    flow.setLocalFlag(localIndex, LocalFlags.INITIALIZED);
    if (type.isShortIntegerValue) {
      if (!flow.canOverflow(valueExpr, type)) flow.setLocalFlag(localIndex, LocalFlags.WRAPPED);
      else flow.unsetLocalFlag(localIndex, LocalFlags.WRAPPED);
    }
    if (tee) { // local = value
      this.currentType = type;
      return module.local_tee(localIndex, valueExpr, type.isManaged);
    } else { // void(local = value)
      this.currentType = Type.void;
      return module.local_set(localIndex, valueExpr, type.isManaged);
    }
  }

  /** Makes an assignment to a global. */
  private makeGlobalAssignment(
    /** The global variable to assign to. */
    global: VariableLikeElement,
    /** The value to assign. */
    valueExpr: ExpressionRef,
    /** The type of the value to assign. */
    valueType: Type,
    /** Whether to tee the value. */
    tee: bool
  ): ExpressionRef {
    var module = this.module;
    var type = global.type;
    assert(type != Type.void);
    var typeRef = type.toRef();

    valueExpr = this.ensureSmallIntegerWrap(valueExpr, type); // globals must be wrapped
    if (tee) { // (global = value), global
      this.currentType = type;
      return module.block(null, [
        module.global_set(global.internalName, valueExpr),
        module.global_get(global.internalName, typeRef)
      ], typeRef);
    } else { // global = value
      this.currentType = Type.void;
      return module.global_set(global.internalName,
        valueExpr
      );
    }
  }

  /** Makes an assignment to a field. */
  private makeFieldAssignment(
    /** The field to assign to. */
    field: Field,
    /** The value to assign. */
    valueExpr: ExpressionRef,
    /** The type of the value to assign. */
    valueType: Type,
    /** The value of `this`. */
    thisExpr: ExpressionRef,
    /** Whether to tee the value. */
    tee: bool
  ): ExpressionRef {
    var module = this.module;
    var flow = this.currentFlow;
    var fieldType = field.type;
    var fieldTypeRef = fieldType.toRef();
    assert(field.parent.kind == ElementKind.CLASS);
    var thisType = (<Class>field.parent).type;

    if (!field.is(CommonFlags.COMPILED)) {
      field.set(CommonFlags.COMPILED);
      let typeNode = field.typeNode;
      if (typeNode) this.checkTypeSupported(field.type, typeNode);
    }

    if (tee) {
      this.compileField(field);
      let tempThis = flow.getTempLocal(thisType);
      let expr = module.block(null, [
        module.call(field.internalSetterName, [ module.local_tee(tempThis.index, thisExpr, thisType.isManaged), valueExpr ], TypeRef.None),
        module.call(field.internalGetterName, [ module.local_get(tempThis.index, thisType.toRef()) ], fieldTypeRef)
      ], fieldTypeRef);
      flow.freeTempLocal(tempThis);
      this.currentType = fieldType;
      return expr;
    } else {
      this.compileFieldSetter(field);
      let expr = module.call(field.internalSetterName, [ thisExpr, valueExpr ], TypeRef.None);
      this.currentType = Type.void;
      return expr;
    }
  }

  /** Compiles a call expression according to the specified context. */
  private compileCallExpression(
    /** Call expression to compile. */
    expression: CallExpression,
    /** Contextual type indicating the return type the caller expects, if any. */
    contextualType: Type,
    /** Constraints indicating contextual conditions. */
    constraints: Constraints
  ): ExpressionRef {

    var module = this.module;
    var flow = this.currentFlow;

    // handle call to super
    if (expression.expression.kind == NodeKind.SUPER) {
      let flow = this.currentFlow;
      let actualFunction = flow.actualFunction;
      if (!actualFunction.is(CommonFlags.CONSTRUCTOR)) {
        this.error(
          DiagnosticCode.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors,
          expression.range
        );
        return module.unreachable();
      }

      let parent = assert(actualFunction.parent);
      assert(parent.kind == ElementKind.CLASS);
      let classInstance = <Class>parent;
      let baseClassInstance = classInstance.base;
      if (!baseClassInstance) {
        this.error(
          DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,
          expression.expression.range
        );
        return module.unreachable();
      }
      let thisLocal = assert(flow.lookupLocal(CommonNames.this_));
      let sizeTypeRef = this.options.sizeTypeRef;

      let baseCtorInstance = this.ensureConstructor(baseClassInstance, expression);
      this.checkFieldInitialization(baseClassInstance, expression);
      let superCall = this.compileCallDirect(
        baseCtorInstance,
        expression.args,
        expression,
        module.local_get(thisLocal.index, sizeTypeRef)
      );

      // check that super had been called before accessing `this`
      if (flow.isAny(
        FlowFlags.ACCESSES_THIS |
        FlowFlags.CONDITIONALLY_ACCESSES_THIS
      )) {
        this.error(
          DiagnosticCode._super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class,
          expression.range
        );
        return module.unreachable();
      }
      flow.set(FlowFlags.ACCESSES_THIS | FlowFlags.CALLS_SUPER);
      this.currentType = Type.void;
      return module.local_set(thisLocal.index, superCall, classInstance.type.isManaged);
    }

    // otherwise resolve normally
    var target = this.resolver.lookupExpression(expression.expression, flow); // reports
    if (!target) return module.unreachable();
    var thisExpression = this.resolver.currentThisExpression;

    var signature: Signature | null;
    var functionArg: ExpressionRef;
    switch (target.kind) {

      // direct call: concrete function
      case ElementKind.FUNCTION_PROTOTYPE: {
        let functionPrototype = <FunctionPrototype>target;
        if (functionPrototype.hasDecorator(DecoratorFlags.BUILTIN)) {
          // builtins handle present respectively omitted type arguments on their own
          return this.compileCallExpressionBuiltin(functionPrototype, expression, contextualType);
        }
        let functionInstance = this.resolver.maybeInferCall(expression, functionPrototype, flow);
        if (!functionInstance) return this.module.unreachable();
        target = functionInstance;
        // fall-through
      }
      case ElementKind.FUNCTION: {
        let functionInstance = <Function>target;
        let thisArg: ExpressionRef = 0;
        if (functionInstance.is(CommonFlags.INSTANCE)) {
          thisArg = this.compileExpression(
            assert(thisExpression),
            assert(functionInstance.signature.thisType),
            Constraints.CONV_IMPLICIT | Constraints.IS_THIS
          );
        }
        return this.compileCallDirect(
          functionInstance,
          expression.args,
          expression,
          thisArg,
          constraints
        );
      }

      // indirect call: first-class function (non-generic, can't be inlined)
      case ElementKind.LOCAL: {
        let local = <Local>target;
        signature = local.type.signatureReference;
        if (signature) {
          if (local.is(CommonFlags.INLINED)) {
            let inlinedValue = local.constantIntegerValue;
            if (this.options.isWasm64) {
              functionArg = module.i64(i64_low(inlinedValue), i64_high(inlinedValue));
            } else {
              assert(!i64_high(inlinedValue));
              functionArg = module.i32(i64_low(inlinedValue));
            }
          } else {
            functionArg = module.local_get(local.index, this.options.sizeTypeRef);
          }
          break;
        }
        this.error(
          DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,
          expression.range, local.type.toString()
        );
        return module.unreachable();
      }
      case ElementKind.GLOBAL: {
        let global = <Global>target;
        signature = global.type.signatureReference;
        if (signature) {
          functionArg = module.global_get(global.internalName, global.type.toRef());
          break;
        }
        this.error(
          DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,
          expression.range, global.type.toString()
        );
        return module.unreachable();
      }
      case ElementKind.FIELD: {
        let fieldInstance = <Field>target;
        let fieldType = fieldInstance.type;
        signature = fieldType.signatureReference;
        if (signature) {
          let fieldParent = fieldInstance.parent;
          assert(fieldParent.kind == ElementKind.CLASS);
          let usizeType = this.options.usizeType;
          functionArg = module.load(usizeType.byteSize, false,
            this.compileExpression(
              assert(thisExpression),
              (<Class>fieldParent).type,
              Constraints.CONV_IMPLICIT | Constraints.IS_THIS
            ),
            usizeType.toRef(),
            fieldInstance.memoryOffset
          );
          break;
        }
        this.error(
          DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,
          expression.range, fieldType.toString()
        );
        return module.unreachable();
      }

      case ElementKind.PROPERTY_PROTOTYPE: {
        let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>target);
        if (!propertyInstance) return module.unreachable();
        target = propertyInstance;
        // fall-through
      }
      case ElementKind.PROPERTY: {
        let propertyInstance = <Property>target;
        let getterInstance = propertyInstance.getterInstance;
        let type = assert(this.resolver.getTypeOfElement(target));

        if (!getterInstance) {
          this.error(
            DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,
            expression.range, type.toString()
          );
          return module.unreachable();
        }

        let thisArg: ExpressionRef = 0;
        if (propertyInstance.is(CommonFlags.INSTANCE)) {
          thisArg = this.compileExpression(
            assert(thisExpression),
            assert(getterInstance.signature.thisType),
            Constraints.CONV_IMPLICIT | Constraints.IS_THIS
          );
        }
        functionArg = this.compileCallDirect(getterInstance, [], expression.expression, thisArg);
        signature = this.currentType.signatureReference;
        if (!signature) {
          this.error(
            DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,
            expression.range, this.currentType.toString()
          );
          return module.unreachable();
        }
        break;
      }
      case ElementKind.CLASS: {
        let classInstance = <Class>target;
        let typeArguments = classInstance.getTypeArgumentsTo(this.program.functionPrototype);
        if (typeArguments !== null && typeArguments.length > 0) {
          let ftype = typeArguments[0];
          signature = ftype.getSignature();
          functionArg = this.compileExpression(expression.expression, ftype, Constraints.CONV_IMPLICIT);
          break;
        }
        // fall-through
      }

      // not supported
      default: {
        let type = this.resolver.getTypeOfElement(target);
        if (type) {
          this.error(
            DiagnosticCode.Type_0_has_no_call_signatures,
            expression.range, type.toString()
          );
        } else {
          this.error(
            DiagnosticCode.Expression_cannot_be_represented_by_a_type,
            expression.range
          );
        }
        return module.unreachable();
      }
    }
    return this.compileCallIndirect(
      assert(signature), // FIXME: bootstrap can't see this yet
      functionArg,
      expression.args,
      expression,
      0,
      contextualType == Type.void
    );
  }

  /** Compiles the given arguments like a call expression according to the specified context. */
  private compileCallExpressionLike(
    /** Called expression. */
    expression: Expression,
    /** Call type arguments. */
    typeArguments: TypeNode[] | null,
    /** Call arguments. */
    args: Expression[],
    /** Diagnostic range. */
    range: Range,
    /** Contextual type indicating the return type the caller expects, if any. */
    contextualType: Type,
    /** Constraints indicating contextual conditions. */
    constraints: Constraints = Constraints.NONE
  ): ExpressionRef {
    // Desugaring like this can happen many times. Let's cache the intermediate allocation.
    var call = this._reusableCallExpression;
    if (call) {
      call.expression = expression;
      call.typeArguments = typeArguments;
      call.args = args;
      call.range = range;
    } else {
      this._reusableCallExpression = call = Node.createCallExpression(expression, typeArguments, args, range);
    }
    return this.compileCallExpression(call, contextualType, constraints);
  }
  private _reusableCallExpression: CallExpression | null = null;

  private compileCallExpressionBuiltin(
    prototype: FunctionPrototype,
    expression: CallExpression,
    contextualType: Type
  ): ExpressionRef {
    if (prototype.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);

    var typeArguments: Type[] | null = null;

    // builtins handle omitted type arguments on their own. if present, however, resolve them here
    // and pass them to the builtin, even if it's still up to the builtin how to handle them.
    var typeParameterNodes = prototype.typeParameterNodes;
    var typeArgumentNodes = expression.typeArguments;
    if (expression.typeArguments) {
      if (!prototype.is(CommonFlags.GENERIC)) {
        this.error(
          DiagnosticCode.Type_0_is_not_generic,
          expression.range, prototype.internalName
        );
      }
      typeArguments = this.resolver.resolveTypeArguments(
        assert(typeParameterNodes),
        typeArgumentNodes,
        this.currentFlow.actualFunction.parent,
        uniqueMap<string,Type>(this.currentFlow.contextualTypeArguments), // don't update
        expression
      );
    }
    var callee = expression.expression;
    var ctx = new BuiltinContext(
      this,
      prototype,
      typeArguments,
      expression.args,
      callee.kind == NodeKind.PROPERTYACCESS
        ? (<PropertyAccessExpression>callee).expression
        : null,
      contextualType,
      expression,
      false
    );
    // global builtins
    var internalName = prototype.internalName;
    if (builtins.has(internalName)) {
      let fn = assert(builtins.get(internalName));
      return fn(ctx);
    }
    // class builtins
    var parent = prototype.parent;
    if (parent.kind == ElementKind.CLASS) {
      let classPrototype = (<Class>parent).prototype;
      if (classPrototype == this.program.functionPrototype) {
        let methodName = prototype.name;
        if (function_builtins.has(methodName)) {
          let fn = assert(function_builtins.get(methodName));
          return fn(ctx);
        }
      }
    }
    assert(false);
    return this.module.unreachable();
  }

  /**
   * Checks that a call with the given number as arguments can be performed according to the
   * specified signature.
   */
  checkCallSignature(
    signature: Signature,
    numArguments: i32,
    hasThis: bool,
    reportNode: Node
  ): bool {

    // cannot call an instance method without a `this` argument (TODO: `.call`?)
    var thisType = signature.thisType;
    if (hasThis != (thisType != null)) {
      this.error(
        DiagnosticCode.The_this_types_of_each_signature_are_incompatible,
        reportNode.range
      );
      return false;
    }

    // not yet implemented (TODO: maybe some sort of an unmanaged/lightweight array?)
    var hasRest = signature.hasRest;
    if (hasRest) {
      this.error(
        DiagnosticCode.Not_implemented_0,
        reportNode.range, "Rest parameters"
      );
      return false;
    }

    var minimum = signature.requiredParameters;
    var maximum = signature.parameterTypes.length;

    // must at least be called with required arguments
    if (numArguments < minimum) {
      this.error(
        minimum < maximum
          ? DiagnosticCode.Expected_at_least_0_arguments_but_got_1
          : DiagnosticCode.Expected_0_arguments_but_got_1,
        reportNode.range, minimum.toString(), numArguments.toString()
      );
      return false;
    }

    // must not be called with more than the maximum arguments
    if (numArguments > maximum && !hasRest) {
      this.error(
        DiagnosticCode.Expected_0_arguments_but_got_1,
        reportNode.range, maximum.toString(), numArguments.toString()
      );
      return false;
    }

    return true;
  }

  /** Checks that an unsafe expression is allowed. */
  private checkUnsafe(reportNode: Node, relatedReportNode: Node | null = null): void {
    // Library files may always use unsafe features
    if (this.options.noUnsafe && !reportNode.range.source.isLibrary) {
      if (relatedReportNode) {
        this.errorRelated(
          DiagnosticCode.Operation_is_unsafe,
          reportNode.range, relatedReportNode.range
        );
      } else {
        this.error(
          DiagnosticCode.Operation_is_unsafe,
          reportNode.range
        );
      }
    }
  }

  /** Compiles a direct call to a concrete function. */
  compileCallDirect(
    instance: Function,
    argumentExpressions: Expression[],
    reportNode: Node,
    thisArg: ExpressionRef = 0,
    constraints: Constraints = Constraints.NONE
  ): ExpressionRef {
    var numArguments = argumentExpressions.length;
    var signature = instance.signature;
    if (!this.checkCallSignature( // reports
      signature,
      numArguments,
      thisArg != 0,
      reportNode
    )) {
      this.currentType = signature.returnType;
      return this.module.unreachable();
    }
    if (instance.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(reportNode);

    // handle call on `this` in constructors
    let actualFunction = this.currentFlow.actualFunction;
    if (actualFunction.is(CommonFlags.CONSTRUCTOR) && reportNode.isAccessOnThis) {
      let parent = actualFunction.parent;
      assert(parent.kind == ElementKind.CLASS);
      this.checkFieldInitialization(<Class>parent, reportNode);
    }

    // Inline if explicitly requested
    if (instance.hasDecorator(DecoratorFlags.INLINE) && (!instance.is(CommonFlags.VIRTUAL) || reportNode.isAccessOnSuper)) {
      assert(!instance.is(CommonFlags.STUB)); // doesn't make sense
      let inlineStack = this.inlineStack;
      if (inlineStack.includes(instance)) {
        this.warning(
          DiagnosticCode.Function_0_cannot_be_inlined_into_itself,
          reportNode.range, instance.internalName
        );
      } else {
        inlineStack.push(instance);
        let parameterTypes = signature.parameterTypes;
        assert(numArguments <= parameterTypes.length);
        // compile argument expressions
        let args = new Array<ExpressionRef>(numArguments);
        for (let i = 0; i < numArguments; ++i) {
          args[i] = this.compileExpression(argumentExpressions[i], parameterTypes[i], Constraints.CONV_IMPLICIT);
        }
        // make the inlined call
        let expr = this.makeCallInline(instance, args, thisArg, (constraints & Constraints.WILL_DROP) != 0);
        inlineStack.pop();
        return expr;
      }
    }

    // Otherwise compile to just a call
    var numArgumentsInclThis = thisArg ? numArguments + 1 : numArguments;
    var operands = new Array<ExpressionRef>(numArgumentsInclThis);
    var index = 0;
    if (thisArg) {
      operands[0] = thisArg;
      index = 1;
    }
    var parameterTypes = signature.parameterTypes;
    for (let i = 0; i < numArguments; ++i, ++index) {
      let paramType = parameterTypes[i];
      let paramExpr = this.compileExpression(argumentExpressions[i], paramType, Constraints.CONV_IMPLICIT);
      operands[index] = paramExpr;
    }
    assert(index == numArgumentsInclThis);
    return this.makeCallDirect(instance, operands, reportNode, (constraints & Constraints.WILL_DROP) != 0);
  }

  makeCallInline(
    instance: Function,
    operands: ExpressionRef[] | null,
    thisArg: ExpressionRef = 0,
    immediatelyDropped: bool = false
  ): ExpressionRef {
    var module = this.module;
    var numArguments = operands ? operands.length : 0;
    var signature = instance.signature;
    var parameterTypes = signature.parameterTypes;
    var numParameters = parameterTypes.length;

    // Create a new inline flow and use it to compile the function as a block
    var previousFlow = this.currentFlow;
    var flow = Flow.createInline(previousFlow.parentFunction, instance);
    var body = [];
    var usedLocals = new Set<i32>();

    // Prepare compiled arguments right to left, keeping track of used locals.
    for (let i = numArguments - 1; i >= 0; --i) {
      // This is necessary because a later expression must not set an earlier argument local, which
      // is also just a temporary, when being executed. Take for example `t1=1, t2=(t1 = 2)`, where
      // the right expression would reassign the foregoing argument local. So, we iterate from right
      // to left, remembering what's used later, and don't use these for earlier arguments, making
      // the example above essentially `t2=1, t1=(t1 = 2)`.
      let paramExpr = operands![i];
      let paramType = parameterTypes[i];
      let argumentLocal = flow.addScopedLocal(instance.getParameterName(i), paramType, usedLocals);
      findUsedLocals(paramExpr, usedLocals);
      // inlining is aware of wrap/nonnull states:
      if (!previousFlow.canOverflow(paramExpr, paramType)) flow.setLocalFlag(argumentLocal.index, LocalFlags.WRAPPED);
      if (flow.isNonnull(paramExpr, paramType)) flow.setLocalFlag(argumentLocal.index, LocalFlags.NONNULL);
      body.unshift(
        module.local_set(argumentLocal.index, paramExpr, paramType.isManaged)
      );
    }
    if (thisArg) {
      let parent = assert(instance.parent);
      assert(parent.kind == ElementKind.CLASS);
      let classInstance = <Class>parent;
      let thisType = assert(instance.signature.thisType);
      let thisLocal = flow.addScopedLocal(CommonNames.this_, thisType, usedLocals);
      body.unshift(
        module.local_set(thisLocal.index, thisArg, thisType.isManaged)
      );
      let base = classInstance.base;
      if (base) flow.addScopedAlias(CommonNames.super_, base.type, thisLocal.index);
    } else {
      assert(!instance.signature.thisType);
    }

    // Compile omitted arguments with final argument locals blocked. Doesn't need to take care of
    // side-effects within earlier expressions because these already happened on set.
    this.currentFlow = flow;
    var isConstructor = instance.is(CommonFlags.CONSTRUCTOR);
    if (isConstructor) flow.set(FlowFlags.CTORPARAM_CONTEXT);
    for (let i = numArguments; i < numParameters; ++i) {
      let initType = parameterTypes[i];
      let initExpr = this.compileExpression(
        assert(instance.prototype.functionTypeNode.parameters[i].initializer),
        initType,
        Constraints.CONV_IMPLICIT
      );
      let argumentLocal = flow.addScopedLocal(instance.getParameterName(i), initType);
      body.push(
        this.makeLocalAssignment(argumentLocal, initExpr, initType, false)
      );
    }
    flow.unset(FlowFlags.CTORPARAM_CONTEXT);

    // Compile the called function's body in the scope of the inlined flow
    this.compileFunctionBody(instance, body);

    // If a constructor, perform field init checks on its flow directly
    if (isConstructor) {
      let parent = instance.parent;
      assert(parent.kind == ElementKind.CLASS);
      this.checkFieldInitializationInFlow(<Class>parent, flow);
    }

    // Free any new scoped locals and reset to the original flow
    flow.freeScopedLocals();
    var returnType = flow.returnType;
    this.currentFlow = previousFlow;

    // Create an outer block that we can break to when returning a value out of order
    this.currentType = returnType;
    return module.block(flow.inlineReturnLabel, body, returnType.toRef());
  }

  /** Makes sure that the arguments length helper global is present. */
  ensureArgumentsLength(): string {
    var name = BuiltinNames.argumentsLength;
    if (!this.builtinArgumentsLength) {
      let module = this.module;
      this.builtinArgumentsLength = module.addGlobal(name, TypeRef.I32, true, module.i32(0));
    }
    return name;
  }

  /** Ensures compilation of the varargs stub for the specified function. */
  ensureVarargsStub(original: Function): Function {
    // A varargs stub is a function called with omitted arguments being zeroed,
    // reading the `argumentsLength` helper global to decide which initializers
    // to inject before calling the original function. It is typically attempted
    // to circumvent the varargs stub where possible, for example where omitted
    // arguments are constants and can be inlined into the original call.
    var stub = original.varargsStub;
    if (stub) return stub;

    var originalSignature = original.signature;
    var originalParameterTypes = originalSignature.parameterTypes;
    var originalParameterDeclarations = original.prototype.functionTypeNode.parameters;
    var returnType = originalSignature.returnType;
    var isInstance = original.is(CommonFlags.INSTANCE);

    // arguments excl. `this`, operands incl. `this`
    var minArguments = originalSignature.requiredParameters;
    var minOperands = minArguments;
    var maxArguments = originalParameterTypes.length;
    var maxOperands = maxArguments;
    if (isInstance) {
      ++minOperands;
      ++maxOperands;
    }
    var numOptional = assert(maxOperands - minOperands);

    var forwardedOperands = new Array<ExpressionRef>(minOperands);
    var operandIndex = 0;
    var stmts = new Array<ExpressionRef>();

    // forward `this` if applicable
    var module = this.module;
    var thisType = originalSignature.thisType;
    if (thisType) {
      forwardedOperands[0] = module.local_get(0, thisType.toRef());
      operandIndex = 1;
    }

    // forward required arguments
    for (let i = 0; i < minArguments; ++i, ++operandIndex) {
      let paramType = originalParameterTypes[i];
      forwardedOperands[operandIndex] = module.local_get(operandIndex, paramType.toRef());
    }
    assert(operandIndex == minOperands);

    // create the varargs stub
    stub = original.newStub("varargs");
    stub.signature.requiredParameters = maxArguments;
    original.varargsStub = stub;

    // compile initializers of omitted arguments in the scope of the stub,
    // accounting for additional locals and a proper `this` context.
    var previousFlow = this.currentFlow;
    var flow = stub.flow;
    if (original.is(CommonFlags.CONSTRUCTOR)) flow.set(FlowFlags.CTORPARAM_CONTEXT);
    this.currentFlow = flow;

    // create a br_table switching over the number of optional parameters provided
    var numNames = numOptional + 1; // incl. outer block
    var names = new Array<string>(numNames);
    var ofN = "of" + numOptional.toString();
    for (let i = 0; i < numNames; ++i) {
      let label = i.toString() + ofN;
      names[i] = label;
    }
    var argumentsLength = this.ensureArgumentsLength();
    var table = module.block(names[0], [
      module.block("outOfRange", [
        module.switch(names, "outOfRange",
          // condition is number of provided optional arguments, so subtract required arguments
          minArguments
            ? module.binary(
                BinaryOp.SubI32,
                module.global_get(argumentsLength, TypeRef.I32),
                module.i32(minArguments)
              )
            : module.global_get(argumentsLength, TypeRef.I32)
        )
      ]),
      module.unreachable()
    ]);
    for (let i = 0; i < numOptional; ++i, ++operandIndex) {
      let type = originalParameterTypes[minArguments + i];
      let declaration = originalParameterDeclarations[minArguments + i];
      let initializer = declaration.initializer;
      let initExpr: ExpressionRef;
      if (initializer) {
        initExpr = this.compileExpression(
          initializer,
          type,
          Constraints.CONV_IMPLICIT
        );
        initExpr = module.local_set(operandIndex, initExpr, type.isManaged);
      } else {
        this.error(
          DiagnosticCode.Optional_parameter_must_have_an_initializer,
          declaration.range
        );
        initExpr = module.unreachable();
      }
      table = module.block(names[i + 1], [
        table,
        initExpr,
      ]);
      forwardedOperands[operandIndex] = module.local_get(operandIndex, type.toRef());
    }
    assert(operandIndex == maxOperands);

    stmts.push(
      table
    );
    stmts.push(
      // assume this will always succeed (can just use name as the reportNode)
      this.makeCallDirect(original, forwardedOperands, original.declaration.name)
    );
    flow.freeScopedLocals();
    this.currentFlow = previousFlow;

    var funcRef = module.addFunction(
      stub.internalName,
      stub.signature.paramRefs,
      stub.signature.resultRefs,
      typesToRefs(stub.additionalLocals),
      module.flatten(stmts, returnType.toRef())
    );
    stub.set(CommonFlags.COMPILED);
    stub.finalize(module, funcRef);
    return stub;
  }

  /** Ensures compilation of the virtual stub for the specified function. */
  ensureVirtualStub(original: Function): Function {
    // A virtual stub is a function redirecting virtual calls to the actual
    // overload targeted by the call. It utilizes varargs stubs where necessary
    // and as such has the same semantics as one. Here, we only make sure that
    // a placeholder exist, with actual code being generated as a finalization
    // step once module compilation is otherwise complete.
    var stub = original.virtualStub;
    if (stub) return stub;
    stub = original.newStub("virtual");
    original.virtualStub = stub;
    var module = this.module;
    stub.ref = module.addFunction(
      stub.internalName,
      stub.signature.paramRefs,
      stub.signature.resultRefs,
      null,
      module.unreachable()
    );
    this.virtualCalls.add(original);
    return stub;
  }

  /** Finalizes the virtual stub of the specified function. */
  private finalizeVirtualStub(instance: Function): void {
    var stub = this.ensureVirtualStub(instance);
    if (stub.is(CommonFlags.COMPILED)) return;

    // Wouldn't be here if there wasn't at least one overload
    var overloadPrototypes = assert(instance.prototype.overloads);

    assert(instance.parent.kind == ElementKind.CLASS || instance.parent.kind == ElementKind.INTERFACE);
    var parentClassInstance = <Class>instance.parent;
    var module = this.module;
    var usizeType = this.options.usizeType;
    var sizeTypeRef = usizeType.toRef();
    var parameterTypes = instance.signature.parameterTypes;
    var returnType = instance.signature.returnType;
    var numParameters = parameterTypes.length;
    var tempIndex = 1 + parameterTypes.length; // incl. `this`

    // Switch over this's rtId and map it to the respective overload
    var builder = new SwitchBuilder(this.module,
      module.load(4, false,
        module.binary(
          sizeTypeRef == TypeRef.I64
            ? BinaryOp.SubI64
            : BinaryOp.SubI32,
          module.local_get(0, sizeTypeRef),
          sizeTypeRef == TypeRef.I64
            ? module.i64(8) // rtId offset = -8
            : module.i32(8)
        ),
        TypeRef.I32
      )
    );

    // A method's `overloads` property contains its unbound overload prototypes
    // so we first have to find the concrete classes it became bound to, obtain
    // their bound prototypes and make sure these are resolved and compiled as
    // we are going to call them conditionally based on this's class id.
    for (let _values = Set_values(overloadPrototypes), i = 0, k = _values.length; i < k; ++i) {
      let unboundOverloadPrototype = _values[i];
      assert(!unboundOverloadPrototype.isBound);
      let unboundOverloadParent = unboundOverloadPrototype.parent;
      let isProperty = unboundOverloadParent.kind == ElementKind.PROPERTY_PROTOTYPE;
      let classInstances: Map<string,Class> | null;
      if (isProperty) {
        let propertyParent = (<PropertyPrototype>unboundOverloadParent).parent;
        assert(propertyParent.kind == ElementKind.CLASS_PROTOTYPE);
        classInstances = (<ClassPrototype>propertyParent).instances;
      } else {
        assert(unboundOverloadParent.kind == ElementKind.CLASS_PROTOTYPE);
        classInstances = (<ClassPrototype>unboundOverloadParent).instances;
      }
      if (classInstances) {
        for (let _values = Map_values(classInstances), j = 0, l = _values.length; j < l; ++j) {
          let classInstance = _values[j];
          // Chcek if the parent class is a subtype of instance's class
          if (!classInstance.isAssignableTo(parentClassInstance)) continue;
          let overloadInstance: Function | null;
          if (isProperty) {
            let boundProperty = assert(classInstance.members!.get(unboundOverloadParent.name));
            assert(boundProperty.kind == ElementKind.PROPERTY_PROTOTYPE);
            let boundPropertyInstance = this.resolver.resolveProperty(<PropertyPrototype>boundProperty);
            if (!boundPropertyInstance) continue;
            if (instance.is(CommonFlags.GET)) {
              overloadInstance = boundPropertyInstance.getterInstance;
            } else {
              assert(instance.is(CommonFlags.SET));
              overloadInstance = boundPropertyInstance.setterInstance;
            }
          } else {
            let boundPrototype = assert(classInstance.members!.get(unboundOverloadPrototype.name));
            assert(boundPrototype.kind == ElementKind.FUNCTION_PROTOTYPE);
            overloadInstance = this.resolver.resolveFunction(<FunctionPrototype>boundPrototype, instance.typeArguments);
          }
          if (!overloadInstance || !this.compileFunction(overloadInstance)) continue;
          let overloadType = overloadInstance.type;
          let originalType = instance.type;
          if (!overloadType.isAssignableTo(originalType)) {
            this.error(
              DiagnosticCode.Type_0_is_not_assignable_to_type_1,
              overloadInstance.identifierNode.range, overloadType.toString(), originalType.toString()
            );
            continue;
          }
          // TODO: additional optional parameters are not permitted by `isAssignableTo` yet
          let overloadSignature = overloadInstance.signature;
          let overloadParameterTypes = overloadSignature.parameterTypes;
          let overloadNumParameters = overloadParameterTypes.length;
          let paramExprs = new Array<ExpressionRef>(1 + overloadNumParameters);
          paramExprs[0] = module.local_get(0, sizeTypeRef); // this
          for (let n = 1; n <= numParameters; ++n) {
            paramExprs[n] = module.local_get(n, parameterTypes[n - 1].toRef());
          }
          let needsVarargsStub = false;
          for (let n = numParameters; n < overloadNumParameters; ++n) {
            // TODO: inline constant initializers and skip varargs stub
            paramExprs[1 + n] = this.makeZero(overloadParameterTypes[n], overloadInstance.declaration);
            needsVarargsStub = true;
          }
          let calledName = needsVarargsStub
            ? this.ensureVarargsStub(overloadInstance).internalName
            : overloadInstance.internalName;
          let returnTypeRef = overloadSignature.returnType.toRef();
          let stmts = new Array<ExpressionRef>();
          if (needsVarargsStub) {
            // Safe to prepend since paramExprs are local.get's
            stmts.push(module.global_set(this.ensureArgumentsLength(), module.i32(numParameters)));
          }
          if (returnType == Type.void) {
            stmts.push(
              module.call(calledName, paramExprs, returnTypeRef)
            );
            stmts.push(
              module.return()
            );
          } else {
            stmts.push(
              module.return(
                module.call(calledName, paramExprs, returnTypeRef)
              )
            );
          }
          builder.addCase(classInstance.id, stmts);
          // Also alias each extendee inheriting this exact overload
          let extendees = classInstance.getAllExtendees(
            isProperty
              ? unboundOverloadParent.name
              : instance.prototype.name
          );
          for (let _values = Set_values(extendees), a = 0, b = _values.length; a < b; ++a) {
            let extendee = _values[a];
            builder.addCase(extendee.id, stmts);
          }
        }
      }
    }

    // Call the original function if no other id matches and the method is not
    // abstract or part of an interface. Note that doing so will not catch an
    // invalid id, but can reduce code size significantly since we also don't
    // have to add branches for extendees inheriting the original function.
    var body: ExpressionRef;
    if (instance.prototype.bodyNode) {
      let paramExprs = new Array<ExpressionRef>(numParameters);
      paramExprs[0] = module.local_get(0, sizeTypeRef); // this
      for (let i = 0, k = parameterTypes.length; i < k; ++i) {
        paramExprs[1 + i] = module.local_get(1 + i, parameterTypes[i].toRef());
      }
      body = module.call(instance.internalName, paramExprs, returnType.toRef());

    // Otherwise trap
    } else {
      body = module.unreachable();
    }

    // Create the virtual stub function
    var ref = stub.ref;
    if (ref) module.removeFunction(stub.internalName);
    stub.ref = module.addFunction(
      stub.internalName,
      stub.signature.paramRefs,
      stub.signature.resultRefs,
      [ TypeRef.I32 ],
      module.block(null, [
        builder.render(tempIndex),
        body
      ], returnType.toRef())
    );
    stub.set(CommonFlags.COMPILED);
  }

  /** Marks managed call operands for the shadow stack. */
  private operandsTostack(signature: Signature, operands: ExpressionRef[]): void {
    if (!this.options.stackSize) return;
    var module = this.module;
    var operandIndex = 0;
    var thisType = signature.thisType;
    if (thisType) {
      if (thisType.isManaged) {
        let operand = operands[0];
        let precomp = module.runExpression(operand, ExpressionRunnerFlags.Default);
        if (!isConstZero(precomp)) { // otherwise unnecessary
          operands[operandIndex] = module.tostack(operand);
        }
      }
      ++operandIndex;
    }
    var parameterIndex = 0;
    var parameterTypes = signature.parameterTypes;
    assert(parameterTypes.length >= operands.length - operandIndex);
    while (operandIndex < operands.length) {
      let paramType = parameterTypes[parameterIndex];
      if (paramType.isManaged) {
        let operand = operands[operandIndex];
        let precomp = module.runExpression(operand, ExpressionRunnerFlags.Default);
        if (!isConstZero(precomp)) { // otherwise unnecessary
          operands[operandIndex] = module.tostack(operand);
        }
      }
      ++operandIndex;
      ++parameterIndex;
    }
  }

  /** Creates a direct call to the specified function. */
  makeCallDirect(
    instance: Function,
    operands: ExpressionRef[] | null,
    reportNode: Node,
    immediatelyDropped: bool = false
  ): ExpressionRef {
    if (instance.hasDecorator(DecoratorFlags.INLINE)) {
      if (!instance.is(CommonFlags.VIRTUAL)) {
        assert(!instance.is(CommonFlags.STUB)); // doesn't make sense
        let inlineStack = this.inlineStack;
        if (inlineStack.includes(instance)) {
          this.warning(
            DiagnosticCode.Function_0_cannot_be_inlined_into_itself,
            reportNode.range, instance.internalName
          );
        } else {
          inlineStack.push(instance);
          let expr: ExpressionRef;
          if (instance.is(CommonFlags.INSTANCE)) {
            let theOperands = assert(operands);
            assert(theOperands.length);
            expr = this.makeCallInline(instance, theOperands.slice(1), theOperands[0], immediatelyDropped);
          } else {
            expr = this.makeCallInline(instance, operands, 0, immediatelyDropped);
          }
          inlineStack.pop();
          return expr;
        }
      } else {
        this.warning(
          DiagnosticCode.Function_0_is_virtual_and_will_not_be_inlined,
          reportNode.range, instance.internalName
        );
      }
    }
    var module = this.module;
    var numOperands = operands ? operands.length : 0;
    var numArguments = numOperands;
    var minArguments = instance.signature.requiredParameters;
    var minOperands = minArguments;
    var parameterTypes = instance.signature.parameterTypes;
    var maxArguments = parameterTypes.length;
    var maxOperands = maxArguments;
    if (instance.is(CommonFlags.INSTANCE)) {
      ++minOperands;
      ++maxOperands;
      --numArguments;
    }
    assert(numOperands >= minOperands);

    if (!this.compileFunction(instance)) return module.unreachable();
    var returnType = instance.signature.returnType;

    // fill up omitted arguments with their initializers, if constant, otherwise with zeroes.
    if (numOperands < maxOperands) {
      if (!operands) {
        operands = new Array(maxOperands);
        operands.length = 0;
      }
      let parameterNodes = instance.prototype.functionTypeNode.parameters;
      assert(parameterNodes.length == parameterTypes.length);
      let allOptionalsAreConstant = true;
      for (let i = numArguments; i < maxArguments; ++i) {
        let initializer = parameterNodes[i].initializer;
        if (initializer) {
          if (initializer.compilesToConst) {
            operands.push(this.compileExpression(
              initializer,
              parameterTypes[i],
              Constraints.CONV_IMPLICIT
            ));
            continue;
          }
          let resolved = this.resolver.lookupExpression(initializer, instance.flow, parameterTypes[i], ReportMode.SWALLOW);
          if (resolved) {
            if (resolved.kind == ElementKind.GLOBAL) {
              let global = <Global>resolved;
              if (this.compileGlobal(global)) {
                if (global.is(CommonFlags.INLINED)) {
                  operands.push(
                    this.compileInlineConstant(global, parameterTypes[i], Constraints.CONV_IMPLICIT)
                  );
                } else {
                  operands.push(
                    this.convertExpression(
                      module.global_get(global.internalName, global.type.toRef()),
                      global.type, parameterTypes[i], false, initializer
                    )
                  );
                }
                continue;
              }
            }
          }
        }
        operands.push(this.makeZero(parameterTypes[i], instance.declaration));
        allOptionalsAreConstant = false;
      }
      if (!allOptionalsAreConstant && !instance.is(CommonFlags.MODULE_IMPORT)) {
        let original = instance;
        instance = this.ensureVarargsStub(instance);
        if (!this.compileFunction(instance)) return module.unreachable();
        instance.flow.flags = original.flow.flags;
        let returnTypeRef = returnType.toRef();
        // We know the last operand is optional and omitted, so inject setting
        // ~argumentsLength into that operand, which is always safe.
        let lastOperand = operands[maxOperands - 1];
        assert(!(getSideEffects(lastOperand) & SideEffects.WritesGlobal));
        let lastOperandType = parameterTypes[maxArguments - 1];
        operands[maxOperands - 1] = module.block(null, [
          module.global_set(this.ensureArgumentsLength(), module.i32(numArguments)),
          lastOperand
        ], lastOperandType.toRef());
        this.operandsTostack(instance.signature, operands);
        let expr = module.call(instance.internalName, operands, returnTypeRef);
        if (returnType != Type.void && immediatelyDropped) {
          expr = module.drop(expr);
          this.currentType = Type.void;
        } else {
          this.currentType = returnType;
        }
        return expr;
      }
    }

    // Call the virtual stub with the vtable if the function has overloads
    if (instance.is(CommonFlags.VIRTUAL) && !reportNode.isAccessOnSuper) {
      instance = this.ensureVirtualStub(instance);
    }

    if (operands) this.operandsTostack(instance.signature, operands);
    var expr = module.call(instance.internalName, operands, returnType.toRef());
    this.currentType = returnType;
    return expr;
  }

  /** Compiles an indirect call to a first-class function. */
  compileCallIndirect(
    signature: Signature,
    functionArg: ExpressionRef,
    argumentExpressions: Expression[],
    reportNode: Node,
    thisArg: ExpressionRef = 0,
    immediatelyDropped: bool = false
  ): ExpressionRef {
    var numArguments = argumentExpressions.length;

    if (!this.checkCallSignature( // reports
      signature,
      numArguments,
      thisArg != 0,
      reportNode
    )) {
      return this.module.unreachable();
    }

    var numArgumentsInclThis = thisArg ? numArguments + 1 : numArguments;
    var operands = new Array<ExpressionRef>(numArgumentsInclThis);
    var index = 0;
    if (thisArg) {
      operands[0] = thisArg;
      index = 1;
    }
    var parameterTypes = signature.parameterTypes;
    for (let i = 0; i < numArguments; ++i, ++index) {
      operands[index] = this.compileExpression(argumentExpressions[i], parameterTypes[i],
        Constraints.CONV_IMPLICIT
      );
    }
    assert(index == numArgumentsInclThis);
    return this.makeCallIndirect(signature, functionArg, reportNode, operands, immediatelyDropped);
  }

  /** Creates an indirect call to a first-class function. */
  makeCallIndirect(
    signature: Signature,
    functionArg: ExpressionRef,
    reportNode: Node,
    operands: ExpressionRef[] | null = null,
    immediatelyDropped: bool = false,
  ): ExpressionRef {
    var module = this.module;
    var numOperands = operands ? operands.length : 0;
    var numArguments = numOperands;
    var minArguments = signature.requiredParameters;
    var minOperands = minArguments;
    var parameterTypes = signature.parameterTypes;
    var returnType = signature.returnType;
    var maxArguments = parameterTypes.length;
    var maxOperands = maxArguments;
    if (signature.thisType) {
      ++minOperands;
      ++maxOperands;
      --numArguments;
    }
    assert(numOperands >= minOperands);

    // fill up omitted arguments with zeroes
    if (numOperands < maxOperands) {
      if (!operands) {
        operands = new Array(maxOperands);
        operands.length = 0;
      }
      let parameterTypes = signature.parameterTypes;
      for (let i = numArguments; i < maxArguments; ++i) {
        operands.push(this.makeZero(parameterTypes[i], reportNode));
      }
    }

    // We might be calling a varargs stub here, even if all operands have been
    // provided, so we must set `argumentsLength` in any case. Inject setting it
    // into the index argument, which becomes executed last after any operands.
    var argumentsLength = this.ensureArgumentsLength();
    var sizeTypeRef = this.options.sizeTypeRef;
    if (getSideEffects(functionArg) & SideEffects.WritesGlobal) {
      let flow = this.currentFlow;
      let temp = flow.getTempLocal(this.options.usizeType, findUsedLocals(functionArg));
      functionArg = module.block(null, [
        module.local_set(temp.index, functionArg, true), // Function
        module.global_set(argumentsLength, module.i32(numArguments)),
        module.local_get(temp.index, sizeTypeRef)
      ], sizeTypeRef);
      flow.freeTempLocal(temp);
    } else { // simplify
      functionArg = module.block(null, [
        module.global_set(argumentsLength, module.i32(numArguments)),
        functionArg
      ], sizeTypeRef);
    }
    if (operands) this.operandsTostack(signature, operands);
    var expr = module.call_indirect(
      module.load(4, false, functionArg, TypeRef.I32), // ._index
      operands,
      signature.paramRefs,
      signature.resultRefs
    );
    this.currentType = returnType;
    return expr;
  }

  private compileCommaExpression(
    expression: CommaExpression,
    contextualType: Type,
    constraints: Constraints
  ): ExpressionRef {
    var expressions = expression.expressions;
    var numExpressions = expressions.length;
    var exprs = new Array<ExpressionRef>(numExpressions--);
    for (let i = 0; i < numExpressions; ++i) {
      exprs[i] = this.compileExpression(expressions[i], Type.void, // drop all except last
        Constraints.CONV_IMPLICIT | Constraints.WILL_DROP
      );
    }
    exprs[numExpressions] = this.compileExpression(expressions[numExpressions], contextualType, constraints);
    return this.module.flatten(exprs, this.currentType.toRef());
  }

  private compileElementAccessExpression(
    expression: ElementAccessExpression,
    contextualType: Type,
    constraints: Constraints
  ): ExpressionRef {
    var module = this.module;
    var targetExpression = expression.expression;
    var targetType = this.resolver.resolveExpression(targetExpression, this.currentFlow); // reports
    if (targetType) {
      let classReference = targetType.getClassOrWrapper(this.program);
      if (classReference) {
        let isUnchecked = this.currentFlow.is(FlowFlags.UNCHECKED_CONTEXT);
        let indexedGet = classReference.lookupOverload(OperatorKind.INDEXED_GET, isUnchecked);
        if (indexedGet) {
          let thisType = assert(indexedGet.signature.thisType);
          let thisArg = this.compileExpression(targetExpression, thisType,
            Constraints.CONV_IMPLICIT
          );
          if (!isUnchecked && this.options.pedantic) {
            this.pedantic(
              DiagnosticCode.Indexed_access_may_involve_bounds_checking,
              expression.range
            );
          }
          return this.compileCallDirect(indexedGet, [
            expression.elementExpression
          ], expression, thisArg, constraints);
        }
      }
      this.error(
        DiagnosticCode.Index_signature_is_missing_in_type_0,
        expression.expression.range, targetType.toString()
      );
    }
    return module.unreachable();
  }

  private compileFunctionExpression(
    expression: FunctionExpression,
    contextualType: Type,
    constraints: Constraints
  ): ExpressionRef {
    var declaration = expression.declaration.clone(); // generic contexts can have multiple
    assert(!declaration.typeParameters); // function expression cannot be generic
    var flow = this.currentFlow;
    var actualFunction = flow.actualFunction;
    var isNamed = declaration.name.text.length > 0;
    var isSemanticallyAnonymous = !isNamed || contextualType != Type.void;
    var prototype = new FunctionPrototype(
      isSemanticallyAnonymous
        ? (isNamed ? declaration.name.text + "|" : "anonymous|") + (actualFunction.nextAnonymousId++).toString()
        : declaration.name.text,
      actualFunction,
      declaration,
      DecoratorFlags.NONE
    );
    var instance: Function | null;
    var contextualTypeArguments = uniqueMap(flow.contextualTypeArguments);
    var module = this.module;

    // compile according to context. this differs from a normal function in that omitted parameter
    // and return types can be inferred and omitted arguments can be replaced with dummies.
    var contextualSignature = contextualType.signatureReference;
    if (contextualSignature) {
      let signatureNode = prototype.functionTypeNode;
      let parameterNodes = signatureNode.parameters;
      let numPresentParameters = parameterNodes.length;

      // must not require more than the maximum number of parameters
      let parameterTypes = contextualSignature.parameterTypes;
      let numParameters = parameterTypes.length;
      if (numPresentParameters > numParameters) {
        this.error(
          DiagnosticCode.Expected_0_arguments_but_got_1,
          expression.range, numParameters.toString(), numPresentParameters.toString()
        );
        return module.unreachable();
      }

      // check non-omitted parameter types
      for (let i = 0; i < numPresentParameters; ++i) {
        let parameterNode = parameterNodes[i];
        if (!isTypeOmitted(parameterNode.type)) {
          let resolvedType = this.resolver.resolveType(
            parameterNode.type,
            actualFunction.parent,
            contextualTypeArguments
          );
          if (!resolvedType) return module.unreachable();
          if (!parameterTypes[i].isStrictlyAssignableTo(resolvedType)) {
            this.error(
              DiagnosticCode.Type_0_is_not_assignable_to_type_1,
              parameterNode.range, parameterTypes[i].toString(), resolvedType.toString()
            );
            return module.unreachable();
          }
        }
        // any unused parameters are inherited but ignored
      }

      // check non-omitted return type
      let returnType = contextualSignature.returnType;
      if (!isTypeOmitted(signatureNode.returnType)) {
        let resolvedType = this.resolver.resolveType(
          signatureNode.returnType,
          actualFunction.parent,
          contextualTypeArguments
        );
        if (!resolvedType) return module.unreachable();
        if (
          returnType == Type.void
            ? resolvedType != Type.void
            : !resolvedType.isStrictlyAssignableTo(returnType)
        ) {
          this.error(
            DiagnosticCode.Type_0_is_not_assignable_to_type_1,
            signatureNode.returnType.range, resolvedType.toString(), returnType.toString()
          );
          return module.unreachable();
        }
      }

      // check explicit this type
      let thisType = contextualSignature.thisType;
      let thisTypeNode = signatureNode.explicitThisType;
      if (thisTypeNode) {
        if (!thisType) {
          this.error(
            DiagnosticCode._this_cannot_be_referenced_in_current_location,
            thisTypeNode.range
          );
          return module.unreachable();
        }
        let resolvedType = this.resolver.resolveType(
          thisTypeNode,
          actualFunction.parent,
          contextualTypeArguments
        );
        if (!resolvedType) return module.unreachable();
        if (!thisType.isStrictlyAssignableTo(resolvedType)) {
          this.error(
            DiagnosticCode.Type_0_is_not_assignable_to_type_1,
            thisTypeNode.range, thisType.toString(), resolvedType.toString()
          );
          return module.unreachable();
        }
      }

      let signature = new Signature(this.program, parameterTypes, returnType, thisType);
      signature.requiredParameters = numParameters; // !
      instance = new Function(
        prototype.name,
        prototype,
        null,
        signature,
        contextualTypeArguments
      );
      instance.flow.outer = flow;
      let worked = this.compileFunction(instance);
      this.currentType = contextualSignature.type;
      if (!worked) return module.unreachable();

    // otherwise compile like a normal function
    } else {
      instance = this.resolver.resolveFunction(prototype, null, contextualTypeArguments);
      if (!instance) return this.module.unreachable();
      instance.flow.outer = flow;
      let worked = this.compileFunction(instance);
      this.currentType = instance.signature.type;
      if (!worked) return module.unreachable();
    }

    var offset = this.ensureRuntimeFunction(instance); // reports
    var expr = this.options.isWasm64
      ? module.i64(i64_low(offset), i64_high(offset))
      : module.i32(i64_low(offset));

    // add a constant local referring to the function if applicable
    if (!isSemanticallyAnonymous) {
      let fname = instance.name;
      let existingLocal = flow.getScopedLocal(fname);
      if (existingLocal) {
        if (!existingLocal.declaration.range.source.isNative) {
          this.errorRelated(
            DiagnosticCode.Duplicate_identifier_0,
            declaration.name.range,
            existingLocal.declaration.name.range,
            fname
          );
        } else { // scoped locals are shared temps that don't track declarations
          this.error(
            DiagnosticCode.Duplicate_identifier_0,
            declaration.name.range, fname
          );
        }
      } else {
        let ftype = instance.type;
        let local = flow.addScopedLocal(instance.name, ftype);
        flow.setLocalFlag(local.index, LocalFlags.CONSTANT);
        expr = module.local_tee(local.index, expr, ftype.isManaged);
      }
    }

    return expr;
  }

  /** Makes sure the enclosing source file of the specified expression has been compiled. */
  private maybeCompileEnclosingSource(expression: Expression): void {
    var internalPath = expression.range.source.internalPath;
    var filesByName = this.program.filesByName;
    assert(filesByName.has(internalPath));
    var enclosingFile = assert(filesByName.get(internalPath));
    if (!enclosingFile.is(CommonFlags.COMPILED)) {
      this.compileFileByPath(internalPath, expression);
    }
  }

  private compileIdentifierExpression(
    expression: IdentifierExpression,
    contextualType: Type,
    constraints: Constraints
  ): ExpressionRef {
    var module = this.module;
    var flow = this.currentFlow;
    var actualFunction = flow.actualFunction;

    // check special keywords first
    switch (expression.kind) {
      case NodeKind.NULL: {
        let options = this.options;
        if (contextualType.isReference) {
          let classReference = contextualType.getClass();
          if (classReference) {
            this.currentType = classReference.type.asNullable();
            return options.isWasm64 ? module.i64(0) : module.i32(0);
          }
          let signatureReference = contextualType.getSignature();
          if (signatureReference) {
            this.currentType = signatureReference.type.asNullable();
            return options.isWasm64 ? module.i64(0) : module.i32(0);
          }
          return this.makeZero(contextualType, expression);
        }
        this.currentType = options.usizeType;
        this.warning(
          DiagnosticCode.Expression_resolves_to_unusual_type_0,
          expression.range, this.currentType.toString()
        );
        return options.isWasm64
          ? module.i64(0)
          : module.i32(0);
      }
      case NodeKind.TRUE: {
        this.currentType = Type.bool;
        return module.i32(1);
      }
      case NodeKind.FALSE: {
        this.currentType = Type.bool;
        return module.i32(0);
      }
      case NodeKind.THIS: {
        let thisType = actualFunction.signature.thisType;
        if (!thisType) {
          this.error(
            DiagnosticCode._this_cannot_be_referenced_in_current_location,
            expression.range
          );
          this.currentType = this.options.usizeType;
          return module.unreachable();
        }
        if (actualFunction.is(CommonFlags.CONSTRUCTOR)) {
          if (flow.is(FlowFlags.CTORPARAM_CONTEXT)) {
            this.error(
              DiagnosticCode._this_cannot_be_referenced_in_constructor_arguments,
              expression.range
            );
          }
          if (!(constraints & Constraints.IS_THIS)) {
            let parent = actualFunction.parent;
            assert(parent.kind == ElementKind.CLASS);
            this.checkFieldInitialization(<Class>parent, expression);
          }
        }
        let thisLocal = assert(flow.lookupLocal(CommonNames.this_));
        flow.set(FlowFlags.ACCESSES_THIS);
        this.currentType = thisType;
        return module.local_get(thisLocal.index, thisType.toRef());
      }
      case NodeKind.SUPER: {
        if (actualFunction.is(CommonFlags.CONSTRUCTOR)) {
          if (flow.is(FlowFlags.CTORPARAM_CONTEXT)) {
            this.error(
              DiagnosticCode._super_cannot_be_referenced_in_constructor_arguments,
              expression.range
            );
          } else if (!flow.is(FlowFlags.CALLS_SUPER)) {
            // TS1034 in the parser effectively limits this to property accesses
            this.error(
              DiagnosticCode._super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class,
              expression.range
            );
          }
        }
        if (flow.isInline) {
          let scopedThis = flow.lookupLocal(CommonNames.this_);
          if (scopedThis) {
            let scopedThisClass = assert(scopedThis.type.getClass());
            let base = scopedThisClass.base;
            if (base) {
              this.currentType = base.type;
              return module.local_get(scopedThis.index, base.type.toRef());
            }
          }
        }
        if (actualFunction.is(CommonFlags.INSTANCE)) {
          let parent = assert(actualFunction.parent);
          assert(parent.kind == ElementKind.CLASS);
          let classInstance = <Class>parent;
          let baseClassInstance = classInstance.base;
          if (baseClassInstance) {
            let superType = baseClassInstance.type;
            this.currentType = superType;
            return module.local_get(0, superType.toRef());
          }
        }
        this.error(
          DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,
          expression.range
        );
        this.currentType = this.options.usizeType;
        return module.unreachable();
      }
    }

    this.maybeCompileEnclosingSource(expression);

    // otherwise resolve
    var currentParent = this.currentParent;
    if (!currentParent) currentParent = actualFunction;
    var target = this.resolver.lookupIdentifierExpression( // reports
      expression,
      flow,
      currentParent
    );
    if (!target) {
      // make a guess to avoid assertions in calling code
      if (this.currentType == Type.void) this.currentType = Type.i32;
      return module.unreachable();
    }

    switch (target.kind) {
      case ElementKind.LOCAL: {
        let local = <Local>target;
        let localType = local.type;
        assert(localType != Type.void);
        if (this.pendingElements.has(local)) {
          this.error(
            DiagnosticCode.Variable_0_used_before_its_declaration,
            expression.range,
            local.internalName
          );
          this.currentType = localType;
          return module.unreachable();
        }
        if (local.is(CommonFlags.INLINED)) {
          return this.compileInlineConstant(local, contextualType, constraints);
        }
        let localIndex = local.index;
        assert(localIndex >= 0);
        if (localType.isNullableReference && flow.isLocalFlag(localIndex, LocalFlags.NONNULL, false)) {
          localType = localType.nonNullableType;
        }
        this.currentType = localType;

        if (target.parent != flow.parentFunction) {
          // TODO: closures
          this.error(
            DiagnosticCode.Not_implemented_0,
            expression.range,
            "Closures"
          );
          return module.unreachable();
        }
        return module.local_get(localIndex, localType.toRef());
      }
      case ElementKind.GLOBAL: {
        let global = <Global>target;
        if (!this.compileGlobal(global)) { // reports; not yet compiled if a static field
          return module.unreachable();
        }
        let globalType = global.type;
        if (this.pendingElements.has(global)) {
          this.error(
            DiagnosticCode.Variable_0_used_before_its_declaration,
            expression.range,
            global.internalName
          );
          this.currentType = globalType;
          return module.unreachable();
        }
        assert(globalType != Type.void);
        if (global.is(CommonFlags.INLINED)) {
          return this.compileInlineConstant(global, contextualType, constraints);
        }
        this.currentType = globalType;
        return module.global_get(global.internalName, globalType.toRef());
      }
      case ElementKind.ENUMVALUE: { // here: if referenced from within the same enum
        let enumValue = <EnumValue>target;
        if (!target.is(CommonFlags.COMPILED)) {
          this.error(
            DiagnosticCode.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums,
            expression.range
          );
          this.currentType = Type.i32;
          return module.unreachable();
        }
        this.currentType = Type.i32;
        if (enumValue.is(CommonFlags.INLINED)) {
          assert(enumValue.constantValueKind == ConstantValueKind.INTEGER);
          return module.i32(i64_low(enumValue.constantIntegerValue));
        }
        return module.global_get(enumValue.internalName, TypeRef.I32);
      }
      case ElementKind.FUNCTION_PROTOTYPE: {
        let functionPrototype = <FunctionPrototype>target;
        let typeParameterNodes = functionPrototype.typeParameterNodes;

        if (typeParameterNodes !== null && typeParameterNodes.length != 0) {
          this.error(
            DiagnosticCode.Expected_0_arguments_but_got_1,
            expression.range, typeParameterNodes.length.toString(), "0"
          );
          return module.unreachable();
        }

        let functionInstance = this.resolver.resolveFunction(
          functionPrototype,
          null,
          uniqueMap<string,Type>(flow.contextualTypeArguments)
        );
        if (!functionInstance || !this.compileFunction(functionInstance)) return module.unreachable();
        if (contextualType.isExternalReference) {
          this.currentType = Type.funcref;
          return module.ref_func(functionInstance.internalName, TypeRef.Funcref); // TODO
        }
        let offset = this.ensureRuntimeFunction(functionInstance);
        this.currentType = functionInstance.signature.type;
        return this.options.isWasm64
          ? module.i64(i64_low(offset), i64_high(offset))
          : module.i32(i64_low(offset));
      }
    }
    this.error(
      DiagnosticCode.Expression_refers_to_a_static_element_that_does_not_compile_to_a_value_at_runtime,
      expression.range
    );
    return this.module.unreachable();
  }

  private compileInstanceOfExpression(
    expression: InstanceOfExpression,
    contextualType: Type,
    constraints: Constraints
  ): ExpressionRef {
    var flow = this.currentFlow;
    var isType = expression.isType;

    // Mimic `instanceof CLASS`
    if (isType.kind == NodeKind.NAMEDTYPE) {
      let namedType = <NamedTypeNode>isType;
      if (!(namedType.isNullable || namedType.hasTypeArguments)) {
        let element = this.resolver.resolveTypeName(namedType.name, flow.actualFunction, ReportMode.SWALLOW);
        if (element !== null && element.kind == ElementKind.CLASS_PROTOTYPE) {
          let prototype = <ClassPrototype>element;
          if (prototype.is(CommonFlags.GENERIC)) {
            return this.makeInstanceofClass(expression, prototype);
          }
        }
      }
    }

    // Fall back to `instanceof TYPE`
    var expectedType = this.resolver.resolveType(
      expression.isType,
      flow.actualFunction,
      uniqueMap(flow.contextualTypeArguments)
    );
    if (!expectedType) {
      this.currentType = Type.bool;
      return this.module.unreachable();
    }
    return this.makeInstanceofType(expression, expectedType);
  }

  private makeInstanceofType(expression: InstanceOfExpression, expectedType: Type): ExpressionRef {
    var module = this.module;
    var flow = this.currentFlow;
    var expr = this.compileExpression(expression.expression, expectedType);
    var actualType = this.currentType;
    this.currentType = Type.bool;

    // instanceof <value> - must be exact
    if (expectedType.isValue) {
      return module.maybeDropCondition(expr, module.i32(actualType == expectedType ? 1 : 0));
    }

    // <value> instanceof <nonValue> - always false
    if (actualType.isValue) {
      return module.maybeDropCondition(expr, module.i32(0));
    }

    // both LHS and RHS are references now
    var sizeTypeRef = actualType.toRef();

    // <nullable> instanceof <nonNullable> - LHS must be != 0
    if (actualType.isNullableReference && !expectedType.isNullableReference) {

      // downcast - check statically
      if (actualType.nonNullableType.isAssignableTo(expectedType)) {
        return module.binary(
          sizeTypeRef == TypeRef.I64
            ? BinaryOp.NeI64
            : BinaryOp.NeI32,
          expr,
          this.makeZero(actualType, expression.expression)
        );
      }

      // upcast - check dynamically
      if (expectedType.isAssignableTo(actualType)) {
        let program = this.program;
        if (!(actualType.isUnmanaged || expectedType.isUnmanaged)) {
          let temp = flow.getTempLocal(actualType);
          let instanceofInstance = assert(program.instanceofInstance);
          this.compileFunction(instanceofInstance);
          let ret = module.if(
            module.unary(
              sizeTypeRef == TypeRef.I64
                ? UnaryOp.EqzI64
                : UnaryOp.EqzI32,
              module.local_tee(temp.index, expr, actualType.isManaged),
            ),
            module.i32(0),
            this.makeCallDirect(instanceofInstance, [
              module.local_get(temp.index, sizeTypeRef),
              module.i32(expectedType.classReference!.id)
            ], expression)
          );
          flow.freeTempLocal(temp);
          if (this.options.pedantic) {
            this.pedantic(
              DiagnosticCode.Expression_compiles_to_a_dynamic_check_at_runtime,
              expression.range
            );
          }
          return ret;
        } else {
          this.error(
            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,
            expression.range, "instanceof", actualType.toString(), expectedType.toString()
          );
        }
      }

    // either none or both nullable
    } else {

      // downcast - check statically
      if (actualType.isAssignableTo(expectedType)) {
        return module.maybeDropCondition(expr, module.i32(1));

      // upcast - check dynamically
      } else if (expectedType.isAssignableTo(actualType)) {
        let program = this.program;
        if (!(actualType.isUnmanaged || expectedType.isUnmanaged)) {
          // FIXME: the temp local and the if can be removed here once flows
          // perform null checking, which would error earlier when checking
          // uninitialized (thus zero) `var a: A` to be an instance of something.
          let temp = flow.getTempLocal(actualType);
          let instanceofInstance = assert(program.instanceofInstance);
          this.compileFunction(instanceofInstance);
          let ret = module.if(
            module.unary(
              sizeTypeRef == TypeRef.I64
                ? UnaryOp.EqzI64
                : UnaryOp.EqzI32,
              module.local_tee(temp.index, expr, actualType.isManaged),
            ),
            module.i32(0),
            this.makeCallDirect(instanceofInstance, [
              module.local_get(temp.index, sizeTypeRef),
              module.i32(expectedType.classReference!.id)
            ], expression)
          );
          flow.freeTempLocal(temp);
          return ret;
        } else {
          this.error(
            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,
            expression.range, "instanceof", actualType.toString(), expectedType.toString()
          );
        }
      }
    }

    // false
    return module.maybeDropCondition(expr, module.i32(0));
  }

  private makeInstanceofClass(expression: InstanceOfExpression, prototype: ClassPrototype): ExpressionRef {
    var module = this.module;
    var expr = this.compileExpression(expression.expression, Type.auto);
    var actualType = this.currentType;
    var sizeTypeRef = actualType.toRef();

    this.currentType = Type.bool;

    // exclusively interested in class references here
    var classReference = actualType.getClass();
    if (classReference) {

      // static check
      if (classReference.extends(prototype)) {

        // <nullable> instanceof <PROTOTYPE> - LHS must be != 0
        if (actualType.isNullableReference) {
          return module.binary(
            sizeTypeRef == TypeRef.I64
              ? BinaryOp.NeI64
              : BinaryOp.NeI32,
            expr,
            this.makeZero(actualType, expression.expression)
          );

        // <nonNullable> is just `true`
        } else {
          return module.maybeDropCondition(expr, module.i32(1));
        }

      // dynamic check against all possible concrete ids
      } else if (prototype.extends(classReference.prototype)) {
        this.pendingClassInstanceOf.add(prototype);
        return module.call(prototype.internalName + "~instanceof", [ expr ], TypeRef.I32);
      }
    }

    // false
    return module.maybeDropCondition(expr, module.i32(0));
  }

  private compileLiteralExpression(
    expression: LiteralExpression,
    contextualType: Type,
    constraints: Constraints,
    implicitlyNegate: bool = false
  ): ExpressionRef {
    var module = this.module;
    switch (expression.literalKind) {
      case LiteralKind.ARRAY: {
        assert(!implicitlyNegate);
        return this.compileArrayLiteral(
          <ArrayLiteralExpression>expression,
          contextualType,
          constraints
        );
      }
      case LiteralKind.FLOAT: {
        let floatValue = (<FloatLiteralExpression>expression).value;
        if (implicitlyNegate) {
          floatValue = -floatValue;
        }
        if (contextualType == Type.f32) {
          return module.f32(<f32>floatValue);
        }
        this.currentType = Type.f64;
        return module.f64(floatValue);
      }
      case LiteralKind.INTEGER: {
        let intValue = (<IntegerLiteralExpression>expression).value;
        if (implicitlyNegate) {
          intValue = i64_sub(
            i64_new(0),
            intValue
          );
        }
        let type = this.resolver.determineIntegerLiteralType(intValue, contextualType);
        this.currentType = type;
        switch (type.kind) {
          case TypeKind.ISIZE: if (!this.options.isWasm64) return module.i32(i64_low(intValue));
          case TypeKind.I64: return module.i64(i64_low(intValue), i64_high(intValue));
          case TypeKind.USIZE: if (!this.options.isWasm64) return module.i32(i64_low(intValue));
          case TypeKind.U64: return module.i64(i64_low(intValue), i64_high(intValue));
          case TypeKind.F32: return module.f32(i64_to_f32(intValue));
          case TypeKind.F64: return module.f64(i64_to_f64(intValue));
          default: return module.i32(i64_low(intValue));
        }
      }
      case LiteralKind.STRING: {
        assert(!implicitlyNegate);
        return this.compileStringLiteral(<StringLiteralExpression>expression, constraints);
      }
      case LiteralKind.TEMPLATE: {
        assert(!implicitlyNegate);
        return this.compileTemplateLiteral(<TemplateLiteralExpression>expression, constraints);
      }
      case LiteralKind.OBJECT: {
        assert(!implicitlyNegate);
        return this.compileObjectLiteral(<ObjectLiteralExpression>expression, contextualType);
      }
      case LiteralKind.REGEXP: {
        this.error(
          DiagnosticCode.Not_implemented_0,
          expression.range,
          "Regular expressions"
        );
        this.currentType = contextualType;
        return module.unreachable();
      }
    }
    assert(false);
    return module.unreachable();
  }

  private compileStringLiteral(
    expression: StringLiteralExpression,
    constraints: Constraints
  ): ExpressionRef {
    return this.ensureStaticString(expression.value);
  }

  private compileTemplateLiteral(
    expression: TemplateLiteralExpression,
    constraints: Constraints
  ): ExpressionRef {
    var tag = expression.tag;
    var parts = expression.parts;
    var numParts = parts.length;
    var expressions = expression.expressions;
    assert(numParts - 1 == expressions.length);

    var module = this.module;
    var stringInstance = this.program.stringInstance;
    var stringType = stringInstance.type;

    if (tag === null) {
      // Shortcut if just a (multi-line) string
      if (numParts == 1) {
        return this.ensureStaticString(parts[0]);
      }

      // Shortcut for `${expr}`, `<prefix>${expr}`, `${expr}<suffix>`
      if (numParts == 2) {
        let expression = expressions[0];
        let lhsLen = parts[0].length;
        let rhsLen = parts[1].length;
        // Shortcut for `${expr}`  ->   expr.toString()
        if (!lhsLen && !rhsLen) {
          return this.makeToString(
            this.compileExpression(expression, stringType),
            this.currentType, expression
          );
        }
        // Shortcuts for
        // `<prefix>${expr}`  ->  "<prefix>" + expr.toString()
        // `${expr}<suffix>`  ->  expr.toString() + "<suffix>"
        let hasPrefix = lhsLen != 0;
        // @ts-ignore: cast
        if (hasPrefix ^ (rhsLen != 0)) {
          let lhs: ExpressionRef;
          let rhs: ExpressionRef;
          let expr = this.makeToString(
            this.compileExpression(expression, stringType),
            this.currentType, expression
          );
          if (hasPrefix) {
            lhs = this.ensureStaticString(parts[0]);
            rhs = expr;
          } else {
            // suffix
            lhs = expr;
            rhs = this.ensureStaticString(parts[1]);
          }
          let concatMethod = assert(stringInstance.getMethod("concat"));
          return this.makeCallDirect(concatMethod, [ lhs, rhs ], expression);
        }
      }

      // Shortcut for `${exprA}${exprB}`  ->  exprA.toString() + exprB.toString()
      if (numParts == 3 && !parts[0].length && !parts[1].length && !parts[2].length) {
        let exprA = expressions[0];
        let exprB = expressions[1];

        let lhs = this.makeToString(
          this.compileExpression(exprA, stringType),
          this.currentType, exprA
        );
        let rhs = this.makeToString(
          this.compileExpression(exprB, stringType),
          this.currentType, exprB
        );
        let concatMethod = assert(stringInstance.getMethod("concat"));
        return this.makeCallDirect(concatMethod, [ lhs, rhs ], expression);
      }

      // Compile to a `StaticArray<string>#join("") for general case
      let length = 2 * numParts - 1;
      let values = new Array<usize>(length);
      values[0] = this.ensureStaticString(parts[0]);
      for (let i = 1; i < numParts; ++i) {
        values[2 * i - 1] = module.usize(0);
        values[2 * i] = this.ensureStaticString(parts[i]);
      }
      let arrayInstance = assert(this.resolver.resolveClass(this.program.staticArrayPrototype, [ stringType ]));
      let segment = this.addStaticBuffer(stringType, values, arrayInstance.id);
      let offset = i64_add(segment.offset, i64_new(this.program.totalOverhead));
      let joinInstance = assert(arrayInstance.getMethod("join"));
      let indexedSetInstance = assert(arrayInstance.lookupOverload(OperatorKind.INDEXED_SET, true));
      let stmts = new Array<ExpressionRef>(numParts);
      for (let i = 0, k = numParts - 1; i < k; ++i) {
        let expression = expressions[i];
        stmts[i] = this.makeCallDirect(indexedSetInstance, [
          module.usize(offset),
          module.i32(2 * i + 1),
          this.makeToString(
            this.compileExpression(expression, stringType),
            this.currentType, expression
          )
        ], expression);
      }
      stmts[numParts - 1] = this.makeCallDirect(joinInstance, [
        module.usize(offset),
        this.ensureStaticString("")
      ], expression);
      return module.flatten(stmts, stringType.toRef());
    }

    // Try to find out whether the template function takes a full-blown TemplateStringsArray or if
    // it is sufficient to compile to a normal array. While technically incorrect, this allows us
    // to avoid generating unnecessary static data that is not explicitly signaled to be used.
    var tsaArrayInstance = this.program.templateStringsArrayInstance;
    var arrayInstance = tsaArrayInstance;
    var target = this.resolver.lookupExpression(tag, this.currentFlow, Type.auto, ReportMode.SWALLOW);
    if (target) {
      switch (target.kind) {
        case ElementKind.FUNCTION_PROTOTYPE: {
          let instance = this.resolver.resolveFunction(
            <FunctionPrototype>target,
            null,
            uniqueMap<string,Type>(),
            ReportMode.SWALLOW
          );
          if (!instance) break;
          target = instance;
          // fall-through
        }
        case ElementKind.FUNCTION: {
          let instance = <Function>target;
          let parameterTypes = instance.signature.parameterTypes;
          if (parameterTypes.length) {
            let first = parameterTypes[0].getClass();
            if (first !== null && !first.extends(tsaArrayInstance.prototype)) {
              arrayInstance = assert(this.resolver.resolveClass(this.program.arrayPrototype, [ stringType ]));
            }
          }
          break;
        }
      }
    }

    // Compile to a call to the tag function
    var rawParts = expression.rawParts;
    assert(rawParts.length == numParts);
    var partExprs = new Array<ExpressionRef>(numParts);
    for (let i = 0; i < numParts; ++i) {
      partExprs[i] = this.ensureStaticString(parts[i]);
    }
    var arraySegment: MemorySegment;
    if (arrayInstance == tsaArrayInstance) {
      var rawExprs = new Array<ExpressionRef>(numParts);
      for (let i = 0; i < numParts; ++i) {
        rawExprs[i] = this.ensureStaticString(rawParts[i]);
      }
      arraySegment = this.addStaticArrayHeader(stringType,
        this.addStaticBuffer(this.options.usizeType, partExprs),
        arrayInstance
      );
      var rawHeaderSegment = this.addStaticArrayHeader(stringType,
        this.addStaticBuffer(this.options.usizeType, rawExprs)
      );
      arrayInstance.writeField("raw",
        i64_add(rawHeaderSegment.offset, i64_new(this.program.totalOverhead)),
        arraySegment.buffer
      );
    } else {
      arraySegment = this.addStaticArrayHeader(stringType,
        this.addStaticBuffer(this.options.usizeType, partExprs),
        arrayInstance
      );
    }

    // Desugar to compileCallExpression
    var args = expressions.slice();
    args.unshift(
      Node.createCompiledExpression(
        module.usize(i64_add(arraySegment.offset, i64_new(this.program.totalOverhead))),
        arrayInstance.type,
        this.program.nativeRange
      )
    );
    // TODO: Requires ReadonlyArray to be safe
    this.error(
      DiagnosticCode.Not_implemented_0,
      expression.range, "Tagged template literals"
    );
    return this.compileCallExpressionLike(tag, null, args, expression.range, stringType);
  }

  private compileArrayLiteral(
    expression: ArrayLiteralExpression,
    contextualType: Type,
    constraints: Constraints
  ): ExpressionRef {
    var module = this.module;
    var flow = this.currentFlow;
    var program = this.program;

    // handle static arrays
    let contextualClass = contextualType.getClass();
    if (contextualClass !== null && contextualClass.extends(program.staticArrayPrototype)) {
      return this.compileStaticArrayLiteral(expression, contextualType, constraints);
    }

    // handle normal arrays
    var element = this.resolver.lookupExpression(expression, flow, this.currentType);
    if (!element) return module.unreachable();
    assert(element.kind == ElementKind.CLASS);
    var arrayInstance = <Class>element;
    var arrayType = arrayInstance.type;
    var elementType = arrayInstance.getTypeArgumentsTo(program.arrayPrototype)![0];
    var arrayBufferInstance = assert(program.arrayBufferInstance);

    // block those here so compiling expressions doesn't conflict
    var tempThis = flow.getTempLocal(this.options.usizeType);
    var tempDataStart = flow.getTempLocal(arrayBufferInstance.type);

    // compile value expressions and find out whether all are constant
    var expressions = expression.elementExpressions;
    var length = expressions.length;
    var values = new Array<ExpressionRef>(length);
    var isStatic = !elementType.isExternalReference;
    for (let i = 0; i < length; ++i) {
      let elementExpression = expressions[i];
      if (elementExpression.kind != NodeKind.OMITTED) {
        let expr = this.compileExpression(<Expression>elementExpression, elementType, Constraints.CONV_IMPLICIT);
        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);
        if (precomp) {
          expr = precomp;
        } else {
          isStatic = false;
        }
        values[i] = expr;
      } else {
        values[i] = this.makeZero(elementType, elementExpression);
      }
    }

    // if the array is static, make a static arraybuffer segment
    if (isStatic) {
      flow.freeTempLocal(tempThis);
      flow.freeTempLocal(tempDataStart);

      let totalOverhead = program.totalOverhead;
      let bufferSegment = this.addStaticBuffer(elementType, values);
      let bufferAddress = i64_add(bufferSegment.offset, i64_new(totalOverhead));

      // make both the buffer and array header static if assigned to a global. this can't be done
      // if inside of a function because each invocation must create a new array reference then.
      if (constraints & Constraints.PREFER_STATIC) {
        let arraySegment = this.addStaticArrayHeader(elementType, bufferSegment);
        let arrayAddress = i64_add(arraySegment.offset, i64_new(totalOverhead));
        this.currentType = arrayType;
        return program.options.isWasm64
          ? this.module.i64(i64_low(arrayAddress), i64_high(arrayAddress))
          : this.module.i32(i64_low(arrayAddress));

      // otherwise allocate a new array header and make it wrap a copy of the static buffer
      } else {
        // __newArray(length, alignLog2, classId, staticBuffer)
        let expr = this.makeCallDirect(program.newArrayInstance, [
          module.i32(length),
          program.options.isWasm64
            ? module.i64(elementType.alignLog2)
            : module.i32(elementType.alignLog2),
          module.i32(arrayInstance.id),
          program.options.isWasm64
            ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))
            : module.i32(i64_low(bufferAddress))
        ], expression);
        this.currentType = arrayType;
        return expr;
      }
    }

    // otherwise compile an explicit instantiation with indexed sets
    var indexedSet = arrayInstance.lookupOverload(OperatorKind.INDEXED_SET, true);
    if (!indexedSet) {
      flow.freeTempLocal(tempThis);
      flow.freeTempLocal(tempDataStart);
      this.error(
        DiagnosticCode.Index_signature_in_type_0_only_permits_reading,
        expression.range, arrayInstance.internalName
      );
      this.currentType = arrayType;
      return module.unreachable();
    }
    var arrayTypeRef = arrayType.toRef();

    var stmts = new Array<ExpressionRef>();
    // tempThis = __newArray(length, alignLog2, classId, source = 0)
    stmts.push(
      module.local_set(tempThis.index,
        this.makeCallDirect(program.newArrayInstance, [
          module.i32(length),
          program.options.isWasm64
            ? module.i64(elementType.alignLog2)
            : module.i32(elementType.alignLog2),
          module.i32(arrayInstance.id),
          program.options.isWasm64
            ? module.i64(0)
            : module.i32(0)
        ], expression),
        arrayType.isManaged
      )
    );
    // tempData = tempThis.dataStart
    var dataStartMember = assert(arrayInstance.lookupInSelf("dataStart"));
    assert(dataStartMember.kind == ElementKind.FIELD);
    stmts.push(
      module.local_set(tempDataStart.index,
        module.load(arrayType.byteSize, false,
          module.local_get(tempThis.index, arrayTypeRef),
          arrayTypeRef,
          (<Field>dataStartMember).memoryOffset
        ),
        true // ArrayBuffer
      )
    );
    for (let i = 0; i < length; ++i) {
      // this[i] = value
      stmts.push(
        module.call(indexedSet.internalName, [
          module.local_get(tempThis.index, arrayTypeRef),
          module.i32(i),
          values[i]
        ], TypeRef.None)
      );
    }
    // -> tempThis
    stmts.push(
      module.local_get(tempThis.index, arrayTypeRef)
    );
    flow.freeTempLocal(tempThis);
    flow.freeTempLocal(tempDataStart);
    if (length) this.compileFunction(indexedSet);
    this.currentType = arrayType;
    return module.flatten(stmts, arrayTypeRef);
  }

  /** Compiles a special `fixed` array literal. */
  private compileStaticArrayLiteral(
    expression: ArrayLiteralExpression,
    contextualType: Type,
    constraints: Constraints
  ): ExpressionRef {
    var module = this.module;
    var flow = this.currentFlow;
    var program = this.program;

    // make sure this method is only called with a valid contextualType
    var arrayInstance = assert(contextualType.getClass());
    var arrayType = arrayInstance.type;
    var typeArguments = assert(arrayInstance.getTypeArgumentsTo(program.staticArrayPrototype));
    var elementType = typeArguments[0];

    // block those here so compiling expressions doesn't conflict
    var tempThis = flow.getTempLocal(this.options.usizeType);

    // compile value expressions and check if all are compile-time constants
    var expressions = expression.elementExpressions;
    var length = expressions.length;
    var values = new Array<ExpressionRef>(length);
    var isStatic = !elementType.isExternalReference;
    for (let i = 0; i < length; ++i) {
      let elementExpression = expressions[i];
      if (elementExpression.kind != NodeKind.OMITTED) {
        let expr = this.compileExpression(elementExpression, elementType, Constraints.CONV_IMPLICIT);
        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);
        if (precomp) {
          expr = precomp;
        } else {
          isStatic = false;
        }
        values[i] = expr;
      } else {
        values[i] = this.makeZero(elementType, elementExpression);
      }
    }

    var isWasm64 = this.options.isWasm64;
    var bufferSize = values.length << elementType.alignLog2;

    // if the array is static, make a static arraybuffer segment
    if (isStatic) {
      flow.freeTempLocal(tempThis);

      let bufferSegment = this.addStaticBuffer(elementType, values, arrayInstance.id);
      let bufferAddress = i64_add(bufferSegment.offset, i64_new(program.totalOverhead));

      // return the static buffer directly if assigned to a global
      if (constraints & Constraints.PREFER_STATIC) {
        let expr = this.options.isWasm64
          ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))
          : module.i32(i64_low(bufferAddress));
        this.currentType = arrayType;
        return expr;

      // otherwise allocate a new chunk of memory and return a copy of the buffer
      } else {
        // __newBuffer(bufferSize, id, buffer)
        let expr = this.makeCallDirect(program.newBufferInstance, [
          isWasm64
            ? module.i64(bufferSize)
            : module.i32(bufferSize),
          module.i32(arrayInstance.id),
          isWasm64
            ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))
            : module.i32(i64_low(bufferAddress))
        ], expression);
        this.currentType = arrayType;
        return expr;
      }
    }

    // otherwise compile an explicit instantiation with indexed sets
    var indexedSet = arrayInstance.lookupOverload(OperatorKind.INDEXED_SET, true);
    if (!indexedSet) {
      flow.freeTempLocal(tempThis);
      this.error(
        DiagnosticCode.Index_signature_in_type_0_only_permits_reading,
        expression.range, arrayInstance.internalName
      );
      this.currentType = arrayType;
      return module.unreachable();
    }
    var arrayTypeRef = arrayType.toRef();

    var stmts = new Array<ExpressionRef>();
    // tempThis = __newBuffer(bufferSize, classId)
    stmts.push(
      module.local_set(tempThis.index,
        this.makeCallDirect(program.newBufferInstance, [
          isWasm64
            ? module.i64(bufferSize)
            : module.i32(bufferSize),
          module.i32(arrayInstance.id)
        ], expression),
        arrayType.isManaged
      )
    );
    for (let i = 0; i < length; ++i) {
      // array[i] = value
      stmts.push(
        module.call(indexedSet.internalName, [
          module.local_get(tempThis.index, arrayTypeRef),
          module.i32(i),
          values[i]
        ], TypeRef.None)
      );
    }
    // -> tempThis
    stmts.push(
      module.local_get(tempThis.index, arrayTypeRef)
    );
    flow.freeTempLocal(tempThis);
    if (length) this.compileFunction(indexedSet);
    this.currentType = arrayType;
    return module.flatten(stmts, arrayTypeRef);
  }

  private compileObjectLiteral(expression: ObjectLiteralExpression, contextualType: Type): ExpressionRef {
    var module = this.module;

    // Check that contextual type is a class (TODO: hidden class for interfaces?)
    var classReference = contextualType.getClass();
    if (!classReference) {
      this.error(
        DiagnosticCode.Type_0_is_not_assignable_to_type_1,
        expression.range, "<object>", contextualType.toString()
      );
      return module.unreachable();
    }
    var classType = classReference.type;
    this.currentType = classType.nonNullableType;
    if (classReference.is(CommonFlags.ABSTRACT)) {
      this.error(
        DiagnosticCode.Cannot_create_an_instance_of_an_abstract_class,
        expression.range
      );
      return module.unreachable();
    }

    // Check that the class is compatible with object literals
    var ctorPrototype = classReference.prototype.constructorPrototype;
    if (ctorPrototype) {
      this.errorRelated(
        DiagnosticCode.Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal,
        expression.range, ctorPrototype.identifierNode.range, classType.toString()
      );
      return module.unreachable();
    }

    var isManaged = classType.isManaged;
    if (!isManaged) {
      this.checkUnsafe(expression, findDecorator(DecoratorKind.UNMANAGED, classReference.decoratorNodes));
    }

    // check and compile field values
    var names = expression.names;
    var numNames = names.length;
    var values = expression.values;
    var members = classReference.members;
    var hasErrors = false;
    var exprs = new Array<ExpressionRef>();
    var flow = this.currentFlow;
    var tempLocal = flow.getTempLocal(classType);
    var classTypeRef = classType.toRef();
    assert(numNames == values.length);

    // Assume all class fields will be omitted, and add them to our omitted list
    var omittedFields = new Set<Field>();
    if (members) {
      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {
        let memberKey = _keys[i];
        let member = assert(members.get(memberKey));
        if (member !== null && member.kind == ElementKind.FIELD) {
          omittedFields.add(<Field>member); // incl. private/protected
        }
      }
    }

    // Iterate through the members defined in our expression
    for (let i = 0; i < numNames; ++i) {
      let memberName = names[i].text;
      let member: DeclaredElement;
      if (!members || !members.has(memberName) || (member = assert(members.get(memberName))).kind != ElementKind.FIELD) {
        this.error(
          DiagnosticCode.Property_0_does_not_exist_on_type_1,
          names[i].range, memberName, classType.toString()
        );
        hasErrors = true;
        continue;
      }
      if (member.is(CommonFlags.PRIVATE)) {
        this.error(
          DiagnosticCode.Property_0_is_private_and_only_accessible_within_class_1,
          names[i].range, memberName, classType.toString()
        );
        hasErrors = true;
        continue;
      }
      if (member.is(CommonFlags.PROTECTED)) {
        this.error(
          DiagnosticCode.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses,
          names[i].range, memberName, classType.toString()
        );
        hasErrors = true;
        continue;
      }
      let fieldInstance = <Field>member;
      let fieldType = fieldInstance.type;

      let expr = this.compileExpression(values[i], fieldType, Constraints.CONV_IMPLICIT);
      exprs.push(
        module.call(fieldInstance.internalSetterName, [
          module.local_get(tempLocal.index, classTypeRef),
          expr
        ], TypeRef.None)
      );
      this.compileFieldSetter(fieldInstance);

      // This member is no longer omitted, so delete from our omitted fields
      omittedFields.delete(fieldInstance);
    }
    this.currentType = classType.nonNullableType;
    if (hasErrors) return module.unreachable();

    // Check remaining omitted fields
    for (let _values = Set_values(omittedFields), j = 0, l = _values.length; j < l; ++j) {
      let fieldInstance = _values[j];
      let fieldType = fieldInstance.type;

      if (fieldInstance.initializerNode) {
        continue; // set by generated ctor
      }

      if (fieldType.isReference) {
        if (!fieldType.isNullableReference) {
          this.error(
            DiagnosticCode.Property_0_is_missing_in_type_1_but_required_in_type_2,
            expression.range, fieldInstance.name, "<object>", classType.toString()
          );
          hasErrors = true;
          continue;
        }
      }

      switch (fieldType.kind) {
        // Number Types (and Number alias types)
        case TypeKind.I8:
        case TypeKind.I16:
        case TypeKind.I32:
        case TypeKind.I64:
        case TypeKind.ISIZE:
        case TypeKind.U8:
        case TypeKind.U16:
        case TypeKind.U32:
        case TypeKind.U64:
        case TypeKind.USIZE:
        case TypeKind.BOOL:
        case TypeKind.F32:
        case TypeKind.F64: {
          exprs.push(
            module.call(fieldInstance.internalSetterName, [
              module.local_get(tempLocal.index, classTypeRef),
              this.makeZero(fieldType, expression)
            ], TypeRef.None)
          );
          this.compileFieldSetter(fieldInstance);
          continue;
        }
      }

      // Otherwise error
      this.error(
        DiagnosticCode.Property_0_is_missing_in_type_1_but_required_in_type_2,
        expression.range, fieldInstance.name, "<object>", classType.toString()
      );
      hasErrors = true;
    }
    if (hasErrors) return module.unreachable();

    // generate the default constructor
    var ctor = this.ensureConstructor(classReference, expression);
    // note that this is not checking field initialization within the ctor, but
    // instead checks conditions above with provided fields taken into account.

    // allocate a new instance first and assign 'this' to the temp. local
    exprs.unshift(
      module.local_set(tempLocal.index,
        this.compileInstantiate(ctor, [], Constraints.NONE, expression),
        classType.isManaged
      )
    );

    // once all field values have been set, return 'this'
    exprs.push(
      module.local_get(tempLocal.index, classTypeRef)
    );

    if (!isManaged) flow.freeTempLocal(tempLocal);
    this.currentType = classType.nonNullableType;
    return module.flatten(exprs, classTypeRef);
  }

  private compileNewExpression(
    expression: NewExpression,
    contextualType: Type,
    constraints: Constraints
  ): ExpressionRef {
    var module = this.module;
    var flow = this.currentFlow;

    // obtain the class being instantiated
    var target = this.resolver.resolveTypeName(expression.typeName, flow.actualFunction);
    if (!target) return module.unreachable();
    if (target.kind != ElementKind.CLASS_PROTOTYPE) {
      this.error(
        DiagnosticCode.This_expression_is_not_constructable,
        expression.typeName.range
      );
      return this.module.unreachable();
    }
    if (target.is(CommonFlags.ABSTRACT)) {
      this.error(
        DiagnosticCode.Cannot_create_an_instance_of_an_abstract_class,
        expression.typeName.range
      );
      return this.module.unreachable();
    }
    var classPrototype = <ClassPrototype>target;
    var classInstance: Class | null = null;
    var typeArguments = expression.typeArguments;
    var classReference: Class | null;
    if (
      !typeArguments &&
      (classReference = contextualType.classReference) !== null &&
      classReference.prototype == classPrototype &&
      classReference.is(CommonFlags.GENERIC)
    ) {
      // e.g. `arr: Array<T> = new Array()`
      classInstance = this.resolver.resolveClass(
        classPrototype,
        classReference.typeArguments,
        uniqueMap<string,Type>(flow.contextualTypeArguments)
      );
    } else {
      classInstance = this.resolver.resolveClassInclTypeArguments(
        classPrototype,
        typeArguments,
        flow.actualFunction.parent, // relative to caller
        uniqueMap<string,Type>(flow.contextualTypeArguments),
        expression
      );
    }
    if (!classInstance) return module.unreachable();
    if (contextualType == Type.void) constraints |= Constraints.WILL_DROP;
    var ctor = this.ensureConstructor(classInstance, expression);
    if (!ctor.hasDecorator(DecoratorFlags.INLINE)) {
      // Inlined ctors haven't been compiled yet and are checked upon inline
      // compilation of their body instead.
      this.checkFieldInitialization(classInstance, expression);
    }
    return this.compileInstantiate(ctor, expression.args, constraints, expression);
  }

  /** Gets the compiled constructor of the specified class or generates one if none is present. */
  ensureConstructor(
    /** Class wanting a constructor. */
    classInstance: Class,
    /** Report node. */
    reportNode: Node
  ): Function {
    var instance = classInstance.constructorInstance;
    if (instance) {
      // shortcut if already compiled
      if (instance.is(CommonFlags.COMPILED)) return instance;
      // do not attempt to compile if inlined anyway
      if (!instance.hasDecorator(DecoratorFlags.INLINE)) this.compileFunction(instance);
    } else {
      // clone base constructor if a derived class. note that we cannot just
      // call the base ctor since the derived class may have additional fields.
      let baseClass = classInstance.base;
      let contextualTypeArguments = uniqueMap(classInstance.contextualTypeArguments);
      if (baseClass) {
        let baseCtor = this.ensureConstructor(baseClass, reportNode);
        this.checkFieldInitialization(baseClass, reportNode);
        instance = new Function(
          CommonNames.constructor,
          new FunctionPrototype(
            CommonNames.constructor,
            classInstance,
            // declaration is important, i.e. to access optional parameter initializers
            (<FunctionDeclaration>baseCtor.declaration).clone()
          ),
          null,
          baseCtor.signature,
          contextualTypeArguments
        );

      // otherwise make a default constructor
      } else {
        instance = new Function(
          CommonNames.constructor,
          new FunctionPrototype(
            CommonNames.constructor,
            classInstance, // bound
            this.program.makeNativeFunctionDeclaration(CommonNames.constructor,
              CommonFlags.INSTANCE | CommonFlags.CONSTRUCTOR
            )
          ),
          null,
          new Signature(this.program, null, classInstance.type, classInstance.type),
          contextualTypeArguments
        );
      }

      instance.set(CommonFlags.COMPILED);
      instance.prototype.setResolvedInstance("", instance);
      if (classInstance.is(CommonFlags.MODULE_EXPORT)) {
        instance.set(CommonFlags.MODULE_EXPORT);
      }
      classInstance.constructorInstance = instance;
      let members = classInstance.members;
      if (!members) classInstance.members = members = new Map();
      members.set("constructor", instance.prototype);

      let previousFlow = this.currentFlow;
      let flow = instance.flow;
      this.currentFlow = flow;

      // generate body
      let signature = instance.signature;
      let module = this.module;
      let sizeTypeRef = this.options.sizeTypeRef;
      let stmts = new Array<ExpressionRef>();

      // {
      //   this = <COND_ALLOC>
      //   IF_DERIVED: this = super(this, ...args)
      //   this.a = X
      //   this.b = Y
      //   return this
      // }
      stmts.push(
        this.makeConditionalAllocation(classInstance, 0)
      );
      if (baseClass) {
        let parameterTypes = signature.parameterTypes;
        let numParameters = parameterTypes.length;
        let operands = new Array<ExpressionRef>(1 + numParameters);
        operands[0] = module.local_get(0, sizeTypeRef);
        for (let i = 1; i <= numParameters; ++i) {
          operands[i] = module.local_get(i, parameterTypes[i - 1].toRef());
        }
        stmts.push(
          module.local_set(0,
            this.makeCallDirect(assert(baseClass.constructorInstance), operands, reportNode, false),
            baseClass.type.isManaged
          )
        );
      }
      this.makeFieldInitializationInConstructor(classInstance, stmts);
      stmts.push(
        module.local_get(0, sizeTypeRef)
      );
      flow.freeScopedLocals();
      this.currentFlow = previousFlow;

      // make the function
      let locals = instance.localsByIndex;
      let varTypes = new Array<TypeRef>(); // of temp. vars added while compiling initializers
      let numOperands = 1 + signature.parameterTypes.length;
      let numLocals = locals.length;
      if (numLocals > numOperands) {
        for (let i = numOperands; i < numLocals; ++i) varTypes.push(locals[i].type.toRef());
      }
      let funcRef = module.addFunction(
        instance.internalName,
        signature.paramRefs,
        signature.resultRefs,
        varTypes,
        module.flatten(stmts, sizeTypeRef)
      );
      instance.finalize(module, funcRef);
    }

    return instance;
  }

  /** Checks that all class fields have been initialized. */
  checkFieldInitialization(classInstance: Class, relatedNode: Node | null = null): void {
    if (classInstance.didCheckFieldInitialization) return;
    classInstance.didCheckFieldInitialization = true;
    var ctor = assert(classInstance.constructorInstance);
    this.checkFieldInitializationInFlow(classInstance, ctor.flow, relatedNode);
  }

  /** Checks that all class fields have been initialized in the specified flow. */
  checkFieldInitializationInFlow(classInstance: Class, flow: Flow, relatedNode: Node | null = null): void {
    var members = classInstance.members;
    if (members) {
      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {
        let element = _values[i];
        if (element.kind == ElementKind.FIELD && element.parent == classInstance) {
          let field = <Field>element;
          if (!field.initializerNode && !flow.isThisFieldFlag(field, FieldFlags.INITIALIZED)) {
            if (!field.is(CommonFlags.DEFINITELY_ASSIGNED)) {
              if (relatedNode) {
                this.errorRelated(
                  DiagnosticCode.Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned,
                  field.declaration.name.range,
                  relatedNode.range,
                  field.internalName
                );
              } else {
                this.error(
                  DiagnosticCode.Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned,
                  field.declaration.name.range,
                  field.internalName
                );
              }
            }
          } else if (field.is(CommonFlags.DEFINITELY_ASSIGNED)) {
            if (field.type.isReference) {
              this.warning( // involves a runtime check
                DiagnosticCode.Property_0_is_always_assigned_before_being_used,
                field.identifierNode.range,
                field.internalName
              );
            } else {
              this.pedantic( // is a nop anyway
                DiagnosticCode.Unnecessary_definite_assignment,
                field.identifierNode.range
              );
            }
          }
        }
      }
    }
  }

  compileInstantiate(
    /** Constructor to call. */
    ctorInstance: Function,
    /** Constructor arguments. */
    argumentExpressions: Expression[],
    /** Contextual flags. */
    constraints: Constraints,
    /** Node to report on. */
    reportNode: Node
  ): ExpressionRef {
    assert(ctorInstance.is(CommonFlags.CONSTRUCTOR));
    var parent = ctorInstance.parent;
    assert(parent.kind == ElementKind.CLASS);
    var classInstance = <Class>parent;
    if (classInstance.type.isUnmanaged || ctorInstance.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(reportNode);
    var expr = this.compileCallDirect(
      ctorInstance,
      argumentExpressions,
      reportNode,
      this.makeZero(this.options.usizeType, reportNode),
      constraints
    );
    if (getExpressionType(expr) != TypeRef.None) { // possibly WILL_DROP
      this.currentType = classInstance.type; // important because a super ctor could be called
    }
    return expr;
  }

  private compilePropertyAccessExpression(
    expression: PropertyAccessExpression,
    ctxType: Type,
    constraints: Constraints
  ): ExpressionRef {
    var module = this.module;
    var flow = this.currentFlow;

    this.maybeCompileEnclosingSource(expression);

    var resolver = this.resolver;
    var target = resolver.lookupExpression(expression, flow, ctxType); // reports
    if (!target) return module.unreachable();
    var thisExpression = resolver.currentThisExpression;
    if (target.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);

    switch (target.kind) {
      case ElementKind.GLOBAL: { // static field
        let global = <Global>target;
        if (!this.compileGlobal(global)) return module.unreachable(); // reports
        let globalType = global.type;
        assert(globalType != Type.void);
        if (this.pendingElements.has(global)) {
          this.error(
            DiagnosticCode.Variable_0_used_before_its_declaration,
            expression.range,
            global.internalName
          );
          this.currentType = globalType;
          return module.unreachable();
        }
        if (global.is(CommonFlags.INLINED)) {
          return this.compileInlineConstant(global, ctxType, constraints);
        }
        this.currentType = globalType;
        return module.global_get(global.internalName, globalType.toRef());
      }
      case ElementKind.ENUMVALUE: { // enum value
        let enumValue = <EnumValue>target;
        let parent = assert(enumValue.parent);
        assert(parent.kind == ElementKind.ENUM);
        let parentEnum = <Enum>parent;
        if (!this.compileEnum(parentEnum)) {
          this.currentType = Type.i32;
          return this.module.unreachable();
        }
        this.currentType = Type.i32;
        if (enumValue.is(CommonFlags.INLINED)) {
          assert(enumValue.constantValueKind == ConstantValueKind.INTEGER);
          return this.compileInlineConstant(enumValue, ctxType, constraints);
        }
        assert(enumValue.type == Type.i32);
        return module.global_get(enumValue.internalName, TypeRef.I32);
      }
      case ElementKind.FIELD: {
        let fieldInstance = <Field>target;
        let fieldType = fieldInstance.type;
        assert(fieldInstance.memoryOffset >= 0);
        let fieldParent = fieldInstance.parent;
        assert(fieldParent.kind == ElementKind.CLASS);
        thisExpression = assert(thisExpression);
        let thisExpr = this.compileExpression(
          thisExpression,
          (<Class>fieldParent).type,
          Constraints.CONV_IMPLICIT | Constraints.IS_THIS
        );
        let thisType = this.currentType;
        if (
          flow.actualFunction.is(CommonFlags.CONSTRUCTOR) &&
          thisExpression.kind == NodeKind.THIS &&
          !flow.isThisFieldFlag(fieldInstance, FieldFlags.INITIALIZED) &&
          !fieldInstance.is(CommonFlags.DEFINITELY_ASSIGNED)
        ) {
          this.errorRelated(
            DiagnosticCode.Property_0_is_used_before_being_assigned,
            expression.range,
            fieldInstance.identifierNode.range,
            fieldInstance.internalName
          );
        }
        if (thisType.isNullableReference) {
          if (!flow.isNonnull(thisExpr, thisType)) {
            this.error(
              DiagnosticCode.Object_is_possibly_null,
              thisExpression.range
            );
          }
        }
        if (!fieldInstance.is(CommonFlags.COMPILED)) {
          fieldInstance.set(CommonFlags.COMPILED);
          let typeNode = fieldInstance.typeNode;
          if (typeNode) this.checkTypeSupported(fieldInstance.type, typeNode);
        }
        this.currentType = fieldType;
        let ret = module.load(
          fieldType.byteSize,
          fieldType.isSignedIntegerValue,
          thisExpr,
          fieldType.toRef(),
          fieldInstance.memoryOffset
        );
        if (fieldInstance.is(CommonFlags.DEFINITELY_ASSIGNED) && fieldType.isReference && !fieldType.isNullableReference) {
          ret = this.makeRuntimeNonNullCheck(ret, fieldType, expression);
        }
        return ret;
      }
      case ElementKind.PROPERTY_PROTOTYPE: {
        let propertyPrototype = <PropertyPrototype>target;
        let propertyInstance = this.resolver.resolveProperty(propertyPrototype);
        if (!propertyInstance) return module.unreachable();
        target = propertyInstance;
        // fall-through
      }
      case ElementKind.PROPERTY: {
        let propertyInstance = <Property>target;
        let getterInstance = propertyInstance.getterInstance;
        if (!getterInstance) return module.unreachable(); // failed earlier
        let thisArg: ExpressionRef = 0;
        if (getterInstance.is(CommonFlags.INSTANCE)) {
          thisArg = this.compileExpression(
            assert(thisExpression),
            assert(getterInstance.signature.thisType),
            Constraints.CONV_IMPLICIT | Constraints.IS_THIS
          );
        }
        return this.compileCallDirect(getterInstance, [], expression, thisArg);
      }
      case ElementKind.FUNCTION_PROTOTYPE: {
        let functionPrototype = <FunctionPrototype>target;
        let functionInstance = this.resolver.resolveFunction(functionPrototype, null);
        if (!functionInstance) return module.unreachable();
        if (!this.compileFunction(functionInstance)) return module.unreachable();
        this.currentType = functionInstance.type;
        let offset = this.ensureRuntimeFunction(functionInstance);
        return this.options.isWasm64
          ? module.i64(i64_low(offset), i64_high(offset))
          : module.i32(i64_low(offset));
      }
    }
    this.error(
      DiagnosticCode.Expression_refers_to_a_static_element_that_does_not_compile_to_a_value_at_runtime,
      expression.range
    );
    return this.module.unreachable();
  }

  private compileTernaryExpression(
    expression: TernaryExpression,
    ctxType: Type,
    constraints: Constraints
  ): ExpressionRef {
    var module = this.module;
    var ifThen = expression.ifThen;
    var ifElse = expression.ifElse;

    var condExpr = this.makeIsTrueish(
      this.compileExpression(expression.condition, Type.bool),
      this.currentType,
      expression.condition
    );
    // Try to eliminate unnecesssary branches if the condition is constant
    // FIXME: skips common denominator, inconsistently picking branch type
    var condKind = this.evaluateCondition(condExpr);
    if (condKind == ConditionKind.TRUE) {
      return module.maybeDropCondition(condExpr, this.compileExpression(ifThen, ctxType));
    }
    if (condKind == ConditionKind.FALSE) {
      return module.maybeDropCondition(condExpr, this.compileExpression(ifElse, ctxType));
    }

    var outerFlow = this.currentFlow;
    var ifThenFlow = outerFlow.fork();
    ifThenFlow.inheritNonnullIfTrue(condExpr);
    this.currentFlow = ifThenFlow;
    var ifThenExpr = this.compileExpression(ifThen, ctxType);
    var ifThenType = this.currentType;

    var ifElseFlow = outerFlow.fork();
    ifElseFlow.inheritNonnullIfFalse(condExpr);
    this.currentFlow = ifElseFlow;
    var ifElseExpr = this.compileExpression(ifElse, ctxType == Type.auto ? ifThenType : ctxType);
    var ifElseType = this.currentType;

    var commonType = Type.commonDenominator(ifThenType, ifElseType, false);
    if (!commonType) {
      this.error(
        DiagnosticCode.Type_0_is_not_assignable_to_type_1,
        ifElse.range, ifElseType.toString(), ifThenType.toString()
      );
      this.currentType = ctxType;
      return module.unreachable();
    }
    ifThenExpr = this.convertExpression(ifThenExpr, ifThenType, commonType, false, ifThen);
    ifThenType = commonType;
    ifElseExpr = this.convertExpression(ifElseExpr, ifElseType, commonType, false, ifElse);
    ifElseType = commonType;
    this.currentType = commonType;

    ifThenFlow.freeScopedLocals();
    ifElseFlow.freeScopedLocals();

    this.currentFlow = outerFlow;
    outerFlow.inheritMutual(ifThenFlow, ifElseFlow);

    return module.if(condExpr, ifThenExpr, ifElseExpr);
  }

  private compileUnaryPostfixExpression(
    expression: UnaryPostfixExpression,
    contextualType: Type,
    constraints: Constraints
  ): ExpressionRef {
    var module = this.module;
    var flow = this.currentFlow;

    // make a getter for the expression (also obtains the type)
    var getValue = this.compileExpression( // reports
      expression.operand,
      contextualType.exceptVoid,
      Constraints.NONE
    );

    // shortcut if compiling the getter already failed
    if (getExpressionId(getValue) == ExpressionId.Unreachable) return getValue;

    // if the value isn't dropped, a temp. local is required to remember the original value,
    // except if a static overload is found, which reverses the use of a temp. (see below)
    var tempLocal: Local | null = null;
    if (contextualType != Type.void) {
      tempLocal = flow.getTempLocal(this.currentType);
      getValue = module.local_tee(
        tempLocal.index,
        getValue,
        this.currentType.isManaged
      );
    }

    var expr: ExpressionRef;

    switch (expression.operator) {
      case Token.PLUS_PLUS: {

        // check operator overload
        let classReference = this.currentType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.POSTFIX_INC);
          if (overload) {
            let isInstance = overload.is(CommonFlags.INSTANCE);
            if (tempLocal !== null && !isInstance) { // revert: static overload simply returns
              getValue = getLocalSetValue(getValue);
              flow.freeTempLocal(tempLocal);
              tempLocal = null;
            }
            expr = this.compileUnaryOverload(overload, expression.operand, getValue, expression);
            if (isInstance) break;
            return expr; // here
          }
        }
        if (!this.currentType.isValue) {
          this.error(
            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
            expression.range, "++", this.currentType.toString()
          );
          if (tempLocal) flow.freeTempLocal(tempLocal);
          return module.unreachable();
        }

        switch (this.currentType.kind) {
          case TypeKind.I8:
          case TypeKind.I16:
          case TypeKind.I32:
          case TypeKind.U8:
          case TypeKind.U16:
          case TypeKind.U32:
          case TypeKind.BOOL: {
            expr = module.binary(
              BinaryOp.AddI32,
              getValue,
              module.i32(1)
            );
            break;
          }
          case TypeKind.USIZE:
          case TypeKind.ISIZE: {
            let options = this.options;
            expr = module.binary(
              options.isWasm64
                ? BinaryOp.AddI64
                : BinaryOp.AddI32,
              getValue,
              this.makeOne(this.currentType)
            );
            break;
          }
          case TypeKind.I64:
          case TypeKind.U64: {
            expr = module.binary(
              BinaryOp.AddI64,
              getValue,
              module.i64(1)
            );
            break;
          }
          case TypeKind.F32: {
            expr = module.binary(
              BinaryOp.AddF32,
              getValue,
              module.f32(1)
            );
            break;
          }
          case TypeKind.F64: {
            expr = module.binary(
              BinaryOp.AddF64,
              getValue,
              module.f64(1)
            );
            break;
          }
          default: {
            this.error(
              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
              expression.range, "++", this.currentType.toString()
            );
            return module.unreachable();
          }
        }
        break;
      }
      case Token.MINUS_MINUS: {

        // check operator overload
        let classReference = this.currentType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.POSTFIX_DEC);
          if (overload) {
            let isInstance = overload.is(CommonFlags.INSTANCE);
            if (tempLocal !== null && !isInstance) { // revert: static overload simply returns
              getValue = getLocalSetValue(getValue);
              flow.freeTempLocal(tempLocal);
              tempLocal = null;
            }
            expr = this.compileUnaryOverload(overload, expression.operand, getValue, expression);
            if (overload.is(CommonFlags.INSTANCE)) break;
            return expr; // here
          }
        }
        if (!this.currentType.isValue) {
          this.error(
            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
            expression.range, "--", this.currentType.toString()
          );
          if (tempLocal) flow.freeTempLocal(tempLocal);
          return module.unreachable();
        }

        switch (this.currentType.kind) {
          case TypeKind.I8:
          case TypeKind.I16:
          case TypeKind.I32:
          case TypeKind.U8:
          case TypeKind.U16:
          case TypeKind.U32:
          case TypeKind.BOOL: {
            expr = module.binary(
              BinaryOp.SubI32,
              getValue,
              module.i32(1)
            );
            break;
          }
          case TypeKind.USIZE:
          case TypeKind.ISIZE: {
            let options = this.options;
            expr = module.binary(
              options.isWasm64
                ? BinaryOp.SubI64
                : BinaryOp.SubI32,
              getValue,
              this.makeOne(this.currentType)
            );
            break;
          }
          case TypeKind.I64:
          case TypeKind.U64: {
            expr = module.binary(
              BinaryOp.SubI64,
              getValue,
              module.i64(1)
            );
            break;
          }
          case TypeKind.F32: {
            expr = module.binary(
              BinaryOp.SubF32,
              getValue,
              module.f32(1)
            );
            break;
          }
          case TypeKind.F64: {
            expr = module.binary(
              BinaryOp.SubF64,
              getValue,
              module.f64(1)
            );
            break;
          }
          default: {
            this.error(
              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
              expression.range, "--", this.currentType.toString()
            );
            return module.unreachable();
          }
        }
        break;
      }
      default: {
        assert(false);
        return module.unreachable();
      }
    }

    var resolver = this.resolver;
    var target = resolver.lookupExpression(expression.operand, flow); // reports
    if (!target) {
      if (tempLocal) flow.freeTempLocal(tempLocal);
      return module.unreachable();
    }

    // simplify if dropped anyway
    if (!tempLocal) {
      return this.makeAssignment(
        target,
        expr,
        this.currentType,
        expression.operand,
        resolver.currentThisExpression,
        resolver.currentElementExpression,
        false
      );
    }

    // otherwise use the temp. local for the intermediate value (always possibly overflows)
    var setValue = this.makeAssignment(
      target,
      expr, // includes a tee of getValue to tempLocal
      this.currentType,
      expression.operand,
      resolver.currentThisExpression,
      resolver.currentElementExpression,
      false
    );

    this.currentType = tempLocal.type;
    flow.freeTempLocal(tempLocal);
    var typeRef = tempLocal.type.toRef();

    return module.block(null, [
      setValue,
      module.local_get(tempLocal.index, typeRef)
    ], typeRef); // result of 'x++' / 'x--' might overflow
  }

  private compileUnaryPrefixExpression(
    expression: UnaryPrefixExpression,
    contextualType: Type,
    constraints: Constraints
  ): ExpressionRef {
    var module = this.module;
    var compound = false;
    var expr: ExpressionRef;

    switch (expression.operator) {
      case Token.PLUS: {
        expr = this.compileExpression(
          expression.operand,
          contextualType.exceptVoid,
          Constraints.NONE
        );

        // check operator overload
        let classReference = this.currentType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.PLUS);
          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);
        }
        if (!this.currentType.isValue) {
          this.error(
            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
            expression.range, "+", this.currentType.toString()
          );
          return module.unreachable();
        }

        // nop
        break;
      }
      case Token.MINUS: {
        let operand = expression.operand;
        if (operand.isNumericLiteral) {
          // implicitly negate integer and float literals. also enables proper checking of literal ranges.
          expr = this.compileLiteralExpression(<LiteralExpression>operand, contextualType, Constraints.NONE, true);
          // compileExpression normally does this:
          if (this.options.sourceMap) this.addDebugLocation(expr, expression.range);
          break;
        }

        expr = this.compileExpression(
          expression.operand,
          contextualType.exceptVoid,
          Constraints.NONE
        );

        // check operator overload
        let classReference = this.currentType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.MINUS);
          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);
        }
        if (!this.currentType.isValue) {
          this.error(
            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
            expression.range, "-", this.currentType.toString()
          );
          return module.unreachable();
        }

        switch (this.currentType.kind) {
          case TypeKind.I8:
          case TypeKind.I16:
          case TypeKind.I32:
          case TypeKind.U8:
          case TypeKind.U16:
          case TypeKind.U32:
          case TypeKind.BOOL: {
            expr = module.binary(BinaryOp.SubI32, module.i32(0), expr);
            break;
          }
          case TypeKind.USIZE:
          case TypeKind.ISIZE: {
            expr = module.binary(
              this.options.isWasm64
                ? BinaryOp.SubI64
                : BinaryOp.SubI32,
              this.makeZero(this.currentType, expression.operand),
              expr
            );
            break;
          }
          case TypeKind.I64:
          case TypeKind.U64: {
            expr = module.binary(BinaryOp.SubI64, module.i64(0), expr);
            break;
          }
          case TypeKind.F32: {
            expr = module.unary(UnaryOp.NegF32, expr);
            break;
          }
          case TypeKind.F64: {
            expr = module.unary(UnaryOp.NegF64, expr);
            break;
          }
          default: {
            this.error(
              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
              expression.range, "-", this.currentType.toString()
            );
            expr = module.unreachable();
          }
        }
        break;
      }
      case Token.PLUS_PLUS: {
        compound = true;
        expr = this.compileExpression(
          expression.operand,
          contextualType.exceptVoid,
          Constraints.NONE
        );

        // check operator overload
        let classReference = this.currentType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.PREFIX_INC);
          if (overload) {
            expr = this.compileUnaryOverload(overload, expression.operand, expr, expression);
            if (overload.is(CommonFlags.INSTANCE)) break; // re-assign
            return expr; // skip re-assign
          }
        }
        if (!this.currentType.isValue) {
          this.error(
            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
            expression.range, "++", this.currentType.toString()
          );
          return module.unreachable();
        }

        switch (this.currentType.kind) {
          case TypeKind.I8:
          case TypeKind.I16:
          case TypeKind.I32:
          case TypeKind.U8:
          case TypeKind.U16:
          case TypeKind.U32:
          case TypeKind.BOOL: {
            expr = module.binary(BinaryOp.AddI32, expr, this.module.i32(1));
            break;
          }
          case TypeKind.USIZE:
          case TypeKind.ISIZE: {
            expr = module.binary(
              this.options.isWasm64
                ? BinaryOp.AddI64
                : BinaryOp.AddI32,
              expr,
              this.makeOne(this.currentType)
            );
            break;
          }
          case TypeKind.I64:
          case TypeKind.U64: {
            expr = module.binary(BinaryOp.AddI64, expr, module.i64(1));
            break;
          }
          case TypeKind.F32: {
            expr = module.binary(BinaryOp.AddF32, expr, module.f32(1));
            break;
          }
          case TypeKind.F64: {
            expr = module.binary(BinaryOp.AddF64, expr, module.f64(1));
            break;
          }
          default: {
            this.error(
              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
              expression.range, "++", this.currentType.toString()
            );
            expr = module.unreachable();
          }
        }
        break;
      }
      case Token.MINUS_MINUS: {
        compound = true;
        expr = this.compileExpression(
          expression.operand,
          contextualType.exceptVoid,
          Constraints.NONE
        );

        // check operator overload
        let classReference = this.currentType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.PREFIX_DEC);
          if (overload) {
            expr = this.compileUnaryOverload(overload, expression.operand, expr, expression);
            if (overload.is(CommonFlags.INSTANCE)) break; // re-assign
            return expr; // skip re-assign
          }
        }
        if (!this.currentType.isValue) {
          this.error(
            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
            expression.range, "--", this.currentType.toString()
          );
          return module.unreachable();
        }

        switch (this.currentType.kind) {
          case TypeKind.I8:
          case TypeKind.I16:
          case TypeKind.I32:
          case TypeKind.U8:
          case TypeKind.U16:
          case TypeKind.U32:
          case TypeKind.BOOL: {
            expr = module.binary(BinaryOp.SubI32, expr, module.i32(1));
            break;
          }
          case TypeKind.USIZE:
          case TypeKind.ISIZE: {
            expr = module.binary(
              this.options.isWasm64
                ? BinaryOp.SubI64
                : BinaryOp.SubI32,
              expr,
              this.makeOne(this.currentType)
            );
            break;
          }
          case TypeKind.I64:
          case TypeKind.U64: {
            expr = module.binary(BinaryOp.SubI64, expr, module.i64(1));
            break;
          }
          case TypeKind.F32: {
            expr = module.binary(BinaryOp.SubF32, expr, module.f32(1));
            break;
          }
          case TypeKind.F64: {
            expr = module.binary(BinaryOp.SubF64, expr, module.f64(1));
            break;
          }
          default: {
            this.error(
              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
              expression.range, "--", this.currentType.toString()
            );
            expr = module.unreachable();
          }
        }
        break;
      }
      case Token.EXCLAMATION: {
        expr = this.compileExpression(
          expression.operand,
          contextualType.exceptVoid,
          Constraints.NONE
        );

        // check operator overload
        let classReference = this.currentType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.NOT);
          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);
          // fall back to compare by value
        }

        expr = module.unary(UnaryOp.EqzI32, this.makeIsTrueish(expr, this.currentType, expression.operand));
        this.currentType = Type.bool;
        break;
      }
      case Token.TILDE: {
        expr = this.compileExpression(
          expression.operand,
          contextualType == Type.void
            ? Type.i32
            : contextualType.isFloatValue
              ? Type.i64
              : contextualType,
          Constraints.NONE
        );

        // check operator overload
        let classReference = this.currentType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.BITWISE_NOT);
          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);
        }
        if (!this.currentType.isValue) {
          this.error(
            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
            expression.range, "~", this.currentType.toString()
          );
          return module.unreachable();
        }

        expr = this.convertExpression(expr, this.currentType, this.currentType.intType, false, expression.operand);

        switch (this.currentType.kind) {
          case TypeKind.I8:
          case TypeKind.I16:
          case TypeKind.I32:
          case TypeKind.U8:
          case TypeKind.U16:
          case TypeKind.U32:
          case TypeKind.BOOL: {
            expr = module.binary(BinaryOp.XorI32, expr, module.i32(-1));
            break;
          }
          case TypeKind.USIZE:
          case TypeKind.ISIZE: {
            expr = module.binary(
              this.options.isWasm64
                ? BinaryOp.XorI64
                : BinaryOp.XorI32,
              expr,
              this.makeNegOne(this.currentType)
            );
            break;
          }
          case TypeKind.I64:
          case TypeKind.U64: {
            expr = module.binary(BinaryOp.XorI64, expr, module.i64(-1, -1));
            break;
          }
          default: {
            this.error(
              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
              expression.range, "~", this.currentType.toString()
            );
            expr = module.unreachable();
          }
        }
        break;
      }
      case Token.TYPEOF: {
        return this.compileTypeof(expression, contextualType, constraints);
      }
      case Token.DOT_DOT_DOT: {
        this.error(
          DiagnosticCode.Not_implemented_0,
          expression.range, "Spread operator"
        );
        return module.unreachable();
      }
      default: {
        assert(false);
        return module.unreachable();
      }
    }
    if (!compound) return expr;
    var resolver = this.resolver;
    var target = resolver.lookupExpression(expression.operand, this.currentFlow);
    if (!target) return module.unreachable();
    return this.makeAssignment(
      target,
      expr,
      this.currentType,
      expression.operand,
      resolver.currentThisExpression,
      resolver.currentElementExpression,
      contextualType != Type.void
    );
  }

  private compileTypeof(
    expression: UnaryPrefixExpression,
    contextualType: Type,
    constraints: Constraints
  ): ExpressionRef {
    var operand = expression.operand;
    var expr: ExpressionRef = 0;
    var stringInstance = this.program.stringInstance;
    var typeString: string;
    if (operand.kind == NodeKind.NULL) {
      typeString = "object"; // special since `null` without type context is usize
    } else {
      let element = this.resolver.lookupExpression(operand, this.currentFlow, Type.auto, ReportMode.SWALLOW);
      if (!element) {
        switch (operand.kind) {
          case NodeKind.IDENTIFIER: break; // ignore error: typeof doesntExist -> undefined
          case NodeKind.PROPERTYACCESS:
          case NodeKind.ELEMENTACCESS: {
            operand = operand.kind == NodeKind.PROPERTYACCESS
              ? (<PropertyAccessExpression>operand).expression
              : (<ElementAccessExpression>operand).expression;
            let targetType = this.resolver.resolveExpression(operand, this.currentFlow, Type.auto, ReportMode.REPORT);
            if (!targetType) { // access on non-object
              this.currentType = stringInstance.type;
              return this.module.unreachable();
            }
            // fall-through
          }
          default: {
            expr = this.compileExpression(operand, Type.auto); // may trigger an error
            expr = this.convertExpression(expr, this.currentType, Type.void, true, operand);
          }
        }
        typeString = "undefined";
      } else {
        switch (element.kind) {
          case ElementKind.CLASS_PROTOTYPE:
          case ElementKind.NAMESPACE:
          case ElementKind.ENUM: {
            typeString = "object";
            break;
          }
          case ElementKind.FUNCTION_PROTOTYPE: {
            typeString = "function";
            break;
          }
          default: {
            expr = this.compileExpression(operand, Type.auto);
            let type = this.currentType;
            expr = this.convertExpression(expr, type, Type.void, true, operand);
            if (type.isReference) {
              let signatureReference = type.getSignature();
              if (signatureReference) {
                typeString = "function";
              } else {
                let classReference = type.getClass();
                if (classReference) {
                  if (classReference.prototype === stringInstance.prototype) {
                    typeString = "string";
                  } else {
                    typeString = "object";
                  }
                } else {
                  typeString = "externref"; // TODO?
                }
              }
            } else if (type == Type.bool) {
              typeString = "boolean";
            } else if (type.isNumericValue) {
              typeString = "number";
            } else {
              typeString = "undefined"; // failed to compile?
            }
            break;
          }
        }
      }
    }
    this.currentType = stringInstance.type;
    return expr
      ? this.module.block(null, [ expr, this.ensureStaticString(typeString) ], this.options.sizeTypeRef)
      : this.ensureStaticString(typeString);
  }

  /** Makes sure that a 32-bit integer value is wrapped to a valid value of the specified type. */
  ensureSmallIntegerWrap(expr: ExpressionRef, type: Type): ExpressionRef {
    var module = this.module;
    var flow = this.currentFlow;
    switch (type.kind) {
      case TypeKind.I8: {
        if (flow.canOverflow(expr, type)) {
          expr = this.options.hasFeature(Feature.SIGN_EXTENSION)
            ? module.unary(UnaryOp.Extend8I32, expr)
            : module.binary(BinaryOp.ShrI32,
                module.binary(BinaryOp.ShlI32,
                  expr,
                  module.i32(24)
                ),
                module.i32(24)
              );
        }
        break;
      }
      case TypeKind.I16: {
        if (flow.canOverflow(expr, type)) {
          expr = this.options.hasFeature(Feature.SIGN_EXTENSION)
            ? module.unary(UnaryOp.Extend16I32, expr)
            : module.binary(BinaryOp.ShrI32,
                module.binary(BinaryOp.ShlI32,
                  expr,
                  module.i32(16)
                ),
                module.i32(16)
              );
        }
        break;
      }
      case TypeKind.U8: {
        if (flow.canOverflow(expr, type)) {
          expr = module.binary(BinaryOp.AndI32,
            expr,
            module.i32(0xff)
          );
        }
        break;
      }
      case TypeKind.U16: {
        if (flow.canOverflow(expr, type)) {
          expr = module.binary(BinaryOp.AndI32,
            expr,
            module.i32(0xffff)
          );
        }
        break;
      }
      case TypeKind.BOOL: {
        if (flow.canOverflow(expr, type)) {
          // bool is special in that it compares to 0 instead of masking with 0x1
          expr = module.binary(BinaryOp.NeI32,
            expr,
            module.i32(0)
          );
        }
        break;
      }
    }
    return expr;
  }

  /** Adds the debug location of the specified expression at the specified range to the source map. */
  addDebugLocation(expr: ExpressionRef, range: Range): void {
    var parentFunction = this.currentFlow.parentFunction;
    var source = range.source;
    if (source.debugInfoIndex < 0) source.debugInfoIndex = this.module.addDebugInfoFile(source.normalizedPath);
    range.debugInfoRef = expr;
    parentFunction.debugLocations.push(range);
  }

  /** Checks whether a particular feature is enabled. */
  checkFeatureEnabled(feature: Feature, reportNode: Node): bool {
    if (!this.options.hasFeature(feature)) {
      this.error(
        DiagnosticCode.Feature_0_is_not_enabled,
        reportNode.range, featureToString(feature)
      );
      return false;
    }
    return true;
  }

  /** Checks whether a particular type is supported. */
  checkTypeSupported(type: Type, reportNode: Node): bool {
    switch (type.kind) {
      case TypeKind.V128: return this.checkFeatureEnabled(Feature.SIMD, reportNode);
      case TypeKind.FUNCREF:
      case TypeKind.EXTERNREF:
        return this.checkFeatureEnabled(Feature.REFERENCE_TYPES, reportNode);
      case TypeKind.ANYREF:
      case TypeKind.EQREF:
      case TypeKind.I31REF:
      case TypeKind.DATAREF: {
        return this.checkFeatureEnabled(Feature.REFERENCE_TYPES, reportNode)
            && this.checkFeatureEnabled(Feature.GC, reportNode);
      }
    }
    let classReference = type.getClass();
    if (classReference) {
      do {
        let typeArguments = classReference.typeArguments;
        if (typeArguments) {
          for (let i = 0, k = typeArguments.length; i < k; ++i) {
            if (!this.checkTypeSupported(typeArguments[i], reportNode)) {
              return false;
            }
          }
        }
        classReference = classReference.base;
      } while(classReference);
    } else {
      let signatureReference = type.getSignature();
      if (signatureReference) {
        let thisType = signatureReference.thisType;
        if (thisType) {
          if (!this.checkTypeSupported(thisType, reportNode)) {
            return false;
          }
        }
        let parameterTypes = signatureReference.parameterTypes;
        for (let i = 0, k = parameterTypes.length; i < k; ++i) {
          if (!this.checkTypeSupported(parameterTypes[i], reportNode)) {
            return false;
          }
        }
        let returnType = signatureReference.returnType;
        if (!this.checkTypeSupported(returnType, reportNode)) {
          return false;
        }
      }
    }
    return true;
  }

  /** Checks whether a particular function signature is supported. */
  checkSignatureSupported(signature: Signature, reportNode: FunctionTypeNode): bool {
    var supported = true;
    var explicitThisType = reportNode.explicitThisType;
    if (explicitThisType) {
      if (!this.checkTypeSupported(assert(signature.thisType), explicitThisType)) {
        supported = false;
      }
    }
    var parameterTypes = signature.parameterTypes;
    var parameterNodes = reportNode.parameters;
    for (let i = 0, k = parameterTypes.length; i < k; ++i) {
      let parameterReportNode: Node;
      if (parameterNodes.length > i) parameterReportNode = parameterNodes[i];
      else parameterReportNode = reportNode;
      if (!this.checkTypeSupported(parameterTypes[i], parameterReportNode)) {
        supported = false;
      }
    }
    if (!this.checkTypeSupported(signature.returnType, reportNode.returnType)) {
      supported = false;
    }
    return supported;
  }

  /** Evaluates a boolean condition, determining whether it is TRUE, FALSE or UNKNOWN. */
  evaluateCondition(expr: ExpressionRef): ConditionKind {
    let type = getExpressionType(expr);
    if (type == TypeRef.Unreachable)
      return ConditionKind.UNKNOWN;

    assert(type == TypeRef.I32);
    var module = this.module;
    var evaled = module.runExpression(expr, ExpressionRunnerFlags.Default);
    if (evaled) {
      return getConstValueI32(evaled)
        ? ConditionKind.TRUE
        : ConditionKind.FALSE;
    }
    return ConditionKind.UNKNOWN;
  }

  // === Specialized code generation ==============================================================

  /** Makes a constant zero of the specified type. */
  makeZero(type: Type, reportNode: Node): ExpressionRef {
    var module = this.module;
    switch (type.kind) {
      default: assert(false);
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.I32:
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.U32:
      case TypeKind.BOOL: return module.i32(0);
      case TypeKind.ISIZE:
      case TypeKind.USIZE: if (type.size != 64) return module.i32(0);
      case TypeKind.I64:
      case TypeKind.U64: return module.i64(0);
      case TypeKind.F32: return module.f32(0);
      case TypeKind.F64: return module.f64(0);
      case TypeKind.V128: return module.v128(v128_zero);
      case TypeKind.FUNCREF:
      case TypeKind.EXTERNREF:
      case TypeKind.ANYREF:
      case TypeKind.EQREF:
      case TypeKind.DATAREF: return module.ref_null(type.toRef());
      case TypeKind.I31REF: return module.i31_new(module.i32(0));
    }
  }

  /** Makes a constant one of the specified type. */
  makeOne(type: Type): ExpressionRef {
    var module = this.module;
    switch (type.kind) {
      default: assert(false);
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.I32:
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.U32:
      case TypeKind.BOOL: return module.i32(1);
      case TypeKind.ISIZE:
      case TypeKind.USIZE: if (type.size != 64) return module.i32(1);
      case TypeKind.I64:
      case TypeKind.U64: return module.i64(1);
      case TypeKind.F32: return module.f32(1);
      case TypeKind.F64: return module.f64(1);
      case TypeKind.I31REF: return module.i31_new(module.i32(1));
    }
  }

  /** Makes a constant negative one of the specified type. */
  makeNegOne(type: Type): ExpressionRef {
    var module = this.module;
    switch (type.kind) {
      default: assert(false);
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.I32:
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.U32: return module.i32(-1);
      case TypeKind.ISIZE:
      case TypeKind.USIZE: if (type.size != 64) return module.i32(-1);
      case TypeKind.I64:
      case TypeKind.U64: return module.i64(-1, -1);
      case TypeKind.F32: return module.f32(-1);
      case TypeKind.F64: return module.f64(-1);
    }
  }

  /** Creates a comparison whether an expression is 'true' in a broader sense. */
  makeIsTrueish(expr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {
    var module = this.module;
    switch (type.kind) {
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.U8:
      case TypeKind.U16: {
        expr = this.ensureSmallIntegerWrap(expr, type);
        // fall-through
      }
      case TypeKind.BOOL: // not a mask, just != 0
      case TypeKind.I32:
      case TypeKind.U32: {
        return expr;
      }
      case TypeKind.I64:
      case TypeKind.U64: {
        return module.binary(BinaryOp.NeI64, expr, module.i64(0));
      }
      case TypeKind.USIZE:
      case TypeKind.ISIZE: {
        return type.size == 64
          ? module.binary(BinaryOp.NeI64, expr, module.i64(0))
          : expr;
      }
      case TypeKind.F32: {
        // 0 < abs(bitCast(x)) <= bitCast(Infinity) or
        // (reinterpret<u32>(x) & 0x7FFFFFFF) - 1 <= 0x7F800000 - 1
        //
        // and finally:
        // (reinterpret<u32>(x) << 1) - (1 << 1) <= ((0x7F800000 - 1) << 1)
        return module.binary(BinaryOp.LeU32,
          module.binary(BinaryOp.SubI32,
            module.binary(BinaryOp.ShlI32,
              module.unary(UnaryOp.ReinterpretF32ToI32, expr),
              module.i32(1)
            ),
            module.i32(2) // 1 << 1
          ),
          module.i32(0xFEFFFFFE) // (0x7F800000 - 1) << 1
        );
      }
      case TypeKind.F64: {
        // 0 < abs(bitCast(x)) <= bitCast(Infinity) or
        // (reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF) - 1 <= 0x7FF0000000000000 - 1
        //
        // and finally:
        // (reinterpret<u64>(x) << 1) - (1 << 1) <= ((0x7FF0000000000000 - 1) << 1)
        return module.binary(BinaryOp.LeU64,
          module.binary(BinaryOp.SubI64,
            module.binary(BinaryOp.ShlI64,
              module.unary(UnaryOp.ReinterpretF64ToI64, expr),
              module.i64(1)
            ),
            module.i64(2) // 1 << 1
          ),
          module.i64(0xFFFFFFFE, 0xFFDFFFFF) // (0x7FF0000000000000 - 1) << 1
        );
      }
      case TypeKind.FUNCREF:
      case TypeKind.EXTERNREF:
      case TypeKind.ANYREF:
      case TypeKind.EQREF:
      case TypeKind.DATAREF:
      case TypeKind.I31REF: {
        // Needs to be true (i.e. not zero) when the ref is _not_ null,
        // which means `ref.is_null` returns false (i.e. zero).
        return module.unary(UnaryOp.EqzI32, module.ref_is(RefIsOp.RefIsNull, expr));

      }
      default: {
        assert(false);
        return module.i32(0);
      }
    }
  }

  /** Makes a string conversion of the given expression. */
  makeToString(expr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {
    var stringType = this.program.stringInstance.type;
    if (type == stringType) {
      return expr;
    }
    var classType = type.getClassOrWrapper(this.program);
    if (classType) {
      let toStringInstance = classType.getMethod("toString");
      if (toStringInstance) {
        let toStringSignature = toStringInstance.signature;
        if (!this.checkCallSignature( // reports
          toStringSignature,
          0,
          true,
          reportNode
        )) {
          this.currentType = stringType;
          return this.module.unreachable();
        }
        if (!type.isStrictlyAssignableTo(assert(toStringSignature.thisType))) {
          this.errorRelated(
            DiagnosticCode.The_this_types_of_each_signature_are_incompatible,
            reportNode.range, toStringInstance.identifierAndSignatureRange
          );
          this.currentType = stringType;
          return this.module.unreachable();
        }
        let toStringReturnType = toStringSignature.returnType;
        if (!toStringReturnType.isStrictlyAssignableTo(stringType)) {
          this.errorRelated(
            DiagnosticCode.Type_0_is_not_assignable_to_type_1,
            reportNode.range, toStringInstance.identifierAndSignatureRange, toStringReturnType.toString(), stringType.toString()
          );
          this.currentType = stringType;
          return this.module.unreachable();
        }
        return this.makeCallDirect(toStringInstance, [ expr ], reportNode);
      }
    }
    this.error(
      DiagnosticCode.Type_0_is_not_assignable_to_type_1,
      reportNode.range, type.toString(), stringType.toString()
    );
    this.currentType = stringType;
    return this.module.unreachable();
  }

  /** Makes an allocation suitable to hold the data of an instance of the given class. */
  makeAllocation(
    classInstance: Class
  ): ExpressionRef {
    var program = this.program;
    assert(classInstance.program == program);
    var module = this.module;
    var options = this.options;
    this.currentType = classInstance.type;
    if (classInstance.hasDecorator(DecoratorFlags.UNMANAGED)) {
      let allocInstance = program.allocInstance;
      this.compileFunction(allocInstance);
      return module.call(allocInstance.internalName, [
        options.isWasm64
          ? module.i64(classInstance.nextMemoryOffset)
          : module.i32(classInstance.nextMemoryOffset)
      ], options.sizeTypeRef);
    } else {
      let newInstance = program.newInstance;
      this.compileFunction(newInstance);
      return module.call(newInstance.internalName, [
        options.isWasm64
          ? module.i64(classInstance.nextMemoryOffset)
          : module.i32(classInstance.nextMemoryOffset),
        module.i32(classInstance.id)
      ], options.sizeTypeRef);
    }
  }

  /** Makes a conditional allocation where `this` might not have been initialized yet. */
  makeConditionalAllocation(
    classInstance: Class,
    thisIndex: i32
  ): ExpressionRef {
    var module = this.module;
    var classType = classInstance.type;
    var classTypeRef = classType.toRef();
    assert(classTypeRef == this.options.sizeTypeRef);
    return module.if(
      module.unary(classTypeRef == TypeRef.I64 ? UnaryOp.EqzI64 : UnaryOp.EqzI32,
        module.local_get(thisIndex, classTypeRef)
      ),
      module.local_set(thisIndex,
        this.makeAllocation(classInstance),
        classInstance.type.isManaged
      )
    );
  }

  /** Makes the initializers for a class's fields within the constructor. */
  makeFieldInitializationInConstructor(
    /** Class being initialized. */
    classInstance: Class,
    /** Statements to append to also being returned. Created if omitted. */
    stmts: ExpressionRef[] = []
  ): ExpressionRef[] {
    var members = classInstance.members;
    if (!members) return stmts;

    var module = this.module;
    var flow = this.currentFlow;
    var isInline = flow.isInline;
    var thisLocalIndex = isInline ? flow.lookupLocal(CommonNames.this_)!.index : 0;
    var sizeTypeRef = this.options.sizeTypeRef;
    var nonParameterFields: Field[] | null = null;

    // TODO: for (let member of members.values()) {
    for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {
      let member = unchecked(_values[i]);
      if (
        member.kind != ElementKind.FIELD || // not a field
        member.parent != classInstance      // inherited field
      ) continue;
      let field = <Field>member;
      assert(!field.isAny(CommonFlags.CONST));
      let fieldPrototype = field.prototype;
      let parameterIndex = fieldPrototype.parameterIndex;

      // Defer non-parameter fields until parameter fields are initialized
      if (parameterIndex < 0) {
        if (!nonParameterFields) nonParameterFields = new Array();
        nonParameterFields.push(field);
        continue;
      }

      // Initialize constructor parameter field
      let fieldType = field.type;
      let fieldTypeRef = fieldType.toRef();
      assert(!fieldPrototype.initializerNode);
      this.compileFieldSetter(field);
      stmts.push(
        module.call(field.internalSetterName, [
          module.local_get(thisLocalIndex, sizeTypeRef),
          module.local_get(
            isInline
              ? flow.lookupLocal(field.name)!.index
              : 1 + parameterIndex, // `this` is local 0
            fieldTypeRef
          )
        ], TypeRef.None)
      );
    }

    // Initialize deferred non-parameter fields
    if (nonParameterFields) {
      for (let i = 0, k = nonParameterFields.length; i < k; ++i) {
        let field = unchecked(nonParameterFields[i]);
        let fieldType = field.type;
        let fieldPrototype = field.prototype;
        let initializerNode = fieldPrototype.initializerNode;
        assert(fieldPrototype.parameterIndex < 0);
        this.compileFieldSetter(field);
        stmts.push(
          module.call(field.internalSetterName, [
            module.local_get(thisLocalIndex, sizeTypeRef),
            initializerNode // use initializer if present, otherwise initialize with zero
              ? this.compileExpression(initializerNode, fieldType, Constraints.CONV_IMPLICIT)
              : this.makeZero(fieldType, fieldPrototype.declaration)
          ], TypeRef.None)
        );
      }
    }

    this.currentType = Type.void;
    return stmts;
  }

  /** Makes a call to `abort`, if present, otherwise creates a trap. */
  makeAbort(
    /** Message argument of type string, if any. */
    message: Expression | null,
    /** Code location to report when aborting. */
    codeLocation: Node
  ): ExpressionRef {
    var program = this.program;
    var abortInstance = program.abortInstance;
    if (!abortInstance || !this.compileFunction(abortInstance)) return this.module.unreachable();

    var stringInstance = program.stringInstance;
    var messageArg: ExpressionRef;
    if (message !== null) {
      messageArg = this.compileExpression(message, stringInstance.type, Constraints.CONV_IMPLICIT);
    } else {
      messageArg = this.makeZero(stringInstance.type, codeLocation);
    }

    return this.makeStaticAbort(messageArg, codeLocation);
  }

  /** Makes a call to `abort`, if present, otherwise creates a trap. */
  makeStaticAbort(
    /** Message argument of type string. May be zero. */
    messageExpr: ExpressionRef,
    /** Code location to report when aborting. */
    codeLocation: Node
  ): ExpressionRef {
    var program = this.program;
    var module = this.module;
    var abortInstance = program.abortInstance;
    if (!abortInstance || !this.compileFunction(abortInstance)) return module.unreachable();

    var filenameExpr = this.ensureStaticString(codeLocation.range.source.normalizedPath);
    var range = codeLocation.range;
    var source = range.source;
    return module.block(null, [
      module.call(
        abortInstance.internalName, [
          messageExpr,
          filenameExpr,
          module.i32(source.lineAt(range.start)),
          module.i32(source.columnAt())
        ],
        TypeRef.None
      ),
      module.unreachable()
    ]);
  }

  /** Makes a runtime non-null check, e.g. on `<Type>possiblyNull` or `possiblyNull!`. */
  makeRuntimeNonNullCheck(
    /** Expression being checked. */
    expr: ExpressionRef,
    /** Type of the expression. */
    type: Type,
    /** Report node. */
    reportNode: Node
  ): ExpressionRef {
    var module = this.module;
    var flow = this.currentFlow;
    var temp = flow.getTempLocal(type);
    if (!flow.canOverflow(expr, type)) flow.setLocalFlag(temp.index, LocalFlags.WRAPPED);
    flow.setLocalFlag(temp.index, LocalFlags.NONNULL);
    expr = module.if(
      module.local_tee(temp.index, expr, type.isManaged),
      module.local_get(temp.index, type.toRef()),
      this.makeStaticAbort(this.ensureStaticString("unexpected null"), reportNode) // TODO: throw
    );
    flow.freeTempLocal(temp);
    this.currentType = type.nonNullableType;
    return expr;
  }

  /** Makes a runtime upcast check, e.g. on `<Child>parent`. */
  makeRuntimeUpcastCheck(
    /** Expression being upcast. */
    expr: ExpressionRef,
    /** Type of the expression. */
    type: Type,
    /** Type casting to. */
    toType: Type,
    /** Report node. */
    reportNode: Node
  ): ExpressionRef {
    assert(toType.isReference && toType.nonNullableType.isAssignableTo(type));
    var module = this.module;
    var flow = this.currentFlow;
    var temp = flow.getTempLocal(type);
    var instanceofInstance = this.program.instanceofInstance;
    assert(this.compileFunction(instanceofInstance));
    expr = module.if(
      module.call(instanceofInstance.internalName, [
        module.local_tee(temp.index, expr, type.isManaged),
        module.i32(toType.classReference!.id)
      ], TypeRef.I32),
      module.local_get(temp.index, type.toRef()),
      this.makeStaticAbort(this.ensureStaticString("unexpected upcast"), reportNode) // TODO: throw
    );
    flow.freeTempLocal(temp);
    this.currentType = toType;
    return expr;
  }
}

// helpers

function mangleImportName(
  element: Element,
  declaration: DeclarationStatement
): void {
  // by default, use the file name as the module name
  mangleImportName_moduleName = declaration.range.source.simplePath;
  // and the internal name of the element within that file as the element name
  mangleImportName_elementName = mangleInternalName(
    element.name, element.parent, element.is(CommonFlags.INSTANCE), true
  );
  if (!element.hasDecorator(DecoratorFlags.EXTERNAL)) return;

  var program = element.program;
  var decorator = assert(findDecorator(DecoratorKind.EXTERNAL, declaration.decorators));
  var args = decorator.args;
  if (args !== null && args.length > 0) {
    let arg = args[0];
    // if one argument is given, override just the element name
    // if two arguments are given, override both module and element name
    if (arg.isLiteralKind(LiteralKind.STRING)) {
      mangleImportName_elementName = (<StringLiteralExpression>arg).value;
      if (args.length >= 2) {
        arg = args[1];
        if (arg.isLiteralKind(LiteralKind.STRING)) {
          mangleImportName_moduleName = mangleImportName_elementName;
          mangleImportName_elementName = (<StringLiteralExpression>arg).value;
          if (args.length > 2) {
            program.error(
              DiagnosticCode.Expected_0_arguments_but_got_1,
              decorator.range, "2", args.length.toString()
            );
          }
        } else {
          program.error(
            DiagnosticCode.String_literal_expected,
            arg.range
          );
        }
      }
    } else {
      program.error(
        DiagnosticCode.String_literal_expected,
        arg.range
      );
    }
  } else {
    program.error(
      DiagnosticCode.Expected_at_least_0_arguments_but_got_1,
      decorator.range, "1", "0"
    );
  }
}

var mangleImportName_moduleName: string;
var mangleImportName_elementName: string;

'''
'''--- src/definitions.ts ---
/**
 * @fileoverview Builders for various definitions describing a module.
 *
 * - TSDBuilder: Creates a TypeScript definition file (.d.ts)
 * - IDLBuilder: Creates a WebIDL interface definition (.webidl)
 *
 * @license Apache-2.0
 */

import {
  CommonFlags
} from "./common";

import {
  Program,
  Element,
  ElementKind,
  Global,
  Enum,
  EnumValue,
  Field,
  Function,
  FunctionPrototype,
  Class,
  ClassPrototype,
  Namespace,
  ConstantValueKind,
  Interface,
  Property,
  PropertyPrototype,
  File
} from "./program";

import {
  Type,
  TypeKind
} from "./types";

import {
  SourceKind
} from "./ast";

import {
  indent
} from "./util";

/** Walker base class. */
export abstract class ExportsWalker {

  /** Program reference. */
  program: Program;
  /** Whether to include private members */
  includePrivate: bool;
  /** Already seen elements. */
  seen: Map<Element,string> = new Map();

  /** Constructs a new Element walker. */
  constructor(program: Program, includePrivate: bool = false) {
    this.program = program;
    this.includePrivate = includePrivate;
  }

  /** Walks all elements and calls the respective handlers. */
  walk(): void {
    // TODO: for (let file of this.program.filesByName.values()) {
    for (let _values = Map_values(this.program.filesByName), i = 0, k = _values.length; i < k; ++i) {
      let file = unchecked(_values[i]);
      if (file.source.sourceKind == SourceKind.USER_ENTRY) this.visitFile(file);
    }
  }

  /** Visits all exported elements of a file. */
  visitFile(file: File): void {
    var exports = file.exports;
    if (exports) {
      // TODO: for (let [memberName, member] of exports) {
      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {
        let memberName = unchecked(_keys[i]);
        let member = assert(exports.get(memberName));
        this.visitElement(memberName, member);
      }
    }
    var exportsStar = file.exportsStar;
    if (exportsStar) {
      for (let i = 0, k = exportsStar.length; i < k; ++i) {
        let exportStar = unchecked(exportsStar[i]);
        this.visitFile(exportStar);
      }
    }
  }

  /** Visits an element.*/
  visitElement(name: string, element: Element): void {
    if (element.is(CommonFlags.PRIVATE) && !this.includePrivate) return;
    var seen = this.seen;
    if (!element.is(CommonFlags.INSTANCE) && seen.has(element)) {
      this.visitAlias(name, element, assert(seen.get(element)));
      return;
    }
    seen.set(element, name);
    switch (element.kind) {
      case ElementKind.GLOBAL: {
        if (element.is(CommonFlags.COMPILED)) this.visitGlobal(name, <Global>element);
        break;
      }
      case ElementKind.ENUM: {
        if (element.is(CommonFlags.COMPILED)) this.visitEnum(name, <Enum>element);
        break;
      }
      case ElementKind.ENUMVALUE: break; // handled by visitEnum
      case ElementKind.FUNCTION_PROTOTYPE: {
        this.visitFunctionInstances(name, <FunctionPrototype>element);
        break;
      }
      case ElementKind.CLASS_PROTOTYPE: {
        this.visitClassInstances(name, <ClassPrototype>element);
        break;
      }
      case ElementKind.FIELD: {
        let fieldInstance = <Field>element;
        if (fieldInstance.is(CommonFlags.COMPILED)) this.visitField(name, fieldInstance);
        break;
      }
      case ElementKind.PROPERTY_PROTOTYPE: {
        let propertyInstance = (<PropertyPrototype>element).instance;
        if (!propertyInstance) break;
        element = propertyInstance;
        // fall-through
      }
      case ElementKind.PROPERTY: {
        let propertyInstance = <Property>element;
        let getterInstance = propertyInstance.getterInstance;
        if (getterInstance) this.visitFunction(name, getterInstance);
        let setterInstance = propertyInstance.setterInstance;
        if (setterInstance) this.visitFunction(name, setterInstance);
        break;
      }
      case ElementKind.NAMESPACE: {
        if (hasCompiledMember(element)) this.visitNamespace(name, element);
        break;
      }
      case ElementKind.TYPEDEFINITION: break;
      default: assert(false);
    }
  }

  private visitFunctionInstances(name: string, element: FunctionPrototype): void {
    var instances = element.instances;
    if (instances) {
      // TODO: for (let instance of instances.values()) {
      for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {
        let instance = unchecked(_values[i]);
        if (instance.is(CommonFlags.COMPILED)) this.visitFunction(name, instance);
      }
    }
  }

  private visitClassInstances(name: string, element: ClassPrototype): void {
    var instances = element.instances;
    if (instances) {
      // TODO: for (let instance of instances.values()) {
      for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {
        let instance = unchecked(_values[i]);
        if (instance.is(CommonFlags.COMPILED)) this.visitClass(name, instance);
      }
    }
  }

  abstract visitGlobal(name: string, element: Global): void;
  abstract visitEnum(name: string, element: Enum): void;
  abstract visitFunction(name: string, element: Function): void;
  abstract visitClass(name: string, element: Class): void;
  abstract visitInterface(name: string, element: Interface): void;
  abstract visitField(name: string, element: Field): void;
  abstract visitNamespace(name: string, element: Element): void;
  abstract visitAlias(name: string, element: Element, originalName: string): void;
}

/** A WebIDL definitions builder. */
export class IDLBuilder extends ExportsWalker {

  /** Builds WebIDL definitions for the specified program. */
  static build(program: Program): string {
    return new IDLBuilder(program).build();
  }

  private sb: string[] = [];
  private indentLevel: i32 = 0;

  /** Constructs a new WebIDL builder. */
  constructor(program: Program, includePrivate: bool = false) {
    super(program, includePrivate);
  }

  visitGlobal(name: string, element: Global): void {
    var sb = this.sb;
    var isConst = element.is(CommonFlags.INLINED);
    indent(sb, this.indentLevel);
    if (isConst) sb.push("const ");
    sb.push(this.typeToString(element.type));
    sb.push(" ");
    sb.push(name);
    if (isConst) {
      switch (element.constantValueKind) {
        case ConstantValueKind.INTEGER: {
          sb.push(" = ");
          sb.push(i64_to_string(element.constantIntegerValue));
          break;
        }
        case ConstantValueKind.FLOAT: {
          sb.push(" = ");
          sb.push(element.constantFloatValue.toString());
          break;
        }
        default: assert(false);
      }
    }
    sb.push(";\n");
  }

  visitEnum(name: string, element: Enum): void {
    var sb = this.sb;
    indent(sb, this.indentLevel++);
    sb.push("interface ");
    sb.push(name);
    sb.push(" {\n");
    var members = element.members;
    if (members) {
      // TODO: for (let [memberName, member] of members) {
      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {
        let memberName = unchecked(_keys[i]);
        let member = assert(members.get(memberName));
        if (member.kind == ElementKind.ENUMVALUE) {
          let enumValue = <EnumValue>member;
          let isConst = enumValue.is(CommonFlags.INLINED);
          indent(sb, this.indentLevel);
          if (isConst) sb.push("const ");
          else sb.push("readonly ");
          sb.push("unsigned long ");
          sb.push(memberName);
          if (isConst) {
            sb.push(" = ");
            assert(enumValue.constantValueKind == ConstantValueKind.INTEGER);
            sb.push(i64_low(enumValue.constantIntegerValue).toString());
          }
          sb.push(";\n");
        }
      }
      // TODO: for (let member of members.values()) {
      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {
        let member = unchecked(_values[i]);
        if (member.kind != ElementKind.ENUMVALUE) this.visitElement(member.name, member);
      }
    }
    indent(sb, --this.indentLevel);
    sb.push("}\n");
  }

  visitFunction(name: string, element: Function): void {
    var sb = this.sb;
    var signature = element.signature;
    indent(sb, this.indentLevel);
    sb.push(this.typeToString(signature.returnType));
    sb.push(" ");
    sb.push(name);
    sb.push("(");
    var parameters = signature.parameterTypes;
    var numParameters = parameters.length;
    // var requiredParameters = signature.requiredParameters;
    for (let i = 0; i < numParameters; ++i) {
      if (i) sb.push(", ");
      // if (i >= requiredParameters) sb.push("optional ");
      sb.push(this.typeToString(parameters[i]));
      sb.push(" ");
      sb.push(element.getParameterName(i));
    }
    sb.push(");\n");
    var members = element.members;
    if (members !== null && members.size > 0) {
      indent(sb, this.indentLevel);
      sb.push("interface ");
      sb.push(element.name);
      sb.push(" {\n");
      // TODO: for (let member of members.values()) {
      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {
        let member = unchecked(_values[i]);
        this.visitElement(member.name, member);
      }
      indent(sb, --this.indentLevel);
      sb.push("}\n");
    }
  }

  visitClass(name: string, element: Class): void {
    var sb = this.sb;
    indent(sb, this.indentLevel++);
    sb.push("interface ");
    sb.push(name);
    sb.push(" {\n");
    // TODO
    indent(sb, --this.indentLevel);
    sb.push("}\n");
  }

  visitInterface(name: string, element: Interface): void {
    this.visitClass(name, element);
  }

  visitField(name: string, element: Field): void {
    // TODO
  }

  visitNamespace(name: string, element: Namespace): void {
    var sb = this.sb;
    indent(sb, this.indentLevel++);
    sb.push("interface ");
    sb.push(name);
    sb.push(" {\n");
    var members = element.members;
    if (members) {
      // TODO: for (let member of members.values()) {
      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {
        let member = unchecked(_values[i]);
        this.visitElement(member.name, member);
      }
    }
    indent(sb, --this.indentLevel);
    sb.push("}\n");
  }

  visitAlias(name: string, element: Element, originalName: string): void {
    // TODO
  }

  typeToString(type: Type): string {
    switch (type.kind) {
      case TypeKind.I8: return "byte";
      case TypeKind.I16: return "short";
      case TypeKind.I32: return "long";
      case TypeKind.I64: return "long long";
      case TypeKind.ISIZE: return this.program.options.isWasm64 ? "long long" : "long";
      case TypeKind.U8: return "octet";
      case TypeKind.U16: return "unsigned short";
      case TypeKind.U32: return "unsigned long";
        // ^ TODO: function types
      case TypeKind.U64: return "unsigned long long";
      case TypeKind.USIZE: return this.program.options.isWasm64 ? "unsigned long long" : "unsigned long";
        // ^ TODO: class types
      case TypeKind.BOOL: return "boolean";
      case TypeKind.F32: return "unrestricted float";
      case TypeKind.F64: return "unrestricted double";
      case TypeKind.VOID: return "void";
      default: {
        assert(false);
        return "";
      }
    }
  }

  build(): string {
    var sb = this.sb;
    sb.push("interface ASModule {\n");
    ++this.indentLevel;
    this.walk();
    --this.indentLevel;
    sb.push("}\n");
    return sb.join("");
  }
}

/** A TypeScript definitions builder. */
export class TSDBuilder extends ExportsWalker {

  /** Builds TypeScript definitions for the specified program. */
  static build(program: Program): string {
    return new TSDBuilder(program).build();
  }

  private sb: string[] = [];
  private indentLevel: i32 = 0;

  /** Constructs a new WebIDL builder. */
  constructor(program: Program, includePrivate: bool = false) {
    super(program, includePrivate);
  }

  visitGlobal(name: string, element: Global): void {
    var sb = this.sb;
    var isConst = element.is(CommonFlags.INLINED);
    indent(sb, this.indentLevel);
    if (element.is(CommonFlags.STATIC)) {
      if (isConst) sb.push("static readonly ");
      else sb.push("static ");
    } else {
      if (isConst) sb.push("export const ");
      else sb.push("export var ");
    }
    sb.push(name);
    sb.push(": ");
    sb.push(this.typeToString(element.type));
    sb.push(";\n");
    this.visitNamespace(name, element);
  }

  visitEnum(name: string, element: Enum): void {
    var sb = this.sb;
    indent(sb, this.indentLevel++);
    sb.push("export ");
    if (element.is(CommonFlags.CONST)) sb.push("const ");
    sb.push("enum ");
    sb.push(name);
    sb.push(" {\n");
    var members = element.members;
    var remainingMembers = 0;
    if (members) {
      remainingMembers = members.size;
      // TODO: for (let [memberName, member] of members) {
      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {
        let memberName = unchecked(_keys[i]);
        let member = assert(members.get(memberName));
        if (member.kind == ElementKind.ENUMVALUE) {
          let enumValue = <EnumValue>member;
          indent(sb, this.indentLevel);
          sb.push(memberName);
          if (member.is(CommonFlags.INLINED)) {
            sb.push(" = ");
            assert(enumValue.constantValueKind == ConstantValueKind.INTEGER);
            sb.push(i64_low(enumValue.constantIntegerValue).toString());
          }
          sb.push(",\n");
          --remainingMembers;
        }
      }
    }
    indent(sb, --this.indentLevel);
    sb.push("}\n");
    if (remainingMembers) this.visitNamespace(name, element);
  }

  visitFunction(name: string, element: Function): void {
    if (element.isAny(CommonFlags.PRIVATE)) return;
    var sb = this.sb;
    var signature = element.signature;
    indent(sb, this.indentLevel);
    if (!element.isAny(CommonFlags.STATIC | CommonFlags.INSTANCE)) {
      sb.push("export function ");
    } else {
      if (element.is(CommonFlags.PROTECTED)) sb.push("protected ");
      if (element.is(CommonFlags.STATIC)) sb.push("static ");
      if (element.is(CommonFlags.GET)) sb.push("get ");
      else if (element.is(CommonFlags.SET)) sb.push("set ");
    }
    sb.push(name);
    sb.push("(");
    var parameters = signature.parameterTypes;
    var numParameters = parameters.length;
    var requiredParameters = signature.requiredParameters;
    for (let i = 0; i < numParameters; ++i) {
      if (i) sb.push(", ");
      sb.push(element.getParameterName(i));
      if (i >= requiredParameters) sb.push("?");
      sb.push(": ");
      sb.push(this.typeToString(parameters[i]));
    }
    if (element.isAny(CommonFlags.CONSTRUCTOR | CommonFlags.SET)) {
      sb.push(")");
    } else {
      sb.push("): ");
      sb.push(this.typeToString(signature.returnType));
    }
    sb.push(";\n");
    this.visitNamespace(name, element);
  }

  visitClass(name: string, element: Class): void {
    var sb = this.sb;
    var isInterface = element.kind == ElementKind.INTERFACE;
    indent(sb, this.indentLevel++);
    if (isInterface) {
      sb.push("export interface ");
    } else {
      sb.push("export ");
      if (element.is(CommonFlags.ABSTRACT)) sb.push("abstract ");
      sb.push("class ");
    }
    sb.push(name);
    var base = element.base;
    if (base !== null && base.is(CommonFlags.COMPILED | CommonFlags.MODULE_EXPORT)) {
      sb.push(" extends ");
      let extendsNode = assert(element.prototype.extendsNode);
      sb.push(extendsNode.name.identifier.text); // TODO: fqn?
    }
    sb.push(" {\n");
    if (!isInterface) {
      indent(sb, this.indentLevel);
      sb.push("static wrap(ptr: usize): ");
      sb.push(name);
      sb.push(";\n");
      indent(sb, this.indentLevel);
      sb.push("valueOf(): usize;\n");
    }
    var staticMembers = element.prototype.members;
    if (staticMembers) {
      // TODO: for (let member of staticMembers.values()) {
      for (let _values = Map_values(staticMembers), i = 0, k = _values.length; i < k; ++i) {
        let member = unchecked(_values[i]);
        this.visitElement(member.name, member);
      }
    }
    var instanceMembers = element.members;
    if (instanceMembers) {
      // TODO: for (let member of instanceMembers.values()) {
      for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {
        let member = unchecked(_values[i]);
        if (member.parent == element) { // own member
          this.visitElement(member.name, member);
        }
      }
    }
    indent(sb, --this.indentLevel);
    sb.push("}\n");
  }

  visitInterface(name: string, element: Interface): void {
    this.visitClass(name, element);
  }

  visitField(name: string, element: Field): void {
    if (element.is(CommonFlags.PRIVATE)) return;
    var sb = this.sb;
    indent(sb, this.indentLevel);
    if (element.is(CommonFlags.PROTECTED)) sb.push("protected ");
    if (element.is(CommonFlags.STATIC)) sb.push("static ");
    if (element.is(CommonFlags.READONLY)) sb.push("readonly ");
    sb.push(name);
    sb.push(": ");
    sb.push(this.typeToString(element.type));
    sb.push(";\n");
  }

  visitNamespace(name: string, element: Element): void {
    var members = element.members;
    if (members !== null && members.size > 0) {
      let sb = this.sb;
      indent(sb, this.indentLevel++);
      sb.push("export namespace ");
      sb.push(name);
      sb.push(" {\n");
      // TODO: for (let member of members.values()) {
      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {
        let member = unchecked(_values[i]);
        this.visitElement(member.name, member);
      }
      indent(sb, --this.indentLevel);
      sb.push("}\n");
    }
  }

  visitAlias(name: string, element: Element, originalName: string): void {
    var sb = this.sb;
    indent(sb, this.indentLevel);
    sb.push("export const ");
    sb.push(name);
    sb.push(": typeof ");
    sb.push(originalName);
    sb.push(";\n");
  }

  typeToString(type: Type): string {
    switch (type.kind) {
      case TypeKind.I8: return "i8";
      case TypeKind.I16: return "i16";
      case TypeKind.I32: return "i32";
      case TypeKind.I64: return "i64";
      case TypeKind.ISIZE: return "isize";
      case TypeKind.U8: return "u8";
      case TypeKind.U16: return "u16";
      case TypeKind.U32: return "u32";
        // ^ TODO: function types
      case TypeKind.U64: return "u64";
      case TypeKind.USIZE: return "usize";
        // ^ TODO: class types
      case TypeKind.BOOL: return "bool";
      case TypeKind.F32: return "f32";
      case TypeKind.F64: return "f64";
      case TypeKind.V128: return "v128";
      case TypeKind.VOID: return "void";
      case TypeKind.FUNCREF: return "funcref";
      case TypeKind.EXTERNREF: return "externref";
      case TypeKind.ANYREF: return "anyref";
      case TypeKind.EQREF: return "eqref";
      case TypeKind.I31REF: return "i31ref";
      case TypeKind.DATAREF: return "dataref";
      default: {
        assert(false);
        return "any";
      }
    }
  }

  build(): string {
    var sb = this.sb;
    var options = this.program.options;
    sb.push("type i8 = number;\n");
    sb.push("type i16 = number;\n");
    sb.push("type i32 = number;\n");
    sb.push("type i64 = bigint;\n");
    if (options.isWasm64) {
      sb.push("type isize = bigint;\n");
    } else {
      sb.push("type isize = number;\n");
    }
    sb.push("type u8 = number;\n");
    sb.push("type u16 = number;\n");
    sb.push("type u32 = number;\n");
    sb.push("type u64 = bigint;\n");
    if (options.isWasm64) {
      sb.push("type usize = bigint;\n");
    } else {
      sb.push("type usize = number;\n");
    }
    sb.push("type f32 = number;\n");
    sb.push("type f64 = number;\n");
    sb.push("type bool = boolean | number;\n");
    this.walk();
    if (options.exportMemory) {
      sb.push("export const memory: WebAssembly.Memory;\n");
    }
    if (options.exportTable) {
      sb.push("export const table: WebAssembly.Table;\n");
    }
    if (options.explicitStart) {
      sb.push("export function _start(): void;\n");
    }
    if (options.exportRuntime) {
      sb.push("export function __new(size: usize, id: u32): usize;\n");
      sb.push("export function __pin(ptr: usize): usize;\n");
      sb.push("export function __unpin(ptr: usize): void;\n");
      sb.push("export function __collect(): void;\n");
      sb.push("export const __rtti_base: usize;\n");
    }
    sb.push("export const __setArgumentsLength: ((n: i32) => void) | undefined;\n");
    return this.sb.join("");
  }
}

// helpers

/** Tests if a namespace-like element has at least one compiled member. */
function hasCompiledMember(element: Element): bool {
  var members = element.members;
  if (members) {
    // TODO: for (let member of members.values()) {
    for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {
      let member = unchecked(_values[i]);
      switch (member.kind) {
        case ElementKind.FUNCTION_PROTOTYPE: {
          let instances = (<FunctionPrototype>member).instances;
          if (instances) {
            // TODO: for (let instance of instances.values()) {
            for (let _values = Map_values(instances), j = 0, l = _values.length; j < l; ++j) {
              let instance = unchecked(_values[j]);
              if (instance.is(CommonFlags.COMPILED)) return true;
            }
          }
          break;
        }
        case ElementKind.CLASS_PROTOTYPE: {
          let instances = (<ClassPrototype>member).instances;
          if (instances) {
            // TODO: for (let instance of instances.values()) {
            for (let _values = Map_values(instances), j = 0, l = _values.length; j < l; ++j) {
              let instance = unchecked(_values[j]);
              if (instance.is(CommonFlags.COMPILED)) return true;
            }
          }
          break;
        }
        default: {
          if (member.is(CommonFlags.COMPILED) || hasCompiledMember(member)) return true;
          break;
        }
      }
    }
  }
  return false;
}

'''
'''--- src/diagnosticMessages.generated.ts ---
/**
 * @fileoverview Generated from diagnosticsMessages.json. Do not edit.
 * @license Apache-2.0
 */

/** Enum of available diagnostic codes. */
export enum DiagnosticCode {
  Not_implemented_0 = 100,
  Operation_is_unsafe = 101,
  User_defined_0 = 102,
  Feature_0_is_not_enabled = 103,
  Low_memory_limit_exceeded_by_static_data_0_1 = 104,
  Module_requires_at_least_0_pages_of_initial_memory = 105,
  Module_requires_at_least_0_pages_of_maximum_memory = 106,
  Shared_memory_requires_maximum_memory_to_be_defined = 107,
  Shared_memory_requires_feature_threads_to_be_enabled = 108,
  Conversion_from_type_0_to_1_requires_an_explicit_cast = 200,
  Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit = 201,
  Type_0_cannot_be_changed_to_type_1 = 202,
  Operation_0_cannot_be_applied_to_type_1 = 203,
  Type_0_cannot_be_nullable = 204,
  Cannot_export_a_mutable_global = 205,
  Mutable_value_cannot_be_inlined = 206,
  Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa = 207,
  Unmanaged_classes_cannot_implement_interfaces = 208,
  Invalid_regular_expression_flags = 209,
  Expression_is_never_null = 210,
  Class_0_is_final_and_cannot_be_extended = 211,
  Decorator_0_is_not_valid_here = 212,
  Duplicate_decorator = 213,
  Type_0_is_illegal_in_this_context = 214,
  Optional_parameter_must_have_an_initializer = 215,
  Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal = 216,
  Function_0_cannot_be_inlined_into_itself = 217,
  Cannot_access_method_0_without_calling_it_as_it_requires_this_to_be_set = 218,
  Optional_properties_are_not_supported = 219,
  Expression_must_be_a_compile_time_constant = 220,
  Type_0_is_not_a_function_index_or_function_reference = 221,
  _0_must_be_a_value_between_1_and_2_inclusive = 222,
  _0_must_be_a_power_of_two = 223,
  _0_is_not_a_valid_operator = 224,
  Expression_cannot_be_represented_by_a_type = 225,
  Expression_resolves_to_unusual_type_0 = 226,
  Array_literal_expected = 227,
  Function_0_is_virtual_and_will_not_be_inlined = 228,
  Property_0_only_has_a_setter_and_is_missing_a_getter = 229,
  _0_keyword_cannot_be_used_here = 230,
  A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final = 231,
  Property_0_is_always_assigned_before_being_used = 233,
  Expression_refers_to_a_static_element_that_does_not_compile_to_a_value_at_runtime = 234,
  Importing_the_table_disables_some_indirect_call_optimizations = 901,
  Exporting_the_table_disables_some_indirect_call_optimizations = 902,
  Expression_compiles_to_a_dynamic_check_at_runtime = 903,
  Indexed_access_may_involve_bounds_checking = 904,
  Explicitly_returning_constructor_drops_this_allocation = 905,
  Unnecessary_definite_assignment = 906,
  Exported_generic_function_or_class_has_no_concrete_instances = 907,
  Unterminated_string_literal = 1002,
  Identifier_expected = 1003,
  _0_expected = 1005,
  A_file_cannot_have_a_reference_to_itself = 1006,
  Trailing_comma_not_allowed = 1009,
  Unexpected_token = 1012,
  A_rest_parameter_must_be_last_in_a_parameter_list = 1014,
  Parameter_cannot_have_question_mark_and_initializer = 1015,
  A_required_parameter_cannot_follow_an_optional_parameter = 1016,
  Statements_are_not_allowed_in_ambient_contexts = 1036,
  Initializers_are_not_allowed_in_ambient_contexts = 1039,
  _0_modifier_cannot_be_used_here = 1042,
  A_rest_parameter_cannot_be_optional = 1047,
  A_rest_parameter_cannot_have_an_initializer = 1048,
  A_set_accessor_must_have_exactly_one_parameter = 1049,
  A_set_accessor_parameter_cannot_have_an_initializer = 1052,
  A_get_accessor_cannot_have_parameters = 1054,
  Enum_member_must_have_initializer = 1061,
  Type_parameters_cannot_appear_on_a_constructor_declaration = 1092,
  Type_annotation_cannot_appear_on_a_constructor_declaration = 1093,
  An_accessor_cannot_have_type_parameters = 1094,
  A_set_accessor_cannot_have_a_return_type_annotation = 1095,
  Type_parameter_list_cannot_be_empty = 1098,
  Type_argument_list_cannot_be_empty = 1099,
  A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement = 1104,
  A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement = 1105,
  A_return_statement_can_only_be_used_within_a_function_body = 1108,
  Expression_expected = 1109,
  Type_expected = 1110,
  A_default_clause_cannot_appear_more_than_once_in_a_switch_statement = 1113,
  Duplicate_label_0 = 1114,
  An_export_assignment_cannot_have_modifiers = 1120,
  Octal_literals_are_not_allowed_in_strict_mode = 1121,
  Digit_expected = 1124,
  Hexadecimal_digit_expected = 1125,
  Unexpected_end_of_text = 1126,
  Invalid_character = 1127,
  _case_or_default_expected = 1130,
  _super_must_be_followed_by_an_argument_list_or_member_access = 1034,
  A_declare_modifier_cannot_be_used_in_an_already_ambient_context = 1038,
  Type_argument_expected = 1140,
  String_literal_expected = 1141,
  Line_break_not_permitted_here = 1142,
  Declaration_expected = 1146,
  _const_declarations_must_be_initialized = 1155,
  Unterminated_regular_expression_literal = 1161,
  Interface_declaration_cannot_have_implements_clause = 1176,
  Binary_digit_expected = 1177,
  Octal_digit_expected = 1178,
  An_implementation_cannot_be_declared_in_ambient_contexts = 1183,
  The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer = 1190,
  An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive = 1198,
  Unterminated_Unicode_escape_sequence = 1199,
  Decorators_are_not_valid_here = 1206,
  _abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration = 1242,
  Method_0_cannot_have_an_implementation_because_it_is_marked_abstract = 1245,
  A_definite_assignment_assertion_is_not_permitted_in_this_context = 1255,
  A_class_may_only_extend_another_class = 1311,
  A_parameter_property_cannot_be_declared_using_a_rest_parameter = 1317,
  An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal = 1351,
  Duplicate_identifier_0 = 2300,
  Cannot_find_name_0 = 2304,
  Module_0_has_no_exported_member_1 = 2305,
  An_interface_can_only_extend_an_interface = 2312,
  Generic_type_0_requires_1_type_argument_s = 2314,
  Type_0_is_not_generic = 2315,
  Type_0_is_not_assignable_to_type_1 = 2322,
  Index_signature_is_missing_in_type_0 = 2329,
  _this_cannot_be_referenced_in_current_location = 2332,
  _this_cannot_be_referenced_in_constructor_arguments = 2333,
  _super_can_only_be_referenced_in_a_derived_class = 2335,
  _super_cannot_be_referenced_in_constructor_arguments = 2336,
  Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors = 2337,
  Property_0_does_not_exist_on_type_1 = 2339,
  Property_0_is_private_and_only_accessible_within_class_1 = 2341,
  Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures = 2349,
  This_expression_is_not_constructable = 2351,
  A_function_whose_declared_type_is_not_void_must_return_a_value = 2355,
  The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access = 2357,
  The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access = 2364,
  Operator_0_cannot_be_applied_to_types_1_and_2 = 2365,
  A_super_call_must_be_the_first_statement_in_the_constructor = 2376,
  Constructors_for_derived_classes_must_contain_a_super_call = 2377,
  Getter_and_setter_accessors_do_not_agree_in_visibility = 2379,
  _get_and_set_accessor_must_have_the_same_type = 2380,
  Overload_signatures_must_all_be_public_private_or_protected = 2385,
  Constructor_implementation_is_missing = 2390,
  Function_implementation_is_missing_or_not_immediately_following_the_declaration = 2391,
  Multiple_constructor_implementations_are_not_allowed = 2392,
  Duplicate_function_implementation = 2393,
  This_overload_signature_is_not_compatible_with_its_implementation_signature = 2394,
  Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local = 2395,
  A_class_can_only_implement_an_interface = 2422,
  A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged = 2434,
  Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses = 2445,
  Variable_0_used_before_its_declaration = 2448,
  Cannot_redeclare_block_scoped_variable_0 = 2451,
  The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly = 2453,
  Type_0_has_no_property_1 = 2460,
  The_0_operator_cannot_be_applied_to_type_1 = 2469,
  In_const_enum_declarations_member_initializer_must_be_constant_expression = 2474,
  Export_declaration_conflicts_with_exported_declaration_of_0 = 2484,
  _0_is_referenced_directly_or_indirectly_in_its_own_base_expression = 2506,
  Cannot_create_an_instance_of_an_abstract_class = 2511,
  Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2 = 2515,
  Object_is_possibly_null = 2531,
  Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property = 2540,
  The_target_of_an_assignment_must_be_a_variable_or_a_property_access = 2541,
  Index_signature_in_type_0_only_permits_reading = 2542,
  Expected_0_arguments_but_got_1 = 2554,
  Expected_at_least_0_arguments_but_got_1 = 2555,
  Expected_0_type_arguments_but_got_1 = 2558,
  Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned = 2564,
  Property_0_is_used_before_being_assigned = 2565,
  A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums = 2651,
  Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration = 2673,
  Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration = 2674,
  The_this_types_of_each_signature_are_incompatible = 2685,
  Namespace_0_has_no_exported_member_1 = 2694,
  Required_type_parameters_may_not_follow_optional_type_parameters = 2706,
  Duplicate_property_0 = 2718,
  Property_0_is_missing_in_type_1_but_required_in_type_2 = 2741,
  Type_0_has_no_call_signatures = 2757,
  File_0_not_found = 6054,
  Numeric_separators_are_not_allowed_here = 6188,
  Multiple_consecutive_numeric_separators_are_not_permitted = 6189,
  _super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class = 17009,
  _super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class = 17011
}

/** Translates a diagnostic code to its respective string. */
export function diagnosticCodeToString(code: DiagnosticCode): string {
  switch (code) {
    case 100: return "Not implemented: {0}";
    case 101: return "Operation is unsafe.";
    case 102: return "User-defined: {0}";
    case 103: return "Feature '{0}' is not enabled.";
    case 104: return "Low memory limit exceeded by static data: {0} > {1}";
    case 105: return "Module requires at least '{0}' pages of initial memory.";
    case 106: return "Module requires at least '{0}' pages of maximum memory.";
    case 107: return "Shared memory requires maximum memory to be defined.";
    case 108: return "Shared memory requires feature 'threads' to be enabled.";
    case 200: return "Conversion from type '{0}' to '{1}' requires an explicit cast.";
    case 201: return "Conversion from type '{0}' to '{1}' will require an explicit cast when switching between 32/64-bit.";
    case 202: return "Type '{0}' cannot be changed to type '{1}'.";
    case 203: return "Operation '{0}' cannot be applied to type '{1}'.";
    case 204: return "Type '{0}' cannot be nullable.";
    case 205: return "Cannot export a mutable global.";
    case 206: return "Mutable value cannot be inlined.";
    case 207: return "Unmanaged classes cannot extend managed classes and vice-versa.";
    case 208: return "Unmanaged classes cannot implement interfaces.";
    case 209: return "Invalid regular expression flags.";
    case 210: return "Expression is never 'null'.";
    case 211: return "Class '{0}' is final and cannot be extended.";
    case 212: return "Decorator '{0}' is not valid here.";
    case 213: return "Duplicate decorator.";
    case 214: return "Type '{0}' is illegal in this context.";
    case 215: return "Optional parameter must have an initializer.";
    case 216: return "Class '{0}' cannot declare a constructor when instantiated from an object literal.";
    case 217: return "Function '{0}' cannot be inlined into itself.";
    case 218: return "Cannot access method '{0}' without calling it as it requires 'this' to be set.";
    case 219: return "Optional properties are not supported.";
    case 220: return "Expression must be a compile-time constant.";
    case 221: return "Type '{0}' is not a function index or function reference.";
    case 222: return "'{0}' must be a value between '{1}' and '{2}' inclusive.";
    case 223: return "'{0}' must be a power of two.";
    case 224: return "'{0}' is not a valid operator.";
    case 225: return "Expression cannot be represented by a type.";
    case 226: return "Expression resolves to unusual type '{0}'.";
    case 227: return "Array literal expected.";
    case 228: return "Function '{0}' is virtual and will not be inlined.";
    case 229: return "Property '{0}' only has a setter and is missing a getter.";
    case 230: return "'{0}' keyword cannot be used here.";
    case 231: return "A class with a constructor explicitly returning something else than 'this' must be '@final'.";
    case 233: return "Property '{0}' is always assigned before being used.";
    case 234: return "Expression refers to a static element that does not compile to a value at runtime.";
    case 901: return "Importing the table disables some indirect call optimizations.";
    case 902: return "Exporting the table disables some indirect call optimizations.";
    case 903: return "Expression compiles to a dynamic check at runtime.";
    case 904: return "Indexed access may involve bounds checking.";
    case 905: return "Explicitly returning constructor drops 'this' allocation.";
    case 906: return "Unnecessary definite assignment.";
    case 907: return "Exported generic function or class has no concrete instances.";
    case 1002: return "Unterminated string literal.";
    case 1003: return "Identifier expected.";
    case 1005: return "'{0}' expected.";
    case 1006: return "A file cannot have a reference to itself.";
    case 1009: return "Trailing comma not allowed.";
    case 1012: return "Unexpected token.";
    case 1014: return "A rest parameter must be last in a parameter list.";
    case 1015: return "Parameter cannot have question mark and initializer.";
    case 1016: return "A required parameter cannot follow an optional parameter.";
    case 1036: return "Statements are not allowed in ambient contexts.";
    case 1039: return "Initializers are not allowed in ambient contexts.";
    case 1042: return "'{0}' modifier cannot be used here.";
    case 1047: return "A rest parameter cannot be optional.";
    case 1048: return "A rest parameter cannot have an initializer.";
    case 1049: return "A 'set' accessor must have exactly one parameter.";
    case 1052: return "A 'set' accessor parameter cannot have an initializer.";
    case 1054: return "A 'get' accessor cannot have parameters.";
    case 1061: return "Enum member must have initializer.";
    case 1092: return "Type parameters cannot appear on a constructor declaration.";
    case 1093: return "Type annotation cannot appear on a constructor declaration.";
    case 1094: return "An accessor cannot have type parameters.";
    case 1095: return "A 'set' accessor cannot have a return type annotation.";
    case 1098: return "Type parameter list cannot be empty.";
    case 1099: return "Type argument list cannot be empty.";
    case 1104: return "A 'continue' statement can only be used within an enclosing iteration statement.";
    case 1105: return "A 'break' statement can only be used within an enclosing iteration or switch statement.";
    case 1108: return "A 'return' statement can only be used within a function body.";
    case 1109: return "Expression expected.";
    case 1110: return "Type expected.";
    case 1113: return "A 'default' clause cannot appear more than once in a 'switch' statement.";
    case 1114: return "Duplicate label '{0}'.";
    case 1120: return "An export assignment cannot have modifiers.";
    case 1121: return "Octal literals are not allowed in strict mode.";
    case 1124: return "Digit expected.";
    case 1125: return "Hexadecimal digit expected.";
    case 1126: return "Unexpected end of text.";
    case 1127: return "Invalid character.";
    case 1130: return "'case' or 'default' expected.";
    case 1034: return "'super' must be followed by an argument list or member access.";
    case 1038: return "A 'declare' modifier cannot be used in an already ambient context.";
    case 1140: return "Type argument expected.";
    case 1141: return "String literal expected.";
    case 1142: return "Line break not permitted here.";
    case 1146: return "Declaration expected.";
    case 1155: return "'const' declarations must be initialized.";
    case 1161: return "Unterminated regular expression literal.";
    case 1176: return "Interface declaration cannot have 'implements' clause.";
    case 1177: return "Binary digit expected.";
    case 1178: return "Octal digit expected.";
    case 1183: return "An implementation cannot be declared in ambient contexts.";
    case 1190: return "The variable declaration of a 'for...of' statement cannot have an initializer.";
    case 1198: return "An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.";
    case 1199: return "Unterminated Unicode escape sequence.";
    case 1206: return "Decorators are not valid here.";
    case 1242: return "'abstract' modifier can only appear on a class, method, or property declaration.";
    case 1245: return "Method '{0}' cannot have an implementation because it is marked abstract.";
    case 1255: return "A definite assignment assertion '!' is not permitted in this context.";
    case 1311: return "A class may only extend another class.";
    case 1317: return "A parameter property cannot be declared using a rest parameter.";
    case 1351: return "An identifier or keyword cannot immediately follow a numeric literal.";
    case 2300: return "Duplicate identifier '{0}'.";
    case 2304: return "Cannot find name '{0}'.";
    case 2305: return "Module '{0}' has no exported member '{1}'.";
    case 2312: return "An interface can only extend an interface.";
    case 2314: return "Generic type '{0}' requires {1} type argument(s).";
    case 2315: return "Type '{0}' is not generic.";
    case 2322: return "Type '{0}' is not assignable to type '{1}'.";
    case 2329: return "Index signature is missing in type '{0}'.";
    case 2332: return "'this' cannot be referenced in current location.";
    case 2333: return "'this' cannot be referenced in constructor arguments.";
    case 2335: return "'super' can only be referenced in a derived class.";
    case 2336: return "'super' cannot be referenced in constructor arguments.";
    case 2337: return "Super calls are not permitted outside constructors or in nested functions inside constructors.";
    case 2339: return "Property '{0}' does not exist on type '{1}'.";
    case 2341: return "Property '{0}' is private and only accessible within class '{1}'.";
    case 2349: return "Cannot invoke an expression whose type lacks a call signature. Type '{0}' has no compatible call signatures.";
    case 2351: return "This expression is not constructable.";
    case 2355: return "A function whose declared type is not 'void' must return a value.";
    case 2357: return "The operand of an increment or decrement operator must be a variable or a property access.";
    case 2364: return "The left-hand side of an assignment expression must be a variable or a property access.";
    case 2365: return "Operator '{0}' cannot be applied to types '{1}' and '{2}'.";
    case 2376: return "A 'super' call must be the first statement in the constructor.";
    case 2377: return "Constructors for derived classes must contain a 'super' call.";
    case 2379: return "Getter and setter accessors do not agree in visibility.";
    case 2380: return "'get' and 'set' accessor must have the same type.";
    case 2385: return "Overload signatures must all be public, private or protected.";
    case 2390: return "Constructor implementation is missing.";
    case 2391: return "Function implementation is missing or not immediately following the declaration.";
    case 2392: return "Multiple constructor implementations are not allowed.";
    case 2393: return "Duplicate function implementation.";
    case 2394: return "This overload signature is not compatible with its implementation signature.";
    case 2395: return "Individual declarations in merged declaration '{0}' must be all exported or all local.";
    case 2422: return "A class can only implement an interface.";
    case 2434: return "A namespace declaration cannot be located prior to a class or function with which it is merged.";
    case 2445: return "Property '{0}' is protected and only accessible within class '{1}' and its subclasses.";
    case 2448: return "Variable '{0}' used before its declaration.";
    case 2451: return "Cannot redeclare block-scoped variable '{0}'";
    case 2453: return "The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.";
    case 2460: return "Type '{0}' has no property '{1}'.";
    case 2469: return "The '{0}' operator cannot be applied to type '{1}'.";
    case 2474: return "In 'const' enum declarations member initializer must be constant expression.";
    case 2484: return "Export declaration conflicts with exported declaration of '{0}'.";
    case 2506: return "'{0}' is referenced directly or indirectly in its own base expression.";
    case 2511: return "Cannot create an instance of an abstract class.";
    case 2515: return "Non-abstract class '{0}' does not implement inherited abstract member '{1}' from '{2}'.";
    case 2531: return "Object is possibly 'null'.";
    case 2540: return "Cannot assign to '{0}' because it is a constant or a read-only property.";
    case 2541: return "The target of an assignment must be a variable or a property access.";
    case 2542: return "Index signature in type '{0}' only permits reading.";
    case 2554: return "Expected {0} arguments, but got {1}.";
    case 2555: return "Expected at least {0} arguments, but got {1}.";
    case 2558: return "Expected {0} type arguments, but got {1}.";
    case 2564: return "Property '{0}' has no initializer and is not assigned in the constructor before 'this' is used or returned.";
    case 2565: return "Property '{0}' is used before being assigned.";
    case 2651: return "A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums.";
    case 2673: return "Constructor of class '{0}' is private and only accessible within the class declaration.";
    case 2674: return "Constructor of class '{0}' is protected and only accessible within the class declaration.";
    case 2685: return "The 'this' types of each signature are incompatible.";
    case 2694: return "Namespace '{0}' has no exported member '{1}'.";
    case 2706: return "Required type parameters may not follow optional type parameters.";
    case 2718: return "Duplicate property '{0}'.";
    case 2741: return "Property '{0}' is missing in type '{1}' but required in type '{2}'.";
    case 2757: return "Type '{0}' has no call signatures.";
    case 6054: return "File '{0}' not found.";
    case 6188: return "Numeric separators are not allowed here.";
    case 6189: return "Multiple consecutive numeric separators are not permitted.";
    case 17009: return "'super' must be called before accessing 'this' in the constructor of a derived class.";
    case 17011: return "'super' must be called before accessing a property of 'super' in the constructor of a derived class.";
    default: return "";
  }
}

'''
'''--- src/diagnosticMessages.json ---
{
  "Not implemented: {0}": 100,
  "Operation is unsafe.": 101,
  "User-defined: {0}": 102,
  "Feature '{0}' is not enabled.": 103,
  "Low memory limit exceeded by static data: {0} > {1}": 104,
  "Module requires at least '{0}' pages of initial memory.": 105,
  "Module requires at least '{0}' pages of maximum memory.": 106,
  "Shared memory requires maximum memory to be defined.": 107,
  "Shared memory requires feature 'threads' to be enabled.": 108,

  "Conversion from type '{0}' to '{1}' requires an explicit cast.": 200,
  "Conversion from type '{0}' to '{1}' will require an explicit cast when switching between 32/64-bit.": 201,
  "Type '{0}' cannot be changed to type '{1}'.": 202,
  "Operation '{0}' cannot be applied to type '{1}'.": 203,
  "Type '{0}' cannot be nullable.": 204,
  "Cannot export a mutable global.": 205,
  "Mutable value cannot be inlined.": 206,
  "Unmanaged classes cannot extend managed classes and vice-versa.": 207,
  "Unmanaged classes cannot implement interfaces.": 208,
  "Invalid regular expression flags.": 209,
  "Expression is never 'null'.": 210,
  "Class '{0}' is final and cannot be extended.": 211,
  "Decorator '{0}' is not valid here.": 212,
  "Duplicate decorator.": 213,
  "Type '{0}' is illegal in this context.": 214,
  "Optional parameter must have an initializer.": 215,
  "Class '{0}' cannot declare a constructor when instantiated from an object literal.": 216,
  "Function '{0}' cannot be inlined into itself.": 217,
  "Cannot access method '{0}' without calling it as it requires 'this' to be set.": 218,
  "Optional properties are not supported.": 219,
  "Expression must be a compile-time constant.": 220,
  "Type '{0}' is not a function index or function reference.": 221,
  "'{0}' must be a value between '{1}' and '{2}' inclusive.": 222,
  "'{0}' must be a power of two.": 223,
  "'{0}' is not a valid operator.": 224,
  "Expression cannot be represented by a type.": 225,
  "Expression resolves to unusual type '{0}'.": 226,
  "Array literal expected.": 227,
  "Function '{0}' is virtual and will not be inlined.": 228,
  "Property '{0}' only has a setter and is missing a getter.": 229,
  "'{0}' keyword cannot be used here.": 230,
  "A class with a constructor explicitly returning something else than 'this' must be '@final'.": 231,
  "Property '{0}' is always assigned before being used.": 233,
  "Expression refers to a static element that does not compile to a value at runtime.": 234,

  "Importing the table disables some indirect call optimizations.": 901,
  "Exporting the table disables some indirect call optimizations.": 902,
  "Expression compiles to a dynamic check at runtime.": 903,
  "Indexed access may involve bounds checking.": 904,
  "Explicitly returning constructor drops 'this' allocation.": 905,
  "Unnecessary definite assignment.": 906,
  "Exported generic function or class has no concrete instances.": 907,

  "Unterminated string literal.": 1002,
  "Identifier expected.": 1003,
  "'{0}' expected.": 1005,
  "A file cannot have a reference to itself.": 1006,
  "Trailing comma not allowed.": 1009,
  "Unexpected token.": 1012,
  "A rest parameter must be last in a parameter list.": 1014,
  "Parameter cannot have question mark and initializer.": 1015,
  "A required parameter cannot follow an optional parameter.": 1016,
  "Statements are not allowed in ambient contexts.": 1036,
  "Initializers are not allowed in ambient contexts.": 1039,
  "'{0}' modifier cannot be used here.": 1042,
  "A rest parameter cannot be optional.": 1047,
  "A rest parameter cannot have an initializer.": 1048,
  "A 'set' accessor must have exactly one parameter.": 1049,
  "A 'set' accessor parameter cannot have an initializer.": 1052,
  "A 'get' accessor cannot have parameters.": 1054,
  "Enum member must have initializer.": 1061,
  "Type parameters cannot appear on a constructor declaration.": 1092,
  "Type annotation cannot appear on a constructor declaration.": 1093,
  "An accessor cannot have type parameters.": 1094,
  "A 'set' accessor cannot have a return type annotation.": 1095,
  "Type parameter list cannot be empty.": 1098,
  "Type argument list cannot be empty.": 1099,
  "A 'continue' statement can only be used within an enclosing iteration statement.": 1104,
  "A 'break' statement can only be used within an enclosing iteration or switch statement.": 1105,
  "A 'return' statement can only be used within a function body.": 1108,
  "Expression expected.": 1109,
  "Type expected.": 1110,
  "A 'default' clause cannot appear more than once in a 'switch' statement.": 1113,
  "Duplicate label '{0}'.": 1114,
  "An export assignment cannot have modifiers.": 1120,
  "Octal literals are not allowed in strict mode.": 1121,
  "Digit expected.": 1124,
  "Hexadecimal digit expected.": 1125,
  "Unexpected end of text.": 1126,
  "Invalid character.": 1127,
  "'case' or 'default' expected.": 1130,
  "'super' must be followed by an argument list or member access.": 1034,
  "A 'declare' modifier cannot be used in an already ambient context.": 1038,
  "Type argument expected.": 1140,
  "String literal expected.": 1141,
  "Line break not permitted here.": 1142,
  "Declaration expected.": 1146,
  "'const' declarations must be initialized.": 1155,
  "Unterminated regular expression literal.": 1161,
  "Interface declaration cannot have 'implements' clause.": 1176,
  "Binary digit expected.": 1177,
  "Octal digit expected.": 1178,
  "An implementation cannot be declared in ambient contexts.": 1183,
  "The variable declaration of a 'for...of' statement cannot have an initializer.": 1190,
  "An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.": 1198,
  "Unterminated Unicode escape sequence.": 1199,
  "Decorators are not valid here.": 1206,
  "'abstract' modifier can only appear on a class, method, or property declaration.": 1242,
  "Method '{0}' cannot have an implementation because it is marked abstract.": 1245,
  "A definite assignment assertion '!' is not permitted in this context.": 1255,
  "A class may only extend another class.": 1311,
  "A parameter property cannot be declared using a rest parameter.": 1317,
  "An identifier or keyword cannot immediately follow a numeric literal.": 1351,

  "Duplicate identifier '{0}'.": 2300,
  "Cannot find name '{0}'.": 2304,
  "Module '{0}' has no exported member '{1}'.": 2305,
  "An interface can only extend an interface.": 2312,
  "Generic type '{0}' requires {1} type argument(s).": 2314,
  "Type '{0}' is not generic.": 2315,
  "Type '{0}' is not assignable to type '{1}'.": 2322,
  "Index signature is missing in type '{0}'.": 2329,
  "'this' cannot be referenced in current location.": 2332,
  "'this' cannot be referenced in constructor arguments.": 2333,
  "'super' can only be referenced in a derived class.": 2335,
  "'super' cannot be referenced in constructor arguments.": 2336,
  "Super calls are not permitted outside constructors or in nested functions inside constructors.": 2337,
  "Property '{0}' does not exist on type '{1}'.": 2339,
  "Property '{0}' is private and only accessible within class '{1}'.": 2341,
  "Cannot invoke an expression whose type lacks a call signature. Type '{0}' has no compatible call signatures.": 2349,
  "This expression is not constructable.": 2351,
  "A function whose declared type is not 'void' must return a value.": 2355,
  "The operand of an increment or decrement operator must be a variable or a property access.": 2357,
  "The left-hand side of an assignment expression must be a variable or a property access.": 2364,
  "Operator '{0}' cannot be applied to types '{1}' and '{2}'.": 2365,
  "A 'super' call must be the first statement in the constructor.": 2376,
  "Constructors for derived classes must contain a 'super' call.": 2377,
  "Getter and setter accessors do not agree in visibility.": 2379,
  "'get' and 'set' accessor must have the same type.": 2380,
  "Overload signatures must all be public, private or protected.": 2385,
  "Constructor implementation is missing.": 2390,
  "Function implementation is missing or not immediately following the declaration.": 2391,
  "Multiple constructor implementations are not allowed.": 2392,
  "Duplicate function implementation.": 2393,
  "This overload signature is not compatible with its implementation signature.": 2394,
  "Individual declarations in merged declaration '{0}' must be all exported or all local.": 2395,
  "A class can only implement an interface.": 2422,
  "A namespace declaration cannot be located prior to a class or function with which it is merged.": 2434,
  "Property '{0}' is protected and only accessible within class '{1}' and its subclasses.": 2445,
  "Variable '{0}' used before its declaration.": 2448,
  "Cannot redeclare block-scoped variable '{0}'" : 2451,
  "The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.": 2453,
  "Type '{0}' has no property '{1}'.": 2460,
  "The '{0}' operator cannot be applied to type '{1}'.": 2469,
  "In 'const' enum declarations member initializer must be constant expression.": 2474,
  "Export declaration conflicts with exported declaration of '{0}'.": 2484,
  "'{0}' is referenced directly or indirectly in its own base expression.": 2506,
  "Cannot create an instance of an abstract class.": 2511,
  "Non-abstract class '{0}' does not implement inherited abstract member '{1}' from '{2}'.": 2515,
  "Object is possibly 'null'.": 2531,
  "Cannot assign to '{0}' because it is a constant or a read-only property.": 2540,
  "The target of an assignment must be a variable or a property access.": 2541,
  "Index signature in type '{0}' only permits reading.": 2542,
  "Expected {0} arguments, but got {1}.": 2554,
  "Expected at least {0} arguments, but got {1}.": 2555,
  "Expected {0} type arguments, but got {1}.": 2558,
  "Property '{0}' has no initializer and is not assigned in the constructor before 'this' is used or returned.": 2564,
  "Property '{0}' is used before being assigned.": 2565,
  "A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums.": 2651,
  "Constructor of class '{0}' is private and only accessible within the class declaration.": 2673,
  "Constructor of class '{0}' is protected and only accessible within the class declaration.": 2674,
  "The 'this' types of each signature are incompatible.": 2685,
  "Namespace '{0}' has no exported member '{1}'.": 2694,
  "Required type parameters may not follow optional type parameters.": 2706,
  "Duplicate property '{0}'.": 2718,
  "Property '{0}' is missing in type '{1}' but required in type '{2}'.": 2741,
  "Type '{0}' has no call signatures.": 2757,

  "File '{0}' not found.": 6054,
  "Numeric separators are not allowed here.": 6188,
  "Multiple consecutive numeric separators are not permitted.": 6189,
  "'super' must be called before accessing 'this' in the constructor of a derived class.": 17009,
  "'super' must be called before accessing a property of 'super' in the constructor of a derived class.": 17011
}

'''
'''--- src/diagnostics.ts ---
/**
 * @fileoverview Shared diagnostic handling.
 * @license Apache-2.0
 */

import {
  Range
} from "./tokenizer";

import {
  Source
} from "./ast";

import {
  DiagnosticCode,
  diagnosticCodeToString
} from "./diagnosticMessages.generated";

import {
  isLineBreak,
  COLOR_CYAN,
  COLOR_YELLOW,
  COLOR_RED,
  COLOR_MAGENTA,
  COLOR_RESET,
  isColorsEnabled,
  setColorsEnabled
} from "./util";

export {
  DiagnosticCode,
  diagnosticCodeToString
} from "./diagnosticMessages.generated";

/** Indicates the category of a {@link DiagnosticMessage}. */
export enum DiagnosticCategory {
  /** Overly pedantic message. */
  PEDANTIC,
  /** Informatory message. */
  INFO,
  /** Warning message. */
  WARNING,
  /** Error message. */
  ERROR
}

/** Returns the string representation of the specified diagnostic category. */
export function diagnosticCategoryToString(category: DiagnosticCategory): string {
  switch (category) {
    case DiagnosticCategory.PEDANTIC: return "PEDANTIC";
    case DiagnosticCategory.INFO: return "INFO";
    case DiagnosticCategory.WARNING: return "WARNING";
    case DiagnosticCategory.ERROR: return "ERROR";
    default: {
      assert(false);
      return "";
    }
  }
}

/** Returns the ANSI escape sequence for the specified category. */
export function diagnosticCategoryToColor(category: DiagnosticCategory): string {
  switch (category) {
    case DiagnosticCategory.PEDANTIC: return COLOR_MAGENTA;
    case DiagnosticCategory.INFO: return COLOR_CYAN;
    case DiagnosticCategory.WARNING: return COLOR_YELLOW;
    case DiagnosticCategory.ERROR: return COLOR_RED;
    default: {
      assert(false);
      return "";
    }
  }
}

/** Represents a diagnostic message. */
export class DiagnosticMessage {

  /** Message code. */
  code: i32;
  /** Message category. */
  category: DiagnosticCategory;
  /** Message text. */
  message: string;
  /** Respective source range, if any. */
  range: Range | null = null;
  /** Related range, if any. */
  relatedRange: Range | null = null; // TODO: Make this a related message for chains?

  /** Constructs a new diagnostic message. */
  private constructor(code: i32, category: DiagnosticCategory, message: string) {
    this.code = code;
    this.category = category;
    this.message = message;
  }

  /** Creates a new diagnostic message of the specified category. */
  static create(
    code: DiagnosticCode,
    category: DiagnosticCategory,
    arg0: string | null = null,
    arg1: string | null = null,
    arg2: string | null = null
  ): DiagnosticMessage {
    var message = diagnosticCodeToString(code);
    if (arg0 !== null) message = message.replace("{0}", arg0);
    if (arg1 !== null) message = message.replace("{1}", arg1);
    if (arg2 !== null) message = message.replace("{2}", arg2);
    return new DiagnosticMessage(code, category, message);
  }

  /** Tests if this message equals the specified. */
  equals(other: DiagnosticMessage): bool {
    if (this.code != other.code) return false;
    var thisRange = this.range;
    var otherRange = other.range;
    if (thisRange) {
      if (!otherRange || !thisRange.equals(otherRange)) return false;
    } else if (otherRange) {
      return false;
    }
    var thisRelatedRange = this.relatedRange;
    var otherRelatedRange = other.relatedRange;
    if (thisRelatedRange) {
      if (!otherRelatedRange || !thisRelatedRange.equals(otherRelatedRange)) return false;
    } else if (otherRange) {
      return false;
    }
    return this.message == other.message;
  }

  /** Adds a source range to this message. */
  withRange(range: Range): this {
    this.range = range;
    return this;
  }

  /** Adds a related source range to this message. */
  withRelatedRange(range: Range): this {
    this.relatedRange = range;
    return this;
  }

  /** Converts this message to a string. */
  toString(): string {
    var range = this.range;
    if (range) {
      let source = range.source;
      return (
        diagnosticCategoryToString(this.category) +
        " " +
        this.code.toString() +
        ": \"" +
        this.message +
        "\" in " +
        source.normalizedPath +
        "(" +
        source.lineAt(range.start).toString() +
        "," +
        source.columnAt().toString() +
        "+" +
        (range.end - range.start).toString() +
        ")"
      );
    }
    return (
      diagnosticCategoryToString(this.category) +
      " " +
      this.code.toString() +
      ": " +
      this.message
    );
  }
}

/** Formats a diagnostic message, optionally with terminal colors and source context. */
export function formatDiagnosticMessage(
  message: DiagnosticMessage,
  useColors: bool = false,
  showContext: bool = false
): string {
  var wasColorsEnabled = setColorsEnabled(useColors);

  // general information
  var sb: string[] = [];
  if (isColorsEnabled()) sb.push(diagnosticCategoryToColor(message.category));
  sb.push(diagnosticCategoryToString(message.category));
  if (isColorsEnabled()) sb.push(COLOR_RESET);
  sb.push(message.code < 1000 ? " AS" : " TS");
  sb.push(message.code.toString());
  sb.push(": ");
  sb.push(message.message);

  // include range information if available
  var range = message.range;
  if (range) {
    let source = range.source;

    // include context information if requested
    if (showContext) {
      sb.push("\n");
      sb.push(formatDiagnosticContext(range));
    }
    sb.push("\n");
    sb.push(" in ");
    sb.push(source.normalizedPath);
    sb.push("(");
    sb.push(source.lineAt(range.start).toString());
    sb.push(",");
    sb.push(source.columnAt().toString());
    sb.push(")");

    let relatedRange = message.relatedRange;
    if (relatedRange) {
      let relatedSource = relatedRange.source;
      if (showContext) {
        sb.push("\n");
        sb.push(formatDiagnosticContext(relatedRange));
      }
      sb.push("\n");
      sb.push(" in ");
      sb.push(relatedSource.normalizedPath);
      sb.push("(");
      sb.push(relatedSource.lineAt(relatedRange.start).toString());
      sb.push(",");
      sb.push(relatedSource.columnAt().toString());
      sb.push(")");
    }
  }
  setColorsEnabled(wasColorsEnabled);
  return sb.join("");
}

/** Formats the diagnostic context for the specified range, optionally with terminal colors. */
function formatDiagnosticContext(range: Range): string {
  var text = range.source.text;
  var len = text.length;
  var start = range.start;
  var end = range.end;
  while (start > 0 && !isLineBreak(text.charCodeAt(start - 1))) start--;
  while (end < len && !isLineBreak(text.charCodeAt(end))) end++;
  var sb: string[] = [
    "\n ",
    text.substring(start, end),
    "\n "
  ];
  while (start < range.start) {
    sb.push(" ");
    start++;
  }
  if (isColorsEnabled()) sb.push(COLOR_RED);
  if (range.start == range.end) {
    sb.push("^");
  } else {
    while (start++ < range.end) {
      if (isLineBreak(text.charCodeAt(start))) {
        sb.push(start == range.start + 1 ? "^" : "~");
        break;
      }
      sb.push("~");
    }
  }
  if (isColorsEnabled()) sb.push(COLOR_RESET);
  return sb.join("");
}

/** Base class of all diagnostic emitters. */
export abstract class DiagnosticEmitter {

  /** Diagnostic messages emitted so far. */
  diagnostics: DiagnosticMessage[];
  /** Diagnostic messages already seen, by range. */
  private seen: Map<Source,Map<i32,DiagnosticMessage[]>> = new Map();

  /** Initializes this diagnostic emitter. */
  protected constructor(diagnostics: DiagnosticMessage[] | null = null) {
    if (!diagnostics) diagnostics = [];
    this.diagnostics = diagnostics;
  }

  /** Emits a diagnostic message of the specified category. */
  emitDiagnostic(
    code: DiagnosticCode,
    category: DiagnosticCategory,
    range: Range | null,
    relatedRange: Range | null,
    arg0: string | null = null,
    arg1: string | null = null,
    arg2: string | null = null
  ): void {
    var message = DiagnosticMessage.create(code, category, arg0, arg1, arg2);
    if (range) message = message.withRange(range);
    if (relatedRange) message.relatedRange = relatedRange;
    // It is possible that the same diagnostic is emitted twice, for example
    // when compiling generics with different types or when recompiling a loop
    // because our initial assumptions didn't hold. It is even possible to get
    // multiple instances of the same range during parsing. Deduplicate these.
    if (range) {
      let seen = this.seen;
      if (seen.has(range.source)) {
        let seenInSource = assert(seen.get(range.source));
        if (seenInSource.has(range.start)) {
          let seenMessagesAtPos = assert(seenInSource.get(range.start));
          for (let i = 0, k = seenMessagesAtPos.length; i < k; ++i) {
            if (seenMessagesAtPos[i].equals(message)) return;
          }
          seenMessagesAtPos.push(message);
        } else {
          seenInSource.set(range.start, [ message ]);
        }
      } else {
        let seenInSource = new Map<i32,DiagnosticMessage[]>();
        seenInSource.set(range.start, [ message ]);
        seen.set(range.source, seenInSource);
      }
    }
    this.diagnostics.push(message);
    // console.log(formatDiagnosticMessage(message, true, true) + "\n"); // temporary
    // console.log(<string>new Error("stack").stack);
  }

  /** Emits an overly pedantic diagnostic message. */
  pedantic(
    code: DiagnosticCode,
    range: Range | null,
    arg0: string | null = null,
    arg1: string | null = null,
    arg2: string | null = null
  ): void {
    this.emitDiagnostic(code, DiagnosticCategory.PEDANTIC, range, null, arg0, arg1, arg2);
  }

  /** Emits an overly pedantic diagnostic message with a related range. */
  pedanticRelated(
    code: DiagnosticCode,
    range: Range,
    relatedRange: Range,
    arg0: string | null = null,
    arg1: string | null = null,
    arg2: string | null = null
  ): void {
    this.emitDiagnostic(code, DiagnosticCategory.PEDANTIC, range, relatedRange, arg0, arg1, arg2);
  }

  /** Emits an informatory diagnostic message. */
  info(
    code: DiagnosticCode,
    range: Range | null,
    arg0: string | null = null,
    arg1: string | null = null,
    arg2: string | null = null
  ): void {
    this.emitDiagnostic(code, DiagnosticCategory.INFO, range, null, arg0, arg1, arg2);
  }

  /** Emits an informatory diagnostic message with a related range. */
  infoRelated(
    code: DiagnosticCode,
    range: Range,
    relatedRange: Range,
    arg0: string | null = null,
    arg1: string | null = null,
    arg2: string | null = null
  ): void {
    this.emitDiagnostic(code, DiagnosticCategory.INFO, range, relatedRange, arg0, arg1, arg2);
  }

  /** Emits a warning diagnostic message. */
  warning(
    code: DiagnosticCode,
    range: Range | null,
    arg0: string | null = null,
    arg1: string | null = null,
    arg2: string | null = null
  ): void {
    this.emitDiagnostic(code, DiagnosticCategory.WARNING, range, null, arg0, arg1, arg2);
  }

  /** Emits a warning diagnostic message with a related range. */
  warningRelated(
    code: DiagnosticCode,
    range: Range,
    relatedRange: Range,
    arg0: string | null = null,
    arg1: string | null = null,
    arg2: string | null = null
  ): void {
    this.emitDiagnostic(code, DiagnosticCategory.WARNING, range, relatedRange, arg0, arg1, arg2);
  }

  /** Emits an error diagnostic message. */
  error(
    code: DiagnosticCode,
    range: Range | null,
    arg0: string | null = null,
    arg1: string | null = null,
    arg2: string | null = null
  ): void {
    this.emitDiagnostic(code, DiagnosticCategory.ERROR, range, null, arg0, arg1, arg2);
  }

  /** Emits an error diagnostic message with a related range. */
  errorRelated(
    code: DiagnosticCode,
    range: Range,
    relatedRange: Range,
    arg0: string | null = null,
    arg1: string | null = null,
    arg2: string | null = null
  ): void {
    this.emitDiagnostic(code, DiagnosticCategory.ERROR, range, relatedRange, arg0, arg1, arg2);
  }
}

'''
'''--- src/extra/README.md ---
Extra components that are not ultimately required in a standalone compiler.

'''
'''--- src/extra/ast.ts ---
/**
 * @fileoverview Abstract Syntax Tree extras.
 *
 * Provides serialization of the AssemblyScript AST back to it source form.
 *
 * @license Apache-2.0
 */

import {
  Node,
  NodeKind,
  Source,
  ArrowKind,

  TypeNode,
  NamedTypeNode,
  FunctionTypeNode,
  TypeName,
  TypeParameterNode,

  Expression,
  IdentifierExpression,
  LiteralExpression,
  LiteralKind,
  FloatLiteralExpression,
  IntegerLiteralExpression,
  StringLiteralExpression,
  TemplateLiteralExpression,
  RegexpLiteralExpression,
  ArrayLiteralExpression,
  AssertionExpression,
  AssertionKind,
  BinaryExpression,
  CallExpression,
  CommaExpression,
  ElementAccessExpression,
  FunctionExpression,
  NewExpression,
  ParenthesizedExpression,
  PropertyAccessExpression,
  TernaryExpression,
  UnaryPostfixExpression,
  UnaryExpression,
  UnaryPrefixExpression,
  ClassExpression,
  ObjectLiteralExpression,

  BlockStatement,
  BreakStatement,
  ContinueStatement,
  DoStatement,
  EmptyStatement,
  ExportImportStatement,
  ExportStatement,
  ExportDefaultStatement,
  ExpressionStatement,
  ForStatement,
  ForOfStatement,
  IfStatement,
  ImportStatement,
  InstanceOfExpression,
  ReturnStatement,
  SwitchStatement,
  ThrowStatement,
  TryStatement,
  VariableStatement,
  WhileStatement,

  DeclarationStatement,
  ClassDeclaration,
  EnumDeclaration,
  EnumValueDeclaration,
  FieldDeclaration,
  FunctionDeclaration,
  ImportDeclaration,
  InterfaceDeclaration,
  MethodDeclaration,
  NamespaceDeclaration,
  TypeDeclaration,
  VariableDeclaration,

  DecoratorNode,
  ParameterNode,
  ParameterKind,
  ExportMember,
  SwitchCase,
  IndexSignatureNode,

  isTypeOmitted
} from "../ast";

import {
  operatorTokenToString
} from "../tokenizer";

import {
  CharCode,
  indent
} from "../util";

import {
  CommonFlags
} from "../common";

/** An AST builder. */
export class ASTBuilder {

  /** Rebuilds the textual source from the specified AST, as far as possible. */
  static build(node: Node): string {
    var builder = new ASTBuilder();
    builder.visitNode(node);
    return builder.finish();
  }

  private sb: string[] = [];
  private indentLevel: i32 = 0;

  visitNode(node: Node): void {
    switch (node.kind) {
      case NodeKind.SOURCE: {
        this.visitSource(<Source>node);
        break;
      }

      // types

      case NodeKind.NAMEDTYPE: {
        this.visitNamedTypeNode(<NamedTypeNode>node);
        break;
      }
      case NodeKind.FUNCTIONTYPE: {
        this.visitFunctionTypeNode(<FunctionTypeNode>node);
        break;
      }
      case NodeKind.TYPEPARAMETER: {
        this.visitTypeParameter(<TypeParameterNode>node);
        break;
      }

      // expressions

      case NodeKind.FALSE:
      case NodeKind.NULL:
      case NodeKind.SUPER:
      case NodeKind.THIS:
      case NodeKind.TRUE:
      case NodeKind.CONSTRUCTOR:
      case NodeKind.IDENTIFIER: {
        this.visitIdentifierExpression(<IdentifierExpression>node);
        break;
      }
      case NodeKind.ASSERTION: {
        this.visitAssertionExpression(<AssertionExpression>node);
        break;
      }
      case NodeKind.BINARY: {
        this.visitBinaryExpression(<BinaryExpression>node);
        break;
      }
      case NodeKind.CALL: {
        this.visitCallExpression(<CallExpression>node);
        break;
      }
      case NodeKind.CLASS: {
        this.visitClassExpression(<ClassExpression>node);
        break;
      }
      case NodeKind.COMMA: {
        this.visitCommaExpression(<CommaExpression>node);
        break;
      }
      case NodeKind.ELEMENTACCESS: {
        this.visitElementAccessExpression(<ElementAccessExpression>node);
        break;
      }
      case NodeKind.FUNCTION: {
        this.visitFunctionExpression(<FunctionExpression>node);
        break;
      }
      case NodeKind.INSTANCEOF: {
        this.visitInstanceOfExpression(<InstanceOfExpression>node);
        break;
      }
      case NodeKind.LITERAL: {
        this.visitLiteralExpression(<LiteralExpression>node);
        break;
      }
      case NodeKind.NEW: {
        this.visitNewExpression(<NewExpression>node);
        break;
      }
      case NodeKind.PARENTHESIZED: {
        this.visitParenthesizedExpression(<ParenthesizedExpression>node);
        break;
      }
      case NodeKind.PROPERTYACCESS: {
        this.visitPropertyAccessExpression(<PropertyAccessExpression>node);
        break;
      }
      case NodeKind.TERNARY: {
        this.visitTernaryExpression(<TernaryExpression>node);
        break;
      }
      case NodeKind.UNARYPOSTFIX: {
        this.visitUnaryPostfixExpression(<UnaryPostfixExpression>node);
        break;
      }
      case NodeKind.UNARYPREFIX: {
        this.visitUnaryPrefixExpression(<UnaryPrefixExpression>node);
        break;
      }

      // statements

      case NodeKind.BLOCK: {
        this.visitBlockStatement(<BlockStatement>node);
        break;
      }
      case NodeKind.BREAK: {
        this.visitBreakStatement(<BreakStatement>node);
        break;
      }
      case NodeKind.CONTINUE: {
        this.visitContinueStatement(<ContinueStatement>node);
        break;
      }
      case NodeKind.DO: {
        this.visitDoStatement(<DoStatement>node);
        break;
      }
      case NodeKind.EMPTY: {
        this.visitEmptyStatement(<EmptyStatement>node);
        break;
      }
      case NodeKind.EXPORT: {
        this.visitExportStatement(<ExportStatement>node);
        break;
      }
      case NodeKind.EXPORTDEFAULT: {
        this.visitExportDefaultStatement(<ExportDefaultStatement>node);
        break;
      }
      case NodeKind.EXPORTIMPORT: {
        this.visitExportImportStatement(<ExportImportStatement>node);
        break;
      }
      case NodeKind.EXPRESSION: {
        this.visitExpressionStatement(<ExpressionStatement>node);
        break;
      }
      case NodeKind.FOR: {
        this.visitForStatement(<ForStatement>node);
        break;
      }
      case NodeKind.FOROF: {
        this.visitForOfStatement(<ForOfStatement>node);
        break;
      }
      case NodeKind.IF: {
        this.visitIfStatement(<IfStatement>node);
        break;
      }
      case NodeKind.IMPORT: {
        this.visitImportStatement(<ImportStatement>node);
        break;
      }
      case NodeKind.RETURN: {
        this.visitReturnStatement(<ReturnStatement>node);
        break;
      }
      case NodeKind.SWITCH: {
        this.visitSwitchStatement(<SwitchStatement>node);
        break;
      }
      case NodeKind.THROW: {
        this.visitThrowStatement(<ThrowStatement>node);
        break;
      }
      case NodeKind.TRY: {
        this.visitTryStatement(<TryStatement>node);
        break;
      }
      case NodeKind.VARIABLE: {
        this.visitVariableStatement(<VariableStatement>node);
        break;
      }
      case NodeKind.WHILE: {
        this.visitWhileStatement(<WhileStatement>node);
        break;
      }

      // declaration statements

      case NodeKind.CLASSDECLARATION: {
        this.visitClassDeclaration(<ClassDeclaration>node);
        break;
      }
      case NodeKind.ENUMDECLARATION: {
        this.visitEnumDeclaration(<EnumDeclaration>node);
        break;
      }
      case NodeKind.ENUMVALUEDECLARATION: {
        this.visitEnumValueDeclaration(<EnumValueDeclaration>node);
        break;
      }
      case NodeKind.FIELDDECLARATION: {
        this.visitFieldDeclaration(<FieldDeclaration>node);
        break;
      }
      case NodeKind.FUNCTIONDECLARATION: {
        this.visitFunctionDeclaration(<FunctionDeclaration>node);
        break;
      }
      case NodeKind.IMPORTDECLARATION: {
        this.visitImportDeclaration(<ImportDeclaration>node);
        break;
      }
      case NodeKind.INTERFACEDECLARATION: {
        this.visitInterfaceDeclaration(<InterfaceDeclaration>node);
        break;
      }
      case NodeKind.METHODDECLARATION: {
        this.visitMethodDeclaration(<MethodDeclaration>node);
        break;
      }
      case NodeKind.NAMESPACEDECLARATION: {
        this.visitNamespaceDeclaration(<NamespaceDeclaration>node);
        break;
      }
      case NodeKind.TYPEDECLARATION: {
        this.visitTypeDeclaration(<TypeDeclaration>node);
        break;
      }
      case NodeKind.VARIABLEDECLARATION: {
        this.visitVariableDeclaration(<VariableDeclaration>node);
        break;
      }

      // other

      case NodeKind.DECORATOR: {
        this.serializeDecorator(<DecoratorNode>node);
        break;
      }
      case NodeKind.EXPORTMEMBER: {
        this.visitExportMember(<ExportMember>node);
        break;
      }
      case NodeKind.PARAMETER: {
        this.serializeParameter(<ParameterNode>node);
        break;
      }
      case NodeKind.SWITCHCASE: {
        this.visitSwitchCase(<SwitchCase>node);
        break;
      }
      case NodeKind.INDEXSIGNATURE: {
        this.visitIndexSignature(<IndexSignatureNode>node);
        break;
      }
      default: assert(false);
    }
  }

  visitSource(source: Source): void {
    var statements = source.statements;
    for (let i = 0, k = statements.length; i < k; ++i) {
      this.visitNodeAndTerminate(statements[i]);
    }
  }

  // types

  visitTypeNode(node: TypeNode): void {
    switch (node.kind) {
      case NodeKind.NAMEDTYPE: {
        this.visitNamedTypeNode(<NamedTypeNode>node);
        break;
      }
      case NodeKind.FUNCTIONTYPE: {
        this.visitFunctionTypeNode(<FunctionTypeNode>node);
        break;
      }
      default: assert(false);
    }
  }

  visitTypeName(node: TypeName): void {
    this.visitIdentifierExpression(node.identifier);
    var sb = this.sb;
    var current = node.next;
    while (current) {
      sb.push(".");
      this.visitIdentifierExpression(current.identifier);
      current = current.next;
    }
  }

  visitNamedTypeNode(node: NamedTypeNode): void {
    this.visitTypeName(node.name);
    var typeArguments = node.typeArguments;
    if (typeArguments) {
      let numTypeArguments = typeArguments.length;
      let sb = this.sb;
      if (numTypeArguments) {
        sb.push("<");
        this.visitTypeNode(typeArguments[0]);
        for (let i = 1; i < numTypeArguments; ++i) {
          sb.push(", ");
          this.visitTypeNode(typeArguments[i]);
        }
        sb.push(">");
      }
      if (node.isNullable) sb.push(" | null");
    }
  }

  visitFunctionTypeNode(node: FunctionTypeNode): void {
    var isNullable = node.isNullable;
    var sb = this.sb;
    sb.push(isNullable ? "((" : "(");
    var explicitThisType = node.explicitThisType;
    if (explicitThisType) {
      sb.push("this: ");
      this.visitTypeNode(explicitThisType);
    }
    var parameters = node.parameters;
    var numParameters = parameters.length;
    if (numParameters) {
      if (explicitThisType) sb.push(", ");
      this.serializeParameter(parameters[0]);
      for (let i = 1; i < numParameters; ++i) {
        sb.push(", ");
        this.serializeParameter(parameters[i]);
      }
    }
    var returnType = node.returnType;
    if (returnType) {
      sb.push(") => ");
      this.visitTypeNode(returnType);
    } else {
      sb.push(") => void");
    }
    if (isNullable) sb.push(") | null");
  }

  visitTypeParameter(node: TypeParameterNode): void {
    this.visitIdentifierExpression(node.name);
    var extendsType = node.extendsType;
    if (extendsType) {
      this.sb.push(" extends ");
      this.visitTypeNode(extendsType);
    }
    var defaultType = node.defaultType;
    if (defaultType) {
      this.sb.push("=");
      this.visitTypeNode(defaultType);
    }
  }

  // expressions

  visitIdentifierExpression(node: IdentifierExpression): void {
    if (node.isQuoted) this.visitStringLiteral(node.text);
    else this.sb.push(node.text);
  }

  visitArrayLiteralExpression(node: ArrayLiteralExpression): void {
    var sb = this.sb;
    sb.push("[");
    var elements = node.elementExpressions;
    var numElements = elements.length;
    if (numElements) {
      let element = elements[0];
      if (element) this.visitNode(element);
      for (let i = 1; i < numElements; ++i) {
        element = elements[i];
        sb.push(", ");
        if (element) this.visitNode(element);
      }
    }
    sb.push("]");
  }

  visitObjectLiteralExpression(node: ObjectLiteralExpression): void {
    var sb = this.sb;
    var names = node.names;
    var values = node.values;
    var numElements = names.length;
    assert(numElements == values.length);
    if (numElements) {
      sb.push("{\n");
      indent(sb, ++this.indentLevel);
      this.visitNode(names[0]);
      sb.push(": ");
      this.visitNode(values[0]);
      for (let i = 1; i < numElements; ++i) {
        sb.push(",\n");
        indent(sb, this.indentLevel);
        let name = names[i];
        let value = values[i];
        if (name === value) {
          this.visitNode(name);
        } else {
          this.visitNode(name);
          sb.push(": ");
          this.visitNode(value);
        }
      }
      sb.push("\n");
      indent(sb, --this.indentLevel);
      sb.push("}");
    } else {
      sb.push("{}");
    }
  }

  visitAssertionExpression(node: AssertionExpression): void {
    var sb = this.sb;
    switch (node.assertionKind) {
      case AssertionKind.PREFIX: {
        sb.push("<");
        this.visitTypeNode(assert(node.toType));
        sb.push(">");
        this.visitNode(node.expression);
        break;
      }
      case AssertionKind.AS: {
        this.visitNode(node.expression);
        sb.push(" as ");
        this.visitTypeNode(assert(node.toType));
        break;
      }
      case AssertionKind.NONNULL: {
        this.visitNode(node.expression);
        sb.push("!");
        break;
      }
      case AssertionKind.CONST: {
        this.visitNode(node.expression);
        sb.push(" as const");
        break;
      }
      default: assert(false);
    }
  }

  visitBinaryExpression(node: BinaryExpression): void {
    var sb = this.sb;
    this.visitNode(node.left);
    sb.push(" ");
    sb.push(operatorTokenToString(node.operator));
    sb.push(" ");
    this.visitNode(node.right);
  }

  visitCallExpression(node: CallExpression): void {
    this.visitNode(node.expression);
    this.visitArguments(node.typeArguments, node.args);
  }

  private visitArguments(typeArguments: TypeNode[] | null, args: Expression[]): void {
    var sb = this.sb;
    if (typeArguments) {
      let numTypeArguments = typeArguments.length;
      if (numTypeArguments) {
        sb.push("<");
        this.visitTypeNode(typeArguments[0]);
        for (let i = 1; i < numTypeArguments; ++i) {
          sb.push(", ");
          this.visitTypeNode(typeArguments[i]);
        }
        sb.push(">(");
      }
    } else {
      sb.push("(");
    }
    var numArgs = args.length;
    if (numArgs) {
      this.visitNode(args[0]);
      for (let i = 1; i < numArgs; ++i) {
        sb.push(", ");
        this.visitNode(args[i]);
      }
    }
    sb.push(")");
  }

  visitClassExpression(node: ClassExpression): void {
    var declaration = node.declaration;
    this.visitClassDeclaration(declaration);
  }

  visitCommaExpression(node: CommaExpression): void {
    var expressions = node.expressions;
    var numExpressions = assert(expressions.length);
    this.visitNode(expressions[0]);
    var sb = this.sb;
    for (let i = 1; i < numExpressions; ++i) {
      sb.push(",");
      this.visitNode(expressions[i]);
    }
  }

  visitElementAccessExpression(node: ElementAccessExpression): void {
    var sb = this.sb;
    this.visitNode(node.expression);
    sb.push("[");
    this.visitNode(node.elementExpression);
    sb.push("]");
  }

  visitFunctionExpression(node: FunctionExpression): void {
    var declaration = node.declaration;
    if (!declaration.arrowKind) {
      if (declaration.name.text.length) {
        this.sb.push("function ");
      } else {
        this.sb.push("function");
      }
    } else {
      assert(declaration.name.text.length == 0);
    }
    this.visitFunctionCommon(declaration);
  }

  visitLiteralExpression(node: LiteralExpression): void {
    switch (node.literalKind) {
      case LiteralKind.FLOAT: {
        this.visitFloatLiteralExpression(<FloatLiteralExpression>node);
        break;
      }
      case LiteralKind.INTEGER: {
        this.visitIntegerLiteralExpression(<IntegerLiteralExpression>node);
        break;
      }
      case LiteralKind.STRING: {
        this.visitStringLiteralExpression(<StringLiteralExpression>node);
        break;
      }
      case LiteralKind.TEMPLATE: {
        this.visitTemplateLiteralExpression(<TemplateLiteralExpression>node);
        break;
      }
      case LiteralKind.REGEXP: {
        this.visitRegexpLiteralExpression(<RegexpLiteralExpression>node);
        break;
      }
      case LiteralKind.ARRAY: {
        this.visitArrayLiteralExpression(<ArrayLiteralExpression>node);
        break;
      }
      case LiteralKind.OBJECT: {
        this.visitObjectLiteralExpression(<ObjectLiteralExpression>node);
        break;
      }
      default: {
        assert(false);
        break;
      }
    }
  }

  visitFloatLiteralExpression(node: FloatLiteralExpression): void {
    this.sb.push(node.value.toString());
  }

  visitInstanceOfExpression(node: InstanceOfExpression): void {
    this.visitNode(node.expression);
    this.sb.push(" instanceof ");
    this.visitTypeNode(node.isType);
  }

  visitIntegerLiteralExpression(node: IntegerLiteralExpression): void {
    this.sb.push(i64_to_string(node.value));
  }

  visitStringLiteral(str: string): void {
    var sb = this.sb;
    sb.push("\"");
    this.visitRawString(str, CharCode.DOUBLEQUOTE);
    sb.push("\"");
  }

  private visitRawString(str: string, quote: CharCode): void {
    var sb = this.sb;
    var off = 0;
    var i = 0;
    for (let k = str.length; i < k;) {
      switch (str.charCodeAt(i)) {
        case CharCode.NULL: {
          if (i > off) sb.push(str.substring(off, off = i + 1));
          sb.push("\\0");
          off = ++i;
          break;
        }
        case CharCode.BACKSPACE: {
          if (i > off) sb.push(str.substring(off, i));
          off = ++i;
          sb.push("\\b");
          break;
        }
        case CharCode.TAB: {
          if (i > off) sb.push(str.substring(off, i));
          off = ++i;
          sb.push("\\t");
          break;
        }
        case CharCode.LINEFEED: {
          if (i > off) sb.push(str.substring(off, i));
          off = ++i;
          sb.push("\\n");
          break;
        }
        case CharCode.VERTICALTAB: {
          if (i > off) sb.push(str.substring(off, i));
          off = ++i;
          sb.push("\\v");
          break;
        }
        case CharCode.FORMFEED: {
          if (i > off) sb.push(str.substring(off, i));
          off = ++i;
          sb.push("\\f");
          break;
        }
        case CharCode.CARRIAGERETURN: {
          if (i > off) sb.push(str.substring(off, i));
          sb.push("\\r");
          off = ++i;
          break;
        }
        case CharCode.DOUBLEQUOTE: {
          if (quote == CharCode.DOUBLEQUOTE) {
            if (i > off) sb.push(str.substring(off, i));
            sb.push("\\\"");
            off = ++i;
          } else {
            ++i;
          }
          break;
        }
        case CharCode.SINGLEQUOTE: {
          if (quote == CharCode.SINGLEQUOTE) {
            if (i > off) sb.push(str.substring(off, i));
            sb.push("\\'");
            off = ++i;
          } else {
            ++i;
          }
          break;
        }
        case CharCode.BACKSLASH: {
          if (i > off) sb.push(str.substring(off, i));
          sb.push("\\\\");
          off = ++i;
          break;
        }
        case CharCode.BACKTICK: {
          if (quote == CharCode.BACKTICK) {
            if (i > off) sb.push(str.substring(off, i));
            sb.push("\\`");
            off = ++i;
          } else {
            ++i;
          }
          break;
        }
        default: {
          ++i;
          break;
        }
      }
    }
    if (i > off) sb.push(str.substring(off, i));
  }

  visitStringLiteralExpression(node: StringLiteralExpression): void {
    this.visitStringLiteral(node.value);
  }

  visitTemplateLiteralExpression(node: TemplateLiteralExpression): void {
    var sb = this.sb;
    var tag = node.tag;
    var parts = node.parts;
    var expressions = node.expressions;
    if (tag) this.visitNode(tag);
    sb.push("`");
    this.visitRawString(parts[0], CharCode.BACKTICK);
    assert(parts.length == expressions.length + 1);
    for (let i = 0, k = expressions.length; i < k; ++i) {
      sb.push("${");
      this.visitNode(expressions[i]);
      sb.push("}");
      this.visitRawString(parts[i + 1], CharCode.BACKTICK);
    }
    sb.push("`");
  }

  visitRegexpLiteralExpression(node: RegexpLiteralExpression): void {
    var sb = this.sb;
    sb.push("/");
    sb.push(node.pattern);
    sb.push("/");
    sb.push(node.patternFlags);
  }

  visitNewExpression(node: NewExpression): void {
    this.sb.push("new ");
    this.visitTypeName(node.typeName);
    this.visitArguments(node.typeArguments, node.args);
  }

  visitParenthesizedExpression(node: ParenthesizedExpression): void {
    var sb = this.sb;
    sb.push("(");
    this.visitNode(node.expression);
    sb.push(")");
  }

  visitPropertyAccessExpression(node: PropertyAccessExpression): void {
    this.visitNode(node.expression);
    this.sb.push(".");
    this.visitIdentifierExpression(node.property);
  }

  visitTernaryExpression(node: TernaryExpression): void {
    var sb = this.sb;
    this.visitNode(node.condition);
    sb.push(" ? ");
    this.visitNode(node.ifThen);
    sb.push(" : ");
    this.visitNode(node.ifElse);
  }

  visitUnaryExpression(node: UnaryExpression): void {
    switch (node.kind) {
      case NodeKind.UNARYPOSTFIX: {
        this.visitUnaryPostfixExpression(<UnaryPostfixExpression>node);
        break;
      }
      case NodeKind.UNARYPREFIX: {
        this.visitUnaryPrefixExpression(<UnaryPrefixExpression>node);
        break;
      }
      default: assert(false);
    }
  }

  visitUnaryPostfixExpression(node: UnaryPostfixExpression): void {
    this.visitNode(node.operand);
    this.sb.push(operatorTokenToString(node.operator));
  }

  visitUnaryPrefixExpression(node: UnaryPrefixExpression): void {
    this.sb.push(operatorTokenToString(node.operator));
    this.visitNode(node.operand);
  }

  // statements

  visitNodeAndTerminate(node: Node): void {
    this.visitNode(node);
    var sb = this.sb;
    if (
      !sb.length ||                     // leading EmptyStatement
      node.kind == NodeKind.VARIABLE || // potentially assigns a FunctionExpression
      node.kind == NodeKind.EXPRESSION  // potentially assigns a FunctionExpression
    ) {
      sb.push(";\n");
    } else {
      let last = sb[sb.length - 1];
      let lastCharPos = last.length - 1;
      if (lastCharPos >= 0 && (
        last.charCodeAt(lastCharPos) == CharCode.CLOSEBRACE ||
        last.charCodeAt(lastCharPos) == CharCode.SEMICOLON)
      ) {
        sb.push("\n");
      } else {
        sb.push(";\n");
      }
    }
  }

  visitBlockStatement(node: BlockStatement): void {
    var sb = this.sb;
    var statements = node.statements;
    var numStatements = statements.length;
    if (numStatements) {
      sb.push("{\n");
      let indentLevel = ++this.indentLevel;
      for (let i = 0; i < numStatements; ++i) {
        indent(sb, indentLevel);
        this.visitNodeAndTerminate(statements[i]);
      }
      indent(sb, --this.indentLevel);
      sb.push("}");
    } else {
      sb.push("{}");
    }
  }

  visitBreakStatement(node: BreakStatement): void {
    var label = node.label;
    if (label) {
      this.sb.push("break ");
      this.visitIdentifierExpression(label);
    } else {
      this.sb.push("break");
    }
  }

  visitContinueStatement(node: ContinueStatement): void {
    var label = node.label;
    if (label) {
      this.sb.push("continue ");
      this.visitIdentifierExpression(label);
    } else {
      this.sb.push("continue");
    }
  }

  visitClassDeclaration(node: ClassDeclaration, isDefault: bool = false): void {
    var decorators = node.decorators;
    if (decorators) {
      for (let i = 0, k = decorators.length; i < k; ++i) {
        this.serializeDecorator(decorators[i]);
      }
    }
    var sb = this.sb;
    if (isDefault) {
      sb.push("export default ");
    } else {
      this.serializeExternalModifiers(node);
    }
    if (node.is(CommonFlags.ABSTRACT)) sb.push("abstract ");
    if (node.name.text.length) {
      sb.push("class ");
      this.visitIdentifierExpression(node.name);
    } else {
      sb.push("class");
    }
    var typeParameters = node.typeParameters;
    if (typeParameters != null && typeParameters.length > 0) {
      sb.push("<");
      this.visitTypeParameter(typeParameters[0]);
      for (let i = 1, k = typeParameters.length; i < k; ++i) {
        sb.push(", ");
        this.visitTypeParameter(typeParameters[i]);
      }
      sb.push(">");
    }
    var extendsType = node.extendsType;
    if (extendsType) {
      sb.push(" extends ");
      this.visitTypeNode(extendsType);
    }
    var implementsTypes = node.implementsTypes;
    if (implementsTypes) {
      let numImplementsTypes = implementsTypes.length;
      if (numImplementsTypes) {
        sb.push(" implements ");
        this.visitTypeNode(implementsTypes[0]);
        for (let i = 1; i < numImplementsTypes; ++i) {
          sb.push(", ");
          this.visitTypeNode(implementsTypes[i]);
        }
      }
    }
    var indexSignature = node.indexSignature;
    var members = node.members;
    var numMembers = members.length;
    if (indexSignature !== null || numMembers) {
      sb.push(" {\n");
      let indentLevel = ++this.indentLevel;
      if (indexSignature) {
        indent(sb, indentLevel);
        this.visitNodeAndTerminate(indexSignature);
      }
      for (let i = 0, k = members.length; i < k; ++i) {
        let member = members[i];
        if (member.kind != NodeKind.FIELDDECLARATION || (<FieldDeclaration>member).parameterIndex < 0) {
          indent(sb, indentLevel);
          this.visitNodeAndTerminate(member);
        }
      }
      indent(sb, --this.indentLevel);
      sb.push("}");
    } else {
      sb.push(" {}");
    }
  }

  visitDoStatement(node: DoStatement): void {
    var sb = this.sb;
    sb.push("do ");
    this.visitNode(node.statement);
    if (node.statement.kind == NodeKind.BLOCK) {
      sb.push(" while (");
    } else {
      sb.push(";\n");
      indent(sb, this.indentLevel);
      sb.push("while (");
    }
    this.visitNode(node.condition);
    sb.push(")");
  }

  visitEmptyStatement(node: EmptyStatement): void {
    /* nop */
  }

  visitEnumDeclaration(node: EnumDeclaration, isDefault: bool = false): void {
    var sb = this.sb;
    if (isDefault) {
      sb.push("export default ");
    } else {
      this.serializeExternalModifiers(node);
    }
    if (node.is(CommonFlags.CONST)) sb.push("const ");
    sb.push("enum ");
    this.visitIdentifierExpression(node.name);
    var values = node.values;
    var numValues = values.length;
    if (numValues) {
      sb.push(" {\n");
      let indentLevel = ++this.indentLevel;
      indent(sb, indentLevel);
      this.visitEnumValueDeclaration(node.values[0]);
      for (let i = 1; i < numValues; ++i) {
        sb.push(",\n");
        indent(sb, indentLevel);
        this.visitEnumValueDeclaration(node.values[i]);
      }
      sb.push("\n");
      indent(sb, --this.indentLevel);
      sb.push("}");
    } else {
      sb.push(" {}");
    }
  }

  visitEnumValueDeclaration(node: EnumValueDeclaration): void {
    this.visitIdentifierExpression(node.name);
    var initializer = node.initializer;
    if (initializer) {
      this.sb.push(" = ");
      this.visitNode(initializer);
    }
  }

  visitExportImportStatement(node: ExportImportStatement): void {
    var sb = this.sb;
    sb.push("export import ");
    this.visitIdentifierExpression(node.externalName);
    sb.push(" = ");
    this.visitIdentifierExpression(node.name);
  }

  visitExportMember(node: ExportMember): void {
    this.visitIdentifierExpression(node.localName);
    if (node.exportedName.text != node.localName.text) {
      this.sb.push(" as ");
      this.visitIdentifierExpression(node.exportedName);
    }
  }

  visitExportStatement(node: ExportStatement): void {
    var sb = this.sb;
    if (node.isDeclare) {
      sb.push("declare ");
    }
    var members = node.members;
    if (members == null) {
      sb.push("export *");
    } else if (members.length > 0) {
      let numMembers = members.length;
      sb.push("export {\n");
      let indentLevel = ++this.indentLevel;
      indent(sb, indentLevel);
      this.visitExportMember(members[0]);
      for (let i = 1; i < numMembers; ++i) {
        sb.push(",\n");
        indent(sb, indentLevel);
        this.visitExportMember(members[i]);
      }
      --this.indentLevel;
      sb.push("\n}");
    } else {
      sb.push("export {}");
    }
    var path = node.path;
    if (path) {
      sb.push(" from ");
      this.visitStringLiteralExpression(path);
    }
    sb.push(";");
  }

  visitExportDefaultStatement(node: ExportDefaultStatement): void {
    var declaration = node.declaration;
    switch (declaration.kind) {
      case NodeKind.ENUMDECLARATION: {
        this.visitEnumDeclaration(<EnumDeclaration>declaration, true);
        break;
      }
      case NodeKind.FUNCTIONDECLARATION: {
        this.visitFunctionDeclaration(<FunctionDeclaration>declaration, true);
        break;
      }
      case NodeKind.CLASSDECLARATION: {
        this.visitClassDeclaration(<ClassDeclaration>declaration, true);
        break;
      }
      case NodeKind.INTERFACEDECLARATION: {
        this.visitInterfaceDeclaration(<InterfaceDeclaration>declaration, true);
        break;
      }
      case NodeKind.NAMESPACEDECLARATION: {
        this.visitNamespaceDeclaration(<NamespaceDeclaration>declaration, true);
        break;
      }
      default: assert(false);
    }
  }

  visitExpressionStatement(node: ExpressionStatement): void {
    this.visitNode(node.expression);
  }

  visitFieldDeclaration(node: FieldDeclaration): void {
    var decorators = node.decorators;
    if (decorators) {
      for (let i = 0, k = decorators.length; i < k; ++i) {
        this.serializeDecorator(decorators[i]);
      }
    }
    this.serializeAccessModifiers(node);
    this.visitIdentifierExpression(node.name);
    var sb = this.sb;
    if (node.flags & CommonFlags.DEFINITELY_ASSIGNED) {
      sb.push("!");
    }
    var type = node.type;
    if (type) {
      sb.push(": ");
      this.visitTypeNode(type);
    }
    var initializer = node.initializer;
    if (initializer) {
      sb.push(" = ");
      this.visitNode(initializer);
    }
  }

  visitForStatement(node: ForStatement): void {
    var sb = this.sb;
    sb.push("for (");
    var initializer = node.initializer;
    if (initializer) {
      this.visitNode(initializer);
    }
    var condition = node.condition;
    if (condition) {
      sb.push("; ");
      this.visitNode(condition);
    } else {
      sb.push(";");
    }
    var incrementor = node.incrementor;
    if (incrementor) {
      sb.push("; ");
      this.visitNode(incrementor);
    } else {
      sb.push(";");
    }
    sb.push(") ");
    this.visitNode(node.statement);
  }

  visitForOfStatement(node: ForOfStatement): void {
    var sb = this.sb;
    sb.push("for (");
    this.visitNode(node.variable);
    sb.push(" of ");
    this.visitNode(node.iterable);
    sb.push(") ");
    this.visitNode(node.statement);
  }

  visitFunctionDeclaration(node: FunctionDeclaration, isDefault: bool = false): void {
    var sb = this.sb;
    var decorators = node.decorators;
    if (decorators) {
      for (let i = 0, k = decorators.length; i < k; ++i) {
        this.serializeDecorator(decorators[i]);
      }
    }
    if (isDefault) {
      sb.push("export default ");
    } else {
      this.serializeExternalModifiers(node);
      this.serializeAccessModifiers(node);
    }
    if (node.name.text.length) {
      sb.push("function ");
    } else {
      sb.push("function");
    }
    this.visitFunctionCommon(node);
  }

  visitFunctionCommon(node: FunctionDeclaration): void {
    var sb = this.sb;
    this.visitIdentifierExpression(node.name);
    var signature = node.signature;
    var typeParameters = node.typeParameters;
    if (typeParameters) {
      let numTypeParameters = typeParameters.length;
      if (numTypeParameters) {
        sb.push("<");
        this.visitTypeParameter(typeParameters[0]);
        for (let i = 1; i < numTypeParameters; ++i) {
          sb.push(", ");
          this.visitTypeParameter(typeParameters[i]);
        }
        sb.push(">");
      }
    }
    if (node.arrowKind == ArrowKind.ARROW_SINGLE) {
      let parameters = signature.parameters;
      assert(parameters.length == 1);
      assert(!signature.explicitThisType);
      this.serializeParameter(parameters[0]);
    } else {
      sb.push("(");
      let parameters = signature.parameters;
      let numParameters = parameters.length;
      let explicitThisType = signature.explicitThisType;
      if (explicitThisType) {
        sb.push("this: ");
        this.visitTypeNode(explicitThisType);
      }
      if (numParameters) {
        if (explicitThisType) sb.push(", ");
        this.serializeParameter(parameters[0]);
        for (let i = 1; i < numParameters; ++i) {
          sb.push(", ");
          this.serializeParameter(parameters[i]);
        }
      }
    }
    var body = node.body;
    var returnType = signature.returnType;
    if (node.arrowKind) {
      if (body) {
        if (node.arrowKind == ArrowKind.ARROW_SINGLE) {
          assert(isTypeOmitted(returnType));
        } else {
          if (isTypeOmitted(returnType)) {
            sb.push(")");
          } else {
            sb.push("): ");
            this.visitTypeNode(returnType);
          }
        }
        sb.push(" => ");
        this.visitNode(body);
      } else {
        assert(!isTypeOmitted(returnType));
        sb.push(" => ");
        this.visitTypeNode(returnType);
      }
    } else {
      if (
        !isTypeOmitted(returnType) &&
        !node.isAny(CommonFlags.CONSTRUCTOR | CommonFlags.SET)
      ) {
        sb.push("): ");
        this.visitTypeNode(returnType);
      } else {
        sb.push(")");
      }
      if (body) {
        sb.push(" ");
        this.visitNode(body);
      }
    }
  }

  visitIfStatement(node: IfStatement): void {
    var sb = this.sb;
    sb.push("if (");
    this.visitNode(node.condition);
    sb.push(") ");
    var ifTrue = node.ifTrue;
    this.visitNode(ifTrue);
    if (ifTrue.kind != NodeKind.BLOCK) {
      sb.push(";\n");
    }
    var ifFalse = node.ifFalse;
    if (ifFalse) {
      if (ifTrue.kind == NodeKind.BLOCK) {
        sb.push(" else ");
      } else {
        sb.push("else ");
      }
      this.visitNode(ifFalse);
    }
  }

  visitImportDeclaration(node: ImportDeclaration): void {
    var externalName = node.foreignName;
    var name = node.name;
    this.visitIdentifierExpression(externalName);
    if (externalName.text != name.text) {
      this.sb.push(" as ");
      this.visitIdentifierExpression(name);
    }
  }

  visitImportStatement(node: ImportStatement): void {
    var sb = this.sb;
    sb.push("import ");
    var declarations = node.declarations;
    var namespaceName = node.namespaceName;
    if (declarations) {
      let numDeclarations = declarations.length;
      if (numDeclarations) {
        sb.push("{\n");
        let indentLevel = ++this.indentLevel;
        indent(sb, indentLevel);
        this.visitImportDeclaration(declarations[0]);
        for (let i = 1; i < numDeclarations; ++i) {
          sb.push(",\n");
          indent(sb, indentLevel);
          this.visitImportDeclaration(declarations[i]);
        }
        --this.indentLevel;
        sb.push("\n} from ");
      } else {
        sb.push("{} from ");
      }
    } else if (namespaceName) {
      sb.push("* as ");
      this.visitIdentifierExpression(namespaceName);
      sb.push(" from ");
    }
    this.visitStringLiteralExpression(node.path);
  }

  visitIndexSignature(node: IndexSignatureNode): void {
    var sb = this.sb;
    sb.push("[key: ");
    this.visitTypeNode(node.keyType);
    sb.push("]: ");
    this.visitTypeNode(node.valueType);
  }

  visitInterfaceDeclaration(node: InterfaceDeclaration, isDefault: bool = false): void {
    var decorators = node.decorators;
    if (decorators) {
      for (let i = 0, k = decorators.length; i < k; ++i) {
        this.serializeDecorator(decorators[i]);
      }
    }
    var sb = this.sb;
    if (isDefault) {
      sb.push("export default ");
    } else {
      this.serializeExternalModifiers(node);
    }
    sb.push("interface ");
    this.visitIdentifierExpression(node.name);
    var typeParameters = node.typeParameters;
    if (typeParameters != null && typeParameters.length > 0) {
      sb.push("<");
      this.visitTypeParameter(typeParameters[0]);
      for (let i = 1, k = typeParameters.length; i < k; ++i) {
        sb.push(", ");
        this.visitTypeParameter(typeParameters[i]);
      }
      sb.push(">");
    }
    var extendsType = node.extendsType;
    if (extendsType) {
      sb.push(" extends ");
      this.visitTypeNode(extendsType);
    }
    // must not have implementsTypes
    sb.push(" {\n");
    var indentLevel = ++this.indentLevel;
    var members = node.members;
    for (let i = 0, k = members.length; i < k; ++i) {
      indent(sb, indentLevel);
      this.visitNodeAndTerminate(members[i]);
    }
    --this.indentLevel;
    sb.push("}");
  }

  visitMethodDeclaration(node: MethodDeclaration): void {
    var decorators = node.decorators;
    if (decorators) {
      for (let i = 0, k = decorators.length; i < k; ++i) {
        this.serializeDecorator(decorators[i]);
      }
    }
    this.serializeAccessModifiers(node);
    if (node.is(CommonFlags.GET)) {
      this.sb.push("get ");
    } else if (node.is(CommonFlags.SET)) {
      this.sb.push("set ");
    }
    this.visitFunctionCommon(node);
  }

  visitNamespaceDeclaration(node: NamespaceDeclaration, isDefault: bool = false): void {
    var decorators = node.decorators;
    if (decorators) {
      for (let i = 0, k = decorators.length; i < k; ++i) {
        this.serializeDecorator(decorators[i]);
      }
    }
    var sb = this.sb;
    if (isDefault) {
      sb.push("export default ");
    } else {
      this.serializeExternalModifiers(node);
    }
    sb.push("namespace ");
    this.visitIdentifierExpression(node.name);
    var members = node.members;
    var numMembers = members.length;
    if (numMembers) {
      sb.push(" {\n");
      let indentLevel = ++this.indentLevel;
      for (let i = 0, k = members.length; i < k; ++i) {
        indent(sb, indentLevel);
        this.visitNodeAndTerminate(members[i]);
      }
      indent(sb, --this.indentLevel);
      sb.push("}");
    } else {
      sb.push(" {}");
    }
  }

  visitReturnStatement(node: ReturnStatement): void {
    var value = node.value;
    if (value) {
      this.sb.push("return ");
      this.visitNode(value);
    } else {
      this.sb.push("return");
    }
  }

  visitSwitchCase(node: SwitchCase): void {
    var sb = this.sb;
    var label = node.label;
    if (label) {
      sb.push("case ");
      this.visitNode(label);
      sb.push(":\n");
    } else {
      sb.push("default:\n");
    }
    var statements = node.statements;
    var numStatements = statements.length;
    if (numStatements) {
      let indentLevel = ++this.indentLevel;
      indent(sb, indentLevel);
      this.visitNodeAndTerminate(statements[0]);
      for (let i = 1; i < numStatements; ++i) {
        indent(sb, indentLevel);
        this.visitNodeAndTerminate(statements[i]);
      }
      --this.indentLevel;
    }
  }

  visitSwitchStatement(node: SwitchStatement): void {
    var sb = this.sb;
    sb.push("switch (");
    this.visitNode(node.condition);
    sb.push(") {\n");
    var indentLevel = ++this.indentLevel;
    var cases = node.cases;
    for (let i = 0, k = cases.length; i < k; ++i) {
      indent(sb, indentLevel);
      this.visitSwitchCase(cases[i]);
      sb.push("\n");
    }
    --this.indentLevel;
    sb.push("}");
  }

  visitThrowStatement(node: ThrowStatement): void {
    this.sb.push("throw ");
    this.visitNode(node.value);
  }

  visitTryStatement(node: TryStatement): void {
    var sb = this.sb;
    sb.push("try {\n");
    var indentLevel = ++this.indentLevel;
    var statements = node.statements;
    for (let i = 0, k = statements.length; i < k; ++i) {
      indent(sb, indentLevel);
      this.visitNodeAndTerminate(statements[i]);
    }
    var catchVariable = node.catchVariable;
    if (catchVariable) {
      indent(sb, indentLevel - 1);
      sb.push("} catch (");
      this.visitIdentifierExpression(catchVariable);
      sb.push(") {\n");
      let catchStatements = node.catchStatements;
      if (catchStatements) {
        for (let i = 0, k = catchStatements.length; i < k; ++i) {
          indent(sb, indentLevel);
          this.visitNodeAndTerminate(catchStatements[i]);
        }
      }
    }
    var finallyStatements = node.finallyStatements;
    if (finallyStatements) {
      indent(sb, indentLevel - 1);
      sb.push("} finally {\n");
      for (let i = 0, k = finallyStatements.length; i < k; ++i) {
        indent(sb, indentLevel);
        this.visitNodeAndTerminate(finallyStatements[i]);
      }
    }
    indent(sb, indentLevel - 1);
    sb.push("}");
  }

  visitTypeDeclaration(node: TypeDeclaration): void {
    var decorators = node.decorators;
    if (decorators) {
      for (let i = 0, k = decorators.length; i < k; ++i) {
        this.serializeDecorator(decorators[i]);
      }
    }
    var sb = this.sb;
    this.serializeExternalModifiers(node);
    sb.push("type ");
    this.visitIdentifierExpression(node.name);
    var typeParameters = node.typeParameters;
    if (typeParameters) {
      let numTypeParameters = typeParameters.length;
      if (numTypeParameters) {
        sb.push("<");
        for (let i = 0; i < numTypeParameters; ++i) {
          this.visitTypeParameter(typeParameters[i]);
        }
        sb.push(">");
      }
    }
    sb.push(" = ");
    this.visitTypeNode(node.type);
  }

  visitVariableDeclaration(node: VariableDeclaration): void {
    this.visitIdentifierExpression(node.name);
    var type = node.type;
    var sb = this.sb;
    if (node.flags & CommonFlags.DEFINITELY_ASSIGNED) {
      sb.push("!");
    }
    if (type) {
      sb.push(": ");
      this.visitTypeNode(type);
    }
    var initializer = node.initializer;
    if (initializer) {
      sb.push(" = ");
      this.visitNode(initializer);
    }
  }

  visitVariableStatement(node: VariableStatement): void {
    var decorators = node.decorators;
    if (decorators) {
      for (let i = 0, k = decorators.length; i < k; ++i) {
        this.serializeDecorator(decorators[i]);
      }
    }
    var sb = this.sb;
    var declarations = node.declarations;
    var numDeclarations = assert(declarations.length);
    var firstDeclaration = declarations[0];
    this.serializeExternalModifiers(firstDeclaration);
    sb.push(firstDeclaration.is(CommonFlags.CONST) ? "const " : firstDeclaration.is(CommonFlags.LET) ? "let " : "var ");
    this.visitVariableDeclaration(node.declarations[0]);
    for (let i = 1; i < numDeclarations; ++i) {
      sb.push(", ");
      this.visitVariableDeclaration(node.declarations[i]);
    }
  }

  visitWhileStatement(node: WhileStatement): void {
    var sb = this.sb;
    sb.push("while (");
    this.visitNode(node.condition);
    var statement = node.statement;
    if (statement.kind == NodeKind.EMPTY) {
      sb.push(")");
    } else {
      sb.push(") ");
      this.visitNode(node.statement);
    }
  }

  // other

  serializeDecorator(node: DecoratorNode): void {
    var sb = this.sb;
    sb.push("@");
    this.visitNode(node.name);
    var args = node.args;
    if (args) {
      sb.push("(");
      let numArgs = args.length;
      if (numArgs) {
        this.visitNode(args[0]);
        for (let i = 1; i < numArgs; ++i) {
          sb.push(", ");
          this.visitNode(args[i]);
        }
      }
      sb.push(")\n");
    } else {
      sb.push("\n");
    }
    indent(sb, this.indentLevel);
  }

  serializeParameter(node: ParameterNode): void {
    var sb = this.sb;
    var kind = node.parameterKind;
    var implicitFieldDeclaration = node.implicitFieldDeclaration;
    if (implicitFieldDeclaration) {
      this.serializeAccessModifiers(implicitFieldDeclaration);
    }
    if (kind == ParameterKind.REST) {
      sb.push("...");
    }
    this.visitIdentifierExpression(node.name);
    var type = node.type;
    var initializer = node.initializer;
    if (type) {
      if (kind == ParameterKind.OPTIONAL && !initializer) sb.push("?");
      if (!isTypeOmitted(type)) {
        sb.push(": ");
        this.visitTypeNode(type);
      }
    }
    if (initializer) {
      sb.push(" = ");
      this.visitNode(initializer);
    }
  }

  serializeExternalModifiers(node: DeclarationStatement): void {
    var sb = this.sb;
    if (node.is(CommonFlags.EXPORT)) {
      sb.push("export ");
    } else if (node.is(CommonFlags.IMPORT)) {
      sb.push("import ");
    } else if (node.is(CommonFlags.DECLARE)) {
      sb.push("declare ");
    }
  }

  serializeAccessModifiers(node: DeclarationStatement): void {
    var sb = this.sb;
    if (node.is(CommonFlags.PUBLIC)) {
      sb.push("public ");
    } else if (node.is(CommonFlags.PRIVATE)) {
      sb.push("private ");
    } else if (node.is(CommonFlags.PROTECTED)) {
      sb.push("protected ");
    }
    if (node.is(CommonFlags.STATIC)) {
      sb.push("static ");
    } else if (node.is(CommonFlags.ABSTRACT)) {
      sb.push("abstract ");
    }
    if (node.is(CommonFlags.READONLY)) {
      sb.push("readonly ");
    }
  }

  finish(): string {
    var ret = this.sb.join("");
    this.sb = [];
    return ret;
  }
}

'''
'''--- src/extra/tsconfig.json ---
{
  "extends": "../../std/portable.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- src/flow.ts ---
/**
 * @fileoverview A concurrent code flow analyzer.
 *
 * Flows keep track of compilation state and can be queried for various
 * conditions, like whether the current branch always terminates, whether
 * a local is known to be non-null or whether an expression has possibly
 * overflown its value range.
 *
 * To accomplish this, compilation of each function begins with a clean
 * flow populated with initial local states etc. While compilation
 * progresses, statements and expressions update flow state while control
 * constructs fork, potentially add scoped locals and later merge these
 * forked branches as necessary.
 *
 * @license Apache-2.0
 */

import {
  Type,
  TypeFlags,
  TypeKind
} from "./types";

import {
  Local,
  Function,
  Element,
  ElementKind,
  Global,
  Field,
  Class
} from "./program";

import {
  TypeRef,
  ExpressionId,
  ExpressionRef,
  BinaryOp,
  UnaryOp,

  getExpressionId,
  getLocalGetIndex,
  isLocalTee,
  getLocalSetValue,
  getGlobalGetName,
  getBinaryOp,
  getBinaryLeft,
  getConstValueI32,
  getBinaryRight,
  getUnaryOp,
  getExpressionType,
  getConstValueI64Low,
  getConstValueF32,
  getConstValueF64,
  getLoadBytes,
  isLoadSigned,
  getBlockName,
  getBlockChildCount,
  getBlockChildAt,
  getIfTrue,
  getIfFalse,
  getSelectThen,
  getSelectElse,
  getCallTarget,
  getLocalSetIndex,
  getIfCondition,
  getConstValueI64High,
  getUnaryValue
} from "./module";

import {
  CommonFlags
} from "./common";

import {
  DiagnosticCode
} from "./diagnostics";

import {
  Node
} from "./ast";

import {
  uniqueMap
} from "./util";

/** Control flow flags indicating specific conditions. */
export const enum FlowFlags {
  /** No specific conditions. */
  NONE = 0,

  // categorical

  /** This flow always returns. */
  RETURNS = 1 << 0,
  /** This flow always returns a wrapped value. */
  RETURNS_WRAPPED = 1 << 1,
  /** This flow always returns a non-null value. */
  RETURNS_NONNULL = 1 << 2,
  /** This flow always throws. */
  THROWS = 1 << 3,
  /** This flow always breaks. */
  BREAKS = 1 << 4,
  /** This flow always continues. */
  CONTINUES = 1 << 5,
  /** This flow always accesses `this`. Constructors only. */
  ACCESSES_THIS = 1 << 6,
  /** This flow always calls `super`. Constructors only. */
  CALLS_SUPER = 1 << 7,
  /** This flow always terminates (returns, throws or continues). */
  TERMINATES = 1 << 8, // Note that this doesn't cover BREAKS, which is separate

  // conditional

  /** This flow conditionally returns in a child flow. */
  CONDITIONALLY_RETURNS = 1 << 9,
  /** This flow conditionally throws in a child flow. */
  CONDITIONALLY_THROWS = 1 << 10,
  /** This flow conditionally breaks in a child flow. */
  CONDITIONALLY_BREAKS = 1 << 11,
  /** This flow conditionally continues in a child flow. */
  CONDITIONALLY_CONTINUES = 1 << 12,
  /** This flow conditionally accesses `this` in a child flow. Constructors only. */
  CONDITIONALLY_ACCESSES_THIS = 1 << 13,
  /** This flow may return a non-this value. Constructors only. */
  MAY_RETURN_NONTHIS = 1 << 14,

  // other

  /** This is a flow with explicitly disabled bounds checking. */
  UNCHECKED_CONTEXT = 1 << 15,
  /** This is a flow compiling a constructor parameter. */
  CTORPARAM_CONTEXT = 1 << 16,

  // masks

  /** Any categorical flag. */
  ANY_CATEGORICAL = FlowFlags.RETURNS
                  | FlowFlags.RETURNS_WRAPPED
                  | FlowFlags.RETURNS_NONNULL
                  | FlowFlags.THROWS
                  | FlowFlags.BREAKS
                  | FlowFlags.CONTINUES
                  | FlowFlags.ACCESSES_THIS
                  | FlowFlags.CALLS_SUPER
                  | FlowFlags.TERMINATES,

  /** Any conditional flag. */
  ANY_CONDITIONAL = FlowFlags.CONDITIONALLY_RETURNS
                  | FlowFlags.CONDITIONALLY_THROWS
                  | FlowFlags.CONDITIONALLY_BREAKS
                  | FlowFlags.CONDITIONALLY_CONTINUES
                  | FlowFlags.CONDITIONALLY_ACCESSES_THIS
}

/** Flags indicating the current state of a local. */
export enum LocalFlags {
  /** No specific conditions. */
  NONE = 0,

  /** Local is constant. */
  CONSTANT = 1 << 0,
  /** Local is properly wrapped. Relevant for small integers. */
  WRAPPED = 1 << 1,
  /** Local is non-null. */
  NONNULL = 1 << 2,
  /** Local is initialized. */
  INITIALIZED = 1 << 3
}

/** Flags indicating the current state of a field. */
export enum FieldFlags {
  NONE = 0,
  INITIALIZED = 1 << 0
}

/** Condition kinds. */
export const enum ConditionKind {
  /** Outcome of the condition is unknown */
  UNKNOWN,
  /** Condition is always true. */
  TRUE,
  /** Condition is always false. */
  FALSE
}

/** A control flow evaluator. */
export class Flow {

  /** Creates the parent flow of the specified function. */
  static createParent(parentFunction: Function): Flow {
    var flow = new Flow(parentFunction);
    if (parentFunction.is(CommonFlags.CONSTRUCTOR)) {
      flow.initThisFieldFlags();
    }
    return flow;
  }

  /** Creates an inline flow within `parentFunction`. */
  static createInline(parentFunction: Function, inlineFunction: Function): Flow {
    var flow = new Flow(parentFunction);
    flow.inlineFunction = inlineFunction;
    flow.inlineReturnLabel = inlineFunction.internalName + "|inlined." + (inlineFunction.nextInlineId++).toString();
    if (inlineFunction.is(CommonFlags.CONSTRUCTOR)) {
      flow.initThisFieldFlags();
    }
    return flow;
  }

  private constructor(
    /** Function this flow belongs to. */
    public parentFunction: Function
  ) {
    /* nop */
  }

  /** Parent flow. */
  parent: Flow | null = null;
  /** Outer flow. Only relevant for first-class functions. */
  outer: Flow | null = null;
  /** Flow flags indicating specific conditions. */
  flags: FlowFlags = FlowFlags.NONE;
  /** The label we break to when encountering a continue statement. */
  continueLabel: string | null = null;
  /** The label we break to when encountering a break statement. */
  breakLabel: string | null = null;
  /** Scoped local variables. */
  scopedLocals: Map<string,Local> | null = null;
  /** Local flags. */
  localFlags: LocalFlags[] = [];
  /** Field flags on `this`. Constructors only. */
  thisFieldFlags: Map<Field,FieldFlags> | null = null;
  /** Function being inlined, when inlining. */
  inlineFunction: Function | null = null;
  /** The label we break to when encountering a return statement, when inlining. */
  inlineReturnLabel: string | null = null;

  /** Tests if this is an inline flow. */
  get isInline(): bool {
    return this.inlineFunction !== null;
  }

  /** Gets the actual function being compiled, The inlined function when inlining, otherwise the parent function. */
  get actualFunction(): Function {
    var inlineFunction = this.inlineFunction;
    if (inlineFunction) return inlineFunction;
    return this.parentFunction;
  }

  /** Gets the current return type. */
  get returnType(): Type {
    return this.actualFunction.signature.returnType;
  }

  /** Gets the current contextual type arguments. */
  get contextualTypeArguments(): Map<string,Type> | null {
    return this.actualFunction.contextualTypeArguments;
  }

  /** Tests if this flow has the specified flag or flags. */
  is(flag: FlowFlags): bool { return (this.flags & flag) == flag; }
  /** Tests if this flow has one of the specified flags. */
  isAny(flag: FlowFlags): bool { return (this.flags & flag) != 0; }
  /** Sets the specified flag or flags. */
  set(flag: FlowFlags): void { this.flags |= flag; }
  /** Unsets the specified flag or flags. */
  unset(flag: FlowFlags): void { this.flags &= ~flag; }

  /** Forks this flow to a child flow. */
  fork(resetBreakContext: bool = false): Flow {
    var branch = new Flow(this.parentFunction);
    branch.parent = this;
    branch.outer = this.outer;
    if (resetBreakContext) {
      branch.flags = this.flags & ~(
        FlowFlags.BREAKS |
        FlowFlags.CONDITIONALLY_BREAKS |
        FlowFlags.CONTINUES |
        FlowFlags.CONDITIONALLY_CONTINUES
      );
    } else {
      branch.flags = this.flags;
      branch.continueLabel = this.continueLabel;
      branch.breakLabel = this.breakLabel;
    }
    branch.localFlags = this.localFlags.slice();
    if (this.actualFunction.is(CommonFlags.CONSTRUCTOR)) {
      let thisFieldFlags = assert(this.thisFieldFlags);
      branch.thisFieldFlags = uniqueMap<Field,FieldFlags>(thisFieldFlags);
    } else {
      assert(!this.thisFieldFlags);
    }
    branch.inlineFunction = this.inlineFunction;
    branch.inlineReturnLabel = this.inlineReturnLabel;
    return branch;
  }

  /** Gets a free temporary local of the specified type. */
  getTempLocal(type: Type, except: Set<i32> | null = null): Local {
    var parentFunction = this.parentFunction;
    var temps: Local[] | null;
    switch (<u32>type.toRef()) {
      case <u32>TypeRef.I32: { temps = parentFunction.tempI32s; break; }
      case <u32>TypeRef.I64: { temps = parentFunction.tempI64s; break; }
      case <u32>TypeRef.F32: { temps = parentFunction.tempF32s; break; }
      case <u32>TypeRef.F64: { temps = parentFunction.tempF64s; break; }
      case <u32>TypeRef.V128: { temps = parentFunction.tempV128s; break; }
      case <u32>TypeRef.Funcref: { temps = parentFunction.tempFuncrefs; break; }
      case <u32>TypeRef.Externref: { temps = parentFunction.tempExternrefs; break; }
      case <u32>TypeRef.Anyref: { temps = parentFunction.tempAnyrefs; break; }
      case <u32>TypeRef.Eqref: { temps = parentFunction.tempEqrefs; break; }
      case <u32>TypeRef.I31ref: { temps = parentFunction.tempI31refs; break; }
      case <u32>TypeRef.Dataref: { temps = parentFunction.tempDatarefs; break; }
      default: throw new Error("concrete type expected");
    }
    var local: Local;
    if (except) {
      if (temps !== null && temps.length > 0) {
        for (let i = 0, k = temps.length; i < k; ++i) {
          if (!except.has(temps[i].index)) {
            local = temps[i];
            let k = temps.length - 1;
            while (i < k) unchecked(temps[i] = temps[i++ + 1]);
            temps.length = k;
            local.type = type;
            local.flags = CommonFlags.NONE;
            this.unsetLocalFlag(local.index, ~0);
            return local;
          }
        }
      }
      local = parentFunction.addLocal(type);
    } else {
      if (temps !== null && temps.length > 0) {
        local = assert(temps.pop());
        local.type = type;
        local.flags = CommonFlags.NONE;
      } else {
        local = parentFunction.addLocal(type);
      }
    }
    this.unsetLocalFlag(local.index, ~0);
    return local;
  }

  /** Frees the temporary local for reuse. */
  freeTempLocal(local: Local): void {
    if (local.is(CommonFlags.INLINED)) return;
    assert(local.index >= 0);
    var parentFunction = this.parentFunction;
    var temps: Local[];
    assert(local.type != null); // internal error
    local.resetTemporaryName();
    switch (<u32>local.type.toRef()) {
      case <u32>TypeRef.I32: {
        let tempI32s = parentFunction.tempI32s;
        if (tempI32s) temps = tempI32s;
        else parentFunction.tempI32s = temps = [];
        break;
      }
      case <u32>TypeRef.I64: {
        let tempI64s = parentFunction.tempI64s;
        if (tempI64s) temps = tempI64s;
        else parentFunction.tempI64s = temps = [];
        break;
      }
      case <u32>TypeRef.F32: {
        let tempF32s = parentFunction.tempF32s;
        if (tempF32s) temps = tempF32s;
        else parentFunction.tempF32s = temps = [];
        break;
      }
      case <u32>TypeRef.F64: {
        let tempF64s = parentFunction.tempF64s;
        if (tempF64s) temps = tempF64s;
        else parentFunction.tempF64s = temps = [];
        break;
      }
      case <u32>TypeRef.V128: {
        let tempV128s = parentFunction.tempV128s;
        if (tempV128s) temps = tempV128s;
        else parentFunction.tempV128s = temps = [];
        break;
      }
      case <u32>TypeRef.Funcref: {
        let tempFuncrefs = parentFunction.tempFuncrefs;
        if (tempFuncrefs) temps = tempFuncrefs;
        else parentFunction.tempFuncrefs = temps = [];
        break;
      }
      case <u32>TypeRef.Externref: {
        let tempExternrefs = parentFunction.tempExternrefs;
        if (tempExternrefs) temps = tempExternrefs;
        else parentFunction.tempExternrefs = temps = [];
        break;
      }
      case <u32>TypeRef.Anyref: {
        let tempAnyrefs = parentFunction.tempAnyrefs;
        if (tempAnyrefs) temps = tempAnyrefs;
        else parentFunction.tempAnyrefs = temps = [];
        break;
      }
      case <u32>TypeRef.Eqref: {
        let tempEqrefs = parentFunction.tempEqrefs;
        if (tempEqrefs) temps = tempEqrefs;
        else parentFunction.tempEqrefs = temps = [];
        break;
      }
      case <u32>TypeRef.I31ref: {
        let tempI31refs = parentFunction.tempI31refs;
        if (tempI31refs) temps = tempI31refs;
        else parentFunction.tempI31refs = temps = [];
        break;
      }
      case <u32>TypeRef.Dataref: {
        let tempDatarefs = parentFunction.tempDatarefs;
        if (tempDatarefs) temps = tempDatarefs;
        else parentFunction.tempDatarefs = temps = [];
        break;
      }
      default: throw new Error("concrete type expected");
    }
    assert(local.index >= 0);
    temps.push(local);
  }

  /** Gets the scoped local of the specified name. */
  getScopedLocal(name: string): Local | null {
    var scopedLocals = this.scopedLocals;
    if (scopedLocals !== null && scopedLocals.has(name)) return assert(scopedLocals.get(name));
    return null;
  }

  /** Adds a new scoped local of the specified name. */
  addScopedLocal(name: string, type: Type, except: Set<i32> | null = null): Local {
    var scopedLocal = this.getTempLocal(type, except);
    scopedLocal.setTemporaryName(name);
    var scopedLocals = this.scopedLocals;
    if (!scopedLocals) this.scopedLocals = scopedLocals = new Map();
    else assert(!scopedLocals.has(name));
    scopedLocal.set(CommonFlags.SCOPED);
    scopedLocals.set(name, scopedLocal);
    return scopedLocal;
  }

  /** Adds a new scoped dummy local of the specified name. */
  addScopedDummyLocal(name: string, type: Type, declarationNode: Node): Local {
    var scopedDummy = new Local(name, -1, type, this.parentFunction);
    var scopedLocals = this.scopedLocals;
    if (!scopedLocals) this.scopedLocals = scopedLocals = new Map();
    else if (scopedLocals.has(name)) {
      this.parentFunction.program.error(
        DiagnosticCode.Cannot_redeclare_block_scoped_variable_0,
        declarationNode.range, name
      );
    }
    scopedDummy.set(CommonFlags.SCOPED);
    scopedLocals.set(name, scopedDummy);
    return scopedDummy;
  }

  /** Adds a new scoped alias for the specified local. For example `super` aliased to the `this` local. */
  addScopedAlias(name: string, type: Type, index: i32, reportNode: Node | null = null): Local {
    var scopedLocals = this.scopedLocals;
    if (!scopedLocals) {
      this.scopedLocals = scopedLocals = new Map();
    } else if (scopedLocals.has(name)) {
      let existingLocal = assert(scopedLocals.get(name));
      if (reportNode) {
        if (!existingLocal.declaration.range.source.isNative) {
          this.parentFunction.program.errorRelated(
            DiagnosticCode.Duplicate_identifier_0,
            reportNode.range,
            existingLocal.declaration.name.range,
            name
          );
        } else {
          this.parentFunction.program.error(
            DiagnosticCode.Duplicate_identifier_0,
            reportNode.range, name
          );
        }
      }
      return existingLocal;
    }
    assert(index < this.parentFunction.localsByIndex.length);
    var scopedAlias = new Local(name, index, type, this.parentFunction);
    // not flagged as SCOPED as it must not be free'd when the flow is finalized
    scopedLocals.set(name, scopedAlias);
    return scopedAlias;
  }

  /** Tests if this flow has any scoped locals that must be free'd. */
  get hasScopedLocals(): bool {
    var scopedLocals = this.scopedLocals;
    if (scopedLocals) {
      // TODO: for (let local of scopedLocals.values()) {
      for (let _values = Map_values(scopedLocals), i = 0, k = _values.length; i < k; ++i) {
        let local = unchecked(_values[i]);
        if (local.is(CommonFlags.SCOPED)) { // otherwise an alias
          return true;
        }
      }
    }
    return false;
  }

  /** Frees a single scoped local by its name. */
  freeScopedDummyLocal(name: string): void {
    var scopedLocals = assert(this.scopedLocals);
    assert(scopedLocals.has(name));
    let local = assert(scopedLocals.get(name));
    assert(local.index == -1);
    scopedLocals.delete(name);
  }

  /** Frees this flow's scoped variables and returns its parent flow. */
  freeScopedLocals(): void {
    var scopedLocals = this.scopedLocals;
    if (scopedLocals) {
      // TODO: for (let local of scopedLocals.values()) {
      for (let _values = Map_values(scopedLocals), i = 0, k = _values.length; i < k; ++i) {
        let local = unchecked(_values[i]);
        if (local.is(CommonFlags.SCOPED)) { // otherwise an alias
          this.freeTempLocal(local);
        }
      }
      this.scopedLocals = null;
    }
  }

  /** Looks up the local of the specified name in the current scope. */
  lookupLocal(name: string): Local | null {
    var current: Flow | null = this;
    do {
      let scope = current.scopedLocals;
      if (scope !== null && scope.has(name)) return assert(scope.get(name));
      current = current.parent;
    } while (current);
    var localsByName = this.parentFunction.localsByName;
    if (localsByName.has(name)) return assert(localsByName.get(name));
    return null;
  }

  /** Looks up the element with the specified name relative to the scope of this flow. */
  lookup(name: string): Element | null {
    var element = this.lookupLocal(name);
    if (element) return element;
    return this.actualFunction.lookup(name);
  }

  /** Tests if the local at the specified index has the specified flag or flags. */
  isLocalFlag(index: i32, flag: LocalFlags, defaultIfInlined: bool = true): bool {
    if (index < 0) return defaultIfInlined;
    var localFlags = this.localFlags;
    return index < localFlags.length && (unchecked(localFlags[index]) & flag) == flag;
  }

  /** Tests if the local at the specified index has any of the specified flags. */
  isAnyLocalFlag(index: i32, flag: LocalFlags, defaultIfInlined: bool = true): bool {
    if (index < 0) return defaultIfInlined;
    var localFlags = this.localFlags;
    return index < localFlags.length && (unchecked(localFlags[index]) & flag) != 0;
  }

  /** Sets the specified flag or flags on the local at the specified index. */
  setLocalFlag(index: i32, flag: LocalFlags): void {
    if (index < 0) return;
    var localFlags = this.localFlags;
    var flags = index < localFlags.length ? unchecked(localFlags[index]) : 0;
    localFlags[index] = flags | flag;
  }

  /** Unsets the specified flag or flags on the local at the specified index. */
  unsetLocalFlag(index: i32, flag: LocalFlags): void {
    if (index < 0) return;
    var localFlags = this.localFlags;
    var flags = index < localFlags.length ? unchecked(localFlags[index]) : 0;
    localFlags[index] = flags & ~flag;
  }

  /** Initializes `this` field flags. */
  initThisFieldFlags(): void {
    var actualFunction = this.actualFunction;
    assert(actualFunction.is(CommonFlags.CONSTRUCTOR));
    var actualParent = actualFunction.parent;
    assert(actualParent.kind == ElementKind.CLASS);
    var actualClass = <Class>actualParent;
    this.thisFieldFlags = new Map();
    var members = actualClass.members;
    if (members) {
      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {
        let member = _values[i];
        if (member.kind == ElementKind.FIELD) {
          let field = <Field>member;
          if (
            // guaranteed by super
            field.parent != actualClass ||
            // has field initializer
            field.initializerNode !== null ||
            // is initialized as a ctor parameter
            field.prototype.parameterIndex != -1 ||
            // is safe to initialize with zero
            field.type.isAny(TypeFlags.VALUE | TypeFlags.NULLABLE)
          ) {
            this.setThisFieldFlag(field, FieldFlags.INITIALIZED);
          }
        }
      }
    }
  }

  /** Tests if the specified `this` field has the specified flag or flags. */
  isThisFieldFlag(field: Field, flag: FieldFlags): bool {
    var fieldFlags = this.thisFieldFlags;
    if (fieldFlags != null && fieldFlags.has(field)) {
      return (changetype<FieldFlags>(fieldFlags.get(field)) & flag) == flag;
    }
    return false;
  }

  /** Sets the specified flag or flags on the given `this` field. */
  setThisFieldFlag(field: Field, flag: FieldFlags): void {
    var fieldFlags = this.thisFieldFlags;
    if (fieldFlags) {
      assert(this.actualFunction.is(CommonFlags.CONSTRUCTOR));
      if (fieldFlags.has(field)) {
        let flags = changetype<FieldFlags>(fieldFlags.get(field));
        fieldFlags.set(field, flags | flag);
      } else {
        fieldFlags.set(field, flag);
      }
    } else {
      assert(!this.actualFunction.is(CommonFlags.CONSTRUCTOR));
    }
  }

  /** Pushes a new break label to the stack, for example when entering a loop that one can `break` from. */
  pushBreakLabel(): string {
    var parentFunction = this.parentFunction;
    var id = parentFunction.nextBreakId++;
    var stack = parentFunction.breakStack;
    if (!stack) parentFunction.breakStack = [ id ];
    else stack.push(id);
    var label = id.toString();
    parentFunction.breakLabel = label;
    return label;
  }

  /** Pops the most recent break label from the stack. */
  popBreakLabel(): void {
    var parentFunction = this.parentFunction;
    var stack = assert(parentFunction.breakStack);
    var length = assert(stack.length);
    stack.pop();
    if (length > 1) {
      parentFunction.breakLabel = stack[length - 2].toString();
    } else {
      parentFunction.breakLabel = null;
      parentFunction.breakStack = null;
    }
  }

  /** Inherits flags of another flow into this one, i.e. a finished inner block. */
  inherit(other: Flow): void {
    assert(other.parentFunction == this.parentFunction);
    assert(other.parent == this); // currently the case, but might change
    var otherFlags = other.flags;

    // respective inner flags are irrelevant if contexts differ
    if (this.breakLabel != other.breakLabel) {
      if (otherFlags & (FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS)) {
        otherFlags &= ~FlowFlags.TERMINATES;
      }
      otherFlags &= ~(FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS);
    }
    if (this.continueLabel != other.continueLabel) {
      otherFlags &= ~(FlowFlags.CONTINUES | FlowFlags.CONDITIONALLY_CONTINUES);
    }

    this.flags = this.flags | otherFlags; // what happens before is still true
    this.localFlags = other.localFlags;
    this.thisFieldFlags = other.thisFieldFlags;
  }

  /** Inherits flags of a conditional branch joining again with this one, i.e. then without else. */
  inheritBranch(other: Flow, conditionKind: ConditionKind = ConditionKind.UNKNOWN): void {
    assert(other.parentFunction == this.parentFunction);
    switch (conditionKind) {
      case ConditionKind.TRUE: this.inherit(other); // always executes
      case ConditionKind.FALSE: return;             // never executes
    }

    // Note that flags in `this` flow have already happened. For instance,
    // a return cannot be undone no matter what'd happen in subsequent branches,
    // but an allocation, which doesn't terminate, can become conditional. Not
    // all flags have a corresponding conditional flag that's tracked.

    var thisFlags = this.flags;
    var otherFlags = other.flags;
    var newFlags = FlowFlags.NONE;

    if (thisFlags & FlowFlags.RETURNS) { // nothing can change that
      newFlags |= FlowFlags.RETURNS;
    } else if (otherFlags & FlowFlags.RETURNS) {
      newFlags |= FlowFlags.CONDITIONALLY_RETURNS;
    } else {
      newFlags |= (thisFlags | otherFlags) & FlowFlags.CONDITIONALLY_RETURNS;
    }

    // must be the case in both
    newFlags |= thisFlags & otherFlags & FlowFlags.RETURNS_WRAPPED;
    newFlags |= thisFlags & otherFlags & FlowFlags.RETURNS_NONNULL;

    if (thisFlags & FlowFlags.THROWS) { // nothing can change that
      newFlags |= FlowFlags.THROWS;
    } else if (otherFlags & FlowFlags.THROWS) {
      newFlags |= FlowFlags.CONDITIONALLY_THROWS;
    } else {
      newFlags |= (thisFlags | otherFlags) & FlowFlags.CONDITIONALLY_THROWS;
    }

    if (thisFlags & FlowFlags.BREAKS) { // nothing can change that
      newFlags |= FlowFlags.BREAKS;
    } else if (other.breakLabel == this.breakLabel) {
      if (otherFlags & FlowFlags.BREAKS) {
        newFlags |= FlowFlags.CONDITIONALLY_BREAKS;
      } else {
        newFlags |= (thisFlags | otherFlags) & FlowFlags.CONDITIONALLY_BREAKS;
      }
    } else {
      newFlags |= thisFlags & FlowFlags.CONDITIONALLY_BREAKS;
    }

    if (thisFlags & FlowFlags.CONTINUES) { // nothing can change that
      newFlags |= FlowFlags.CONTINUES;
    } else if (other.continueLabel === this.continueLabel) {
      if (otherFlags & FlowFlags.CONTINUES) {
        newFlags |= FlowFlags.CONDITIONALLY_CONTINUES;
      } else {
        newFlags |= (thisFlags | otherFlags) & FlowFlags.CONDITIONALLY_CONTINUES;
      }
    } else {
      newFlags |= thisFlags & FlowFlags.CONDITIONALLY_CONTINUES;
    }

    if (thisFlags & FlowFlags.ACCESSES_THIS) { // can become conditional
      if (otherFlags & FlowFlags.ACCESSES_THIS) {
        newFlags |= FlowFlags.ACCESSES_THIS;
      } else {
        newFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;
      }
    } else if (otherFlags & FlowFlags.ACCESSES_THIS) {
      newFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;
    }

    // may be the case in any
    newFlags |= (thisFlags | otherFlags) & FlowFlags.MAY_RETURN_NONTHIS;

    // must be the case in both
    newFlags |= thisFlags & otherFlags & FlowFlags.CALLS_SUPER;

    if (thisFlags & FlowFlags.TERMINATES) { // nothing can change that
      newFlags |= FlowFlags.TERMINATES;
    }

    this.flags = newFlags | (thisFlags & (FlowFlags.UNCHECKED_CONTEXT | FlowFlags.CTORPARAM_CONTEXT));

    // local flags
    var thisLocalFlags = this.localFlags;
    var numThisLocalFlags = thisLocalFlags.length;
    var otherLocalFlags = other.localFlags;
    var numOtherLocalFlags = otherLocalFlags.length;
    var maxLocalFlags = max(numThisLocalFlags, numOtherLocalFlags);
    for (let i = 0; i < maxLocalFlags; ++i) {
      let thisFlags = i < numThisLocalFlags ? thisLocalFlags[i] : 0;
      let otherFlags = i < numOtherLocalFlags ? otherLocalFlags[i] : 0;
      thisLocalFlags[i] = thisFlags & otherFlags & (
        LocalFlags.CONSTANT  |
        LocalFlags.WRAPPED   |
        LocalFlags.NONNULL   |
        LocalFlags.INITIALIZED
      );
    }

    // field flags do not matter here since there's only INITIALIZED, which can
    // only be set if it has been observed prior to entering the branch.
  }

  /** Inherits mutual flags of two alternate branches becoming this one, i.e. then with else. */
  inheritMutual(left: Flow, right: Flow): void {
    assert(left.parentFunction == right.parentFunction);
    assert(left.parentFunction == this.parentFunction);
    // This differs from the previous method in that no flags are guaranteed
    // to happen unless it is the case in both flows.

    var leftFlags = left.flags;
    var rightFlags = right.flags;
    var newFlags = FlowFlags.NONE;

    if (leftFlags & FlowFlags.RETURNS) {
      if (rightFlags & FlowFlags.RETURNS) {
        newFlags |= FlowFlags.RETURNS;
      } else {
        newFlags |= FlowFlags.CONDITIONALLY_RETURNS;
      }
    } else if (rightFlags & FlowFlags.RETURNS) {
      newFlags |= FlowFlags.CONDITIONALLY_RETURNS;
    } else {
      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_RETURNS;
    }

    if ((leftFlags & FlowFlags.RETURNS_WRAPPED) && (rightFlags & FlowFlags.RETURNS_WRAPPED)) {
      newFlags |= FlowFlags.RETURNS_WRAPPED;
    }

    if ((leftFlags & FlowFlags.RETURNS_NONNULL) && (rightFlags & FlowFlags.RETURNS_NONNULL)) {
      newFlags |= FlowFlags.RETURNS_NONNULL;
    }

    if (leftFlags & FlowFlags.THROWS) {
      if (rightFlags & FlowFlags.THROWS) {
        newFlags |= FlowFlags.THROWS;
      } else {
        newFlags |= FlowFlags.CONDITIONALLY_THROWS;
      }
    } else if (rightFlags & FlowFlags.THROWS) {
      newFlags |= FlowFlags.CONDITIONALLY_THROWS;
    } else {
      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_THROWS;
    }

    if (leftFlags & FlowFlags.BREAKS) {
      if (rightFlags & FlowFlags.BREAKS) {
        newFlags |= FlowFlags.BREAKS;
      } else {
        newFlags |= FlowFlags.CONDITIONALLY_BREAKS;
      }
    } else if (rightFlags & FlowFlags.BREAKS) {
      newFlags |= FlowFlags.CONDITIONALLY_BREAKS;
    } else {
      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_BREAKS;
    }

    if (leftFlags & FlowFlags.CONTINUES) {
      if (rightFlags & FlowFlags.CONTINUES) {
        newFlags |= FlowFlags.CONTINUES;
      } else {
        newFlags |= FlowFlags.CONDITIONALLY_CONTINUES;
      }
    } else if (rightFlags & FlowFlags.CONTINUES) {
      newFlags |= FlowFlags.CONDITIONALLY_CONTINUES;
    } else {
      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_CONTINUES;
    }

    if (leftFlags & FlowFlags.ACCESSES_THIS) {
      if (rightFlags & FlowFlags.ACCESSES_THIS) {
        newFlags |= FlowFlags.ACCESSES_THIS;
      } else {
        newFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;
      }
    } else if (rightFlags & FlowFlags.ACCESSES_THIS) {
      newFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;
    } else {
      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_ACCESSES_THIS;
    }

    newFlags |= (leftFlags | rightFlags) & FlowFlags.MAY_RETURN_NONTHIS;

    if ((leftFlags & FlowFlags.CALLS_SUPER) && (rightFlags & FlowFlags.CALLS_SUPER)) {
      newFlags |= FlowFlags.CALLS_SUPER;
    }

    if ((leftFlags & FlowFlags.TERMINATES) && (rightFlags & FlowFlags.TERMINATES)) {
      newFlags |= FlowFlags.TERMINATES;
    }

    this.flags = newFlags | (this.flags & (FlowFlags.UNCHECKED_CONTEXT | FlowFlags.CTORPARAM_CONTEXT));

    // local flags
    var thisLocalFlags = this.localFlags;
    if (leftFlags & FlowFlags.TERMINATES) {
      if (!(rightFlags & FlowFlags.TERMINATES)) {
        let rightLocalFlags = right.localFlags;
        for (let i = 0, k = rightLocalFlags.length; i < k; ++i) {
          thisLocalFlags[i] = rightLocalFlags[i];
        }
      }
    } else if (rightFlags & FlowFlags.TERMINATES) {
      let leftLocalFlags = left.localFlags;
      for (let i = 0, k = leftLocalFlags.length; i < k; ++i) {
        thisLocalFlags[i] = leftLocalFlags[i];
      }
    } else {
      let leftLocalFlags = left.localFlags;
      let numLeftLocalFlags = leftLocalFlags.length;
      let rightLocalFlags = right.localFlags;
      let numRightLocalFlags = rightLocalFlags.length;
      let maxLocalFlags = max(numLeftLocalFlags, numRightLocalFlags);
      for (let i = 0; i < maxLocalFlags; ++i) {
        let leftFlags = i < numLeftLocalFlags ? leftLocalFlags[i] : 0;
        let rightFlags = i < numRightLocalFlags ? rightLocalFlags[i] : 0;
        thisLocalFlags[i] = leftFlags & rightFlags & (
          LocalFlags.CONSTANT  |
          LocalFlags.WRAPPED   |
          LocalFlags.NONNULL   |
          LocalFlags.INITIALIZED
        );
      }
    }

    // field flags (currently only INITIALIZED, so can simplify)
    var leftFieldFlags = left.thisFieldFlags;
    if (leftFieldFlags) {
      let newFieldFlags = new Map<Field,FieldFlags>();
      let rightFieldFlags = assert(right.thisFieldFlags);
      for (let _keys = Map_keys(leftFieldFlags), i = 0, k = _keys.length; i < k; ++i) {
        let key = _keys[i];
        let leftFlags = changetype<FieldFlags>(leftFieldFlags.get(key));
        if (
          (leftFlags & FieldFlags.INITIALIZED) != 0 && rightFieldFlags.has(key) && 
          (changetype<FieldFlags>(rightFieldFlags.get(key)) & FieldFlags.INITIALIZED)
        ) {
          newFieldFlags.set(key, FieldFlags.INITIALIZED);
        }
      }
      this.thisFieldFlags = newFieldFlags;
    } else {
      assert(!right.thisFieldFlags);
    }
  }

  /** Tests if the specified flows have differing local states. */
  static hasIncompatibleLocalStates(before: Flow, after: Flow): bool {
    var numThisLocalFlags = before.localFlags.length;
    var numOtherLocalFlags = after.localFlags.length;
    var parentFunction = before.parentFunction;
    assert(parentFunction === after.parentFunction);
    var localsByIndex = parentFunction.localsByIndex;
    assert(localsByIndex === after.parentFunction.localsByIndex);
    for (let i = 0, k = min<i32>(numThisLocalFlags, numOtherLocalFlags); i < k; ++i) {
      let local = localsByIndex[i];
      let type = local.type;
      if (type.isShortIntegerValue) {
        if (before.isLocalFlag(i, LocalFlags.WRAPPED) && !after.isLocalFlag(i, LocalFlags.WRAPPED)) {
          return true;
        }
      }
      if (type.isNullableReference) {
        if (before.isLocalFlag(i, LocalFlags.NONNULL) && !after.isLocalFlag(i, LocalFlags.NONNULL)) {
          return true;
        }
      }
    }
    return false;
  }

  /** Unifies local flags between this and the other flow. */
  unifyLocalFlags(other: Flow): void {
    var numThisLocalFlags = this.localFlags.length;
    var numOtherLocalFlags = other.localFlags.length;
    for (let i = 0, k = min<i32>(numThisLocalFlags, numOtherLocalFlags); i < k; ++i) {
      if (this.isLocalFlag(i, LocalFlags.WRAPPED) != other.isLocalFlag(i, LocalFlags.WRAPPED)) {
        this.unsetLocalFlag(i, LocalFlags.WRAPPED); // assume not wrapped
      }
      if (this.isLocalFlag(i, LocalFlags.NONNULL) != other.isLocalFlag(i, LocalFlags.NONNULL)) {
        this.unsetLocalFlag(i, LocalFlags.NONNULL); // assume possibly null
      }
    }
  }

  /** Checks if an expression of the specified type is known to be non-null, even if the type might be nullable. */
  isNonnull(expr: ExpressionRef, type: Type): bool {
    if (!type.isNullableReference) return true;
    // below, only teeLocal/getLocal are relevant because these are the only expressions that
    // depend on a dynamic nullable state (flag = LocalFlags.NONNULL), while everything else
    // has already been handled by the nullable type check above.
    switch (getExpressionId(expr)) {
      case ExpressionId.LocalSet: {
        if (!isLocalTee(expr)) break;
        let local = this.parentFunction.localsByIndex[getLocalSetIndex(expr)];
        return !local.type.isNullableReference || this.isLocalFlag(local.index, LocalFlags.NONNULL, false);
      }
      case ExpressionId.LocalGet: {
        let local = this.parentFunction.localsByIndex[getLocalGetIndex(expr)];
        return !local.type.isNullableReference || this.isLocalFlag(local.index, LocalFlags.NONNULL, false);
      }
    }
    return false;
  }

  /** Updates local states to reflect that this branch is only taken when `expr` is true-ish. */
  inheritNonnullIfTrue(
    /** Expression being true. */
    expr: ExpressionRef,
    /** If specified, only set the flag if also nonnull in this flow. */
    iff: Flow | null = null
  ): void {
    // A: `expr` is true-ish -> Q: how did that happen?

    // The iff argument is useful in situations like
    //
    //  if (!ref) {
    //    ref = new Ref();
    //  }
    //  // inheritNonnullIfFalse(`!ref`, thenFlow) -> ref != null
    //

    switch (getExpressionId(expr)) {
      case ExpressionId.LocalSet: {
        if (!isLocalTee(expr)) break;
        let local = this.parentFunction.localsByIndex[getLocalSetIndex(expr)];
        if (!iff || iff.isLocalFlag(local.index, LocalFlags.NONNULL)) {
          this.setLocalFlag(local.index, LocalFlags.NONNULL);
        }
        this.inheritNonnullIfTrue(getLocalSetValue(expr), iff); // must have been true-ish as well
        break;
      }
      case ExpressionId.LocalGet: {
        let local = this.parentFunction.localsByIndex[getLocalGetIndex(expr)];
        if (!iff || iff.isLocalFlag(local.index, LocalFlags.NONNULL)) {
          this.setLocalFlag(local.index, LocalFlags.NONNULL);
        }
        break;
      }
      case ExpressionId.If: {
        let ifFalse = getIfFalse(expr);
        if (!ifFalse) break;
        if (getExpressionId(ifFalse) == ExpressionId.Const) {
          // Logical AND: (if (condition ifTrue 0))
          // the only way this had become true is if condition and ifTrue are true
          if (
            (getExpressionType(ifFalse) == TypeRef.I32 && getConstValueI32(ifFalse) == 0) ||
            (getExpressionType(ifFalse) == TypeRef.I64 && getConstValueI64Low(ifFalse) == 0 && getConstValueI64High(ifFalse) == 0)
          ) {
            this.inheritNonnullIfTrue(getIfCondition(expr), iff);
            this.inheritNonnullIfTrue(getIfTrue(expr), iff);
          }
        }
        break;
      }
      case ExpressionId.Unary: {
        switch (getUnaryOp(expr)) {
          case UnaryOp.EqzI32:
          case UnaryOp.EqzI64: {
            this.inheritNonnullIfFalse(getUnaryValue(expr), iff); // !value -> value must have been false
            break;
          }
        }
        break;
      }
      case ExpressionId.Binary: {
        switch (getBinaryOp(expr)) {
          case BinaryOp.EqI32: {
            let left = getBinaryLeft(expr);
            let right = getBinaryRight(expr);
            if (getExpressionId(left) == ExpressionId.Const && getConstValueI32(left) != 0) {
              this.inheritNonnullIfTrue(right, iff); // TRUE == right -> right must have been true
            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI32(right) != 0) {
              this.inheritNonnullIfTrue(left, iff); // left == TRUE -> left must have been true
            }
            break;
          }
          case BinaryOp.EqI64: {
            let left = getBinaryLeft(expr);
            let right = getBinaryRight(expr);
            if (getExpressionId(left) == ExpressionId.Const && (getConstValueI64Low(left) != 0 || getConstValueI64High(left) != 0)) {
              this.inheritNonnullIfTrue(right, iff); // TRUE == right -> right must have been true
            } else if (getExpressionId(right) == ExpressionId.Const && (getConstValueI64Low(right) != 0 && getConstValueI64High(right) != 0)) {
              this.inheritNonnullIfTrue(left, iff); // left == TRUE -> left must have been true
            }
            break;
          }
          case BinaryOp.NeI32: {
            let left = getBinaryLeft(expr);
            let right = getBinaryRight(expr);
            if (getExpressionId(left) == ExpressionId.Const && getConstValueI32(left) == 0) {
              this.inheritNonnullIfTrue(right, iff); // FALSE != right -> right must have been true
            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI32(right) == 0) {
              this.inheritNonnullIfTrue(left, iff); // left != FALSE -> left must have been true
            }
            break;
          }
          case BinaryOp.NeI64: {
            let left = getBinaryLeft(expr);
            let right = getBinaryRight(expr);
            if (getExpressionId(left) == ExpressionId.Const && getConstValueI64Low(left) == 0 && getConstValueI64High(left) == 0) {
              this.inheritNonnullIfTrue(right, iff); // FALSE != right -> right must have been true
            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI64Low(right) == 0 && getConstValueI64High(right) == 0) {
              this.inheritNonnullIfTrue(left, iff); // left != FALSE -> left must have been true
            }
            break;
          }
        }
        break;
      }
    }
  }

  /** Updates local states to reflect that this branch is only taken when `expr` is false-ish. */
  inheritNonnullIfFalse(
    /** Expression being false. */
    expr: ExpressionRef,
    /** If specified, only set the flag if also nonnull in this flow. */
    iff: Flow | null = null
  ): void {
    // A: `expr` is false-ish -> Q: how did that happen?
    switch (getExpressionId(expr)) {
      case ExpressionId.Unary: {
        switch (getUnaryOp(expr)) {
          case UnaryOp.EqzI32:
          case UnaryOp.EqzI64: {
            this.inheritNonnullIfTrue(getUnaryValue(expr), iff); // !value -> value must have been true
            break;
          }
        }
        break;
      }
      case ExpressionId.If: {
        let ifTrue = getIfTrue(expr);
        if (getExpressionId(ifTrue) == ExpressionId.Const) {
          let ifFalse = getIfFalse(expr);
          if (!ifFalse) break;
          // Logical OR: (if (condition 1 ifFalse))
          // the only way this had become false is if condition and ifFalse are false
          let exprType = getExpressionType(ifTrue);
          if (
            (exprType == TypeRef.I32 && getConstValueI32(ifTrue) != 0) ||
            (exprType == TypeRef.I64 && (getConstValueI64Low(ifTrue) != 0 || getConstValueI64High(ifTrue) != 0))
          ) {
            this.inheritNonnullIfFalse(getIfCondition(expr), iff);
            this.inheritNonnullIfFalse(getIfFalse(expr), iff);
          }

        }
        break;
      }
      case ExpressionId.Binary: {
        switch (getBinaryOp(expr)) {
          // remember: we want to know how the _entire_ expression became FALSE (!)
          case BinaryOp.EqI32: {
            let left = getBinaryLeft(expr);
            let right = getBinaryRight(expr);
            if (getExpressionId(left) == ExpressionId.Const && getConstValueI32(left) == 0) {
              this.inheritNonnullIfTrue(right, iff); // FALSE == right -> right must have been true
            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI32(right) == 0) {
              this.inheritNonnullIfTrue(left, iff); // left == FALSE -> left must have been true
            }
            break;
          }
          case BinaryOp.EqI64: {
            let left = getBinaryLeft(expr);
            let right = getBinaryRight(expr);
            if (getExpressionId(left) == ExpressionId.Const && getConstValueI64Low(left) == 0 && getConstValueI64High(left) == 0) {
              this.inheritNonnullIfTrue(right, iff); // FALSE == right -> right must have been true
            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI64Low(right) == 0 && getConstValueI64High(right) == 0) {
              this.inheritNonnullIfTrue(left, iff); // left == FALSE -> left must have been true
            }
            break;
          }
          case BinaryOp.NeI32: {
            let left = getBinaryLeft(expr);
            let right = getBinaryRight(expr);
            if (getExpressionId(left) == ExpressionId.Const && getConstValueI32(left) != 0) {
              this.inheritNonnullIfTrue(right, iff); // TRUE != right -> right must have been true
            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI32(right) != 0) {
              this.inheritNonnullIfTrue(left, iff); // left != TRUE -> left must have been true
            }
            break;
          }
          case BinaryOp.NeI64: {
            let left = getBinaryLeft(expr);
            let right = getBinaryRight(expr);
            if (getExpressionId(left) == ExpressionId.Const && (getConstValueI64Low(left) != 0 || getConstValueI64High(left) != 0)) {
              this.inheritNonnullIfTrue(right, iff); // TRUE != right -> right must have been true for this to become false
            } else if (getExpressionId(right) == ExpressionId.Const && (getConstValueI64Low(right) != 0 || getConstValueI64High(right) != 0)) {
              this.inheritNonnullIfTrue(left, iff); // left != TRUE -> left must have been true for this to become false
            }
            break;
          }
        }
        break;
      }
    }
  }

  /**
   * Tests if an expression can possibly overflow in the context of this flow. Assumes that the
   * expression might already have overflown and returns `false` only if the operation neglects
   * any possible combination of garbage bits being present.
   */
  canOverflow(expr: ExpressionRef, type: Type): bool {
    // TODO: the following catches most common and a few uncommon cases, but there are additional
    // opportunities here, obviously.
    assert(type != Type.void);

    // types other than i8, u8, i16, u16 and bool do not overflow
    if (!type.isShortIntegerValue) return false;

    var operand: ExpressionRef;
    switch (getExpressionId(expr)) {

      // overflows if the local isn't wrapped or the conversion does
      case ExpressionId.LocalGet: {
        let local = this.parentFunction.localsByIndex[getLocalGetIndex(expr)];
        return !this.isLocalFlag(local.index, LocalFlags.WRAPPED, true)
            || canConversionOverflow(local.type, type);
      }

      // overflows if the value does
      case ExpressionId.LocalSet: { // tee
        assert(isLocalTee(expr));
        return this.canOverflow(getLocalSetValue(expr), type);
      }

      // overflows if the conversion does (globals are wrapped on set)
      case ExpressionId.GlobalGet: {
        // TODO: this is inefficient because it has to read a string
        let global = assert(this.parentFunction.program.elementsByName.get(assert(getGlobalGetName(expr))));
        assert(global.kind == ElementKind.GLOBAL);
        return canConversionOverflow((<Global>global).type, type);
      }

      case ExpressionId.Binary: {
        switch (getBinaryOp(expr)) {

          // comparisons do not overflow (result is 0 or 1)
          case BinaryOp.EqI32:
          case BinaryOp.EqI64:
          case BinaryOp.EqF32:
          case BinaryOp.EqF64:
          case BinaryOp.NeI32:
          case BinaryOp.NeI64:
          case BinaryOp.NeF32:
          case BinaryOp.NeF64:
          case BinaryOp.LtI32:
          case BinaryOp.LtU32:
          case BinaryOp.LtI64:
          case BinaryOp.LtU64:
          case BinaryOp.LtF32:
          case BinaryOp.LtF64:
          case BinaryOp.LeI32:
          case BinaryOp.LeU32:
          case BinaryOp.LeI64:
          case BinaryOp.LeU64:
          case BinaryOp.LeF32:
          case BinaryOp.LeF64:
          case BinaryOp.GtI32:
          case BinaryOp.GtU32:
          case BinaryOp.GtI64:
          case BinaryOp.GtU64:
          case BinaryOp.GtF32:
          case BinaryOp.GtF64:
          case BinaryOp.GeI32:
          case BinaryOp.GeU32:
          case BinaryOp.GeI64:
          case BinaryOp.GeU64:
          case BinaryOp.GeF32:
          case BinaryOp.GeF64: return false;

          // result won't overflow if one side is 0 or if one side is 1 and the other wrapped
          case BinaryOp.MulI32: {
            return !(
              (
                getExpressionId(operand = getBinaryLeft(expr)) == ExpressionId.Const &&
                (
                  getConstValueI32(operand) == 0 ||
                  (
                    getConstValueI32(operand) == 1 &&
                    !this.canOverflow(getBinaryRight(expr), type)
                  )
                )
              ) || (
                getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&
                (
                  getConstValueI32(operand) == 0 ||
                  (
                    getConstValueI32(operand) == 1 &&
                    !this.canOverflow(getBinaryLeft(expr), type)
                  )
                )
              )
            );
          }

          // result won't overflow if one side is a constant less than this type's mask or one side
          // is wrapped
          case BinaryOp.AndI32: {
            // note that computeSmallIntegerMask returns the mask minus the MSB for signed types
            // because signed value garbage bits must be guaranteed to be equal to the MSB.
            return !(
              (
                (
                  getExpressionId(operand = getBinaryLeft(expr)) == ExpressionId.Const &&
                  getConstValueI32(operand) <= type.computeSmallIntegerMask(Type.i32)
                ) || !this.canOverflow(operand, type)
              ) || (
                (
                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&
                  getConstValueI32(operand) <= type.computeSmallIntegerMask(Type.i32)
                ) || !this.canOverflow(operand, type)
              )
            );
          }

          // overflows if the shift doesn't clear potential garbage bits
          case BinaryOp.ShlI32: {
            let shift = 32 - type.size;
            return getExpressionId(operand = getBinaryRight(expr)) != ExpressionId.Const
                || getConstValueI32(operand) < shift;
          }

          // overflows if the value does and the shift doesn't clear potential garbage bits
          case BinaryOp.ShrI32: {
            let shift = 32 - type.size;
            return this.canOverflow(getBinaryLeft(expr), type) && (
              getExpressionId(operand = getBinaryRight(expr)) != ExpressionId.Const ||
              getConstValueI32(operand) < shift
            );
          }

          // overflows if the shift does not clear potential garbage bits. if an unsigned value is
          // wrapped, it can't overflow.
          case BinaryOp.ShrU32: {
            let shift = 32 - type.size;
            return type.isSignedIntegerValue
              ? !(
                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&
                  getConstValueI32(operand) > shift // must clear MSB
                )
              : this.canOverflow(getBinaryLeft(expr), type) &&
                !(
                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&
                  getConstValueI32(operand) >= shift // can leave MSB
                );
          }

          // overflows if any side does
          case BinaryOp.DivU32:
          case BinaryOp.RemI32:
          case BinaryOp.RemU32: {
            return this.canOverflow(getBinaryLeft(expr), type)
                || this.canOverflow(getBinaryRight(expr), type);
          }
        }
        break;
      }

      case ExpressionId.Unary: {
        switch (getUnaryOp(expr)) {

          // comparisons do not overflow (result is 0 or 1)
          case UnaryOp.EqzI32:
          case UnaryOp.EqzI64: return false;

          // overflow if the maximum result (32) cannot be represented in the target type
          case UnaryOp.ClzI32:
          case UnaryOp.CtzI32:
          case UnaryOp.PopcntI32: return type.size < 7;

          // sign extensions overflow if result can have high garbage bits in the target type
          case UnaryOp.Extend8I32: return type.size < (type.isUnsignedIntegerValue ? 32 : 8);
          case UnaryOp.Extend8I64: return type.size < (type.isUnsignedIntegerValue ? 64 : 8);
          case UnaryOp.Extend16I32: return type.size < (type.isUnsignedIntegerValue ? 32 : 16);
          case UnaryOp.Extend16I64: return type.size < (type.isUnsignedIntegerValue ? 64 : 16);
          case UnaryOp.Extend32I64: return type.size < (type.isUnsignedIntegerValue ? 64 : 32);
        }
        break;
      }

      // overflows if the value cannot be represented in the target type
      case ExpressionId.Const: {
        let value: i32 = 0;
        switch (<u32>getExpressionType(expr)) {
          case <u32>TypeRef.I32: { value = getConstValueI32(expr); break; }
          case <u32>TypeRef.I64: { value = getConstValueI64Low(expr); break; } // discards upper bits
          case <u32>TypeRef.F32: { value = i32(getConstValueF32(expr)); break; }
          case <u32>TypeRef.F64: { value = i32(getConstValueF64(expr)); break; }
          default: assert(false);
        }
        switch (type.kind) {
          case TypeKind.I8: return value < <i32>i8.MIN_VALUE || value > <i32>i8.MAX_VALUE;
          case TypeKind.I16: return value < <i32>i16.MIN_VALUE || value > <i32>i16.MAX_VALUE;
          case TypeKind.U8: return value < 0 || value > <i32>u8.MAX_VALUE;
          case TypeKind.U16: return value < 0 || value > <i32>u16.MAX_VALUE;
          case TypeKind.BOOL: return (value & ~1) != 0;
        }
        break;
      }

      // overflows if the conversion does
      case ExpressionId.Load: {
        let fromType: Type;
        let signed = isLoadSigned(expr);
        switch (getLoadBytes(expr)) {
          case 1:  { fromType = signed ? Type.i8  : Type.u8;  break; }
          case 2:  { fromType = signed ? Type.i16 : Type.u16; break; }
          default: { fromType = signed ? Type.i32 : Type.u32; break; }
        }
        return canConversionOverflow(fromType, type);
      }

      // overflows if the result does, which is either
      // - the last expression of the block, by contract, if the block doesn't have a label
      // - the last expression or the value of an inner br if the block has a label (TODO)
      case ExpressionId.Block: {
        if (!getBlockName(expr)) {
          let size = assert(getBlockChildCount(expr));
          let last = getBlockChildAt(expr, size - 1);
          return this.canOverflow(last, type);
        }
        break;
      }

      // overflows if either side does
      case ExpressionId.If: {
        return this.canOverflow(getIfTrue(expr), type)
            || this.canOverflow(assert(getIfFalse(expr)), type);
      }

      // overflows if either side does
      case ExpressionId.Select: {
        return this.canOverflow(getSelectThen(expr), type)
            || this.canOverflow(getSelectElse(expr), type);
      }

      // overflows if the call does not return a wrapped value or the conversion does
      case ExpressionId.Call: {
        let program = this.parentFunction.program;
        let instancesByName = program.instancesByName;
        let instanceName = assert(getCallTarget(expr));
        if (instancesByName.has(instanceName)) {
          let instance = assert(instancesByName.get(instanceName));
          assert(instance.kind == ElementKind.FUNCTION);
          let functionInstance = <Function>instance;
          let returnType = functionInstance.signature.returnType;
          return !functionInstance.flow.is(FlowFlags.RETURNS_WRAPPED)
              || canConversionOverflow(returnType, type);
        }
        return false; // assume no overflow for builtins
      }

      // doesn't technically overflow
      case ExpressionId.Unreachable: return false;
    }
    return true;
  }

  toString(): string {
    var levels = 0;
    var parent = this.parent;
    while (parent) {
      parent = parent.parent;
      ++levels;
    }
    var sb = new Array<string>();
    if (this.is(FlowFlags.RETURNS)) sb.push("RETURNS");
    if (this.is(FlowFlags.RETURNS_WRAPPED)) sb.push("RETURNS_WRAPPED");
    if (this.is(FlowFlags.RETURNS_NONNULL)) sb.push("RETURNS_NONNULL");
    if (this.is(FlowFlags.THROWS)) sb.push("THROWS");
    if (this.is(FlowFlags.BREAKS)) sb.push("BREAKS");
    if (this.is(FlowFlags.CONTINUES)) sb.push("CONTINUES");
    if (this.is(FlowFlags.ACCESSES_THIS)) sb.push("ACCESSES_THIS");
    if (this.is(FlowFlags.CALLS_SUPER)) sb.push("CALLS_SUPER");
    if (this.is(FlowFlags.TERMINATES)) sb.push("TERMINATES");
    if (this.is(FlowFlags.CONDITIONALLY_RETURNS)) sb.push("CONDITIONALLY_RETURNS");
    if (this.is(FlowFlags.CONDITIONALLY_THROWS)) sb.push("CONDITIONALLY_THROWS");
    if (this.is(FlowFlags.CONDITIONALLY_BREAKS)) sb.push("CONDITIONALLY_BREAKS");
    if (this.is(FlowFlags.CONDITIONALLY_CONTINUES)) sb.push("CONDITIONALLY_CONTINUES");
    if (this.is(FlowFlags.CONDITIONALLY_ACCESSES_THIS)) sb.push("CONDITIONALLY_ACCESSES_THIS");
    if (this.is(FlowFlags.MAY_RETURN_NONTHIS)) sb.push("MAY_RETURN_NONTHIS");
    return "Flow(" + this.actualFunction.toString() + ")[" + levels.toString() + "] " + sb.join(" ");
  }
}

/** Tests if a conversion from one type to another can technically overflow. */
function canConversionOverflow(fromType: Type, toType: Type): bool {
  return toType.isShortIntegerValue && (
    !fromType.isIntegerValue ||                                    // i.e. float to small int
    fromType.size > toType.size ||                                 // larger int to small int
    fromType.isSignedIntegerValue != toType.isSignedIntegerValue   // signedness mismatch
  );
}

export { findUsedLocals } from "./passes/findusedlocals";

'''
'''--- src/glue/README.md ---
Environment specific glue code.

'''
'''--- src/glue/binaryen.d.ts ---
/**
 * @fileoverview Portable definitions for Binaryen's C-API.
 *
 * tsc uses the .js file next to it, while asc makes it a Wasm import.
 *
 * See: https://github.com/WebAssembly/binaryen/blob/main/src/binaryen-c.h
 *
 * @license Apache-2.0
 */

export type Index = u32;
export type ExpressionId = i32;
export type FeatureFlags = u32;
export type Op = i32;
export type ExternalKind = u32;
export type SideEffects = u32;
export type ExpressionRunnerFlags = u32;
type Ref = usize;
export type StringRef = Ref;
export type ArrayRef<T> = Ref;
export type TypeRef = Ref;
export type ModuleRef = Ref;
export type LiteralRef = Ref;
export type ExpressionRef = Ref;
export type FunctionRef = Ref;
export type ImportRef = Ref;
export type ExportRef = Ref;
export type GlobalRef = Ref;
export type TagRef = Ref;
export type TableRef = Ref;
export type ElementSegmentRef = Ref;
export type RelooperRef = Ref;
export type RelooperBlockRef = Ref;
export type ExpressionRunnerRef = Ref;

export declare function _BinaryenTypeCreate(types: ArrayRef<TypeRef>, numTypes: u32): TypeRef;
export declare function _BinaryenTypeArity(type: TypeRef): u32;
export declare function _BinaryenTypeExpand(type: TypeRef, typesOut: ArrayRef<TypeRef>): void;

export declare function _BinaryenModuleCreate(): ModuleRef;
export declare function _BinaryenModuleDispose(module: ModuleRef): void;

export declare function _BinaryenSizeofLiteral(): usize;
export declare function _BinaryenLiteralInt32(literalOut: LiteralRef, x: i32): void;
export declare function _BinaryenLiteralInt64(literalOut: LiteralRef, x: i32, y: i32): void;
export declare function _BinaryenLiteralFloat32(literalOut: LiteralRef, x: f32): void;
export declare function _BinaryenLiteralFloat64(literalOut: LiteralRef, x: f64): void;
export declare function _BinaryenLiteralVec128(literalOut: LiteralRef, x: ArrayRef<u8>): void;
export declare function _BinaryenLiteralFloat32Bits(literalOut: LiteralRef, x: i32): void;
export declare function _BinaryenLiteralFloat64Bits(literalOut: LiteralRef, x: i32, y: i32): void;

export declare function _BinaryenExpressionGetId(expr: ExpressionRef): ExpressionId;
export declare function _BinaryenExpressionGetType(expr: ExpressionRef): TypeRef;
export declare function _BinaryenExpressionSetType(expr: ExpressionRef, type: TypeRef): void;
export declare function _BinaryenExpressionPrint(expr: ExpressionRef): void;
export declare function _BinaryenExpressionCopy(expr: ExpressionRef, module: ModuleRef): ExpressionRef;
export declare function _BinaryenExpressionFinalize(expr: ExpressionRef): void;

export declare function _BinaryenBlock(module: ModuleRef, name: StringRef, childExprs: ArrayRef<ExpressionRef>, numChildren: Index, type: TypeRef): ExpressionRef;
export declare function _BinaryenBlockGetName(expr: ExpressionRef): StringRef;
export declare function _BinaryenBlockSetName(expr: ExpressionRef, name: StringRef): void;
export declare function _BinaryenBlockGetNumChildren(expr: ExpressionRef): Index;
export declare function _BinaryenBlockGetChildAt(expr: ExpressionRef, index: Index): ExpressionRef;
export declare function _BinaryenBlockSetChildAt(expr: ExpressionRef, index: Index, childExpr: ExpressionRef): void;
export declare function _BinaryenBlockAppendChild(expr: ExpressionRef, childExpr: ExpressionRef): Index;
export declare function _BinaryenBlockInsertChildAt(expr: ExpressionRef, index: Index, childExpr: ExpressionRef): void;
export declare function _BinaryenBlockRemoveChildAt(expr: ExpressionRef, index: Index): ExpressionRef;

export declare function _BinaryenIf(module: ModuleRef, conditionExpr: ExpressionRef, ifTrueExpr: ExpressionRef, ifFalseExpr: ExpressionRef): ExpressionRef;
export declare function _BinaryenIfGetCondition(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenIfSetCondition(expr: ExpressionRef, conditionExpr: ExpressionRef): void;
export declare function _BinaryenIfGetIfTrue(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenIfSetIfTrue(expr: ExpressionRef, ifTrueExpr: ExpressionRef): void;
export declare function _BinaryenIfGetIfFalse(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenIfSetIfFalse(expr: ExpressionRef, ifFalseExpr: ExpressionRef): void;

export declare function _BinaryenLoop(module: ModuleRef, name: StringRef, bodyExpr: ExpressionRef): ExpressionRef;
export declare function _BinaryenLoopGetName(expr: ExpressionRef): StringRef;
export declare function _BinaryenLoopSetName(expr: ExpressionRef, name: StringRef): void;
export declare function _BinaryenLoopGetBody(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenLoopSetBody(expr: ExpressionRef, bodyExpr: ExpressionRef): void;

export declare function _BinaryenBreak(module: ModuleRef, name: StringRef, conditionExpr: ExpressionRef, valueExpr: ExpressionRef): ExpressionRef;
export declare function _BinaryenBreakGetName(expr: ExpressionRef): StringRef;
export declare function _BinaryenBreakSetName(expr: ExpressionRef, name: StringRef): void;
export declare function _BinaryenBreakGetCondition(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenBreakSetCondition(expr: ExpressionRef, conditionExpr: ExpressionRef): void;
export declare function _BinaryenBreakGetValue(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenBreakSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;

export declare function _BinaryenSwitch(module: ModuleRef, names: ArrayRef<StringRef>, numNames: Index, defaultName: StringRef, conditionExpr: ExpressionRef, valueExpr: ExpressionRef): ExpressionRef;
export declare function _BinaryenSwitchGetNumNames(expr: ExpressionRef): Index;
export declare function _BinaryenSwitchGetNameAt(expr: ExpressionRef, index: Index): StringRef;
export declare function _BinaryenSwitchSetNameAt(expr: ExpressionRef, index: Index, name: StringRef): void;
export declare function _BinaryenSwitchAppendName(expr: ExpressionRef, name: StringRef): Index;
export declare function _BinaryenSwitchInsertNameAt(expr: ExpressionRef, index: Index, name: StringRef): void;
export declare function _BinaryenSwitchRemoveNameAt(expr: ExpressionRef, index: Index): StringRef;
export declare function _BinaryenSwitchGetDefaultName(expr: ExpressionRef): StringRef;
export declare function _BinaryenSwitchSetDefaultName(expr: ExpressionRef, defaultName: StringRef): void;
export declare function _BinaryenSwitchGetCondition(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenSwitchSetCondition(expr: ExpressionRef, conditionExpr: ExpressionRef): void;
export declare function _BinaryenSwitchGetValue(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenSwitchSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;

export declare function _BinaryenCall(module: ModuleRef, targetName: StringRef, operandExprs: ArrayRef<ExpressionRef>, numOperands: Index, returnType: TypeRef): ExpressionRef;
export declare function _BinaryenCallGetTarget(expr: ExpressionRef): StringRef;
export declare function _BinaryenCallSetTarget(expr: ExpressionRef, targetName: StringRef): void;
export declare function _BinaryenCallGetNumOperands(expr: ExpressionRef): Index;
export declare function _BinaryenCallGetOperandAt(expr: ExpressionRef, index: Index): ExpressionRef;
export declare function _BinaryenCallSetOperandAt(expr: ExpressionRef, index: Index, operandExpr: ExpressionRef): void;
export declare function _BinaryenCallAppendOperand(expr: ExpressionRef, operandExpr: ExpressionRef): Index;
export declare function _BinaryenCallInsertOperandAt(expr: ExpressionRef, index: Index, operandExpr: ExpressionRef): void;
export declare function _BinaryenCallRemoveOperandAt(expr: ExpressionRef, index: Index): ExpressionRef;
export declare function _BinaryenCallIsReturn(expr: ExpressionRef): bool;
export declare function _BinaryenCallSetReturn(expr: ExpressionRef, isReturn: bool): void;
// ^ with return = true
export declare function _BinaryenReturnCall(module: ModuleRef, targetName: StringRef, operandExprs: ArrayRef<ExpressionRef>, numOperands: Index, returnType: TypeRef): ExpressionRef;

export declare function _BinaryenCallIndirect(module: ModuleRef, table: StringRef, targetExpr: ExpressionRef, operandExprs: ArrayRef<ExpressionRef>, numOperands: Index, params: TypeRef, results: TypeRef): ExpressionRef;
export declare function _BinaryenCallIndirectGetTable(expr: ExpressionRef): StringRef;
export declare function _BinaryenCallIndirectSetTable(expr: ExpressionRef, table: StringRef): void;
export declare function _BinaryenCallIndirectGetTarget(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenCallIndirectSetTarget(expr: ExpressionRef, targetExpr: ExpressionRef): void;
export declare function _BinaryenCallIndirectGetNumOperands(expr: ExpressionRef): Index;
export declare function _BinaryenCallIndirectGetOperandAt(expr: ExpressionRef, index: Index): ExpressionRef;
export declare function _BinaryenCallIndirectSetOperandAt(expr: ExpressionRef, index: Index, operandExpr: ExpressionRef): void;
export declare function _BinaryenCallIndirectAppendOperand(expr: ExpressionRef, operandExpr: ExpressionRef): Index;
export declare function _BinaryenCallIndirectInsertOperandAt(expr: ExpressionRef, index: Index, operandExpr: ExpressionRef): void;
export declare function _BinaryenCallIndirectRemoveOperandAt(expr: ExpressionRef, index: Index): ExpressionRef;
export declare function _BinaryenCallIndirectIsReturn(expr: ExpressionRef): bool;
export declare function _BinaryenCallIndirectSetReturn(expr: ExpressionRef, isReturn: bool): void;
// ^ with return = true
export declare function _BinaryenReturnCallIndirect(module: ModuleRef, table: StringRef, targetExpr: ExpressionRef, operandExprs: ArrayRef<ExpressionRef>, numOperands: Index, params: TypeRef, results: TypeRef): ExpressionRef;

export declare function _BinaryenLocalGet(module: ModuleRef, index: Index, type: TypeRef): ExpressionRef;
export declare function _BinaryenLocalGetGetIndex(expr: ExpressionRef): Index;
export declare function _BinaryenLocalGetSetIndex(expr: ExpressionRef, index: Index): void;

export declare function _BinaryenLocalSet(module: ModuleRef, index: Index, valueExpr: ExpressionRef): ExpressionRef;
export declare function _BinaryenLocalSetIsTee(expr: ExpressionRef): bool;
export declare function _BinaryenLocalSetGetIndex(expr: ExpressionRef): Index;
export declare function _BinaryenLocalSetSetIndex(expr: ExpressionRef, index: Index): void;
export declare function _BinaryenLocalSetGetValue(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenLocalSetSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;
// ^ with type != none
export declare function _BinaryenLocalTee(module: ModuleRef, index: Index, valueExpr: ExpressionRef, type: TypeRef): ExpressionRef;

export declare function _BinaryenGlobalGet(module: ModuleRef, name: StringRef, type: TypeRef): ExpressionRef;
export declare function _BinaryenGlobalGetGetName(expr: ExpressionRef): StringRef;
export declare function _BinaryenGlobalGetSetName(expr: ExpressionRef, name: StringRef): void;

export declare function _BinaryenGlobalSet(module: ModuleRef, name: StringRef, value: ExpressionRef): ExpressionRef;
export declare function _BinaryenGlobalSetGetName(expr: ExpressionRef): StringRef;
export declare function _BinaryenGlobalSetSetName(expr: ExpressionRef, name: StringRef): void;
export declare function _BinaryenGlobalSetGetValue(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenGlobalSetSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;

export declare function _BinaryenMemorySize(module: ModuleRef): ExpressionRef;

export declare function _BinaryenMemoryGrow(module: ModuleRef, delta: ExpressionRef): ExpressionRef;
export declare function _BinaryenMemoryGrowGetDelta(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenMemoryGrowSetDelta(expr: ExpressionRef, delta: ExpressionRef): void;

export declare function _BinaryenLoad(module: ModuleRef, bytes: u32, signed: bool, offset: u32, align: u32, type: TypeRef, ptrExpr: ExpressionRef): ExpressionRef;
export declare function _BinaryenLoadIsAtomic(expr: ExpressionRef): bool;
export declare function _BinaryenLoadSetAtomic(expr: ExpressionRef, isAtomic: bool): void;
export declare function _BinaryenLoadIsSigned(expr: ExpressionRef): bool;
export declare function _BinaryenLoadSetSigned(expr: ExpressionRef, isSigned: bool): void;
export declare function _BinaryenLoadGetOffset(expr: ExpressionRef): u32;
export declare function _BinaryenLoadSetOffset(expr: ExpressionRef, offset: u32): void;
export declare function _BinaryenLoadGetBytes(expr: ExpressionRef): u32;
export declare function _BinaryenLoadSetBytes(expr: ExpressionRef, bytes: u32): void;
export declare function _BinaryenLoadGetAlign(expr: ExpressionRef): u32;
export declare function _BinaryenLoadSetAlign(expr: ExpressionRef, align: u32): void;
export declare function _BinaryenLoadGetPtr(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenLoadSetPtr(expr: ExpressionRef, ptrExpr: ExpressionRef): void;
// ^ with atomic = true
export declare function _BinaryenAtomicLoad(module: ModuleRef, bytes: Index, offset: Index, type: TypeRef, ptrExpr: ExpressionRef): ExpressionRef;

export declare function _BinaryenStore(module: ModuleRef, bytes: u32, offset: u32, align: u32, ptrExpr: ExpressionRef, valueExpr: ExpressionRef, type: TypeRef): ExpressionRef;
export declare function _BinaryenStoreIsAtomic(expr: ExpressionRef): bool;
export declare function _BinaryenStoreSetAtomic(expr: ExpressionRef, isAtomic: bool): void;
export declare function _BinaryenStoreGetBytes(expr: ExpressionRef): u32;
export declare function _BinaryenStoreSetBytes(expr: ExpressionRef, bytes: u32): void;
export declare function _BinaryenStoreGetOffset(expr: ExpressionRef): u32;
export declare function _BinaryenStoreSetOffset(expr: ExpressionRef, offset: u32): void;
export declare function _BinaryenStoreGetAlign(expr: ExpressionRef): u32;
export declare function _BinaryenStoreSetAlign(expr: ExpressionRef, align: u32): void;
export declare function _BinaryenStoreGetPtr(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenStoreSetPtr(expr: ExpressionRef, ptrExpr: ExpressionRef): void;
export declare function _BinaryenStoreGetValue(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenStoreSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;
export declare function _BinaryenStoreGetValueType(expr: ExpressionRef): TypeRef;
export declare function _BinaryenStoreSetValueType(expr: ExpressionRef, valueType: TypeRef): void;
// ^ with atomic = true
export declare function _BinaryenAtomicStore(module: ModuleRef, bytes: Index, offset: Index, ptrExpr: ExpressionRef, valueExpr: ExpressionRef, type: TypeRef): ExpressionRef;

export declare function _BinaryenConst(module: ModuleRef, value: LiteralRef): ExpressionRef;
export declare function _BinaryenConstGetValueI32(expr: ExpressionRef): i32;
export declare function _BinaryenConstSetValueI32(expr: ExpressionRef, value: i32): void;
export declare function _BinaryenConstGetValueI64Low(expr: ExpressionRef): i32;
export declare function _BinaryenConstSetValueI64Low(expr: ExpressionRef, value: i32): void;
export declare function _BinaryenConstGetValueI64High(expr: ExpressionRef): i32;
export declare function _BinaryenConstSetValueI64High(expr: ExpressionRef, value: i32): void;
export declare function _BinaryenConstGetValueF32(expr: ExpressionRef): f32;
export declare function _BinaryenConstSetValueF32(expr: ExpressionRef, value: f32): void;
export declare function _BinaryenConstGetValueF64(expr: ExpressionRef): f64;
export declare function _BinaryenConstSetValueF64(expr: ExpressionRef, value: f64): void;
export declare function _BinaryenConstGetValueV128(expr: ExpressionRef, valueOut: ArrayRef<u8>): void;
export declare function _BinaryenConstSetValueV128(expr: ExpressionRef, value: ArrayRef<u8>): void;

export declare function _BinaryenUnary(module: ModuleRef, op: Op, valueExpr: ExpressionRef): ExpressionRef;
export declare function _BinaryenUnaryGetOp(expr: ExpressionRef): Op;
export declare function _BinaryenUnarySetOp(expr: ExpressionRef, op: Op): void;
export declare function _BinaryenUnaryGetValue(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenUnarySetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;

export declare function _BinaryenBinary(module: ModuleRef, op: Op, leftExpr: ExpressionRef, rightExpr: ExpressionRef): ExpressionRef;
export declare function _BinaryenBinaryGetOp(expr: ExpressionRef): Op;
export declare function _BinaryenBinarySetOp(expr: ExpressionRef, op: Op): void;
export declare function _BinaryenBinaryGetLeft(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenBinarySetLeft(expr: ExpressionRef, leftExpr: ExpressionRef): void;
export declare function _BinaryenBinaryGetRight(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenBinarySetRight(expr: ExpressionRef, rightExpr: ExpressionRef): void;

export declare function _BinaryenSelect(module: ModuleRef, conditionExpr: ExpressionRef, ifTrueExpr: ExpressionRef, ifFalseExpr: ExpressionRef, type: TypeRef): ExpressionRef;
export declare function _BinaryenSelectGetIfTrue(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenSelectSetIfTrue(expr: ExpressionRef, ifTrueExpr: ExpressionRef): void;
export declare function _BinaryenSelectGetIfFalse(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenSelectSetIfFalse(expr: ExpressionRef, ifFalseExpr: ExpressionRef): void;
export declare function _BinaryenSelectGetCondition(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenSelectSetCondition(expr: ExpressionRef, conditionExpr: ExpressionRef): void;

export declare function _BinaryenDrop(module: ModuleRef, valueExpr: ExpressionRef): ExpressionRef;
export declare function _BinaryenDropGetValue(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenDropSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;

export declare function _BinaryenReturn(module: ModuleRef, valueExpr: ExpressionRef): ExpressionRef;
export declare function _BinaryenReturnGetValue(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenReturnSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;

export declare function _BinaryenNop(module: ModuleRef): ExpressionRef;

export declare function _BinaryenUnreachable(module: ModuleRef): ExpressionRef;

export declare function _BinaryenAtomicRMW(module: ModuleRef, op: Op, bytes: u32, offset: u32, ptrExpr: ExpressionRef, valueExpr: ExpressionRef, type: TypeRef): ExpressionRef;
export declare function _BinaryenAtomicRMWGetOp(expr: ExpressionRef): Op;
export declare function _BinaryenAtomicRMWSetOp(expr: ExpressionRef, op: Op): void;
export declare function _BinaryenAtomicRMWGetBytes(expr: ExpressionRef): u32;
export declare function _BinaryenAtomicRMWSetBytes(expr: ExpressionRef, bytes: u32): void;
export declare function _BinaryenAtomicRMWGetOffset(expr: ExpressionRef): u32;
export declare function _BinaryenAtomicRMWSetOffset(expr: ExpressionRef, offset: u32): void;
export declare function _BinaryenAtomicRMWGetPtr(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenAtomicRMWSetPtr(expr: ExpressionRef, ptrExpr: ExpressionRef): void;
export declare function _BinaryenAtomicRMWGetValue(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenAtomicRMWSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;

export declare function _BinaryenAtomicCmpxchg(module: ModuleRef, bytes: u32, offset: u32, ptrExpr: ExpressionRef, expectedExpr: ExpressionRef, replacementExpr: ExpressionRef, type: TypeRef): ExpressionRef;
export declare function _BinaryenAtomicCmpxchgGetBytes(expr: ExpressionRef): u32;
export declare function _BinaryenAtomicCmpxchgSetBytes(expr: ExpressionRef, bytes: u32): void;
export declare function _BinaryenAtomicCmpxchgGetOffset(expr: ExpressionRef): u32;
export declare function _BinaryenAtomicCmpxchgSetOffset(expr: ExpressionRef, offset: u32): void;
export declare function _BinaryenAtomicCmpxchgGetPtr(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenAtomicCmpxchgSetPtr(expr: ExpressionRef, ptrExpr: ExpressionRef): void;
export declare function _BinaryenAtomicCmpxchgGetExpected(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenAtomicCmpxchgSetExpected(expr: ExpressionRef, expectedExpr: ExpressionRef): void;
export declare function _BinaryenAtomicCmpxchgGetReplacement(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenAtomicCmpxchgSetReplacement(expr: ExpressionRef, replacementExpr: ExpressionRef): void;

export declare function _BinaryenAtomicWait(module: ModuleRef, ptrExpr: ExpressionRef, expectedExpr: ExpressionRef, timeoutExpr: ExpressionRef, expectedType: TypeRef): ExpressionRef;
export declare function _BinaryenAtomicWaitGetPtr(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenAtomicWaitSetPtr(expr: ExpressionRef, ptrExpr: ExpressionRef): void;
export declare function _BinaryenAtomicWaitGetExpected(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenAtomicWaitSetExpected(expr: ExpressionRef, expectedExpr: ExpressionRef): void;
export declare function _BinaryenAtomicWaitGetTimeout(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenAtomicWaitSetTimeout(expr: ExpressionRef, timeoutExpr: ExpressionRef): void;
export declare function _BinaryenAtomicWaitGetExpectedType(expr: ExpressionRef): TypeRef;
export declare function _BinaryenAtomicWaitSetExpectedType(expr: ExpressionRef, expectedType: TypeRef): void;

export declare function _BinaryenAtomicNotify(module: ModuleRef, ptrExpr: ExpressionRef, notifyCountExpr: ExpressionRef): ExpressionRef;
export declare function _BinaryenAtomicNotifyGetPtr(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenAtomicNotifySetPtr(expr: ExpressionRef, ptrExpr: ExpressionRef): void;
export declare function _BinaryenAtomicNotifyGetNotifyCount(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenAtomicNotifySetNotifyCount(expr: ExpressionRef, notifyCountExpr: ExpressionRef): void;

export declare function _BinaryenAtomicFence(module: ModuleRef): ExpressionRef;
export declare function _BinaryenAtomicFenceGetOrder(expr: ExportRef): u8; // unused
export declare function _BinaryenAtomicFenceSetOrder(expr: ExportRef, order: u8): void; // unused

export declare function _BinaryenSIMDExtract(module: ModuleRef, op: Op, vecExpr: ExpressionRef, index: u8): ExpressionRef;
export declare function _BinaryenSIMDExtractGetOp(expr: ExpressionRef): Op;
export declare function _BinaryenSIMDExtractSetOp(expr: ExpressionRef, op: Op): void;
export declare function _BinaryenSIMDExtractGetVec(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenSIMDExtractSetVec(expr: ExpressionRef, vecExpr: ExpressionRef): void;
export declare function _BinaryenSIMDExtractGetIndex(expr: ExpressionRef): u8;
export declare function _BinaryenSIMDExtractSetIndex(expr: ExpressionRef, index: u8): void;

export declare function _BinaryenSIMDReplace(module: ModuleRef, op: Op, vecEpr: ExpressionRef, index: u8, valueExpr: ExpressionRef): ExpressionRef;
export declare function _BinaryenSIMDReplaceGetOp(expr: ExpressionRef): Op;
export declare function _BinaryenSIMDReplaceSetOp(expr: ExpressionRef, op: Op): void;
export declare function _BinaryenSIMDReplaceGetVec(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenSIMDReplaceSetVec(expr: ExpressionRef, vecExpr: ExpressionRef): void;
export declare function _BinaryenSIMDReplaceGetIndex(expr: ExpressionRef): u8;
export declare function _BinaryenSIMDReplaceSetIndex(expr: ExpressionRef, index: u8): void;
export declare function _BinaryenSIMDReplaceGetValue(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenSIMDReplaceSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;

export declare function _BinaryenSIMDShuffle(module: ModuleRef, leftExpr: ExpressionRef, rightExpr: ExpressionRef, mask: ArrayRef<u8>): ExpressionRef;
export declare function _BinaryenSIMDShuffleGetLeft(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenSIMDShuffleSetLeft(expr: ExpressionRef, leftExpr: ExpressionRef): void;
export declare function _BinaryenSIMDShuffleGetRight(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenSIMDShuffleSetRight(expr: ExpressionRef, rightExpr: ExpressionRef): void;
export declare function _BinaryenSIMDShuffleGetMask(expr: ExpressionRef, maskOut: ArrayRef<u8>): void;
export declare function _BinaryenSIMDShuffleSetMask(expr: ExpressionRef, mask: ArrayRef<u8>): void;

export declare function _BinaryenSIMDTernary(module: ModuleRef, op: Op, aExpr: ExpressionRef, bExpr: ExpressionRef, cExpr: ExpressionRef): ExpressionRef;
export declare function _BinaryenSIMDTernaryGetOp(expr: ExpressionRef): Op;
export declare function _BinaryenSIMDTernarySetOp(expr: ExpressionRef, op: Op): void;
export declare function _BinaryenSIMDTernaryGetA(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenSIMDTernarySetA(expr: ExpressionRef, aExpr: ExpressionRef): void;
export declare function _BinaryenSIMDTernaryGetB(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenSIMDTernarySetB(expr: ExpressionRef, bExpr: ExpressionRef): void;
export declare function _BinaryenSIMDTernaryGetC(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenSIMDTernarySetC(expr: ExpressionRef, cExpr: ExpressionRef): void;

export declare function _BinaryenSIMDShift(module: ModuleRef, op: Op, vecExpr: ExpressionRef, shiftExpr: ExpressionRef): ExpressionRef;
export declare function _BinaryenSIMDShiftGetOp(expr: ExpressionRef): Op;
export declare function _BinaryenSIMDShiftSetOp(expr: ExpressionRef, op: Op): void;
export declare function _BinaryenSIMDShiftGetVec(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenSIMDShiftSetVec(expr: ExpressionRef, vecExpr: ExpressionRef): void;
export declare function _BinaryenSIMDShiftGetShift(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenSIMDShiftSetShift(expr: ExpressionRef, shiftExpr: ExpressionRef): void;

export declare function _BinaryenSIMDLoad(module: ModuleRef, op: Op, offset: u32, align: u32, ptrExpr: ExportRef): ExpressionRef;
export declare function _BinaryenSIMDLoadGetOp(expr: ExpressionRef): Op;
export declare function _BinaryenSIMDLoadSetOp(expr: ExpressionRef, op: Op): void;
export declare function _BinaryenSIMDLoadGetOffset(expr: ExpressionRef): u32;
export declare function _BinaryenSIMDLoadSetOffset(expr: ExpressionRef, offset: u32): void;
export declare function _BinaryenSIMDLoadGetAlign(expr: ExpressionRef): u32;
export declare function _BinaryenSIMDLoadSetAlign(expr: ExpressionRef, align: u32): void;
export declare function _BinaryenSIMDLoadGetPtr(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenSIMDLoadSetPtr(expr: ExpressionRef, ptrExpr: ExpressionRef): void;

export declare function _BinaryenSIMDLoadStoreLane(module: ModuleRef, op: Op, offset: u32, align: u32, index: u8, ptr: ExpressionRef, vec: ExpressionRef): ExpressionRef;
export declare function _BinaryenSIMDLoadStoreLaneGetOp(expr: ExpressionRef): Op;
export declare function _BinaryenSIMDLoadStoreLaneSetOp(expr: ExpressionRef, op: Op): void;
export declare function _BinaryenSIMDLoadStoreLaneGetOffset(expr: ExpressionRef): u32;
export declare function _BinaryenSIMDLoadStoreLaneSetOffset(expr: ExpressionRef, offset: u32): void;
export declare function _BinaryenSIMDLoadStoreLaneGetAlign(expr: ExpressionRef): u32;
export declare function _BinaryenSIMDLoadStoreLaneSetAlign(expr: ExpressionRef, align: u32): void;
export declare function _BinaryenSIMDLoadStoreLaneGetIndex(expr: ExpressionRef): u8;
export declare function _BinaryenSIMDLoadStoreLaneSetIndex(expr: ExpressionRef, index: u8): void;
export declare function _BinaryenSIMDLoadStoreLaneGetPtr(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenSIMDLoadStoreLaneSetPtr(expr: ExpressionRef, ptrExpr: ExpressionRef): void;
export declare function _BinaryenSIMDLoadStoreLaneGetVec(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenSIMDLoadStoreLaneSetVec(expr: ExpressionRef, vecExpr: ExpressionRef): void;
export declare function _BinaryenSIMDLoadStoreLaneIsStore(expr: ExpressionRef): bool;

export declare function _BinaryenMemoryInit(module: ModuleRef, segmentIndex: u32, destExpr: ExpressionRef, offsetExpr: ExpressionRef, sizeExpr: ExpressionRef): ExpressionRef;
export declare function _BinaryenMemoryInitGetSegment(expr: ExpressionRef): u32;
export declare function _BinaryenMemoryInitSetSegment(expr: ExpressionRef, segmentIndex: u32): void;
export declare function _BinaryenMemoryInitGetDest(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenMemoryInitSetDest(expr: ExpressionRef, destExpr: ExpressionRef): void;
export declare function _BinaryenMemoryInitGetOffset(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenMemoryInitSetOffset(expr: ExpressionRef, offsetExpr: ExpressionRef): void;
export declare function _BinaryenMemoryInitGetSize(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenMemoryInitSetSize(expr: ExpressionRef, sizeExpr: ExpressionRef): void;

export declare function _BinaryenDataDrop(module: ModuleRef, segmentIndex: u32): ExpressionRef;
export declare function _BinaryenDataDropGetSegment(expr: ExpressionRef): u32;
export declare function _BinaryenDataDropSetSegment(expr: ExpressionRef, segmentIndex: u32): void;

export declare function _BinaryenMemoryCopy(module: ModuleRef, destExpr: ExpressionRef, sourceExpr: ExpressionRef, sizeExpr: ExpressionRef): ExpressionRef;
export declare function _BinaryenMemoryCopyGetDest(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenMemoryCopySetDest(expr: ExpressionRef, destExpr: ExpressionRef): void;
export declare function _BinaryenMemoryCopyGetSource(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenMemoryCopySetSource(expr: ExpressionRef, sourceExpr: ExpressionRef): void;
export declare function _BinaryenMemoryCopyGetSize(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenMemoryCopySetSize(expr: ExpressionRef, sizeExpr: ExpressionRef): void;

export declare function _BinaryenMemoryFill(module: ModuleRef, destExpr: ExpressionRef, valueExpr: ExpressionRef, sizeExpr: ExpressionRef): ExpressionRef;
export declare function _BinaryenMemoryFillGetDest(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenMemoryFillSetDest(expr: ExpressionRef, destExpr: ExpressionRef): void;
export declare function _BinaryenMemoryFillGetValue(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenMemoryFillSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;
export declare function _BinaryenMemoryFillGetSize(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenMemoryFillSetSize(expr: ExpressionRef, sizeExpr: ExpressionRef): void;

export declare function _BinaryenRefNull(module: ModuleRef, type: TypeRef): ExpressionRef;

export declare function _BinaryenRefIs(module: ModuleRef, op: Op, valueExpr: ExpressionRef): ExpressionRef;
export declare function _BinaryenRefIsGetOp(expr: ExpressionRef): Op;
export declare function _BinaryenRefIsSetOp(expr: ExpressionRef, op: Op): void;
export declare function _BinaryenRefIsGetValue(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenRefIsSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;

export declare function _BinaryenRefAs(module: ModuleRef, op: Op, valueExpr: ExpressionRef): ExpressionRef;
export declare function _BinaryenRefAsGetOp(expr: ExpressionRef): Op;
export declare function _BinaryenRefAsSetOp(expr: ExpressionRef, op: Op): void;
export declare function _BinaryenRefAsGetValue(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenRefAsSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;

export declare function _BinaryenRefFunc(module: ModuleRef, funcName: StringRef, type: TypeRef): ExpressionRef;
export declare function _BinaryenRefFuncGetFunc(expr: ExpressionRef): StringRef;
export declare function _BinaryenRefFuncSetFunc(expr: ExpressionRef, funcName: StringRef): void;

export declare function _BinaryenRefEq(module: ModuleRef, leftExpr: ExpressionRef, rightExpr: ExpressionRef): ExpressionRef;
export declare function _BinaryenRefEqGetLeft(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenRefEqSetLeft(expr: ExpressionRef, leftExpr: ExpressionRef): void;
export declare function _BinaryenRefEqGetRight(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenRefEqSetRight(expr: ExpressionRef, rightExpr: ExpressionRef): void;

export declare function _BinaryenTry(module: ModuleRef, name: StringRef, bodyExpr: ExpressionRef, catchTags: ArrayRef<StringRef>, numCatchTags: Index, catchBodies: ArrayRef<ExpressionRef>, numCatchBodies: Index, delegateTarget: StringRef): ExpressionRef;
export declare function _BinaryenTryGetName(expr: ExpressionRef): StringRef;
export declare function _BinaryenTrySetName(expr: ExpressionRef, name: StringRef): void;
export declare function _BinaryenTryGetBody(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenTrySetBody(expr: ExpressionRef, bodyExpr: ExpressionRef): void;
export declare function _BinaryenTryGetNumCatchTags(expr: ExpressionRef): Index;
export declare function _BinaryenTryGetNumCatchBodies(expr: ExpressionRef): Index;
export declare function _BinaryenTryGetCatchTagAt(expr: ExpressionRef, index: Index): StringRef;
export declare function _BinaryenTrySetCatchTagAt(expr: ExpressionRef, index: Index, catchTag: StringRef): void;
export declare function _BinaryenTryAppendCatchTag(expr: ExpressionRef, catchTag: StringRef): Index;
export declare function _BinaryenTryInsertCatchTagAt(expr: ExpressionRef, index: Index, catchTag: StringRef): void;
export declare function _BinaryenTryRemoveCatchTagAt(expr: ExpressionRef, index: Index): StringRef;
export declare function _BinaryenTryGetCatchBodyAt(expr: ExpressionRef, index: Index): ExpressionRef;
export declare function _BinaryenTrySetCatchBodyAt(expr: ExpressionRef, index: Index, catchExpr: ExpressionRef): void;
export declare function _BinaryenTryAppendCatchBody(expr: ExpressionRef, catchExpr: ExpressionRef): Index;
export declare function _BinaryenTryInsertCatchBodyAt(expr: ExpressionRef, index: Index, catchExpr: ExpressionRef): void;
export declare function _BinaryenTryRemoveCatchBodyAt(expr: ExpressionRef, index: Index): ExpressionRef;
export declare function _BinaryenTryHasCatchAll(expr: ExpressionRef): bool;
export declare function _BinaryenTryGetDelegateTarget(expr: ExpressionRef): StringRef;
export declare function _BinaryenTrySetDelegateTarget(expr: ExpressionRef, delegateTarget: StringRef): void;
export declare function _BinaryenTryIsDelegate(expr: ExpressionRef): bool;

export declare function _BinaryenThrow(module: ModuleRef, tagName: StringRef, operands: ArrayRef<ExpressionRef>, numOperands: Index): ExpressionRef;
export declare function _BinaryenThrowGetTag(expr: ExpressionRef): StringRef;
export declare function _BinaryenThrowSetTag(expr: ExpressionRef, tagName: StringRef): void;
export declare function _BinaryenThrowGetNumOperands(expr: ExpressionRef): Index;
export declare function _BinaryenThrowGetOperandAt(expr: ExpressionRef, index: Index): ExpressionRef;
export declare function _BinaryenThrowSetOperandAt(expr: ExpressionRef, index: Index, operandExpr: ExpressionRef): void;
export declare function _BinaryenThrowAppendOperand(expr: ExpressionRef, operandExpr: ExpressionRef): Index;
export declare function _BinaryenThrowInsertOperandAt(expr: ExpressionRef, index: Index, operandExpr: ExpressionRef): void;
export declare function _BinaryenThrowRemoveOperandAt(expr: ExpressionRef, index: Index): ExpressionRef;

export declare function _BinaryenRethrow(module: ModuleRef, target: StringRef): ExpressionRef;
export declare function _BinaryenRethrowGetTarget(expr: ExpressionRef): StringRef;
export declare function _BinaryenRethrowSetDepth(expr: ExpressionRef, target: StringRef): void;

export declare function _BinaryenTupleMake(module: ModuleRef, operandExprs: ArrayRef<ExpressionRef>, numOperands: Index): ExpressionRef;
export declare function _BinaryenTupleMakeGetNumOperands(expr: ExpressionRef): Index;
export declare function _BinaryenTupleMakeGetOperandAt(expr: ExpressionRef, index: Index): ExpressionRef;
export declare function _BinaryenTupleMakeSetOperandAt(expr: ExpressionRef, index: Index, operandExpr: ExpressionRef): void;
export declare function _BinaryenTupleMakeAppendOperand(expr: ExpressionRef, operandExpr: ExpressionRef): Index;
export declare function _BinaryenTupleMakeInsertOperandAt(expr: ExpressionRef, index: Index, operandExpr: ExpressionRef): void;
export declare function _BinaryenTupleMakeRemoveOperandAt(expr: ExpressionRef, index: Index): ExpressionRef;

export declare function _BinaryenTupleExtract(module: ModuleRef, tupleExpr: ExpressionRef, index: Index): ExpressionRef;
export declare function _BinaryenTupleExtractGetTuple(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenTupleExtractSetTuple(expr: ExpressionRef, tupleExpr: ExpressionRef): void;
export declare function _BinaryenTupleExtractGetIndex(expr: ExpressionRef): Index;
export declare function _BinaryenTupleExtractSetIndex(expr: ExpressionRef, index: Index): void;

export declare function _BinaryenPop(module: ModuleRef, type: TypeRef): ExpressionRef;

export declare function _BinaryenI31New(module: ModuleRef, value: ExpressionRef): ExpressionRef;
export declare function _BinaryenI31NewGetValue(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenI31NewSetValue(expr: ExpressionRef, valueExpr: ExpressionRef): void;

export declare function _BinaryenI31Get(module: ModuleRef, i31Expr: ExpressionRef, signed: bool): ExpressionRef;
export declare function _BinaryenI31GetGetI31(expr: ExpressionRef): ExpressionRef;
export declare function _BinaryenI31GetSetI31(expr: ExpressionRef, i31Expr: ExpressionRef): void;
export declare function _BinaryenI31GetIsSigned(expr: ExpressionRef): bool;
export declare function _BinaryenI31GetSetSigned(expr: ExpressionRef, signed: bool): void;

export declare function _BinaryenAddFunction(module: ModuleRef, name: StringRef, params: TypeRef, results: TypeRef, varTypes: ArrayRef<TypeRef>, numVarTypes: Index, body: ExpressionRef): FunctionRef;
export declare function _BinaryenGetFunction(module: ModuleRef, name: StringRef): FunctionRef;
export declare function _BinaryenRemoveFunction(module: ModuleRef, name: StringRef): void;
export declare function _BinaryenGetNumFunctions(module: ModuleRef): Index;
export declare function _BinaryenGetFunctionByIndex(module: ModuleRef, index: Index): FunctionRef;

export declare function _BinaryenFunctionGetName(func: FunctionRef): StringRef;
export declare function _BinaryenFunctionGetParams(func: FunctionRef): TypeRef;
export declare function _BinaryenFunctionGetResults(func: FunctionRef): TypeRef;
export declare function _BinaryenFunctionGetNumVars(func: FunctionRef): Index;
export declare function _BinaryenFunctionGetVar(func: FunctionRef, index: Index): TypeRef;
export declare function _BinaryenFunctionGetNumLocals(func: FunctionRef): Index;
export declare function _BinaryenFunctionHasLocalName(func: FunctionRef, index: Index): bool;
export declare function _BinaryenFunctionGetLocalName(func: FunctionRef, index: Index): StringRef;
export declare function _BinaryenFunctionSetLocalName(func: FunctionRef, index: Index, name: StringRef): void;
export declare function _BinaryenFunctionGetBody(func: FunctionRef): ExpressionRef;
export declare function _BinaryenFunctionSetBody(func: FunctionRef, bodyExpr: ExpressionRef): void;
export declare function _BinaryenFunctionOptimize(func: FunctionRef, module: ModuleRef): void;
export declare function _BinaryenFunctionRunPasses(func: FunctionRef, module: ModuleRef, passes: ArrayRef<StringRef>, numPasses: Index): void;
export declare function _BinaryenFunctionSetDebugLocation(func: FunctionRef, expr: ExpressionRef, fileIndex: Index, lineNumber: Index, columnNumber: Index): void;

export declare function _BinaryenAddFunctionImport(module: ModuleRef, internalName: StringRef, externalModuleName: StringRef, externalBaseName: StringRef, params: TypeRef, results: TypeRef): void;
export declare function _BinaryenAddTableImport(module: ModuleRef, internalName: StringRef, externalModuleName: StringRef, externalBaseName: StringRef): void;
export declare function _BinaryenAddMemoryImport(module: ModuleRef, internalName: StringRef, externalModuleName: StringRef, externalBaseName: StringRef, shared:bool): void;
export declare function _BinaryenAddGlobalImport(module: ModuleRef, internalName: StringRef, externalModuleName: StringRef, externalBaseName: StringRef, globalType: TypeRef, mutable: bool): void;
export declare function _BinaryenAddTagImport(module: ModuleRef, internalName: StringRef, externalModuleName: StringRef, externalBaseName: StringRef, params: TypeRef, results: TypeRef): void;

export declare function _BinaryenAddFunctionExport(module: ModuleRef, internalName: StringRef, externalName: StringRef): ExportRef;
export declare function _BinaryenAddTableExport(module: ModuleRef, internalName: StringRef, externalName: StringRef): ExportRef;
export declare function _BinaryenAddMemoryExport(module: ModuleRef, internalName: StringRef, externalName: StringRef): ExportRef;
export declare function _BinaryenAddGlobalExport(module: ModuleRef, internalName: StringRef, externalName: StringRef): ExportRef;
export declare function _BinaryenAddTagExport(module: ModuleRef, internalName: StringRef, externalName: StringRef): ExportRef;
export declare function _BinaryenGetExport(module: ModuleRef, externalName: StringRef): ExportRef;
export declare function _BinaryenRemoveExport(module: ModuleRef, externalName: StringRef): void;
export declare function _BinaryenGetNumExports(module: ModuleRef): Index;
export declare function _BinaryenGetExportByIndex(module: ModuleRef, index: Index): ExportRef;
export declare function _BinaryenExportGetKind(ref: ExportRef): ExternalKind;
export declare function _BinaryenExportGetName(ref: ExportRef): StringRef;
export declare function _BinaryenExportGetValue(ref: ExportRef): StringRef;

export declare function _BinaryenAddGlobal(module: ModuleRef, name: StringRef, type: TypeRef, mutable: bool, init: ExpressionRef): GlobalRef;
export declare function _BinaryenGetGlobal(module: ModuleRef, name: StringRef): GlobalRef;
export declare function _BinaryenRemoveGlobal(module: ModuleRef, name: StringRef): void;
export declare function _BinaryenGetNumGlobals(module: ModuleRef): Index;
export declare function _BinaryenGetGlobalByIndex(module: ModuleRef, index: Index): GlobalRef;

export declare function _BinaryenGlobalGetName(global: GlobalRef): StringRef;
export declare function _BinaryenGlobalGetType(global: GlobalRef): TypeRef;
export declare function _BinaryenGlobalIsMutable(global: GlobalRef): bool;
export declare function _BinaryenGlobalGetInitExpr(global: GlobalRef): ExpressionRef;

export declare function _BinaryenAddTag(module: ModuleRef, name: StringRef, params: TypeRef, results: TypeRef): TagRef;
export declare function _BinaryenGetTag(module: ModuleRef, name: StringRef): TagRef;
export declare function _BinaryenRemoveTag(module: ModuleRef, name: StringRef): void;

export declare function _BinaryenTagGetName(tag: TagRef): StringRef;
export declare function _BinaryenTagGetParams(tag: TagRef): TypeRef;
export declare function _BinaryenTagGetResults(tag: TagRef): TypeRef;

export declare function _BinaryenAddTable(module: ModuleRef, name: StringRef, initial: Index, maximum: Index): TableRef;
export declare function _BinaryenRemoveTable(module: ModuleRef, table: StringRef): void;
export declare function _BinaryenGetNumTables(module: ModuleRef): Index;
export declare function _BinaryenGetTable(module: ModuleRef, name: StringRef): TableRef;
export declare function _BinaryenGetTableByIndex(module: ModuleRef, index: Index): TableRef;

export declare function _BinaryenTableGetName(table: TableRef): StringRef;
export declare function _BinaryenTableSetName(table: TableRef, name: StringRef): void;
export declare function _BinaryenTableGetInitial(table: TableRef): Index;
export declare function _BinaryenTableSetInitial(table: TableRef, initial: Index): void;
export declare function _BinaryenTableHasMax(table: TableRef): bool;
export declare function _BinaryenTableGetMax(table: TableRef): Index;
export declare function _BinaryenTableSetMax(table: TableRef, max: Index): void;

export declare function _BinaryenAddActiveElementSegment(module: ModuleRef, table: StringRef, name: StringRef, funcNames: ArrayRef<StringRef>, numFuncNames: Index, offset: ExpressionRef): ElementSegmentRef;
export declare function _BinaryenAddPassiveElementSegment(module: ModuleRef, name: StringRef, funcNames: ArrayRef<StringRef>, numFuncNames: Index): ElementSegmentRef;
export declare function _BinaryenRemoveElementSegment(module: ModuleRef, name: StringRef): void;
export declare function _BinaryenGetNumElementSegments(module: ModuleRef, name: StringRef): Index;
export declare function _BinaryenGetElementSegment(module: ModuleRef, name: StringRef): ElementSegmentRef;
export declare function _BinaryenGetElementSegmentByIndex(module: ModuleRef, index: Index): ElementSegmentRef;

export declare function _BinaryenSetMemory(module: ModuleRef, initial: Index, maximum: Index, exportName: StringRef, segments: ArrayRef<ArrayRef<u8>>, segmentPassive: ArrayRef<bool>, segmentOffsets: ArrayRef<usize>, segmentSizes: ArrayRef<u32>, numSegments: Index, shared: bool): void;
export declare function _BinaryenGetNumMemorySegments(module: ModuleRef): Index;
export declare function _BinaryenGetMemorySegmentByteOffset(module: ModuleRef, index: Index): u32;
export declare function _BinaryenGetMemorySegmentByteLength(module: ModuleRef, id: Index): usize;
export declare function _BinaryenCopyMemorySegmentData(module: ModuleRef, id: Index, buffer: ArrayRef<u8>): void;

export declare function _BinaryenSetStart(module: ModuleRef, start: FunctionRef): void;

export declare function _BinaryenModuleParse(text: StringRef): ModuleRef;
export declare function _BinaryenModulePrint(module: ModuleRef): void;
export declare function _BinaryenModulePrintAsmjs(module: ModuleRef): void;
export declare function _BinaryenModuleValidate(module: ModuleRef): i32;
export declare function _BinaryenModuleOptimize(module: ModuleRef): void;
export declare function _BinaryenModuleRunPasses(module: ModuleRef, passes: ArrayRef<StringRef>, numPasses: Index): void;
export declare function _BinaryenModuleAutoDrop(module: ModuleRef): void;
export declare function _BinaryenModuleAllocateAndWrite(out: ArrayRef<u8>, module: ModuleRef, sourceMapUrl: StringRef): void;
export declare function _BinaryenModuleRead(input: ArrayRef<u8>, inputSize: usize): ModuleRef;
export declare function _BinaryenModuleInterpret(module: ModuleRef): void;
export declare function _BinaryenModuleAddDebugInfoFileName(module: ModuleRef, filename: StringRef): Index;
export declare function _BinaryenModuleGetDebugInfoFileName(module: ModuleRef, index: Index): StringRef;
export declare function _BinaryenModuleGetFeatures(module: ModuleRef): FeatureFlags;
export declare function _BinaryenModuleSetFeatures(module: ModuleRef, featureFlags: FeatureFlags): void;

export declare function _BinaryenAddCustomSection(module: ModuleRef, name: StringRef, contents: ArrayRef<u8>, contentsSize: Index): void;

export declare function _BinaryenExpressionGetSideEffects(expr: ExpressionRef, features: FeatureFlags): SideEffects;

export declare function _RelooperCreate(module: ModuleRef): RelooperRef;
export declare function _RelooperAddBlock(relooper: RelooperRef, code: ExpressionRef): RelooperBlockRef;
export declare function _RelooperAddBranch(from: RelooperBlockRef, to: RelooperBlockRef, condition: ExpressionRef, code: ExpressionRef): void;
export declare function _RelooperAddBlockWithSwitch(relooper: RelooperRef, code: ExpressionRef, condition: ExpressionRef): RelooperBlockRef;
export declare function _RelooperAddBranchForSwitch(from: RelooperBlockRef, to: RelooperBlockRef, indexes: ArrayRef<Index>, numIndexes: Index, code: ExpressionRef): void;
export declare function _RelooperRenderAndDispose(relooper: RelooperRef, entry: RelooperBlockRef, labelHelper: Index): ExpressionRef;

export declare function _ExpressionRunnerCreate(module: ModuleRef, flags: ExpressionRunnerFlags, maxDepth: Index, maxLoopIterations: Index): ExpressionRunnerRef;
export declare function _ExpressionRunnerSetLocalValue(runner: ExpressionRunnerRef, index: Index, value: ExpressionRef): bool;
export declare function _ExpressionRunnerSetGlobalValue(runner: ExpressionRunnerRef, name: StringRef, value: ExpressionRef): bool;
export declare function _ExpressionRunnerRunAndDispose(runner: ExpressionRunnerRef, expr: ExpressionRef): ExpressionRef;

export declare function _BinaryenGetOptimizeLevel(): i32;
export declare function _BinaryenSetOptimizeLevel(level: i32): void;
export declare function _BinaryenGetShrinkLevel(): i32;
export declare function _BinaryenSetShrinkLevel(level: i32): void;
export declare function _BinaryenGetDebugInfo(): bool;
export declare function _BinaryenSetDebugInfo(on: bool): void;
export declare function _BinaryenGetLowMemoryUnused(): bool;
export declare function _BinaryenSetLowMemoryUnused(on: bool): void;
export declare function _BinaryenGetFastMath(): bool;
export declare function _BinaryenSetFastMath(on: bool): void;
export declare function _BinaryenGetPassArgument(key: StringRef): StringRef;
export declare function _BinaryenSetPassArgument(key: StringRef, value: StringRef): void;
export declare function _BinaryenClearPassArguments(): void;
export declare function _BinaryenGetAlwaysInlineMaxSize(): Index;
export declare function _BinaryenSetAlwaysInlineMaxSize(size: Index): void;
export declare function _BinaryenGetFlexibleInlineMaxSize(): Index;
export declare function _BinaryenSetFlexibleInlineMaxSize(size: Index): void;
export declare function _BinaryenGetOneCallerInlineMaxSize(): Index;
export declare function _BinaryenSetOneCallerInlineMaxSize(size: Index): void;
export declare function _BinaryenGetAllowInliningFunctionsWithLoops(): bool;
export declare function _BinaryenSetAllowInliningFunctionsWithLoops(enabled: bool): void;

// Helpers

export declare function _malloc(size: usize): usize;
export declare function _free(ptr: usize): void;
export declare function __i32_store8(ptr: usize, value: number): void;
export declare function __i32_store16(ptr: usize, value: number): void;
export declare function __i32_store(ptr: usize, value: number): void;
export declare function __f32_store(ptr: usize, value: number): void;
export declare function __f64_store(ptr: usize, value: number): void;
export declare function __i32_load8_s(ptr: usize): i8;
export declare function __i32_load8_u(ptr: usize): u8;
export declare function __i32_load16_s(ptr: usize): i16;
export declare function __i32_load16_u(ptr: usize): u16;
export declare function __i32_load(ptr: usize): i32;
export declare function __f32_load(ptr: usize): f32;
export declare function __f64_load(ptr: usize): f64;

'''
'''--- src/glue/binaryen.js ---
/**
 * @fileoverview Binaryen glue code for JavaScript.
 * @license Apache-2.0
 */

const binaryen = global.binaryen || (global.binaryen = require("binaryen"));

module.exports = binaryen;

const { Module } = require("../module");

Module.prototype.toText = function toText(watFormat = true) {
  if (watFormat) {
    // NOTE: Conversion to StackIR can yield conversion artifacts like sequences
    // of unreachable statements not actually emitted by the compiler. Optimizing
    // StackIR removes these again, but may also suppress useless code emitted by
    // the compiler that's then no longer visible in tests. Both not ideal.
    return binaryen.wrapModule(this.ref).emitStackIR(/* optimize-stack-ir */ true);
  } else {
    return binaryen.wrapModule(this.ref).emitText();
  }
};

Module.prototype.toAsmjs = function toAsmjs() {
  return binaryen.wrapModule(this.ref).emitAsmjs();
};

'''
'''--- src/glue/js/collections.d.ts ---
/**
 * @fileoverview Collections glue code for TypeScript.
 * @license Apache-2.0
 */

declare function Map_keys<K,V>(map: Map<K,V>): K[];
declare function Map_values<K,V>(map: Map<K,V>): V[];
declare function Set_values<V>(set: Set<V>): V[];

'''
'''--- src/glue/js/collections.js ---
/**
 * @fileoverview Collections glue code for JavaScript.
 * @license Apache-2.0
 */

global.Map_keys = function Map_keys(map) {
  return Array.from(map.keys());
};

global.Map_values = function Map_values(map) {
  return Array.from(map.values());
};

global.Set_values = function Set_values(set) {
  return Array.from(set.values());
};

'''
'''--- src/glue/js/float.d.ts ---
/**
 * @fileoverview Floating point glue code for TypeScript.
 * @license Apache-2.0
 */

declare function f32_as_i32(value: f32): i32;
declare function i32_as_f32(value: i32): f32;
declare function f64_as_i64(value: f64): i64;
declare function i64_as_f64(value: i64): f64;

'''
'''--- src/glue/js/float.js ---
/**
 * @fileoverview Floating point glue code for JavaScript.
 * @license Apache-2.0
 */

/* eslint-disable no-undef */

const F64 = new Float64Array(1);
const F32 = new Float32Array(F64.buffer);
const I32 = new Int32Array(F64.buffer);

global.f32_as_i32 = function f32_as_i32(value) {
  F32[0] = value;
  return I32[0];
};

global.i32_as_f32 = function i32_as_f32(value) {
  I32[0] = value;
  return F32[0];
};

global.f64_as_i64 = function f64_as_i64(value) {
  F64[0] = value;
  return i64_new(I32[0], I32[1]);
};

global.i64_as_f64 = function i64_as_f64(value) {
  I32[0] = i64_low(value);
  I32[1] = i64_high(value);
  return F64[0];
};

'''
'''--- src/glue/js/i64.d.ts ---
/**
 * @fileoverview 64-bit integer glue code for TypeScript.
 * @license Apache-2.0
 */

declare type i64 = { __Long__: true }; // opaque

declare const i64_zero: i64;
declare const i64_one: i64;

declare function i64_is(value: unknown): value is i64;
declare function i64_new(lo: i32, hi?: i32): i64;
declare function i64_low(value: i64): i32;
declare function i64_high(value: i64): i32;

declare function i64_add(left: i64, right: i64): i64;
declare function i64_sub(left: i64, right: i64): i64;
declare function i64_mul(left: i64, right: i64): i64;
declare function i64_pow(left: i64, right: i64): i64;
declare function i64_div(left: i64, right: i64): i64;
declare function i64_div_u(left: i64, right: i64): i64;
declare function i64_rem(left: i64, right: i64): i64;
declare function i64_rem_u(left: i64, right: i64): i64;
declare function i64_and(left: i64, right: i64): i64;
declare function i64_or(left: i64, right: i64): i64;
declare function i64_xor(left: i64, right: i64): i64;
declare function i64_shl(left: i64, right: i64): i64;
declare function i64_shr(left: i64, right: i64): i64;
declare function i64_shr_u(left: i64, right: i64): i64;
declare function i64_not(value: i64): i64;

declare function i64_eq(left: i64, right: i64): boolean;
declare function i64_ne(left: i64, right: i64): boolean;
declare function i64_gt(left: i64, right: i64): boolean;

declare function i64_align(value: i64, alignment: i32): i64;

declare function i64_is_i8(value: i64): boolean;
declare function i64_is_i16(value: i64): boolean;
declare function i64_is_i32(value: i64): boolean;
declare function i64_is_u8(value: i64): boolean;
declare function i64_is_u16(value: i64): boolean;
declare function i64_is_u32(value: i64): boolean;
declare function i64_is_bool(value: i64): boolean;
declare function i64_is_f32(value: i64): boolean;
declare function i64_is_f64(value: i64): boolean;

declare function i64_to_f32(value: i64): f64;
declare function i64_to_f64(value: i64): f64;
declare function i64_to_string(value: i64, unsigned?: boolean): string;

'''
'''--- src/glue/js/i64.js ---
/**
 * @fileoverview 64-bit integer glue code for JavaScript.
 * @license Apache-2.0
 */

/* eslint-disable no-undef */

const Long = global.Long || require("long");

global.i64_zero    = Long.ZERO;
global.i64_one     = Long.ONE;
global.i64_neg_one = Long.fromInt(-1);

global.i64_is = function i64_is(value) {
  return Long.isLong(value);
};

global.i64_new = function i64_new(lo, hi) {
  return Long.fromBits(lo, hi);
};

global.i64_low = function i64_low(value) {
  return value.low;
};

global.i64_high = function i64_high(value) {
  return value.high;
};

global.i64_add = function i64_add(left, right) {
  return left.add(right);
};

global.i64_sub = function i64_sub(left, right) {
  return left.sub(right);
};

global.i64_mul = function i64_mul(left, right) {
  return left.mul(right);
};

global.i64_pow = function i64_pow(left, right) {
  var rightLo = right.low;
  var rightHi = right.high;
  if (rightHi <= 0) {
    if (rightHi < 0) {
      if (left.eq(global.i64_neg_one)) {
        return rightLo & 1 ? left : Long.ONE;
      }
      return left.eq(Long.ONE) ? left : Long.ZERO;
    }
    if (rightLo == 0) return Long.ONE;
    if (rightLo == 1) return left;
    if (rightLo == 2) return left.mul(left);
  }
  var result = Long.ONE;
  while (rightLo | rightHi) {
    if (rightLo & 1) result = result.mul(left);
    right = right.shru(1);
    left  = left.mul(left);
    rightLo = right.low;
    rightHi = right.high;
  }
  return result;
};

global.i64_div = function i64_div(left, right) {
  return left.div(right);
};

global.i64_div_u = function i64_div_u(left, right) {
  return left.toUnsigned().div(right.toUnsigned()).toSigned();
};

global.i64_rem = function i64_rem(left, right) {
  return left.mod(right);
};

global.i64_rem_u = function i64_rem_u(left, right) {
  return left.toUnsigned().mod(right.toUnsigned()).toSigned();
};

global.i64_and = function i64_and(left, right) {
  return left.and(right);
};

global.i64_or = function i64_or(left, right) {
  return left.or(right);
};

global.i64_xor = function i64_xor(left, right) {
  return left.xor(right);
};

global.i64_shl = function i64_shl(left, right) {
  return left.shl(right);
};

global.i64_shr = function i64_shr(left, right) {
  return left.shr(right);
};

global.i64_shr_u = function i64_shr_u(left, right) {
  return left.shru(right);
};

global.i64_not = function i64_not(value) {
  return value.not();
};

global.i64_eq = function i64_eq(left, right) {
  return left.eq(right);
};

global.i64_ne = function i64_ne(left, right) {
  return left.ne(right);
};

global.i64_gt = function i64_gt(left, right) {
  return left.gt(right);
};

global.i64_align = function i64_align(value, alignment) {
  assert(alignment && (alignment & (alignment - 1)) == 0);
  var mask = Long.fromInt(alignment - 1);
  return value.add(mask).and(mask.not());
};

global.i64_is_i8 = function i64_is_i8(value) {
  return value.high === 0 && (value.low >= 0 && value.low <= i8.MAX_VALUE)
      || value.high === -1 && (value.low >= i8.MIN_VALUE && value.low < 0);
};

global.i64_is_i16 = function i64_is_i16(value) {
  return value.high === 0 && (value.low >= 0 && value.low <= i16.MAX_VALUE)
      || value.high === -1 && (value.low >= i16.MIN_VALUE && value.low < 0);
};

global.i64_is_i32 = function i64_is_i32(value) {
  return (value.high === 0 && value.low >= 0)
      || (value.high === -1 && value.low < 0);
};

global.i64_is_u8 = function i64_is_u8(value) {
  return value.high === 0 && (value.low >>> 0) <= u8.MAX_VALUE;
};

global.i64_is_u16 = function i64_is_u16(value) {
  return value.high === 0 && (value.low >>> 0) <= u16.MAX_VALUE;
};

global.i64_is_u32 = function i64_is_u32(value) {
  return value.high === 0;
};

global.i64_is_bool = function i64_is_bool(value) {
  return (value.high | (value.low & ~1)) === 0;
};

const minSafeF32 = Long.fromNumber(f32.MIN_SAFE_INTEGER);
const maxSafeF32 = Long.fromNumber(f32.MAX_SAFE_INTEGER);

global.i64_is_f32 = function i64_is_f32(value) {
  return value.gte(minSafeF32) && value.lte(maxSafeF32);
};

const minSafeF64 = Long.fromNumber(f64.MIN_SAFE_INTEGER);
const maxSafeF64 = Long.fromNumber(f64.MAX_SAFE_INTEGER);

global.i64_is_f64 = function i64_is_f64(value) {
  return value.gte(minSafeF64) && value.lte(maxSafeF64);
};

global.i64_to_f32 = function i64_to_f32(value) {
  return global.Math.fround(value.toNumber());
};

global.i64_to_f64 = function i64_to_f64(value) {
  return value.toNumber();
};

global.i64_to_string = function i64_to_string(value, unsigned) {
  return unsigned ? value.toUnsigned().toString() : value.toString();
};

'''
'''--- src/glue/js/index.ts ---
/**
 * @fileoverview JavaScript glue code.
 * @license Apache-2.0
 */

import "../../../std/portable/index";
import "../binaryen";
import "./float";
import "./i64";
import "./collections";

'''
'''--- src/glue/js/node.d.ts ---
/**
 * @fileoverview Node.js glue code for TypeScript.
 * @license Apache-2.0
 */

declare const global: Record<string,unknown>;
declare function require(name: string): unknown;
declare namespace console {
  function log(...args: unknown[]): void;
}

'''
'''--- src/glue/tsconfig.json ---
{
  "extends": "../tsconfig.json",
  "include": [
    "./**/*.ts"
  ],
  "exclude": [
    "./wasm/**"
  ]
}

'''
'''--- src/glue/wasm/collections.ts ---
/**
 * @fileoverview Collections glue code for WebAssembly.
 * @license Apache-2.0
 */

/* eslint-disable @typescript-eslint/no-unused-vars */

// @ts-ignore: decorator
@global @inline
function Map_keys<K,V>(map: Map<K,V>): K[] {
  return map.keys(); // preliminary
}

// @ts-ignore: decorator
@global @inline
function Map_values<K,V>(map: Map<K,V>): V[] {
  return map.values(); // preliminary
}

// @ts-ignore: decorator
@global @inline
function Set_values<V>(set: Set<V>): V[] {
  return set.values(); // preliminary
}

'''
'''--- src/glue/wasm/float.ts ---
/**
 * @fileoverview Floating point glue code for WebAssembly.
 * @license Apache-2.0
 */

/* eslint-disable @typescript-eslint/no-unused-vars */

// @ts-ignore: decorator
@global @inline
function f32_as_i32(value: f32): i32 {
  return reinterpret<i32>(value);
}

// @ts-ignore: decorator
@global @inline
function i32_as_f32(value: i32): f32 {
  return reinterpret<f32>(value);
}

// @ts-ignore: decorator
@global @inline
function f64_as_i64(value: f64): i64 {
  return reinterpret<i64>(value);
}

// @ts-ignore: decorator
@global @inline
function i64_as_f64(value: i64): f64 {
  return reinterpret<f64>(value);
}

'''
'''--- src/glue/wasm/i64.ts ---
/**
 * @fileoverview 64-bit integer glue code for WebAssembly.
 * @license Apache-2.0
 */

/* eslint-disable @typescript-eslint/no-unused-vars */

// @ts-ignore: decorator
@global const i64_zero: i64 = 0;

// @ts-ignore: decorator
@global const i64_one: i64 = 1;

// @ts-ignore: decorator
@global const i64_neg_one: i64 = -1;

// @ts-ignore: decorator
@global @inline
function i64_is<T>(value: T): bool {
  return isInteger<T>() && sizeof<T>() == 8;
}

// @ts-ignore: decorator
@global @inline
function i64_new(lo: i32, hi: i32 = 0): i64 {
  return <i64><u32>lo | (<i64>hi << 32);
}

// @ts-ignore: decorator
@global @inline
function i64_low(value: i64): i32 {
  return <i32>value;
}

// @ts-ignore: decorator
@global @inline
function i64_high(value: i64): i32 {
  return <i32>(value >>> 32);
}

// @ts-ignore: decorator
@global @inline
function i64_add(left: i64, right: i64): i64 {
  return left + right;
}

// @ts-ignore: decorator
@global @inline
function i64_sub(left: i64, right: i64): i64 {
  return left - right;
}

// @ts-ignore: decorator
@global @inline
function i64_mul(left: i64, right: i64): i64 {
  return left * right;
}

// @ts-ignore: decorator
@global
function i64_pow(left: i64, right: i64): i64 {
  if (right <= 0) {
    if (left == -1) return select<i64>(-1, 1, right & 1);
    return i64(right == 0) | i64(left == 1);
  }
  if (right == 1) return left;
  if (right == 2) return left * left;
  var result: i64 = 1;
  while (right) {
    if (right & 1) result *= left;
    right >>>= 1;
    left *= left;
  }
  return result;
}

// @ts-ignore: decorator
@global @inline
function i64_div(left: i64, right: i64): i64 {
  return left / right;
}

// @ts-ignore: decorator
@global @inline
function i64_div_u(left: i64, right: i64): i64 {
  return <u64>left / <u64>right;
}

// @ts-ignore: decorator
@global @inline
function i64_rem(left: i64, right: i64): i64 {
  return left % right;
}

// @ts-ignore: decorator
@global @inline
function i64_rem_u(left: i64, right: i64): i64 {
  return <u64>left % <u64>right;
}

// @ts-ignore: decorator
@global @inline
function i64_and(left: i64, right: i64): i64 {
  return left & right;
}

// @ts-ignore: decorator
@global @inline
function i64_or(left: i64, right: i64): i64 {
  return left | right;
}

// @ts-ignore: decorator
@global @inline
function i64_xor(left: i64, right: i64): i64 {
  return left ^ right;
}

// @ts-ignore: decorator
@global @inline
function i64_shl(left: i64, right: i64): i64 {
  return left << right;
}

// @ts-ignore: decorator
@global @inline
function i64_shr(left: i64, right: i64): i64 {
  return left >> right;
}

// @ts-ignore: decorator
@global @inline
function i64_shr_u(left: i64, right: i64): i64 {
  return left >>> right;
}

// @ts-ignore: decorator
@global @inline
function i64_not(value: i64): i64 {
  return ~value;
}

// @ts-ignore: decorator
@global @inline
function i64_eq(left: i64, right: i64): bool {
  return left == right;
}

// @ts-ignore: decorator
@global @inline
function i64_ne(left: i64, right: i64): bool {
  return left != right;
}

// @ts-ignore: decorator
@global @inline
function i64_gt(left: i64, right: i64): bool {
  return left > right;
}

// @ts-ignore: decorator
@global @inline
function i64_align(value: i64, alignment: i64): i64 {
  var mask: i64 = alignment - 1;
  assert(alignment && (alignment & mask) == 0);
  return (value + mask) & ~mask;
}

// @ts-ignore: decorator
@global @inline
function i64_is_i8(value: i64): bool {
  return value >= i8.MIN_VALUE && value <= <i64>i8.MAX_VALUE;
}

// @ts-ignore: decorator
@global @inline
function i64_is_i16(value: i64): bool {
  return value >= i16.MIN_VALUE && value <= <i64>i16.MAX_VALUE;
}

// @ts-ignore: decorator
@global @inline
function i64_is_i32(value: i64): bool {
  return value >= i32.MIN_VALUE && value <= <i64>i32.MAX_VALUE;
}

// @ts-ignore: decorator
@global @inline
function i64_is_u8(value: i64): bool {
  return <u64>value <= <u64>u8.MAX_VALUE;
}

// @ts-ignore: decorator
@global @inline
function i64_is_u16(value: i64): bool {
  return <u64>value <= <u64>u16.MAX_VALUE;
}

// @ts-ignore: decorator
@global @inline
function i64_is_u32(value: i64): bool {
  return <u64>value <= <u64>u32.MAX_VALUE;
}

// @ts-ignore: decorator
@global @inline
function i64_is_bool(value: i64): bool {
  return (value & ~1) == 0;
}

// @ts-ignore: decorator
@global @inline
function i64_is_f32(value: i64): bool {
  return value >= <i64>f32.MIN_SAFE_INTEGER && value <= <i64>f32.MAX_SAFE_INTEGER;
}

// @ts-ignore: decorator
@global @inline
function i64_is_f64(value: i64): bool {
  return value >= <i64>f64.MIN_SAFE_INTEGER && value <= <i64>f64.MAX_SAFE_INTEGER;
}

// @ts-ignore: decorator
@global @inline
function i64_to_f32(value: i64): f32 {
  return <f32>value;
}

// @ts-ignore: decorator
@global @inline
function i64_to_f64(value: i64): f64 {
  return <f64>value;
}

// @ts-ignore: decorator
@global @inline
function i64_to_string(value: i64, unsigned: bool = false): string {
  return unsigned ? u64(value).toString() : value.toString();
}

'''
'''--- src/glue/wasm/index.ts ---
/**
 * @fileoverview WebAssembly glue code.
 * @license Apache-2.0
 */

import "./i64";
import "./float";
import "./collections";

'''
'''--- src/glue/wasm/tsconfig.json ---
{
  "extends": "../../../std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- src/index.ts ---
/**
 * @license
 * Copyright 2020 Daniel Wirtz / The AssemblyScript Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview The C-like and re-exported public compiler interface.
 *
 * The intended way to consume the compiler sources is to import this
 * file, which again exports all relevant functions, classes and constants
 * as a flat namespace.
 *
 * Note though that the compiler sources are written in "portable
 * AssemblyScript" that can be compiled to both JavaScript with tsc and
 * to WebAssembly with asc, and as such require additional glue code
 * depending on the target.
 *
 * When compiling to JavaScript `glue/js/index.js` must be included.
 * When compiling to WebAssembly `glue/wasm/index.ts` must be included.
 */

import { Target, Feature } from "./common";
import { Compiler, Options } from "./compiler";
import { IDLBuilder, TSDBuilder } from "./definitions";
import { DiagnosticMessage, DiagnosticCategory, formatDiagnosticMessage } from "./diagnostics";
import { Module } from "./module";
import { Program } from "./program";

// Options

/** Creates a new set of compiler options. */
export function newOptions(): Options {
  return new Options();
}

/** Sets the `target` option. */
export function setTarget(options: Options, target: Target): void {
  options.target = target;
}

/** Sets the `noAssert` option. */
export function setNoAssert(options: Options, noAssert: bool): void {
  options.noAssert = noAssert;
}

/** Sets the `exportMemory` option. */
export function setExportMemory(options: Options, exportMemory: bool): void {
  options.exportMemory = exportMemory;
}

/** Sets the `importMemory` option. */
export function setImportMemory(options: Options, importMemory: bool): void {
  options.importMemory = importMemory;
}

/** Sets the `initialMemory` option. */
export function setInitialMemory(options: Options, initialMemory: u32): void {
  options.initialMemory = initialMemory;
}

/** Sets the `maximumMemory` option. */
export function setMaximumMemory(options: Options, maximumMemory: u32): void {
  options.maximumMemory = maximumMemory;
}

/** Sets the `sharedMemory` option. */
export function setSharedMemory(options: Options, sharedMemory: bool): void {
  options.sharedMemory = sharedMemory;
}

/** Sets the `importTable` option. */
export function setImportTable(options: Options, importTable: bool): void {
  options.importTable = importTable;
}

/** Sets the `exportTable` option. */
export function setExportTable(options: Options, exportTable: bool): void {
  options.exportTable = exportTable;
}

/** Sets the `sourceMap` option. */
export function setSourceMap(options: Options, sourceMap: bool): void {
  options.sourceMap = sourceMap;
}

/** Sets the `memoryBase` option. */
export function setMemoryBase(options: Options, memoryBase: u32): void {
  options.memoryBase = memoryBase;
}

/** Sets the `tableBase` option. */
export function setTableBase(options: Options, tableBase: u32): void {
  options.tableBase = tableBase;
}

/** Sets a 'globalAliases' value. */
export function setGlobalAlias(options: Options, alias: string, name: string): void {
  var globalAliases = options.globalAliases;
  if (!globalAliases) options.globalAliases = globalAliases = new Map();
  globalAliases.set(alias, name);
}

/** Sets the `explicitStart` option. */
export function setExplicitStart(options: Options, explicitStart: bool): void {
  options.explicitStart = explicitStart;
}

/** Sets the `noUnsafe` option. */
export function setNoUnsafe(options: Options, noUnsafe: bool): void {
  options.noUnsafe = noUnsafe;
}

/** Sets the `lowMemoryLimit` option. */
export function setLowMemoryLimit(options: Options, lowMemoryLimit: i32): void {
  options.lowMemoryLimit = lowMemoryLimit;
}

/** Sets the `exportRuntime` option. */
export function setExportRuntime(options: Options, exportRuntime: bool): void {
  options.exportRuntime = exportRuntime;
}

/** Default stack size. */
export const DEFAULT_STACK_SIZE = 16384;

/** Sets the `stackSize` option. */
export function setStackSize(options: Options, stackSize: i32): void {
  options.stackSize = stackSize;
}

/** Sets the bundle semantic version. */
export function setBundleVersion(
  options: Options,
  bundleMajorVersion: i32,
  bundleMinorVersion: i32,
  bundlePatchVersion: i32,
): void {
  options.bundleMajorVersion = bundleMajorVersion;
  options.bundleMinorVersion = bundleMinorVersion;
  options.bundlePatchVersion = bundlePatchVersion;
}

/** Sign extension operations. */
export const FEATURE_SIGN_EXTENSION = Feature.SIGN_EXTENSION;
/** Mutable global imports and exports. */
export const FEATURE_MUTABLE_GLOBALS = Feature.MUTABLE_GLOBALS;
/** Non-trapping float to int conversion operations. */
export const FEATURE_NONTRAPPING_F2I = Feature.NONTRAPPING_F2I;
/** Bulk memory operations. */
export const FEATURE_BULK_MEMORY = Feature.BULK_MEMORY;
/** SIMD types and operations. */
export const FEATURE_SIMD = Feature.SIMD;
/** Threading and atomic operations. */
export const FEATURE_THREADS = Feature.THREADS;
/** Exception handling operations. */
export const FEATURE_EXCEPTION_HANDLING = Feature.EXCEPTION_HANDLING;
/** Tail call operations. */
export const FEATURE_TAIL_CALLS = Feature.TAIL_CALLS;
/** Reference types. */
export const FEATURE_REFERENCE_TYPES = Feature.REFERENCE_TYPES;
/** Multi value types. */
export const FEATURE_MULTI_VALUE = Feature.MULTI_VALUE;
/** Garbage collection. */
export const FEATURE_GC = Feature.GC;
/** Memory64. */
export const FEATURE_MEMORY64 = Feature.MEMORY64;

/** Enables a specific feature. */
export function enableFeature(options: Options, feature: Feature): void {
  options.features |= feature;
}

/** Disables a specific feature. */
export function disableFeature(options: Options, feature: Feature): void {
  options.features &= ~feature;
}

/** Gives the compiler a hint at the optimize levels that will be used later on. */
export function setOptimizeLevelHints(options: Options, optimizeLevel: i32, shrinkLevel: i32): void {
  options.optimizeLevelHint = optimizeLevel;
  options.shrinkLevelHint = shrinkLevel;
}

/** Sets the `pedantic` option. */
export function setPedantic(options: Options, pedantic: bool): void {
  options.pedantic = pedantic;
}

// Program

/** Creates a new Program. */
export function newProgram(options: Options): Program {
  return new Program(options);
}

/** Obtains the next diagnostic message. Returns `null` once complete. */
export function nextDiagnostic(program: Program): DiagnosticMessage | null {
  return program.diagnosticsOffset < program.diagnostics.length
    ? program.diagnostics[program.diagnosticsOffset++]
    : null;
}

/** Obtains the source of the given file. */
export function getSource(program: Program, internalPath: string): string | null {
  return program.getSource(internalPath);
}

/** Formats a diagnostic message to a string. */
export { formatDiagnosticMessage as formatDiagnostic };

/** Tests whether a diagnostic is informatory. */
export function isInfo(message: DiagnosticMessage): bool {
  return message.category == DiagnosticCategory.INFO;
}

/** Tests whether a diagnostic is a warning. */
export function isWarning(message: DiagnosticMessage): bool {
  return message.category == DiagnosticCategory.WARNING;
}

/** Tests whether a diagnostic is an error. */
export function isError(message: DiagnosticMessage): bool {
  return message.category == DiagnosticCategory.ERROR;
}

// Parser

/** Parses a source file. If `parser` has been omitted a new one is created. */
export function parse(
  /** Program reference. */
  program: Program,
  /** Source text of the file, or `null` to indicate not found. */
  text: string | null,
  /** Normalized path of the file. */
  path: string,
  /** Whether this is an entry file. */
  isEntry: bool = false
): void {
  program.parser.parseFile(text, path, isEntry);
}

/** Obtains the next required file's path. Returns `null` once complete. */
export function nextFile(program: Program): string | null {
  return program.parser.nextFile();
}

/** Obtains the path of the dependee of a given imported file. */
export function getDependee(program: Program, file: string): string | null {
  return program.parser.getDependee(file);
}

// Compiler

/** Initializes the program pre-emptively for transform hooks. */
export function initializeProgram(program: Program): void {
  program.initialize();
}

/** Compiles the parsed sources to a module. */
export function compile(program: Program): Module {
  program.parser.finish();
  return new Compiler(program).compile();
}

/** Builds WebIDL definitions for the specified program. */
export function buildIDL(program: Program): string {
  return IDLBuilder.build(program);
}

/** Builds TypeScript definitions for the specified program. */
export function buildTSD(program: Program): string {
  return TSDBuilder.build(program);
}

// Full API
export * from "./ast";
export * from "./common";
export * from "./compiler";
export * from "./definitions";
export * from "./diagnostics";
export * from "./flow";
export * from "./module";
export * from "./parser";
export * from "./program";
export * from "./resolver";
export * from "./tokenizer";
export * from "./types";
export * from "./extra/ast";
import * as util from "./util/index";
export { util };

'''
'''--- src/module.ts ---
/**
 * @fileoverview A thin wrapper around Binaryen's C-API.
 *
 * The AssemblyScript compiler utilizes Binaryen's C-API directly. Even
 * though it currently imports binaryen.js, none of the JS APIs it
 * provides are used.
 *
 * @license Apache-2.0
 */

import { BuiltinNames } from "./builtins";
import { Target } from "./common";
import * as binaryen from "./glue/binaryen";

/** A Binaryen-compatible index. */
export type Index = binaryen.Index;
/** Reference to a Binaryen-compatible string. */
export type StringRef = binaryen.StringRef;
/** Reference to a Binaryen module. */
export type ModuleRef = binaryen.ModuleRef;
/** Reference to a Binaryen function. */
export type FunctionRef = binaryen.FunctionRef;
/** Reference to a Binaryen expression. */
export type ExpressionRef = binaryen.ExpressionRef;
/** Reference to a Binaryen global. */
export type GlobalRef = binaryen.GlobalRef;
/** Reference to a Binaryen tag. */
export type TagRef = binaryen.TagRef;
/** Reference to a Binaryen import. */
export type ImportRef = binaryen.ImportRef;
/** Reference to a Binaryen export. */
export type ExportRef = binaryen.ExportRef;
/** Reference to a Binaryen relooper. */
export type RelooperRef = binaryen.RelooperRef;
/** Reference to a Binaryen relooper block. */
export type RelooperBlockRef = binaryen.RelooperBlockRef;

// The following constants must be updated by running scripts/update-constants.
// This is necessary because the functions are not yet callable with Binaryen
// compiled to WebAssembly, requiring awaiting the ready promise first. Note
// that this essentially fixes the compiler to specific versions of Binaryen
// sometimes, because these constants can differ between Binaryen versions.

/** Reference to a Binaryen type. */
export type TypeRef = binaryen.TypeRef;
export namespace TypeRef {
  export const None: TypeRef = 0 /* _BinaryenTypeNone */;
  export const Unreachable: TypeRef = 1 /* _BinaryenTypeUnreachable */;
  export const I32: TypeRef = 2 /* _BinaryenTypeInt32 */;
  export const I64: TypeRef = 3 /* _BinaryenTypeInt64 */;
  export const F32: TypeRef = 4 /* _BinaryenTypeFloat32 */;
  export const F64: TypeRef = 5 /* _BinaryenTypeFloat64 */;
  export const V128: TypeRef = 6 /* _BinaryenTypeVec128 */;
  export const Funcref: TypeRef = 7 /* _BinaryenTypeFuncref */;
  export const Externref: TypeRef = 8 /* _BinaryenTypeExternref */;
  export const Anyref: TypeRef = 9 /* _BinaryenTypeAnyref */;
  export const Eqref: TypeRef = 10 /* _BinaryenTypeEqref */;
  export const I31ref: TypeRef = 11 /* _BinaryenTypeI31ref */;
  export const Dataref: TypeRef = 12 /* _BinaryenTypeDataref */;
  export const Auto: TypeRef = -1 /* _BinaryenTypeAuto */;
}

/** Binaryen feature constants. */
export enum FeatureFlags {
  MVP = 0 /* _BinaryenFeatureMVP */,
  Atomics = 1 /* _BinaryenFeatureAtomics */,
  MutableGloabls = 2 /* _BinaryenFeatureMutableGlobals */,
  NontrappingFPToInt = 4 /* _BinaryenFeatureNontrappingFPToInt */,
  SIMD128 = 8 /* _BinaryenFeatureSIMD128 */,
  BulkMemory = 16 /* _BinaryenFeatureBulkMemory */,
  SignExt = 32 /* _BinaryenFeatureSignExt */,
  ExceptionHandling = 64 /* _BinaryenFeatureExceptionHandling */,
  TailCall = 128 /* _BinaryenFeatureTailCall */,
  ReferenceTypes = 256 /* _BinaryenFeatureReferenceTypes */,
  MultiValue = 512 /* _BinaryenFeatureMultivalue */,
  GC = 1024 /* _BinaryenFeatureGC */,
  Memory64 = 2048 /* _BinaryenFeatureMemory64 */,
  TypedFunctionReferences  = 4096 /* _BinaryenTypedFunctionReferences */,
  All = 8191 /* _BinaryenFeatureAll */
}

/** Binaryen expression id constants. */
export enum ExpressionId {
  Invalid = 0 /* _BinaryenInvalidId */,
  Block = 1 /* _BinaryenBlockId */,
  If = 2 /* _BinaryenIfId */,
  Loop = 3 /* _BinaryenLoopId */,
  Break = 4 /* _BinaryenBreakId */,
  Switch = 5 /* _BinaryenSwitchId */,
  Call = 6 /* _BinaryenCallId */,
  CallIndirect = 7 /* _BinaryenCallIndirectId */,
  LocalGet = 8 /* _BinaryenLocalGetId */,
  LocalSet = 9 /* _BinaryenLocalSetId */,
  GlobalGet = 10 /* _BinaryenGlobalGetId */,
  GlobalSet = 11 /* _BinaryenGlobalSetId */,
  Load = 12 /* _BinaryenLoadId */,
  Store = 13 /* _BinaryenStoreId */,
  Const = 14 /* _BinaryenConstId */,
  Unary = 15 /* _BinaryenUnaryId */,
  Binary = 16 /* _BinaryenBinaryId */,
  Select = 17 /* _BinaryenSelectId */,
  Drop = 18 /* _BinaryenDropId */,
  Return = 19 /* _BinaryenReturnId */,
  MemorySize = 20 /* _BinaryenMemorySizeId */,
  MemoryGrow = 21 /* _BinaryenMemoryGrowId */,
  Nop = 22 /* _BinaryenNopId */,
  Unreachable = 23 /* _BinaryenUnreachableId */,
  AtomicRMW = 24 /* _BinaryenAtomicRMWId */,
  AtomicCmpxchg = 25 /* _BinaryenAtomicCmpxchgId */,
  AtomicWait = 26 /* _BinaryenAtomicWaitId */,
  AtomicNotify = 27 /* _BinaryenAtomicNotifyId */,
  AtomicFence = 28 /* _BinaryenAtomicFenceId */,
  SIMDExtract = 29 /* _BinaryenSIMDExtractId */,
  SIMDReplace = 30 /* _BinaryenSIMDReplaceId */,
  SIMDShuffle = 31 /* _BinaryenSIMDShuffleId */,
  SIMDTernary = 32 /* _BinaryenSIMDTernaryId */,
  SIMDShift = 33 /* _BinaryenSIMDShiftId */,
  SIMDLoad = 34 /* _BinaryenSIMDLoadId */,
  SIMDLoadStoreLane = 35 /* _BinaryenSIMDLoadStoreLaneId */,
  MemoryInit = 36 /* _BinaryenMemoryInitId */,
  DataDrop = 37 /* _BinaryenDataDropId */,
  MemoryCopy = 38 /* _BinaryenMemoryCopyId */,
  MemoryFill = 39 /* _BinaryenMemoryFillId */,
  Pop = 40 /* _BinaryenPopId */,
  RefNull = 41 /* _BinaryenRefNullId */,
  RefIs = 42 /* _BinaryenRefIsId */,
  RefFunc = 43 /* _BinaryenRefFuncId */,
  RefEq = 44 /* _BinaryenRefEqId */,
  Try = 45 /* _BinaryenTryId */,
  Throw = 46 /* _BinaryenThrowId */,
  Rethrow = 47 /* _BinaryenRethrowId */,
  TupleMake = 48 /* _BinaryenTupleMakeId */,
  TupleExtract = 49 /* _BinaryenTupleExtractId */,
  I31New = 50 /* _BinaryenI31NewId */,
  I31Get = 51 /* _BinaryenI31GetId */,
  CallRef = 52 /* _BinaryenCallRefId */,
  RefTest = 53 /* _BinaryenRefTestId */,
  RefCast = 54 /* _BinaryenRefCastId */,
  BrOn = 55 /* _BinaryenBrOnId */,
  RttCanon = 56 /* _BinaryenRttCanonId */,
  RttSub = 57 /* _BinaryenRttSubId */,
  StructNew = 58 /* _BinaryenStructNewId */,
  StructGet = 59 /* _BinaryenStructGetId */,
  StructSet = 60 /* _BinaryenStructSetId */,
  ArrayNew = 61 /* _BinaryenArrayNewId */,
  ArrayGet = 62 /* _BinaryenArrayGetId */,
  ArraySet = 63 /* _BinaryenArraySetId */,
  ArrayLen = 64 /* _BinaryenArrayLenId */,
  RefAs = 65 /* _BinaryenRefAsId */
}

/** Binaryen external kind constants. */
export enum ExternalKind {
  Function = 0 /* _BinaryenExternalFunction */,
  Table = 1 /* _BinaryenExternalTable */,
  Memory = 2 /* _BinaryenExternalMemory */,
  Global = 3 /* _BinaryenExternalGlobal */,
  Tag = 4 /* _BinaryenExternalTag */
}

/** Binaryen unary operation constants. */
export enum UnaryOp {
  /** i32.clz */
  ClzI32 = 0 /* _BinaryenClzInt32 */,
  /** i64.clz */
  ClzI64 = 1 /* _BinaryenClzInt64 */,
  /** i32.ctz */
  CtzI32 = 2 /* _BinaryenCtzInt32 */,
  /** i64.ctz */
  CtzI64 = 3 /* _BinaryenCtzInt64 */,
  /** i32.popcnt */
  PopcntI32 = 4 /* _BinaryenPopcntInt32 */,
  /** i64.popcnt */
  PopcntI64 = 5 /* _BinaryenPopcntInt64 */,
  /** f32.neg */
  NegF32 = 6 /* _BinaryenNegFloat32 */,
  /** f64.neg */
  NegF64 = 7 /* _BinaryenNegFloat64 */,
  /** f32.abs */
  AbsF32 = 8 /* _BinaryenAbsFloat32 */,
  /** f64.abs */
  AbsF64 = 9 /* _BinaryenAbsFloat64 */,
  /** f32.ceil */
  CeilF32 = 10 /* _BinaryenCeilFloat32 */,
  /** f64.ceil */
  CeilF64 = 11 /* _BinaryenCeilFloat64 */,
  /** f32.floor */
  FloorF32 = 12 /* _BinaryenFloorFloat32 */,
  /** f64.floor */
  FloorF64 = 13 /* _BinaryenFloorFloat64 */,
  /** f32.trunc */
  TruncF32 = 14 /* _BinaryenTruncFloat32 */,
  /** f64.trunc */
  TruncF64 = 15 /* _BinaryenTruncFloat64 */,
  /** f32.nearest */
  NearestF32 = 16 /* _BinaryenNearestFloat32 */,
  /** f64.nearest */
  NearestF64 = 17 /* _BinaryenNearestFloat64 */,
  /** f32.sqrt */
  SqrtF32 = 18 /* _BinaryenSqrtFloat32 */,
  /** f64.sqrt */
  SqrtF64 = 19 /* _BinaryenSqrtFloat64 */,
  /** i32.eqz */
  EqzI32 = 20 /* _BinaryenEqZInt32 */,
  /** i64.eqz */
  EqzI64 = 21 /* _BinaryenEqZInt64 */,
  /** i64.extend_i32_s */
  ExtendI32ToI64 = 22 /* _BinaryenExtendSInt32 */,
  /** i64.extend_i32_u */
  ExtendU32ToU64 = 23 /* _BinaryenExtendUInt32 */,
  /** i32.wrap_i64 */
  WrapI64ToI32 = 24 /* _BinaryenWrapInt64 */,
  /** i32.trunc_f32_s */
  TruncF32ToI32 = 25 /* _BinaryenTruncSFloat32ToInt32 */,
  /** i64.trunc_f32_s */
  TruncF32ToI64 = 26 /* _BinaryenTruncSFloat32ToInt64 */,
  /** i32.trunc_f32_u */
  TruncF32ToU32 = 27 /* _BinaryenTruncUFloat32ToInt32 */,
  /** i64.trunc_f32_u */
  TruncF32ToU64 = 28 /* _BinaryenTruncUFloat32ToInt64 */,
  /** i32.trunc_f64_s */
  TruncF64ToI32 = 29 /* _BinaryenTruncSFloat64ToInt32 */,
  /** i64.trunc_f64_s */
  TruncF64ToI64 = 30 /* _BinaryenTruncSFloat64ToInt64 */,
  /** i32.trunc_f64_u */
  TruncF64ToU32 = 31 /* _BinaryenTruncUFloat64ToInt32 */,
  /** i64.trunc_f64_u */
  TruncF64ToU64 = 32 /* _BinaryenTruncUFloat64ToInt64 */,
  /** i32.reinterpret_f32 */
  ReinterpretF32ToI32 = 33 /* _BinaryenReinterpretFloat32 */,
  /** i64.reinterpret_f64 */
  ReinterpretF64ToI64 = 34 /* _BinaryenReinterpretFloat64 */,
  /** f32.convert_i32_s */
  ConvertI32ToF32 = 35 /* _BinaryenConvertSInt32ToFloat32 */,
  /** f64.convert_i32_s */
  ConvertI32ToF64 = 36 /* _BinaryenConvertSInt32ToFloat64 */,
  /** f32.convert_i32_u */
  ConvertU32ToF32 = 37 /* _BinaryenConvertUInt32ToFloat32 */,
  /** f64.convert_i32_u */
  ConvertU32ToF64 = 38 /* _BinaryenConvertUInt32ToFloat64 */,
  /** f32.convert_i64_s */
  ConvertI64ToF32 = 39 /* _BinaryenConvertSInt64ToFloat32 */,
  /** f64.convert_i64_s */
  ConvertI64ToF64 = 40 /* _BinaryenConvertSInt64ToFloat64 */,
  /** f32.convert_i64_u */
  ConvertU64ToF32 = 41 /* _BinaryenConvertUInt64ToFloat32 */,
  /** f64.convert_i64_u */
  ConvertU64ToF64 = 42 /* _BinaryenConvertUInt64ToFloat64 */,
  /** f64.promote.f32 */
  PromoteF32ToF64 = 43 /* _BinaryenPromoteFloat32 */,
  /** f32.demote_f64 */
  DemoteF64ToF32 = 44 /* _BinaryenDemoteFloat64 */,
  /** f32.reinterpret_i32 */
  ReinterpretI32ToF32 = 45 /* _BinaryenReinterpretInt32 */,
  /** f64.reinterpret_i64 */
  ReinterpretI64ToF64 = 46 /* _BinaryenReinterpretInt64 */,

  // see: https://github.com/WebAssembly/sign-extension-ops

  /** i32.extend8_s */
  Extend8I32 = 47 /* _BinaryenExtendS8Int32 */,
  /** i32.extend16_s */
  Extend16I32 = 48 /* _BinaryenExtendS16Int32 */,
  /** i64.extend8_s */
  Extend8I64 = 49 /* _BinaryenExtendS8Int64 */,
  /** i64.extend16_s */
  Extend16I64 = 50 /* _BinaryenExtendS16Int64 */,
  /** i64.extend32_s (i64 in, i64 out) */
  Extend32I64 = 51 /* _BinaryenExtendS32Int64 */,

  // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions

  /** i32.trunc_sat_f32_s */
  TruncSatF32ToI32 = 52 /* _BinaryenTruncSatSFloat32ToInt32 */,
  /** i32.trunc_sat_f32_u */
  TruncSatF32ToU32 = 53 /* _BinaryenTruncSatUFloat32ToInt32 */,
  /** i32.trunc_sat_f64_s */
  TruncSatF64ToI32 = 54 /* _BinaryenTruncSatSFloat64ToInt32 */,
  /** i32.trunc_sat_f64_u */
  TruncSatF64ToU32 = 55 /* _BinaryenTruncSatUFloat64ToInt32 */,
  /** i64.trunc_sat_f32_s */
  TruncSatF32ToI64 = 56 /* _BinaryenTruncSatSFloat32ToInt64 */,
  /** i64.trunc_sat_f32_u */
  TruncSatF32ToU64 = 57 /* _BinaryenTruncSatUFloat32ToInt64 */,
  /** i64.trunc_sat_f64_s */
  TruncSatF64ToI64 = 58 /* _BinaryenTruncSatSFloat64ToInt64 */,
  /** i64.trunc_sat_f64_u */
  TruncSatF64ToU64 = 59 /* _BinaryenTruncSatUFloat64ToInt64 */,

  // see: https://github.com/WebAssembly/simd

  /** i8x16.splat */
  SplatI8x16 = 60 /* _BinaryenSplatVecI8x16 */,
  /** i16x8.splat */
  SplatI16x8 = 61 /* _BinaryenSplatVecI16x8 */,
  /** i32x4.splat */
  SplatI32x4 = 62 /* _BinaryenSplatVecI32x4 */,
  /** i64x2.splat */
  SplatI64x2 = 63 /* _BinaryenSplatVecI64x2 */,
  /** f32x4.splat */
  SplatF32x4 = 64 /* _BinaryenSplatVecF32x4 */,
  /** f64x2.splat */
  SplatF64x2 = 65 /* _BinaryenSplatVecF64x2 */,
  /** v128.not */
  NotV128 = 66 /* _BinaryenNotVec128 */,
  /** v128.any_true */
  AnyTrueV128 = 67 /* _BinaryenAnyTrueVec128 */,
  /** i8x16.abs */
  AbsI8x16 = 68 /* _BinaryenAbsVecI8x16 */,
  /** i8x16.neg */
  NegI8x16 = 69 /* _BinaryenNegVecI8x16 */,
  /** i8x16.all_true */
  AllTrueI8x16 = 70 /* _BinaryenAllTrueVecI8x16 */,
  /** i8x16.bitmask */
  BitmaskI8x16 = 71 /* _BinaryenBitmaskVecI8x16 */,
  /** i8x16.popcnt */
  PopcntI8x16 = 72 /* _BinaryenPopcntVecI8x16 */,
  /** i16x8.abs */
  AbsI16x8 = 73 /* _BinaryenAbsVecI16x8 */,
  /** i16x8.neg */
  NegI16x8 = 74 /* _BinaryenNegVecI16x8 */,
  /** i16x8.all_true */
  AllTrueI16x8 = 75 /* _BinaryenAllTrueVecI16x8 */,
  /** i16x8.bitmask */
  BitmaskI16x8 = 76 /* _BinaryenBitmaskVecI16x8 */,
  /** i32x4.abs */
  AbsI32x4 = 77 /* _BinaryenAbsVecI32x4 */,
  /** i32x4.neg */
  NegI32x4 = 78 /* _BinaryenNegVecI32x4 */,
  /** i32x4.all_true */
  AllTrueI32x4 = 79 /* _BinaryenAllTrueVecI32x4 */,
  /** i32x4.bitmask */
  BitmaskI32x4 = 80 /* _BinaryenBitmaskVecI32x4 */,
  /** i64x2.abs */
  AbsI64x2 = 81 /* _BinaryenAbsVecI64x2 */,
  /** i64x2.neg */
  NegI64x2 = 82 /* _BinaryenNegVecI64x2 */,
  /** i64x2.all_true */
  AllTrueI64x2 = 83 /* _BinaryenAllTrueVecI64x2 */,
  /** i64x2.bitmask */
  BitmaskI64x2 = 84 /* _BinaryenBitmaskVecI64x2 */,
  /** f32x4.abs */
  AbsF32x4 = 85 /* _BinaryenAbsVecF32x4 */,
  /** f32x4.neg */
  NegF32x4 = 86 /* _BinaryenNegVecF32x4 */,
  /** f32x4.sqrt */
  SqrtF32x4 = 87 /* _BinaryenSqrtVecF32x4 */,
  /** f32x4.ceil */
  CeilF32x4 = 88 /* _BinaryenCeilVecF32x4 */,
  /** f32x4.floor */
  FloorF32x4 = 89 /* _BinaryenFloorVecF32x4 */,
  /** f32x4.trunc */
  TruncF32x4 = 90 /* BinaryenTruncVecF32x4 */,
  /** f32x4.nearest */
  NearestF32x4 = 91 /* BinaryenNearestVecF32x4 */,
  /** f64x2.abs */
  AbsF64x2 = 92 /* _BinaryenAbsVecF64x2 */,
  /** f64x2.neg */
  NegF64x2 = 93 /* _BinaryenNegVecF64x2 */,
  /** f64x2.sqrt */
  SqrtF64x2 = 94 /* _BinaryenSqrtVecF64x2 */,
  /** f64x2.ceil */
  CeilF64x2 = 95 /* _BinaryenCeilVecF64x2 */,
  /** f64x2.floor */
  FloorF64x2 = 96 /* _BinaryenFloorVecF64x2 */,
  /** f64x2.trunc */
  TruncF64x2 = 97 /* _BinaryenTruncVecF64x2 */,
  /** f64x2.nearest */
  NearestF64x2 = 98 /* _BinaryenNearestVecF64x2 */,
  /** i16x8.extadd_pairwise_i8x16_s */
  ExtaddPairwiseI8x16ToI16x8 = 99 /* _BinaryenExtAddPairwiseSVecI8x16ToI16x8 */,
  /** i16x8.extadd_pairwise.i8x16_u */
  ExtaddPairwiseU8x16ToU16x8 = 100 /* _BinaryenExtAddPairwiseUVecI8x16ToI16x8 */,
  /** i32x4.extadd_pairwise.i16x8_s */
  ExtaddPairwiseI16x8ToI32x4 = 101 /* _BinaryenExtAddPairwiseSVecI16x8ToI32x4 */,
  /** i32x4.extadd_pairwise.i64x8_u */
  ExtaddPairwiseU16x8ToU32x4 = 102 /* _BinaryenExtAddPairwiseUVecI16x8ToI32x4 */,
  /** i32x4.trunc_sat_f32x4_s */
  TruncSatF32x4ToI32x4 = 103 /* _BinaryenTruncSatSVecF32x4ToVecI32x4 */,
  /** i32x4.trunc_sat_f32x4_u */
  TruncSatF32x4ToU32x4 = 104 /* _BinaryenTruncSatUVecF32x4ToVecI32x4 */,
  /** f32x4.convert_i32x4_s */
  ConvertI32x4ToF32x4 = 105 /* _BinaryenConvertSVecI32x4ToVecF32x4 */,
  /** f32x4.convert_i32x4_u */
  ConvertU32x4ToF32x4 = 106 /* _BinaryenConvertUVecI32x4ToVecF32x4 */,
  /** i16x8.extend_low_i8x16_s */
  ExtendLowI8x16ToI16x8 = 107 /* _BinaryenExtendLowSVecI8x16ToVecI16x8 */,
  /** i16x8.extend_high_i8x16_s */
  ExtendHighI8x16ToI16x8 = 108 /* _BinaryenExtendHighSVecI8x16ToVecI16x8 */,
  /** i16x8.extend_low_i8x16_u */
  ExtendLowU8x16ToU16x8 = 109 /* _BinaryenExtendLowUVecI8x16ToVecI16x8 */,
  /** i16x8.extend_high_i8x16_u */
  ExtendHighU8x16ToU16x8 = 110 /* _BinaryenExtendHighUVecI8x16ToVecI16x8 */,
  /** i32x4.extend_low_i16x8_s */
  ExtendLowI16x8ToI32x4 = 111 /* _BinaryenExtendLowSVecI16x8ToVecI32x4 */,
  /** i32x4.extend_high_i16x8_s */
  ExtendHighI16x8ToI32x4 = 112 /* _BinaryenExtendHighSVecI16x8ToVecI32x4 */,
  /** i32x4.extend_low_i16x8_u */
  ExtendLowU16x8ToU32x4 = 113 /* _BinaryenExtendLowUVecI16x8ToVecI32x4 */,
  /** i32x4.extend_high_i16x8_u */
  ExtendHighU16x8ToU32x4 = 114 /* _BinaryenExtendHighUVecI16x8ToVecI32x4 */,
  /** i64x2.extend_low_i32x4_s */
  ExtendLowI32x4ToI64x2 = 115 /* _BinaryenExtendLowSVecI32x4ToVecI64x2 */,
  /** i64x2.extend_high_i32x4_s */
  ExtendHighI32x4ToI64x2 = 116 /* _BinaryenExtendHighSVecI32x4ToVecI64x2 */,
  /** i64x2.extend_low_i32x4_u */
  ExtendLowU32x4ToU64x2 = 117 /* _BinaryenExtendLowUVecI32x4ToVecI64x2 */,
  /** i64x2.extend_high_i32x4_u */
  ExtendHighU32x4ToU64x2 = 118 /* _BinaryenExtendHighUVecI32x4ToVecI64x2 */,
  /** f32x4.convert_i32x4_s */
  ConvertLowI32x4ToF64x2 = 119 /* _BinaryenConvertLowSVecI32x4ToVecF64x2 */,
  /** f32x4.convert_i32x4_u */
  ConvertLowU32x4ToF64x2 = 120 /* _BinaryenConvertLowUVecI32x4ToVecF64x2 */,
  /** i32x4.trunc_sat_f64x2_s_zero */
  TruncSatF64x2ToI32x4Zero = 121 /* _BinaryenTruncSatZeroSVecF64x2ToVecI32x4 */,
  /** i32x4.trunc_sat_f64x2_u_zero */
  TruncSatF64x2ToU32x4Zero = 122 /* _BinaryenTruncSatZeroUVecF64x2ToVecI32x4 */,
  /** f32x4.demote_f64x2_zero */
  DemoteZeroF64x2ToF32x4 = 123 /* _BinaryenDemoteZeroVecF64x2ToVecF32x4 */,
  /** f64x2.promote_low_f32x4 */
  PromoteLowF32x4ToF64x2 = 124 /* _BinaryenPromoteLowVecF32x4ToVecF64x2 */,

  _last = PromoteLowF32x4ToF64x2,

  // Target dependent

  /** i32.clz or i64.clz, depending on target word size */
  ClzSize,
  /** i32.ctz or i64.ctz, depending on target word size */
  CtzSize,
  /** i32.popcnt or i64.popcnt, depending on target word size */
  PopcntSize,
  /** i32.eqz or i64.eqz, depending on target word size */
  EqzSize
}

/** Binaryen binary operation constants. */
export enum BinaryOp {
  /** i32.add */
  AddI32 = 0 /* _BinaryenAddInt32 */,
  /** i32.sub */
  SubI32 = 1 /* _BinaryenSubInt32 */,
  /** i32.mul */
  MulI32 = 2 /* _BinaryenMulInt32 */,
  /** i32.div_s */
  DivI32 = 3 /* _BinaryenDivSInt32 */,
  /** i32.div_u */
  DivU32 = 4 /* _BinaryenDivUInt32 */,
  /** i32.rem_s */
  RemI32 = 5 /* _BinaryenRemSInt32 */,
  /** i32.rem_u */
  RemU32 = 6 /* _BinaryenRemUInt32 */,
  /** i32.and */
  AndI32 = 7 /* _BinaryenAndInt32 */,
  /** i32.or */
  OrI32 = 8 /* _BinaryenOrInt32 */,
  /** i32.xor */
  XorI32 = 9 /* _BinaryenXorInt32 */,
  /** i32.shl */
  ShlI32 = 10 /* _BinaryenShlInt32 */,
  /** i32.shr_s */
  ShrI32 = 11 /* _BinaryenShrSInt32 */,
  /** i32.shr_u */
  ShrU32 = 12 /* _BinaryenShrUInt32 */,
  /** i32.rotl */
  RotlI32 = 13 /* _BinaryenRotLInt32 */,
  /** i32.rotr */
  RotrI32 = 14 /* _BinaryenRotRInt32 */,
  /** i32.eq */
  EqI32 = 15 /* _BinaryenEqInt32 */,
  /** i32.ne */
  NeI32 = 16 /* _BinaryenNeInt32 */,
  /** i32.lt_s */
  LtI32 = 17 /* _BinaryenLtSInt32 */,
  /** i32.lt_u */
  LtU32 = 18 /* _BinaryenLtUInt32 */,
  /** i32.le_s */
  LeI32 = 19 /* _BinaryenLeSInt32 */,
  /** i32.le_u */
  LeU32 = 20 /* _BinaryenLeUInt32 */,
  /** i32.gt_s */
  GtI32 = 21 /* _BinaryenGtSInt32 */,
  /** i32.gt_u */
  GtU32 = 22 /* _BinaryenGtUInt32 */,
  /** i32.ge_s */
  GeI32 = 23 /* _BinaryenGeSInt32 */,
  /** i32.ge_u */
  GeU32 = 24 /* _BinaryenGeUInt32 */,
  /** i64.add */
  AddI64 = 25 /* _BinaryenAddInt64 */,
  /** i64.sub */
  SubI64 = 26 /* _BinaryenSubInt64 */,
  /** i64.mul */
  MulI64 = 27 /* _BinaryenMulInt64 */,
  /** i64.div_s */
  DivI64 = 28 /* _BinaryenDivSInt64 */,
  /** i64.div_u */
  DivU64 = 29 /* _BinaryenDivUInt64 */,
  /** i64.rem_s */
  RemI64 = 30 /* _BinaryenRemSInt64 */,
  /** i64.rem_u */
  RemU64 = 31 /* _BinaryenRemUInt64 */,
  /** i64.and */
  AndI64 = 32 /* _BinaryenAndInt64 */,
  /** i64.or */
  OrI64 = 33 /* _BinaryenOrInt64 */,
  /** i64.xor */
  XorI64 = 34 /* _BinaryenXorInt64 */,
  /** i64.shl */
  ShlI64 = 35 /* _BinaryenShlInt64 */,
  /** i64.shr_s */
  ShrI64 = 36 /* _BinaryenShrSInt64 */,
  /** i64.shr_u */
  ShrU64 = 37 /* _BinaryenShrUInt64 */,
  /** i64.rotl */
  RotlI64 = 38 /* _BinaryenRotLInt64 */,
  /** i64.rotr */
  RotrI64 = 39 /* _BinaryenRotRInt64 */,
  /** i64.eq */
  EqI64 = 40 /* _BinaryenEqInt64 */,
  /** i64.ne */
  NeI64 = 41 /* _BinaryenNeInt64 */,
  /** i64.lt_s */
  LtI64 = 42 /* _BinaryenLtSInt64 */,
  /** i64.lt_u */
  LtU64 = 43 /* _BinaryenLtUInt64 */,
  /** i64.le_s */
  LeI64 = 44 /* _BinaryenLeSInt64 */,
  /** i64.le_u */
  LeU64 = 45 /* _BinaryenLeUInt64 */,
  /** i64.gt_s */
  GtI64 = 46 /* _BinaryenGtSInt64 */,
  /** i64.gt_u */
  GtU64 = 47 /* _BinaryenGtUInt64 */,
  /** i64.ge_s */
  GeI64 = 48 /* _BinaryenGeSInt64 */,
  /** i64.ge_u */
  GeU64 = 49 /* _BinaryenGeUInt64 */,
  /** f32.add */
  AddF32 = 50 /* _BinaryenAddFloat32 */,
  /** f32.sub */
  SubF32 = 51 /* _BinaryenSubFloat32 */,
  /** f32.mul */
  MulF32 = 52 /* _BinaryenMulFloat32 */,
  /** f32.div */
  DivF32 = 53 /* _BinaryenDivFloat32 */,
  /** f32.copysign */
  CopysignF32 = 54 /* _BinaryenCopySignFloat32 */,
  /** f32.min */
  MinF32 = 55 /* _BinaryenMinFloat32 */,
  /** f32.max */
  MaxF32 = 56 /* _BinaryenMaxFloat32 */,
  /** f32.eq */
  EqF32 = 57 /* _BinaryenEqFloat32 */,
  /** f32.ne */
  NeF32 = 58 /* _BinaryenNeFloat32 */,
  /** f32.lt */
  LtF32 = 59 /* _BinaryenLtFloat32 */,
  /** f32.le */
  LeF32 = 60 /* _BinaryenLeFloat32 */,
  /** f32.gt */
  GtF32 = 61 /* _BinaryenGtFloat32 */,
  /** f32.ge */
  GeF32 = 62 /* _BinaryenGeFloat32 */,
  /** f64.add */
  AddF64 = 63 /* _BinaryenAddFloat64 */,
  /** f64.sub */
  SubF64 = 64 /* _BinaryenSubFloat64 */,
  /** f64.mul */
  MulF64 = 65 /* _BinaryenMulFloat64 */,
  /** f64.div */
  DivF64 = 66 /* _BinaryenDivFloat64 */,
  /** f64.copysign */
  CopysignF64 = 67 /* _BinaryenCopySignFloat64 */,
  /** f64.min */
  MinF64 = 68 /* _BinaryenMinFloat64 */,
  /** f64.max */
  MaxF64 = 69 /* _BinaryenMaxFloat64 */,
  /** f64.eq */
  EqF64 = 70 /* _BinaryenEqFloat64 */,
  /** f64.ne */
  NeF64 = 71 /* _BinaryenNeFloat64 */,
  /** f64.lt */
  LtF64 = 72 /* _BinaryenLtFloat64 */,
  /** f64.le */
  LeF64 = 73 /* _BinaryenLeFloat64 */,
  /** f64.gt */
  GtF64 = 74 /* _BinaryenGtFloat64 */,
  /** f64.ge */
  GeF64 = 75 /* _BinaryenGeFloat64 */,

  // see: https://github.com/WebAssembly/simd

  /** i8x16.eq */
  EqI8x16 = 76 /* _BinaryenEqVecI8x16 */,
  /** i8x16.he */
  NeI8x16 = 77 /* _BinaryenNeVecI8x16 */,
  /** i8x16.lt_s */
  LtI8x16 = 78 /* _BinaryenLtSVecI8x16 */,
  /** i8x16.lt_u */
  LtU8x16 = 79 /* _BinaryenLtUVecI8x16 */,
  /** i8x16.gt_s */
  GtI8x16 = 80 /* _BinaryenGtSVecI8x16 */,
  /** i8x16.gt_u */
  GtU8x16 = 81 /* _BinaryenGtUVecI8x16 */,
  /** i8x16.le_s */
  LeI8x16 = 82 /* _BinaryenLeSVecI8x16 */,
  /** i8x16.le_u */
  LeU8x16 = 83 /* _BinaryenLeUVecI8x16 */,
  /** i8x16.ge_s */
  GeI8x16 = 84 /* _BinaryenGeSVecI8x16 */,
  /** i8x16.ge_u */
  GeU8x16 = 85 /* _BinaryenGeUVecI8x16 */,
  /** i16x8.eq */
  EqI16x8 = 86 /* _BinaryenEqVecI16x8 */,
  /** i16x8.ne */
  NeI16x8 = 87 /* _BinaryenNeVecI16x8 */,
  /** i16x8.lt_s */
  LtI16x8 = 88 /* _BinaryenLtSVecI16x8 */,
  /** i16x8.lt_u */
  LtU16x8 = 89 /* _BinaryenLtUVecI16x8 */,
  /** i16x8.gt_s */
  GtI16x8 = 90 /* _BinaryenGtSVecI16x8 */,
  /** i16x8.gt_u */
  GtU16x8 = 91 /* _BinaryenGtUVecI16x8 */,
  /** i16x8.le_s */
  LeI16x8 = 92 /* _BinaryenLeSVecI16x8 */,
  /** i16x8.le_u */
  LeU16x8 = 93 /* _BinaryenLeUVecI16x8 */,
  /** i16x8.ge_s */
  GeI16x8 = 94 /* _BinaryenGeSVecI16x8 */,
  /** i16x8.ge_u */
  GeU16x8 = 95 /* _BinaryenGeUVecI16x8 */,
  /** i32x4.eq */
  EqI32x4 = 96 /* _BinaryenEqVecI32x4 */,
  /** i32x4.ne */
  NeI32x4 = 97 /* _BinaryenNeVecI32x4 */,
  /** i32x4.lt_s */
  LtI32x4 = 98 /* _BinaryenLtSVecI32x4 */,
  /** i32x4.lt_u */
  LtU32x4 = 99 /* _BinaryenLtUVecI32x4 */,
  /** i32x4.gt_s */
  GtI32x4 = 100 /* _BinaryenGtSVecI32x4 */,
  /** i32x4.gt_u */
  GtU32x4 = 101 /* _BinaryenGtUVecI32x4 */,
  /** i32x4.le_s */
  LeI32x4 = 102 /* _BinaryenLeSVecI32x4 */,
  /** i32x4.le_u */
  LeU32x4 = 103 /* _BinaryenLeUVecI32x4 */,
  /** i32x4.ge_s */
  GeI32x4 = 104 /* _BinaryenGeSVecI32x4 */,
  /** i32x4.ge_u */
  GeU32x4 = 105 /* _BinaryenGeUVecI32x4 */,
  /** i64x2.eq */
  EqI64x2 = 106 /* _BinaryenEqVecI64x2 */,
  /** i64x2.ne */
  NeI64x2 = 107 /* _BinaryenNeVecI64x2 */,
  /** i64x2.lt_s */
  LtI64x2 = 108 /* _BinaryenLtSVecI64x2 */,
  /** i64x2.gt_s */
  GtI64x2 = 109 /* _BinaryenGtSVecI64x2 */,
  /** i64x2.le_s */
  LeI64x2 = 110 /* _BinaryenLeSVecI64x2 */,
  /** i64x2.ge_s */
  GeI64x2 = 111 /* _BinaryenGeSVecI64x2 */,
  /** f32x4.eq */
  EqF32x4 = 112 /* _BinaryenEqVecF32x4 */,
  /** f32x4.ne */
  NeF32x4 = 113 /* _BinaryenNeVecF32x4 */,
  /** f32x4.lt */
  LtF32x4 = 114 /* _BinaryenLtVecF32x4 */,
  /** f32x4.gt */
  GtF32x4 = 115 /* _BinaryenGtVecF32x4 */,
  /** f32x4.le */
  LeF32x4 = 116 /* _BinaryenLeVecF32x4 */,
  /** f32x4.ge */
  GeF32x4 = 117 /* _BinaryenGeVecF32x4 */,
  /** f64x2.eq */
  EqF64x2 = 118 /* _BinaryenEqVecF64x2 */,
  /** f64x2.ne */
  NeF64x2 = 119 /* _BinaryenNeVecF64x2 */,
  /** f64x2.lt */
  LtF64x2 = 120 /* _BinaryenLtVecF64x2 */,
  /** f64x2.gt */
  GtF64x2 = 121 /* _BinaryenGtVecF64x2 */,
  /** f64x2.le */
  LeF64x2 = 122 /* _BinaryenLeVecF64x2 */,
  /** f64x2.ge */
  GeF64x2 = 123 /* _BinaryenGeVecF64x2 */,
  /** v128.and */
  AndV128 = 124 /* _BinaryenAndVec128 */,
  /** v128.or */
  OrV128 = 125 /* _BinaryenOrVec128 */,
  /** v128.xor */
  XorV128 = 126 /* _BinaryenXorVec128 */,
  /** v128.andnot */
  AndnotV128 = 127 /* _BinaryenAndNotVec128 */,
  /** i8x16.add */
  AddI8x16 = 128 /* _BinaryenAddVecI8x16 */,
  /** i8x16.add_sat_s */
  AddSatI8x16 = 129 /* _BinaryenAddSatSVecI8x16 */,
  /** i8x16.add_sat_u */
  AddSatU8x16 = 130 /* _BinaryenAddSatUVecI8x16 */,
  /** i8x16.sub */
  SubI8x16 = 131 /* _BinaryenSubVecI8x16 */,
  /** i8x16.sub_sat_s */
  SubSatI8x16 = 132 /* _BinaryenSubSatSVecI8x16 */,
  /** i8x16.sub_sat_u */
  SubSatU8x16 = 133 /* _BinaryenSubSatUVecI8x16 */,
  /** i8x16.min_s */
  MinI8x16 = 134 /* _BinaryenMinSVecI8x16 */,
  /** i8x16.min_u */
  MinU8x16 = 135 /* _BinaryenMinUVecI8x16 */,
  /** i8x16.max_s */
  MaxI8x16 = 136 /* _BinaryenMaxSVecI8x16 */,
  /** i8x16.max_u */
  MaxU8x16 = 137 /* _BinaryenMaxUVecI8x16 */,
  /** i8x16.avgr_u */
  AvgrU8x16 = 138 /* _BinaryenAvgrUVecI8x16 */,
  /** i16x8.add */
  AddI16x8 = 139 /* _BinaryenAddVecI16x8 */,
  /** i16x8.add_sat_s */
  AddSatI16x8 = 140 /* _BinaryenAddSatSVecI16x8 */,
  /** i16x8.add_sat_u */
  AddSatU16x8 = 141 /* _BinaryenAddSatUVecI16x8 */,
  /** i16x8.sub */
  SubI16x8 = 142 /* _BinaryenSubVecI16x8 */,
  /** i16x8.sub_sat_s */
  SubSatI16x8 = 143 /* _BinaryenSubSatSVecI16x8 */,
  /** i16x8.sub_sat_u */
  SubSatU16x8 = 144 /* _BinaryenSubSatUVecI16x8 */,
  /** i16x8.mul */
  MulI16x8 = 145 /* _BinaryenMulVecI16x8 */,
  /** i16x8.min_s */
  MinI16x8 = 146 /* _BinaryenMinSVecI16x8 */,
  /** i16x8.min_u */
  MinU16x8 = 147 /* _BinaryenMinUVecI16x8 */,
  /** i16x8.max_s */
  MaxI16x8 = 148 /* _BinaryenMaxSVecI16x8 */,
  /** i16x8.max_u */
  MaxU16x8 = 149 /* _BinaryenMaxUVecI16x8 */,
  /** i16x8.avgr_u */
  AvgrU16x8 = 150 /* _BinaryenAvgrUVecI16x8 */,
  /** i16x8.q15mulr_sat_s */
  Q15mulrSatI16x8 = 151 /* _BinaryenQ15MulrSatSVecI16x8 */,
  /** i16x8.extmul_low_i8x16_s */
  ExtmulLowI16x8 = 152 /* _BinaryenExtMulLowSVecI16x8 */,
  /** i16x8.extmul_high_i8x16_s */
  ExtmulHighI16x8 = 153 /* _BinaryenExtMulHighSVecI16x8 */,
  /** i16x8.extmul_low_i8x16_u */
  ExtmulLowU16x8 = 154 /* _BinaryenExtMulLowUVecI16x8 */,
  /** i16x8.extmul_high_i8x16_u */
  ExtmulHighU16x8 = 155 /* _BinaryenExtMulHighUVecI16x8 */,
  /** i32x4.add */
  AddI32x4 = 156 /* _BinaryenAddVecI32x4 */,
  /** i32x4.sub */
  SubI32x4 = 157 /* _BinaryenSubVecI32x4 */,
  /** i32x4.mul */
  MulI32x4 = 158 /* _BinaryenMulVecI32x4 */,
  /** i32x4.min_s */
  MinI32x4 = 159 /* _BinaryenMinSVecI32x4 */,
  /** i32x4.min_u */
  MinU32x4 = 160 /* _BinaryenMinUVecI32x4 */,
  /** i32x4.max_s */
  MaxI32x4 = 161 /* _BinaryenMaxSVecI32x4 */,
  /** i32x4.max_u */
  MaxU32x4 = 162 /* _BinaryenMaxUVecI32x4 */,
  /** i32x4.dot_i16x8_s */
  DotI16x8 = 163 /* _BinaryenDotSVecI16x8ToVecI32x4 */,
  /** i32x4.extmul_low_i16x8_s */
  ExtmulLowI32x4 = 164 /* _BinaryenExtMulLowSVecI32x4 */,
  /** i32x4.extmul_high_i16x8_s */
  ExtmulHighI32x4 = 165 /* _BinaryenExtMulHighSVecI32x4 */,
  /** i32x4.extmul_low_i16x8_u */
  ExtmulLowU32x4 = 166 /* _BinaryenExtMulLowUVecI32x4 */,
  /** i32x4.extmul_high_i16x8_u */
  ExtmulHighU32x4 = 167 /* _BinaryenExtMulHighUVecI32x4 */,
  /** i64x2.add */
  AddI64x2 = 168 /* _BinaryenAddVecI64x2 */,
  /** i64x2.sub */
  SubI64x2 = 169 /* _BinaryenSubVecI64x2 */,
  /** i64x2.mul */
  MulI64x2 = 170 /* _BinaryenMulVecI64x2 */,
  /** i64x2.extmul_low_i32x4_s */
  ExtmulLowI64x2 = 171 /* _BinaryenExtMulLowSVecI64x2 */,
  /** i64x2.extmul_high_i32x4_s */
  ExtmulHighI64x2 = 172 /* _BinaryenExtMulHighSVecI64x2 */,
  /** i64x2.extmul_low_i32x4_u */
  ExtmulLowU64x2 = 173 /* _BinaryenExtMulLowUVecI64x2 */,
  /** i64x2.extmul_high_i32x4_u */
  ExtmulHighU64x2 = 174 /* _BinaryenExtMulHighUVecI64x2 */,
  /** f32x4.add */
  AddF32x4 = 175 /* _BinaryenAddVecF32x4 */,
  /** f32x4.sub */
  SubF32x4 = 176 /* _BinaryenSubVecF32x4 */,
  /** f32x4.mul */
  MulF32x4 = 177 /* _BinaryenMulVecF32x4 */,
  /** f32x4.div */
  DivF32x4 = 178 /* _BinaryenDivVecF32x4 */,
  /** f32x4.min */
  MinF32x4 = 179 /* _BinaryenMinVecF32x4 */,
  /** f32x4.max */
  MaxF32x4 = 180 /* _BinaryenMaxVecF32x4 */,
  /** f32x4.pmin */
  PminF32x4 = 181 /* _BinaryenPMinVecF32x4 */,
  /** f32x4.pmax */
  PmaxF32x4 = 182 /* _BinaryenPMaxVecF32x4 */,
  /** f64x2.add */
  AddF64x2 = 183 /* _BinaryenAddVecF64x2 */,
  /** f64x2.sub */
  SubF64x2 = 184 /* _BinaryenSubVecF64x2 */,
  /** f64x2.mul */
  MulF64x2 = 185 /* _BinaryenMulVecF64x2 */,
  /** f64x2.div */
  DivF64x2 = 186 /* _BinaryenDivVecF64x2 */,
  /** f64x2.min */
  MinF64x2 = 187 /* _BinaryenMinVecF64x2 */,
  /** f64x2.max */
  MaxF64x2 = 188 /* _BinaryenMaxVecF64x2 */,
  /** f64x2.pmin */
  PminF64x2 = 189 /* _BinaryenPMinVecF64x2 */,
  /** f64x2.pmax */
  PmaxF64x2 = 190 /* _BinaryenPMaxVecF64x2 */,
  /** i8x16.narrow_i16x8_s */
  NarrowI16x8ToI8x16 = 191 /* _BinaryenNarrowSVecI16x8ToVecI8x16 */,
  /** i8x16.narrow_i16x8_u */
  NarrowU16x8ToU8x16 = 192 /* _BinaryenNarrowUVecI16x8ToVecI8x16 */,
  /** i16x8.narrow_i32x4_s */
  NarrowI32x4ToI16x8 = 193 /* _BinaryenNarrowSVecI32x4ToVecI16x8 */,
  /** i16x8.narrow_i32x4_u */
  NarrowU32x4ToU16x8 = 194 /* _BinaryenNarrowUVecI32x4ToVecI16x8 */,
  /** i8x16.swizzle */
  SwizzleI8x16 = 195 /* _BinaryenSwizzleVec8x16 */,

  _last = SwizzleI8x16,

  // Target dependent

  /** i32.add or i64.add, depending on target word size */
  AddSize,
  /** i32.sub or i64.sub, depending on target word size */
  SubSize,
  /** i32.mul or i64.mul, depending on target word size */
  MulSize,
  /** i32.div_s or i64.div_s, depending on target word size */
  DivISize,
  /** i32.div_u or i64.div_u, depending on target word size */
  DivUSize,
  /** i32.rem_s or i64.rem_s, depending on target word size */
  RemISize,
  /** i32.rem_u or i64.rem_u, depending on target word size */
  RemUSize,
  /** i32.and or i64.and, depending on target word size */
  AndSize,
  /** i32.or or i64.or, depending on target word size */
  OrSize,
  /** i32.xor or i64.xor, depending on target word size */
  XorSize,
  /** i32.shl or i64.shl, depending on target word size */
  ShlSize,
  /** i32.shr_s or i64.shr_s, depending on target word size */
  ShrISize,
  /** i32.shr_u or i64.shr_u, depending on target word size */
  ShrUSize,
  /** i32.rotl or i64.rotl, depending on target word size */
  RotlSize,
  /** i32.rotr or i64.rotr, depending on target word size */
  RotrSize,
  /** i32.eq or i64.eq, depending on target word size */
  EqSize,
  /** i32.ne or i64.ne, depending on target word size */
  NeSize,
  /** i32.lt_s or i64.lt_s, depending on target word size */
  LtISize,
  /** i32.lt_u or i64.lt_u, depending on target word size */
  LtUSize,
  /** i32.le_s or i64.le_s, depending on target word size */
  LeISize,
  /** i32.le_u or i64.le_u, depending on target word size */
  LeUSize,
  /** i32.gt_s or i64.gt_s, depending on target word size */
  GtISize,
  /** i32.gt_u or i64.gt_u, depending on target word size */
  GtUSize,
  /** i32.ge_s or i64.ge_s, depending on target word size */
  GeISize,
  /** i32.ge_u or i64.ge_u, depending on target word size */
  GeUSize
}

/** Binaryen atomic read-modify-write operation constants. */
export enum AtomicRMWOp {
  /** i32.atomic.rmw.add, i32.atomic.rmw8.add_u, i32.atomic.rmw16.add_u, i64.atomic.rmw.add, i64.atomic.rmw8.add_u, i64.atomic.rmw16.add_u, i64.atomic.rmw32.add_u */
  Add = 0 /* _BinaryenAtomicRMWAdd */,
  /** i32.atomic.rmw.sub, i32.atomic.rmw8.sub_u, i32.atomic.rmw16.sub_u, i64.atomic.rmw.sub, i64.atomic.rmw8.sub_u, i64.atomic.rmw16.sub_u, i64.atomic.rmw32.sub_u */
  Sub = 1 /* _BinaryenAtomicRMWSub */,
  /** i32.atomic.rmw.and, i32.atomic.rmw8.and_u, i32.atomic.rmw16.and_u, i64.atomic.rmw.and, i64.atomic.rmw8.and_u, i64.atomic.rmw16.and_u, i64.atomic.rmw32.and_u */
  And = 2 /* _BinaryenAtomicRMWAnd */,
  /** i32.atomic.rmw.or, i32.atomic.rmw8.or_u, i32.atomic.rmw16.or_u, i64.atomic.rmw.or, i64.atomic.rmw8.or_u, i64.atomic.rmw16.or_u, i64.atomic.rmw32.or_u */
  Or = 3 /* _BinaryenAtomicRMWOr */,
  /** i32.atomic.rmw.xor, i32.atomic.rmw8.xor_u, i32.atomic.rmw16.xor_u, i64.atomic.rmw.xor, i64.atomic.rmw8.xor_u, i64.atomic.rmw16.xor_u, i64.atomic.rmw32.xor_u */
  Xor = 4 /* _BinaryenAtomicRMWXor */,
  /** i32.atomic.rmw.xchg, i32.atomic.rmw8.xchg_u, i32.atomic.rmw16.xchg_u, i64.atomic.rmw.xchg, i64.atomic.rmw8.xchg_u, i64.atomic.rmw16.xchg_u, i64.atomic.rmw32.xchg_u */
  Xchg = 5 /* _BinaryenAtomicRMWXchg */
}

/** Binaryen SIMD extract operation constants. */
export enum SIMDExtractOp {
  /** i8x16.extract_lane_s */
  ExtractLaneI8x16 = 0 /* _BinaryenExtractLaneSVecI8x16 */,
  /** i8x16.extract_lane_u */
  ExtractLaneU8x16 = 1 /* _BinaryenExtractLaneUVecI8x16 */,
  /** i16x8.extract_lane_s */
  ExtractLaneI16x8 = 2 /* _BinaryenExtractLaneSVecI16x8 */,
  /** i16x8.extract_lane_u */
  ExtractLaneU16x8 = 3 /* _BinaryenExtractLaneUVecI16x8 */,
  /** i32x4.extract_lane_s */
  ExtractLaneI32x4 = 4 /* _BinaryenExtractLaneVecI32x4 */,
  /** i32x4.extract_lane_u */
  ExtractLaneI64x2 = 5 /* _BinaryenExtractLaneVecI64x2 */,
  /** i64x2.extract_lane_s */
  ExtractLaneF32x4 = 6 /* _BinaryenExtractLaneVecF32x4 */,
  /** i64x2.extract_lane_u */
  ExtractLaneF64x2 = 7 /* _BinaryenExtractLaneVecF64x2 */,
}

/** Binaryen SIMD replace operation constants. */
export enum SIMDReplaceOp {
  /** i8x16.replace_lane */
  ReplaceLaneI8x16 = 0 /* _BinaryenReplaceLaneVecI8x16 */,
  /** i16x8.replace_lane */
  ReplaceLaneI16x8 = 1 /* _BinaryenReplaceLaneVecI16x8 */,
  /** i32x4.replace_lane */
  ReplaceLaneI32x4 = 2 /* _BinaryenReplaceLaneVecI32x4 */,
  /** i64x2.replace_lane */
  ReplaceLaneI64x2 = 3 /* _BinaryenReplaceLaneVecI64x2 */,
  /** f32x4.replace_lane */
  ReplaceLaneF32x4 = 4 /* _BinaryenReplaceLaneVecF32x4 */,
  /** f64x2.replace_lane */
  ReplaceLaneF64x2 = 5 /* _BinaryenReplaceLaneVecF64x2 */
}

/** Binaryen SIMD shift operation constants. */
export enum SIMDShiftOp {
  /** i8x16.shl */
  ShlI8x16 = 0 /* _BinaryenShlVecI8x16 */,
  /** i8x16.shr_s */
  ShrI8x16 = 1 /* _BinaryenShrSVecI8x16 */,
  /** i8x16.shr_u */
  ShrU8x16 = 2 /* _BinaryenShrUVecI8x16 */,
  /** i16x8.shl */
  ShlI16x8 = 3 /* _BinaryenShlVecI16x8 */,
  /** i16x8.shr_s */
  ShrI16x8 = 4 /* _BinaryenShrSVecI16x8 */,
  /** i16x8.shr_u */
  ShrU16x8 = 5 /* _BinaryenShrUVecI16x8 */,
  /** i16x8.shl */
  ShlI32x4 = 6 /* _BinaryenShlVecI32x4 */,
  /** i32x4.shr_s */
  ShrI32x4 = 7 /* _BinaryenShrSVecI32x4 */,
  /** i32x4.shr_u */
  ShrU32x4 = 8 /* _BinaryenShrUVecI32x4 */,
  /** i64x2.shl */
  ShlI64x2 = 9 /* _BinaryenShlVecI64x2 */,
  /** i64x2.shr_u */
  ShrI64x2 = 10 /* _BinaryenShrSVecI64x2 */,
  /** i64x2.shr_u */
  ShrU64x2 = 11 /* _BinaryenShrUVecI64x2 */
}

/** Binaryen SIMD load operation constants. */
export enum SIMDLoadOp {
  /** v128.load8_splat */
  Load8Splat = 0 /* _BinaryenLoad8SplatVec128 */,
  /** v128.load16_splat */
  Load16Splat = 1 /* _BinaryenLoad16SplatVec128 */,
  /** v128.load32_splat */
  Load32Splat = 2 /* _BinaryenLoad32SplatVec128 */,
  /** v128.load64_splat */
  Load64Splat = 3 /* _BinaryenLoad64SplatVec128 */,
  /** v128.load8x8_s */
  Load8x8S = 4 /* _BinaryenLoad8x8SVec128 */,
  /** v128.load8x8_u */
  Load8x8U = 5 /* _BinaryenLoad8x8UVec128 */,
  /** v128.load16x4_s */
  Load16x4S = 6 /* _BinaryenLoad16x4SVec128 */,
  /** v128.load16x4_u */
  Load16x4U = 7 /* _BinaryenLoad16x4UVec128 */,
  /** v128.load32x2_s */
  Load32x2S = 8 /* _BinaryenLoad32x2SVec128 */,
  /** v128.load32x2_u */
  Load32x2U = 9 /* _BinaryenLoad32x2UVec128 */,
  /** v128.load32_zero */
  Load32Zero = 10 /* _BinaryenLoad32ZeroVec128 */,
  /** v128.load64_zero */
  Load64Zero = 11 /* _BinaryenLoad64ZeroVec128 */,
}

/** Binaryen SIMD load/store lane operation constants. */
export enum SIMDLoadStoreLaneOp {
  /** v128.load8_lane */
  Load8Lane = 0 /* _BinaryenLoad8LaneVec128 */,
  /** v128.load16_lane */
  Load16Lane = 1 /* _BinaryenLoad16LaneVec128 */,
  /** v128.load32_lane */
  Load32Lane = 2 /* _BinaryenLoad32LaneVec128 */,
  /** v128.load64_lane */
  Load64Lane = 3 /* _BinaryenLoad64LaneVec128 */,
  /** v128.store8_lane */
  Store8Lane = 4 /* _BinaryenStore8LaneVec128 */,
  /** v128.store16_lane */
  Store16Lane = 5 /* _BinaryenStore16LaneVec128 */,
  /** v128.store32_lane */
  Store32Lane = 6 /* _BinaryenStore32LaneVec128 */,
  /** v128.store64_lane */
  Store64Lane = 7 /* _BinaryenStore64LaneVec128 */,
}

/** Binaryen SIMD ternary operation constants. */
export enum SIMDTernaryOp {
  /** v128.bitselect */
  Bitselect = 0 /* _BinaryenBitselectVec128 */
}

/** Binaryen RefIs operation constants. */
export enum RefIsOp {
  /** ref.is_null */
  RefIsNull = 0 /* _BinaryenRefIsNull */,
  /** ref.is_func */
  RefIsFunc = 1 /* _BinaryenRefIsFunc */,
  /** ref.is_data */
  RefIsData = 2 /* _BinaryenRefIsData */,
  /** ref.is_i31 */
  RefIsI31 = 3 /* _BinaryenRefIsI31 */
}

/** Binaryen RefAs operation constants. */
export enum RefAsOp {
  /** ref.as_non_null */
  RefAsNonNull = 0 /* _BinaryenRefAsNonNull */,
  /** ref.as_func */
  RefAsFunc = 1 /* _BinaryenRefAsFunc */,
  /** ref.as_data */
  RefAsData = 2 /* _BinaryenRefAsData */,
  /** ref.as_i31 */
  RefAsI31 = 3 /* _BinaryenRefAsI31 */
}

/** Binaryen BrOn operation constants. */
export enum BrOnOp {
  /** br_on_null */
  BrOnNull = 0 /* TODO_BinaryenBrOnNull */,
  /** br_on_cast */
  BrOnCast = 1 /* TODO_BinaryenBrOnCast */,
  /** br_on_func */
  BrOnFunc = 2 /* TODO_BinaryenBrOnFunc */,
  /** br_on_data */
  BrOnData = 3 /* TODO_BinaryenBrOnData */,
  /** br_on_i31 */
  BrOnI31 = 4 /* TODO_BinaryenBrOnI31 */
}

/** Binaryen expression runner flags. */
export enum ExpressionRunnerFlags {
  Default = 0 /* _ExpressionRunnerFlagsDefault */,
  PreserveSideeffects = 1 /* _ExpressionRunnerFlagsPreserveSideeffects */,
  TraverseCalls = 2 /* _ExpressionRunnerFlagsTraverseCalls */
}

export class MemorySegment {
  constructor(
    /** Segment data. */
    public buffer: Uint8Array,
    /** Segment offset. */
    public offset: i64
  ) {}
}

export class Module {
  constructor(
    /** Binaryen module reference. */
    public ref: ModuleRef,
    /** Whether a shadow stack is used. */
    public useShadowStack: bool,
    /** Architecture-dependent size type. */
    public sizeType: TypeRef
  ) {
    assert(sizeType == TypeRef.I32 || sizeType == TypeRef.I64);
    this.lit = binaryen._malloc(binaryen._BinaryenSizeofLiteral());
  }

  private lit: usize;

  static create(useShadowStack: bool, sizeType: TypeRef): Module {
    return new Module(binaryen._BinaryenModuleCreate(), useShadowStack, sizeType);
  }

  static createFrom(buffer: Uint8Array, useShadowStack: bool, sizeType: TypeRef): Module {
    var cArr = allocU8Array(buffer);
    var module = new Module(binaryen._BinaryenModuleRead(cArr, buffer.length), useShadowStack, sizeType);
    binaryen._free(changetype<usize>(cArr));
    return module;
  }

  // constants

  i32(value: i32): ExpressionRef {
    var out = this.lit;
    binaryen._BinaryenLiteralInt32(out, value);
    return binaryen._BinaryenConst(this.ref, out);
  }

  i64(valueLow: i32, valueHigh: i32 = 0): ExpressionRef {
    var out = this.lit;
    binaryen._BinaryenLiteralInt64(out, valueLow, valueHigh);
    return binaryen._BinaryenConst(this.ref, out);
  }

  // isize<T>(value: T): ExpressionRef {
  //   if (i64_is(value)) {
  //     if (this.sizeType == TypeRef.I64) {
  //       return this.i64(i64_low(value), i64_high(value));
  //     }
  //     assert(i64_is_i32(value));
  //     return this.i32(i64_low(value));
  //   }
  //   return this.sizeType == TypeRef.I64
  //     ? this.i64(i32(value), i32(value) < 0 ? -1 : 0)
  //     : this.i32(i32(value));
  // }

  usize<T>(value: T): ExpressionRef {
    if (i64_is(value)) {
      if (this.sizeType == TypeRef.I64) {
        return this.i64(i64_low(value), i64_high(value));
      }
      assert(i64_is_u32(value));
      return this.i32(i64_low(value));
    }
    return this.sizeType == TypeRef.I64
      ? this.i64(i32(value))
      : this.i32(i32(value));
  }

  f32(value: f32): ExpressionRef {
    var out = this.lit;
    binaryen._BinaryenLiteralFloat32(out, value);
    return binaryen._BinaryenConst(this.ref, out);
  }

  f64(value: f64): ExpressionRef {
    var out = this.lit;
    binaryen._BinaryenLiteralFloat64(out, value);
    return binaryen._BinaryenConst(this.ref, out);
  }

  v128(bytes: Uint8Array): ExpressionRef {
    assert(bytes.length == 16);
    var out = this.lit;
    for (let i = 0; i < 16; ++i) {
      binaryen.__i32_store8(out + i, bytes[i]);
    }
    binaryen._BinaryenLiteralVec128(out, out);
    return binaryen._BinaryenConst(this.ref, out);
  }

  ref_null(type: TypeRef): ExpressionRef {
    return binaryen._BinaryenRefNull(this.ref, type);
  }

  ref_eq(left: ExpressionRef, right: ExpressionRef): ExpressionRef {
    return binaryen._BinaryenRefEq(this.ref, left, right);
  }

  // expressions

  unary(
    op: UnaryOp,
    value: ExpressionRef
  ): ExpressionRef {
    if (op > UnaryOp._last) {
      let isWam64 = this.sizeType == TypeRef.I64;
      switch (op) {
        case UnaryOp.ClzSize: return this.unary(isWam64 ? UnaryOp.ClzI64 : UnaryOp.ClzI32, value);
        case UnaryOp.CtzSize: return this.unary(isWam64 ? UnaryOp.CtzI64 : UnaryOp.CtzI32, value);
        case UnaryOp.PopcntSize: return this.unary(isWam64 ? UnaryOp.PopcntI64 : UnaryOp.PopcntI32, value);
        case UnaryOp.EqzSize: return this.unary(isWam64 ? UnaryOp.EqzI64 : UnaryOp.EqzI32, value);
      }
      assert(false);
    }
    return binaryen._BinaryenUnary(this.ref, op, value);
  }

  binary(
    op: BinaryOp,
    left: ExpressionRef,
    right: ExpressionRef
  ): ExpressionRef {
    if (op > BinaryOp._last) {
      let isWasm64 = this.sizeType == TypeRef.I64;
      switch (op) {
        case BinaryOp.AddSize: return this.binary(isWasm64 ? BinaryOp.AddI64 : BinaryOp.AddI32, left, right);
        case BinaryOp.SubSize: return this.binary(isWasm64 ? BinaryOp.SubI64 : BinaryOp.SubI32, left, right);
        case BinaryOp.MulSize: return this.binary(isWasm64 ? BinaryOp.MulI64 : BinaryOp.MulI32, left, right);
        case BinaryOp.DivISize: return this.binary(isWasm64 ? BinaryOp.DivI64 : BinaryOp.DivI32, left, right);
        case BinaryOp.DivUSize: return this.binary(isWasm64 ? BinaryOp.DivU64 : BinaryOp.DivU32, left, right);
        case BinaryOp.RemISize: return this.binary(isWasm64 ? BinaryOp.RemI64 : BinaryOp.RemI32, left, right);
        case BinaryOp.RemUSize: return this.binary(isWasm64 ? BinaryOp.RemU64 : BinaryOp.RemU32, left, right);
        case BinaryOp.AndSize: return this.binary(isWasm64 ? BinaryOp.AndI64 : BinaryOp.AndI32, left, right);
        case BinaryOp.OrSize: return this.binary(isWasm64 ? BinaryOp.OrI64 : BinaryOp.OrI32, left, right);
        case BinaryOp.XorSize: return this.binary(isWasm64 ? BinaryOp.XorI64 : BinaryOp.XorI32, left, right);
        case BinaryOp.ShlSize: return this.binary(isWasm64 ? BinaryOp.ShlI64 : BinaryOp.ShlI32, left, right);
        case BinaryOp.ShrISize: return this.binary(isWasm64 ? BinaryOp.ShrI64 : BinaryOp.ShrI32, left, right);
        case BinaryOp.ShrUSize: return this.binary(isWasm64 ? BinaryOp.ShrU64 : BinaryOp.ShrU32, left, right);
        case BinaryOp.RotlSize: return this.binary(isWasm64 ? BinaryOp.RotlI64 : BinaryOp.RotlI32, left, right);
        case BinaryOp.RotrSize: return this.binary(isWasm64 ? BinaryOp.RotrI64 : BinaryOp.RotrI32, left, right);
        case BinaryOp.EqSize: return this.binary(isWasm64 ? BinaryOp.EqI64 : BinaryOp.EqI32, left, right);
        case BinaryOp.NeSize: return this.binary(isWasm64 ? BinaryOp.NeI64 : BinaryOp.NeI32, left, right);
        case BinaryOp.LtISize: return this.binary(isWasm64 ? BinaryOp.LtI64 : BinaryOp.LtI32, left, right);
        case BinaryOp.LtUSize: return this.binary(isWasm64 ? BinaryOp.LtU64 : BinaryOp.LtU32, left, right);
        case BinaryOp.LeISize: return this.binary(isWasm64 ? BinaryOp.LeI64 : BinaryOp.LeI32, left, right);
        case BinaryOp.LeUSize: return this.binary(isWasm64 ? BinaryOp.LeU64 : BinaryOp.LeU32, left, right);
        case BinaryOp.GtISize: return this.binary(isWasm64 ? BinaryOp.GtI64 : BinaryOp.GtI32, left, right);
        case BinaryOp.GtUSize: return this.binary(isWasm64 ? BinaryOp.GtU64 : BinaryOp.GtU32, left, right);
        case BinaryOp.GeISize: return this.binary(isWasm64 ? BinaryOp.GeI64 : BinaryOp.GeI32, left, right);
        case BinaryOp.GeUSize: return this.binary(isWasm64 ? BinaryOp.GeU64 : BinaryOp.GeU32, left, right);
      }
      assert(false);
    }
    return binaryen._BinaryenBinary(this.ref, op, left, right);
  }

  memory_size(): ExpressionRef {
    return binaryen._BinaryenMemorySize(this.ref);
  }

  memory_grow(delta: ExpressionRef): ExpressionRef {
    return binaryen._BinaryenMemoryGrow(this.ref, delta);
  }

  local_get(
    index: i32,
    type: TypeRef
  ): ExpressionRef {
    return binaryen._BinaryenLocalGet(this.ref, index, type);
  }

  tostack(value: ExpressionRef): ExpressionRef {
    if (this.useShadowStack) {
      let type = binaryen._BinaryenExpressionGetType(value);
      assert(type == TypeRef.I32 || type == TypeRef.Unreachable);
      return this.call(BuiltinNames.tostack, [ value ], type);
    }
    return value;
  }

  local_tee(
    index: i32,
    value: ExpressionRef,
    isManaged: bool,
    type: TypeRef = TypeRef.Auto,
  ): ExpressionRef {
    if (type == TypeRef.Auto) type = binaryen._BinaryenExpressionGetType(value);
    if (isManaged && this.useShadowStack) {
      value = this.tostack(value);
    }
    return binaryen._BinaryenLocalTee(this.ref, index, value, type);
  }

  global_get(
    name: string,
    type: TypeRef
  ): ExpressionRef {
    var cStr = this.allocStringCached(name);
    return binaryen._BinaryenGlobalGet(this.ref, cStr, type);
  }

  load(
    bytes: Index,
    signed: bool,
    ptr: ExpressionRef,
    type: TypeRef,
    offset: Index = 0,
    align: Index = bytes // naturally aligned by default
  ): ExpressionRef {
    return binaryen._BinaryenLoad(this.ref, bytes, signed, offset, align, type, ptr);
  }

  store(
    bytes: Index,
    ptr: ExpressionRef,
    value: ExpressionRef,
    type: TypeRef,
    offset: Index = 0,
    align: Index = bytes // naturally aligned by default
  ): ExpressionRef {
    return binaryen._BinaryenStore(this.ref, bytes, offset, align, ptr, value, type);
  }

  atomic_load(
    bytes: Index,
    ptr: ExpressionRef,
    type: TypeRef,
    offset: Index = 0
  ): ExpressionRef {
    return binaryen._BinaryenAtomicLoad(this.ref, bytes, offset, type, ptr);
  }

  atomic_store(
    bytes: Index,
    ptr: ExpressionRef,
    value: ExpressionRef,
    type: TypeRef,
    offset: Index = 0
  ): ExpressionRef {
    return binaryen._BinaryenAtomicStore(this.ref, bytes, offset, ptr, value, type);
  }

  atomic_rmw(
    op: AtomicRMWOp,
    bytes: Index,
    offset: Index,
    ptr: ExpressionRef,
    value: ExpressionRef,
    type: TypeRef
  ): ExpressionRef {
    return binaryen._BinaryenAtomicRMW(this.ref, op, bytes, offset, ptr, value, type);
  }

  atomic_cmpxchg(
    bytes: Index,
    offset: Index,
    ptr: ExpressionRef,
    expected: ExpressionRef,
    replacement: ExpressionRef,
    type: TypeRef
  ): ExpressionRef {
    return binaryen._BinaryenAtomicCmpxchg(this.ref, bytes, offset, ptr, expected, replacement, type);
  }

  atomic_wait(
    ptr: ExpressionRef,
    expected: ExpressionRef,
    timeout: ExpressionRef,
    expectedType: TypeRef
  ): ExpressionRef {
    return binaryen._BinaryenAtomicWait(this.ref, ptr, expected, timeout, expectedType);
  }

  atomic_notify(
    ptr: ExpressionRef,
    notifyCount: ExpressionRef
  ): ExpressionRef {
    return binaryen._BinaryenAtomicNotify(this.ref, ptr, notifyCount);
  }

  atomic_fence(): ExpressionRef {
    return binaryen._BinaryenAtomicFence(this.ref);
  }

  // statements

  local_set(
    index: Index,
    value: ExpressionRef,
    isManaged: bool
  ): ExpressionRef {
    if (isManaged && this.useShadowStack) {
      value = this.tostack(value);
    }
    return binaryen._BinaryenLocalSet(this.ref, index, value);
  }

  global_set(
    name: string,
    value: ExpressionRef
  ): ExpressionRef {
    var cStr = this.allocStringCached(name);
    return binaryen._BinaryenGlobalSet(this.ref, cStr, value);
  }

  block(
    label: string | null,
    children: ExpressionRef[],
    type: TypeRef = TypeRef.None
  ): ExpressionRef {
    var cStr = this.allocStringCached(label);
    var cArr = allocPtrArray(children);
    var ret = binaryen._BinaryenBlock(this.ref, cStr, cArr, children.length, type);
    binaryen._free(cArr);
    return ret;
  }

  /** Attempts to trivially flatten a series of expressions instead of emitting a block. */
  flatten(
    stmts: ExpressionRef[],
    type: TypeRef = TypeRef.None
  ): ExpressionRef {
    var length = stmts.length;
    if (length == 0) return this.nop(); // usually filtered out again
    if (length == 1) {
      let single = stmts[0];
      switch (getExpressionId(single)) {
        case ExpressionId.Return:
        case ExpressionId.Throw:
        case ExpressionId.Unreachable: {
          // type does no matter, terminates anyway
          return single;
        }
      }
      let singleType = getExpressionType(single);
      assert(singleType == TypeRef.Unreachable || singleType == type);
      return single;
    }
    return this.block(null, stmts, type);
  }

  br(
    label: string | null,
    condition: ExpressionRef = 0,
    value: ExpressionRef = 0
  ): ExpressionRef {
    var cStr = this.allocStringCached(label);
    return binaryen._BinaryenBreak(this.ref, cStr, condition, value);
  }

  drop(
    expression: ExpressionRef
  ): ExpressionRef {
    return binaryen._BinaryenDrop(this.ref, expression);
  }

  maybeDropCondition(condition: ExpressionRef, result: ExpressionRef): ExpressionRef {
    // FIXME: This is necessary because Binaryen's ExpressionRunner bails early
    // when encountering a local with an unknown value. This helper only drops
    // the pre-evaluated condition if it has relevant side effects.
    // see WebAssembly/binaryen#1237
    if ((getSideEffects(condition) & ~(SideEffects.ReadsLocal | SideEffects.ReadsGlobal)) != 0) {
      return this.block(null, [
        this.drop(condition),
        result
      ], getExpressionType(result));
    }
    return result;
  }

  loop(
    label: string | null,
    body: ExpressionRef
  ): ExpressionRef {
    var cStr = this.allocStringCached(label);
    return binaryen._BinaryenLoop(this.ref, cStr, body);
  }

  if(
    condition: ExpressionRef,
    ifTrue: ExpressionRef,
    ifFalse: ExpressionRef = 0
  ): ExpressionRef {
    return binaryen._BinaryenIf(this.ref, condition, ifTrue, ifFalse);
  }

  nop(): ExpressionRef {
    return binaryen._BinaryenNop(this.ref);
  }

  return(
    expression: ExpressionRef = 0
  ): ExpressionRef {
    return binaryen._BinaryenReturn(this.ref, expression);
  }

  select(
    ifTrue: ExpressionRef,
    ifFalse: ExpressionRef,
    condition: ExpressionRef,
    type: TypeRef = TypeRef.Auto
  ): ExpressionRef {
    if (type == TypeRef.Auto) {
      type = binaryen._BinaryenExpressionGetType(ifTrue);
      assert(type == binaryen._BinaryenExpressionGetType(ifFalse));
    }
    return binaryen._BinaryenSelect(this.ref, condition, ifTrue, ifFalse, type);
  }

  switch(
    names: string[],
    defaultName: string | null,
    condition: ExpressionRef,
    value: ExpressionRef = 0
  ): ExpressionRef {
    var numNames = names.length;
    var strs = new Array<StringRef>(numNames);
    for (let i = 0; i < numNames; ++i) {
      strs[i] = this.allocStringCached(names[i]);
    }
    var cArr = allocPtrArray(strs);
    var cStr = this.allocStringCached(defaultName);
    var ret = binaryen._BinaryenSwitch(this.ref, cArr, numNames, cStr, condition, value);
    binaryen._free(cArr);
    return ret;
  }

  call(
    target: string,
    operands: ExpressionRef[] | null,
    returnType: TypeRef,
    isReturn: bool = false
  ): ExpressionRef {
    var cStr = this.allocStringCached(target);
    var cArr = allocPtrArray(operands);
    var ret = isReturn
      ? binaryen._BinaryenReturnCall(
          this.ref, cStr, cArr, operands ? operands.length : 0, returnType
        )
      : binaryen._BinaryenCall(
          this.ref, cStr, cArr, operands ? operands.length : 0, returnType
        );
    binaryen._free(cArr);
    return ret;
  }

  return_call(
    target: string,
    operands: ExpressionRef[] | null,
    returnType: TypeRef
  ): ExpressionRef {
    return this.call(target, operands, returnType, true);
  }

  call_indirect(
    index: ExpressionRef,
    operands: ExpressionRef[] | null,
    params: TypeRef,
    results: TypeRef,
    isReturn: bool = false
  ): ExpressionRef {
    var cStr = this.allocStringCached("0"); // TODO: multiple tables
    var cArr = allocPtrArray(operands);
    var ret = isReturn
      ? binaryen._BinaryenReturnCallIndirect(
          this.ref, cStr, index, cArr, operands ? operands.length : 0, params, results
        )
      : binaryen._BinaryenCallIndirect(
          this.ref, cStr, index, cArr, operands ? operands.length : 0, params, results
        );
    binaryen._free(cArr);
    return ret;
  }

  return_call_indirect(
    tableName: string,
    index: ExpressionRef,
    operands: ExpressionRef[] | null,
    params: TypeRef,
    results: TypeRef
  ): ExpressionRef {
    return this.call_indirect(index, operands, params, results, true);
  }

  unreachable(): ExpressionRef {
    return binaryen._BinaryenUnreachable(this.ref);
  }

  // bulk memory

  memory_copy(
    dest: ExpressionRef,
    source: ExpressionRef,
    size: ExpressionRef
  ): ExpressionRef {
    return binaryen._BinaryenMemoryCopy(this.ref, dest, source, size);
  }

  memory_fill(
    dest: ExpressionRef,
    value: ExpressionRef,
    size: ExpressionRef
  ): ExpressionRef {
    return binaryen._BinaryenMemoryFill(this.ref, dest, value, size);
  }

  // exception handling

  // try(
  //   body: ExpressionRef,
  //   catchTags: string[],
  //   catchBodies: ExpressionRef[]
  // ): ExpressionRef {
  //   var numCatchTags = catchTags.length;
  //   var strs = new Array<TagRef>(numCatchTags);
  //   for (let i = 0; i < numCatchTags; ++i) {
  //     strs[i] = this.allocStringCached(catchTags[i]);
  //   }
  //   var cArr1 = allocPtrArray(strs);
  //   var cArr2 = allocPtrArray(catchBodies);
  //   var ret = binaryen._BinaryenTry(this.ref, body, cArr1, numCatchTags, cArr2, catchBodies.length);
  //   binaryen._free(cArr2);
  //   binaryen._free(cArr1);
  //   return ret;
  // }

  throw(
    tagName: string,
    operands: ExpressionRef[]
  ): ExpressionRef {
    var cStr = this.allocStringCached(tagName);
    var cArr = allocPtrArray(operands);
    var ret = binaryen._BinaryenThrow(this.ref, cStr, cArr, operands.length);
    binaryen._free(cArr);
    return ret;
  }

  rethrow(
    target: string
  ): ExpressionRef {
    var cStr = this.allocStringCached(target);
    return binaryen._BinaryenRethrow(this.ref, cStr);
  }

  // multi value (pseudo instructions)

  pop(
    type: TypeRef
  ): ExpressionRef {
    return binaryen._BinaryenPop(this.ref, type);
  }

  tuple_make(operands: ExpressionRef[]): ExpressionRef {
    var cArr = allocPtrArray(operands);
    var ret = binaryen._BinaryenTupleMake(this.ref, cArr, operands.length);
    binaryen._free(cArr);
    return ret;
  }

  tuple_extract(tuple: ExpressionRef, index: Index): ExpressionRef {
    return binaryen._BinaryenTupleExtract(this.ref, tuple, index);
  }

  // simd

  simd_extract(
    op: SIMDExtractOp,
    vec: ExpressionRef,
    idx: u8
  ): ExpressionRef {
    return binaryen._BinaryenSIMDExtract(this.ref, op, vec, idx);
  }

  simd_replace(
    op: SIMDReplaceOp,
    vec: ExpressionRef,
    idx: u8,
    value: ExpressionRef
  ): ExpressionRef {
    return binaryen._BinaryenSIMDReplace(this.ref, op, vec, idx, value);
  }

  simd_shuffle(
    vec1: ExpressionRef,
    vec2: ExpressionRef,
    mask: Uint8Array
  ): ExpressionRef {
    assert(mask.length == 16);
    var cArr = allocU8Array(mask);
    var ret = binaryen._BinaryenSIMDShuffle(this.ref, vec1, vec2, cArr);
    binaryen._free(cArr);
    return ret;
  }

  simd_ternary(
    op: SIMDTernaryOp,
    a: ExpressionRef,
    b: ExpressionRef,
    c: ExpressionRef
  ): ExpressionRef {
    return binaryen._BinaryenSIMDTernary(this.ref, op, a, b, c);
  }

  simd_shift(
    op: SIMDShiftOp,
    vec: ExpressionRef,
    shift: ExpressionRef
  ): ExpressionRef {
    return binaryen._BinaryenSIMDShift(this.ref, op, vec, shift);
  }

  simd_load(
    op: SIMDLoadOp,
    ptr: ExpressionRef,
    offset: u32,
    align: u32
  ): ExpressionRef {
    return binaryen._BinaryenSIMDLoad(this.ref, op, offset, align, ptr);
  }

  simd_loadstorelane(
    op: SIMDLoadStoreLaneOp,
    ptr: ExpressionRef,
    offset: u32,
    align: u32,
    index: u8,
    vec: ExpressionRef
  ): ExpressionRef {
    return binaryen._BinaryenSIMDLoadStoreLane(this.ref, op, offset, align, index, ptr, vec);
  }

  // reference types / gc

  ref_is(
    op: RefIsOp,
    expr: ExpressionRef
  ): ExpressionRef {
    return binaryen._BinaryenRefIs(this.ref, op, expr);
  }

  ref_as(
    op: RefAsOp,
    expr: ExpressionRef
  ): ExpressionRef {
    return binaryen._BinaryenRefAs(this.ref, op, expr);
  }

  ref_func(
    name: string,
    type: TypeRef
  ): ExpressionRef {
    var cStr = this.allocStringCached(name);
    return binaryen._BinaryenRefFunc(this.ref, cStr, type);
  }

  i31_new(
    value: ExpressionRef
  ): ExpressionRef {
    return binaryen._BinaryenI31New(this.ref, value);
  }

  i31_get(
    expr: ExpressionRef,
    signed: bool
  ): ExpressionRef {
    return binaryen._BinaryenI31Get(this.ref, expr, signed);
  }

  // globals

  addGlobal(
    name: string,
    type: TypeRef,
    mutable: bool,
    initializer: ExpressionRef
  ): GlobalRef {
    var cStr = this.allocStringCached(name);
    return binaryen._BinaryenAddGlobal(this.ref, cStr, type, mutable, initializer);
  }

  getGlobal(
    name: string
  ): GlobalRef {
    var cStr = this.allocStringCached(name);
    return binaryen._BinaryenGetGlobal(this.ref, cStr);
  }

  removeGlobal(
    name: string
  ): void {
    var cStr = this.allocStringCached(name);
    binaryen._BinaryenRemoveGlobal(this.ref, cStr);
  }

  // tags

  addTag(
    name: string,
    params: TypeRef,
    results: TypeRef
  ): TagRef {
    var cStr = this.allocStringCached(name);
    return binaryen._BinaryenAddTag(this.ref, cStr, params, results);
  }

  getTag(
    name: string
  ): TagRef {
    var cStr = this.allocStringCached(name);
    return binaryen._BinaryenGetTag(this.ref, cStr);
  }

  removeTag(
    name: string
  ): void {
    var cStr = this.allocStringCached(name);
    binaryen._BinaryenRemoveTag(this.ref, cStr);
  }

  // functions

  addFunction(
    name: string,
    params: TypeRef,
    results: TypeRef,
    varTypes: TypeRef[] | null,
    body: ExpressionRef
  ): FunctionRef {
    var cStr = this.allocStringCached(name);
    var cArr = allocPtrArray(varTypes);
    var ret = binaryen._BinaryenAddFunction(
      this.ref,
      cStr,
      params,
      results,
      cArr,
      varTypes ? varTypes.length : 0,
      body
    );
    binaryen._free(cArr);
    return ret;
  }

  getFunction(
    name: string
  ): FunctionRef {
    var cStr = this.allocStringCached(name);
    return binaryen._BinaryenGetFunction(this.ref, cStr);
  }

  removeFunction(name: string): void {
    var cStr = this.allocStringCached(name);
    binaryen._BinaryenRemoveFunction(this.ref, cStr);
  }

  hasFunction(name: string): bool {
    var cStr = this.allocStringCached(name);
    return binaryen._BinaryenGetFunction(this.ref, cStr) != 0;
  }

  private hasTemporaryFunction: bool = false;

  addTemporaryFunction(
    result: TypeRef,
    paramTypes: TypeRef[] | null,
    body: ExpressionRef
  ): FunctionRef {
    this.hasTemporaryFunction = assert(!this.hasTemporaryFunction);
    var tempName = this.allocStringCached("");
    var cArr = allocPtrArray(paramTypes);
    var ret = binaryen._BinaryenAddFunction(this.ref,
      tempName,
      createType(paramTypes),
      result,
      0, 0,
      body
    );
    binaryen._free(cArr);
    return ret;
  }

  removeTemporaryFunction(): void {
    this.hasTemporaryFunction = !assert(this.hasTemporaryFunction);
    var tempName = this.allocStringCached("");
    binaryen._BinaryenRemoveFunction(this.ref, tempName);
  }

  setStart(func: FunctionRef): void {
    binaryen._BinaryenSetStart(this.ref, func);
  }

  // exports

  addFunctionExport(
    internalName: string,
    externalName: string
  ): ExportRef {
    var cStr1 = this.allocStringCached(internalName);
    var cStr2 = this.allocStringCached(externalName);
    return binaryen._BinaryenAddFunctionExport(this.ref, cStr1, cStr2);
  }

  addTableExport(
    internalName: string,
    externalName: string
  ): ExportRef {
    var cStr1 = this.allocStringCached(internalName);
    var cStr2 = this.allocStringCached(externalName);
    return binaryen._BinaryenAddTableExport(this.ref, cStr1, cStr2);
  }

  addMemoryExport(
    internalName: string,
    externalName: string
  ): ExportRef {
    var cStr1 = this.allocStringCached(internalName);
    var cStr2 = this.allocStringCached(externalName);
    return binaryen._BinaryenAddMemoryExport(this.ref, cStr1, cStr2);
  }

  addGlobalExport(
    internalName: string,
    externalName: string
  ): ExportRef {
    var cStr1 = this.allocStringCached(internalName);
    var cStr2 = this.allocStringCached(externalName);
    return binaryen._BinaryenAddGlobalExport(this.ref, cStr1, cStr2);
  }

  addTagExport(
    internalName: string,
    externalName: string
  ): ExportRef {
    var cStr1 = this.allocStringCached(internalName);
    var cStr2 = this.allocStringCached(externalName);
    return binaryen._BinaryenAddTagExport(this.ref, cStr1, cStr2);
  }

  removeExport(externalName: string): void {
    var cStr = this.allocStringCached(externalName);
    binaryen._BinaryenRemoveExport(this.ref, cStr);
  }

  hasExport(externalName: string): bool {
    var cStr = this.allocStringCached(externalName);
    return binaryen._BinaryenGetExport(this.ref, cStr) != 0;
  }

  // imports

  addFunctionImport(
    internalName: string,
    externalModuleName: string,
    externalBaseName: string,
    params: TypeRef,
    results: TypeRef
  ): void {
    var cStr1 = this.allocStringCached(internalName);
    var cStr2 = this.allocStringCached(externalModuleName);
    var cStr3 = this.allocStringCached(externalBaseName);
    binaryen._BinaryenAddFunctionImport(this.ref, cStr1, cStr2, cStr3, params, results);
  }

  addTableImport(
    internalName: string,
    externalModuleName: string,
    externalBaseName: string
  ): void {
    var cStr1 = this.allocStringCached(internalName);
    var cStr2 = this.allocStringCached(externalModuleName);
    var cStr3 = this.allocStringCached(externalBaseName);
    binaryen._BinaryenAddTableImport(this.ref, cStr1, cStr2, cStr3);
  }

  addMemoryImport(
    internalName: string,
    externalModuleName: string,
    externalBaseName: string,
    shared: bool = false,
  ): void {
    var cStr1 = this.allocStringCached(internalName);
    var cStr2 = this.allocStringCached(externalModuleName);
    var cStr3 = this.allocStringCached(externalBaseName);
    binaryen._BinaryenAddMemoryImport(this.ref, cStr1, cStr2, cStr3, shared);
  }

  addGlobalImport(
    internalName: string,
    externalModuleName: string,
    externalBaseName: string,
    globalType: TypeRef,
    mutable: bool = false
  ): void {
    var cStr1 = this.allocStringCached(internalName);
    var cStr2 = this.allocStringCached(externalModuleName);
    var cStr3 = this.allocStringCached(externalBaseName);
    binaryen._BinaryenAddGlobalImport(this.ref, cStr1, cStr2, cStr3, globalType, mutable);
  }

  addTagImport(
    internalName: string,
    externalModuleName: string,
    externalBaseName: string,
    params: TypeRef,
    results: TypeRef
  ): void {
    var cStr1 = this.allocStringCached(internalName);
    var cStr2 = this.allocStringCached(externalModuleName);
    var cStr3 = this.allocStringCached(externalBaseName);
    binaryen._BinaryenAddTagImport(
      this.ref, cStr1, cStr2, cStr3, params, results
    );
  }

  // memory

  /** Unlimited memory constant. */
  static readonly UNLIMITED_MEMORY: Index = <Index>-1;

  setMemory(
    initial: Index,
    maximum: Index,
    segments: MemorySegment[],
    target: Target,
    exportName: string | null = null,
    shared: bool = false
  ): void {
    var cStr = this.allocStringCached(exportName);
    var k = segments.length;
    var segs = new Array<usize>(k);
    var psvs = new Uint8Array(k);
    var offs = new Array<ExpressionRef>(k);
    var sizs = new Array<Index>(k);
    for (let i = 0; i < k; ++i) {
      let segment = segments[i];
      let buffer = segment.buffer;
      let offset = segment.offset;
      segs[i] = allocU8Array(buffer);
      psvs[i] = 0; // no passive segments currently
      offs[i] = target == Target.WASM64
        ? this.i64(i64_low(offset), i64_high(offset))
        : this.i32(i64_low(offset));
      sizs[i] = buffer.length;
    }
    var cArr1 = allocPtrArray(segs);
    var cArr2 = allocU8Array(psvs);
    var cArr3 = allocPtrArray(offs);
    var cArr4 = allocU32Array(sizs);
    binaryen._BinaryenSetMemory(
      this.ref, initial, maximum, cStr, cArr1, cArr2, cArr3, cArr4, k, shared
    );
    binaryen._free(cArr4);
    binaryen._free(cArr3);
    binaryen._free(cArr2);
    binaryen._free(cArr1);
    for (let i = k - 1; i >= 0; --i) {
      binaryen._free(segs[i]);
    }
  }

  // table

  /** Unlimited table constant. */
  static readonly UNLIMITED_TABLE: Index = <Index>-1;

  addFunctionTable(
    name: string,
    initial: Index,
    maximum: Index,
    funcs: string[],
    offset: ExpressionRef
  ): void {
    var cStr = this.allocStringCached(name);
    var numNames = funcs.length;
    var names = new Array<StringRef>(numNames);
    for (let i = 0; i < numNames; ++i) {
      names[i] = this.allocStringCached(funcs[i]);
    }
    var cArr = allocPtrArray(names);
    var tableRef = binaryen._BinaryenGetTable(this.ref, cStr);
    if (!tableRef) {
      tableRef = binaryen._BinaryenAddTable(this.ref, cStr, initial, maximum);
    } else {
      binaryen._BinaryenTableSetInitial(tableRef, initial);
      binaryen._BinaryenTableSetMax(tableRef, maximum);
    }
    binaryen._BinaryenAddActiveElementSegment(this.ref, cStr, cStr, cArr, numNames, offset);
    binaryen._free(cArr);
  }

  /* setFunctionTable(
    initial: Index,
    maximum: Index,
    funcs: string[],
    offset: ExpressionRef
  ): void {
    var numNames = funcs.length;
    var names = new Array<CString>(numNames);
    for (let i = 0; i < numNames; ++i) {
      names[i] = this.allocStringCached(funcs[i]);
    }
    var cArr = allocPtrArray(names);
    binaryen._BinaryenSetFunctionTable(
      this.ref, initial, maximum, cArr, numNames, offset
    );
    binaryen._free(cArr);
  } */

  // sections

  addCustomSection(name: string, contents: Uint8Array): void {
    var cStr = this.allocStringCached(name);
    var cArr = allocU8Array(contents);
    binaryen._BinaryenAddCustomSection(this.ref, cStr, cArr, contents.length);
    binaryen._free(cArr);
  }

  // meta (global)

  getOptimizeLevel(): i32 {
    return binaryen._BinaryenGetOptimizeLevel();
  }

  setOptimizeLevel(level: i32): void {
    binaryen._BinaryenSetOptimizeLevel(level);
  }

  getShrinkLevel(): i32 {
    return binaryen._BinaryenGetShrinkLevel();
  }

  setShrinkLevel(level: i32): void {
    binaryen._BinaryenSetShrinkLevel(level);
  }

  getDebugInfo(): boolean {
    return binaryen._BinaryenGetDebugInfo();
  }

  setDebugInfo(on: bool): void {
    binaryen._BinaryenSetDebugInfo(on);
  }

  getLowMemoryUnused(): bool {
    return binaryen._BinaryenGetLowMemoryUnused();
  }

  setLowMemoryUnused(on: bool): void {
    binaryen._BinaryenSetLowMemoryUnused(on);
  }

  getFastMath(): bool {
    return binaryen._BinaryenGetFastMath();
  }

  setFastMath(on: bool): void {
    binaryen._BinaryenSetFastMath(on);
  }

  getPassArgument(key: string): string | null {
    var cStr = this.allocStringCached(key);
    var ptr = binaryen._BinaryenGetPassArgument(cStr);
    return ptr ? readString(ptr) : null;
  }

  setPassArgument(key: string, value: string | null): void {
    var cStr1 = this.allocStringCached(key);
    var cStr2 = this.allocStringCached(value);
    binaryen._BinaryenSetPassArgument(cStr1, cStr2);
  }

  clearPassArguments(): void {
    binaryen._BinaryenClearPassArguments();
  }

  getAlwaysInlineMaxSize(): Index {
    return binaryen._BinaryenGetAlwaysInlineMaxSize();
  }

  setAlwaysInlineMaxSize(size: Index): void {
    binaryen._BinaryenSetAlwaysInlineMaxSize(size);
  }

  getFlexibleInlineMaxSize(): Index {
    return binaryen._BinaryenGetFlexibleInlineMaxSize();
  }

  setFlexibleInlineMaxSize(size: Index): void {
    binaryen._BinaryenSetFlexibleInlineMaxSize(size);
  }

  getOneCallerInlineMaxSize(): Index {
    return binaryen._BinaryenGetOneCallerInlineMaxSize();
  }

  setOneCallerInlineMaxSize(size: Index): void {
    binaryen._BinaryenSetOneCallerInlineMaxSize(size);
  }

  getAllowInliningFunctionsWithLoops(): bool {
    return binaryen._BinaryenGetAllowInliningFunctionsWithLoops();
  }

  setAllowInliningFunctionsWithLoops(enabled: bool): void {
    binaryen._BinaryenSetAllowInliningFunctionsWithLoops(enabled);
  }

  // meta (module)

  getFeatures(): FeatureFlags {
    return binaryen._BinaryenModuleGetFeatures(this.ref);
  }

  setFeatures(featureFlags: FeatureFlags): void {
    binaryen._BinaryenModuleSetFeatures(this.ref, featureFlags);
  }

  runPasses(passes: string[], func: FunctionRef = 0): void {
    var numNames = passes.length;
    var cStrs = new Array<StringRef>(numNames);
    for (let i = 0; i < numNames; ++i) {
      cStrs[i] = allocString(passes[i]);
    }
    var cArr = allocPtrArray(cStrs);
    if (func) {
      binaryen._BinaryenFunctionRunPasses(func, this.ref, cArr, numNames);
    } else {
      binaryen._BinaryenModuleRunPasses(this.ref, cArr, numNames);
    }
    binaryen._free(cArr);
    for (let i = numNames - 1; i >= 0; --i) binaryen._free(cStrs[i]);
  }

  optimize(optimizeLevel: i32, shrinkLevel: i32, debugInfo: bool = false): void {
    // Implicitly run costly non-LLVM optimizations on -O3 or -Oz
    if (optimizeLevel >= 3 || shrinkLevel >= 2) optimizeLevel = 4;

    this.setOptimizeLevel(optimizeLevel);
    this.setShrinkLevel(shrinkLevel);
    this.setDebugInfo(debugInfo);
    this.setFastMath(true);
    this.clearPassArguments();

    // Tweak inlining limits based on optimization levels
    if (optimizeLevel >= 2 && shrinkLevel == 0) {
      this.setAlwaysInlineMaxSize(12);
      this.setFlexibleInlineMaxSize(70);
      this.setOneCallerInlineMaxSize(200);
      this.setAllowInliningFunctionsWithLoops(optimizeLevel >= 3);
    } else {
      this.setAlwaysInlineMaxSize(
        optimizeLevel <= 1 || shrinkLevel >= 2
          ? 2
          : 6
      );
      this.setFlexibleInlineMaxSize(65);
      this.setOneCallerInlineMaxSize(80);
      this.setAllowInliningFunctionsWithLoops(false);
    }

    // Pass order here differs substantially from Binaryen's defaults
    // see: Binaryen/src/pass.cpp
    if (optimizeLevel > 0 || shrinkLevel > 0) {
      let passes = new Array<string>();

      // --- PassRunner::addDefaultGlobalOptimizationPrePasses ---

      passes.push("duplicate-function-elimination");
      passes.push("remove-unused-module-elements"); // +

      // --- PassRunner::addDefaultFunctionOptimizationPasses ---

      if (optimizeLevel >= 3 || shrinkLevel >= 1) {
        passes.push("simplify-locals-notee-nostructure");
        passes.push("rse");
        passes.push("vacuum");
        passes.push("ssa-nomerge");
        passes.push("simplify-globals-optimizing");
        passes.push("remove-unused-brs");
        passes.push("remove-unused-names");
        passes.push("merge-blocks");
        passes.push("precompute-propagate");
      }
      if (optimizeLevel >= 3) {
        passes.push("flatten");
        passes.push("vacuum");
        passes.push("simplify-locals-notee-nostructure");
        passes.push("merge-locals");

        passes.push("code-folding");
        passes.push("flatten");
        passes.push("vacuum");
        passes.push("local-cse");
        passes.push("reorder-locals");
      }
      passes.push("optimize-instructions");
      if (optimizeLevel >= 3 || shrinkLevel >= 1) {
        passes.push("dce");
      }
      passes.push("remove-unused-names");
      passes.push("remove-unused-brs");
      if (optimizeLevel >= 3 || shrinkLevel >= 2) {
        passes.push("inlining");
        passes.push("precompute-propagate");
      } else {
        passes.push("precompute");
      }
      if (optimizeLevel >= 2 || shrinkLevel >= 1) {
        passes.push("pick-load-signs");
        passes.push("simplify-globals-optimizing");
      }
      if (optimizeLevel >= 3 && shrinkLevel <= 1) {
        passes.push("licm");
      }
      passes.push("simplify-locals-nostructure");
      passes.push("vacuum");

      passes.push("reorder-locals");
      passes.push("remove-unused-brs");
      passes.push("coalesce-locals");
      passes.push("simplify-locals");
      passes.push("vacuum");

      passes.push("reorder-locals");
      passes.push("coalesce-locals");
      passes.push("reorder-locals");
      if (optimizeLevel >= 3 || shrinkLevel >= 1) {
        passes.push("merge-locals");
      }
      passes.push("vacuum");
      if (optimizeLevel >= 2 || shrinkLevel >= 1) {
        passes.push("simplify-globals-optimizing");
      }
      passes.push("merge-blocks");
      passes.push("remove-unused-brs");
      passes.push("remove-unused-names");
      passes.push("merge-blocks");
      if (optimizeLevel >= 3) {
        passes.push("optimize-instructions");
      }
      if (optimizeLevel >= 2 || shrinkLevel >= 1) {
        passes.push("rse");
        passes.push("vacuum");
      }

      // --- PassRunner::addDefaultGlobalOptimizationPostPasses ---

      if (optimizeLevel >= 2 || shrinkLevel >= 1) {
        passes.push("simplify-globals-optimizing");
        passes.push("dae-optimizing");
      }
      if (optimizeLevel >= 2 || shrinkLevel >= 2) {
        passes.push("inlining-optimizing");
      }
      if (this.getLowMemoryUnused()) {
        if (optimizeLevel >= 3 || shrinkLevel >= 1) {
          passes.push("optimize-added-constants-propagate");
        } else {
          passes.push("optimize-added-constants");
        }
      }
      passes.push("duplicate-import-elimination");
      if (optimizeLevel >= 2 || shrinkLevel >= 2) {
        passes.push("simplify-globals-optimizing");
      } else {
        passes.push("simplify-globals");
        passes.push("vacuum");
      }
      if (optimizeLevel >= 3 || shrinkLevel >= 1) {
        passes.push("code-folding");
      }
      if (optimizeLevel > 1 && (this.getFeatures() & FeatureFlags.GC) != 0) {
        passes.push("heap2local");
      }
      // precompute works best after global optimizations
      if (optimizeLevel >= 2 || shrinkLevel >= 1) {
        passes.push("precompute-propagate");
      } else {
        passes.push("precompute");
      }
      passes.push("directize"); // replace indirect with direct calls
      passes.push("dae-optimizing"); // reduce arity
      passes.push("inlining-optimizing"); // and inline if possible
      if (optimizeLevel >= 2 || shrinkLevel >= 1) {
        passes.push("rse");
        // move code on early return (after CFG cleanup)
        passes.push("code-pushing");
        if (optimizeLevel >= 3) {
          // very expensive, so O3 only
          passes.push("simplify-globals");
          passes.push("vacuum");

          passes.push("precompute-propagate");

          // replace indirect with direct calls again and inline
          passes.push("inlining-optimizing");
          passes.push("directize");
          passes.push("dae-optimizing");

          passes.push("merge-locals");
          passes.push("coalesce-locals");
          passes.push("simplify-locals");
          passes.push("vacuum");

          passes.push("inlining");
          passes.push("precompute-propagate");
          passes.push("vacuum");

          passes.push("coalesce-locals");
        }
        passes.push("remove-unused-brs");
        passes.push("remove-unused-names");
        passes.push("vacuum");

        passes.push("optimize-instructions");
        passes.push("simplify-globals-optimizing");
      }
      // clean up
      passes.push("duplicate-function-elimination");
      passes.push("remove-unused-nonfunction-module-elements");
      passes.push("memory-packing");
      passes.push("remove-unused-module-elements");

      this.runPasses(passes);
    }
  }

  validate(): bool {
    return binaryen._BinaryenModuleValidate(this.ref) == 1;
  }

  interpret(): void {
    binaryen._BinaryenModuleInterpret(this.ref);
  }

  toBinary(sourceMapUrl: string | null = null): BinaryModule {
    var out = this.lit; // safe to reuse as long as..
    assert(binaryen._BinaryenSizeofLiteral() >= 12);
    var cStr = allocString(sourceMapUrl);
    var binaryPtr: usize = 0;
    var sourceMapPtr: usize = 0;
    binaryen._BinaryenModuleAllocateAndWrite(out, this.ref, cStr);
    binaryPtr = assert(binaryen.__i32_load(out));
    var binaryLen = binaryen.__i32_load(out + 4);
    sourceMapPtr = binaryen.__i32_load(out + 8); // may be NULL
    var binary = new BinaryModule(readBuffer(binaryPtr, binaryLen), readString(sourceMapPtr));
    if (cStr) binaryen._free(cStr);
    binaryen._free(binaryPtr);
    if (sourceMapPtr) binaryen._free(sourceMapPtr);
    return binary;
  }

  toText(watFormat: bool = true): string {
    throw new Error("not implemented"); // JS glue overrides this
  }

  toAsmjs(): string {
    throw new Error("not implemented"); // JS glue overrides this
  }

  private cachedStringsToPointers: Map<string,usize> = new Map();
  private cachedPointersToStrings: Map<usize,string | null> = new Map();

  allocStringCached(str: string | null): usize {
    if (str === null) return 0;
    var cached = this.cachedStringsToPointers;
    if (cached.has(str)) return changetype<usize>(cached.get(str));
    var ptr = allocString(str);
    cached.set(str, ptr);
    return ptr;
  }

  readStringCached(ptr: usize): string | null {
    // Binaryen internalizes names, so using this method where it's safe can
    // avoid quite a bit of unnecessary garbage.
    if (ptr == 0) return null;
    var cached = this.cachedPointersToStrings;
    if (cached.has(ptr)) return changetype<string>(this.cachedPointersToStrings.get(ptr));
    var str = readString(ptr);
    cached.set(ptr, str);
    return str;
  }

  dispose(): void {
    assert(this.ref);
    // TODO: for (let ptr of this.cachedStrings.values()) {
    for (let _values = Map_values(this.cachedStringsToPointers), i = 0, k = _values.length; i < k; ++i) {
      let ptr = unchecked(_values[i]);
      binaryen._free(ptr);
    }
    this.cachedStringsToPointers.clear();
    this.cachedPointersToStrings.clear();
    binaryen._free(this.lit);
    binaryen._BinaryenModuleDispose(this.ref);
    this.ref = 0;
  }

  createRelooper(): Relooper {
    return Relooper.create(this);
  }

  cloneExpression(
    expr: ExpressionRef,
    noSideEffects: bool = false,
    maxDepth: i32 = i32.MAX_VALUE
  ): ExpressionRef { // currently supports side effect free expressions only
    if (maxDepth < 0) return 0;
    maxDepth -= 1;

    var nested1: ExpressionRef,
        nested2: ExpressionRef;

    switch (binaryen._BinaryenExpressionGetId(expr)) {
      case ExpressionId.Const: {
        switch (<u32>binaryen._BinaryenExpressionGetType(expr)) {
          case <u32>TypeRef.I32: {
            return this.i32(binaryen._BinaryenConstGetValueI32(expr));
          }
          case <u32>TypeRef.I64: {
            return this.i64(
              binaryen._BinaryenConstGetValueI64Low(expr),
              binaryen._BinaryenConstGetValueI64High(expr)
            );
          }
          case <u32>TypeRef.F32: {
            return this.f32(binaryen._BinaryenConstGetValueF32(expr));
          }
          case <u32>TypeRef.F64: {
            return this.f64(binaryen._BinaryenConstGetValueF64(expr));
          }
          case <u32>TypeRef.V128: {
            // TODO
            return 0;
          }
          // Not possible to clone an externref as it is opaque
          case <u32>TypeRef.Externref: {
            return 0;
          }
          default: {
            throw new Error("concrete type expected");
          }
        }
      }
      case ExpressionId.LocalGet: {
        return binaryen._BinaryenLocalGet(this.ref,
          binaryen._BinaryenLocalGetGetIndex(expr),
          binaryen._BinaryenExpressionGetType(expr)
        );
      }
      case ExpressionId.GlobalGet: {
        let globalName = binaryen._BinaryenGlobalGetGetName(expr);
        if (!globalName) break;
        return binaryen._BinaryenGlobalGet(
          this.ref, globalName, binaryen._BinaryenExpressionGetType(expr)
        );
      }
      case ExpressionId.Load: {
        if (!(nested1 = this.cloneExpression(
          binaryen._BinaryenLoadGetPtr(expr), noSideEffects, maxDepth)
        )) {
          break;
        }
        return (
          binaryen._BinaryenLoadIsAtomic(expr)
            ? binaryen._BinaryenAtomicLoad(this.ref,
                binaryen._BinaryenLoadGetBytes(expr),
                binaryen._BinaryenLoadGetOffset(expr),
                binaryen._BinaryenExpressionGetType(expr),
                nested1
              )
            : binaryen._BinaryenLoad(this.ref,
                binaryen._BinaryenLoadGetBytes(expr),
                binaryen._BinaryenLoadIsSigned(expr),
                binaryen._BinaryenLoadGetOffset(expr),
                binaryen._BinaryenLoadGetAlign(expr),
                binaryen._BinaryenExpressionGetType(expr),
                nested1
              )
        );
      }
      case ExpressionId.Unary: {
        if (!(nested1 = this.cloneExpression(
          binaryen._BinaryenUnaryGetValue(expr), noSideEffects, maxDepth)
        )) {
          break;
        }
        return binaryen._BinaryenUnary(
          this.ref, binaryen._BinaryenUnaryGetOp(expr), nested1
        );
      }
      case ExpressionId.Binary: {
        if (!(nested1 = this.cloneExpression(
          binaryen._BinaryenBinaryGetLeft(expr), noSideEffects, maxDepth)
        )) {
          break;
        }
        if (!(nested2 = this.cloneExpression(
          binaryen._BinaryenBinaryGetRight(expr), noSideEffects, maxDepth)
        )) {
          break;
        }
        return binaryen._BinaryenBinary(
          this.ref, binaryen._BinaryenBinaryGetOp(expr), nested1, nested2
        );
      }
    }
    return 0;
  }

  copyExpression(expr: ExpressionRef): ExpressionRef {
    return binaryen._BinaryenExpressionCopy(expr, this.ref);
  }

  runExpression(
    expr: ExpressionRef,
    flags: ExpressionRunnerFlags,
    maxDepth: i32 = 50,
    maxLoopIterations: i32 = 1
  ): ExpressionRef {
    var runner = binaryen._ExpressionRunnerCreate(this.ref, flags, maxDepth, maxLoopIterations);
    var precomp =  binaryen._ExpressionRunnerRunAndDispose(runner, expr);
    if (precomp) {
      assert(getExpressionId(precomp) == ExpressionId.Const);
      assert(getExpressionType(precomp) == getExpressionType(expr));
    }
    return precomp;
  }

  // source map generation

  addDebugInfoFile(name: string): Index {
    var cStr = allocString(name);
    var ret = binaryen._BinaryenModuleAddDebugInfoFileName(this.ref, cStr);
    binaryen._free(cStr);
    return ret;
  }

  getDebugInfoFile(index: Index): string | null {
    return readString(binaryen._BinaryenModuleGetDebugInfoFileName(this.ref, index));
  }

  setDebugLocation(
    func: FunctionRef,
    expr: ExpressionRef,
    fileIndex: Index,
    lineNumber: Index,
    columnNumber: Index
  ): void {
    binaryen._BinaryenFunctionSetDebugLocation(func, expr, fileIndex, lineNumber, columnNumber);
  }
}

// types

export function createType(types: TypeRef[] | null): TypeRef {
  if (!types) return TypeRef.None;
  switch (types.length) {
    case 0: return TypeRef.None;
    case 1: return types[0];
  }
  var cArr = allocPtrArray(types);
  var ret = binaryen._BinaryenTypeCreate(cArr, types.length);
  binaryen._free(cArr);
  return ret;
}

export function expandType(type: TypeRef): TypeRef[] {
  var arity = binaryen._BinaryenTypeArity(type);
  var cArr = binaryen._malloc(<usize>arity << 2);
  binaryen._BinaryenTypeExpand(type, cArr);
  var types = new Array<TypeRef>(arity);
  for (let i: u32 = 0; i < arity; ++i) {
    types[i] = binaryen.__i32_load(cArr + (<usize>i << 2));
  }
  binaryen._free(cArr);
  return types;
}

// expressions

export function getExpressionId(expr: ExpressionRef): ExpressionId {
  return binaryen._BinaryenExpressionGetId(expr);
}

export function getExpressionType(expr: ExpressionRef): TypeRef {
  return binaryen._BinaryenExpressionGetType(expr);
}

export function getConstValueI32(expr: ExpressionRef): i32 {
  return binaryen._BinaryenConstGetValueI32(expr);
}

export function getConstValueI64Low(expr: ExpressionRef): i32 {
  return binaryen._BinaryenConstGetValueI64Low(expr);
}

export function getConstValueI64High(expr: ExpressionRef): i32 {
  return binaryen._BinaryenConstGetValueI64High(expr);
}

export function getConstValueF32(expr: ExpressionRef): f32 {
  return binaryen._BinaryenConstGetValueF32(expr);
}

export function getConstValueF64(expr: ExpressionRef): f64 {
  return binaryen._BinaryenConstGetValueF64(expr);
}

export function isConstZero(expr: ExpressionRef): bool {
  if (getExpressionId(expr) != ExpressionId.Const) return false;
  var type = getExpressionType(expr);
  if (type == TypeRef.I32) return getConstValueI32(expr) == 0;
  if (type == TypeRef.I64) return getConstValueI64Low(expr) == 0 && getConstValueI64High(expr) == 0;
  if (type == TypeRef.F32) return getConstValueF32(expr) == 0;
  if (type == TypeRef.F64) return getConstValueF64(expr) == 0;
  return false;
}

export function getLocalGetIndex(expr: ExpressionRef): Index {
  return binaryen._BinaryenLocalGetGetIndex(expr);
}

export function getLocalSetIndex(expr: ExpressionRef): Index {
  return binaryen._BinaryenLocalSetGetIndex(expr);
}

export function getLocalSetValue(expr: ExpressionRef): ExpressionRef {
  return binaryen._BinaryenLocalSetGetValue(expr);
}

export function isLocalTee(expr: ExpressionRef): bool {
  return binaryen._BinaryenLocalSetIsTee(expr);
}

export function getGlobalGetName(expr: ExpressionRef): string | null {
  return readString(binaryen._BinaryenGlobalGetGetName(expr));
}

export function getBinaryOp(expr: ExpressionRef): BinaryOp {
  return binaryen._BinaryenBinaryGetOp(expr);
}

export function getBinaryLeft(expr: ExpressionRef): ExpressionRef {
  return binaryen._BinaryenBinaryGetLeft(expr);
}

export function getBinaryRight(expr: ExpressionRef): ExpressionRef {
  return binaryen._BinaryenBinaryGetRight(expr);
}

export function getUnaryOp(expr: ExpressionRef): UnaryOp {
  return binaryen._BinaryenUnaryGetOp(expr);
}

export function getUnaryValue(expr: ExpressionRef): ExpressionRef {
  return binaryen._BinaryenUnaryGetValue(expr);
}

export function getLoadBytes(expr: ExpressionRef): u32 {
  return binaryen._BinaryenLoadGetBytes(expr);
}

export function getLoadOffset(expr: ExpressionRef): u32 {
  return binaryen._BinaryenLoadGetOffset(expr);
}

export function getLoadPtr(expr: ExpressionRef): ExpressionRef {
  return binaryen._BinaryenLoadGetPtr(expr);
}

export function isLoadSigned(expr: ExpressionRef): bool {
  return binaryen._BinaryenLoadIsSigned(expr);
}

export function getStoreBytes(expr: ExpressionRef): u32 {
  return binaryen._BinaryenStoreGetBytes(expr);
}

export function getStoreOffset(expr: ExpressionRef): u32 {
  return binaryen._BinaryenStoreGetOffset(expr);
}

export function getStorePtr(expr: ExpressionRef): ExpressionRef {
  return binaryen._BinaryenStoreGetPtr(expr);
}

export function getStoreValue(expr: ExpressionRef): ExpressionRef {
  return binaryen._BinaryenStoreGetValue(expr);
}

export function getBlockName(expr: ExpressionRef): string | null {
  return readString(binaryen._BinaryenBlockGetName(expr));
}

export function getBlockChildCount(expr: ExpressionRef): Index {
  return binaryen._BinaryenBlockGetNumChildren(expr);
}

export function getBlockChildAt(expr: ExpressionRef, index: Index): ExpressionRef {
  return binaryen._BinaryenBlockGetChildAt(expr, index);
}

export function getIfCondition(expr: ExpressionRef): ExpressionRef {
  return binaryen._BinaryenIfGetCondition(expr);
}

export function getIfTrue(expr: ExpressionRef): ExpressionRef {
  return binaryen._BinaryenIfGetIfTrue(expr);
}

export function getIfFalse(expr: ExpressionRef): ExpressionRef {
  return binaryen._BinaryenIfGetIfFalse(expr);
}

export function getLoopName(expr: ExpressionRef): string | null {
  return readString(binaryen._BinaryenLoopGetName(expr));
}

export function getLoopBody(expr: ExpressionRef): ExpressionRef {
  return binaryen._BinaryenLoopGetBody(expr);
}

export function getBreakName(expr: ExpressionRef): string | null {
  return readString(binaryen._BinaryenBreakGetName(expr));
}

export function getBreakCondition(expr: ExpressionRef): ExpressionRef {
  return binaryen._BinaryenBreakGetCondition(expr);
}

export function getSelectThen(expr: ExpressionRef): ExpressionRef {
  return binaryen._BinaryenSelectGetIfTrue(expr);
}

export function getSelectElse(expr: ExpressionRef): ExpressionRef {
  return binaryen._BinaryenSelectGetIfFalse(expr);
}

export function getSelectCondition(expr: ExpressionRef): ExpressionRef {
  return binaryen._BinaryenSelectGetCondition(expr);
}

export function getDropValue(expr: ExpressionRef): ExpressionRef {
  return binaryen._BinaryenDropGetValue(expr);
}

export function getReturnValue(expr: ExpressionRef): ExpressionRef {
  return binaryen._BinaryenReturnGetValue(expr);
}

export function getCallTarget(expr: ExpressionRef): string | null {
  return readString(binaryen._BinaryenCallGetTarget(expr));
}

export function getCallOperandCount(expr: ExpressionRef): i32 {
  return binaryen._BinaryenCallGetNumOperands(expr);
}

export function getCallOperandAt(expr: ExpressionRef, index: Index): ExpressionRef {
  return binaryen._BinaryenCallGetOperandAt(expr, index);
}

export function getMemoryGrowDelta(expr: ExpressionRef): ExpressionRef {
  return binaryen._BinaryenMemoryGrowGetDelta(expr);
}

// functions

export function getFunctionBody(func: FunctionRef): ExpressionRef {
  return binaryen._BinaryenFunctionGetBody(func);
}

export function getFunctionName(func: FunctionRef): string | null {
  return readString(binaryen._BinaryenFunctionGetName(func));
}

export function getFunctionParams(func: FunctionRef): TypeRef {
  return binaryen._BinaryenFunctionGetParams(func);
}

export function getFunctionResults(func: FunctionRef): TypeRef {
  return binaryen._BinaryenFunctionGetResults(func);
}

export function getFunctionVars(func: FunctionRef): TypeRef[] {
  var count = binaryen._BinaryenFunctionGetNumVars(func);
  var types = new Array<TypeRef>(count);
  for (let i: Index = 0; i < count; ++i) {
    types[i] = binaryen._BinaryenFunctionGetVar(func, i);
  }
  return types;
}

// globals

export function getGlobalName(global: GlobalRef): string | null {
  return readString(binaryen._BinaryenGlobalGetName(global));
}

export function getGlobalType(global: GlobalRef): TypeRef {
  return binaryen._BinaryenGlobalGetType(global);
}

export function isGlobalMutable(global: GlobalRef): bool {
  return binaryen._BinaryenGlobalIsMutable(global);
}

export function getGlobalInit(global: GlobalRef): ExpressionRef {
  return binaryen._BinaryenGlobalGetInitExpr(global);
}

// tags

export function getTagName(tag: TagRef): string | null {
  return readString(binaryen._BinaryenTagGetName(tag));
}

export function getTagParams(tag: TagRef): TypeRef {
  return binaryen._BinaryenTagGetParams(tag);
}

export function getTagResults(tag: TagRef): TypeRef {
  return binaryen._BinaryenTagGetResults(tag);
}

export class Relooper {
  constructor(
    /** Module this relooper belongs to. */
    public module: Module,
    /** Binaryen relooper reference. */
    public ref: RelooperRef
  ) {}

  static create(module: Module): Relooper {
    return new Relooper(module, binaryen._RelooperCreate(module.ref));
  }

  addBlock(code: ExpressionRef): RelooperBlockRef {
    return binaryen._RelooperAddBlock(this.ref, code);
  }

  addBranch(
    from: RelooperBlockRef,
    to: RelooperBlockRef,
    condition: ExpressionRef = 0,
    code: ExpressionRef = 0
  ): void {
    binaryen._RelooperAddBranch(from, to, condition, code);
  }

  addBlockWithSwitch(code: ExpressionRef, condition: ExpressionRef): RelooperBlockRef {
    return binaryen._RelooperAddBlockWithSwitch(this.ref, code, condition);
  }

  addBranchForSwitch(
    from: RelooperBlockRef,
    to: RelooperBlockRef,
    indexes: i32[],
    code: ExpressionRef = 0
  ): void {
    var cArr = allocI32Array(indexes);
    binaryen._RelooperAddBranchForSwitch(from, to, cArr, indexes.length, code);
    binaryen._free(cArr);
  }

  renderAndDispose(entry: RelooperBlockRef, labelHelper: Index): ExpressionRef {
    return binaryen._RelooperRenderAndDispose(this.ref, entry, labelHelper);
  }
}

/** Builds a switch using a sequence of `br_if`s. */
export class SwitchBuilder {
  // This is useful because Binaryen understands sequences of `br_if`s and
  // knows how to make a `br_table` from such a sequence if switched over
  // values are considered dense enough, respectively a size-efficient sequence
  // of `if`s if not, depending on optimization levels.

  private module: Module;
  private condition: ExpressionRef;
  private values: i32[] = new Array();
  private indexes: i32[] = new Array();
  private cases: ExpressionRef[][] = new Array();
  private defaultIndex: i32 = -1;

  /** Creates a new builder using the specified i32 condition. */
  constructor(module: Module, condition: ExpressionRef) {
    this.module = module;
    this.condition = condition;
  }

  /** Links a case to the specified branch. */
  addCase(value: i32, code: ExpressionRef[]): void {
    var cases = this.cases;
    var index = cases.indexOf(code);
    if (index < 0) {
      index = cases.length;
      cases.push(code);
    }
    this.values.push(value);
    this.indexes.push(index);
  }

  /** Links the default branch. */
  addDefault(code: ExpressionRef[]): void {
    assert(this.defaultIndex == -1);
    var cases = this.cases;
    this.defaultIndex = cases.length;
    cases.push(code);
  }

  /** Renders the switch to a block. */
  render(localIndex: i32, labelPostfix: string = ""): ExpressionRef {
    var module = this.module;
    var cases = this.cases;
    var numCases = cases.length;
    if (!numCases) {
      return module.drop(this.condition);
    }
    var values = this.values;
    var numValues = values.length;
    var indexes = this.indexes;
    var entry = new Array<ExpressionRef>(1 + numValues + 1);
    var labels = new Array<string>(numCases);
    for (let i = 0; i < numCases; ++i) {
      labels[i] = "case" + i.toString() + labelPostfix;
    }
    entry[0] = module.local_set(localIndex, this.condition, false); // u32
    for (let i = 0; i < numValues; ++i) {
      let index = indexes[i];
      entry[1 + i] = module.br(labels[index],
        module.binary(BinaryOp.EqI32,
          module.local_get(localIndex, TypeRef.I32),
          module.i32(values[i])
        )
      );
    }
    var defaultIndex = this.defaultIndex;
    var defaultLabel = "default" + labelPostfix;
    entry[1 + numValues] = module.br(
      ~defaultIndex
        ? labels[defaultIndex]
        : defaultLabel
    );
    var current = module.block(labels[0], entry);
    for (let i = 1; i < numCases; ++i) {
      let block = cases[i - 1];
      block.unshift(current);
      current = module.block(labels[i], block);
    }
    var lastCase = cases[numCases - 1];
    lastCase.unshift(current);
    return module.block(
      ~defaultIndex
        ? null
        : defaultLabel,
      lastCase
    );
  }
}

export enum SideEffects {
  None = 0 /* _BinaryenSideEffectNone */,
  Branches = 1 /* _BinaryenSideEffectBranches */,
  Calls = 2 /* _BinaryenSideEffectCalls */,
  ReadsLocal = 4 /* _BinaryenSideEffectReadsLocal */,
  WritesLocal = 8 /* _BinaryenSideEffectWritesLocal */,
  ReadsGlobal = 16 /* _BinaryenSideEffectReadsGlobal */,
  WritesGlobal = 32 /* _BinaryenSideEffectWritesGlobal */,
  ReadsMemory = 64 /* _BinaryenSideEffectReadsMemory */,
  WritesMemory = 128 /* _BinaryenSideEffectWritesMemory */,
  ImplicitTrap = 256 /* _BinaryenSideEffectImplicitTrap */,
  IsAtomic = 512 /* _BinaryenSideEffectIsAtomic */,
  Throws = 1024 /* _BinaryenSideEffectThrows */,
  DanglingPop = 2048 /* _BinaryenSideEffectDanglingPop */,
  Any = 4095 /* _BinaryenSideEffectAny */
}

export function getSideEffects(expr: ExpressionRef, features: FeatureFlags = FeatureFlags.All): SideEffects {
  return binaryen._BinaryenExpressionGetSideEffects(expr, features);
}

export function hasSideEffects(expr: ExpressionRef, features: FeatureFlags = FeatureFlags.All): bool {
  return getSideEffects(expr, features) != SideEffects.None;
}

// helpers
// can't do stack allocation here: STACKTOP is a global in WASM but a hidden variable in asm.js

function allocU8Array(u8s: Uint8Array | null): usize {
  if (!u8s) return 0;
  var len = u8s.length;
  var ptr = binaryen._malloc(len);
  for (let i = 0; i < len; ++i) {
    binaryen.__i32_store8(ptr + i, u8s[i]);
  }
  return ptr;
}

function allocI32Array(i32s: i32[] | null): usize {
  if (!i32s) return 0;
  var len = i32s.length;
  var ptr = binaryen._malloc(len << 2);
  var idx = ptr;
  for (let i = 0; i < len; ++i) {
    let val = i32s[i];
    binaryen.__i32_store(idx, val);
    idx += 4;
  }
  return ptr;
}

function allocU32Array(u32s: u32[] | null): usize {
  if (!u32s) return 0;
  var len = u32s.length;
  var ptr = binaryen._malloc(len << 2);
  var idx = ptr;
  for (let i = 0; i < len; ++i) {
    let val = u32s[i];
    binaryen.__i32_store(idx, val);
    idx += 4;
  }
  return ptr;
}

export function allocPtrArray(ptrs: usize[] | null): usize {
  if (!ptrs) return 0;
  // TODO: WASM64
  assert(ASC_TARGET != Target.WASM64);
  var len = ptrs.length;
  var ptr = binaryen._malloc(len << 2);
  var idx = ptr;
  for (let i = 0, k = len; i < k; ++i) {
    let val = ptrs[i];
    binaryen.__i32_store(idx, <i32>val);
    idx += 4;
  }
  return ptr;
}

function stringLengthUTF8(str: string): usize {
  var len = 0;
  for (let i = 0, k = str.length; i < k; ++i) {
    let u = str.charCodeAt(i);
    if (u >= 0xD800 && u <= 0xDFFF && i + 1 < k) {
      u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    }
    if (u <= 0x7F) {
      len += 1;
    } else if (u <= 0x7FF) {
      len += 2;
    } else if (u <= 0xFFFF) {
      len += 3;
    } else {
      len += 4;
    }
  }
  return len;
}

function allocString(str: string | null): usize {
  if (str === null) return 0;
  var ptr = binaryen._malloc(stringLengthUTF8(str) + 1) >>> 0;
  // the following is based on Emscripten's stringToUTF8Array
  var idx = ptr;
  for (let i = 0, k = str.length; i < k; ++i) {
    let u = str.charCodeAt(i);
    if (u >= 0xD800 && u <= 0xDFFF && i + 1 < k) {
      u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    }
    if (u <= 0x7F) {
      binaryen.__i32_store8(idx++, u as u8);
    } else if (u <= 0x7FF) {
      binaryen.__i32_store8(idx++, (0xC0 |  (u >>> 6)       ) as u8);
      binaryen.__i32_store8(idx++, (0x80 | ( u         & 63)) as u8);
    } else if (u <= 0xFFFF) {
      binaryen.__i32_store8(idx++, (0xE0 |  (u >>> 12)      ) as u8);
      binaryen.__i32_store8(idx++, (0x80 | ((u >>>  6) & 63)) as u8);
      binaryen.__i32_store8(idx++, (0x80 | ( u         & 63)) as u8);
    } else {
      assert(u < 0x200000, "Invalid Unicode code point during allocString");
      binaryen.__i32_store8(idx++, (0xF0 |  (u >>> 18)      ) as u8);
      binaryen.__i32_store8(idx++, (0x80 | ((u >>> 12) & 63)) as u8);
      binaryen.__i32_store8(idx++, (0x80 | ((u >>>  6) & 63)) as u8);
      binaryen.__i32_store8(idx++, (0x80 | ( u         & 63)) as u8);
    }
  }
  binaryen.__i32_store8(idx, 0);
  return ptr;
}

function readBuffer(ptr: usize, len: i32): Uint8Array {
  var ret = new Uint8Array(len);
  for (let i = 0; i < len; ++i) {
    ret[i] = binaryen.__i32_load8_u(ptr + <usize>i);
  }
  return ret;
}

export function readString(ptr: usize): string | null {
  if (!ptr) return null;
  var arr = new Array<i32>();
  // the following is based on Emscripten's UTF8ArrayToString
  var cp: u32;
  var u1: u32, u2: u32, u3: u32;
  while (cp = binaryen.__i32_load8_u(ptr++)) {
    if (!(cp & 0x80)) {
      arr.push(cp);
      continue;
    }
    u1 = binaryen.__i32_load8_u(ptr++) & 63;
    if ((cp & 0xE0) == 0xC0) {
      arr.push(((cp & 31) << 6) | u1);
      continue;
    }
    u2 = binaryen.__i32_load8_u(ptr++) & 63;
    if ((cp & 0xF0) == 0xE0) {
      cp = ((cp & 15) << 12) | (u1 << 6) | u2;
    } else {
      u3 = binaryen.__i32_load8_u(ptr++) & 63;
      if ((cp & 0xF8) == 0xF0) {
        cp = ((cp & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;
      } else {
        assert(false, "Invalid UTF8 sequence during readString");
      }
    }
    if (cp < 0x10000) {
      arr.push(cp);
    } else {
      let ch = cp - 0x10000;
      arr.push(0xD800 | (ch >>> 10));
      arr.push(0xDC00 | (ch & 0x3FF));
    }
  }
  return String.fromCharCodes(arr);
}

/** Result structure of {@link Module#toBinary}. */
export class BinaryModule {
  constructor(
    /** WebAssembly binary. */
    public output: Uint8Array,
    /** Source map, if generated. */
    public sourceMap: string | null
  ) {}
}

/** Tests if an expression needs an explicit 'unreachable' when it is the terminating statement. */
export function needsExplicitUnreachable(expr: ExpressionRef): bool {
  // not applicable if pushing a value to the stack
  if (binaryen._BinaryenExpressionGetType(expr) != TypeRef.Unreachable) {
    return false;
  }

  switch (binaryen._BinaryenExpressionGetId(expr)) {
    case ExpressionId.Unreachable:
    case ExpressionId.Return: return false;
    case ExpressionId.Break: {
      return binaryen._BinaryenBreakGetCondition(expr) != 0;
    }
    case ExpressionId.Block: {
      if (!binaryen._BinaryenBlockGetName(expr)) { // can't break out of it
        let numChildren = binaryen._BinaryenBlockGetNumChildren(expr); // last child needs unreachable
        return (
          numChildren > 0 &&
          needsExplicitUnreachable(binaryen._BinaryenBlockGetChildAt(expr, numChildren - 1))
        );
      }
    }
  }
  return true;
}

'''
'''--- src/parser.ts ---
/**
 * @fileoverview A TypeScript parser for the AssemblyScript subset.
 *
 * Takes the tokens produced by the `Tokenizer` and builds an abstract
 * syntax tree composed of `Node`s wrapped in a `Source` out of it.
 *
 * @license Apache-2.0
 */

import {
  CommonFlags,
  LIBRARY_PREFIX,
  PATH_DELIMITER
} from "./common";

import {
  Tokenizer,
  Token,
  Range,
  CommentHandler,
  IdentifierHandling,
  isIllegalVariableIdentifier
} from "./tokenizer";

import {
  DiagnosticCode,
  DiagnosticEmitter,
  DiagnosticMessage
} from "./diagnostics";

import {
  CharCode,
  normalizePath
} from "./util";

import {
  Node,
  NodeKind,
  Source,
  SourceKind,
  TypeNode,
  TypeName,
  NamedTypeNode,
  FunctionTypeNode,
  ArrowKind,

  Expression,
  AssertionKind,
  CallExpression,
  ClassExpression,
  FunctionExpression,
  IdentifierExpression,
  StringLiteralExpression,

  Statement,
  BlockStatement,
  BreakStatement,
  ClassDeclaration,
  ContinueStatement,
  DeclarationStatement,
  DecoratorNode,
  DoStatement,
  EnumDeclaration,
  EnumValueDeclaration,
  ExportImportStatement,
  ExportMember,
  ExportStatement,
  ExpressionStatement,
  ForOfStatement,
  FunctionDeclaration,
  IfStatement,
  ImportDeclaration,
  ImportStatement,
  IndexSignatureNode,
  NamespaceDeclaration,
  ParameterNode,
  ParameterKind,
  ReturnStatement,
  SwitchCase,
  SwitchStatement,
  ThrowStatement,
  TryStatement,
  TypeDeclaration,
  TypeParameterNode,
  VariableStatement,
  VariableDeclaration,
  VoidStatement,
  WhileStatement,

  mangleInternalPath
} from "./ast";

/** Represents a dependee. */
class Dependee {
  constructor(
    public source: Source,
    public reportNode: Node
  ) {}
}

/** Parser interface. */
export class Parser extends DiagnosticEmitter {

  /** Source file names to be requested next. */
  backlog: string[] = new Array();
  /** Source file names already seen, that is processed or backlogged. */
  seenlog: Set<string> = new Set();
  /** Source file names already completely processed. */
  donelog: Set<string> = new Set();
  /** Optional handler to intercept comments while tokenizing. */
  onComment: CommentHandler | null = null;
  /** Current file being parsed. */
  currentSource: Source | null = null;
  /** Map of dependees being depended upon by a source, by path. */
  dependees: Map<string, Dependee> = new Map();
  /** An array of parsed sources. */
  sources: Source[];

  /** Constructs a new parser. */
  constructor(
    diagnostics: DiagnosticMessage[] | null = null,
    sources: Source[] | null = null
  ) {
    super(diagnostics);
    this.sources = sources ? sources : new Array<Source>();
  }

  /** Parses a file and adds its definitions to the program. */
  parseFile(
    /** Source text of the file, or `null` to indicate not found. */
    text: string | null,
    /** Normalized path of the file. */
    path: string,
    /** Whether this is an entry file. */
    isEntry: bool
  ): void {
    // the frontend gives us paths with file extensions
    var normalizedPath = normalizePath(path);
    var internalPath = mangleInternalPath(normalizedPath);

    // check if already processed
    if (this.donelog.has(internalPath)) return;
    this.donelog.add(internalPath); // do not parse again
    this.seenlog.add(internalPath); // do not request again

    // check if this is an error
    if (text === null) {
      let dependees = this.dependees;
      let dependee: Dependee | null = null;
      if (dependees.has(internalPath)) dependee = assert(dependees.get(internalPath));
      this.error(
        DiagnosticCode.File_0_not_found,
        dependee
          ? dependee.reportNode.range
          : null,
        path
      );
      return;
    }

    // create the source element
    var source = new Source(
      isEntry
        ? SourceKind.USER_ENTRY
        : path.startsWith(LIBRARY_PREFIX)
          ? path.indexOf(PATH_DELIMITER, LIBRARY_PREFIX.length) < 0
            ? SourceKind.LIBRARY_ENTRY
            : SourceKind.LIBRARY
          : SourceKind.USER,
      normalizedPath,
      text
    );

    this.sources.push(source);
    this.currentSource = source;

    // tokenize and parse
    var tn = new Tokenizer(source, this.diagnostics);
    tn.onComment = this.onComment;
    var statements = source.statements;
    while (!tn.skip(Token.ENDOFFILE)) {
      let statement = this.parseTopLevelStatement(tn, null);
      if (statement) {
        statements.push(statement);
      } else {
        this.skipStatement(tn);
      }
    }
  }

  /** Parses a top-level statement. */
  parseTopLevelStatement(
    tn: Tokenizer,
    namespace: NamespaceDeclaration | null = null
  ): Statement | null {
    var flags = CommonFlags.NONE;
    var startPos = -1;

    // check decorators
    var decorators: DecoratorNode[] | null = null;
    while (tn.skip(Token.AT)) {
      if (startPos < 0) startPos = tn.tokenPos;
      let decorator = this.parseDecorator(tn);
      if (!decorator) {
        this.skipStatement(tn);
        continue;
      }
      if (!decorators) decorators = [decorator];
      else decorators.push(decorator);
    }

    // check modifiers
    var exportStart = 0;
    var exportEnd = 0;
    var defaultStart = 0;
    var defaultEnd = 0;
    if (tn.skip(Token.EXPORT)) {
      if (startPos < 0) startPos = tn.tokenPos;
      flags |= CommonFlags.EXPORT;
      exportStart = tn.tokenPos;
      exportEnd = tn.pos;
      if (tn.skip(Token.DEFAULT)) {
        defaultStart = tn.tokenPos;
        defaultEnd = tn.pos;
      }
    }

    var declareStart = 0;
    var declareEnd = 0;
    var contextIsAmbient = namespace != null && namespace.is(CommonFlags.AMBIENT);
    if (tn.skip(Token.DECLARE)) {
      if (contextIsAmbient) {
        this.error(
          DiagnosticCode.A_declare_modifier_cannot_be_used_in_an_already_ambient_context,
          tn.range()
        ); // recoverable
      } else {
        if (startPos < 0) startPos = tn.tokenPos;
        declareStart = startPos;
        declareEnd = tn.pos;
        flags |= CommonFlags.DECLARE | CommonFlags.AMBIENT;
      }
    } else if (contextIsAmbient) {
      flags |= CommonFlags.AMBIENT;
    }

    // parse the statement
    var statement: Statement | null = null;

    // handle declarations
    var first = tn.peek();
    if (startPos < 0) startPos = tn.nextTokenPos;
    switch (first) {
      case Token.CONST: {
        tn.next();
        flags |= CommonFlags.CONST;
        if (tn.skip(Token.ENUM)) {
          statement = this.parseEnum(tn, flags, decorators, startPos);
        } else {
          statement = this.parseVariable(tn, flags, decorators, startPos);
        }
        decorators = null;
        break;
      }
      case Token.LET: flags |= CommonFlags.LET;
      case Token.VAR: {
        tn.next();
        statement = this.parseVariable(tn, flags, decorators, startPos);
        decorators = null;
        break;
      }
      case Token.ENUM: {
        tn.next();
        statement = this.parseEnum(tn, flags, decorators, startPos);
        decorators = null;
        break;
      }
      case Token.FUNCTION: {
        tn.next();
        statement = this.parseFunction(tn, flags, decorators, startPos);
        decorators = null;
        break;
      }
      case Token.ABSTRACT: {
        let state = tn.mark();
        tn.next();
        let abstractStart = tn.tokenPos;
        let abstractEnd = tn.pos;
        let next = tn.peek(true);
        if (tn.nextTokenOnNewLine) {
          tn.reset(state);
          statement = this.parseStatement(tn, true);
          break;
        }
        if (next != Token.CLASS) {
          if (next == Token.INTERFACE) {
            this.error(
              DiagnosticCode._abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration,
              tn.range(abstractStart, abstractEnd)
            );
          }
          tn.reset(state);
          statement = this.parseStatement(tn, true);
          break;
        } else {
          tn.discard(state);
        }
        flags |= CommonFlags.ABSTRACT;
        // fall through
      }
      case Token.CLASS:
      case Token.INTERFACE: {
        tn.next();
        statement = this.parseClassOrInterface(tn, flags, decorators, startPos);
        decorators = null;
        break;
      }
      case Token.NAMESPACE: {
        let state = tn.mark();
        tn.next();
        if (tn.peek(false, IdentifierHandling.PREFER) == Token.IDENTIFIER) {
          tn.discard(state);
          statement = this.parseNamespace(tn, flags, decorators, startPos);
          decorators = null;
        } else {
          tn.reset(state);
          statement = this.parseStatement(tn, true);
        }
        break;
      }
      case Token.IMPORT: {
        tn.next();
        flags |= CommonFlags.IMPORT;
        if (flags & CommonFlags.EXPORT) {
          statement = this.parseExportImport(tn, startPos);
        } else {
          statement = this.parseImport(tn);
        }
        break;
      }
      case Token.TYPE: { // also identifier
        let state = tn.mark();
        tn.next();
        if (tn.peek(false, IdentifierHandling.PREFER) == Token.IDENTIFIER) {
          tn.discard(state);
          statement = this.parseTypeDeclaration(tn, flags, decorators, startPos);
          decorators = null;
        } else {
          tn.reset(state);
          statement = this.parseStatement(tn, true);
        }
        break;
      }
      default: {

        // handle plain exports
        if (flags & CommonFlags.EXPORT) {
          if (defaultEnd && tn.skipIdentifier(IdentifierHandling.PREFER)) {
            if (declareEnd) {
              this.error(
                DiagnosticCode.An_export_assignment_cannot_have_modifiers,
                tn.range(declareStart, declareEnd)
              );
            }
            statement = this.parseExportDefaultAlias(tn, startPos, defaultStart, defaultEnd);
            defaultStart = defaultEnd = 0; // consume
          } else {
            statement = this.parseExport(tn, startPos, (flags & CommonFlags.DECLARE) != 0);
          }

        // handle non-declaration statements
        } else {
          if (exportEnd) {
            this.error(
              DiagnosticCode._0_modifier_cannot_be_used_here,
              tn.range(exportStart, exportEnd), "export"
            ); // recoverable
          }
          if (declareEnd) {
            this.error(
              DiagnosticCode._0_modifier_cannot_be_used_here,
              tn.range(declareStart, declareEnd), "declare"
            ); // recoverable
          }
          if (!namespace) {
            statement = this.parseStatement(tn, true);
          } // TODO: else?
        }
        break;
      }
    }

    // check for decorators that weren't consumed
    if (decorators) {
      for (let i = 0, k = decorators.length; i < k; ++i) {
        this.error(
          DiagnosticCode.Decorators_are_not_valid_here,
          decorators[i].range
        );
      }
    }

    // check if this an `export default` declaration
    if (defaultEnd && statement !== null) {
      switch (statement.kind) {
        case NodeKind.ENUMDECLARATION:
        case NodeKind.FUNCTIONDECLARATION:
        case NodeKind.CLASSDECLARATION:
        case NodeKind.INTERFACEDECLARATION:
        case NodeKind.NAMESPACEDECLARATION: {
          return Node.createExportDefaultStatement(<DeclarationStatement>statement, tn.range(startPos, tn.pos));
        }
        default: {
          this.error(
            DiagnosticCode._0_modifier_cannot_be_used_here,
            tn.range(defaultStart, defaultEnd), "default"
          );
        }
      }
    }
    return statement;
  }

  /** Obtains the next file to parse. */
  nextFile(): string | null {
    var backlog = this.backlog;
    return backlog.length ? assert(backlog.shift()) : null;
  }

  /** Obtains the path of the dependee of the given imported file. */
  getDependee(dependent: string): string | null {
    var dependees = this.dependees;
    if (dependees.has(dependent)) {
      let dependee = assert(dependees.get(dependent));
      return dependee.source.internalPath;
    }
    return null;
  }

  /** Finishes parsing. */
  finish(): void {
    if (this.backlog.length) throw new Error("backlog is not empty");
    this.backlog = [];
    this.seenlog.clear();
    this.donelog.clear();
    this.dependees.clear();
  }

  // types

  /** Parses a type name. */
  parseTypeName(
    tn: Tokenizer
  ): TypeName | null {

    // at: Identifier ('.' Identifier)*

    var first = Node.createSimpleTypeName(tn.readIdentifier(), tn.range());
    var current = first;
    while (tn.skip(Token.DOT)) {
      if (tn.skip(Token.IDENTIFIER)) {
        let next = Node.createSimpleTypeName(tn.readIdentifier(), tn.range());
        current.next = next;
        current = next;
      } else {
        this.error(
          DiagnosticCode.Identifier_expected,
          tn.range(tn.pos)
        );
        return null;
      }
    }
    return first;
  }

  /** Parses a type. */
  parseType(
    tn: Tokenizer,
    acceptParenthesized: bool = true,
    suppressErrors: bool = false
  ): TypeNode | null {

    // before: Type

    // NOTE: this parses our limited subset
    var token = tn.next();
    var startPos = tn.tokenPos;

    var type: TypeNode;

    // '(' ...
    if (token == Token.OPENPAREN) {

      // '(' FunctionSignature ')' '|' 'null'?
      let isNullableSignature = tn.skip(Token.OPENPAREN);
      // FunctionSignature?
      let signature = this.tryParseFunctionType(tn);
      if (signature) {
        if (isNullableSignature) {
          if (!tn.skip(Token.CLOSEPAREN)) {
            this.error(
              DiagnosticCode._0_expected,
              tn.range(), ")"
            );
            return null;
          }
          if (!tn.skip(Token.BAR)) {
            this.error(
              DiagnosticCode._0_expected,
              tn.range(), "|"
            );
            return null;
          }
          if (!tn.skip(Token.NULL)) {
            this.error(
              DiagnosticCode._0_expected,
              tn.range(), "null"
            );
          }
          signature.isNullable = true;
        }
        return signature;
      } else if (isNullableSignature || this.tryParseSignatureIsSignature) {
        this.error(
          DiagnosticCode.Unexpected_token,
          tn.range()
        );
        return null;
      }

      // Type (',' Type)* ')'
      if (acceptParenthesized) {
        let innerType = this.parseType(tn, false, suppressErrors);
        if (!innerType) return null;
        if (!tn.skip(Token.CLOSEPAREN)) {
          if (!suppressErrors) {
            this.error(
              DiagnosticCode._0_expected,
              tn.range(tn.pos), ")"
            );
          }
          return null;
        }
        type = innerType;
        type.range.start = startPos;
        type.range.end = tn.pos;
      } else {
        this.error(
          DiagnosticCode.Unexpected_token,
          tn.range()
        );
        return null;
      }

    // 'void'
    } else if (token == Token.VOID) {
      type = Node.createNamedType(
        Node.createSimpleTypeName("void", tn.range()), [], false, tn.range(startPos, tn.pos)
      );

    // 'this'
    } else if (token == Token.THIS) {
      type = Node.createNamedType(
        Node.createSimpleTypeName("this", tn.range()), [], false, tn.range(startPos, tn.pos)
      );

    // 'true'
    } else if (token == Token.TRUE || token == Token.FALSE) {
      type = Node.createNamedType(
        Node.createSimpleTypeName("bool", tn.range()), [], false, tn.range(startPos, tn.pos)
      );

    // 'null'
    } else if (token == Token.NULL) {
      type = Node.createNamedType(
        Node.createSimpleTypeName("null", tn.range()), [], false, tn.range(startPos, tn.pos)
      );

    // StringLiteral
    } else if (token == Token.STRINGLITERAL) {
      tn.readString();
      type = Node.createNamedType(
        Node.createSimpleTypeName("string", tn.range()), [], false, tn.range(startPos, tn.pos)
      );

    // Identifier
    } else if (token == Token.IDENTIFIER) {
      let name = this.parseTypeName(tn);
      if (!name) return null;
      let parameters: TypeNode[] | null = null;

      // Name<T>
      if (tn.skip(Token.LESSTHAN)) {
        do {
          let parameter = this.parseType(tn, true, suppressErrors);
          if (!parameter) return null;
          if (!parameters) parameters = [ parameter ];
          else parameters.push(parameter);
        } while (tn.skip(Token.COMMA));
        if (!tn.skip(Token.GREATERTHAN)) {
          if (!suppressErrors) {
            this.error(
              DiagnosticCode._0_expected,
              tn.range(tn.pos), ">"
            );
          }
          return null;
        }
      }
      if (!parameters) parameters = [];
      type = Node.createNamedType(name, parameters, false, tn.range(startPos, tn.pos));
    } else {
      if (!suppressErrors) {
        this.error(
          DiagnosticCode.Type_expected,
          tn.range()
        );
      }
      return null;
    }
    // ... | null
    while (tn.skip(Token.BAR)) {
      if (tn.skip(Token.NULL)) {
        type.isNullable = true;
      } else {
        let notNullStart = tn.pos;
        let notNull = this.parseType(tn, false, true);
        if (!suppressErrors) {
          this.error(
            DiagnosticCode._0_expected,
            notNull ? notNull.range : tn.range(notNullStart), "null"
          );
        }
        return null;
      }
    }
    // ... [][]
    while (tn.skip(Token.OPENBRACKET)) {
      let bracketStart = tn.tokenPos;
      if (!tn.skip(Token.CLOSEBRACKET)) {
        if (!suppressErrors) {
          this.error(
            DiagnosticCode._0_expected,
            tn.range(), "]"
          );
        }
        return null;
      }
      let bracketRange = tn.range(bracketStart, tn.pos);

      // ...[] | null
      let nullable = false;
      if (tn.skip(Token.BAR)) {
        if (tn.skip(Token.NULL)) {
          nullable = true;
        } else {
          if (!suppressErrors) {
            this.error(
              DiagnosticCode._0_expected,
              tn.range(), "null"
            );
          }
          return null;
        }
      }
      type = Node.createNamedType(
        Node.createSimpleTypeName("Array", bracketRange),
        [ type ],
        nullable,
        tn.range(startPos, tn.pos)
      );
      if (nullable) break;
    }

    return type;
  }

  // Indicates whether tryParseSignature determined that it is handling a Signature
  private tryParseSignatureIsSignature: bool = false;

  /** Parses a function type, as used in type declarations. */
  tryParseFunctionType(
    tn: Tokenizer
  ): FunctionTypeNode | null {

    // at '(': ('...'? Identifier '?'? ':' Type (','  '...'? Identifier '?'? ':' Type)* )? ')' '=>' Type

    var state = tn.mark();
    var startPos = tn.tokenPos;
    var parameters: ParameterNode[] | null = null;
    var thisType: NamedTypeNode | null = null;
    var isSignature: bool = false;
    var firstParamNameNoType: IdentifierExpression | null = null;
    var firstParamKind: ParameterKind = ParameterKind.DEFAULT;

    if (tn.skip(Token.CLOSEPAREN)) {
      isSignature = true;
      tn.discard(state);
      parameters = [];

    } else {
      isSignature = false; // not yet known
      do {
        let paramStart = -1;
        let kind = ParameterKind.DEFAULT;
        if (tn.skip(Token.DOT_DOT_DOT)) {
          paramStart = tn.tokenPos;
          isSignature = true;
          tn.discard(state);
          kind = ParameterKind.REST;
        }
        if (tn.skip(Token.THIS)) {
          if (paramStart < 0) paramStart = tn.tokenPos;
          if (tn.skip(Token.COLON)) {
            isSignature = true;
            tn.discard(state);
            let type = this.parseType(tn, false);
            if (!type) return null;
            if (type.kind != NodeKind.NAMEDTYPE) {
              this.error(
                DiagnosticCode.Identifier_expected,
                type.range
              );
              this.tryParseSignatureIsSignature = true;
              return null;
            }
            thisType = <NamedTypeNode>type;
          } else {
            tn.reset(state);
            this.tryParseSignatureIsSignature = false;
            return null;
          }
        } else if (tn.skipIdentifier()) {
          if (paramStart < 0) paramStart = tn.tokenPos;
          let name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range(tn.tokenPos, tn.pos));
          if (tn.skip(Token.QUESTION)) {
            isSignature = true;
            tn.discard(state);
            if (kind == ParameterKind.REST) {
              this.error(
                DiagnosticCode.A_rest_parameter_cannot_be_optional,
                tn.range()
              ); // recoverable
            } else {
              kind = ParameterKind.OPTIONAL;
            }
          }
          if (tn.skip(Token.COLON)) {
            isSignature = true;
            tn.discard(state);
            let type = this.parseType(tn); // not suppressing errors because known
            if (!type) {
              this.tryParseSignatureIsSignature = isSignature;
              return null;
            }
            let param = Node.createParameter(kind, name, type, null, tn.range(paramStart, tn.pos));
            if (!parameters) parameters = [ param ];
            else parameters.push(param);
          } else {
            if (!isSignature) {
              if (tn.peek() == Token.COMMA) {
                isSignature = true;
                tn.discard(state);
              }
            }
            if (isSignature) {
              let param = Node.createParameter(kind, name, Node.createOmittedType(tn.range(tn.pos)), null, tn.range(paramStart, tn.pos));
              if (!parameters) parameters = [ param ];
              else parameters.push(param);
              this.error(
                DiagnosticCode.Type_expected,
                param.type.range
              ); // recoverable
            } else if (!parameters) {
              // on '(' Identifier ^',' we don't yet know whether this is a
              // parenthesized or a function type, hence we have to delay the
              // respective diagnostic until we know for sure.
              firstParamNameNoType = name;
              firstParamKind = kind;
            }
          }
        } else {
          if (isSignature) {
            this.error(
              DiagnosticCode.Identifier_expected,
              tn.range()
            );
          } else {
            tn.reset(state);
          }
          this.tryParseSignatureIsSignature = isSignature;
          return null;
        }
      } while (tn.skip(Token.COMMA));
      if (!tn.skip(Token.CLOSEPAREN)) {
        if (isSignature) {
          this.error(
            DiagnosticCode._0_expected,
            tn.range(), ")"
          );
        } else {
          tn.reset(state);
        }
        this.tryParseSignatureIsSignature = isSignature;
        return null;
      }
    }

    var returnType: TypeNode | null;
    if (tn.skip(Token.EQUALS_GREATERTHAN)) {
      if (!isSignature) {
        isSignature = true;
        tn.discard(state);
        if (firstParamNameNoType) { // now we know
          let param = Node.createParameter(
            firstParamKind,
            firstParamNameNoType,
            Node.createOmittedType(firstParamNameNoType.range.atEnd),
            null,
            firstParamNameNoType.range
          );
          if (!parameters) parameters = [ param ];
          else parameters.push(param);
          this.error(
            DiagnosticCode.Type_expected,
            param.type.range
          ); // recoverable
        }
      }
      returnType = this.parseType(tn);
      if (!returnType) {
        this.tryParseSignatureIsSignature = isSignature;
        return null;
      }
    } else {
      if (isSignature) {
        this.error(
          DiagnosticCode._0_expected,
          tn.range(), "=>"
        );
      } else {
        tn.reset(state);
      }
      this.tryParseSignatureIsSignature = isSignature;
      return null;
    }
    this.tryParseSignatureIsSignature = true;

    if (!parameters) parameters = [];

    return Node.createFunctionType(
      parameters,
      returnType,
      thisType,
      false,
      tn.range(startPos, tn.pos)
    );
  }

  // statements

  parseDecorator(
    tn: Tokenizer
  ): DecoratorNode | null {

    // at '@': Identifier ('.' Identifier)* '(' Arguments

    var startPos = tn.tokenPos;
    if (tn.skipIdentifier()) {
      let name = tn.readIdentifier();
      let expression: Expression = Node.createIdentifierExpression(name, tn.range(startPos, tn.pos));
      while (tn.skip(Token.DOT)) {
        if (tn.skipIdentifier(IdentifierHandling.PREFER)) {
          name = tn.readIdentifier();
          expression = Node.createPropertyAccessExpression(
            expression,
            Node.createIdentifierExpression(name, tn.range()),
            tn.range(startPos, tn.pos)
          );
        } else {
          this.error(
            DiagnosticCode.Identifier_expected,
            tn.range()
          );
          return null;
        }
      }
      let args: Expression[] | null;
      if (tn.skip(Token.OPENPAREN)) {
        args = this.parseArguments(tn);
        if (args) {
          return Node.createDecorator(expression, args, tn.range(startPos, tn.pos));
        }
      } else {
        return Node.createDecorator(expression, null, tn.range(startPos, tn.pos));
      }
    } else {
      this.error(
        DiagnosticCode.Identifier_expected,
        tn.range()
      );
    }
    return null;
  }

  parseVariable(
    tn: Tokenizer,
    flags: CommonFlags,
    decorators: DecoratorNode[] | null,
    startPos: i32,
    isFor: bool = false
  ): VariableStatement | null {

    // at ('const' | 'let' | 'var'): VariableDeclaration (',' VariableDeclaration)* ';'?

    var declarations = new Array<VariableDeclaration>();
    do {
      let declaration = this.parseVariableDeclaration(tn, flags, decorators, isFor);
      if (!declaration) return null;
      declarations.push(declaration);
    } while (tn.skip(Token.COMMA));

    var ret = Node.createVariableStatement(decorators, declarations, tn.range(startPos, tn.pos));
    tn.skip(Token.SEMICOLON);
    return ret;
  }

  parseVariableDeclaration(
    tn: Tokenizer,
    parentFlags: CommonFlags,
    parentDecorators: DecoratorNode[] | null,
    isFor: bool = false
  ): VariableDeclaration | null {

    // before: Identifier (':' Type)? ('=' Expression)?

    if (!tn.skipIdentifier()) {
      this.error(
        DiagnosticCode.Identifier_expected,
        tn.range()
      );
      return null;
    }
    var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
    if (isIllegalVariableIdentifier(identifier.text)) {
      this.error(
        DiagnosticCode.Identifier_expected,
        identifier.range
      );
    }
    var flags = parentFlags;
    if (tn.skip(Token.EXCLAMATION)) {
      flags |= CommonFlags.DEFINITELY_ASSIGNED;
    }

    var type: TypeNode | null = null;
    if (tn.skip(Token.COLON)) {
      type = this.parseType(tn, true);
    }

    var initializer: Expression | null = null;
    if (tn.skip(Token.EQUALS)) {
      if (flags & CommonFlags.AMBIENT) {
        this.error(
          DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts,
          tn.range()
        ); // recoverable
      }
      initializer = this.parseExpression(tn, Precedence.COMMA + 1);
      if (!initializer) return null;
    } else if (!isFor) {
      if (flags & CommonFlags.CONST) {
        if (!(flags & CommonFlags.AMBIENT)) {
          this.error(
            DiagnosticCode._const_declarations_must_be_initialized,
            identifier.range
          ); // recoverable
        }
      } else if (!type) { // neither type nor initializer
        this.error(
          DiagnosticCode.Type_expected,
          tn.range(tn.pos)
        ); // recoverable
      }
    }
    var range = Range.join(identifier.range, tn.range());
    if (initializer !== null && (flags & CommonFlags.DEFINITELY_ASSIGNED) != 0) {
      this.error(
        DiagnosticCode.A_definite_assignment_assertion_is_not_permitted_in_this_context,
        range
      );
    }
    return Node.createVariableDeclaration(
      identifier,
      parentDecorators,
      flags,
      type,
      initializer,
      range
    );
  }

  parseEnum(
    tn: Tokenizer,
    flags: CommonFlags,
    decorators: DecoratorNode[] | null,
    startPos: i32
  ): EnumDeclaration | null {

    // at 'enum': Identifier '{' (EnumValueDeclaration (',' EnumValueDeclaration )*)? '}' ';'?

    if (tn.next() != Token.IDENTIFIER) {
      this.error(
        DiagnosticCode.Identifier_expected,
        tn.range()
      );
      return null;
    }
    var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
    if (tn.next() != Token.OPENBRACE) {
      this.error(
        DiagnosticCode._0_expected,
        tn.range(), "{"
      );
      return null;
    }
    var members = new Array<EnumValueDeclaration>();
    while (!tn.skip(Token.CLOSEBRACE)) {
      let member = this.parseEnumValue(tn, CommonFlags.NONE);
      if (!member) return null;
      members.push(member);
      if (!tn.skip(Token.COMMA)) {
        if (tn.skip(Token.CLOSEBRACE)) {
          break;
        } else {
          this.error(
            DiagnosticCode._0_expected,
            tn.range(), "}"
          );
          return null;
        }
      }
    }
    var ret = Node.createEnumDeclaration(
      identifier,
      decorators,
      flags,
      members,
      tn.range(startPos, tn.pos)
    );
    tn.skip(Token.SEMICOLON);
    return ret;
  }

  parseEnumValue(
    tn: Tokenizer,
    parentFlags: CommonFlags
  ): EnumValueDeclaration | null {

    // before: Identifier ('=' Expression)?

    if (!tn.skipIdentifier()) {
      this.error(
        DiagnosticCode.Identifier_expected,
        tn.range()
      );
      return null;
    }
    var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
    var value: Expression | null = null;
    if (tn.skip(Token.EQUALS)) {
      value = this.parseExpression(tn, Precedence.COMMA + 1);
      if (!value) return null;
    }
    return Node.createEnumValueDeclaration(
      identifier,
      parentFlags,
      value,
      Range.join(identifier.range, tn.range())
    );
  }

  parseReturn(
    tn: Tokenizer
  ): ReturnStatement | null {

    // at 'return': Expression | (';' | '}' | ...'\n')

    var startPos = tn.tokenPos;
    var expr: Expression | null = null;
    if (
      tn.peek(true) != Token.SEMICOLON &&
      tn.nextToken != Token.CLOSEBRACE &&
      !tn.nextTokenOnNewLine
    ) {
      if (!(expr = this.parseExpression(tn))) return null;
    }

    var ret = Node.createReturnStatement(expr, tn.range(startPos, tn.pos));
    tn.skip(Token.SEMICOLON);
    return ret;
  }

  parseTypeParameters(
    tn: Tokenizer
  ): TypeParameterNode[] | null {

    // at '<': TypeParameter (',' TypeParameter)* '>'

    var typeParameters = new Array<TypeParameterNode>();
    var seenOptional = false;
    var start = tn.tokenPos;
    while (!tn.skip(Token.GREATERTHAN)) {
      let typeParameter = this.parseTypeParameter(tn);
      if (!typeParameter) return null;
      if (typeParameter.defaultType !== null) {
        seenOptional = true;
      } else if (seenOptional) {
        this.error(
          DiagnosticCode.Required_type_parameters_may_not_follow_optional_type_parameters,
          typeParameter.range
        );
        typeParameter.defaultType = null;
      }
      typeParameters.push(typeParameter);
      if (!tn.skip(Token.COMMA)) {
        if (tn.skip(Token.GREATERTHAN)) {
          break;
        } else {
          this.error(
            DiagnosticCode._0_expected,
            tn.range(), ">"
          );
          return null;
        }
      }
    }
    if (!typeParameters.length) {
      this.error(
        DiagnosticCode.Type_parameter_list_cannot_be_empty,
        tn.range(start, tn.pos)
      ); // recoverable
    }
    return typeParameters;
  }

  parseTypeParameter(
    tn: Tokenizer
  ): TypeParameterNode | null {

    // before: Identifier ('extends' Type)? ('=' Type)?

    if (tn.next() == Token.IDENTIFIER) {
      let identifier = Node.createIdentifierExpression(
        tn.readIdentifier(),
        tn.range()
      );
      let extendsType: NamedTypeNode | null = null;
      if (tn.skip(Token.EXTENDS)) {
        let type = this.parseType(tn);
        if (!type) return null;
        if (type.kind != NodeKind.NAMEDTYPE) {
          this.error(
            DiagnosticCode.Identifier_expected,
            type.range
          );
          return null;
        }
        extendsType = <NamedTypeNode>type;
      }
      let defaultType: NamedTypeNode | null = null;
      if (tn.skip(Token.EQUALS)) {
        let type = this.parseType(tn);
        if (!type) return null;
        if (type.kind != NodeKind.NAMEDTYPE) {
          this.error(
            DiagnosticCode.Identifier_expected,
            type.range
          );
          return null;
        }
        defaultType = <NamedTypeNode>type;
      }
      return Node.createTypeParameter(
        identifier,
        extendsType,
        defaultType,
        Range.join(identifier.range, tn.range())
      );
    } else {
      this.error(
        DiagnosticCode.Identifier_expected,
        tn.range()
      );
    }
    return null;
  }

  private parseParametersThis: NamedTypeNode | null = null;

  parseParameters(
    tn: Tokenizer,
    isConstructor: bool = false
  ): ParameterNode[] | null {

    // at '(': (Parameter (',' Parameter)*)? ')'

    var parameters = new Array<ParameterNode>();
    var seenRest: ParameterNode | null = null;
    var seenOptional = false;
    var reportedRest = false;
    var thisType: TypeNode | null = null;

    // check if there is a leading `this` parameter
    this.parseParametersThis = null;
    if (tn.skip(Token.THIS)) {
      if (tn.skip(Token.COLON)) {
        thisType = this.parseType(tn); // reports
        if (!thisType) return null;
        if (thisType.kind == NodeKind.NAMEDTYPE) {
          this.parseParametersThis = <NamedTypeNode>thisType;
        } else {
          this.error(
            DiagnosticCode.Identifier_expected,
            thisType.range
          );
        }
      } else {
        this.error(
          DiagnosticCode._0_expected,
          tn.range(), ":"
        );
        return null;
      }
      if (!tn.skip(Token.COMMA)) {
        if (tn.skip(Token.CLOSEPAREN)) {
          return parameters;
        } else {
          this.error(
            DiagnosticCode._0_expected,
            tn.range(), ")"
          );
          return null;
        }
      }
    }

    while (!tn.skip(Token.CLOSEPAREN)) {
      let param = this.parseParameter(tn, isConstructor); // reports
      if (!param) return null;
      if (seenRest !== null && !reportedRest) {
        this.error(
          DiagnosticCode.A_rest_parameter_must_be_last_in_a_parameter_list,
          seenRest.name.range
        );
        reportedRest = true;
      }
      switch (param.parameterKind) {
        default: {
          if (seenOptional) {
            this.error(
              DiagnosticCode.A_required_parameter_cannot_follow_an_optional_parameter,
              param.name.range
            );
          }
          break;
        }
        case ParameterKind.OPTIONAL: {
          seenOptional = true;
          break;
        }
        case ParameterKind.REST: {
          seenRest = param;
          break;
        }
      }
      parameters.push(param);
      if (!tn.skip(Token.COMMA)) {
        if (tn.skip(Token.CLOSEPAREN)) {
          break;
        } else {
          this.error(
            DiagnosticCode._0_expected,
            tn.range(), ")"
          );
          return null;
        }
      }
    }
    return parameters;
  }

  parseParameter(
    tn: Tokenizer,
    isConstructor: bool = false
  ): ParameterNode | null {

    // before: ('public' | 'private' | 'protected' | '...')? Identifier '?'? (':' Type)? ('=' Expression)?

    var isRest = false;
    var isOptional = false;
    var startRange: Range | null = null;
    var accessFlags: CommonFlags = CommonFlags.NONE;
    if (isConstructor) {
      if (tn.skip(Token.PUBLIC)) {
        startRange = tn.range();
        accessFlags |= CommonFlags.PUBLIC;
      } else if (tn.skip(Token.PROTECTED)) {
        startRange = tn.range();
        accessFlags |= CommonFlags.PROTECTED;
      } else if (tn.skip(Token.PRIVATE)) {
        startRange = tn.range();
        accessFlags |= CommonFlags.PRIVATE;
      }
      if (tn.peek() == Token.READONLY) {
        let state = tn.mark();
        tn.next();
        if (tn.peek() != Token.COLON) { // modifier
          tn.discard(state);
          if (!startRange) startRange = tn.range();
          accessFlags |= CommonFlags.READONLY;
        } else { // identifier
          tn.reset(state);
        }
      }
    }
    if (tn.skip(Token.DOT_DOT_DOT)) {
      if (accessFlags) {
        this.error(
          DiagnosticCode.A_parameter_property_cannot_be_declared_using_a_rest_parameter,
          tn.range()
        );
      } else {
        startRange = tn.range();
      }
      isRest = true;
    }
    if (tn.skipIdentifier()) {
      if (!isRest) startRange = tn.range();
      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
      let type: TypeNode | null = null;
      if (isOptional = tn.skip(Token.QUESTION)) {
        if (isRest) {
          this.error(
            DiagnosticCode.A_rest_parameter_cannot_be_optional,
            identifier.range
          );
        }
      }
      if (tn.skip(Token.COLON)) {
        type = this.parseType(tn);
        if (!type) return null;
      } else {
        type = Node.createOmittedType(tn.range(tn.pos));
      }
      let initializer: Expression | null = null;
      if (tn.skip(Token.EQUALS)) {
        if (isRest) {
          this.error(
            DiagnosticCode.A_rest_parameter_cannot_have_an_initializer,
            identifier.range
          );
        }
        if (isOptional) {
          this.error(
            DiagnosticCode.Parameter_cannot_have_question_mark_and_initializer,
            identifier.range
          );
        } else {
          isOptional = true;
        }
        initializer = this.parseExpression(tn, Precedence.COMMA + 1);
        if (!initializer) return null;
      }
      let param = Node.createParameter(
        isRest
          ? ParameterKind.REST
          : isOptional
            ? ParameterKind.OPTIONAL
            : ParameterKind.DEFAULT,
        identifier,
        type,
        initializer,
        Range.join(assert(startRange), tn.range())
      );
      param.flags |= accessFlags;
      return param;
    } else {
      this.error(
        DiagnosticCode.Identifier_expected,
        tn.range()
      );
    }
    return null;
  }

  parseFunction(
    tn: Tokenizer,
    flags: CommonFlags,
    decorators: DecoratorNode[] | null,
    startPos: i32
  ): FunctionDeclaration | null {

    // at 'function':
    //  Identifier
    //  ('<' TypeParameters)?
    //  '(' Parameters (':' Type)?
    //  '{' Statement* '}'
    //  ';'?

    if (!tn.skipIdentifier()) {
      this.error(
        DiagnosticCode.Identifier_expected,
        tn.range(tn.pos)
      );
      return null;
    }

    var name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
    var signatureStart = -1;

    var typeParameters: TypeParameterNode[] | null = null;
    if (tn.skip(Token.LESSTHAN)) {
      signatureStart = tn.tokenPos;
      typeParameters = this.parseTypeParameters(tn);
      if (!typeParameters) return null;
      flags |= CommonFlags.GENERIC;
    }

    if (!tn.skip(Token.OPENPAREN)) {
      this.error(
        DiagnosticCode._0_expected,
        tn.range(tn.pos), "("
      );
      return null;
    }

    if (signatureStart < 0) {
      signatureStart = tn.tokenPos;
    }

    var parameters = this.parseParameters(tn);
    if (!parameters) return null;
    var thisType = this.parseParametersThis;

    var isSetter = (flags & CommonFlags.SET) != 0;
    if (isSetter) {
      if (parameters.length != 1) {
        this.error(
          DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter,
          name.range
        ); // recoverable
      }
      if (parameters.length > 0 && parameters[0].initializer !== null) {
        this.error(
          DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer,
          name.range
        ); // recoverable
      }
    }

    if (flags & CommonFlags.GET) {
      if (parameters.length) {
        this.error(
          DiagnosticCode.A_get_accessor_cannot_have_parameters,
          name.range
        ); // recoverable
      }
    }

    var returnType: TypeNode | null = null;
    if (tn.skip(Token.COLON)) {
      returnType = this.parseType(tn, true, isSetter);
      if (!returnType) return null;
    }

    if (!returnType) {
      returnType = Node.createOmittedType(
        tn.range(tn.pos)
      );
      if (!isSetter) {
        this.error(
          DiagnosticCode.Type_expected,
          returnType.range
        ); // recoverable
      }
    }

    var signature = Node.createFunctionType(
      parameters,
      returnType,
      thisType,
      false,
      tn.range(signatureStart, tn.pos)
    );

    var body: Statement | null = null;
    if (tn.skip(Token.OPENBRACE)) {
      if (flags & CommonFlags.AMBIENT) {
        this.error(
          DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,
          tn.range()
        ); // recoverable
      }

      body = this.parseBlockStatement(tn, false);
      if (!body) return null;
    } else if (!(flags & CommonFlags.AMBIENT)) {
      this.error(
        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,
        tn.range(tn.pos)
      );
    }

    var ret = Node.createFunctionDeclaration(
      name,
      decorators,
      flags,
      typeParameters,
      signature,
      body,
      ArrowKind.NONE,
      tn.range(startPos, tn.pos)
    );
    tn.skip(Token.SEMICOLON);
    return ret;
  }

  parseFunctionExpression(tn: Tokenizer): FunctionExpression | null {
    var startPos = tn.tokenPos;
    var name: IdentifierExpression;
    var arrowKind = ArrowKind.NONE;

    // either at 'function':
    //  Identifier?
    //  '(' Parameters (':' Type)?
    //  Statement

    if (tn.token == Token.FUNCTION) {
      if (tn.skipIdentifier()) {
        name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
      } else { // empty name
        name = Node.createEmptyIdentifierExpression(tn.range(tn.pos));
      }
      if (!tn.skip(Token.OPENPAREN)) {
        this.error(
          DiagnosticCode._0_expected,
          tn.range(tn.pos), "("
        );
        return null;
      }

      // or at '(' of arrow function:
      //  Parameters (':' Type)?
      //  Statement

    } else {
      arrowKind = ArrowKind.ARROW_PARENTHESIZED;
      assert(tn.token == Token.OPENPAREN);
      name = Node.createEmptyIdentifierExpression(tn.range(tn.tokenPos));
    }

    // TODO: type parameters? doesn't seem worth it.

    var signatureStart = tn.pos;
    var parameters = this.parseParameters(tn);
    if (!parameters) return null;

    return this.parseFunctionExpressionCommon(tn, name, parameters, this.parseParametersThis, arrowKind, startPos, signatureStart);
  }

  private parseFunctionExpressionCommon(
    tn: Tokenizer,
    name: IdentifierExpression,
    parameters: ParameterNode[],
    explicitThis: NamedTypeNode | null,
    arrowKind: ArrowKind,
    startPos: i32 = -1,
    signatureStart: i32 = -1
  ): FunctionExpression | null {
    if (startPos < 0) startPos = name.range.start;
    if (signatureStart < 0) signatureStart = startPos;

    var returnType: TypeNode | null = null;
    if (arrowKind != ArrowKind.ARROW_SINGLE && tn.skip(Token.COLON)) {
      returnType = this.parseType(tn);
      if (!returnType) return null;
    } else {
      returnType = Node.createOmittedType(tn.range(tn.pos));
    }

    if (arrowKind) {
      if (!tn.skip(Token.EQUALS_GREATERTHAN)) {
        this.error(
          DiagnosticCode._0_expected,
          tn.range(tn.pos), "=>"
        );
        return null;
      }
    }

    var signature = Node.createFunctionType(
      parameters,
      returnType,
      explicitThis,
      false,
      tn.range(signatureStart, tn.pos)
    );

    var body: Statement | null = null;
    if (arrowKind) {
      if (tn.skip(Token.OPENBRACE)) {
        body = this.parseBlockStatement(tn, false);
      } else {
        let bodyExpression = this.parseExpression(tn, Precedence.COMMA + 1);
        if (bodyExpression) body = Node.createExpressionStatement(bodyExpression);
      }
    } else {
      if (!tn.skip(Token.OPENBRACE)) {
        this.error(
          DiagnosticCode._0_expected,
          tn.range(tn.pos), "{"
        );
        return null;
      }
      body = this.parseBlockStatement(tn, false);
    }
    if (!body) return null;

    var declaration = Node.createFunctionDeclaration(
      name,
      null,
      CommonFlags.NONE,
      null,
      signature,
      body,
      arrowKind,
      tn.range(startPos, tn.pos)
    );
    return Node.createFunctionExpression(declaration);
  }

  parseClassOrInterface(
    tn: Tokenizer,
    flags: CommonFlags,
    decorators: DecoratorNode[] | null,
    startPos: i32
  ): ClassDeclaration | null {

    // at ('class' | 'interface'):
    //   Identifier
    //   ('<' TypeParameters)?
    //   ('extends' Type)?
    //   ('implements' Type (',' Type)*)?
    //   '{' ClassMember* '}'

    var isInterface = tn.token == Token.INTERFACE;

    if (!tn.skipIdentifier()) {
      this.error(
        DiagnosticCode.Identifier_expected,
        tn.range()
      );
      return null;
    }

    var identifier = Node.createIdentifierExpression(
      tn.readIdentifier(),
      tn.range()
    );

    var typeParameters: TypeParameterNode[] | null = null;
    if (tn.skip(Token.LESSTHAN)) {
      typeParameters = this.parseTypeParameters(tn);
      if (!typeParameters) return null;
      flags |= CommonFlags.GENERIC;
    }

    var extendsType: NamedTypeNode | null = null;
    if (tn.skip(Token.EXTENDS)) {
      let type = this.parseType(tn);
      if (!type) return null;
      if (type.kind != NodeKind.NAMEDTYPE) {
        this.error(
          DiagnosticCode.Identifier_expected,
          type.range
        );
        return null;
      }
      extendsType = <NamedTypeNode>type;
    }

    var implementsTypes: NamedTypeNode[] | null = null;
    if (tn.skip(Token.IMPLEMENTS)) {
      if (isInterface) {
        this.error(
          DiagnosticCode.Interface_declaration_cannot_have_implements_clause,
          tn.range()
        ); // recoverable
      }
      do {
        let type = this.parseType(tn);
        if (!type) return null;
        if (type.kind != NodeKind.NAMEDTYPE) {
          this.error(
            DiagnosticCode.Identifier_expected,
            type.range
          );
          return null;
        }
        if (!isInterface) {
          if (!implementsTypes) implementsTypes = [];
          implementsTypes.push(<NamedTypeNode>type);
        }
      } while (tn.skip(Token.COMMA));
    }

    if (!tn.skip(Token.OPENBRACE)) {
      this.error(
        DiagnosticCode._0_expected,
        tn.range(), "{"
      );
      return null;
    }

    var members = new Array<DeclarationStatement>();
    var declaration: ClassDeclaration;
    if (isInterface) {
      assert(!implementsTypes);
      declaration = Node.createInterfaceDeclaration(
        identifier,
        decorators,
        flags,
        typeParameters,
        extendsType,
        null,
        members,
        tn.range(startPos, tn.pos)
      );
    } else {
      declaration = Node.createClassDeclaration(
        identifier,
        decorators,
        flags,
        typeParameters,
        extendsType,
        implementsTypes,
        members,
        tn.range(startPos, tn.pos)
      );
    }
    if (!tn.skip(Token.CLOSEBRACE)) {
      do {
        let member = this.parseClassMember(tn, declaration);
        if (member) {
          if (member.kind == NodeKind.INDEXSIGNATURE) {
            declaration.indexSignature = <IndexSignatureNode>member;
          } else {
            assert(member instanceof DeclarationStatement);
            members.push(<DeclarationStatement>member);
          }
        } else {
          this.skipStatement(tn);
          if (tn.skip(Token.ENDOFFILE)) {
            this.error(
              DiagnosticCode._0_expected,
              tn.range(), "}"
            );
            return null;
          }
        }
      } while (!tn.skip(Token.CLOSEBRACE));
    }
    declaration.range.end = tn.pos;
    return declaration;
  }

  parseClassExpression(tn: Tokenizer): ClassExpression | null {

    // at 'class': Identifier? '{' ... '}'

    var startPos = tn.tokenPos;
    var name: IdentifierExpression;

    if (tn.skipIdentifier()) {
      name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
    } else {
      name = Node.createEmptyIdentifierExpression(tn.range(tn.pos));
    }

    if (!tn.skip(Token.OPENBRACE)) {
      this.error(
        DiagnosticCode._0_expected,
        tn.range(tn.pos), "{"
      );
      return null;
    }

    var members = new Array<DeclarationStatement>();
    var declaration = Node.createClassDeclaration(
      name,
      null,
      CommonFlags.NONE,
      null,
      null,
      null,
      members,
      tn.range(startPos, tn.pos)
    );
    if (!tn.skip(Token.CLOSEBRACE)) {
      do {
        let member = this.parseClassMember(tn, declaration);
        if (member) {
          if (member.kind == NodeKind.INDEXSIGNATURE) {
            declaration.indexSignature = <IndexSignatureNode>member;
          } else {
            assert(declaration instanceof DeclarationStatement);
            members.push(<DeclarationStatement>member);
          }
        } else {
          this.skipStatement(tn);
          if (tn.skip(Token.ENDOFFILE)) {
            this.error(
              DiagnosticCode._0_expected,
              tn.range(), "}"
            );
            return null;
          }
        }
      } while (!tn.skip(Token.CLOSEBRACE));
    }
    declaration.range.end = tn.pos;
    return Node.createClassExpression(declaration);
  }

  parseClassMember(
    tn: Tokenizer,
    parent: ClassDeclaration
  ): Node | null {

    // before:
    //   ('public' | 'private' | 'protected')?
    //   ('static' | 'abstract')?
    //   'readonly'?
    //   ('get' | 'set')?
    //   Identifier ...

    var isInterface = parent.kind == NodeKind.INTERFACEDECLARATION;
    var startPos = 0;
    var decorators: DecoratorNode[] | null = null;
    if (tn.skip(Token.AT)) {
      startPos = tn.tokenPos;
      do {
        let decorator = this.parseDecorator(tn);
        if (!decorator) break;
        if (!decorators) decorators = new Array();
        decorators.push(decorator);
      } while (tn.skip(Token.AT));
      if (isInterface && decorators !== null) {
        this.error(
          DiagnosticCode.Decorators_are_not_valid_here,
          Range.join(decorators[0].range, decorators[decorators.length - 1].range)
        );
      }
    }

    // inherit ambient status
    var flags = parent.flags & CommonFlags.AMBIENT;

    // implemented methods are virtual
    if (isInterface) flags |= CommonFlags.VIRTUAL;

    var accessStart = 0;
    var accessEnd = 0;
    if (tn.skip(Token.PUBLIC)) {
      if (isInterface) {
        this.error(
          DiagnosticCode._0_modifier_cannot_be_used_here,
          tn.range(), "public"
        );
      } else {
        flags |= CommonFlags.PUBLIC;
        accessStart = tn.tokenPos;
        accessEnd = tn.pos;
      }
      if (!startPos) startPos = tn.tokenPos;
    } else if (tn.skip(Token.PRIVATE)) {
      if (isInterface) {
        this.error(
          DiagnosticCode._0_modifier_cannot_be_used_here,
          tn.range(), "private"
        );
      } else {
        flags |= CommonFlags.PRIVATE;
        accessStart = tn.tokenPos;
        accessEnd = tn.pos;
      }
      if (!startPos) startPos = tn.tokenPos;
    } else if (tn.skip(Token.PROTECTED)) {
      if (isInterface) {
        this.error(
          DiagnosticCode._0_modifier_cannot_be_used_here,
          tn.range(), "protected"
        );
      } else {
        flags |= CommonFlags.PROTECTED;
        accessStart = tn.tokenPos;
        accessEnd = tn.pos;
      }
      if (!startPos) startPos = tn.tokenPos;
    }

    var staticStart = 0;
    var staticEnd = 0;
    var abstractStart = 0;
    var abstractEnd = 0;
    if (tn.skip(Token.STATIC)) {
      if (isInterface) {
        this.error(
          DiagnosticCode._0_modifier_cannot_be_used_here,
          tn.range(), "static"
        );
      } else {
        flags |= CommonFlags.STATIC;
        staticStart = tn.tokenPos;
        staticEnd = tn.pos;
      }
      if (!startPos) startPos = tn.tokenPos;
    } else {
      flags |= CommonFlags.INSTANCE;
      if (tn.skip(Token.ABSTRACT)) {
        if (isInterface || !parent.is(CommonFlags.ABSTRACT)) {
          this.error(
            DiagnosticCode._0_modifier_cannot_be_used_here,
            tn.range(), "abstract"
          );
        } else {
          flags |= CommonFlags.ABSTRACT;
          abstractStart = tn.tokenPos;
          abstractEnd = tn.pos;
        }
        if (!startPos) startPos = tn.tokenPos;
      }
      if (parent.flags & CommonFlags.GENERIC) flags |= CommonFlags.GENERIC_CONTEXT;
    }

    var readonlyStart = 0;
    var readonlyEnd = 0;
    if (tn.peek() == Token.READONLY) {
      let state = tn.mark();
      tn.next();
      if (tn.peek() != Token.COLON) { // modifier
        tn.discard(state);
        flags |= CommonFlags.READONLY;
        readonlyStart = tn.tokenPos;
        readonlyEnd = tn.pos;
        if (!startPos) startPos = readonlyStart;
      } else { // identifier
        tn.reset(state);
      }
    }

    // check if accessor: ('get' | 'set') ^\n Identifier
    var state = tn.mark();
    var isConstructor = false;
    var isGetter = false;
    var getStart = 0;
    var getEnd = 0;
    var isSetter = false;
    var setStart = 0;
    var setEnd = 0;
    if (!isInterface) {
      if (tn.skip(Token.GET)) {
        if (tn.peek(true, IdentifierHandling.PREFER) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {
          flags |= CommonFlags.GET;
          isGetter = true;
          getStart = tn.tokenPos;
          getEnd = tn.pos;
          if (!startPos) startPos = getStart;
          if (flags & CommonFlags.READONLY) {
            this.error(
              DiagnosticCode._0_modifier_cannot_be_used_here,
              tn.range(readonlyStart, readonlyEnd), "readonly"
            ); // recoverable
          }
        } else {
          tn.reset(state);
        }
      } else if (tn.skip(Token.SET)) {
        if (tn.peek(true, IdentifierHandling.PREFER) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {
          flags |= CommonFlags.SET;
          isSetter = true;
          setStart = tn.tokenPos;
          setEnd = tn.pos;
          if (!startPos) startPos = setStart;
          if (flags & CommonFlags.READONLY) {
            this.error(
              DiagnosticCode._0_modifier_cannot_be_used_here,
              tn.range(readonlyStart, readonlyEnd), "readonly"
            ); // recoverable
          }
        } else {
          tn.reset(state);
        }
      } else if (tn.skip(Token.CONSTRUCTOR)) {
        flags |= CommonFlags.CONSTRUCTOR;
        isConstructor = true;
        if (!startPos) startPos = tn.tokenPos;
        if (flags & CommonFlags.STATIC) {
          this.error(
            DiagnosticCode._0_modifier_cannot_be_used_here,
            tn.range(staticStart, staticEnd), "static"
          ); // recoverable
        }
        if (flags & CommonFlags.ABSTRACT) {
          this.error(
            DiagnosticCode._0_modifier_cannot_be_used_here,
            tn.range(abstractStart, abstractEnd), "abstract"
          ); // recoverable
        }
        if (flags & CommonFlags.READONLY) {
          this.error(
            DiagnosticCode._0_modifier_cannot_be_used_here,
            tn.range(readonlyStart, readonlyEnd), "readonly"
          ); // recoverable
        }
      }
    }

    var isGetterOrSetter = isGetter || isSetter;
    var name: IdentifierExpression;
    if (isConstructor) {
      name = Node.createConstructorExpression(tn.range());
    } else {
      if (!isGetterOrSetter && tn.skip(Token.OPENBRACKET)) {
        if (!startPos) startPos = tn.tokenPos;
        // TODO: also handle symbols, which might have some of these modifiers
        if (flags & CommonFlags.PUBLIC) {
          this.error(
            DiagnosticCode._0_modifier_cannot_be_used_here,
            tn.range(accessStart, accessEnd), "public"
          ); // recoverable
        } else if (flags & CommonFlags.PROTECTED) {
          this.error(
            DiagnosticCode._0_modifier_cannot_be_used_here,
            tn.range(accessStart, accessEnd), "protected"
          ); // recoverable
        } else if (flags & CommonFlags.PRIVATE) {
          this.error(
            DiagnosticCode._0_modifier_cannot_be_used_here,
            tn.range(accessStart, accessEnd), "protected"
          ); // recoverable
        }
        if (flags & CommonFlags.STATIC) {
          this.error(
            DiagnosticCode._0_modifier_cannot_be_used_here,
            tn.range(staticStart, staticEnd), "static"
          ); // recoverable
        }
        if (flags & CommonFlags.ABSTRACT) {
          this.error(
            DiagnosticCode._0_modifier_cannot_be_used_here,
            tn.range(abstractStart, abstractEnd), "abstract"
          ); // recoverable
        }
        let retIndex = this.parseIndexSignature(tn, flags, decorators);
        if (!retIndex) {
          if (flags & CommonFlags.READONLY) {
            this.error(
              DiagnosticCode._0_modifier_cannot_be_used_here,
              tn.range(readonlyStart, readonlyEnd), "readonly"
            ); // recoverable
          }
          return null;
        }
        tn.skip(Token.SEMICOLON);
        return retIndex;
      }
      if (!tn.skipIdentifier(IdentifierHandling.ALWAYS)) {
        this.error(
          DiagnosticCode.Identifier_expected,
          tn.range()
        );
        return null;
      }
      if (!startPos) startPos = tn.tokenPos;
      name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
    }
    var typeParameters: TypeParameterNode[] | null = null;
    if (tn.skip(Token.LESSTHAN)) {
      let typeParametersStart = tn.tokenPos;
      typeParameters = this.parseTypeParameters(tn);
      if (!typeParameters) return null;
      if (isConstructor) {
        this.error(
          DiagnosticCode.Type_parameters_cannot_appear_on_a_constructor_declaration,
          tn.range(typeParametersStart, tn.pos)
        ); // recoverable
      } else if (isGetterOrSetter) {
        this.error(
          DiagnosticCode.An_accessor_cannot_have_type_parameters,
          tn.range(typeParametersStart, tn.pos)
        ); // recoverable
      } else {
        flags |= CommonFlags.GENERIC;
      }
    }

    // method: '(' Parameters (':' Type)? '{' Statement* '}' ';'?
    if (tn.skip(Token.OPENPAREN)) {
      let signatureStart = tn.tokenPos;
      let parameters = this.parseParameters(tn, isConstructor);
      if (!parameters) return null;
      let thisType = this.parseParametersThis;
      if (isConstructor) {
        for (let i = 0, k = parameters.length; i < k; ++i) {
          let parameter = parameters[i];
          if (parameter.isAny(
            CommonFlags.PUBLIC |
            CommonFlags.PROTECTED |
            CommonFlags.PRIVATE |
            CommonFlags.READONLY
          )) {
            let implicitFieldDeclaration = Node.createFieldDeclaration(
              parameter.name,
              null,
              parameter.flags | CommonFlags.INSTANCE,
              parameter.type,
              null, // initialized via parameter
              parameter.range
            );
            implicitFieldDeclaration.parameterIndex = i;
            parameter.implicitFieldDeclaration = implicitFieldDeclaration;
            parent.members.push(implicitFieldDeclaration);
          }
        }
      } else if (isGetter) {
        if (parameters.length) {
          this.error(
            DiagnosticCode.A_get_accessor_cannot_have_parameters,
            name.range
          );
        }
      } else if (isSetter) {
        if (parameters.length != 1) {
          this.error(
            DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter,
            name.range
          );
        }
        if (parameters.length > 0 && parameters[0].initializer !== null) {
          this.error(
            DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer,
            name.range
          );
        }
      } else if (name.text == "constructor") {
        this.error(
          DiagnosticCode._0_keyword_cannot_be_used_here,
          name.range, "constructor"
        );
      }

      let returnType: TypeNode | null = null;
      if (tn.skip(Token.COLON)) {
        if (name.kind == NodeKind.CONSTRUCTOR) {
          this.error(
            DiagnosticCode.Type_annotation_cannot_appear_on_a_constructor_declaration,
            tn.range()
          );
        } else if (isSetter) {
          this.error(
            DiagnosticCode.A_set_accessor_cannot_have_a_return_type_annotation,
            tn.range()
          );
        }
        returnType = this.parseType(tn, isSetter || name.kind == NodeKind.CONSTRUCTOR);
        if (!returnType) return null;
      } else {
        returnType = Node.createOmittedType(tn.range(tn.pos));
        if (!isSetter && name.kind != NodeKind.CONSTRUCTOR) {
          this.error(
            DiagnosticCode.Type_expected,
            returnType.range
          ); // recoverable
        }
      }

      let signature = Node.createFunctionType(
        parameters,
        returnType,
        thisType,
        false,
        tn.range(signatureStart, tn.pos)
      );

      let body: Statement | null = null;
      if (tn.skip(Token.OPENBRACE)) {
        if (flags & CommonFlags.AMBIENT) {
          this.error(
            DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,
            tn.range()
          ); // recoverable
        } else if (flags & CommonFlags.ABSTRACT) {
          this.error(
            DiagnosticCode.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract,
            tn.range(), name.text
          ); // recoverable
        } else if (isInterface) {
          this.error(
            DiagnosticCode._0_expected,
            tn.range(), ";"
          ); // recoverable
        }
        body = this.parseBlockStatement(tn, false);
        if (!body) return null;
      } else if (!isInterface && !(flags & (CommonFlags.AMBIENT | CommonFlags.ABSTRACT))) {
        this.error(
          DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,
          tn.range()
        ); // recoverable
      }

      let retMethod = Node.createMethodDeclaration(
        name,
        decorators,
        flags,
        typeParameters,
        signature,
        body,
        tn.range(startPos, tn.pos)
      );
      if (!(isInterface && tn.skip(Token.COMMA))) {
        tn.skip(Token.SEMICOLON);
      }
      return retMethod;

    } else if (isConstructor) {
      this.error(
        DiagnosticCode.Constructor_implementation_is_missing,
        name.range
      );

    } else if (isGetterOrSetter) {
      this.error(
        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,
        name.range
      );

    // field: (':' Type)? ('=' Expression)? ';'?
    } else {
      if (flags & CommonFlags.ABSTRACT) {
        this.error(
          DiagnosticCode._0_modifier_cannot_be_used_here,
          tn.range(abstractStart, abstractEnd), "abstract"
        ); // recoverable
      }

      if (flags & CommonFlags.GET) {
        this.error(
          DiagnosticCode._0_modifier_cannot_be_used_here,
          tn.range(getStart, getEnd), "get"
        ); // recoverable
      }

      if (flags & CommonFlags.SET) {
        this.error(
          DiagnosticCode._0_modifier_cannot_be_used_here,
          tn.range(setStart, setEnd), "set"
        ); // recoverable
      }

      let type: TypeNode | null = null;
      if (tn.skip(Token.QUESTION)) {
        this.error(
          DiagnosticCode.Optional_properties_are_not_supported,
          tn.range(startPos, tn.pos)
        );
      }
      if (tn.skip(Token.EXCLAMATION)) {
        flags |= CommonFlags.DEFINITELY_ASSIGNED;
      }
      if (tn.skip(Token.COLON)) {
        type = this.parseType(tn);
        if (!type) return null;
      } else {
        this.error(
          DiagnosticCode.Type_expected,
          tn.range()
        ); // recoverable
      }
      let initializer: Expression | null = null;
      if (tn.skip(Token.EQUALS)) {
        initializer = this.parseExpression(tn);
        if (!initializer) return null;
      }
      let range = tn.range(startPos, tn.pos);
      if (
        (flags & CommonFlags.DEFINITELY_ASSIGNED) != 0 &&
        (isInterface || initializer !== null || (flags & CommonFlags.STATIC) != 0)
      ) {
        this.error(
          DiagnosticCode.A_definite_assignment_assertion_is_not_permitted_in_this_context,
          range
        );
      }
      let retField = Node.createFieldDeclaration(
        name,
        decorators,
        flags,
        type,
        initializer,
        range
      );
      if (!(isInterface && tn.skip(Token.COMMA))) {
        tn.skip(Token.SEMICOLON);
      }
      return retField;
    }
    return null;
  }

  parseIndexSignature(
    tn: Tokenizer,
    flags: CommonFlags,
    decorators: DecoratorNode[] | null,
  ): IndexSignatureNode | null {

    // at: '[': 'key' ':' Type ']' ':' Type

    if (decorators !== null && decorators.length > 0) {
      this.error(
        DiagnosticCode.Decorators_are_not_valid_here,
        Range.join(decorators[0].range, decorators[decorators.length - 1].range)
      ); // recoverable
    }

    var start = tn.tokenPos;
    if (tn.skipIdentifier()) {
      let id = tn.readIdentifier();
      if (id == "key") {
        if (tn.skip(Token.COLON)) {
          let keyType = this.parseType(tn);
          if (!keyType) return null;
          if (keyType.kind != NodeKind.NAMEDTYPE) {
            this.error(
              DiagnosticCode.Type_expected,
              tn.range()
            );
            return null;
          }
          if (tn.skip(Token.CLOSEBRACKET)) {
            if (tn.skip(Token.COLON)) {
              let valueType = this.parseType(tn);
              if (!valueType) return null;
              if (valueType.kind != NodeKind.NAMEDTYPE) {
                this.error(
                  DiagnosticCode.Identifier_expected,
                  valueType.range
                );
                return null;
              }
              return Node.createIndexSignature(<NamedTypeNode>keyType, valueType, flags, tn.range(start, tn.pos));
            } else {
              this.error(
                DiagnosticCode._0_expected,
                tn.range(), ":"
              );
            }
          } else {
            this.error(
              DiagnosticCode._0_expected,
              tn.range(), "]"
            );
          }
        } else {
          this.error(
            DiagnosticCode._0_expected,
            tn.range(), ":"
          );
        }
      } else {
        this.error(
          DiagnosticCode._0_expected,
          tn.range(), "key"
        );
      }
    } else {
      this.error(
        DiagnosticCode.Identifier_expected,
        tn.range()
      );
    }
    return null;
  }

  parseNamespace(
    tn: Tokenizer,
    flags: CommonFlags,
    decorators: DecoratorNode[] | null,
    startPos: i32
  ): NamespaceDeclaration | null {

    // at 'namespace': Identifier '{' (Variable | Function)* '}'

    if (tn.skipIdentifier()) {
      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
      if (tn.skip(Token.OPENBRACE)) {
        let members = new Array<Statement>();
        let declaration = Node.createNamespaceDeclaration(
          identifier,
          decorators,
          flags,
          members,
          tn.range(startPos, tn.pos)
        );
        while (!tn.skip(Token.CLOSEBRACE)) {
          let member = this.parseTopLevelStatement(tn, declaration);
          if (member) members.push(member);
          else {
            this.skipStatement(tn);
            if (tn.skip(Token.ENDOFFILE)) {
              this.error(
                DiagnosticCode._0_expected,
                tn.range(), "}"
              );
              return null;
            }
          }
        }
        declaration.range.end = tn.pos;
        tn.skip(Token.SEMICOLON);
        return declaration;
      } else {
        this.error(
          DiagnosticCode._0_expected,
          tn.range(), "{"
        );
      }
    } else {
      this.error(
        DiagnosticCode.Identifier_expected,
        tn.range()
      );
    }
    return null;
  }

  parseExport(
    tn: Tokenizer,
    startPos: i32,
    isDeclare: bool
  ): ExportStatement | null {

    // at 'export': '{' ExportMember (',' ExportMember)* }' ('from' StringLiteral)? ';'?

    var path: StringLiteralExpression | null = null;
    var currentSource = assert(this.currentSource);
    if (tn.skip(Token.OPENBRACE)) {
      let members = new Array<ExportMember>();
      while (!tn.skip(Token.CLOSEBRACE)) {
        let member = this.parseExportMember(tn);
        if (!member) return null;
        members.push(member);
        if (!tn.skip(Token.COMMA)) {
          if (tn.skip(Token.CLOSEBRACE)) {
            break;
          } else {
            this.error(
              DiagnosticCode._0_expected,
              tn.range(), "}"
            );
            return null;
          }
        }
      }
      if (tn.skip(Token.FROM)) {
        if (tn.skip(Token.STRINGLITERAL)) {
          path = Node.createStringLiteralExpression(tn.readString(), tn.range());
        } else {
          this.error(
            DiagnosticCode.String_literal_expected,
            tn.range()
          );
          return null;
        }
      }
      let ret = Node.createExportStatement(members, path, isDeclare, tn.range(startPos, tn.pos));
      if (path !== null) {
        let internalPath = assert(ret.internalPath);
        if (!this.seenlog.has(internalPath)) {
          this.dependees.set(internalPath, new Dependee(currentSource, path));
          this.backlog.push(internalPath);
          this.seenlog.add(internalPath);
        }
      }
      tn.skip(Token.SEMICOLON);
      return ret;
    } else if (tn.skip(Token.ASTERISK)) {
      if (tn.skip(Token.FROM)) {
        if (tn.skip(Token.STRINGLITERAL)) {
          path = Node.createStringLiteralExpression(tn.readString(), tn.range());
          let ret = Node.createExportStatement(null, path, isDeclare, tn.range(startPos, tn.pos));
          let internalPath = assert(ret.internalPath);
          let source = tn.source;
          let exportPaths = source.exportPaths;
          if (!exportPaths) source.exportPaths = [ internalPath ];
          else if (!exportPaths.includes(internalPath)) exportPaths.push(internalPath);
          if (!this.seenlog.has(internalPath)) {
            this.dependees.set(internalPath, new Dependee(currentSource, path));
            this.backlog.push(internalPath);
          }
          tn.skip(Token.SEMICOLON);
          return ret;
        } else {
          this.error(
            DiagnosticCode.String_literal_expected,
            tn.range()
          );
        }
      } else {
        this.error(
          DiagnosticCode._0_expected,
          tn.range(), "from"
        );
      }
    } else {
      this.error(
        DiagnosticCode._0_expected,
        tn.range(), "{"
      );
    }
    return null;
  }

  parseExportMember(
    tn: Tokenizer
  ): ExportMember | null {

    // before: Identifier ('as' Identifier)?

    if (tn.skipIdentifier(IdentifierHandling.ALWAYS)) {
      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
      let asIdentifier: IdentifierExpression | null = null;
      if (tn.skip(Token.AS)) {
        if (tn.skipIdentifier(IdentifierHandling.ALWAYS)) {
          asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
        } else {
          this.error(
            DiagnosticCode.Identifier_expected,
            tn.range()
          );
          return null;
        }
      }
      if (asIdentifier) {
        return Node.createExportMember(
          identifier,
          asIdentifier,
          Range.join(identifier.range, asIdentifier.range)
        );
      }
      return Node.createExportMember(
        identifier,
        null,
        identifier.range
      );
    } else {
      this.error(
        DiagnosticCode.Identifier_expected,
        tn.range()
      );
    }
    return null;
  }

  parseExportDefaultAlias(
    tn: Tokenizer,
    startPos: i32,
    defaultStart: i32,
    defaultEnd: i32
  ): ExportStatement {

    // at 'export' 'default': [Known-To-Be-]Identifier

    var name = tn.readIdentifier();
    var range = tn.range();
    var ret = Node.createExportStatement([
      Node.createExportMember(
        Node.createIdentifierExpression(name, range),
        Node.createIdentifierExpression("default", tn.range(defaultStart, defaultEnd)),
        range
      )
    ], null, false, tn.range(startPos, tn.pos));
    tn.skip(Token.SEMICOLON);
    return ret;
  }

  parseImport(
    tn: Tokenizer
  ): ImportStatement | null {

    // at 'import':
    //  ('{' (ImportMember (',' ImportMember)* '}') | ('*' 'as' Identifier)?
    //  'from' StringLiteral ';'?

    var startPos = tn.tokenPos;
    var members: ImportDeclaration[] | null = null;
    var namespaceName: IdentifierExpression | null = null;
    var skipFrom = false;
    if (tn.skip(Token.OPENBRACE)) { // import { ... } from "file"
      members = new Array();
      while (!tn.skip(Token.CLOSEBRACE)) {
        let member = this.parseImportDeclaration(tn);
        if (!member) return null;
        members.push(member);
        if (!tn.skip(Token.COMMA)) {
          if (tn.skip(Token.CLOSEBRACE)) {
            break;
          } else {
            this.error(
              DiagnosticCode._0_expected,
              tn.range(), "}"
            );
            return null;
          }
        }
      }
    } else if (tn.skip(Token.ASTERISK)) { // import * from "file"
      if (tn.skip(Token.AS)) {
        if (tn.skipIdentifier()) {
          namespaceName = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
        } else {
          this.error(
            DiagnosticCode.Identifier_expected,
            tn.range()
          );
          return null;
        }
      } else {
        this.error(
          DiagnosticCode._0_expected,
          tn.range(), "as"
        );
        return null;
      }
    } else if (tn.skip(Token.IDENTIFIER, IdentifierHandling.PREFER)) { // import Name from "file"
      let name = tn.readIdentifier();
      let range = tn.range();
      members = [
        Node.createImportDeclaration(
          Node.createIdentifierExpression("default", range),
          Node.createIdentifierExpression(name, range),
          range
        )
      ];
      if (tn.skip(Token.COMMA)) {
        // TODO: default + star, default + members
        this.error(
          DiagnosticCode.Not_implemented_0,
          tn.range(),
          "Mixed default and named imports"
        );
        return null;
      }
    } else { // import "file"
      skipFrom = true;
    }

    if (skipFrom || tn.skip(Token.FROM)) {
      if (tn.skip(Token.STRINGLITERAL)) {
        let path = Node.createStringLiteralExpression(tn.readString(), tn.range());
        let ret: ImportStatement;
        if (namespaceName) {
          assert(!members);
          ret = Node.createWildcardImportStatement(namespaceName, path, tn.range(startPos, tn.pos));
        } else {
          ret = Node.createImportStatement(members, path, tn.range(startPos, tn.pos));
        }
        let internalPath = ret.internalPath;
        if (!this.seenlog.has(internalPath)) {
          this.dependees.set(internalPath, new Dependee(assert(this.currentSource), path));
          this.backlog.push(internalPath);
        }
        tn.skip(Token.SEMICOLON);
        return ret;
      } else {
        this.error(
          DiagnosticCode.String_literal_expected,
          tn.range()
        );
      }
    } else {
      this.error(
        DiagnosticCode._0_expected,
        tn.range(), "from"
      );
    }
    return null;
  }

  parseImportDeclaration(
    tn: Tokenizer
  ): ImportDeclaration | null {

    // before: Identifier ('as' Identifier)?

    if (tn.skipIdentifier(IdentifierHandling.ALWAYS)) {
      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
      let asIdentifier: IdentifierExpression | null = null;
      if (tn.skip(Token.AS)) {
        if (tn.skipIdentifier()) {
          asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
        } else {
          this.error(
            DiagnosticCode.Identifier_expected,
            tn.range()
          );
          return null;
        }
      }
      if (asIdentifier) {
        return Node.createImportDeclaration(
          identifier,
          asIdentifier,
          Range.join(identifier.range, asIdentifier.range)
        );
      }
      return Node.createImportDeclaration(
        identifier,
        null,
        identifier.range
      );
    } else {
      this.error(
        DiagnosticCode.Identifier_expected,
        tn.range()
      );
    }
    return null;
  }

  parseExportImport(
    tn: Tokenizer,
    startPos: i32
  ): ExportImportStatement | null {

    // at 'export' 'import': Identifier ('=' Identifier)? ';'?

    if (tn.skipIdentifier()) {
      let asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
      if (tn.skip(Token.EQUALS)) {
        if (tn.skipIdentifier()) {
          let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
          let ret = Node.createExportImportStatement(identifier, asIdentifier, tn.range(startPos, tn.pos));
          tn.skip(Token.SEMICOLON);
          return ret;
        } else {
          this.error(
            DiagnosticCode.Identifier_expected,
            tn.range()
          );
        }
      } else {
        this.error(
          DiagnosticCode._0_expected,
          tn.range(), "="
        );
      }
    } else {
      this.error(
        DiagnosticCode.Identifier_expected,
        tn.range()
      );
    }
    return null;
  }

  parseStatement(
    tn: Tokenizer,
    topLevel: bool = false
  ): Statement | null {

    // at previous token

    var state = tn.mark();
    var token = tn.next();
    var statement: Statement | null = null;
    switch (token) {
      case Token.BREAK: {
        statement = this.parseBreak(tn);
        break;
      }
      case Token.CONST: {
        statement = this.parseVariable(tn, CommonFlags.CONST, null, tn.tokenPos);
        break;
      }
      case Token.CONTINUE: {
        statement = this.parseContinue(tn);
        break;
      }
      case Token.DO: {
        statement = this.parseDoStatement(tn);
        break;
      }
      case Token.FOR: {
        statement = this.parseForStatement(tn);
        break;
      }
      case Token.IF: {
        statement = this.parseIfStatement(tn);
        break;
      }
      case Token.LET: {
        statement = this.parseVariable(tn, CommonFlags.LET, null, tn.tokenPos);
        break;
      }
      case Token.VAR: {
        statement = this.parseVariable(tn, CommonFlags.NONE, null, tn.tokenPos);
        break;
      }
      case Token.OPENBRACE: {
        statement = this.parseBlockStatement(tn, topLevel);
        break;
      }
      case Token.RETURN: {
        if (topLevel) {
          this.error(
            DiagnosticCode.A_return_statement_can_only_be_used_within_a_function_body,
            tn.range()
          ); // recoverable
        }
        statement = this.parseReturn(tn);
        break;
      }
      case Token.SEMICOLON: {
        return Node.createEmptyStatement(tn.range(tn.tokenPos));
      }
      case Token.SWITCH: {
        statement = this.parseSwitchStatement(tn);
        break;
      }
      case Token.THROW: {
        statement = this.parseThrowStatement(tn);
        break;
      }
      case Token.TRY: {
        statement = this.parseTryStatement(tn);
        break;
      }
      case Token.VOID: {
        statement = this.parseVoidStatement(tn);
        break;
      }
      case Token.WHILE: {
        statement = this.parseWhileStatement(tn);
        break;
      }
      case Token.TYPE: { // also identifier
        if (tn.peek(false, IdentifierHandling.PREFER) == Token.IDENTIFIER) {
          statement = this.parseTypeDeclaration(tn, CommonFlags.NONE, null, tn.tokenPos);
          break;
        }
        // fall-through
      }
      default: {
        tn.reset(state);
        statement = this.parseExpressionStatement(tn);
        break;
      }
    }
    if (!statement) { // has been reported
      tn.reset(state);
      this.skipStatement(tn);
    } else {
      tn.discard(state);
    }
    return statement;
  }

  parseBlockStatement(
    tn: Tokenizer,
    topLevel: bool
  ): BlockStatement | null {

    // at '{': Statement* '}' ';'?

    var startPos = tn.tokenPos;
    var statements = new Array<Statement>();
    while (!tn.skip(Token.CLOSEBRACE)) {
      let state = tn.mark();
      let statement = this.parseStatement(tn, topLevel);
      if (!statement) {
        if (tn.token == Token.ENDOFFILE) return null;
        tn.reset(state);
        this.skipStatement(tn);
      } else {
        tn.discard(state);
        statements.push(statement);
      }
    }
    var ret = Node.createBlockStatement(statements, tn.range(startPos, tn.pos));
    tn.skip(Token.SEMICOLON);
    return ret;
  }

  parseBreak(
    tn: Tokenizer
  ): BreakStatement | null {

    // at 'break': Identifier? ';'?

    var identifier: IdentifierExpression | null = null;
    if (tn.peek(true) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {
      tn.next(IdentifierHandling.PREFER);
      identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
    }
    var ret = Node.createBreakStatement(identifier, tn.range());
    tn.skip(Token.SEMICOLON);
    return ret;
  }

  parseContinue(
    tn: Tokenizer
  ): ContinueStatement | null {

    // at 'continue': Identifier? ';'?

    var identifier: IdentifierExpression | null = null;
    if (tn.peek(true) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {
      tn.next(IdentifierHandling.PREFER);
      identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
    }
    var ret = Node.createContinueStatement(identifier, tn.range());
    tn.skip(Token.SEMICOLON);
    return ret;
  }

  parseDoStatement(
    tn: Tokenizer
  ): DoStatement | null {

    // at 'do': Statement 'while' '(' Expression ')' ';'?

    var startPos = tn.tokenPos;
    var statement = this.parseStatement(tn);
    if (!statement) return null;

    if (tn.skip(Token.WHILE)) {

      if (tn.skip(Token.OPENPAREN)) {
        let condition = this.parseExpression(tn);
        if (!condition) return null;

        if (tn.skip(Token.CLOSEPAREN)) {
          let ret = Node.createDoStatement(statement, condition, tn.range(startPos, tn.pos));
          tn.skip(Token.SEMICOLON);
          return ret;
        } else {
          this.error(
            DiagnosticCode._0_expected,
            tn.range(), ")"
          );
        }
      } else {
        this.error(
          DiagnosticCode._0_expected,
          tn.range(), "("
        );
      }
    } else {
      this.error(
        DiagnosticCode._0_expected,
        tn.range(), "while"
      );
    }
    return null;
  }

  parseExpressionStatement(
    tn: Tokenizer
  ): ExpressionStatement | null {

    // at previous token

    var expr = this.parseExpression(tn);
    if (!expr) return null;

    var ret = Node.createExpressionStatement(expr);
    tn.skip(Token.SEMICOLON);
    return ret;
  }

  parseForStatement(
    tn: Tokenizer
  ): Statement | null {

    // at 'for': '(' Statement? Expression? ';' Expression? ')' Statement

    var startPos = tn.tokenPos;

    if (tn.skip(Token.OPENPAREN)) {
      let initializer: Statement | null = null;

      if (tn.skip(Token.CONST)) {
        initializer = this.parseVariable(tn, CommonFlags.CONST, null, tn.tokenPos, true);
      } else if (tn.skip(Token.LET)) {
        initializer = this.parseVariable(tn, CommonFlags.LET, null, tn.tokenPos, true);
      } else if (tn.skip(Token.VAR)) {
        initializer = this.parseVariable(tn, CommonFlags.NONE, null, tn.tokenPos, true);

      } else if (!tn.skip(Token.SEMICOLON)) {
        initializer = this.parseExpressionStatement(tn);
        if (!initializer) return null;
      }

      if (initializer) {
        if (tn.skip(Token.OF)) {
          // TODO: for (let [key, val] of ...)
          if (initializer.kind == NodeKind.EXPRESSION) {
            if ((<ExpressionStatement>initializer).expression.kind != NodeKind.IDENTIFIER) {
              this.error(
                DiagnosticCode.Identifier_expected,
                initializer.range
              );
              return null;
            }
            return this.parseForOfStatement(tn, startPos, initializer);
          }
          if (initializer.kind == NodeKind.VARIABLE) {
            let declarations = (<VariableStatement>initializer).declarations;
            for (let i = 0, k = declarations.length; i < k; ++i) {
              let declaration = declarations[i];
              let initializer = declaration.initializer;
              if (initializer) {
                this.error(
                  DiagnosticCode.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer,
                  initializer.range
                ); // recoverable
              }
            }
            return this.parseForOfStatement(tn, startPos, initializer);
          }
          this.error(
            DiagnosticCode.Identifier_expected,
            initializer.range
          );
          return null;
        }
        // non-for..of needs type or initializer
        if (initializer.kind == NodeKind.VARIABLE) {
          let declarations = (<VariableStatement>initializer).declarations;
          for (let i = 0, k = declarations.length; i < k; ++i) {
            let declaration = declarations[i];
            if (!declaration.initializer) {
              if (declaration.flags & CommonFlags.CONST) {
                this.error(
                  DiagnosticCode._const_declarations_must_be_initialized,
                  declaration.name.range
                );
              } else if (!declaration.type) {
                this.error(
                  DiagnosticCode.Type_expected,
                  declaration.name.range.atEnd
                );
              }
            }
          }
        }
      }

      if (tn.token == Token.SEMICOLON) {
        let condition: ExpressionStatement | null = null;
        if (!tn.skip(Token.SEMICOLON)) {
          condition = this.parseExpressionStatement(tn);
          if (!condition) return null;
        }

        if (tn.token == Token.SEMICOLON) {
          let incrementor: Expression | null = null;
          if (!tn.skip(Token.CLOSEPAREN)) {
            incrementor = this.parseExpression(tn);
            if (!incrementor) return null;

            if (!tn.skip(Token.CLOSEPAREN)) {
              this.error(
                DiagnosticCode._0_expected,
                tn.range(), ")"
              );
              return null;
            }
          }

          let statement = this.parseStatement(tn);
          if (!statement) return null;

          return Node.createForStatement(
            initializer,
            condition
              ? condition.expression
              : null,
            incrementor,
            statement,
            tn.range(startPos, tn.pos)
          );

        } else {
          this.error(
            DiagnosticCode._0_expected,
            tn.range(), ";"
          );
        }
      } else {
        this.error(
          DiagnosticCode._0_expected,
          tn.range(), ";"
        );
      }
    } else {
      this.error(
        DiagnosticCode._0_expected,
        tn.range(), "("
      );
    }
    return null;
  }

  parseForOfStatement(
    tn: Tokenizer,
    startPos: i32,
    variable: Statement,
  ): ForOfStatement | null {

    // at 'of': Expression ')' Statement

    var iterable = this.parseExpression(tn);
    if (!iterable) return null;

    if (!tn.skip(Token.CLOSEPAREN)) {
      this.error(
        DiagnosticCode._0_expected,
        tn.range(), ")"
      );
      return null;
    }

    var statement = this.parseStatement(tn);
    if (!statement) return null;

    return Node.createForOfStatement(
      variable,
      iterable,
      statement,
      tn.range(startPos, tn.pos)
    );
  }

  parseIfStatement(
    tn: Tokenizer
  ): IfStatement | null {

    // at 'if': '(' Expression ')' Statement ('else' Statement)?

    var startPos = tn.tokenPos;
    if (tn.skip(Token.OPENPAREN)) {
      let condition = this.parseExpression(tn);
      if (!condition) return null;
      if (tn.skip(Token.CLOSEPAREN)) {
        let statement = this.parseStatement(tn);
        if (!statement) return null;
        let elseStatement: Statement | null = null;
        if (tn.skip(Token.ELSE)) {
          elseStatement = this.parseStatement(tn);
          if (!elseStatement) return null;
        }
        return Node.createIfStatement(
          condition,
          statement,
          elseStatement,
          tn.range(startPos, tn.pos)
        );
      } else {
        this.error(
          DiagnosticCode._0_expected,
          tn.range(), ")"
        );
      }
    } else {
      this.error(
        DiagnosticCode._0_expected,
        tn.range(), "("
      );
    }
    return null;
  }

  parseSwitchStatement(
    tn: Tokenizer
  ): SwitchStatement | null {

    // at 'switch': '(' Expression ')' '{' SwitchCase* '}' ';'?

    var startPos = tn.tokenPos;
    if (tn.skip(Token.OPENPAREN)) {
      let condition = this.parseExpression(tn);
      if (!condition) return null;
      if (tn.skip(Token.CLOSEPAREN)) {
        if (tn.skip(Token.OPENBRACE)) {
          let switchCases = new Array<SwitchCase>();
          while (!tn.skip(Token.CLOSEBRACE)) {
            let switchCase = this.parseSwitchCase(tn);
            if (!switchCase) return null;
            switchCases.push(switchCase);
          }
          let ret = Node.createSwitchStatement(condition, switchCases, tn.range(startPos, tn.pos));
          tn.skip(Token.SEMICOLON);
          return ret;
        } else {
          this.error(
            DiagnosticCode._0_expected,
            tn.range(), "{"
          );
        }
      } else {
        this.error(
          DiagnosticCode._0_expected,
          tn.range(), ")"
        );
      }
    } else {
      this.error(
        DiagnosticCode._0_expected,
        tn.range(), "("
      );
    }
    return null;
  }

  parseSwitchCase(
    tn: Tokenizer
  ): SwitchCase | null {

    var startPos = tn.tokenPos;
    var statements: Statement[],
        statement: Statement | null;

    // 'case' Expression ':' Statement*

    if (tn.skip(Token.CASE)) {
      let label = this.parseExpression(tn);
      if (!label) return null;
      if (tn.skip(Token.COLON)) {
        statements = new Array<Statement>();
        while (
          tn.peek() != Token.CASE &&
          tn.nextToken != Token.DEFAULT &&
          tn.nextToken != Token.CLOSEBRACE
        ) {
          statement = this.parseStatement(tn);
          if (!statement) return null;
          statements.push(statement);
        }
        return Node.createSwitchCase(label, statements, tn.range(startPos, tn.pos));
      } else {
        this.error(
          DiagnosticCode._0_expected,
          tn.range(), ":"
        );
      }

      // 'default' ':' Statement*

    } else if (tn.skip(Token.DEFAULT)) {
      if (tn.skip(Token.COLON)) {
        statements = new Array<Statement>();
        while (
          tn.peek() != Token.CASE &&
          tn.nextToken != Token.DEFAULT &&
          tn.nextToken != Token.CLOSEBRACE
        ) {
          statement = this.parseStatement(tn);
          if (!statement) return null;
          statements.push(statement);
        }
        return Node.createSwitchCase(null, statements, tn.range(startPos, tn.pos));
      } else {
        this.error(
          DiagnosticCode._0_expected,
          tn.range(), ":"
        );
      }
    } else {
      this.error(
        DiagnosticCode._case_or_default_expected,
        tn.range()
      );
    }
    return null;
  }

  parseThrowStatement(
    tn: Tokenizer
  ): ThrowStatement | null {

    // at 'throw': Expression ';'?

    var startPos = tn.tokenPos;
    var expression = this.parseExpression(tn);
    if (!expression) return null;
    var ret = Node.createThrowStatement(expression, tn.range(startPos, tn.pos));
    tn.skip(Token.SEMICOLON);
    return ret;
  }

  parseTryStatement(
    tn: Tokenizer
  ): TryStatement | null {

    // at 'try':
    //   '{' Statement* '}'
    //   ('catch' '(' VariableMember ')' '{' Statement* '}')?
    //   ('finally' '{' Statement* '}'? ';'?

    var startPos = tn.tokenPos;
    var stmt: Statement | null;
    if (tn.skip(Token.OPENBRACE)) {
      let statements = new Array<Statement>();
      while (!tn.skip(Token.CLOSEBRACE)) {
        stmt = this.parseStatement(tn);
        if (!stmt) return null;
        statements.push(stmt);
      }
      let catchVariable: IdentifierExpression | null = null;
      let catchStatements: Statement[] | null = null;
      let finallyStatements: Statement[] | null = null;
      if (tn.skip(Token.CATCH)) {
        if (!tn.skip(Token.OPENPAREN)) {
          this.error(
            DiagnosticCode._0_expected,
            tn.range(), "("
          );
          return null;
        }
        if (!tn.skipIdentifier()) {
          this.error(
            DiagnosticCode.Identifier_expected,
            tn.range()
          );
          return null;
        }
        catchVariable = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
        if (!tn.skip(Token.CLOSEPAREN)) {
          this.error(
            DiagnosticCode._0_expected,
            tn.range(), ")"
          );
          return null;
        }
        if (!tn.skip(Token.OPENBRACE)) {
          this.error(
            DiagnosticCode._0_expected,
            tn.range(), "{"
          );
          return null;
        }
        catchStatements = [];
        while (!tn.skip(Token.CLOSEBRACE)) {
          stmt = this.parseStatement(tn);
          if (!stmt) return null;
          catchStatements.push(stmt);
        }
      }
      if (tn.skip(Token.FINALLY)) {
        if (!tn.skip(Token.OPENBRACE)) {
          this.error(
            DiagnosticCode._0_expected,
            tn.range(), "{"
          );
          return null;
        }
        finallyStatements = [];
        while (!tn.skip(Token.CLOSEBRACE)) {
          stmt = this.parseStatement(tn);
          if (!stmt) return null;
          finallyStatements.push(stmt);
        }
      }
      if (!(catchStatements || finallyStatements)) {
        this.error(
          DiagnosticCode._0_expected,
          tn.range(), "catch"
        );
        return null;
      }
      let ret = Node.createTryStatement(
        statements,
        catchVariable,
        catchStatements,
        finallyStatements,
        tn.range(startPos, tn.pos)
      );
      tn.skip(Token.SEMICOLON);
      return ret;
    } else {
      this.error(
        DiagnosticCode._0_expected,
        tn.range(), "{"
      );
    }
    return null;
  }

  parseTypeDeclaration(
    tn: Tokenizer,
    flags: CommonFlags,
    decorators: DecoratorNode[] | null,
    startPos: i32
  ): TypeDeclaration | null {

    // at 'type': Identifier ('<' TypeParameters '>')? '=' Type ';'?

    if (tn.skipIdentifier()) {
      let name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
      let typeParameters: TypeParameterNode[] | null = null;
      if (tn.skip(Token.LESSTHAN)) {
        typeParameters = this.parseTypeParameters(tn);
        if (!typeParameters) return null;
        flags |= CommonFlags.GENERIC;
      }
      if (tn.skip(Token.EQUALS)) {
        let type = this.parseType(tn);
        if (!type) return null;
        let ret = Node.createTypeDeclaration(
          name,
          decorators,
          flags,
          typeParameters,
          type,
          tn.range(startPos, tn.pos)
        );
        tn.skip(Token.SEMICOLON);
        return ret;
      } else {
        this.error(
          DiagnosticCode._0_expected,
          tn.range(), "="
        );
      }
    } else {
      this.error(
        DiagnosticCode.Identifier_expected,
        tn.range()
      );
    }
    return null;
  }

  parseVoidStatement(
    tn: Tokenizer
  ): VoidStatement | null {

    // at 'void': Expression ';'?

    var startPos = tn.tokenPos;
    var expression = this.parseExpression(tn, Precedence.GROUPING);
    if (!expression) return null;
    var ret = Node.createVoidStatement(expression, tn.range(startPos, tn.pos));
    tn.skip(Token.SEMICOLON);
    return ret;
  }

  parseWhileStatement(
    tn: Tokenizer
  ): WhileStatement | null {

    // at 'while': '(' Expression ')' Statement ';'?

    var startPos = tn.tokenPos;
    if (tn.skip(Token.OPENPAREN)) {
      let expression = this.parseExpression(tn);
      if (!expression) return null;
      if (tn.skip(Token.CLOSEPAREN)) {
        let statement = this.parseStatement(tn);
        if (!statement) return null;
        let ret = Node.createWhileStatement(expression, statement, tn.range(startPos, tn.pos));
        tn.skip(Token.SEMICOLON);
        return ret;
      } else {
        this.error(
          DiagnosticCode._0_expected,
          tn.range(), ")"
        );
      }
    } else {
      this.error(
        DiagnosticCode._0_expected,
        tn.range(), "("
      );
    }
    return null;
  }

  // expressions

  parseExpressionStart(
    tn: Tokenizer
  ): Expression | null {
    var token = tn.next(IdentifierHandling.PREFER);
    var startPos = tn.tokenPos;
    switch (token) {

      // TODO: SpreadExpression, YieldExpression
      case Token.DOT_DOT_DOT:
      case Token.YIELD: // fallthrough to unsupported UnaryPrefixExpression

      // UnaryPrefixExpression
      case Token.EXCLAMATION:
      case Token.TILDE:
      case Token.PLUS:
      case Token.MINUS:
      case Token.TYPEOF:
      case Token.VOID:
      case Token.DELETE: {
        let operand = this.parseExpression(tn, Precedence.UNARY_PREFIX);
        if (!operand) return null;
        return Node.createUnaryPrefixExpression(token, operand, tn.range(startPos, tn.pos));
      }
      case Token.PLUS_PLUS:
      case Token.MINUS_MINUS: {
        let operand = this.parseExpression(tn, Precedence.UNARY_PREFIX);
        if (!operand) return null;
        switch (operand.kind) {
          case NodeKind.IDENTIFIER:
          case NodeKind.ELEMENTACCESS:
          case NodeKind.PROPERTYACCESS: break;
          default: {
            this.error(
              DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,
              operand.range
            );
          }
        }
        return Node.createUnaryPrefixExpression(token, operand, tn.range(startPos, tn.pos));
      }

      // NewExpression
      case Token.NEW: {
        if (!tn.skipIdentifier()) {
          this.error(
            DiagnosticCode.Identifier_expected,
            tn.range()
          );
          return null;
        }
        let typeName = this.parseTypeName(tn);
        if (!typeName) return null;
        let typeArguments: TypeNode[] | null = null;
        let arguments_: Expression[] | null = null;
        if (
          tn.skip(Token.OPENPAREN) ||
          (typeArguments = this.tryParseTypeArgumentsBeforeArguments(tn)) !== null
        ) {
          arguments_ = this.parseArguments(tn);
          if (!arguments_) return null;
        } else {
          arguments_ = []; // new Type;
        }
        return Node.createNewExpression(
          typeName,
          typeArguments,
          arguments_,
          tn.range(startPos, tn.pos)
        );
      }

      // Special IdentifierExpression
      case Token.NULL: return Node.createNullExpression(tn.range());
      case Token.TRUE: return Node.createTrueExpression(tn.range());
      case Token.FALSE: return Node.createFalseExpression(tn.range());
      case Token.THIS: return Node.createThisExpression(tn.range());
      case Token.CONSTRUCTOR: return Node.createConstructorExpression(tn.range());

      // ParenthesizedExpression or FunctionExpression
      case Token.OPENPAREN: {

        // determine whether this is a function expression
        if (tn.skip(Token.CLOSEPAREN)) { // must be a function expression (fast route)
          return this.parseFunctionExpressionCommon(
            tn,
            Node.createEmptyIdentifierExpression(tn.range(startPos)),
            [],
            null,
            ArrowKind.ARROW_PARENTHESIZED
          );
        }
        let state = tn.mark();
        let again = true;
        do {
          switch (tn.next(IdentifierHandling.PREFER)) {

            // function expression
            case Token.DOT_DOT_DOT: {
              tn.reset(state);
              return this.parseFunctionExpression(tn);
            }
            // can be both
            case Token.IDENTIFIER: {
              tn.readIdentifier();
              switch (tn.next()) {

                // if we got here, check for arrow
                case Token.CLOSEPAREN: {
                  if (
                    !tn.skip(Token.COLON) &&
                    !tn.skip(Token.EQUALS_GREATERTHAN)
                  ) {
                    again = false;
                    break;
                  }
                  // fall-through
                }
                // function expression
                case Token.COLON: {    // type annotation
                  tn.reset(state);
                  return this.parseFunctionExpression(tn);
                }
                // optional parameter or parenthesized
                case Token.QUESTION: {
                  if (
                    tn.skip(Token.COLON) ||   // optional parameter with type
                    tn.skip(Token.COMMA) ||   // optional parameter without type
                    tn.skip(Token.CLOSEPAREN) // last optional parameter without type
                  ) {
                    tn.reset(state);
                    return this.parseFunctionExpression(tn);
                  }
                  again = false; // parenthesized
                  break;
                }
                case Token.COMMA: {
                  break; // continue
                }
                // parenthesized expression
                // case Token.EQUALS:  // missing type annotation for simplicity
                default: {
                  again = false;
                  break;
                }
              }
              break;
            }
            // parenthesized expression
            default: {
              again = false;
              break;
            }
          }
        } while (again);
        tn.reset(state);

        // parse parenthesized
        let inner = this.parseExpression(tn);
        if (!inner) return null;
        if (!tn.skip(Token.CLOSEPAREN)) {
          this.error(
            DiagnosticCode._0_expected,
            tn.range(), ")"
          );
          return null;
        }
        inner = Node.createParenthesizedExpression(inner, tn.range(startPos, tn.pos));
        return this.maybeParseCallExpression(tn, inner);
      }
      // ArrayLiteralExpression
      case Token.OPENBRACKET: {
        let elementExpressions = new Array<Expression>();
        while (!tn.skip(Token.CLOSEBRACKET)) {
          let expr: Expression | null;
          if (tn.peek() == Token.COMMA) {
            expr = Node.createOmittedExpression(tn.range(tn.pos));
          } else {
            expr = this.parseExpression(tn, Precedence.COMMA + 1);
            if (!expr) return null;
          }
          elementExpressions.push(expr);
          if (!tn.skip(Token.COMMA)) {
            if (tn.skip(Token.CLOSEBRACKET)) {
              break;
            } else {
              this.error(
                DiagnosticCode._0_expected,
                tn.range(), "]"
              );
              return null;
            }
          }
        }
        return Node.createArrayLiteralExpression(elementExpressions, tn.range(startPos, tn.pos));
      }
      // ObjectLiteralExpression
      case Token.OPENBRACE: {
        let startPos = tn.tokenPos;
        let names = new Array<IdentifierExpression>();
        let values = new Array<Expression>();
        let name: IdentifierExpression;
        while (!tn.skip(Token.CLOSEBRACE)) {
          if (!tn.skipIdentifier()) {
            if (!tn.skip(Token.STRINGLITERAL)) {
              this.error(
                DiagnosticCode.Identifier_expected,
                tn.range(),
              );
              return null;
            }
            name = Node.createIdentifierExpression(tn.readString(), tn.range());
            name.isQuoted = true;
          } else {
            name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
          }
          names.push(name);
          if (tn.skip(Token.COLON)) {
            let value = this.parseExpression(tn, Precedence.COMMA + 1);
            if (!value) return null;
            values.push(value);
          } else if (!name.isQuoted) {
            values.push(name);
          } else {
            this.error(
              DiagnosticCode._0_expected,
              tn.range(), ":"
            );
            return null;
          }
          if (!tn.skip(Token.COMMA)) {
            if (tn.skip(Token.CLOSEBRACE)) {
              break;
            } else {
              this.error(
                DiagnosticCode._0_expected,
                tn.range(), "}"
              );
              return null;
            }
          }
        }
        return Node.createObjectLiteralExpression(names, values, tn.range(startPos, tn.pos));
      }
      // AssertionExpression (unary prefix)
      case Token.LESSTHAN: {
        let toType = this.parseType(tn);
        if (!toType) return null;
        if (!tn.skip(Token.GREATERTHAN)) {
          this.error(
            DiagnosticCode._0_expected,
            tn.range(), ">"
          );
          return null;
        }
        let expr = this.parseExpression(tn, Precedence.CALL);
        if (!expr) return null;
        return Node.createAssertionExpression(
          AssertionKind.PREFIX,
          expr,
          toType,
          tn.range(startPos, tn.pos)
        );
      }
      case Token.IDENTIFIER: {
        let identifierText = tn.readIdentifier();
        if (identifierText == "null") return Node.createNullExpression(tn.range()); // special
        let identifier = Node.createIdentifierExpression(identifierText, tn.range(startPos, tn.pos));
        if (tn.skip(Token.TEMPLATELITERAL)) {
          return this.parseTemplateLiteral(tn, identifier);
        }
        if (tn.peek(true) == Token.EQUALS_GREATERTHAN && !tn.nextTokenOnNewLine) {
          return this.parseFunctionExpressionCommon(
            tn,
            Node.createEmptyIdentifierExpression(tn.range(startPos)),
            [
              Node.createParameter(
                ParameterKind.DEFAULT,
                identifier,
                Node.createOmittedType(identifier.range.atEnd),
                null,
                identifier.range
              )
            ],
            null,
            ArrowKind.ARROW_SINGLE,
            startPos
          );
        }
        return this.maybeParseCallExpression(tn, identifier, true);
      }
      case Token.SUPER: {
        if (tn.peek() != Token.DOT && tn.nextToken != Token.OPENPAREN) {
          this.error(
            DiagnosticCode._super_must_be_followed_by_an_argument_list_or_member_access,
            tn.range()
          );
        }
        let expr = Node.createSuperExpression(tn.range(startPos, tn.pos));
        return this.maybeParseCallExpression(tn, expr);
      }
      case Token.STRINGLITERAL: {
        return Node.createStringLiteralExpression(tn.readString(), tn.range(startPos, tn.pos));
      }
      case Token.TEMPLATELITERAL: {
        return this.parseTemplateLiteral(tn);
      }
      case Token.INTEGERLITERAL: {
        let value = tn.readInteger();
        tn.checkForIdentifierStartAfterNumericLiteral();
        return Node.createIntegerLiteralExpression(value, tn.range(startPos, tn.pos));
      }
      case Token.FLOATLITERAL: {
        let value = tn.readFloat();
        tn.checkForIdentifierStartAfterNumericLiteral();
        return Node.createFloatLiteralExpression(value, tn.range(startPos, tn.pos));
      }
      // RegexpLiteralExpression
      // note that this also continues on invalid ones so the surrounding AST remains intact
      case Token.SLASH: {
        let regexpPattern = tn.readRegexpPattern(); // also reports
        if (!tn.skip(Token.SLASH)) {
          this.error(
            DiagnosticCode._0_expected,
            tn.range(), "/"
          );
          return null;
        }
        return Node.createRegexpLiteralExpression(
          regexpPattern,
          tn.readRegexpFlags(), // also reports
          tn.range(startPos, tn.pos)
        );
      }
      case Token.FUNCTION: {
        let expr = this.parseFunctionExpression(tn);
        if (!expr) return null;
        return this.maybeParseCallExpression(tn, expr);
      }
      case Token.CLASS: {
        return this.parseClassExpression(tn);
      }
      default: {
        if (token == Token.ENDOFFILE) {
          this.error(
            DiagnosticCode.Unexpected_end_of_text,
            tn.range(startPos)
          );
        } else {
          this.error(
            DiagnosticCode.Expression_expected,
            tn.range()
          );
        }
        return null;
      }
    }
  }

  tryParseTypeArgumentsBeforeArguments(
    tn: Tokenizer
  ): TypeNode[] | null {

    // at '<': Type (',' Type)* '>' '('

    var state = tn.mark();
    if (!tn.skip(Token.LESSTHAN)) return null;
    var start = tn.tokenPos;
    var typeArguments: TypeNode[] | null = null;
    do {
      if (tn.peek() === Token.GREATERTHAN) {
        break;
      }
      let type = this.parseType(tn, true, true);
      if (!type) {
        tn.reset(state);
        return null;
      }
      if (!typeArguments) typeArguments = [ type ];
      else typeArguments.push(type);
    } while (tn.skip(Token.COMMA));
    if (tn.skip(Token.GREATERTHAN)) {
      let end = tn.pos;
      if (tn.skip(Token.OPENPAREN)) {
        if (!typeArguments) {
          this.error(
            DiagnosticCode.Type_argument_list_cannot_be_empty,
            tn.range(start, end)
          );
        }
        return typeArguments;
      }
    }
    tn.reset(state);
    return null;
  }

  parseArguments(
    tn: Tokenizer
  ): Expression[] | null {

    // at '(': (Expression (',' Expression)*)? ')'

    var args = new Array<Expression>();
    while (!tn.skip(Token.CLOSEPAREN)) {
      let expr = this.parseExpression(tn, Precedence.COMMA + 1);
      if (!expr) return null;
      args.push(expr);
      if (!tn.skip(Token.COMMA)) {
        if (tn.skip(Token.CLOSEPAREN)) {
          break;
        } else {
          this.error(
            DiagnosticCode._0_expected,
            tn.range(), ")"
          );
          return null;
        }
      }
    }
    return args;
  }

  parseExpression(
    tn: Tokenizer,
    precedence: Precedence = Precedence.COMMA
  ): Expression | null {
    assert(precedence != Precedence.NONE);
    var expr = this.parseExpressionStart(tn);
    if (!expr) return null;
    var startPos = expr.range.start;

    // precedence climbing
    // see: http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm#climbing
    var nextPrecedence: Precedence;
    while (
      (nextPrecedence = determinePrecedence(tn.peek())) >= precedence
    ) {
      let token = tn.next();
      switch (token) {

        // AssertionExpression
        case Token.AS: {
          if (tn.skip(Token.CONST)) {
            expr = Node.createAssertionExpression(
              AssertionKind.CONST,
              expr,
              null,
              tn.range(startPos, tn.pos)
            );
          } else {
            let toType = this.parseType(tn); // reports
            if (!toType) return null;
            expr = Node.createAssertionExpression(
              AssertionKind.AS,
              expr,
              toType,
              tn.range(startPos, tn.pos)
            );
          }
          break;
        }
        case Token.EXCLAMATION: {
          expr = Node.createAssertionExpression(
            AssertionKind.NONNULL,
            expr,
            null,
            tn.range(startPos, tn.pos)
          );
          expr = this.maybeParseCallExpression(tn, expr);
          break;
        }
        // InstanceOfExpression
        case Token.INSTANCEOF: {
          let isType = this.parseType(tn); // reports
          if (!isType) return null;
          expr = Node.createInstanceOfExpression(
            expr,
            isType,
            tn.range(startPos, tn.pos)
          );
          break;
        }
        // ElementAccessExpression
        case Token.OPENBRACKET: {
          let next = this.parseExpression(tn); // reports
          if (!next) return null;
          if (!tn.skip(Token.CLOSEBRACKET)) {
            this.error(
              DiagnosticCode._0_expected,
              tn.range(), "]"
            );
            return null;
          }
          expr = Node.createElementAccessExpression(
            expr,
            next,
            tn.range(startPos, tn.pos)
          );
          expr = this.maybeParseCallExpression(tn, expr);
          break;
        }
        // UnaryPostfixExpression
        case Token.PLUS_PLUS:
        case Token.MINUS_MINUS: {
          if (
            expr.kind != NodeKind.IDENTIFIER &&
            expr.kind != NodeKind.ELEMENTACCESS &&
            expr.kind != NodeKind.PROPERTYACCESS
          ) {
            this.error(
              DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,
              expr.range
            );
          }
          expr = Node.createUnaryPostfixExpression(
            token,
            expr,
            tn.range(startPos, tn.pos)
          );
          break;
        }
        // TernaryExpression
        case Token.QUESTION: {
          let ifThen = this.parseExpression(tn);
          if (!ifThen) return null;
          if (!tn.skip(Token.COLON)) {
            this.error(
              DiagnosticCode._0_expected,
              tn.range(), ":"
            );
            return null;
          }
          let ifElse = this.parseExpression(tn, precedence > Precedence.COMMA
            ? Precedence.COMMA + 1
            : Precedence.COMMA
          );
          if (!ifElse) return null;
          expr = Node.createTernaryExpression(
            expr,
            ifThen,
            ifElse,
            tn.range(startPos, tn.pos)
          );
          break;
        }
        // CommaExpression
        case Token.COMMA: {
          let commaExprs: Expression[] = [ expr ];
          do {
            expr = this.parseExpression(tn, Precedence.COMMA + 1);
            if (!expr) return null;
            commaExprs.push(expr);
          } while (tn.skip(Token.COMMA));
          expr = Node.createCommaExpression(commaExprs, tn.range(startPos, tn.pos));
          break;
        }
        // PropertyAccessExpression
        case Token.DOT: {
          if (tn.skipIdentifier(IdentifierHandling.ALWAYS)) { // expr '.' Identifier
            let next = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
            expr = Node.createPropertyAccessExpression(
              expr,
              next,
              tn.range(startPos, tn.pos)
            );
          } else {
            let next = this.parseExpression(tn, nextPrecedence + 1);
            if (!next) return null;
            if (next.kind == NodeKind.CALL) { // expr '.' CallExpression
              expr = this.joinPropertyCall(tn, startPos, expr, <CallExpression>next);
              if (!expr) return null;
            } else {
              this.error(
                DiagnosticCode.Identifier_expected,
                next.range
              );
              return null;
            }
          }
          if (tn.skip(Token.TEMPLATELITERAL)) {
            expr = this.parseTemplateLiteral(tn, expr);
            if (!expr) return null;
          } else {
            expr = this.maybeParseCallExpression(tn, expr, true);
          }
          break;
        }
        // BinaryExpression (right associative)
        case Token.EQUALS:
        case Token.PLUS_EQUALS:
        case Token.MINUS_EQUALS:
        case Token.ASTERISK_ASTERISK_EQUALS:
        case Token.ASTERISK_EQUALS:
        case Token.SLASH_EQUALS:
        case Token.PERCENT_EQUALS:
        case Token.LESSTHAN_LESSTHAN_EQUALS:
        case Token.GREATERTHAN_GREATERTHAN_EQUALS:
        case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:
        case Token.AMPERSAND_EQUALS:
        case Token.CARET_EQUALS:
        case Token.BAR_EQUALS:
        case Token.ASTERISK_ASTERISK: {
          let next = this.parseExpression(tn, nextPrecedence);
          if (!next) return null;
          expr = Node.createBinaryExpression(token, expr, next, tn.range(startPos, tn.pos));
          break;
        }
        // BinaryExpression
        case Token.LESSTHAN:
        case Token.GREATERTHAN:
        case Token.LESSTHAN_EQUALS:
        case Token.GREATERTHAN_EQUALS:
        case Token.EQUALS_EQUALS:
        case Token.EQUALS_EQUALS_EQUALS:
        case Token.EXCLAMATION_EQUALS_EQUALS:
        case Token.EXCLAMATION_EQUALS:
        case Token.PLUS:
        case Token.MINUS:
        case Token.ASTERISK:
        case Token.SLASH:
        case Token.PERCENT:
        case Token.LESSTHAN_LESSTHAN:
        case Token.GREATERTHAN_GREATERTHAN:
        case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN:
        case Token.AMPERSAND:
        case Token.BAR:
        case Token.CARET:
        case Token.AMPERSAND_AMPERSAND:
        case Token.BAR_BAR: {
          let next = this.parseExpression(tn, nextPrecedence + 1);
          if (!next) return null;
          expr = Node.createBinaryExpression(token, expr, next, tn.range(startPos, tn.pos));
          break;
        }
        default: assert(false); // filtered by determinePrecedence
      }
    }
    return expr;
  }

  private parseTemplateLiteral(tn: Tokenizer, tag: Expression | null = null): Expression | null {
    // at '`': ... '`'
    var startPos = tag ? tag.range.start : tn.tokenPos;
    var parts = new Array<string>();
    var rawParts = new Array<string>();
    var exprs = new Array<Expression>();
    parts.push(tn.readString(0, tag != null));
    rawParts.push(tn.source.text.substring(tn.readStringStart, tn.readStringEnd));
    while (tn.readingTemplateString) {
      let expr = this.parseExpression(tn);
      if (!expr) return null;
      exprs.push(expr);
      if (!tn.skip(Token.CLOSEBRACE)) {
        this.error(
          DiagnosticCode._0_expected,
          tn.range(), "}"
        );
        return null;
      }
      parts.push(tn.readString(CharCode.BACKTICK, tag != null));
      rawParts.push(tn.source.text.substring(tn.readStringStart, tn.readStringEnd));
    }
    return Node.createTemplateLiteralExpression(tag, parts, rawParts, exprs, tn.range(startPos, tn.pos));
  }

  private joinPropertyCall(
    tn: Tokenizer,
    startPos: i32,
    expr: Expression,
    call: CallExpression
  ): Expression | null {
    var callee = call.expression;
    switch (callee.kind) {
      case NodeKind.IDENTIFIER: { // join property access and use as call target
        call.expression = Node.createPropertyAccessExpression(
          expr,
          <IdentifierExpression>callee,
          tn.range(startPos, tn.pos)
        );
        break;
      }
      case NodeKind.CALL: { // join call target und wrap the original call around it
        let inner = this.joinPropertyCall(tn, startPos, expr, <CallExpression>callee);
        if (!inner) return null;
        call.expression = inner;
        call.range = tn.range(startPos, tn.pos);
        break;
      }
      default: {
        this.error(
          DiagnosticCode.Identifier_expected,
          call.range
        );
        return null;
      }
    }
    return call;
  }

  private maybeParseCallExpression(
    tn: Tokenizer,
    expr: Expression,
    potentiallyGeneric: bool = false
  ): Expression {
    var typeArguments: TypeNode[] | null = null;
    while (
      tn.skip(Token.OPENPAREN) ||
      potentiallyGeneric &&
      (typeArguments = this.tryParseTypeArgumentsBeforeArguments(tn)) !== null
    ) {
      let args = this.parseArguments(tn);
      if (!args) break;
      expr = Node.createCallExpression( // is again callable
        expr,
        typeArguments,
        args,
        tn.range(expr.range.start, tn.pos)
      );
      potentiallyGeneric = false;
    }
    return expr;
  }

  /** Skips over a statement on errors in an attempt to reduce unnecessary diagnostic noise. */
  skipStatement(tn: Tokenizer): void {
    tn.peek(true);
    if (tn.nextTokenOnNewLine) tn.next(); // if reset() to the previous line
    do {
      let nextToken = tn.peek(true);
      if (
        nextToken == Token.ENDOFFILE ||   // next step should handle this
        nextToken == Token.SEMICOLON      // end of the statement for sure
      ) {
        tn.next();
        break;
      }
      if (tn.nextTokenOnNewLine) break;   // end of the statement maybe
      switch (tn.next()) {
        case Token.IDENTIFIER: {
          tn.readIdentifier();
          break;
        }
        case Token.STRINGLITERAL:
        case Token.TEMPLATELITERAL: {
          tn.readString();
          break;
        }
        case Token.INTEGERLITERAL: {
          tn.readInteger();
          tn.checkForIdentifierStartAfterNumericLiteral();
          break;
        }
        case Token.FLOATLITERAL: {
          tn.readFloat();
          tn.checkForIdentifierStartAfterNumericLiteral();
          break;
        }
        case Token.OPENBRACE: {
          this.skipBlock(tn);
          break;
        }
      }
    } while (true);
    tn.readingTemplateString = false;
  }

  /** Skips over a block on errors in an attempt to reduce unnecessary diagnostic noise. */
  skipBlock(tn: Tokenizer): void {
    // at '{': ... '}'
    var depth = 1;
    var again = true;
    do {
      switch (tn.next()) {
        case Token.ENDOFFILE: {
          this.error(
            DiagnosticCode._0_expected,
            tn.range(), "}"
          );
          again = false;
          break;
        }
        case Token.OPENBRACE: {
          ++depth;
          break;
        }
        case Token.CLOSEBRACE: {
          --depth;
          if (!depth) again = false;
          break;
        }
        case Token.IDENTIFIER: {
          tn.readIdentifier();
          break;
        }
        case Token.STRINGLITERAL: {
          tn.readString();
          break;
        }
        case Token.INTEGERLITERAL: {
          tn.readInteger();
          tn.checkForIdentifierStartAfterNumericLiteral();
          break;
        }
        case Token.FLOATLITERAL: {
          tn.readFloat();
          tn.checkForIdentifierStartAfterNumericLiteral();
          break;
        }
      }
    } while (again);
  }
}

/** Operator precedence from least to largest. */
export const enum Precedence {
  NONE,
  COMMA,
  SPREAD,
  YIELD,
  ASSIGNMENT,
  CONDITIONAL,
  LOGICAL_OR,
  LOGICAL_AND,
  BITWISE_OR,
  BITWISE_XOR,
  BITWISE_AND,
  EQUALITY,
  RELATIONAL,
  SHIFT,
  ADDITIVE,
  MULTIPLICATIVE,
  EXPONENTIATED,
  UNARY_PREFIX,
  UNARY_POSTFIX,
  CALL,
  MEMBERACCESS,
  GROUPING
}

/** Determines the precende of a non-starting token. */
function determinePrecedence(kind: Token): Precedence {
  switch (kind) {
    case Token.COMMA: return Precedence.COMMA;
    case Token.EQUALS:
    case Token.PLUS_EQUALS:
    case Token.MINUS_EQUALS:
    case Token.ASTERISK_ASTERISK_EQUALS:
    case Token.ASTERISK_EQUALS:
    case Token.SLASH_EQUALS:
    case Token.PERCENT_EQUALS:
    case Token.LESSTHAN_LESSTHAN_EQUALS:
    case Token.GREATERTHAN_GREATERTHAN_EQUALS:
    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:
    case Token.AMPERSAND_EQUALS:
    case Token.CARET_EQUALS:
    case Token.BAR_EQUALS: return Precedence.ASSIGNMENT;
    case Token.QUESTION: return Precedence.CONDITIONAL;
    case Token.BAR_BAR: return Precedence.LOGICAL_OR;
    case Token.AMPERSAND_AMPERSAND: return Precedence.LOGICAL_AND;
    case Token.BAR: return Precedence.BITWISE_OR;
    case Token.CARET: return Precedence.BITWISE_XOR;
    case Token.AMPERSAND: return Precedence.BITWISE_AND;
    case Token.EQUALS_EQUALS:
    case Token.EXCLAMATION_EQUALS:
    case Token.EQUALS_EQUALS_EQUALS:
    case Token.EXCLAMATION_EQUALS_EQUALS: return Precedence.EQUALITY;
    case Token.AS:
    case Token.IN:
    case Token.INSTANCEOF:
    case Token.LESSTHAN:
    case Token.GREATERTHAN:
    case Token.LESSTHAN_EQUALS:
    case Token.GREATERTHAN_EQUALS: return Precedence.RELATIONAL;
    case Token.LESSTHAN_LESSTHAN:
    case Token.GREATERTHAN_GREATERTHAN:
    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: return Precedence.SHIFT;
    case Token.PLUS:
    case Token.MINUS: return Precedence.ADDITIVE;
    case Token.ASTERISK:
    case Token.SLASH:
    case Token.PERCENT: return Precedence.MULTIPLICATIVE;
    case Token.ASTERISK_ASTERISK: return Precedence.EXPONENTIATED;
    case Token.PLUS_PLUS:
    case Token.MINUS_MINUS: return Precedence.UNARY_POSTFIX;
    case Token.DOT:
    case Token.NEW:
    case Token.OPENBRACKET:
    case Token.EXCLAMATION: return Precedence.MEMBERACCESS;
  }
  return Precedence.NONE;
}

'''
'''--- src/passes/findusedlocals.ts ---
/**
 * @fileoverview Utility to find all locals used in an expression.
 * @license Apache-2.0
 */

import {
  Visitor
} from "./pass";

import {
  ExpressionRef
} from "../module";

import {
  _BinaryenLocalGetGetIndex,
  _BinaryenLocalSetGetIndex
} from "../glue/binaryen";

class FindUsedLocalsVisitor extends Visitor {
  used: Set<i32>;

  constructor(used: Set<i32> = new Set()) {
    super();
    this.used = used;
  }
  
  /** @override */
  visitLocalGet(localGet: ExpressionRef): void {
    this.used.add(<i32>_BinaryenLocalGetGetIndex(localGet));
  }

  /** @override */
  visitLocalSet(localSet: ExpressionRef): void {
    this.used.add(<i32>_BinaryenLocalSetGetIndex(localSet));
  }
}

var singleton: FindUsedLocalsVisitor | null = null;

/** Finds the indexes of all locals used in the specified expression. */
export function findUsedLocals(
  expr: ExpressionRef,
  used: Set<i32> = new Set()
): Set<i32> {
  var visitor = singleton;
  if (!visitor) singleton = visitor = new FindUsedLocalsVisitor(used);
  else visitor.used = used;
  visitor.visit(expr);
  return used;
}

'''
'''--- src/passes/ministack.ts ---
/**
 * @fileoverview A potential minimalistic shadow stack. Currently not used.
 * 
 * Instruments a module's exports to track when the execution stack is fully
 * unwound, and injects a call to `__autocollect` to be invoked when it is.
 * Accounts for the currently in-flight managed return value from Wasm to the
 * host by pushing it to a mini stack, essentially a stack of only one value,
 * while `__autocollect` is executing.
 * 
 * @license Apache-2.0
 */

import {
  Pass
} from "./pass";

import {
  BinaryOp,
  expandType,
  ExportRef,
  ExpressionRef,
  ExternalKind,
  Index,
  Module,
  TypeRef,
  UnaryOp
} from "../module";

import {
  _BinaryenAddFunctionExport,
  _BinaryenExportGetKind,
  _BinaryenExportGetName,
  _BinaryenExportGetValue,
  _BinaryenFunctionGetName,
  _BinaryenFunctionGetNumLocals,
  _BinaryenFunctionGetParams,
  _BinaryenFunctionGetResults,
  _BinaryenGetExportByIndex,
  _BinaryenGetFunction,
  _BinaryenGetNumExports,
  _BinaryenRemoveExport
} from "../glue/binaryen";

import {
  Program
} from "../program";

const MINISTACK = "~lib/rt/__ministack";
const STACK_DEPTH = "~stack_depth";
const AUTOCOLLECT = "__autocollect";

/** Instruments a module with a minimalistic shadow stack for precise GC. */
export class MiniStack extends Pass {
  /** Compiler reference. */
  program: Program;
  /** Exported functions returning managed values. */
  managedReturns: Set<string> = new Set();

  constructor(module: Module, program: Program) {
    super(module);
    this.program = program;
  }

  /** Notes the presence of an exported function with a managed return value. */
  noteManagedReturn(exportName: string): void {
    this.managedReturns.add(exportName);
  }

  /** Instruments a function export to also maintain stack depth. */
  instrumentFunctionExport(ref: ExportRef): void {
    assert(_BinaryenExportGetKind(ref) == ExternalKind.Function);
    var module = this.module;
    var internalNameRef = _BinaryenExportGetValue(ref);
    var externalNameRef = _BinaryenExportGetName(ref);
    var functionRef = _BinaryenGetFunction(module.ref, internalNameRef);
    var originalName = module.readStringCached(_BinaryenFunctionGetName(functionRef))!;

    var wrapperName = "export:" + originalName;
    if (!module.hasFunction(wrapperName)) {
      var params = _BinaryenFunctionGetParams(functionRef);
      var results = _BinaryenFunctionGetResults(functionRef);
      let numLocals = _BinaryenFunctionGetNumLocals(functionRef);
      var vars = new Array<TypeRef>();

      // Prepare a call to the original function
      var paramTypes = expandType(params);
      var numParams = paramTypes.length;
      var operands = new Array<ExpressionRef>(numParams);
      for (let i = 0; i < numParams; ++i) {
        operands[i] = module.local_get(i, paramTypes[i]);
      }
      var call = module.call(originalName, operands, results);

      // Create a wrapper function also maintaining stack depth
      var stmts = new Array<ExpressionRef>();
      if (numLocals) {
        stmts.push(
          module.global_set(STACK_DEPTH,
            module.binary(BinaryOp.AddI32,
              module.global_get(STACK_DEPTH, TypeRef.I32),
              module.i32(1) // only need to know > 0
            )
          )
        );
      }
      if (results == TypeRef.None) {
        stmts.push(
          call
        );
      } else {
        vars.push(results);
        stmts.push(
          module.local_set(numParams, call, false) // no shadow stack here
        );
      }
      if (numLocals) {
        stmts.push(
          module.global_set(STACK_DEPTH,
            module.binary(BinaryOp.SubI32,
              module.global_get(STACK_DEPTH, TypeRef.I32),
              module.i32(1) // only need to know > 0
            )
          )
        );
      }
      let exportName = module.readStringCached(externalNameRef)!;
      stmts.push(
        module.global_set(MINISTACK,
          this.managedReturns.has(exportName)
            ? module.local_get(numParams, results)
            : module.i32(0)
        )
      );
      stmts.push(
        module.if(
          module.unary(UnaryOp.EqzI32,
            module.global_get(STACK_DEPTH, TypeRef.I32)
          ),
          module.call(AUTOCOLLECT, null, TypeRef.None)
        )
      );
      if (results != TypeRef.None) {
        stmts.push(
          module.local_get(numParams, results)
        );
      }
      module.addFunction(wrapperName, params, results, vars,
        module.block(null, stmts, results)
      );
    }

    // Replace the original export with the wrapped one
    _BinaryenRemoveExport(module.ref, externalNameRef);
    _BinaryenAddFunctionExport(module.ref, module.allocStringCached(wrapperName), externalNameRef);
  }

  /** Runs the pass. Returns `true` if the mini stack has been added. */
  run(): bool {
    var module = this.module;
    var moduleRef = module.ref;
    var numExports = _BinaryenGetNumExports(moduleRef);
    if (numExports) {
      let functionExportRefs = new Array<ExportRef>();
      // We are going to modify the list of exports, so do this in two steps
      for (let i: Index = 0; i < numExports; ++i) {
        let exportRef = _BinaryenGetExportByIndex(moduleRef, i);
        if (_BinaryenExportGetKind(exportRef) == ExternalKind.Function) {
          functionExportRefs.push(exportRef);
        }
      }
      let numFunctionExports = functionExportRefs.length;
      if (numFunctionExports) {
        for (let i = 0; i < numFunctionExports; ++i) {
          this.instrumentFunctionExport(functionExportRefs[i]);
        }
        module.addGlobal(STACK_DEPTH, TypeRef.I32, true, module.i32(0));
        return true;
      }
    }
    return false;
  }
}

'''
'''--- src/passes/pass.ts ---
/**
 * @fileoverview Infrastructure for custom Binaryen passes.
 * @license Apache-2.0
 */

import {
  Module,
  ExpressionId,
  ExpressionRef,
  FunctionRef,
  GlobalRef,
  Index,
  StringRef
} from "../module";

import {
  _BinaryenExpressionGetId,
  _BinaryenBlockGetNumChildren,
  _BinaryenBlockGetChildAt,
  _BinaryenIfGetCondition,
  _BinaryenIfGetIfTrue,
  _BinaryenIfGetIfFalse,
  _BinaryenLoopGetBody,
  _BinaryenBreakGetCondition,
  _BinaryenBreakGetValue,
  _BinaryenGetNumFunctions,
  _BinaryenGetFunctionByIndex,
  _BinaryenGetNumGlobals,
  _BinaryenGetGlobalByIndex,
  _BinaryenFunctionGetBody,
  _BinaryenSwitchGetCondition,
  _BinaryenSwitchGetValue,
  _BinaryenCallGetNumOperands,
  _BinaryenCallGetOperandAt,
  _BinaryenCallIndirectGetNumOperands,
  _BinaryenCallIndirectGetOperandAt,
  _BinaryenLocalSetGetValue,
  _BinaryenGlobalSetGetValue,
  _BinaryenGlobalGetInitExpr,
  _BinaryenLoadGetPtr,
  _BinaryenStoreGetPtr,
  _BinaryenStoreGetValue,
  _BinaryenUnaryGetValue,
  _BinaryenBinaryGetLeft,
  _BinaryenBinaryGetRight,
  _BinaryenSelectGetIfTrue,
  _BinaryenSelectGetIfFalse,
  _BinaryenSelectGetCondition,
  _BinaryenDropGetValue,
  _BinaryenBlockSetChildAt,
  _BinaryenCallIndirectGetTarget,
  _BinaryenReturnGetValue,
  _BinaryenMemoryGrowGetDelta,
  _BinaryenAtomicRMWGetPtr,
  _BinaryenAtomicRMWGetValue,
  _BinaryenAtomicCmpxchgGetPtr,
  _BinaryenAtomicCmpxchgGetExpected,
  _BinaryenAtomicCmpxchgGetReplacement,
  _BinaryenAtomicWaitGetPtr,
  _BinaryenAtomicWaitGetExpected,
  _BinaryenAtomicWaitGetTimeout,
  _BinaryenAtomicNotifyGetPtr,
  _BinaryenSIMDExtractGetVec,
  _BinaryenSIMDReplaceGetVec,
  _BinaryenSIMDReplaceGetValue,
  _BinaryenSIMDShuffleGetLeft,
  _BinaryenSIMDShuffleGetRight,
  _BinaryenSIMDTernaryGetA,
  _BinaryenSIMDTernaryGetB,
  _BinaryenSIMDTernaryGetC,
  _BinaryenSIMDShiftGetVec,
  _BinaryenSIMDShiftGetShift,
  _BinaryenSIMDLoadGetPtr,
  _BinaryenMemoryInitGetDest,
  _BinaryenMemoryInitGetOffset,
  _BinaryenMemoryInitGetSize,
  _BinaryenMemoryCopyGetDest,
  _BinaryenMemoryCopyGetSource,
  _BinaryenMemoryCopyGetSize,
  _BinaryenMemoryFillGetDest,
  _BinaryenMemoryFillGetValue,
  _BinaryenMemoryFillGetSize,
  _BinaryenRefIsGetValue,
  _BinaryenTryGetBody,
  _BinaryenTryGetNumCatchBodies,
  _BinaryenTryGetCatchBodyAt,
  _BinaryenThrowGetNumOperands,
  _BinaryenThrowGetOperandAt,
  _BinaryenTupleMakeGetOperandAt,
  _BinaryenTupleMakeGetNumOperands,
  _BinaryenIfSetCondition,
  _BinaryenIfSetIfTrue,
  _BinaryenIfSetIfFalse,
  _BinaryenLoopSetBody,
  _BinaryenBreakSetCondition,
  _BinaryenBreakSetValue,
  _BinaryenSwitchSetCondition,
  _BinaryenSwitchSetValue,
  _BinaryenCallSetOperandAt,
  _BinaryenCallIndirectSetTarget,
  _BinaryenCallIndirectSetOperandAt,
  _BinaryenLocalSetSetValue,
  _BinaryenGlobalSetSetValue,
  _BinaryenLoadSetPtr,
  _BinaryenStoreSetPtr,
  _BinaryenStoreSetValue,
  _BinaryenUnarySetValue,
  _BinaryenExpressionFinalize,
  _BinaryenBinarySetLeft,
  _BinaryenBinarySetRight,
  _BinaryenSelectSetIfTrue,
  _BinaryenSelectSetIfFalse,
  _BinaryenSelectSetCondition,
  _BinaryenDropSetValue,
  _BinaryenReturnSetValue,
  _BinaryenMemoryGrowSetDelta,
  _BinaryenAtomicRMWSetPtr,
  _BinaryenAtomicRMWSetValue,
  _BinaryenAtomicCmpxchgSetPtr,
  _BinaryenAtomicCmpxchgSetExpected,
  _BinaryenAtomicCmpxchgSetReplacement,
  _BinaryenAtomicWaitSetPtr,
  _BinaryenAtomicWaitSetExpected,
  _BinaryenAtomicWaitSetTimeout,
  _BinaryenAtomicNotifySetPtr,
  _BinaryenSIMDExtractSetVec,
  _BinaryenSIMDReplaceSetVec,
  _BinaryenSIMDReplaceSetValue,
  _BinaryenSIMDShuffleSetLeft,
  _BinaryenSIMDShuffleSetRight,
  _BinaryenSIMDTernarySetA,
  _BinaryenSIMDTernarySetB,
  _BinaryenSIMDTernarySetC,
  _BinaryenSIMDShiftSetVec,
  _BinaryenSIMDShiftSetShift,
  _BinaryenSIMDLoadSetPtr,
  _BinaryenSIMDLoadStoreLaneGetPtr,
  _BinaryenSIMDLoadStoreLaneGetVec,
  _BinaryenSIMDLoadStoreLaneSetPtr,
  _BinaryenSIMDLoadStoreLaneSetVec,
  _BinaryenMemoryInitSetDest,
  _BinaryenMemoryInitSetOffset,
  _BinaryenMemoryInitSetSize,
  _BinaryenMemoryCopySetDest,
  _BinaryenMemoryCopySetSource,
  _BinaryenMemoryCopySetSize,
  _BinaryenMemoryFillSetDest,
  _BinaryenMemoryFillSetValue,
  _BinaryenMemoryFillSetSize,
  _BinaryenRefIsSetValue,
  _BinaryenTrySetBody,
  _BinaryenTrySetCatchBodyAt,
  _BinaryenThrowSetOperandAt,
  _BinaryenTupleMakeSetOperandAt,
  _BinaryenBlockGetName,
  _BinaryenLoopGetName,
  _BinaryenBreakGetName,
  _BinaryenSwitchGetDefaultName,
  _BinaryenSwitchGetNumNames,
  _BinaryenSwitchGetNameAt,
  _BinaryenCallGetTarget,
  _BinaryenLocalGetGetIndex,
  _BinaryenLocalSetGetIndex,
  _BinaryenGlobalGetGetName,
  _BinaryenGlobalSetGetName,
  _BinaryenAtomicNotifyGetNotifyCount,
  _BinaryenAtomicNotifySetNotifyCount,
  _BinaryenRefFuncGetFunc,
  _BinaryenThrowGetTag,
  _BinaryenTupleExtractGetTuple,
  _BinaryenTupleExtractSetTuple,
  _BinaryenRefEqGetLeft,
  _BinaryenRefEqGetRight,
  _BinaryenRefEqSetLeft,
  _BinaryenRefEqSetRight,
  _BinaryenFunctionSetBody,
  _BinaryenI31NewGetValue,
  _BinaryenI31GetGetI31,
  _BinaryenI31NewSetValue,
  _BinaryenI31GetSetI31
} from "../glue/binaryen";

/** Base class of custom Binaryen visitors. */
export abstract class Visitor {
  /** Expression stack. */
  private stack: ExpressionRef[] = new Array<ExpressionRef>();

  /** Gets the current expression being walked. */
  get currentExpression(): ExpressionRef {
    var currentExpression = this._currentExpression;
    if (!currentExpression) throw new Error("not walking expressions");
    return currentExpression;
  }
  _currentExpression: ExpressionRef = 0;

  /** Gets the parent expression of the current expression being walked. Returns zero if already the top-most expression. */
  get parentExpressionOrNull(): ExpressionRef {
    var stack = this.stack;
    var length = stack.length;
    return length ? stack[length - 1] : 0;
  }

  // Expressions

  visitBlock(expr: ExpressionRef): void {
    // unimp
  }

  visitIf(expr: ExpressionRef): void {
    // unimp
  }

  visitLoop(expr: ExpressionRef): void {
    // unimp
  }

  visitBreak(expr: ExpressionRef): void {
    // unimp
  }

  visitSwitch(expr: ExpressionRef): void {
    // unimp
  }

  visitCallPre(expr: ExpressionRef): void {
    // unimp
  }

  visitCall(expr: ExpressionRef): void {
    // unimp
  }

  visitCallIndirectPre(expr: ExpressionRef): void {
    // unimp
  }

  visitCallIndirect(expr: ExpressionRef): void {
    // unimp
  }

  visitLocalGet(expr: ExpressionRef): void {
    // unimp
  }

  visitLocalSet(expr: ExpressionRef): void {
    // unimp
  }

  visitGlobalGet(expr: ExpressionRef): void {
    // unimp
  }

  visitGlobalSet(expr: ExpressionRef): void {
    // unimp
  }

  visitLoad(expr: ExpressionRef): void {
    // unimp
  }

  visitStore(expr: ExpressionRef): void {
    // unimp
  }

  visitConst(expr: ExpressionRef): void {
    // unimp
  }

  visitUnary(expr: ExpressionRef): void {
    // unimp
  }

  visitBinary(expr: ExpressionRef): void {
    // unimp
  }

  visitSelect(expr: ExpressionRef): void {
    // unimp
  }

  visitDrop(expr: ExpressionRef): void {
    // unimp
  }

  visitReturn(expr: ExpressionRef): void {
    // unimp
  }

  visitMemorySize(expr: ExpressionRef): void {
    // unimp
  }

  visitMemoryGrow(expr: ExpressionRef): void {
    // unimp
  }

  visitNop(expr: ExpressionRef): void {
    // unimp
  }

  visitUnreachable(expr: ExpressionRef): void {
    // unimp
  }

  visitAtomicRMW(expr: ExpressionRef): void {
    // unimp
  }

  visitAtomicCmpxchg(expr: ExpressionRef): void {
    // unimp
  }

  visitAtomicWait(expr: ExpressionRef): void {
    // unimp
  }

  visitAtomicNotify(expr: ExpressionRef): void {
    // unimp
  }

  visitAtomicFence(expr: ExpressionRef): void {
    // unimp
  }

  visitSIMDExtract(expr: ExpressionRef): void {
    // unimp
  }

  visitSIMDReplace(expr: ExpressionRef): void {
    // unimp
  }

  visitSIMDShuffle(expr: ExpressionRef): void {
    // unimp
  }

  visitSIMDTernary(expr: ExpressionRef): void {
    // unimp
  }

  visitSIMDShift(expr: ExpressionRef): void {
    // unimp
  }

  visitSIMDLoad(expr: ExpressionRef): void {
    // unimp
  }

  visitSIMDLoadStoreLane(expr: ExpressionRef): void {
    // unimp
  }

  visitMemoryInit(expr: ExpressionRef): void {
    // unimp
  }

  visitDataDrop(expr: ExpressionRef): void {
    // unimp
  }

  visitMemoryCopy(expr: ExpressionRef): void {
    // unimp
  }

  visitMemoryFill(expr: ExpressionRef): void {
    // unimp
  }

  visitPop(expr: ExpressionRef): void {
    // unimp
  }

  visitRefNull(expr: ExpressionRef): void {
    // unimp
  }

  visitRefIs(expr: ExpressionRef): void {
    // unimp
  }

  visitRefFunc(expr: ExpressionRef): void {
    // unimp
  }

  visitRefEq(expr: ExpressionRef): void {
    // unimp
  }

  visitTry(expr: ExpressionRef): void {
    // unimp
  }

  visitThrow(expr: ExpressionRef): void {
    // unimp
  }

  visitRethrow(expr: ExpressionRef): void {
    // unimp
  }

  visitTupleMake(expr: ExpressionRef): void {
    // unimp
  }

  visitTupleExtract(expr: ExpressionRef): void {
    // unimp
  }

  visitI31New(expr: ExpressionRef): void {
    // unimp
  }

  visitI31Get(expr: ExpressionRef): void {
    // unimp
  }

  visitCallRef(expr: ExpressionRef): void {
    // unimp
  }

  visitRefTest(expr: ExpressionRef): void {
    // unimp
  }

  visitRefCast(expr: ExpressionRef): void {
    // unimp
  }

  visitBrOn(expr: ExpressionRef): void {
    // unimp
  }

  visitRttCanon(expr: ExpressionRef): void {
    // unimp
  }

  visitRttSub(expr: ExpressionRef): void {
    // unimp
  }

  visitStructNew(expr: ExpressionRef): void {
    // unimp
  }

  visitStructGet(expr: ExpressionRef): void {
    // unimp
  }

  visitStructSet(expr: ExpressionRef): void {
    // unimp
  }

  visitArrayNew(expr: ExpressionRef): void {
    // unimp
  }

  visitArrayGet(expr: ExpressionRef): void {
    // unimp
  }

  visitArraySet(expr: ExpressionRef): void {
    // unimp
  }

  visitArrayLen(expr: ExpressionRef): void {
    // unimp
  }

  visitRefAs(expr: ExpressionRef): void {
    // unimp
  }

  // Immediates

  visitName(name: StringRef): void {
    // unimp
  }

  visitLabel(name: StringRef): void {
    // unimp
  }

  visitIndex(index: Index): void {
    // unimp
  }

  visitTag(name: StringRef): void {
    // unimp
  }

  // Delegate

  /** Visits any expression, delegating to the respective visitor methods. */
  visit(expr: ExpressionRef): void {
    let previousExpression = this._currentExpression;
    this._currentExpression = assert(expr);
    switch (_BinaryenExpressionGetId(expr)) {
      case ExpressionId.Block: {
        this.stack.push(expr);
        let name = _BinaryenBlockGetName(expr);
        if (name) this.visitLabel(name);
        for (let i: Index = 0, n = _BinaryenBlockGetNumChildren(expr); i < n; ++i) {
          this.visit(_BinaryenBlockGetChildAt(expr, i));
        }
        assert(this.stack.pop() == expr);
        this.visitBlock(expr);
        break;
      }
      case ExpressionId.If: {
        this.stack.push(expr);
        this.visit(_BinaryenIfGetCondition(expr));
        this.visit(_BinaryenIfGetIfTrue(expr));
        let ifFalse = _BinaryenIfGetIfFalse(expr);
        if (ifFalse) this.visit(ifFalse);
        assert(this.stack.pop() == expr);
        this.visitIf(expr);
        break;
      }
      case ExpressionId.Loop: {
        this.stack.push(expr);
        let name = _BinaryenLoopGetName(expr);
        if (name) this.visitLabel(name);
        this.visit(_BinaryenLoopGetBody(expr));
        assert(this.stack.pop() == expr);
        this.visitLoop(expr);
        break;
      }
      case ExpressionId.Break: {
        this.stack.push(expr);
        this.visitLabel(_BinaryenBreakGetName(expr));
        let condition = _BinaryenBreakGetCondition(expr);
        if (condition) this.visit(condition);
        let value = _BinaryenBreakGetValue(expr);
        if (value) this.visit(value);
        assert(this.stack.pop() == expr);
        this.visitBreak(expr);
        break;
      }
      case ExpressionId.Switch: {
        this.stack.push(expr);
        let defaultName = _BinaryenSwitchGetDefaultName(expr);
        if (defaultName) this.visitLabel(defaultName);
        let numNames = _BinaryenSwitchGetNumNames(expr);
        for (let i: Index = 0; i < numNames; ++i) {
          this.visitLabel(_BinaryenSwitchGetNameAt(expr, i));
        }
        this.visit(_BinaryenSwitchGetCondition(expr));
        let value = _BinaryenSwitchGetValue(expr);
        if (value) this.visit(value);
        assert(this.stack.pop() == expr);
        this.visitSwitch(expr);
        break;
      }
      case ExpressionId.Call: {
        this.visitCallPre(expr);
        this.stack.push(expr);
        this.visitName(_BinaryenCallGetTarget(expr));
        let numOperands = _BinaryenCallGetNumOperands(expr);
        for (let i: Index = 0; i < numOperands; ++i) {
          this.visit(_BinaryenCallGetOperandAt(expr, i));
        }
        assert(this.stack.pop() == expr);
        this.visitCall(expr);
        break;
      }
      case ExpressionId.CallIndirect: {
        this.visitCallIndirectPre(expr);
        this.stack.push(expr);
        this.visit(_BinaryenCallIndirectGetTarget(expr));
        for (let i: Index = 0, k = _BinaryenCallIndirectGetNumOperands(expr); i < k; ++i) {
          this.visit(_BinaryenCallIndirectGetOperandAt(expr, i));
        }
        assert(this.stack.pop() == expr);
        this.visitCallIndirect(expr);
        break;
      }
      case ExpressionId.LocalGet: {
        this.stack.push(expr);
        this.visitIndex(_BinaryenLocalGetGetIndex(expr));
        assert(this.stack.pop() == expr);
        this.visitLocalGet(expr);
        break;
      }
      case ExpressionId.LocalSet: {
        this.stack.push(expr);
        this.visitIndex(_BinaryenLocalSetGetIndex(expr));
        this.visit(_BinaryenLocalSetGetValue(expr));
        assert(this.stack.pop() == expr);
        this.visitLocalSet(expr);
        break;
      }
      case ExpressionId.GlobalGet: {
        this.stack.push(expr);
        this.visitName(_BinaryenGlobalGetGetName(expr));
        assert(this.stack.pop() == expr);
        this.visitGlobalGet(expr);
        break;
      }
      case ExpressionId.GlobalSet: {
        this.stack.push(expr);
        this.visitName(_BinaryenGlobalSetGetName(expr));
        this.visit(_BinaryenGlobalSetGetValue(expr));
        assert(this.stack.pop() == expr);
        this.visitGlobalSet(expr);
        break;
      }
      case ExpressionId.Load: {
        this.stack.push(expr);
        this.visit(_BinaryenLoadGetPtr(expr));
        assert(this.stack.pop() == expr);
        this.visitLoad(expr);
        break;
      }
      case ExpressionId.Store: {
        this.stack.push(expr);
        this.visit(_BinaryenStoreGetPtr(expr));
        this.visit(_BinaryenStoreGetValue(expr));
        assert(this.stack.pop() == expr);
        this.visitStore(expr);
        break;
      }
      case ExpressionId.Const: {
        this.visitConst(expr);
        break;
      }
      case ExpressionId.Unary: {
        this.stack.push(expr);
        this.visit(_BinaryenUnaryGetValue(expr));
        assert(this.stack.pop() == expr);
        this.visitUnary(expr);
        break;
      }
      case ExpressionId.Binary: {
        this.stack.push(expr);
        this.visit(_BinaryenBinaryGetLeft(expr));
        this.visit(_BinaryenBinaryGetRight(expr));
        assert(this.stack.pop() == expr);
        this.visitBinary(expr);
        break;
      }
      case ExpressionId.Select: {
        this.stack.push(expr);
        this.visit(_BinaryenSelectGetIfTrue(expr));
        this.visit(_BinaryenSelectGetIfFalse(expr));
        this.visit(_BinaryenSelectGetCondition(expr));
        assert(this.stack.pop() == expr);
        this.visitSelect(expr);
        break;
      }
      case ExpressionId.Drop: {
        this.stack.push(expr);
        this.visit(_BinaryenDropGetValue(expr));
        assert(this.stack.pop() == expr);
        this.visitDrop(expr);
        break;
      }
      case ExpressionId.Return: {
        let value = _BinaryenReturnGetValue(expr);
        if (value) {
          this.stack.push(expr);
          this.visit(value);
          assert(this.stack.pop() == expr);
        }
        this.visitReturn(expr);
        break;
      }
      case ExpressionId.MemorySize: {
        this.visitMemorySize(expr);
        break;
      }
      case ExpressionId.MemoryGrow: {
        this.stack.push(expr);
        this.visit(_BinaryenMemoryGrowGetDelta(expr));
        assert(this.stack.pop() == expr);
        this.visitMemoryGrow(expr);
        break;
      }
      case ExpressionId.Nop: {
        this.visitNop(expr);
        break;
      }
      case ExpressionId.Unreachable: {
        this.visitUnreachable(expr);
        break;
      }
      case ExpressionId.AtomicRMW: {
        this.stack.push(expr);
        this.visit(_BinaryenAtomicRMWGetPtr(expr));
        this.visit(_BinaryenAtomicRMWGetValue(expr));
        assert(this.stack.pop() == expr);
        this.visitAtomicRMW(expr);
        break;
      }
      case ExpressionId.AtomicCmpxchg: {
        this.stack.push(expr);
        this.visit(_BinaryenAtomicCmpxchgGetPtr(expr));
        this.visit(_BinaryenAtomicCmpxchgGetExpected(expr));
        this.visit(_BinaryenAtomicCmpxchgGetReplacement(expr));
        assert(this.stack.pop() == expr);
        this.visitAtomicCmpxchg(expr);
        break;
      }
      case ExpressionId.AtomicWait: {
        this.stack.push(expr);
        this.visit(_BinaryenAtomicWaitGetPtr(expr));
        this.visit(_BinaryenAtomicWaitGetExpected(expr));
        this.visit(_BinaryenAtomicWaitGetTimeout(expr));
        assert(this.stack.pop() == expr);
        this.visitAtomicWait(expr);
        break;
      }
      case ExpressionId.AtomicNotify: {
        this.stack.push(expr);
        this.visit(_BinaryenAtomicNotifyGetPtr(expr));
        this.visit(_BinaryenAtomicNotifyGetNotifyCount(expr));
        assert(this.stack.pop() == expr);
        this.visitAtomicNotify(expr);
        break;
      }
      case ExpressionId.AtomicFence: {
        this.visitAtomicFence(expr);
        break;
      }
      case ExpressionId.SIMDExtract: {
        this.stack.push(expr);
        this.visit(_BinaryenSIMDExtractGetVec(expr));
        assert(this.stack.pop() == expr);
        this.visitSIMDExtract(expr);
        break;
      }
      case ExpressionId.SIMDReplace: {
        this.stack.push(expr);
        this.visit(_BinaryenSIMDReplaceGetVec(expr));
        this.visit(_BinaryenSIMDReplaceGetValue(expr));
        assert(this.stack.pop() == expr);
        this.visitSIMDReplace(expr);
        break;
      }
      case ExpressionId.SIMDShuffle: {
        this.stack.push(expr);
        this.visit(_BinaryenSIMDShuffleGetLeft(expr));
        this.visit(_BinaryenSIMDShuffleGetRight(expr));
        assert(this.stack.pop() == expr);
        this.visitSIMDShuffle(expr);
        break;
      }
      case ExpressionId.SIMDTernary: {
        this.stack.push(expr);
        this.visit(_BinaryenSIMDTernaryGetA(expr));
        this.visit(_BinaryenSIMDTernaryGetB(expr));
        this.visit(_BinaryenSIMDTernaryGetC(expr));
        assert(this.stack.pop() == expr);
        this.visitSIMDTernary(expr);
        break;
      }
      case ExpressionId.SIMDShift: {
        this.stack.push(expr);
        this.visit(_BinaryenSIMDShiftGetVec(expr));
        this.visit(_BinaryenSIMDShiftGetShift(expr));
        assert(this.stack.pop() == expr);
        this.visitSIMDShift(expr);
        break;
      }
      case ExpressionId.SIMDLoad: {
        this.stack.push(expr);
        this.visit(_BinaryenSIMDLoadGetPtr(expr));
        assert(this.stack.pop() == expr);
        this.visitSIMDLoad(expr);
        break;
      }
      case ExpressionId.SIMDLoadStoreLane: {
        this.stack.push(expr);
        this.visit(_BinaryenSIMDLoadStoreLaneGetPtr(expr));
        this.visit(_BinaryenSIMDLoadStoreLaneGetVec(expr));
        assert(this.stack.pop() == expr);
        this.visitSIMDLoadStoreLane(expr);
        break;
      }
      case ExpressionId.MemoryInit: {
        this.stack.push(expr);
        this.visit(_BinaryenMemoryInitGetDest(expr));
        this.visit(_BinaryenMemoryInitGetOffset(expr));
        this.visit(_BinaryenMemoryInitGetSize(expr));
        assert(this.stack.pop() == expr);
        this.visitMemoryInit(expr);
        break;
      }
      case ExpressionId.DataDrop: {
        this.visitDataDrop(expr);
        break;
      }
      case ExpressionId.MemoryCopy: {
        this.stack.push(expr);
        this.visit(_BinaryenMemoryCopyGetDest(expr));
        this.visit(_BinaryenMemoryCopyGetSource(expr));
        this.visit(_BinaryenMemoryCopyGetSize(expr));
        assert(this.stack.pop() == expr);
        this.visitMemoryCopy(expr);
        break;
      }
      case ExpressionId.MemoryFill: {
        this.stack.push(expr);
        this.visit(_BinaryenMemoryFillGetDest(expr));
        this.visit(_BinaryenMemoryFillGetValue(expr));
        this.visit(_BinaryenMemoryFillGetSize(expr));
        assert(this.stack.pop() == expr);
        this.visitMemoryFill(expr);
        break;
      }
      case ExpressionId.Pop: {
        this.visitPop(expr);
        break;
      }
      case ExpressionId.RefNull: {
        this.visitRefNull(expr);
        break;
      }
      case ExpressionId.RefIs: {
        this.stack.push(expr);
        this.visit(_BinaryenRefIsGetValue(expr));
        assert(this.stack.pop() == expr);
        this.visitRefIs(expr);
        break;
      }
      case ExpressionId.RefFunc: {
        this.stack.push(expr);
        this.visitName(_BinaryenRefFuncGetFunc(expr));
        assert(this.stack.pop() == expr);
        this.visitRefFunc(expr);
        break;
      }
      case ExpressionId.RefEq: {
        this.stack.push(expr);
        this.visit(_BinaryenRefEqGetLeft(expr));
        this.visit(_BinaryenRefEqGetRight(expr));
        assert(this.stack.pop() == expr);
        this.visitRefEq(expr);
        break;
      }
      case ExpressionId.Try: {
        this.stack.push(expr);
        this.visit(_BinaryenTryGetBody(expr));
        let numCatchBodies = _BinaryenTryGetNumCatchBodies(expr);
        for (let i: Index = 0; i < numCatchBodies; ++i) {
          this.visit(_BinaryenTryGetCatchBodyAt(expr, i));
        }
        assert(this.stack.pop() == expr);
        this.visitTry(expr);
        break;
      }
      case ExpressionId.Throw: {
        this.stack.push(expr);
        this.visitTag(_BinaryenThrowGetTag(expr));
        let numOperands = _BinaryenThrowGetNumOperands(expr);
        for (let i: Index = 0; i < numOperands; ++i) {
          this.visit(_BinaryenThrowGetOperandAt(expr, i));
        }
        assert(this.stack.pop() == expr);
        this.visitThrow(expr);
        break;
      }
      case ExpressionId.Rethrow: {
        this.visitRethrow(expr);
        break;
      }
      case ExpressionId.TupleMake: {
        let numOperands = _BinaryenTupleMakeGetNumOperands(expr);
        if (numOperands) {
          this.stack.push(expr);
          for (let i: Index = 0; i < numOperands; ++i) {
            this.visit(_BinaryenTupleMakeGetOperandAt(expr, i));
          }
          assert(this.stack.pop() == expr);
        }
        this.visitTupleMake(expr);
        break;
      }
      case ExpressionId.TupleExtract: {
        this.stack.push(expr);
        this.visit(_BinaryenTupleExtractGetTuple(expr));
        assert(this.stack.pop() == expr);
        this.visitTupleExtract(expr);
        break;
      }
      case ExpressionId.I31New: {
        this.stack.push(expr);
        this.visit(_BinaryenI31NewGetValue(expr));
        assert(this.stack.pop() == expr);
        this.visitI31New(expr);
        break;
      }
      case ExpressionId.I31Get: {
        this.stack.push(expr);
        this.visit(_BinaryenI31GetGetI31(expr));
        assert(this.stack.pop() == expr);
        this.visitI31Get(expr);
        break;
      }
      case ExpressionId.CallRef: {
        this.stack.push(expr);
        assert(false); // TODO
        assert(this.stack.pop() == expr);
        this.visitCallRef(expr);
        break;
      }
      case ExpressionId.RefTest: {
        this.stack.push(expr);
        assert(false); // TODO
        assert(this.stack.pop() == expr);
        this.visitRefTest(expr);
        break;
      }
      case ExpressionId.RefCast: {
        this.stack.push(expr);
        assert(false); // TODO
        assert(this.stack.pop() == expr);
        this.visitRefCast(expr);
        break;
      }
      case ExpressionId.BrOn: {
        this.stack.push(expr);
        assert(false); // TODO
        assert(this.stack.pop() == expr);
        this.visitBrOn(expr);
        break;
      }
      case ExpressionId.RttCanon: {
        this.stack.push(expr);
        assert(false); // TODO
        assert(this.stack.pop() == expr);
        this.visitRttCanon(expr);
        break;
      }
      case ExpressionId.RttSub: {
        this.stack.push(expr);
        assert(false); // TODO
        assert(this.stack.pop() == expr);
        this.visitRttSub(expr);
        break;
      }
      case ExpressionId.StructNew: {
        this.stack.push(expr);
        assert(false); // TODO
        assert(this.stack.pop() == expr);
        this.visitStructNew(expr);
        break;
      }
      case ExpressionId.StructGet: {
        this.stack.push(expr);
        assert(false); // TODO
        assert(this.stack.pop() == expr);
        this.visitStructGet(expr);
        break;
      }
      case ExpressionId.StructSet: {
        this.stack.push(expr);
        assert(false); // TODO
        assert(this.stack.pop() == expr);
        this.visitStructSet(expr);
        break;
      }
      case ExpressionId.ArrayNew: {
        this.stack.push(expr);
        assert(false); // TODO
        assert(this.stack.pop() == expr);
        this.visitArrayNew(expr);
        break;
      }
      case ExpressionId.ArrayGet: {
        this.stack.push(expr);
        assert(false); // TODO
        assert(this.stack.pop() == expr);
        this.visitArrayGet(expr);
        break;
      }
      case ExpressionId.ArraySet: {
        this.stack.push(expr);
        assert(false); // TODO
        assert(this.stack.pop() == expr);
        this.visitArraySet(expr);
        break;
      }
      case ExpressionId.ArrayLen: {
        this.stack.push(expr);
        assert(false); // TODO
        assert(this.stack.pop() == expr);
        this.visitArrayLen(expr);
        break;
      }
      case ExpressionId.RefAs: {
        this.stack.push(expr);
        assert(false); // TODO
        assert(this.stack.pop() == expr);
        this.visitRefAs(expr);
        break;
      }
      default: throw new Error("unexpected expression kind");
    }
    this._currentExpression = previousExpression;
  }
}

/** Base class of custom Binaryen passes. */
export abstract class Pass extends Visitor {

  /** Gets the current function being walked. */
  get currentFunction(): FunctionRef {
    var currentFunction = this._currentFunction;
    if (!currentFunction) throw new Error("not walking a function");
    return currentFunction;
  }
  private _currentFunction: FunctionRef = 0;

  /** Gets the current global being walked. */
  get currentGlobal(): GlobalRef {
    var currentGlobal = this._currentGlobal;
    if (!currentGlobal) throw new Error("not walking a global");
    return currentGlobal;
  }
  private _currentGlobal: GlobalRef = 0;

  /** Constructs a new Binaryen pass. */
  constructor(readonly module: Module) {
    super();
  }

  // Walking

  /** Walks the entire module. */
  walkModule(): void {
    this.walkFunctions();
    this.walkGlobals();
  }

  /** Walks all functions. */
  walkFunctions(): void {
    var moduleRef = this.module.ref;
    for (let i: Index = 0, k = _BinaryenGetNumFunctions(moduleRef); i < k; ++i) {
      this.walkFunction(_BinaryenGetFunctionByIndex(moduleRef, i));
    }
  }

  /** Walks a specific function. */
  walkFunction(func: FunctionRef): void {
    var body = _BinaryenFunctionGetBody(func);
    if (body) {
      this._currentFunction = func;
      this.visit(body);
      this._currentFunction = 0;
    }
  }

  /** Walks all global variables. */
  walkGlobals(): void {
    var moduleRef = this.module.ref;
    for (let i: Index = 0, k = _BinaryenGetNumGlobals(moduleRef); i < k; ++i) {
      this.walkGlobal(_BinaryenGetGlobalByIndex(moduleRef, i));
    }
  }

  /** Walks a specific global variable. */
  walkGlobal(global: GlobalRef): void {
    this._currentGlobal = global;
    var init = _BinaryenGlobalGetInitExpr(global);
    if (init) this.visit(init);
    this._currentGlobal = 0;
  }

  // Utility

  /** Replaces the current expression with the specified replacement. */
  replaceCurrent(replacement: ExpressionRef): void {
    var search = this.currentExpression;
    var func = this.currentFunction;
    var body = _BinaryenFunctionGetBody(func);
    if (body == search) {
      _BinaryenFunctionSetBody(func, replacement);
    } else {
      var parent = assert(this.parentExpressionOrNull);
      var replaced = replaceChild(parent, search, replacement);
      if (!replaced) throw Error("failed to replace expression");
      _BinaryenExpressionFinalize(parent);
    }
  }
}

/** Replaces an expression within a parent expression. Returns the replaced expression on success, otherwise `0`. */
export function replaceChild(
  /** Parent expression containing `search`. */
  parent: ExpressionRef,
  /** Expression to replace. */
  search: ExpressionRef,
  /** Expression to replace `search` with. */
  replacement: ExpressionRef
): ExpressionRef {
  switch (_BinaryenExpressionGetId(parent)) {
    case ExpressionId.Block: {
      let numChildren = _BinaryenBlockGetNumChildren(parent);
      for (let i: Index = 0; i < numChildren; ++i) {
        let child = _BinaryenBlockGetChildAt(parent, i);
        if (child == search) {
          _BinaryenBlockSetChildAt(parent, i, replacement);
          return child;
        }
      }
      break;
    }
    case ExpressionId.If: {
      let condition = _BinaryenIfGetCondition(parent);
      if (condition == search) {
        _BinaryenIfSetCondition(parent, replacement);
        return condition;
      }
      let ifTrue = _BinaryenIfGetIfTrue(parent);
      if (ifTrue == search) {
        _BinaryenIfSetIfTrue(parent, replacement);
        return ifTrue;
      }
      let ifFalse = _BinaryenIfGetIfFalse(parent);
      if (ifFalse == search) {
        _BinaryenIfSetIfFalse(parent, replacement);
        return ifFalse;
      }
      break;
    }
    case ExpressionId.Loop: {
      let body = _BinaryenLoopGetBody(parent);
      if (body == search) {
        _BinaryenLoopSetBody(parent, replacement);
        return body;
      }
      break;
    }
    case ExpressionId.Break: {
      let condition = _BinaryenBreakGetCondition(parent);
      if (condition == search) {
        _BinaryenBreakSetCondition(parent, replacement);
        return condition;
      }
      let value = _BinaryenBreakGetValue(parent);
      if (value == search) {
        _BinaryenBreakSetValue(parent, replacement);
        return value;
      }
      break;
    }
    case ExpressionId.Switch: {
      let condition = _BinaryenSwitchGetCondition(parent);
      if (condition == search) {
        _BinaryenSwitchSetCondition(parent, replacement);
        return condition;
      }
      let value = _BinaryenSwitchGetValue(parent);
      if (value == search) {
        _BinaryenSwitchSetValue(parent, replacement);
        return value;
      }
      break;
    }
    case ExpressionId.Call: {
      let numOperands = _BinaryenCallGetNumOperands(parent);
      for (let i: Index = 0; i < numOperands; ++i) {
        let operand = _BinaryenCallGetOperandAt(parent, i);
        if (operand == search) {
          _BinaryenCallSetOperandAt(parent, i, replacement);
          return operand;
        }
      }
      break;
    }
    case ExpressionId.CallIndirect: {
      let target = _BinaryenCallIndirectGetTarget(parent);
      if (target == search) {
        _BinaryenCallIndirectSetTarget(parent, replacement);
        return target;
      }
      let numOperands = _BinaryenCallIndirectGetNumOperands(parent);
      for (let i: Index = 0; i < numOperands; ++i) {
        let operand = _BinaryenCallIndirectGetOperandAt(parent, i);
        if (operand == search) {
          _BinaryenCallIndirectSetOperandAt(parent, i, replacement);
          return operand;
        }
      }
      break;
    }
    case ExpressionId.LocalGet: {
      break;
    }
    case ExpressionId.LocalSet: {
      let value = _BinaryenLocalSetGetValue(parent);
      if (value == search) {
        _BinaryenLocalSetSetValue(parent, replacement);
        return value;
      }
      break;
    }
    case ExpressionId.GlobalGet: {
      break;
    }
    case ExpressionId.GlobalSet: {
      let value = _BinaryenGlobalSetGetValue(parent);
      if (value == search) {
        _BinaryenGlobalSetSetValue(parent, replacement);
        return value;
      }
      break;
    }
    case ExpressionId.Load: {
      let ptr = _BinaryenLoadGetPtr(parent);
      if (ptr == search) {
        _BinaryenLoadSetPtr(parent, replacement);
        return ptr;
      }
      break;
    }
    case ExpressionId.Store: {
      let ptr = _BinaryenStoreGetPtr(parent);
      if (ptr == search) {
        _BinaryenStoreSetPtr(parent, replacement);
        return ptr;
      }
      let value = _BinaryenStoreGetValue(parent);
      if (value == search) {
        _BinaryenStoreSetValue(parent, replacement);
        return value;
      }
      break;
    }
    case ExpressionId.Const: {
      break;
    }
    case ExpressionId.Unary: {
      let value = _BinaryenUnaryGetValue(parent);
      if (value == search) {
        _BinaryenUnarySetValue(parent, replacement);
        return value;
      }
      break;
    }
    case ExpressionId.Binary: {
      let left = _BinaryenBinaryGetLeft(parent);
      if (left == search) {
        _BinaryenBinarySetLeft(parent, replacement);
        return left;
      }
      let right = _BinaryenBinaryGetRight(parent);
      if (right == search) {
        _BinaryenBinarySetRight(parent, replacement);
        return right;
      }
      break;
    }
    case ExpressionId.Select: {
      let ifTrue = _BinaryenSelectGetIfTrue(parent);
      if (ifTrue == search) {
        _BinaryenSelectSetIfTrue(parent, replacement);
        return ifTrue;
      }
      let ifFalse = _BinaryenSelectGetIfFalse(parent);
      if (ifFalse == search) {
        _BinaryenSelectSetIfFalse(parent, replacement);
        return ifFalse;
      }
      let condition = _BinaryenSelectGetCondition(parent);
      if (condition == search) {
        _BinaryenSelectSetCondition(parent, replacement);
        return condition;
      }
      break;
    }
    case ExpressionId.Drop: {
      let value = _BinaryenDropGetValue(parent);
      if (value == search) {
        _BinaryenDropSetValue(parent, replacement);
        return value;
      }
      break;
    }
    case ExpressionId.Return: {
      let value = _BinaryenReturnGetValue(parent);
      if (value == search) {
        _BinaryenReturnSetValue(parent, replacement);
        return value;
      }
      break;
    }
    case ExpressionId.MemorySize: {
      break;
    }
    case ExpressionId.MemoryGrow: {
      let delta = _BinaryenMemoryGrowGetDelta(parent);
      if (delta == search) {
        _BinaryenMemoryGrowSetDelta(parent, replacement);
        return delta;
      }
      break;
    }
    case ExpressionId.Nop: {
      break;
    }
    case ExpressionId.Unreachable: {
      break;
    }
    case ExpressionId.AtomicRMW: {
      let ptr = _BinaryenAtomicRMWGetPtr(parent);
      if (ptr == search) {
        _BinaryenAtomicRMWSetPtr(parent, replacement);
        return ptr;
      }
      let value = _BinaryenAtomicRMWGetValue(parent);
      if (value == search) {
        _BinaryenAtomicRMWSetValue(parent, replacement);
        return value;
      }
      break;
    }
    case ExpressionId.AtomicCmpxchg: {
      let ptr = _BinaryenAtomicCmpxchgGetPtr(parent);
      if (ptr == search) {
        _BinaryenAtomicCmpxchgSetPtr(parent, replacement);
        return ptr;
      }
      let expected = _BinaryenAtomicCmpxchgGetExpected(parent);
      if (expected == search) {
        _BinaryenAtomicCmpxchgSetExpected(parent, replacement);
        return expected;
      }
      let repl = _BinaryenAtomicCmpxchgGetReplacement(parent);
      if (repl == search) {
        _BinaryenAtomicCmpxchgSetReplacement(parent, replacement);
        return repl;
      }
      break;
    }
    case ExpressionId.AtomicWait: {
      let ptr = _BinaryenAtomicWaitGetPtr(parent);
      if (ptr == search) {
        _BinaryenAtomicWaitSetPtr(parent, replacement);
        return ptr;
      }
      let expected = _BinaryenAtomicWaitGetExpected(parent);
      if (expected == search) {
        _BinaryenAtomicWaitSetExpected(parent, replacement);
        return expected;
      }
      let timeout = _BinaryenAtomicWaitGetTimeout(parent);
      if (timeout == search) {
        _BinaryenAtomicWaitSetTimeout(parent, replacement);
        return timeout;
      }
      break;
    }
    case ExpressionId.AtomicNotify: {
      let ptr = _BinaryenAtomicNotifyGetPtr(parent);
      if (ptr == search) {
        _BinaryenAtomicNotifySetPtr(parent, replacement);
        return ptr;
      }
      let notifyCount = _BinaryenAtomicNotifyGetNotifyCount(parent);
      if (notifyCount == search) {
        _BinaryenAtomicNotifySetNotifyCount(parent, replacement);
        return notifyCount;
      }
      break;
    }
    case ExpressionId.AtomicFence: {
      break;
    }
    case ExpressionId.SIMDExtract: {
      let vec = _BinaryenSIMDExtractGetVec(parent);
      if (vec == search) {
        _BinaryenSIMDExtractSetVec(parent, replacement);
        return vec;
      }
      break;
    }
    case ExpressionId.SIMDReplace: {
      let vec = _BinaryenSIMDReplaceGetVec(parent);
      if (vec == search) {
        _BinaryenSIMDReplaceSetVec(parent, replacement);
        return vec;
      }
      let value = _BinaryenSIMDReplaceGetValue(parent);
      if (value == search) {
        _BinaryenSIMDReplaceSetValue(parent, replacement);
        return value;
      }
      break;
    }
    case ExpressionId.SIMDShuffle: {
      let left = _BinaryenSIMDShuffleGetLeft(parent);
      if (left == search) {
        _BinaryenSIMDShuffleSetLeft(parent, replacement);
        return left;
      }
      let right = _BinaryenSIMDShuffleGetRight(parent);
      if (right == search) {
        _BinaryenSIMDShuffleSetRight(parent, replacement);
        return right;
      }
      break;
    }
    case ExpressionId.SIMDTernary: {
      let a = _BinaryenSIMDTernaryGetA(parent);
      if (a == search) {
        _BinaryenSIMDTernarySetA(parent, replacement);
        return a;
      }
      let b = _BinaryenSIMDTernaryGetB(parent);
      if (b == search) {
        _BinaryenSIMDTernarySetB(parent, replacement);
        return b;
      }
      let c = _BinaryenSIMDTernaryGetC(parent);
      if (c == search) {
        _BinaryenSIMDTernarySetC(parent, replacement);
        return c;
      }
      break;
    }
    case ExpressionId.SIMDShift: {
      let vec = _BinaryenSIMDShiftGetVec(parent);
      if (vec == search) {
        _BinaryenSIMDShiftSetVec(parent, replacement);
        return vec;
      }
      let shift = _BinaryenSIMDShiftGetShift(parent);
      if (shift == search) {
        _BinaryenSIMDShiftSetShift(parent, replacement);
        return shift;
      }
      break;
    }
    case ExpressionId.SIMDLoad: {
      let ptr = _BinaryenSIMDLoadGetPtr(parent);
      if (ptr == search) {
        _BinaryenSIMDLoadSetPtr(parent, replacement);
        return ptr;
      }
      break;
    }
    case ExpressionId.SIMDLoadStoreLane: {
      let ptr = _BinaryenSIMDLoadStoreLaneGetPtr(parent);
      if (ptr == search) {
        _BinaryenSIMDLoadStoreLaneSetPtr(parent, replacement);
        return ptr;
      }
      let vec = _BinaryenSIMDLoadStoreLaneGetVec(parent);
      if (vec == search) {
        _BinaryenSIMDLoadStoreLaneSetVec(parent, replacement);
        return ptr;
      }
      break;
    }
    case ExpressionId.MemoryInit: {
      let dest = _BinaryenMemoryInitGetDest(parent);
      if (dest == search) {
        _BinaryenMemoryInitSetDest(parent, replacement);
        return dest;
      }
      let offset = _BinaryenMemoryInitGetOffset(parent);
      if (offset == search) {
        _BinaryenMemoryInitSetOffset(parent, replacement);
        return offset;
      }
      let size = _BinaryenMemoryInitGetSize(parent);
      if (size == search) {
        _BinaryenMemoryInitSetSize(parent, replacement);
        return size;
      }
      break;
    }
    case ExpressionId.DataDrop: {
      break;
    }
    case ExpressionId.MemoryCopy: {
      let dest = _BinaryenMemoryCopyGetDest(parent);
      if (dest == search) {
        _BinaryenMemoryCopySetDest(parent, replacement);
        return dest;
      }
      let source = _BinaryenMemoryCopyGetSource(parent);
      if (source == search) {
        _BinaryenMemoryCopySetSource(parent, replacement);
        return source;
      }
      let size = _BinaryenMemoryCopyGetSize(parent);
      if (size == search) {
        _BinaryenMemoryCopySetSize(parent, replacement);
        return size;
      }
      break;
    }
    case ExpressionId.MemoryFill: {
      let dest = _BinaryenMemoryFillGetDest(parent);
      if (dest == search) {
        _BinaryenMemoryFillSetDest(parent, replacement);
        return dest;
      }
      let value = _BinaryenMemoryFillGetValue(parent);
      if (value == search) {
        _BinaryenMemoryFillSetValue(parent, replacement);
        return value;
      }
      let size = _BinaryenMemoryFillGetSize(parent);
      if (size == search) {
        _BinaryenMemoryFillSetSize(parent, replacement);
        return size;
      }
      break;
    }
    case ExpressionId.Pop: {
      break;
    }
    case ExpressionId.RefNull: {
      break;
    }
    case ExpressionId.RefIs: {
      let value = _BinaryenRefIsGetValue(parent);
      if (value == search) {
        _BinaryenRefIsSetValue(parent, replacement);
        return value;
      }
      break;
    }
    case ExpressionId.RefFunc: {
      break;
    }
    case ExpressionId.RefEq: {
      let left = _BinaryenRefEqGetLeft(parent);
      if (left == search) {
        _BinaryenRefEqSetLeft(parent, replacement);
        return left;
      }
      let right = _BinaryenRefEqGetRight(parent);
      if (right == search) {
        _BinaryenRefEqSetRight(parent, replacement);
        return right;
      }
      break;
    }
    case ExpressionId.Try: {
      let body = _BinaryenTryGetBody(parent);
      if (body == search) {
        _BinaryenTrySetBody(parent, replacement);
        return body;
      }
      let numCatchBodies = _BinaryenTryGetNumCatchBodies(parent);
      for (let i: Index = 0; i < numCatchBodies; ++i) {
        let catchBody = _BinaryenTryGetCatchBodyAt(parent, i);
        if (catchBody == search) {
          _BinaryenTrySetCatchBodyAt(parent, i, replacement);
          return catchBody;
        }
      }
      break;
    }
    case ExpressionId.Throw: {
      let numOperands = _BinaryenThrowGetNumOperands(parent);
      for (let i: Index = 0; i < numOperands; ++i) {
        let operand = _BinaryenThrowGetOperandAt(parent, i);
        if (operand == search) {
          _BinaryenThrowSetOperandAt(parent, i, replacement);
          return operand;
        }
      }
      break;
    }
    case ExpressionId.Rethrow: {
      break;
    }
    case ExpressionId.TupleMake: {
      let numOperands = _BinaryenTupleMakeGetNumOperands(parent);
      for (let i: Index = 0; i < numOperands; ++i) {
        let operand = _BinaryenTupleMakeGetOperandAt(parent, i);
        if (operand == search) {
          _BinaryenTupleMakeSetOperandAt(parent, i, replacement);
          return operand;
        }
      }
      break;
    }
    case ExpressionId.TupleExtract: {
      let tuple = _BinaryenTupleExtractGetTuple(parent);
      if (tuple == search) {
        _BinaryenTupleExtractSetTuple(parent, replacement);
        return tuple;
      }
      break;
    }
    case ExpressionId.I31New: {
      let value = _BinaryenI31NewGetValue(parent);
      if (value == search) {
        _BinaryenI31NewSetValue(parent, replacement);
        return value;
      }
      break;
    }
    case ExpressionId.I31Get: {
      let i31Expr = _BinaryenI31GetGetI31(parent);
      if (i31Expr == search) {
        _BinaryenI31GetSetI31(parent, replacement);
        return i31Expr;
      }
      break;
    }
    case ExpressionId.CallRef: {
      assert(false); // TODO
      break;
    }
    case ExpressionId.RefTest: {
      assert(false); // TODO
      break;
    }
    case ExpressionId.RefCast: {
      assert(false); // TODO
      break;
    }
    case ExpressionId.BrOn: {
      assert(false); // TODO
      break;
    }
    case ExpressionId.RttCanon: {
      assert(false); // TODO
      break;
    }
    case ExpressionId.RttSub: {
      assert(false); // TODO
      break;
    }
    case ExpressionId.StructNew: {
      assert(false); // TODO
      break;
    }
    case ExpressionId.StructGet: {
      assert(false); // TODO
      break;
    }
    case ExpressionId.StructSet: {
      assert(false); // TODO
      break;
    }
    case ExpressionId.ArrayNew: {
      assert(false); // TODO
      break;
    }
    case ExpressionId.ArrayGet: {
      assert(false); // TODO
      break;
    }
    case ExpressionId.ArraySet: {
      assert(false); // TODO
      break;
    }
    case ExpressionId.ArrayLen: {
      assert(false); // TODO
      break;
    }
    case ExpressionId.RefAs: {
      assert(false); // TODO
      break;
    }
    default: throw new Error("unexpected expression id");
  }
  return 0;
}

'''
'''--- src/passes/rtrace.ts ---
/**
 * @fileoverview A lightweight store instrumentation pass.
 * 
 * Can be used to find rogue stores to protected memory addresses like object
 * headers or similar, without going overboard with instrumentation. Also
 * passes a flag whether a store originates within the runtime or other code.
 * 
 * @license Apache-2.0
 */

import {
  Pass
} from "./pass";

import {
  Compiler
} from "../compiler";

import {
  createType,
  ExpressionRef,
  TypeRef
} from "../module";

import {
  _BinaryenFunctionGetName,
  _BinaryenStoreGetBytes,
  _BinaryenStoreGetOffset,
  _BinaryenStoreGetPtr,
  _BinaryenStoreSetPtr
} from "../glue/binaryen";

/** Instruments stores to also call an import. */
export class RtraceMemory extends Pass {
  /** Whether we've seen any stores. */
  seenStores: bool = false;
  /** Target pointer type. */
  ptrType: TypeRef;

  constructor(compiler: Compiler) {
    super(compiler.module);
    this.ptrType = compiler.options.sizeTypeRef;
  }

  checkRT(): bool {
    var functionName = this.module.readStringCached(_BinaryenFunctionGetName(this.currentFunction))!;
    return functionName.startsWith("~lib/rt/");
  }

  /** @override */
  visitStore(store: ExpressionRef): void {
    var module = this.module;
    var ptr = _BinaryenStoreGetPtr(store);
    var offset = _BinaryenStoreGetOffset(store);
    var bytes = _BinaryenStoreGetBytes(store);
    // onstore(ptr: usize, offset: i32, bytes: i32, isRT: bool) -> ptr
    _BinaryenStoreSetPtr(store,
      module.call("~onstore", [
        ptr,
        module.i32(offset),
        module.i32(bytes),
        module.i32(i32(this.checkRT()))
      ], this.ptrType)
    );
    this.seenStores = true;
  }

  // TODO: MemoryFill, Atomics

  /** @override */
  walkModule(): void {
    super.walkModule();
    if (this.seenStores) {
      this.module.addFunctionImport("~onstore", "rtrace", "onstore",
        createType([ this.ptrType, TypeRef.I32, TypeRef.I32, TypeRef.I32 ]),
        this.ptrType
      );
    }
  }
}

'''
'''--- src/passes/shadowstack.ts ---
/**
 * @fileoverview Shadow stack instrumentation for a precise GC.
 * 
 * Instruments function arguments and local assignments marked with a 'tostack'
 * call to also do stores to a shadow stack of managed values only.
 * 
 * Consider a simple call to a function looking like the following, taking
 * managed arguments, plus assigning managed values to locals:
 * 
 *   function foo(a: Obj, b: Obj): Obj {
 *     var c = __tostack(a) // slot 2
 *     __collect()
 *     return b
 *   }
 *   
 *   foo(__tostack(a), __tostack(b)) // slot 0, 1
 * 
 * At the call to `__collect()` the 32-bit stack frame of the function is:
 * 
 *   Offset | Value stored
 *   -------|----------------------------
 *      0   | First managed argument 'a'
 *      4   | Second managed argument 'b'
 *   -------|----------------------------
 *      8   | First managed local 'c'
 * 
 * We are splitting the frame in two halves as annotated since both halves are
 * only known separately for indirect calls, with the first half becoming an
 * extension of the calling function's stack frame by means of treating the
 * arguments as if these were locals beyond the caller's `numLocals`. Function
 * arguments stay a bit longer on the stack than usually, but we also don't have
 * to modify the stack pointer pre-call at all this way. The caller's amended
 * stack frame when assuming one managed local may look like this:
 * 
 *   Offset | Value stored
 *   -------|----------------------------
 *      0   | First managed local '?'
 *      4   | Extended with first managed argument 'a'
 *      8   | Extended with second managed argument 'b'
 * 
 * with the callee's stack frame becoming just:
 * 
 *   Offset | Value stored
 *   -------|----------------------------
 *      0   | First managed local 'c'
 * 
 * Instrumentation added below looks about like the following, with the stack
 * growing downwards and 't' and 'r' being new temporary locals:
 * 
 *   // callee frameSize = 1 * sizeof<usize>()
 *   function foo(a: usize, b: usize): usize {
 *     memory.fill(__stack_pointer -= frameSize, 0, frameSize)
 *     store<usize>(__stack_pointer, c = a, 0 * sizeof<usize>())
 *     __collect()
 *     var r = b
 *     __stack_pointer += frameSize
 *     return r
 *   }
 * 
 *   // caller frameSize = (numLocalSlots + 2 [by extension]) * sizeof<usize>()
 *   (
 *     r = foo(
 *       ( t = a,
 *         store<usize>(__stack_pointer, t, (numLocalSlots + 0) * sizeof<usize>()),
 *         t ),
 *       ( t = b,
 *         store<usize>(__stack_pointer, t, (numLocalSlots + 1) * sizeof<usize>()),
 *         t )
 *     ),
 *     r
 *   )
 * 
 * Also note that we have to `memory.fill` the second half because the first
 * assignment to a local may happen at a later point within the function. The
 * invariant we need to maintain for a precise GC is that it only sees zeroes
 * or valid pointers, but never an invalid pointer left on the stack earlier.
 * Since most frames are small, we unroll a sequence of `store`s up to a frame
 * size of 16 bytes, and `memory.fill`, if available, beyond.
 * 
 * @license Apache-2.0
 */

import {
  Pass
} from "./pass";

import {
  _BinaryenAddFunction,
  _BinaryenAddFunctionExport,
  _BinaryenCallGetNumOperands,
  _BinaryenCallGetOperandAt,
  _BinaryenCallGetTarget,
  _BinaryenCallIndirectGetNumOperands,
  _BinaryenCallIndirectGetOperandAt,
  _BinaryenCallIndirectSetOperandAt,
  _BinaryenCallSetOperandAt,
  _BinaryenExportGetKind,
  _BinaryenExportGetName,
  _BinaryenExportGetValue,
  _BinaryenExpressionGetId,
  _BinaryenExpressionGetType,
  _BinaryenFunctionGetBody,
  _BinaryenFunctionGetName,
  _BinaryenFunctionGetNumLocals,
  _BinaryenFunctionGetNumVars,
  _BinaryenFunctionGetParams,
  _BinaryenFunctionGetResults,
  _BinaryenFunctionGetVar,
  _BinaryenFunctionSetBody,
  _BinaryenGetExport,
  _BinaryenGetFunction,
  _BinaryenLocalSetGetIndex,
  _BinaryenLocalSetGetValue,
  _BinaryenLocalSetIsTee,
  _BinaryenLocalSetSetValue,
  _BinaryenRemoveExport,
  _BinaryenRemoveFunction,
  _BinaryenReturnGetValue,
  _BinaryenReturnSetValue,
  _free
} from "../glue/binaryen";

import {
  ExpressionId,
  ExpressionRef,
  FunctionRef,
  Index,
  BinaryOp,
  TypeRef,
  allocPtrArray,
  Module,
  ExternalKind,
  ExportRef,
  expandType,
  isConstZero
} from "../module";

import {
  Compiler,
  Options
} from "../compiler";

import {
  Feature
} from "../common";

import {
  BuiltinNames
} from "../builtins";

type LocalIndex = Index;
type SlotIndex = Index;
type SlotMap = Map<LocalIndex,SlotIndex>;
type TempMap = Map<TypeRef,LocalIndex>;

/** Attempts to match the `__tostack(value)` pattern. Returns `value` if a match, otherwise `0`.  */
function matchPattern(module: Module, expr: ExpressionRef): ExpressionRef {
  if (_BinaryenExpressionGetId(expr) == ExpressionId.Call && module.readStringCached(_BinaryenCallGetTarget(expr)) == BuiltinNames.tostack) {
    assert(_BinaryenCallGetNumOperands(expr) == 1);
    return _BinaryenCallGetOperandAt(expr, 0);
  }
  return 0;
}

/** Tests whether a `value` matched by `matchTostack` needs a slot. */
function needsSlot(module: Module, value: ExpressionRef): bool {
  switch (_BinaryenExpressionGetId(value)) {
    // no need to stack null pointers
    case ExpressionId.Const: return !isConstZero(value);
    // already kept in another slot
    case ExpressionId.LocalGet:
    case ExpressionId.LocalSet: return false; // tee
  }
  return true;
}

/** Instruments a module with a shadow stack for precise GC. */
export class ShadowStackPass extends Pass {
  /** Stack frame slots, per function. */
  slotMaps: Map<FunctionRef, SlotMap> = new Map();
  /** Temporary locals, per function. */
  tempMaps: Map<FunctionRef, TempMap> = new Map();
  /** Exports (with managed operands) map. */
  exportMap: Map<string,i32[]> = new Map();
  /** Compiler reference. */
  compiler: Compiler;

  constructor(compiler: Compiler) {
    super(compiler.module);
    this.compiler = compiler;
  }

  /** Compiler options. */
  get options(): Options { return this.compiler.options; }
  /** Target pointer type. */
  get ptrType(): TypeRef { return this.options.sizeTypeRef; }
  /** Target pointer size. */
  get ptrSize(): i32 { return this.ptrType == TypeRef.I64 ? 8 : 4; }
  /** Target pointer addition operation. */
  get ptrBinaryAdd(): BinaryOp { return this.ptrType == TypeRef.I64 ? BinaryOp.AddI64 : BinaryOp.AddI32; }
  /** Target pointer subtraction operation. */
  get ptrBinarySub(): BinaryOp { return this.ptrType == TypeRef.I64 ? BinaryOp.SubI64 : BinaryOp.SubI32; }

  /** Gets a constant with the specified value of the target pointer type. */
  ptrConst(value: i32): ExpressionRef {
    return this.ptrType == TypeRef.I64
      ? this.module.i64(value)
      : this.module.i32(value);
  }

  /** Notes the presence of a slot for the specified (imaginary) local, returning the slot index. */
  noteSlot(func: FunctionRef, localIndex: Index): i32 {
    let slotMap: SlotMap;
    if (this.slotMaps.has(func)) {
      slotMap = changetype<SlotMap>(this.slotMaps.get(func));
      if (slotMap.has(localIndex)) {
        return changetype<i32>(slotMap.get(localIndex));
      }
    } else {
      slotMap = new Map();
      this.slotMaps.set(func, slotMap);
    }
    let slotIndex = slotMap.size;
    slotMap.set(localIndex, slotIndex);
    return slotIndex;
  }

  /** Notes the presence of an exported function taking managed operands. */
  noteExport(name: string, managedOperandIndices: i32[]): void {
    if (!managedOperandIndices.length) return;
    this.exportMap.set(name, managedOperandIndices);
  }

  /** Gets a shared temporary local of the given type in the specified functions. */
  getSharedTemp(func: FunctionRef, type: TypeRef): Index {
    let tempMap: TempMap;
    if (this.tempMaps.has(func)) {
      tempMap = changetype<TempMap>(this.tempMaps.get(func));
      if (tempMap.has(type)) {
        return changetype<Index>(tempMap.get(type));
      }
    } else {
      tempMap = new Map();
      this.tempMaps.set(func, tempMap);
    }
    let numLocals = _BinaryenFunctionGetNumLocals(func);
    let localIndex = numLocals + tempMap.size;
    tempMap.set(type, localIndex);
    return localIndex;
  }

  /** Makes an expression modifying the stack pointer by the given offset. */
  makeStackOffset(offset: i32): ExpressionRef {
    assert(offset != 0);
    var module = this.module;
    var expr = module.global_set(BuiltinNames.stack_pointer,
      module.binary(offset >= 0 ? this.ptrBinaryAdd : this.ptrBinarySub,
        module.global_get(BuiltinNames.stack_pointer, this.ptrType),
        this.ptrConst(abs(offset))
      )
    );
    if (offset > 0) return expr;
    return module.block(null, [
      expr,
      this.makeStackCheck()
    ], TypeRef.None);
  }

  /** Makes a sequence of expressions zeroing the stack frame. */
  makeStackFill(frameSize: i32, stmts: ExpressionRef[]): void {
    assert(frameSize > 0);
    var module = this.module;
    if (this.options.hasFeature(Feature.BULK_MEMORY) && frameSize > 16) {
      stmts.push(
        module.memory_fill(
          module.global_get(BuiltinNames.stack_pointer, this.ptrType),
          module.i32(0), // TODO: Wasm64 also i32?
          this.ptrConst(frameSize)
        )
      );
    } else {
      let remain = frameSize;
      while (remain >= 8) {
        // store<i64>(__stack_pointer, 0, frameSize - remain)
        stmts.push(
          module.store(8,
            module.global_get(BuiltinNames.stack_pointer, this.ptrType),
            module.i64(0),
            TypeRef.I64,
            frameSize - remain
          )
        );
        remain -= 8;
      }
      if (remain) {
        assert(remain == 4);
        // store<i32>(__stack_pointer, 0, frameSize - remain)
        stmts.push(
          module.store(4,
            module.global_get(BuiltinNames.stack_pointer, this.ptrType),
            module.i32(0),
            TypeRef.I32,
            frameSize - remain
          )
        );
      }
    }
  }

  private hasStackCheckFunction: bool = false;

  /** Makes a check that the current stack pointer is valid. */
  makeStackCheck(): ExpressionRef {
    var module = this.module;
    if (!this.hasStackCheckFunction) {
      this.hasStackCheckFunction = true;
      module.addFunction("~stack_check", TypeRef.None, TypeRef.None, null,
        module.if(
          module.binary(BinaryOp.LtI32,
            module.global_get(BuiltinNames.stack_pointer, this.ptrType),
            module.global_get(BuiltinNames.data_end, this.ptrType)
          ),
          this.compiler.makeStaticAbort(this.compiler.ensureStaticString("stack overflow"), this.compiler.program.nativeSource)
        )
      );
    }
    return module.call("~stack_check", null, TypeRef.None);
  }

  private updateCallOperands(operands: ExpressionRef[]): i32 {
    var module = this.module;
    var numSlots = 0;
    for (let i = 0, k = operands.length; i < k; ++i) {
      let operand = operands[i];
      let match = matchPattern(module, operand);
      if (!match) continue;
      if (!needsSlot(module, match)) {
        operands[i] = match;
        continue;
      }
      let currentFunction = this.currentFunction;
      let numLocals = _BinaryenFunctionGetNumLocals(currentFunction);
      let slotIndex = this.noteSlot(currentFunction, numLocals + this.callSlotOffset + i);
      let temp = this.getSharedTemp(currentFunction, this.ptrType);
      let stmts = new Array<ExpressionRef>();
      // t = value
      stmts.push(
        module.local_set(temp, match, false)
      );
      // store<usize>(__stack_pointer, t, slotIndex * ptrSize)
      stmts.push(
        module.store(this.ptrSize,
          module.global_get(BuiltinNames.stack_pointer, this.ptrType),
          module.local_get(temp, this.ptrType),
          this.ptrType, slotIndex * this.ptrSize
        )
      );
      // -> t
      stmts.push(
        module.local_get(temp, this.ptrType)
      );
      operands[i] = module.block(null, stmts, this.ptrType);
      ++numSlots;
    }
    return numSlots;
  }

  /** Slot offset accounting for nested calls. */
  private callSlotOffset: i32 = 0;
  /** Slot offset stack in nested calls. */
  private callSlotStack: i32[] = new Array();

  /** @override */
  visitCallPre(call: ExpressionRef): void {
    var numOperands = _BinaryenCallGetNumOperands(call);
    var operands = new Array<ExpressionRef>(numOperands);
    for (let i: Index = 0; i < numOperands; ++i) {
      operands[i] = _BinaryenCallGetOperandAt(call, i);
    }
    let numSlots = this.updateCallOperands(operands);
    for (let i = 0, k = operands.length; i < k; ++i) {
      _BinaryenCallSetOperandAt(call, i, operands[i]);
    }
    if (numSlots) {
      // Reserve these slots for us so nested calls use their own
      this.callSlotOffset += numSlots;
    }
    this.callSlotStack.push(numSlots);
  }

  /** @override */
  visitCall(call: ExpressionRef): void {
    let numSlots = this.callSlotStack.pop();
    if (numSlots) this.callSlotOffset -= numSlots;
  }

  /** @override */
  visitCallIndirectPre(callIndirect: ExpressionRef): void {
    let numOperands = _BinaryenCallIndirectGetNumOperands(callIndirect);
    let operands = new Array<ExpressionRef>(numOperands);
    for (let i: Index = 0; i < numOperands; ++i) {
      operands[i] = _BinaryenCallIndirectGetOperandAt(callIndirect, i);
    }
    let numSlots = this.updateCallOperands(operands);
    for (let i = 0, k = operands.length; i < k; ++i) {
      _BinaryenCallIndirectSetOperandAt(callIndirect, i, operands[i]);
    }
    if (numSlots) {
      // Reserve these slots for us so nested calls use their own
      this.callSlotOffset += numSlots;
    }
    this.callSlotStack.push(numSlots);
  }

  /** @override */
  visitCallIndirect(callIndirect: ExpressionRef): void {
    let numSlots = this.callSlotStack.pop();
    if (numSlots) this.callSlotOffset -= numSlots;
  }

  /** @override */
  visitLocalSet(localSet: ExpressionRef): void {
    let module = this.module;
    let value = _BinaryenLocalSetGetValue(localSet);
    let match = matchPattern(module, value);
    if (!match) return;
    if (!needsSlot(module, match)) {
      _BinaryenLocalSetSetValue(localSet, match);
      return;
    }
    let index = _BinaryenLocalSetGetIndex(localSet);
    let slotIndex = this.noteSlot(this.currentFunction, index);
    let stmts = new Array<ExpressionRef>();
    // store<usize>(__stack_pointer, local = match, slotIndex * ptrSize)
    stmts.push(
      module.store(this.ptrSize,
        module.global_get(BuiltinNames.stack_pointer, this.ptrType),
        module.local_tee(index, match, false),
        this.ptrType, slotIndex * this.ptrSize
      )
    );
    if (_BinaryenLocalSetIsTee(localSet)) {
      // -> local
      stmts.push(
        module.local_get(index, this.ptrType)
      );
      this.replaceCurrent(module.flatten(stmts, this.ptrType));
    } else {
      this.replaceCurrent(module.flatten(stmts, TypeRef.None));
    }
  }

  /** Updates a function with additional locals etc. */
  updateFunction(funcRef: FunctionRef): void {
    let name = _BinaryenFunctionGetName(funcRef);
    let params = _BinaryenFunctionGetParams(funcRef);
    let results = _BinaryenFunctionGetResults(funcRef);
    let body = assert(_BinaryenFunctionGetBody(funcRef));
    let numVars = _BinaryenFunctionGetNumVars(funcRef);
    let vars = new Array<TypeRef>();
    for (let i: Index = 0; i < numVars; ++i) {
      vars[i] = _BinaryenFunctionGetVar(funcRef, i);
    }
    let tempMaps = this.tempMaps;
    if (tempMaps.has(funcRef)) {
      let tempMap = changetype<TempMap>(tempMaps.get(funcRef));
      for (let _keys = Map_keys(tempMap), i = 0, k = _keys.length; i < k; ++i) {
        vars.push(_keys[i]);
      }
    }
    let moduleRef = this.module.ref;
    _BinaryenRemoveFunction(moduleRef, name);
    let cArr = allocPtrArray(vars);
    _BinaryenAddFunction(moduleRef, name, params, results, cArr, vars.length, body);
    _free(cArr);
  }

  /** Updates a function export taking managed arguments. */
  updateExport(exportRef: ExportRef, managedOperandIndices: i32[]): void {
    var module = this.module;
    var moduleRef = module.ref;
    assert(_BinaryenExportGetKind(exportRef) == ExternalKind.Function);

    var internalNameRef = _BinaryenExportGetValue(exportRef);
    var internalName = module.readStringCached(internalNameRef)!;
    var externalNameRef = _BinaryenExportGetName(exportRef);
    var funcRef = _BinaryenGetFunction(moduleRef, internalNameRef);
    var params = _BinaryenFunctionGetParams(funcRef);
    var paramTypes = expandType(params);
    var numParams = paramTypes.length;
    var results = _BinaryenFunctionGetResults(funcRef);
    var numLocals = numParams;
    var vars = new Array<TypeRef>();
    var numSlots = assert(managedOperandIndices.length);
    var frameSize = numSlots * this.ptrSize;
    var wrapperName = "export:" + internalName;
    var wrapperNameRef = module.allocStringCached(wrapperName);

    if (_BinaryenGetFunction(moduleRef, wrapperNameRef) == 0) {
      let stmts = new Array<ExpressionRef>();
      // __stack_pointer -= frameSize
      stmts.push(
        this.makeStackOffset(-frameSize)
      );
      for (let slotIndex = 0; slotIndex < numSlots; ++slotIndex) {
        // store<usize>(__stack_pointer, $local, slotIndex * ptrSize)
        stmts.push(
          module.store(this.ptrSize,
            module.global_get(BuiltinNames.stack_pointer, this.ptrType),
            module.local_get(managedOperandIndices[slotIndex], this.ptrType),
            this.ptrType, slotIndex * this.ptrSize
          )
        );
      }
      let forwardedOperands = new Array<ExpressionRef>(numParams);
      for (let i = 0; i < numParams; ++i) {
        forwardedOperands[i] = module.local_get(i, paramTypes[i]);
      }
      if (results != TypeRef.None) {
        let tempIndex = numLocals++;
        vars.push(results);
        // t = original(...)
        stmts.push(
          module.local_set(tempIndex,
            module.call(internalName, forwardedOperands, results),
            false // internal
          )
        );
        // __stack_pointer += frameSize
        stmts.push(
          this.makeStackOffset(+frameSize)
        );
        // -> t
        stmts.push(
          module.local_get(tempIndex, results)
        );
      } else {
        // original(...)
        stmts.push(
          module.call(internalName, forwardedOperands, results)
        );
        // __stack_pointer += frameSize
        stmts.push(
          this.makeStackOffset(+frameSize)
        );
      }
      let cArr = allocPtrArray(vars);
      _BinaryenAddFunction(moduleRef, wrapperNameRef, params, results, cArr, vars.length,
        module.block(null, stmts, results)
      );
      _free(cArr);
    }
    _BinaryenRemoveExport(moduleRef, externalNameRef);
    _BinaryenAddFunctionExport(moduleRef, wrapperNameRef, externalNameRef);
  }

  /** @override */
  walkModule(): void {
    // Run the pass normally
    super.walkModule();

    // Instrument returns in functions utilizing stack slots
    var module = this.module;
    var instrumentReturns = new InstrumentReturns(this);
    for (let _keys = Map_keys(this.slotMaps), i = 0, k = _keys.length; i < k; ++i) {
      let func = _keys[i];
      let slotMap = changetype<SlotMap>(this.slotMaps.get(func));
      let frameSize = slotMap.size * this.ptrSize;

      // Instrument function returns
      instrumentReturns.frameSize = frameSize;
      instrumentReturns.walkFunction(func);

      // Instrument function entry
      let stmts = new Array<ExpressionRef>();
      // __stack_pointer -= frameSize
      stmts.push(
        this.makeStackOffset(-frameSize)
      );
      // memory.fill(__stack_pointer, 0, frameSize)
      this.makeStackFill(frameSize, stmts);
      
      // Handle implicit return
      let body = _BinaryenFunctionGetBody(func);
      let bodyType = _BinaryenExpressionGetType(body);
      if (bodyType == TypeRef.Unreachable) {
        // body
        stmts.push(
          body
        );
      } else if (bodyType == TypeRef.None) {
        // body
        stmts.push(
          body
        );
        // __stack_pointer += frameSize
        stmts.push(
          this.makeStackOffset(+frameSize)
        );
      } else {
        let temp = this.getSharedTemp(func, bodyType);
        // t = body
        stmts.push(
          module.local_set(temp, body, false)
        );
        // __stack_pointer += frameSize
        stmts.push(
          this.makeStackOffset(+frameSize)
        );
        // -> t
        stmts.push(
          module.local_get(temp, bodyType)
        );
      }
      _BinaryenFunctionSetBody(func, module.flatten(stmts, bodyType));
    }

    // Update functions we added more locals to
    // TODO: _BinaryenFunctionAddVar ?
    for (let _keys = Map_keys(this.tempMaps), i = 0, k = _keys.length; i < k; ++i) {
      this.updateFunction(_keys[i]);
    }

    // Update exports taking managed arguments
    var exportMap = this.exportMap;
    for (let _keys = Map_keys(exportMap), i = 0, k = _keys.length; i < k; ++i) {
      let exportName = _keys[i];
      let exportRef = _BinaryenGetExport(module.ref, module.allocStringCached(exportName));
      let managedOperandIndices = changetype<i32[]>(exportMap.get(exportName));
      this.updateExport(exportRef, managedOperandIndices);
    }
  }
}

/** Companion pass instrumenting `return` statements to restore the stack frame. */
class InstrumentReturns extends Pass {
  /** Parent pass. */
  parentPass: ShadowStackPass;
  /** Frame size of the current function being processed. */
  frameSize: i32 = 0;

  constructor(shadowStack: ShadowStackPass) {
    super(shadowStack.module);
    this.parentPass = shadowStack;
  }

  /** @override */
  visitReturn(ret: ExpressionRef): void {
    assert(this.frameSize);
    var module = this.module;
    var value = _BinaryenReturnGetValue(ret);
    var stmts = new Array<ExpressionRef>();
    if (value) {
      let returnType = _BinaryenExpressionGetType(value);
      let temp = this.parentPass.getSharedTemp(this.currentFunction, returnType);
      // t = value
      stmts.push(
        module.local_set(temp, value, false)
      );
      // __stack_pointer += frameSize
      stmts.push(
        this.parentPass.makeStackOffset(+this.frameSize)
      );
      // return t
      _BinaryenReturnSetValue(ret, module.local_get(temp, returnType));
    } else {
      // __stack_pointer += frameSize
      stmts.push(
        this.parentPass.makeStackOffset(+this.frameSize)
      );
      // return
    }
    stmts.push(
      ret
    );
    this.replaceCurrent(module.flatten(stmts, TypeRef.Unreachable));
  }
}
'''
'''--- src/program.ts ---
/**
 * @fileoverview AssemblyScript's intermediate representation.
 *
 * The compiler uses Binaryen IR, which is fairly low level, as its
 * primary intermediate representation, with the following structures
 * holding any higher level information that cannot be represented by
 * Binaryen IR alone, for example higher level types.
 *
 * Similar to the AST being composed of `Node`s in `Source`s, the IR is
 * composed of `Element`s in a `Program`. Each class or function is
 * represented by a "prototype" holding all the relevant information,
 * including each's concrete instances. If a class or function is not
 * generic, there is exactly one instance, otherwise there is one for
 * each concrete set of type arguments.
 *
 * @license Apache-2.0
 */

// Element                    Base class of all elements
// â”œâ”€DeclaredElement          Base class of elements with a declaration
// â”‚ â”œâ”€TypedElement           Base class of elements resolving to a type
// â”‚ â”‚ â”œâ”€TypeDefinition       Type alias declaration
// â”‚ â”‚ â”œâ”€VariableLikeElement  Base class of all variable-like elements
// â”‚ â”‚ â”‚ â”œâ”€EnumValue          Enum value
// â”‚ â”‚ â”‚ â”œâ”€Global             File global
// â”‚ â”‚ â”‚ â”œâ”€Local              Function local
// â”‚ â”‚ â”‚ â”œâ”€Field              Class field (instance only)
// â”‚ â”‚ â”‚ â””â”€Property           Class property
// â”‚ â”‚ â”œâ”€IndexSignature       Class index signature
// â”‚ â”‚ â”œâ”€Function             Concrete function instance
// â”‚ â”‚ â””â”€Class                Concrete class instance
// â”‚ â”œâ”€Namespace              Namespace with static members
// â”‚ â”œâ”€FunctionPrototype      Prototype of concrete function instances
// â”‚ â”œâ”€FieldPrototype         Prototype of concrete field instances
// â”‚ â”œâ”€PropertyPrototype      Prototype of concrete property instances
// â”‚ â””â”€ClassPrototype         Prototype of concrete classe instances
// â””â”€File                     File, analogous to Source in the AST

import {
  CommonFlags,
  PATH_DELIMITER,
  STATIC_DELIMITER,
  INSTANCE_DELIMITER,
  GETTER_PREFIX,
  SETTER_PREFIX,
  INNER_DELIMITER,
  LIBRARY_SUBST,
  INDEX_SUFFIX,
  STUB_DELIMITER,
  CommonNames,
  Feature,
  Target
} from "./common";

import {
  Options
} from "./compiler";

import {
  DiagnosticCode,
  DiagnosticMessage,
  DiagnosticEmitter
} from "./diagnostics";

import {
  Type,
  TypeKind,
  Signature,
  TypeFlags
} from "./types";

import {
  Token,
  Range
} from "./tokenizer";

import {
  Node,
  NodeKind,
  Source,
  SourceKind,
  DecoratorNode,
  DecoratorKind,
  TypeParameterNode,
  TypeNode,
  NamedTypeNode,
  FunctionTypeNode,
  ArrowKind,

  Expression,
  IdentifierExpression,
  LiteralKind,
  StringLiteralExpression,

  Statement,
  ClassDeclaration,
  DeclarationStatement,
  EnumDeclaration,
  EnumValueDeclaration,
  ExportMember,
  ExportDefaultStatement,
  ExportStatement,
  FieldDeclaration,
  FunctionDeclaration,
  ImportDeclaration,
  ImportStatement,
  InterfaceDeclaration,
  MethodDeclaration,
  NamespaceDeclaration,
  TypeDeclaration,
  VariableDeclaration,
  VariableLikeDeclarationStatement,
  VariableStatement,
  ParameterKind
} from "./ast";

import {
  Module,
  FunctionRef,
  MemorySegment
} from "./module";

import {
  CharCode,
  writeI8,
  writeI16,
  writeI32,
  writeF32,
  writeF64,
  writeI64,
  writeI32AsI64,
  writeI64AsI32
} from "./util";

import {
  Resolver
} from "./resolver";

import {
  Flow
} from "./flow";

import {
  Parser
} from "./parser";

import {
  BuiltinNames
} from "./builtins";

// Memory manager constants
const AL_SIZE = 16;
const AL_MASK = AL_SIZE - 1;

/** Represents a yet unresolved `import`. */
class QueuedImport {
  constructor(
    /** File being imported into. */
    public localFile: File,
    /** Identifier within the local file. */
    public localIdentifier: IdentifierExpression,
    /** Identifier within the other file. Is an `import *` if not set. */
    public foreignIdentifier: IdentifierExpression | null,
    /** Path to the other file. */
    public foreignPath: string,
    /** Alternative path to the other file. */
    public foreignPathAlt: string
  ) {}
}

/** Represents a yet unresolved `export`. */
class QueuedExport {
  constructor(
    /** Identifier within the local file. */
    public localIdentifier: IdentifierExpression,
    /** Identifier within the other file. */
    public foreignIdentifier: IdentifierExpression,
    /** Path to the other file if a re-export. */
    public foreignPath: string | null,
    /** Alternative path to the other file if a re-export. */
    public foreignPathAlt: string | null
  ) {}
}

/** Represents a yet unresolved `export *`. */
class QueuedExportStar {
  // stored in a map with localFile as the key
  constructor(
    /** Path to the other file. */
    public foreignPath: string,
    /** Alternative path to the other file. */
    public foreignPathAlt: string,
    /** Reference to the path literal for reporting. */
    public pathLiteral: StringLiteralExpression
  ) {}
}

/** Represents the kind of an operator overload. */
export enum OperatorKind {
  INVALID,

  // indexed access
  INDEXED_GET,            // a[]
  INDEXED_SET,            // a[]=b
  UNCHECKED_INDEXED_GET,  // unchecked(a[])
  UNCHECKED_INDEXED_SET,  // unchecked(a[]=b)

  // binary
  ADD,                    // a + b
  SUB,                    // a - b
  MUL,                    // a * b
  DIV,                    // a / b
  REM,                    // a % b
  POW,                    // a ** b
  BITWISE_AND,            // a & b
  BITWISE_OR,             // a | b
  BITWISE_XOR,            // a ^ b
  BITWISE_SHL,            // a << b
  BITWISE_SHR,            // a >> b
  BITWISE_SHR_U,          // a >>> b
  EQ,                     // a == b
  NE,                     // a != b
  GT,                     // a > b
  GE,                     // a >= b
  LT,                     // a < b
  LE,                     // a <= b

  // unary prefix
  PLUS,                   // +a
  MINUS,                  // -a
  NOT,                    // !a
  BITWISE_NOT,            // ~a
  PREFIX_INC,             // ++a
  PREFIX_DEC,             // --a

  // unary postfix
  POSTFIX_INC,            // a++
  POSTFIX_DEC             // a--

  // not overridable:
  // IDENTITY             // a === b
  // LOGICAL_AND          // a && b
  // LOGICAL_OR           // a || b
}

export namespace OperatorKind {

  /** Returns the operator kind represented by the specified decorator and string argument. */
  export function fromDecorator(decoratorKind: DecoratorKind, arg: string): OperatorKind {
    assert(arg.length);
    switch (decoratorKind) {
      case DecoratorKind.OPERATOR:
      case DecoratorKind.OPERATOR_BINARY: {
        switch (arg.charCodeAt(0)) {
          case CharCode.OPENBRACKET: {
            if (arg == "[]") return OperatorKind.INDEXED_GET;
            if (arg == "[]=") return OperatorKind.INDEXED_SET;
            break;
          }
          case CharCode.OPENBRACE: {
            if (arg == "{}") return OperatorKind.UNCHECKED_INDEXED_GET;
            if (arg == "{}=") return OperatorKind.UNCHECKED_INDEXED_SET;
            break;
          }
          case CharCode.PLUS: {
            if (arg == "+") return OperatorKind.ADD;
            break;
          }
          case CharCode.MINUS: {
            if (arg == "-") return OperatorKind.SUB;
            break;
          }
          case CharCode.ASTERISK: {
            if (arg == "*") return OperatorKind.MUL;
            if (arg == "**") return OperatorKind.POW;
            break;
          }
          case CharCode.SLASH: {
            if (arg == "/") return OperatorKind.DIV;
            break;
          }
          case CharCode.PERCENT: {
            if (arg == "%") return OperatorKind.REM;
            break;
          }
          case CharCode.AMPERSAND: {
            if (arg == "&") return OperatorKind.BITWISE_AND;
            break;
          }
          case CharCode.BAR: {
            if (arg == "|") return OperatorKind.BITWISE_OR;
            break;
          }
          case CharCode.CARET: {
            if (arg == "^") return OperatorKind.BITWISE_XOR;
            break;
          }
          case CharCode.EQUALS: {
            if (arg == "==") return OperatorKind.EQ;
            break;
          }
          case CharCode.EXCLAMATION: {
            if (arg == "!=") return OperatorKind.NE;
            break;
          }
          case CharCode.GREATERTHAN: {
            if (arg == ">") return OperatorKind.GT;
            if (arg == ">=") return OperatorKind.GE;
            if (arg == ">>") return OperatorKind.BITWISE_SHR;
            if (arg == ">>>") return OperatorKind.BITWISE_SHR_U;
            break;
          }
          case CharCode.LESSTHAN: {
            if (arg == "<") return OperatorKind.LT;
            if (arg == "<=") return OperatorKind.LE;
            if (arg == "<<") return OperatorKind.BITWISE_SHL;
            break;
          }
        }
        break;
      }
      case DecoratorKind.OPERATOR_PREFIX: {
        switch (arg.charCodeAt(0)) {
          case CharCode.PLUS: {
            if (arg == "+") return OperatorKind.PLUS;
            if (arg == "++") return OperatorKind.PREFIX_INC;
            break;
          }
          case CharCode.MINUS: {
            if (arg == "-") return OperatorKind.MINUS;
            if (arg == "--") return OperatorKind.PREFIX_DEC;
            break;
          }
          case CharCode.EXCLAMATION: {
            if (arg == "!") return OperatorKind.NOT;
            break;
          }
          case CharCode.TILDE: {
            if (arg == "~") return OperatorKind.BITWISE_NOT;
            break;
          }
        }
        break;
      }
      case DecoratorKind.OPERATOR_POSTFIX: {
        switch (arg.charCodeAt(0)) {
          case CharCode.PLUS: {
            if (arg == "++") return OperatorKind.POSTFIX_INC;
            break;
          }
          case CharCode.MINUS: {
            if (arg == "--") return OperatorKind.POSTFIX_DEC;
            break;
          }
        }
        break;
      }
    }
    return OperatorKind.INVALID;
  }

  /** Converts a binary operator token to the respective operator kind. */
  export function fromBinaryToken(token: Token): OperatorKind {
    switch (token) {
      case Token.PLUS:
      case Token.PLUS_EQUALS: return OperatorKind.ADD;
      case Token.MINUS:
      case Token.MINUS_EQUALS: return OperatorKind.SUB;
      case Token.ASTERISK:
      case Token.ASTERISK_EQUALS: return OperatorKind.MUL;
      case Token.SLASH:
      case Token.SLASH_EQUALS: return OperatorKind.DIV;
      case Token.PERCENT:
      case Token.PERCENT_EQUALS: return OperatorKind.REM;
      case Token.ASTERISK_ASTERISK:
      case Token.ASTERISK_ASTERISK_EQUALS: return OperatorKind.POW;
      case Token.AMPERSAND:
      case Token.AMPERSAND_EQUALS: return OperatorKind.BITWISE_AND;
      case Token.BAR:
      case Token.BAR_EQUALS: return OperatorKind.BITWISE_OR;
      case Token.CARET:
      case Token.CARET_EQUALS: return OperatorKind.BITWISE_XOR;
      case Token.LESSTHAN_LESSTHAN:
      case Token.LESSTHAN_LESSTHAN_EQUALS: return OperatorKind.BITWISE_SHL;
      case Token.GREATERTHAN_GREATERTHAN:
      case Token.GREATERTHAN_GREATERTHAN_EQUALS: return OperatorKind.BITWISE_SHR;
      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN:
      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS: return OperatorKind.BITWISE_SHR_U;
      case Token.EQUALS_EQUALS: return OperatorKind.EQ;
      case Token.EXCLAMATION_EQUALS: return OperatorKind.NE;
      case Token.GREATERTHAN: return OperatorKind.GT;
      case Token.GREATERTHAN_EQUALS: return OperatorKind.GE;
      case Token.LESSTHAN: return OperatorKind.LT;
      case Token.LESSTHAN_EQUALS: return OperatorKind.LE;
    }
    return OperatorKind.INVALID;
  }

  /** Converts a unary prefix operator token to the respective operator kind. */
  export function fromUnaryPrefixToken(token: Token): OperatorKind {
    switch (token) {
      case Token.PLUS: return OperatorKind.PLUS;
      case Token.MINUS: return OperatorKind.MINUS;
      case Token.EXCLAMATION: return OperatorKind.NOT;
      case Token.TILDE: return OperatorKind.BITWISE_NOT;
      case Token.PLUS_PLUS: return OperatorKind.PREFIX_INC;
      case Token.MINUS_MINUS: return OperatorKind.PREFIX_DEC;
    }
    return OperatorKind.INVALID;
  }

  /** Converts a unary postfix operator token to the respective operator kind. */
  export function fromUnaryPostfixToken(token: Token): OperatorKind {
    switch (token) {
      case Token.PLUS_PLUS: return OperatorKind.POSTFIX_INC;
      case Token.MINUS_MINUS: return OperatorKind.POSTFIX_DEC;
    }
    return OperatorKind.INVALID;
  }
}

/** Represents an AssemblyScript program. */
export class Program extends DiagnosticEmitter {

  /** Constructs a new program, optionally inheriting parser diagnostics. */
  constructor(
    /** Compiler options. */
    public options: Options,
    /** Shared array of diagnostic messages (emitted so far). */
    diagnostics: DiagnosticMessage[] | null = null
  ) {
    super(diagnostics);
    var nativeSource = new Source(SourceKind.LIBRARY_ENTRY, LIBRARY_SUBST + ".wasm", "[native code]");
    this.nativeSource = nativeSource;
    this.parser = new Parser(this.diagnostics, this.sources);
    this.resolver = new Resolver(this);
    var nativeFile = new File(this, nativeSource);
    this.nativeFile = nativeFile;
    this.filesByName.set(nativeFile.internalName, nativeFile);
  }

  /** Parser instance. */
  parser: Parser;
  /** Resolver instance. */
  resolver!: Resolver;
  /** Array of sources. */
  sources: Source[] = [];
  /** Diagnostic offset used where successively obtaining the next diagnostic. */
  diagnosticsOffset: i32 = 0;
  /** Special native code source. */
  nativeSource: Source;
  /** Special native code range. */
  get nativeRange(): Range { return this.nativeSource.range; }
  /** Special native code file. */
  nativeFile!: File;
  /** Next class id. */
  nextClassId: u32 = 0;
  /** Next signature id. */
  nextSignatureId: i32 = 0;
  /** An indicator if the program has been initialized. */
  initialized: bool = false;

  // Lookup maps

  /** Files by unique internal name. */
  filesByName: Map<string,File> = new Map();
  /** Elements by unique internal name in element space. */
  elementsByName: Map<string,Element> = new Map();
  /** Elements by declaration. */
  elementsByDeclaration: Map<DeclarationStatement,DeclaredElement> = new Map();
  /** Element instances by unique internal name. */
  instancesByName: Map<string,Element> = new Map();
  /** Classes wrapping basic types like `i32`. */
  wrapperClasses: Map<Type,Class> = new Map();
  /** Managed classes contained in the program, by id. */
  managedClasses: Map<i32,Class> = new Map();
  /** A set of unique function signatures contained in the program, by id. */
  uniqueSignatures: Signature[] = new Array<Signature>(0);

  // Standard library

  /** Gets the standard `ArrayBufferView` instance. */
  get arrayBufferViewInstance(): Class {
    var cached = this._arrayBufferViewInstance;
    if (!cached) this._arrayBufferViewInstance = cached = this.requireClass(CommonNames.ArrayBufferView);
    return cached;
  }
  private _arrayBufferViewInstance: Class | null = null;

  /** Gets the standard `ArrayBuffer` instance. */
  get arrayBufferInstance(): Class {
    var cached = this._arrayBufferInstance;
    if (!cached) this._arrayBufferInstance = cached = this.requireClass(CommonNames.ArrayBuffer);
    return cached;
  }
  private _arrayBufferInstance: Class | null = null;

  /** Gets the standard `Array` prototype. */
  get arrayPrototype(): ClassPrototype {
    var cached = this._arrayPrototype;
    if (!cached) this._arrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Array, ElementKind.CLASS_PROTOTYPE);
    return cached;
  }
  private _arrayPrototype: ClassPrototype | null = null;

  /** Gets the standard `StaticArray` prototype. */
  get staticArrayPrototype(): ClassPrototype {
    var cached = this._staticArrayPrototype;
    if (!cached) this._staticArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.StaticArray, ElementKind.CLASS_PROTOTYPE);
    return cached;
  }
  private _staticArrayPrototype: ClassPrototype | null = null;

  /** Gets the standard `Set` prototype. */
  get setPrototype(): ClassPrototype {
    var cached = this._setPrototype;
    if (!cached) this._setPrototype = cached = <ClassPrototype>this.require(CommonNames.Set, ElementKind.CLASS_PROTOTYPE);
    return cached;
  }
  private _setPrototype: ClassPrototype | null = null;

  /** Gets the standard `Map` prototype. */
  get mapPrototype(): ClassPrototype {
    var cached = this._mapPrototype;
    if (!cached) this._mapPrototype = cached = <ClassPrototype>this.require(CommonNames.Map, ElementKind.CLASS_PROTOTYPE);
    return cached;
  }
  private _mapPrototype: ClassPrototype | null = null;

  /** Gets the standard `Function` prototype. */
  get functionPrototype(): ClassPrototype {
    var cached = this._functionPrototype;
    if (!cached) this._functionPrototype = cached = <ClassPrototype>this.require(CommonNames.Function, ElementKind.CLASS_PROTOTYPE);
    return cached;
  }
  private _functionPrototype: ClassPrototype | null = null;

  /** Gets the standard `Int8Array` prototype. */
  get int8ArrayPrototype(): ClassPrototype {
    var cached = this._int8ArrayPrototype;
    if (!cached) this._int8ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int8Array, ElementKind.CLASS_PROTOTYPE);
    return cached;
  }
  private _int8ArrayPrototype: ClassPrototype | null = null;

  /** Gets the standard `Int16Array` prototype. */
  get int16ArrayPrototype(): ClassPrototype {
    var cached = this._int16ArrayPrototype;
    if (!cached) this._int16ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int16Array, ElementKind.CLASS_PROTOTYPE);
    return cached;
  }
  private _int16ArrayPrototype: ClassPrototype | null = null;

  /** Gets the standard `Int32Array` prototype. */
  get int32ArrayPrototype(): ClassPrototype {
    var cached = this._int32ArrayPrototype;
    if (!cached) this._int32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int32Array, ElementKind.CLASS_PROTOTYPE);
    return cached;
  }
  private _int32ArrayPrototype: ClassPrototype | null = null;

  /** Gets the standard `Int64Array` prototype. */
  get int64ArrayPrototype(): ClassPrototype {
    var cached = this._int64ArrayPrototype;
    if (!cached) this._int64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int64Array, ElementKind.CLASS_PROTOTYPE);
    return cached;
  }
  private _int64ArrayPrototype: ClassPrototype | null = null;

  /** Gets the standard `Uint8Array` prototype. */
  get uint8ArrayPrototype(): ClassPrototype {
    var cached = this._uint8ArrayPrototype;
    if (!cached) this._uint8ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint8Array, ElementKind.CLASS_PROTOTYPE);
    return cached;
  }
  private _uint8ArrayPrototype: ClassPrototype | null = null;

  /** Gets the standard `Uint8ClampedArray` prototype. */
  get uint8ClampedArrayPrototype(): ClassPrototype {
    var cached = this._uint8ClampedArrayPrototype;
    if (!cached) this._uint8ClampedArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint8ClampedArray, ElementKind.CLASS_PROTOTYPE);
    return cached;
  }
  private _uint8ClampedArrayPrototype: ClassPrototype | null = null;

  /** Gets the standard `Uint16Array` prototype. */
  get uint16ArrayPrototype(): ClassPrototype {
    var cached = this._uint16ArrayPrototype;
    if (!cached) this._uint16ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint16Array, ElementKind.CLASS_PROTOTYPE);
    return cached;
  }
  private _uint16ArrayPrototype: ClassPrototype | null = null;

  /** Gets the standard `Uint32Array` prototype. */
  get uint32ArrayPrototype(): ClassPrototype {
    var cached = this._uint32ArrayPrototype;
    if (!cached) this._uint32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint32Array, ElementKind.CLASS_PROTOTYPE);
    return cached;
  }
  private _uint32ArrayPrototype: ClassPrototype | null = null;

  /** Gets the standard `Uint64Array` prototype. */
  get uint64ArrayPrototype(): ClassPrototype {
    var cached = this._uint64ArrayPrototype;
    if (!cached) this._uint64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint64Array, ElementKind.CLASS_PROTOTYPE);
    return cached;
  }
  private _uint64ArrayPrototype: ClassPrototype | null = null;

  /** Gets the standard `Float32Array` prototype. */
  get float32ArrayPrototype(): ClassPrototype {
    var cached = this._float32ArrayPrototype;
    if (!cached) this._float32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Float32Array, ElementKind.CLASS_PROTOTYPE);
    return cached;
  }
  private _float32ArrayPrototype: ClassPrototype | null = null;

  /** Gets the standard `Float64Array` prototype. */
  get float64ArrayPrototype(): ClassPrototype {
    var cached = this._float64ArrayPrototype;
    if (!cached) this._float64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Float64Array, ElementKind.CLASS_PROTOTYPE);
    return cached;
  }
  private _float64ArrayPrototype: ClassPrototype | null = null;

  /** Gets the standard `String` instance. */
  get stringInstance(): Class {
    var cached = this._stringInstance;
    if (!cached) this._stringInstance = cached = this.requireClass(CommonNames.String);
    return cached;
  }
  private _stringInstance: Class | null = null;

  /** Gets the standard `Object` instance. */
  get objectInstance(): Class {
    var cached = this._objectInstance;
    if (!cached) this._objectInstance = cached = this.requireClass(CommonNames.Object);
    return cached;
  }
  private _objectInstance: Class | null = null;

  /** Gets the standard `TemplateStringsArray` instance. */
  get templateStringsArrayInstance(): Class {
    var cached = this._templateStringsArrayInstance;
    if (!cached) this._templateStringsArrayInstance = cached = this.requireClass(CommonNames.TemplateStringsArray);
    return cached;
  }
  private _templateStringsArrayInstance: Class | null = null;

  /** Gets the standard `abort` instance, if not explicitly disabled. */
  get abortInstance(): Function | null {
    var prototype = this.lookup(CommonNames.abort);
    if (!prototype || prototype.kind != ElementKind.FUNCTION_PROTOTYPE) return null;
    return this.resolver.resolveFunction(<FunctionPrototype>prototype, null);
  }

  // Runtime interface

  /** Gets the runtime `__alloc(size: usize): usize` instance. */
  get allocInstance(): Function {
    var cached = this._allocInstance;
    if (!cached) this._allocInstance = cached = this.requireFunction(CommonNames.alloc);
    return cached;
  }
  private _allocInstance: Function | null = null;

  /** Gets the runtime `__realloc(ptr: usize, newSize: usize): usize` instance. */
  get reallocInstance(): Function {
    var cached = this._reallocInstance;
    if (!cached) this._reallocInstance = cached = this.requireFunction(CommonNames.realloc);
    return cached;
  }
  private _reallocInstance: Function | null = null;

  /** Gets the runtime `__free(ptr: usize): void` instance. */
  get freeInstance(): Function {
    var cached = this._freeInstance;
    if (!cached) this._freeInstance = cached = this.requireFunction(CommonNames.free);
    return cached;
  }
  private _freeInstance: Function | null = null;

  /** Gets the runtime `__new(size: usize, id: u32): usize` instance. */
  get newInstance(): Function {
    var cached = this._newInstance;
    if (!cached) this._newInstance = cached = this.requireFunction(CommonNames.new_);
    return cached;
  }
  private _newInstance: Function | null = null;

  /** Gets the runtime `__renew(ptr: usize, size: usize): usize` instance. */
  get renewInstance(): Function {
    var cached = this._renewInstance;
    if (!cached) this._renewInstance = cached = this.requireFunction(CommonNames.renew);
    return cached;
  }
  private _renewInstance: Function | null = null;

  /** Gets the runtime `__link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void` instance. */
  get linkInstance(): Function {
    var cached = this._linkInstance;
    if (!cached) this._linkInstance = cached = this.requireFunction(CommonNames.link);
    return cached;
  }
  private _linkInstance: Function | null = null;

  /** Gets the runtime `__collect(): void` instance. */
  get collectInstance(): Function {
    var cached = this._collectInstance;
    if (!cached) this._collectInstance = cached = this.requireFunction(CommonNames.collect);
    return cached;
  }
  private _collectInstance: Function | null = null;

  /** Gets the runtime `__visit(ptr: usize, cookie: u32): void` instance. */
  get visitInstance(): Function {
    var cached = this._visitInstance;
    if (!cached) this._visitInstance = cached = this.requireFunction(CommonNames.visit);
    return cached;
  }
  private _visitInstance: Function | null = null;

  /** Gets the runtime `__typeinfo(id: u32): RTTIFlags` instance. */
  get typeinfoInstance(): Function {
    var cached = this._typeinfoInstance;
    if (!cached) this._typeinfoInstance = cached = this.requireFunction(CommonNames.typeinfo);
    return cached;
  }
  private _typeinfoInstance: Function | null = null;

  /** Gets the runtime `__instanceof(ptr: usize, superId: u32): bool` instance. */
  get instanceofInstance(): Function {
    var cached = this._instanceofInstance;
    if (!cached) this._instanceofInstance = cached = this.requireFunction(CommonNames.instanceof_);
    return cached;
  }
  private _instanceofInstance: Function | null = null;

  /** Gets the runtime `__newBuffer(size: usize, id: u32, data: usize = 0): usize` instance. */
  get newBufferInstance(): Function {
    var cached = this._newBufferInstance;
    if (!cached) this._newBufferInstance = cached = this.requireFunction(CommonNames.newBuffer);
    return cached;
  }
  private _newBufferInstance: Function | null = null;

  /** Gets the runtime `__newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize` instance. */
  get newArrayInstance(): Function {
    var cached = this._newArrayInstance;
    if (!cached) this._newArrayInstance = cached = this.requireFunction(CommonNames.newArray);
    return cached;
  }
  private _newArrayInstance: Function | null = null;

  /** Gets the runtime's internal `BLOCK` instance. */
  get BLOCKInstance(): Class {
    var cached = this._BLOCKInstance;
    if (!cached) this._BLOCKInstance = cached = this.requireClass(CommonNames.BLOCK);
    return cached;
  }
  private _BLOCKInstance: Class | null = null;

  /** Gets the runtime's internal `OBJECT` instance. */
  get OBJECTInstance(): Class {
    var cached = this._OBJECTInstance;
    if (!cached) this._OBJECTInstance = cached = this.requireClass(CommonNames.OBJECT);
    return cached;
  }
  private _OBJECTInstance: Class | null = null;

  // Utility

  /** Tests whether this is a WASI program. */
  get isWasi(): bool {
    return this.elementsByName.has(CommonNames.ASC_WASI);
  }

  /** Obtains the source matching the specified internal path. */
  getSource(internalPath: string): string | null {
    var sources = this.sources;
    for (let i = 0; i < sources.length; ++i) {
      let source = sources[i];
      if (source.internalPath == internalPath) return source.text;
    }
    return null;
  }

  /** Gets the overhead of a memory manager block. */
  get blockOverhead(): i32 {
    // BLOCK | data...
    //       ^ 16b alignment
    return this.BLOCKInstance.nextMemoryOffset;
  }

  /** Gets the overhead of a managed object, excl. block overhead, incl. alignment. */
  get objectOverhead(): i32 {
    // OBJECT+align | data...
    //        â”” 0 â”˜ ^ 16b alignment
    return (this.OBJECTInstance.nextMemoryOffset - this.blockOverhead + AL_MASK) & ~AL_MASK;
  }

  /** Gets the total overhead of a managed object, incl. block overhead. */
  get totalOverhead(): i32 {
    // BLOCK | OBJECT+align | data...
    // â””     = TOTAL      â”˜ ^ 16b alignment
    return this.blockOverhead + this.objectOverhead;
  }

  /** Computes the next properly aligned offset of a memory manager block, given the current bump offset. */
  computeBlockStart(currentOffset: i32): i32 {
    var blockOverhead = this.blockOverhead;
    return ((currentOffset + blockOverhead + AL_MASK) & ~AL_MASK) - blockOverhead;
  }

  /** Computes the next properly aligned offset of a memory manager block, given the current bump offset. */
  computeBlockStart64(currentOffset: i64): i64 {
    var blockOverhead = i64_new(this.blockOverhead);
    return i64_sub(i64_align(i64_add(currentOffset, blockOverhead), AL_SIZE), blockOverhead);
  }

  /** Computes the size of a memory manager block, excl. block overhead. */
  computeBlockSize(payloadSize: i32, isManaged: bool): i32 {
    // see: std/rt/tlsf.ts, computeSize; becomes mmInfo
    if (isManaged) payloadSize += this.objectOverhead;
    // we know that payload must be aligned, and that block sizes must be chosen
    // so that blocks are adjacent with the next payload aligned. hence, block
    // size is payloadSize rounded up to where the next block would start:
    var blockSize = this.computeBlockStart(payloadSize);
    // make sure that block size is valid according to TLSF requirements
    var blockOverhead = this.blockOverhead;
    var blockMinsize = ((3 * this.options.usizeType.byteSize + blockOverhead + AL_MASK) & ~AL_MASK) - blockOverhead;
    if (blockSize < blockMinsize) blockSize = blockMinsize;
    const blockMaxsize = 1 << 30; // 1 << (FL_BITS + SB_BITS - 1), exclusive
    const tagsMask = 3;
    if (blockSize >= blockMaxsize || (blockSize & tagsMask) != 0) {
      throw new Error("invalid block size");
    }
    return blockSize;
  }

  /** Creates a native variable declaration. */
  makeNativeVariableDeclaration(
    /** The simple name of the variable */
    name: string,
    /** Flags indicating specific traits, e.g. `CONST`. */
    flags: CommonFlags = CommonFlags.NONE
  ): VariableDeclaration {
    var range = this.nativeSource.range;
    return Node.createVariableDeclaration(
      Node.createIdentifierExpression(name, range),
      null, flags, null, null, range
    );
  }

  /** Creates a native type declaration. */
  makeNativeTypeDeclaration(
    /** The simple name of the type. */
    name: string,
    /** Flags indicating specific traits, e.g. `GENERIC`. */
    flags: CommonFlags = CommonFlags.NONE
  ): TypeDeclaration {
    var range = this.nativeSource.range;
    var identifier = Node.createIdentifierExpression(name, range);
    return Node.createTypeDeclaration(
      identifier,
      null, flags, null,
      Node.createOmittedType(range),
      range
    );
  }

  // a dummy signature for programmatically generated native functions
  private nativeDummySignature: FunctionTypeNode | null = null;

  /** Creates a native function declaration. */
  makeNativeFunctionDeclaration(
    /** The simple name of the function. */
    name: string,
    /** Flags indicating specific traits, e.g. `DECLARE`. */
    flags: CommonFlags = CommonFlags.NONE
  ): FunctionDeclaration {
    var range = this.nativeSource.range;
    var signature = this.nativeDummySignature;
    if (!signature) {
      this.nativeDummySignature = signature = Node.createFunctionType([],
        Node.createNamedType( // ^ AST signature doesn't really matter, is overridden anyway
          Node.createSimpleTypeName(CommonNames.void_, range),
          null, false, range
        ),
        null, false, range
      );
    }
    return Node.createFunctionDeclaration(
      Node.createIdentifierExpression(name, range),
      null, flags, null, signature, null, ArrowKind.NONE, range
    );
  }

  /** Creates a native namespace declaration. */
  makeNativeNamespaceDeclaration(
    /** The simple name of the namespace. */
    name: string,
    /** Flags indicating specific traits, e.g. `EXPORT`. */
    flags: CommonFlags = CommonFlags.NONE
  ): NamespaceDeclaration {
    var range = this.nativeSource.range;
    return Node.createNamespaceDeclaration(
      Node.createIdentifierExpression(name, range),
      null, flags, [], range
    );
  }

  /** Creates a native function. */
  makeNativeFunction(
    /** The simple name of the function. */
    name: string,
    /** Concrete function signature. */
    signature: Signature,
    /** Parent element, usually a file, class or namespace. */
    parent: Element = this.nativeFile,
    /** Flags indicating specific traits, e.g. `GENERIC`. */
    flags: CommonFlags = CommonFlags.NONE,
    /** Decorator flags representing built-in decorators. */
    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE
  ): Function {
    return new Function(
      name,
      new FunctionPrototype(
        name,
        parent,
        this.makeNativeFunctionDeclaration(name, flags),
        decoratorFlags
      ),
      null,
      signature
    );
  }

  /** Gets the (possibly merged) program element linked to the specified declaration. */
  getElementByDeclaration(declaration: DeclarationStatement): DeclaredElement | null {
    var elementsByDeclaration = this.elementsByDeclaration;
    return elementsByDeclaration.has(declaration)
      ? assert(elementsByDeclaration.get(declaration))
      : null;
  }

  /** Initializes the program and its elements prior to compilation. */
  initialize(): void {
    if (this.initialized) return;
    this.initialized = true;

    var options = this.options;

    // register native types
    this.registerNativeType(CommonNames.i8, Type.i8);
    this.registerNativeType(CommonNames.i16, Type.i16);
    this.registerNativeType(CommonNames.i32, Type.i32);
    this.registerNativeType(CommonNames.i64, Type.i64);
    this.registerNativeType(CommonNames.isize, options.isizeType);
    this.registerNativeType(CommonNames.u8, Type.u8);
    this.registerNativeType(CommonNames.u16, Type.u16);
    this.registerNativeType(CommonNames.u32, Type.u32);
    this.registerNativeType(CommonNames.u64, Type.u64);
    this.registerNativeType(CommonNames.usize, options.usizeType);
    this.registerNativeType(CommonNames.bool, Type.bool);
    this.registerNativeType(CommonNames.f32, Type.f32);
    this.registerNativeType(CommonNames.f64, Type.f64);
    this.registerNativeType(CommonNames.void_, Type.void);
    this.registerNativeType(CommonNames.number, Type.f64); // alias
    this.registerNativeType(CommonNames.boolean, Type.bool); // alias
    this.nativeFile.add(CommonNames.native, new TypeDefinition(
      CommonNames.native,
      this.nativeFile,
      this.makeNativeTypeDeclaration(CommonNames.native, CommonFlags.EXPORT | CommonFlags.GENERIC),
      DecoratorFlags.BUILTIN
    ));
    this.nativeFile.add(CommonNames.indexof, new TypeDefinition(
      CommonNames.indexof,
      this.nativeFile,
      this.makeNativeTypeDeclaration(CommonNames.indexof, CommonFlags.EXPORT | CommonFlags.GENERIC),
      DecoratorFlags.BUILTIN
    ));
    this.nativeFile.add(CommonNames.valueof, new TypeDefinition(
      CommonNames.valueof,
      this.nativeFile,
      this.makeNativeTypeDeclaration(CommonNames.valueof, CommonFlags.EXPORT | CommonFlags.GENERIC),
      DecoratorFlags.BUILTIN
    ));
    this.nativeFile.add(CommonNames.returnof, new TypeDefinition(
      CommonNames.returnof,
      this.nativeFile,
      this.makeNativeTypeDeclaration(CommonNames.returnof, CommonFlags.EXPORT | CommonFlags.GENERIC),
      DecoratorFlags.BUILTIN
    ));
    this.nativeFile.add(CommonNames.nonnull, new TypeDefinition(
      CommonNames.nonnull,
      this.nativeFile,
      this.makeNativeTypeDeclaration(CommonNames.nonnull, CommonFlags.EXPORT | CommonFlags.GENERIC),
      DecoratorFlags.BUILTIN
    ));

    // The following types might not be enabled by compiler options, so the
    // compiler needs to check this condition whenever such a value is created
    // respectively stored or loaded.
    this.registerNativeType(CommonNames.v128, Type.v128);
    this.registerNativeType(CommonNames.funcref, Type.funcref);
    this.registerNativeType(CommonNames.externref, Type.externref);
    this.registerNativeType(CommonNames.anyref, Type.anyref);
    this.registerNativeType(CommonNames.eqref, Type.eqref);
    this.registerNativeType(CommonNames.i31ref, Type.i31ref);
    this.registerNativeType(CommonNames.dataref, Type.dataref);

    // register compiler hints
    this.registerConstantInteger(CommonNames.ASC_TARGET, Type.i32,
      i64_new(options.isWasm64 ? Target.WASM64 : Target.WASM32));
    this.registerConstantInteger(CommonNames.ASC_NO_ASSERT, Type.bool,
      i64_new(options.noAssert ? 1 : 0, 0));
    this.registerConstantInteger(CommonNames.ASC_MEMORY_BASE, Type.i32,
      i64_new(options.memoryBase, 0));
    this.registerConstantInteger(CommonNames.ASC_TABLE_BASE, Type.i32,
      i64_new(options.tableBase, 0));
    this.registerConstantInteger(CommonNames.ASC_OPTIMIZE_LEVEL, Type.i32,
      i64_new(options.optimizeLevelHint, 0));
    this.registerConstantInteger(CommonNames.ASC_SHRINK_LEVEL, Type.i32,
      i64_new(options.shrinkLevelHint, 0));
    this.registerConstantInteger(CommonNames.ASC_LOW_MEMORY_LIMIT, Type.i32,
      i64_new(options.lowMemoryLimit, 0));
    this.registerConstantInteger(CommonNames.ASC_EXPORT_RUNTIME, Type.bool,
      i64_new(options.exportRuntime ? 1 : 0, 0));
    this.registerConstantInteger(CommonNames.ASC_VERSION_MAJOR, Type.i32,
      i64_new(options.bundleMajorVersion));
    this.registerConstantInteger(CommonNames.ASC_VERSION_MINOR, Type.i32,
      i64_new(options.bundleMinorVersion));
    this.registerConstantInteger(CommonNames.ASC_VERSION_PATCH, Type.i32,
      i64_new(options.bundlePatchVersion));

    // register feature hints
    this.registerConstantInteger(CommonNames.ASC_FEATURE_SIGN_EXTENSION, Type.bool,
      i64_new(options.hasFeature(Feature.SIGN_EXTENSION) ? 1 : 0, 0));
    this.registerConstantInteger(CommonNames.ASC_FEATURE_MUTABLE_GLOBALS, Type.bool,
      i64_new(options.hasFeature(Feature.MUTABLE_GLOBALS) ? 1 : 0, 0));
    this.registerConstantInteger(CommonNames.ASC_FEATURE_NONTRAPPING_F2I, Type.bool,
      i64_new(options.hasFeature(Feature.NONTRAPPING_F2I) ? 1 : 0, 0));
    this.registerConstantInteger(CommonNames.ASC_FEATURE_BULK_MEMORY, Type.bool,
      i64_new(options.hasFeature(Feature.BULK_MEMORY) ? 1 : 0, 0));
    this.registerConstantInteger(CommonNames.ASC_FEATURE_SIMD, Type.bool,
      i64_new(options.hasFeature(Feature.SIMD) ? 1 : 0, 0));
    this.registerConstantInteger(CommonNames.ASC_FEATURE_THREADS, Type.bool,
      i64_new(options.hasFeature(Feature.THREADS) ? 1 : 0, 0));
    this.registerConstantInteger(CommonNames.ASC_FEATURE_EXCEPTION_HANDLING, Type.bool,
      i64_new(options.hasFeature(Feature.EXCEPTION_HANDLING) ? 1 : 0, 0));
    this.registerConstantInteger(CommonNames.ASC_FEATURE_TAIL_CALLS, Type.bool,
      i64_new(options.hasFeature(Feature.TAIL_CALLS) ? 1 : 0, 0));
    this.registerConstantInteger(CommonNames.ASC_FEATURE_REFERENCE_TYPES, Type.bool,
      i64_new(options.hasFeature(Feature.REFERENCE_TYPES) ? 1 : 0, 0));
    this.registerConstantInteger(CommonNames.ASC_FEATURE_MULTI_VALUE, Type.bool,
      i64_new(options.hasFeature(Feature.MULTI_VALUE) ? 1 : 0, 0));
    this.registerConstantInteger(CommonNames.ASC_FEATURE_GC, Type.bool,
      i64_new(options.hasFeature(Feature.GC) ? 1 : 0, 0));
    this.registerConstantInteger(CommonNames.ASC_FEATURE_MEMORY64, Type.bool,
      i64_new(options.hasFeature(Feature.MEMORY64) ? 1 : 0, 0));

    // remember deferred elements
    var queuedImports = new Array<QueuedImport>();
    var queuedExports = new Map<File,Map<string,QueuedExport>>();
    var queuedExportsStar = new Map<File,QueuedExportStar[]>();
    var queuedExtends = new Array<ClassPrototype>();
    var queuedImplements = new Array<ClassPrototype>();

    // initialize relevant declaration-like statements of the entire program
    for (let i = 0, k = this.sources.length; i < k; ++i) {
      let source = this.sources[i];
      let file = new File(this, source);
      this.filesByName.set(file.internalName, file);
      let statements = source.statements;
      for (let j = 0, l = statements.length; j < l; ++j) {
        let statement = statements[j];
        switch (statement.kind) {
          case NodeKind.EXPORT: {
            this.initializeExports(<ExportStatement>statement, file, queuedExports, queuedExportsStar);
            break;
          }
          case NodeKind.EXPORTDEFAULT: {
            this.initializeExportDefault(<ExportDefaultStatement>statement, file, queuedExtends, queuedImplements);
            break;
          }
          case NodeKind.IMPORT: {
            this.initializeImports(<ImportStatement>statement, file, queuedImports, queuedExports);
            break;
          }
          case NodeKind.VARIABLE: {
            this.initializeVariables(<VariableStatement>statement, file);
            break;
          }
          case NodeKind.CLASSDECLARATION: {
            this.initializeClass(<ClassDeclaration>statement, file, queuedExtends, queuedImplements);
            break;
          }
          case NodeKind.ENUMDECLARATION: {
            this.initializeEnum(<EnumDeclaration>statement, file);
            break;
          }
          case NodeKind.FUNCTIONDECLARATION: {
            this.initializeFunction(<FunctionDeclaration>statement, file);
            break;
          }
          case NodeKind.INTERFACEDECLARATION: {
            this.initializeInterface(<InterfaceDeclaration>statement, file, queuedExtends);
            break;
          }
          case NodeKind.NAMESPACEDECLARATION: {
            this.initializeNamespace(<NamespaceDeclaration>statement, file, queuedExtends, queuedImplements);
            break;
          }
          case NodeKind.TYPEDECLARATION: {
            this.initializeTypeDefinition(<TypeDeclaration>statement, file);
            break;
          }
        }
      }
    }

    // queued exports * should be linkable now that all files have been processed
    // TODO: for (let [file, starExports] of queuedExportsStar) {
    for (let _keys = Map_keys(queuedExportsStar), i = 0, k = _keys.length; i < k; ++i) {
      let file = _keys[i];
      let starExports = assert(queuedExportsStar.get(file));
      for (let j = 0, l = starExports.length; j < l; ++j) {
        let exportStar = unchecked(starExports[j]);
        let foreignFile = this.lookupForeignFile(exportStar.foreignPath, exportStar.foreignPathAlt);
        if (!foreignFile) {
          this.error(
            DiagnosticCode.File_0_not_found,
            exportStar.pathLiteral.range, exportStar.pathLiteral.value
          );
          continue;
        }
        file.ensureExportStar(foreignFile);
      }
    }

    // queued imports should be resolvable now through traversing exports and queued exports.
    // note that imports may depend upon imports, so repeat until there's no more progress.
    do {
      let i = 0, madeProgress = false;
      while (i < queuedImports.length) {
        let queuedImport = queuedImports[i];
        let localIdentifier = queuedImport.localIdentifier;
        let foreignIdentifier = queuedImport.foreignIdentifier;
        // File must be found here, as it would otherwise already have been reported by the parser
        let foreignFile = assert(this.lookupForeignFile(queuedImport.foreignPath, queuedImport.foreignPathAlt));
        if (foreignIdentifier) { // i.e. import { foo [as bar] } from "./baz"
          let element = this.lookupForeign(
            foreignIdentifier.text,
            foreignFile,
            queuedExports
          );
          if (element) {
            queuedImport.localFile.add(
              localIdentifier.text,
              element,
              localIdentifier // isImport
            );
            queuedImports.splice(i, 1);
            madeProgress = true;
          } else {
            ++i;
          }
        } else { // i.e. import * as bar from "./bar"
          let localFile = queuedImport.localFile;
          let localName = localIdentifier.text;
          localFile.add(
            localName,
            foreignFile.asAliasNamespace(
              localName,
              localFile,
              localIdentifier
            ),
            localIdentifier // isImport
          );
          queuedImports.splice(i, 1);
          madeProgress = true;
        }
      }
      if (!madeProgress) {
        // report queued imports we were unable to resolve
        for (let j = 0, l = queuedImports.length; j < l; ++j) {
          let queuedImport = queuedImports[j];
          let foreignIdentifier = queuedImport.foreignIdentifier;
          if (foreignIdentifier) {
            this.error(
              DiagnosticCode.Module_0_has_no_exported_member_1,
              foreignIdentifier.range, queuedImport.foreignPath, foreignIdentifier.text
            );
          }
        }
        break;
      }
    } while (true);

    // queued exports should be resolvable now that imports are finalized
    // TODO: for (let [file, exports] of queuedExports) {
    for (let _keys = Map_keys(queuedExports), i = 0, k = _keys.length; i < k; ++i) {
      let file = unchecked(_keys[i]);
      let exports = assert(queuedExports.get(file));
      // TODO: for (let [exportName, queuedExport] of exports) {
      for (let exportNames = Map_keys(exports), j = 0, l = exportNames.length; j < l; ++j) {
        let exportName = unchecked(exportNames[j]);
        let queuedExport = assert(exports.get(exportName));
        let localName = queuedExport.localIdentifier.text;
        let foreignPath = queuedExport.foreignPath;
        if (foreignPath) { // i.e. export { foo [as bar] } from "./baz"
          // File must be found here, as it would otherwise already have been reported by the parser
          let foreignFile = assert(this.lookupForeignFile(foreignPath, assert(queuedExport.foreignPathAlt)));
          let element = this.lookupForeign(localName, foreignFile, queuedExports);
          if (element) {
            file.ensureExport(exportName, element);
          } else {
            this.error(
              DiagnosticCode.Module_0_has_no_exported_member_1,
              queuedExport.localIdentifier.range,
              foreignPath, localName
            );
          }
        } else { // i.e. export { foo [as bar] }
          let element = file.lookupInSelf(localName);
          if (element) {
            file.ensureExport(exportName, element);
          } else {
            let globalElement = this.lookup(localName);
            if (globalElement !== null && isDeclaredElement(globalElement.kind)) { // export { memory }
              file.ensureExport(exportName, <DeclaredElement>globalElement);
            } else {
              this.error(
                DiagnosticCode.Module_0_has_no_exported_member_1,
                queuedExport.foreignIdentifier.range,
                file.internalName, queuedExport.foreignIdentifier.text
              );
            }
          }
        }
      }
    }

    // register ArrayBuffer (id=0), String (id=1), ArrayBufferView (id=2)
    assert(this.arrayBufferInstance.id == 0);
    assert(this.stringInstance.id == 1);
    assert(this.arrayBufferViewInstance.id == 2);

    // register classes backing basic types
    this.registerWrapperClass(Type.i8, CommonNames.I8);
    this.registerWrapperClass(Type.i16, CommonNames.I16);
    this.registerWrapperClass(Type.i32, CommonNames.I32);
    this.registerWrapperClass(Type.i64, CommonNames.I64);
    this.registerWrapperClass(options.isizeType, CommonNames.Isize);
    this.registerWrapperClass(Type.u8, CommonNames.U8);
    this.registerWrapperClass(Type.u16, CommonNames.U16);
    this.registerWrapperClass(Type.u32, CommonNames.U32);
    this.registerWrapperClass(Type.u64, CommonNames.U64);
    this.registerWrapperClass(options.usizeType, CommonNames.Usize);
    this.registerWrapperClass(Type.bool, CommonNames.Bool);
    this.registerWrapperClass(Type.f32, CommonNames.F32);
    this.registerWrapperClass(Type.f64, CommonNames.F64);
    if (options.hasFeature(Feature.SIMD)) this.registerWrapperClass(Type.v128, CommonNames.V128);
    if (options.hasFeature(Feature.REFERENCE_TYPES)) {
      this.registerWrapperClass(Type.funcref, CommonNames.Funcref);
      this.registerWrapperClass(Type.externref, CommonNames.Externref);
      if (options.hasFeature(Feature.GC)) {
        this.registerWrapperClass(Type.anyref, CommonNames.Anyref);
        this.registerWrapperClass(Type.eqref, CommonNames.Eqref);
        this.registerWrapperClass(Type.i31ref, CommonNames.I31ref);
        this.registerWrapperClass(Type.dataref, CommonNames.Dataref);
      }
    }

    // resolve prototypes of extended classes or interfaces
    var resolver = this.resolver;
    for (let i = 0, k = queuedExtends.length; i < k; ++i) {
      let thisPrototype = queuedExtends[i];
      let extendsNode = assert(thisPrototype.extendsNode); // must be present if in queuedExtends
      let baseElement = resolver.resolveTypeName(extendsNode.name, thisPrototype.parent);
      if (!baseElement) continue;
      if (thisPrototype.kind == ElementKind.CLASS_PROTOTYPE) {
        if (baseElement.kind == ElementKind.CLASS_PROTOTYPE) {
          let basePrototype = <ClassPrototype>baseElement;
          if (basePrototype.hasDecorator(DecoratorFlags.FINAL)) {
            this.error(
              DiagnosticCode.Class_0_is_final_and_cannot_be_extended,
              extendsNode.range, basePrototype.identifierNode.text
            );
          }
          if (
            basePrototype.hasDecorator(DecoratorFlags.UNMANAGED) !=
            thisPrototype.hasDecorator(DecoratorFlags.UNMANAGED)
          ) {
            this.error(
              DiagnosticCode.Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa,
              Range.join(thisPrototype.identifierNode.range, extendsNode.range)
            );
          }
          thisPrototype.basePrototype = basePrototype;
        } else {
          this.error(
            DiagnosticCode.A_class_may_only_extend_another_class,
            extendsNode.range
          );
        }
      } else if (thisPrototype.kind == ElementKind.INTERFACE_PROTOTYPE) {
        if (baseElement.kind == ElementKind.INTERFACE_PROTOTYPE) {
          thisPrototype.basePrototype = <InterfacePrototype>baseElement;
        } else {
          this.error(
            DiagnosticCode.An_interface_can_only_extend_an_interface,
            extendsNode.range
          );
        }
      }
    }

    // resolve prototypes of implemented interfaces
    for (let i = 0, k = queuedImplements.length; i < k; ++i) {
      let thisPrototype = queuedImplements[i];
      let implementsNodes = assert(thisPrototype.implementsNodes); // must be present if in queuedImplements
      for (let j = 0, l = implementsNodes.length; j < l; ++j) {
        let implementsNode = implementsNodes[j];
        let interfaceElement = resolver.resolveTypeName(implementsNode.name, thisPrototype.parent);
        if (!interfaceElement) continue;
        if (interfaceElement.kind == ElementKind.INTERFACE_PROTOTYPE) {
          let interfacePrototype = <InterfacePrototype>interfaceElement;
          let interfacePrototypes = thisPrototype.interfacePrototypes;
          if (!interfacePrototypes) thisPrototype.interfacePrototypes = interfacePrototypes = new Array();
          interfacePrototypes.push(interfacePrototype);
        } else {
          this.error(
            DiagnosticCode.A_class_can_only_implement_an_interface,
            implementsNode.range
          );
        }
      }
    }

    // check for virtual overloads in extended classes and implemented interfaces
    for (let i = 0, k = queuedExtends.length; i < k; ++i) {
      let thisPrototype = queuedExtends[i];
      let basePrototype = thisPrototype.basePrototype;
      if (basePrototype) {
        this.markVirtuals(thisPrototype, basePrototype);
      }
    }
    for (let i = 0, k = queuedImplements.length; i < k; ++i) {
      let thisPrototype = queuedImplements[i];
      let basePrototype = thisPrototype.basePrototype;
      let interfacePrototypes = thisPrototype.interfacePrototypes;
      if (basePrototype) {
        this.markVirtuals(thisPrototype, basePrototype);
      }
      if (interfacePrototypes) {
        for (let j = 0, l = interfacePrototypes.length; j < l; ++j) {
          this.markVirtuals(thisPrototype, interfacePrototypes[j]);
        }
      }
    }

    // set up global aliases
    {
      let globalAliases = options.globalAliases;
      if (!globalAliases) globalAliases = new Map();
      let isWasi = this.isWasi;
      if (!globalAliases.has(CommonNames.abort)) {
        globalAliases.set(CommonNames.abort,
          isWasi
            ? BuiltinNames.wasiAbort
            : BuiltinNames.abort
        );
      }
      if (!globalAliases.has(CommonNames.trace)) {
        globalAliases.set(CommonNames.trace,
          isWasi
            ? BuiltinNames.wasiTrace
            : BuiltinNames.trace
        );
      }
      if (!globalAliases.has(CommonNames.seed)) {
        globalAliases.set(CommonNames.seed,
          isWasi
            ? BuiltinNames.wasiSeed
            : BuiltinNames.seed
        );
      }
      if (!globalAliases.has(CommonNames.Math)) {
        globalAliases.set(CommonNames.Math, CommonNames.NativeMath);
      }
      if (!globalAliases.has(CommonNames.Mathf)) {
        globalAliases.set(CommonNames.Mathf, CommonNames.NativeMathf);
      }
      // TODO: for (let [alias, name] of globalAliases) {
      for (let _keys = Map_keys(globalAliases), i = 0, k = _keys.length; i < k; ++i) {
        let alias = unchecked(_keys[i]);
        let name = changetype<string>(globalAliases.get(alias));
        assert(name != null);
        if (!name.length) {
          this.elementsByName.delete(alias);
          continue;
        }
        let firstChar = name.charCodeAt(0);
        if (firstChar >= CharCode._0 && firstChar <= CharCode._9) {
          this.registerConstantInteger(alias, Type.i32, i64_new(<i32>parseInt(name, 10)));
        } else {
          let elementsByName = this.elementsByName;
          if (elementsByName.has(name)) {
            elementsByName.set(alias, assert(elementsByName.get(name)));
          } else {
            throw new Error("no such global element: " + name);
          }
        }
      }
    }

    // mark module exports, i.e. to apply proper wrapping behavior on the boundaries
    // TODO: for (let file of this.filesByName.values()) {
    for (let _values = Map_values(this.filesByName), i = 0, k = _values.length; i < k; ++i) {
      let file = unchecked(_values[i]);
      if (file.source.sourceKind == SourceKind.USER_ENTRY) {
        this.markModuleExports(file);
      }
    }
  }

  /** Marks virtual members in a base class overloaded in this class. */
  private markVirtuals(thisPrototype: ClassPrototype, basePrototype: ClassPrototype): void {
    // TODO: make this work with interfaaces as well
    var thisInstanceMembers = thisPrototype.instanceMembers;
    if (thisInstanceMembers) {
      do {
        let baseInstanceMembers = basePrototype.instanceMembers;
        if (baseInstanceMembers) {
          for (let _values = Map_values(thisInstanceMembers), j = 0, l = _values.length; j < l; ++j) {
            let thisMember = _values[j];
            if (
              !thisMember.isAny(CommonFlags.CONSTRUCTOR | CommonFlags.PRIVATE) &&
              baseInstanceMembers.has(thisMember.name)
            ) {
              let baseMember = assert(baseInstanceMembers.get(thisMember.name));
              if (
                thisMember.kind == ElementKind.FUNCTION_PROTOTYPE &&
                baseMember.kind == ElementKind.FUNCTION_PROTOTYPE
              ) {
                let thisMethod = <FunctionPrototype>thisMember;
                let baseMethod = <FunctionPrototype>baseMember;
                if (!thisMethod.visibilityEquals(baseMethod)) {
                  this.errorRelated(
                    DiagnosticCode.Overload_signatures_must_all_be_public_private_or_protected,
                    thisMethod.identifierNode.range, baseMethod.identifierNode.range
                  );
                }
                baseMember.set(CommonFlags.VIRTUAL);
                let overloads = baseMethod.overloads;
                if (!overloads) baseMethod.overloads = overloads = new Set();
                overloads.add(<FunctionPrototype>thisMember);
                let baseMethodInstances = baseMethod.instances;
                if (baseMethodInstances) {
                  for (let _values = Map_values(baseMethodInstances), a = 0, b = _values.length; a < b; ++a) {
                    let baseMethodInstance = _values[a];
                    baseMethodInstance.set(CommonFlags.VIRTUAL);
                  }
                }
              } else if (
                thisMember.kind == ElementKind.PROPERTY_PROTOTYPE &&
                baseMember.kind == ElementKind.PROPERTY_PROTOTYPE
              ) {
                let thisProperty = <PropertyPrototype>thisMember;
                let baseProperty = <PropertyPrototype>baseMember;
                if (!thisProperty.visibilityEquals(baseProperty)) {
                  this.errorRelated(
                    DiagnosticCode.Overload_signatures_must_all_be_public_private_or_protected,
                    thisProperty.identifierNode.range, baseProperty.identifierNode.range
                  );
                }
                baseProperty.set(CommonFlags.VIRTUAL);
                let baseGetter = baseProperty.getterPrototype;
                if (baseGetter) {
                  baseGetter.set(CommonFlags.VIRTUAL);
                  let thisGetter = thisProperty.getterPrototype;
                  if (thisGetter) {
                    let overloads = baseGetter.overloads;
                    if (!overloads) baseGetter.overloads = overloads = new Set();
                    overloads.add(thisGetter);
                  }
                  let baseGetterInstances = baseGetter.instances;
                  if (baseGetterInstances) {
                    for (let _values = Map_values(baseGetterInstances), a = 0, b = _values.length; a < b; ++a) {
                      let baseGetterInstance = _values[a];
                      baseGetterInstance.set(CommonFlags.VIRTUAL);
                    }
                  }
                }
                let baseSetter = baseProperty.setterPrototype;
                if (baseSetter !== null && thisProperty.setterPrototype !== null) {
                  baseSetter.set(CommonFlags.VIRTUAL);
                  let thisSetter = thisProperty.setterPrototype;
                  if (thisSetter) {
                    let overloads = baseSetter.overloads;
                    if (!overloads) baseSetter.overloads = overloads = new Set();
                    overloads.add(thisSetter);
                  }
                  let baseSetterInstances = baseSetter.instances;
                  if (baseSetterInstances) {
                    for (let _values = Map_values(baseSetterInstances), a = 0, b = _values.length; a < b; ++a) {
                      let baseSetterInstance = _values[a];
                      baseSetterInstance.set(CommonFlags.VIRTUAL);
                    }
                  }
                }
              } else {
                this.errorRelated(
                  DiagnosticCode.Duplicate_identifier_0,
                  thisMember.identifierNode.range,
                  baseMember.identifierNode.range,
                  baseMember.identifierNode.text
                );
              }
            }
          }
        }
        let nextPrototype = basePrototype.basePrototype;
        if (!nextPrototype) break;
        basePrototype = nextPrototype;
      } while (true);
    }
  }

  /** Looks up the element of the specified name in the global scope. */
  lookup(name: string): Element | null {
    var elements = this.elementsByName;
    if (elements.has(name)) return assert(elements.get(name));
    return null;
  }

  /** Requires that a global library element of the specified kind is present and returns it. */
  private require(name: string, kind: ElementKind): Element {
    var element = this.lookup(name);
    if (!element) throw new Error("Missing standard library component: " + name);
    if (element.kind != kind) throw Error("Invalid standard library component kind: " + name);
    return element;
  }

  /** Requires that a global variable is present and returns it. */
  requireGlobal(name: string): Global {
    return <Global>this.require(name, ElementKind.GLOBAL);
  }

  /** Requires that a non-generic global class is present and returns it. */
  requireClass(name: string): Class {
    var prototype = this.require(name, ElementKind.CLASS_PROTOTYPE);
    var resolved = this.resolver.resolveClass(<ClassPrototype>prototype, null);
    if (!resolved) throw new Error("Invalid standard library class: " + name);
    return resolved;
  }

  /** Requires that a global function is present and returns it. */
  requireFunction(name: string, typeArguments: Type[] | null = null): Function {
    var prototype = <FunctionPrototype>this.require(name, ElementKind.FUNCTION_PROTOTYPE);
    var resolved = this.resolver.resolveFunction(prototype, typeArguments);
    if (!resolved) throw new Error("Invalid standard library function: " + name);
    return resolved;
  }

  /** Marks all exports of the specified file as module exports. */
  private markModuleExports(file: File): void {
    var exports = file.exports;
    if (exports) {
      // TODO: for (let element of exports.values()) {
      for (let _values = Map_values(exports), j = 0, l = _values.length; j < l; ++j) {
        let element = unchecked(_values[j]);
        this.markModuleExport(element);
      }
    }
    var exportsStar = file.exportsStar;
    if (exportsStar) {
      for (let i = 0, k = exportsStar.length; i < k; ++i) {
        this.markModuleExports(exportsStar[i]);
      }
    }
  }

  /** Marks an element and its children as a module export. */
  private markModuleExport(element: Element): void {
    element.set(CommonFlags.MODULE_EXPORT);
    switch (element.kind) {
      case ElementKind.CLASS_PROTOTYPE: {
        let instanceMembers = (<ClassPrototype>element).instanceMembers;
        if (instanceMembers) {
          // TODO: for (let member of instanceMembers.values()) {
          for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {
            let member = unchecked(_values[i]);
            this.markModuleExport(member);
          }
        }
        break;
      }
      case ElementKind.PROPERTY_PROTOTYPE: {
        let propertyPrototype = <PropertyPrototype>element;
        let getterPrototype = propertyPrototype.getterPrototype;
        if (getterPrototype) this.markModuleExport(getterPrototype);
        let setterPrototype = propertyPrototype.setterPrototype;
        if (setterPrototype) this.markModuleExport(setterPrototype);
        break;
      }
      case ElementKind.PROPERTY:
      case ElementKind.FUNCTION:
      case ElementKind.FIELD:
      case ElementKind.CLASS: assert(false); // assumes that there are no instances yet
    }
    var staticMembers = element.members;
    if (staticMembers) {
      // TODO: for (let member of staticMembers.values()) {
      for (let _values = Map_values(staticMembers), i = 0, k = _values.length; i < k; ++i) {
        let member = unchecked(_values[i]);
        this.markModuleExport(member);
      }
    }
  }

  /** Registers a native type with the program. */
  private registerNativeType(name: string, type: Type): void {
    var element = new TypeDefinition(
      name,
      this.nativeFile,
      this.makeNativeTypeDeclaration(name, CommonFlags.EXPORT),
      DecoratorFlags.BUILTIN
    );
    element.setType(type);
    this.nativeFile.add(name, element);
  }

  /** Registers the wrapper class of a non-class type. */
  private registerWrapperClass(type: Type, className: string): void {
    var wrapperClasses = this.wrapperClasses;
    assert(!type.isInternalReference && !wrapperClasses.has(type));
    var element = assert(this.lookup(className));
    assert(element.kind == ElementKind.CLASS_PROTOTYPE);
    var classElement = assert(this.resolver.resolveClass(<ClassPrototype>element, null));
    classElement.wrappedType = type;
    wrapperClasses.set(type, classElement);
  }

  /** Registers a constant integer value within the global scope. */
  registerConstantInteger(name: string, type: Type, value: i64): void {
    assert(type.isIntegerInclReference);
    var global = new Global(
      name,
      this.nativeFile,
      DecoratorFlags.NONE,
      this.makeNativeVariableDeclaration(name, CommonFlags.CONST | CommonFlags.EXPORT)
    );
    global.setConstantIntegerValue(value, type);
    this.nativeFile.add(name, global);
  }

  /** Registers a constant float value within the global scope. */
  private registerConstantFloat(name: string, type: Type, value: f64): void {
    assert(type.isFloatValue);
    var global = new Global(
      name,
      this.nativeFile,
      DecoratorFlags.NONE,
      this.makeNativeVariableDeclaration(name, CommonFlags.CONST | CommonFlags.EXPORT)
    );
    global.setConstantFloatValue(value, type);
    this.nativeFile.add(name, global);
  }

  /** Ensures that the given global element exists. Attempts to merge duplicates. */
  ensureGlobal(name: string, element: DeclaredElement): DeclaredElement {
    var elementsByName = this.elementsByName;
    if (elementsByName.has(name)) {
      let existing = assert(elementsByName.get(name));
      // NOTE: this is effectively only performed when merging native types with
      // their respective namespaces in std/builtins, but can also trigger when a
      // user has multiple global elements of the same name in different files,
      // which might result in unexpected shared symbols accross files. considering
      // this a wonky feature for now that we might want to revisit later.
      if (existing !== element) {
        let merged = tryMerge(existing, element);
        if (!merged) {
          if (isDeclaredElement(existing.kind)) {
            this.errorRelated(
              DiagnosticCode.Duplicate_identifier_0,
              element.identifierNode.range,
              (<DeclaredElement>existing).declaration.name.range,
              name
            );
          } else {
            this.error(
              DiagnosticCode.Duplicate_identifier_0,
              element.identifierNode.range, name
            );
          }
          return element;
        }
        element = merged;
      }
    }
    elementsByName.set(name, element);
    return element;
  }

  /** Tries to locate a foreign file given its normalized path. */
  private lookupForeignFile(
    /** Normalized path to the other file. */
    foreignPath: string,
    /** Alternative normalized path to the other file. */
    foreignPathAlt: string
  ): File | null {
    var filesByName = this.filesByName;
    return filesByName.has(foreignPath)
      ? assert(filesByName.get(foreignPath))
      : filesByName.has(foreignPathAlt)
        ? assert(filesByName.get(foreignPathAlt))
        : null;
  }

  /** Tries to locate a foreign element by traversing exports and queued exports. */
  private lookupForeign(
    /** Identifier within the other file. */
    foreignName: string,
    /** The other file. */
    foreignFile: File,
    /** So far queued exports. */
    queuedExports: Map<File,Map<string,QueuedExport>>
  ): DeclaredElement | null {
    do {
      // check if already resolved
      let element = foreignFile.lookupExport(foreignName);
      if (element) return element;

      // follow queued exports
      if (queuedExports.has(foreignFile)) {
        let fileQueuedExports = assert(queuedExports.get(foreignFile));
        if (fileQueuedExports.has(foreignName)) {
          let queuedExport = assert(fileQueuedExports.get(foreignName));
          let queuedExportForeignPath = queuedExport.foreignPath;

          // re-exported from another file
          if (queuedExportForeignPath) {
            let otherFile = this.lookupForeignFile(queuedExportForeignPath, assert(queuedExport.foreignPathAlt));
            if (!otherFile) return null;
            foreignName = queuedExport.localIdentifier.text;
            foreignFile = otherFile;
            continue;
          }

          // exported from this file
          element = foreignFile.lookupInSelf(queuedExport.localIdentifier.text);
          if (element) return element;
        }
      }
      break;
    } while (true);

    // follow star exports
    var exportsStar = foreignFile.exportsStar;
    if (exportsStar) {
      for (let i = 0, k = exportsStar.length; i < k; ++i) {
        let element = this.lookupForeign(foreignName, exportsStar[i], queuedExports);
        if (element) return element;
      }
    }
    return null;
  }

  /** Validates that only supported decorators are present. */
  private checkDecorators(
    /** Decorators present on an element. */
    decorators: DecoratorNode[] | null,
    /** Accepted decorator flags. Emits diagnostics if any other decorators are present. */
    acceptedFlags: DecoratorFlags
  ): DecoratorFlags {
    var flags = DecoratorFlags.NONE;
    if (decorators) {
      for (let i = 0, k = decorators.length; i < k; ++i) {
        let decorator = decorators[i];
        let kind = DecoratorKind.fromNode(decorator.name);
        let flag = DecoratorFlags.fromKind(kind);
        if (flag) {
          if (flag == DecoratorFlags.BUILTIN) {
            if (!(acceptedFlags & flag) && !decorator.range.source.isLibrary) {
              this.error(
                DiagnosticCode.Decorator_0_is_not_valid_here,
                decorator.range, decorator.name.range.toString()
              );
            } else {
              flags |= flag;
            }
          } else if (!(acceptedFlags & flag)) {
            this.error(
              DiagnosticCode.Decorator_0_is_not_valid_here,
              decorator.range, decorator.name.range.toString()
            );
          } else if (flags & flag) {
            this.error(
              DiagnosticCode.Duplicate_decorator,
              decorator.range
            );
          } else {
            flags |= flag;
          }
        }
      }
    }
    return flags;
  }

  /** Initializes a class declaration. */
  private initializeClass(
    /** The declaration to initialize. */
    declaration: ClassDeclaration,
    /** Parent element, usually a file or namespace. */
    parent: Element,
    /** So far queued `extends` clauses. */
    queuedExtends: ClassPrototype[],
    /** So far queued `implements` clauses. */
    queuedImplements: ClassPrototype[]
  ): ClassPrototype | null {
    var name = declaration.name.text;
    var element = new ClassPrototype(
      name,
      parent,
      declaration,
      this.checkDecorators(declaration.decorators,
        DecoratorFlags.GLOBAL |
        DecoratorFlags.FINAL |
        DecoratorFlags.UNMANAGED
      )
    );
    if (!parent.add(name, element)) return null;

    // remember classes that implement interfaces
    var implementsTypes = declaration.implementsTypes;
    if (implementsTypes) {
      let numImplementsTypes = implementsTypes.length;
      if (numImplementsTypes) {
        // cannot implement interfaces when unmanaged
        if (element.hasDecorator(DecoratorFlags.UNMANAGED)) {
          this.error(
            DiagnosticCode.Unmanaged_classes_cannot_implement_interfaces,
            Range.join(
              declaration.name.range,
              implementsTypes[numImplementsTypes - 1].range
            )
          );
        } else {
          queuedImplements.push(element);
        }
      }
    }

    // remember classes that extend another class
    if (declaration.extendsType) queuedExtends.push(element);

    // initialize members
    var memberDeclarations = declaration.members;
    for (let i = 0, k = memberDeclarations.length; i < k; ++i) {
      let memberDeclaration = memberDeclarations[i];
      switch (memberDeclaration.kind) {
        case NodeKind.FIELDDECLARATION: {
          this.initializeField(<FieldDeclaration>memberDeclaration, element);
          break;
        }
        case NodeKind.METHODDECLARATION: {
          let methodDeclaration = <MethodDeclaration>memberDeclaration;
          if (memberDeclaration.isAny(CommonFlags.GET | CommonFlags.SET)) {
            this.initializeProperty(methodDeclaration, element);
          } else {
            let method = this.initializeMethod(methodDeclaration, element);
            if (method !== null && methodDeclaration.name.kind == NodeKind.CONSTRUCTOR) {
              element.constructorPrototype = method;
            }
          }
          break;
        }
        case NodeKind.INDEXSIGNATURE: break; // ignored for now
        default: assert(false); // class member expected
      }
    }
    return element;
  }

  /** Initializes a field of a class or interface. */
  private initializeField(
    /** The declaration to initialize. */
    declaration: FieldDeclaration,
    /** Parent class. */
    parent: ClassPrototype
  ): void {
    var name = declaration.name.text;
    var decorators = declaration.decorators;
    var element: DeclaredElement;
    var acceptedFlags: DecoratorFlags = DecoratorFlags.UNSAFE;
    if (parent.is(CommonFlags.AMBIENT)) {
      acceptedFlags |= DecoratorFlags.EXTERNAL;
    }
    if (declaration.is(CommonFlags.STATIC)) { // global variable
      assert(parent.kind != ElementKind.INTERFACE_PROTOTYPE);
      acceptedFlags |= DecoratorFlags.LAZY;
      if (declaration.is(CommonFlags.READONLY)) {
        acceptedFlags |= DecoratorFlags.INLINE;
      }
      element = new Global(
        name,
        parent,
        this.checkDecorators(decorators, acceptedFlags),
        declaration
      );
      if (!parent.add(name, element)) return;
    } else { // actual instance field
      assert(!declaration.isAny(CommonFlags.ABSTRACT | CommonFlags.GET | CommonFlags.SET));
      element = new FieldPrototype(
        name,
        parent,
        declaration,
        this.checkDecorators(decorators, acceptedFlags)
      );
      if (!parent.addInstance(name, element)) return;
    }
  }

  /** Initializes a method of a class or interface. */
  private initializeMethod(
    /** The declaration to initialize. */
    declaration: MethodDeclaration,
    /** Parent class. */
    parent: ClassPrototype
  ): FunctionPrototype | null {
    var name = declaration.name.text;
    var isStatic = declaration.is(CommonFlags.STATIC);
    var acceptedFlags = DecoratorFlags.INLINE | DecoratorFlags.UNSAFE;
    if (!declaration.is(CommonFlags.GENERIC)) {
      acceptedFlags |= DecoratorFlags.OPERATOR_BINARY
                    |  DecoratorFlags.OPERATOR_PREFIX
                    |  DecoratorFlags.OPERATOR_POSTFIX;
    }
    if (parent.is(CommonFlags.AMBIENT)) {
      acceptedFlags |= DecoratorFlags.EXTERNAL;
    }
    var element = new FunctionPrototype(
      name,
      parent,
      declaration,
      this.checkDecorators(declaration.decorators, acceptedFlags)
    );
    if (isStatic) { // global function
      assert(declaration.name.kind != NodeKind.CONSTRUCTOR);
      if (!parent.add(name, element)) return null;
    } else { // actual instance method
      if (!parent.addInstance(name, element)) return null;
    }
    this.checkOperatorOverloads(declaration.decorators, element, parent);
    return element;
  }

  /** Checks that operator overloads are generally valid, if present. */
  private checkOperatorOverloads(
    /** Decorators to check. */
    decorators: DecoratorNode[] | null,
    /** Decorated method. */
    prototype: FunctionPrototype,
    /** Parent class. */
    classPrototype: ClassPrototype
  ): void {
    if (decorators) {
      for (let i = 0, k = decorators.length; i < k; ++i) {
        let decorator: DecoratorNode = decorators[i]; // FIXME: why does tsc want a type here?
        switch (decorator.decoratorKind) {
          case DecoratorKind.OPERATOR:
          case DecoratorKind.OPERATOR_BINARY:
          case DecoratorKind.OPERATOR_PREFIX:
          case DecoratorKind.OPERATOR_POSTFIX: {
            let args = decorator.args;
            let numArgs = args ? args.length : 0;
            if (numArgs == 1) {
              let firstArg = (<Expression[]>decorator.args)[0];
              if (firstArg.isLiteralKind(LiteralKind.STRING)) {
                let text = (<StringLiteralExpression>firstArg).value;
                let kind = OperatorKind.fromDecorator(decorator.decoratorKind, text);
                if (kind == OperatorKind.INVALID) {
                  this.error(
                    DiagnosticCode._0_is_not_a_valid_operator,
                    firstArg.range, text
                  );
                } else {
                  let overloads = classPrototype.overloadPrototypes;
                  if (overloads.has(kind)) {
                    this.error(
                      DiagnosticCode.Duplicate_function_implementation,
                      firstArg.range
                    );
                  } else {
                    prototype.operatorKind = kind;
                    overloads.set(kind, prototype);
                  }
                }
              } else {
                this.error(
                  DiagnosticCode.String_literal_expected,
                  firstArg.range
                );
              }
            } else {
              this.error(
                DiagnosticCode.Expected_0_arguments_but_got_1,
                decorator.range, "1", numArgs.toString()
              );
            }
          }
        }
      }
    }
  }

  /** Ensures that the property introduced by the specified getter or setter exists.*/
  private ensureProperty(
    /** The declaration of the getter or setter introducing the property. */
    declaration: MethodDeclaration,
    /** Parent class. */
    parent: ClassPrototype
  ): PropertyPrototype | null {
    var name = declaration.name.text;
    if (declaration.is(CommonFlags.STATIC)) {
      let parentMembers = parent.members;
      if (parentMembers !== null && parentMembers.has(name)) {
        let element = assert(parentMembers.get(name));
        if (element.kind == ElementKind.PROPERTY_PROTOTYPE) return <PropertyPrototype>element;
      } else {
        let element = new PropertyPrototype(name, parent, declaration);
        if (!parent.add(name, element)) return null;
        return element;
      }
    } else {
      let parentMembers = parent.instanceMembers;
      if (parentMembers !== null && parentMembers.has(name)) {
        let element = assert(parentMembers.get(name));
        if (element.kind == ElementKind.PROPERTY_PROTOTYPE) return <PropertyPrototype>element;
      } else {
        let element = new PropertyPrototype(name, parent, declaration);
        if (!parent.addInstance(name, element)) return null;
        return element;
      }
    }
    this.error(
      DiagnosticCode.Duplicate_property_0,
      declaration.name.range, name
    );
    return null;
  }

  /** Initializes a property of a class. */
  private initializeProperty(
    /** The declaration of the getter or setter. */
    declaration: MethodDeclaration,
    /** Parent class. */
    parent: ClassPrototype
  ): void {
    var property = this.ensureProperty(declaration, parent);
    if (!property) return;
    var name = declaration.name.text;
    var isGetter = declaration.is(CommonFlags.GET);
    if (isGetter) {
      if (property.getterPrototype) {
        this.error(
          DiagnosticCode.Duplicate_property_0,
          declaration.name.range, name
        );
        return;
      }
    } else {
      if (property.setterPrototype) {
        this.error(
          DiagnosticCode.Duplicate_property_0,
          declaration.name.range, name
        );
        return;
      }
    }
    var element = new FunctionPrototype(
      (isGetter ? GETTER_PREFIX : SETTER_PREFIX) + name,
      property,
      declaration,
      this.checkDecorators(declaration.decorators,
        DecoratorFlags.INLINE | DecoratorFlags.UNSAFE
      )
    );
    if (isGetter) {
      property.getterPrototype = element;
    } else {
      property.setterPrototype = element;
    }
  }

  /** Initializes an enum. */
  private initializeEnum(
    /** The declaration to initialize. */
    declaration: EnumDeclaration,
    /** Parent element, usually a file or namespace. */
    parent: Element
  ): Enum | null {
    var name = declaration.name.text;
    var element = new Enum(
      name,
      parent,
      declaration,
      this.checkDecorators(declaration.decorators,
        DecoratorFlags.GLOBAL |
        DecoratorFlags.INLINE |
        DecoratorFlags.LAZY
      )
    );
    if (!parent.add(name, element)) return null;
    var values = declaration.values;
    for (let i = 0, k = values.length; i < k; ++i) {
      this.initializeEnumValue(values[i], element);
    }
    return element;
  }

  /** Initializes an enum value. */
  private initializeEnumValue(
    /** The declaration to initialize. */
    declaration: EnumValueDeclaration,
    /** Parent enum. */
    parent: Enum
  ): void {
    var name = declaration.name.text;
    var element = new EnumValue(
      name,
      parent,
      declaration,
      this.checkDecorators(declaration.decorators,
        DecoratorFlags.NONE
      )
    );
    if (!parent.add(name, element)) return;
  }

  /** Initializes an `export` statement. */
  private initializeExports(
    /** The statement to initialize. */
    statement: ExportStatement,
    /** Parent file. */
    parent: File,
    /** So far queued `export`s. */
    queuedExports: Map<File,Map<string,QueuedExport>>,
    /** So far queued `export *`s. */
    queuedExportsStar: Map<File,QueuedExportStar[]>
  ): void {
    var members = statement.members;
    if (members) { // export { foo, bar } [from "./baz"]
      for (let i = 0, k = members.length; i < k; ++i) {
        this.initializeExport(members[i], parent, statement.internalPath, queuedExports);
      }
    } else { // export * from "./baz"
      let queued: QueuedExportStar[];
      if (queuedExportsStar.has(parent)) queued = assert(queuedExportsStar.get(parent));
      else queuedExportsStar.set(parent, queued = []);
      let foreignPath = statement.internalPath!; // must be set for export *
      queued.push(new QueuedExportStar(
        foreignPath,
        foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present
          ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)
          : foreignPath + INDEX_SUFFIX,
        assert(statement.path)
      ));
    }
  }

  /** Initializes a single `export` member. Does not handle `export *`. */
  private initializeExport(
    /** The member to initialize. */
    member: ExportMember,
    /** Local file. */
    localFile: File,
    /** Path to the other file, if present. */
    foreignPath: string | null,
    /** So far queued `export`s. */
    queuedExports: Map<File,Map<string,QueuedExport>>
  ): void {
    var localName = member.localName.text;
    var foreignName = member.exportedName.text;

    // check for duplicates
    var element = localFile.lookupExport(foreignName);
    if (element) {
      this.error(
        DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0,
        member.exportedName.range, foreignName
      );
      return;
    }
    // local element, i.e. export { foo [as bar] }
    if (foreignPath === null) {

      // resolve right away if the local element already exists
      if (element = localFile.lookupInSelf(localName)) {
        localFile.ensureExport(foreignName, element);

      // otherwise queue it
      } else {
        let queued: Map<string,QueuedExport>;
        if (queuedExports.has(localFile)) queued = assert(queuedExports.get(localFile));
        else queuedExports.set(localFile, queued = new Map());
        queued.set(foreignName, new QueuedExport(
          member.localName,
          member.exportedName,
          null, null
        ));
      }

    // foreign element, i.e. export { foo } from "./bar"
    } else {
      let queued: Map<string,QueuedExport>;
      if (queuedExports.has(localFile)) queued = assert(queuedExports.get(localFile));
      else queuedExports.set(localFile, queued = new Map());
      queued.set(foreignName, new QueuedExport(
        member.localName,
        member.exportedName,
        foreignPath,
        foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present
          ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)
          : foreignPath + INDEX_SUFFIX
      ));
    }
  }

  private initializeExportDefault(
    /** The statement to initialize. */
    statement: ExportDefaultStatement,
    /** Parent file. */
    parent: File,
    /** So far queued `extends` clauses. */
    queuedExtends: Array<ClassPrototype>,
    /** So far queued `implements` clauses. */
    queuedImplements: ClassPrototype[]
  ): void {
    var declaration = statement.declaration;
    var element: DeclaredElement | null = null;
    switch (declaration.kind) {
      case NodeKind.ENUMDECLARATION: {
        element = this.initializeEnum(<EnumDeclaration>declaration, parent);
        break;
      }
      case NodeKind.FUNCTIONDECLARATION: {
        element = this.initializeFunction(<FunctionDeclaration>declaration, parent);
        break;
      }
      case NodeKind.CLASSDECLARATION: {
        element = this.initializeClass(<ClassDeclaration>declaration, parent, queuedExtends, queuedImplements);
        break;
      }
      case NodeKind.INTERFACEDECLARATION: {
        element = this.initializeInterface(<InterfaceDeclaration>declaration, parent, queuedExtends);
        break;
      }
      case NodeKind.NAMESPACEDECLARATION: {
        element = this.initializeNamespace(<NamespaceDeclaration>declaration, parent, queuedExtends, queuedImplements);
        break;
      }
      default: assert(false);
    }
    if (element) {
      let exports = parent.exports;
      if (!exports) parent.exports = exports = new Map();
      else {
        if (exports.has("default")) {
          let existing = assert(exports.get("default"));
          this.errorRelated(
            DiagnosticCode.Duplicate_identifier_0,
            declaration.name.range,
            existing.declaration.name.range,
            "default"
          );
          return;
        }
      }
      exports.set("default", element);
    }
  }

  /** Initializes an `import` statement. */
  private initializeImports(
    /** The statement to initialize. */
    statement: ImportStatement,
    /** Parent file. */
    parent: File,
    /** So far queued `import`s. */
    queuedImports: QueuedImport[],
    /** So far queued `export`s. */
    queuedExports: Map<File,Map<string,QueuedExport>>
  ): void {
    var declarations = statement.declarations;
    if (declarations) { // import { foo [as bar] } from "./baz"
      for (let i = 0, k = declarations.length; i < k; ++i) {
        this.initializeImport(
          declarations[i],
          parent,
          statement.internalPath,
          queuedImports,
          queuedExports
        );
      }
    } else {
      let namespaceName = statement.namespaceName;
      if (namespaceName) { // import * as foo from "./bar"
        queuedImports.push(new QueuedImport(
          parent,
          namespaceName,
          null, // indicates import *
          statement.internalPath,
          statement.internalPath + INDEX_SUFFIX
        ));
      } else {
        // import "./foo"
      }
    }
  }

  /** Initializes a single `import` declaration. Does not handle `import *`. */
  private initializeImport( // { foo [as bar] }
    /** The declaration to initialize. */
    declaration: ImportDeclaration,
    /** Parent file. */
    parent: File,
    /** Path to the other file. */
    foreignPath: string,
    /** So far queued `import`s. */
    queuedImports: QueuedImport[],
    /** So far queued `export`s. */
    queuedExports: Map<File,Map<string,QueuedExport>>
  ): void {
    var foreignPathAlt = foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present
      ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)
      : foreignPath + INDEX_SUFFIX;

    // resolve right away if the element exists
    var foreignFile = this.lookupForeignFile(foreignPath, foreignPathAlt);
    if (foreignFile) {
      var element = this.lookupForeign(declaration.foreignName.text, foreignFile, queuedExports);
      if (element) {
        parent.add(declaration.name.text, element, declaration.name /* isImport */);
        return;
      }
    }

    // otherwise queue it
    queuedImports.push(new QueuedImport(
      parent,
      declaration.name,
      declaration.foreignName,
      foreignPath,
      foreignPathAlt
    ));
  }

  /** Initializes a function. Does not handle methods. */
  private initializeFunction(
    /** The declaration to initialize. */
    declaration: FunctionDeclaration,
    /** Parent element, usually a file or namespace. */
    parent: Element
  ): FunctionPrototype | null {
    var name = declaration.name.text;
    var validDecorators = DecoratorFlags.UNSAFE | DecoratorFlags.BUILTIN;
    if (declaration.is(CommonFlags.AMBIENT)) {
      validDecorators |= DecoratorFlags.EXTERNAL;
    } else {
      validDecorators |= DecoratorFlags.INLINE;
      if (declaration.range.source.isLibrary || declaration.is(CommonFlags.EXPORT)) {
        validDecorators |= DecoratorFlags.LAZY;
      }
    }
    if (!declaration.is(CommonFlags.INSTANCE)) {
      if (parent.kind != ElementKind.CLASS_PROTOTYPE) {
        validDecorators |= DecoratorFlags.GLOBAL;
      }
    }
    var element = new FunctionPrototype(
      name,
      parent,
      declaration,
      this.checkDecorators(declaration.decorators, validDecorators)
    );
    if (!parent.add(name, element)) return null;
    return element;
  }

  /** Initializes an interface. */
  private initializeInterface(
    /** The declaration to initialize. */
    declaration: InterfaceDeclaration,
    /** Parent element, usually a file or namespace. */
    parent: Element,
    /** So far queued `extends` clauses. */
    queuedExtends: ClassPrototype[],
  ): InterfacePrototype | null {
    var name = declaration.name.text;
    var element = new InterfacePrototype(
      name,
      parent,
      declaration,
      this.checkDecorators(declaration.decorators,
        DecoratorFlags.GLOBAL
      )
    );
    if (!parent.add(name, element)) return null;

    // remember interfaces that extend another interface
    if (declaration.extendsType) queuedExtends.push(element);

    var memberDeclarations = declaration.members;
    for (let i = 0, k = memberDeclarations.length; i < k; ++i) {
      let memberDeclaration = memberDeclarations[i];
      switch (memberDeclaration.kind) {
        case NodeKind.FIELDDECLARATION: {
          this.initializeFieldAsProperty(<FieldDeclaration>memberDeclaration, element);
          break;
        }
        case NodeKind.METHODDECLARATION: {
          let methodDeclaration = <MethodDeclaration>memberDeclaration;
          if (memberDeclaration.isAny(CommonFlags.GET | CommonFlags.SET)) {
            this.initializeProperty(methodDeclaration, element);
          } else {
            this.initializeMethod(methodDeclaration, element);
          }
          break;
        }
        default: assert(false); // interface member expected
      }
    }
    return element;
  }

  /** Initializes a field of an interface, as a property. */
  private initializeFieldAsProperty(
    /** Field declaration. */
    declaration: FieldDeclaration,
    /** Parent interface. */
    parent: InterfacePrototype
  ): void {
    var typeNode = declaration.type;
    if (!typeNode) typeNode = Node.createOmittedType(declaration.name.range.atEnd);
    this.initializeProperty(
      Node.createMethodDeclaration(
        declaration.name,
        declaration.decorators,
        declaration.flags | CommonFlags.GET,
        null,
        Node.createFunctionType(
          [],
          typeNode,
          null,
          false,
          declaration.range
        ),
        null,
        declaration.range
      ),
      parent
    );
    if (!declaration.is(CommonFlags.READONLY)) {
      this.initializeProperty(
        Node.createMethodDeclaration(
          declaration.name,
          declaration.decorators,
          declaration.flags | CommonFlags.SET,
          null,
          Node.createFunctionType(
            [
              Node.createParameter(
                ParameterKind.DEFAULT,
                declaration.name,
                typeNode,
                null,
                declaration.name.range
              )
            ],
            Node.createOmittedType(declaration.name.range.atEnd),
            null,
            false,
            declaration.range
          ),
          null,
          declaration.range
        ),
        parent
      );
    }
  }

  /** Initializes a namespace. */
  private initializeNamespace(
    /** The declaration to initialize. */
    declaration: NamespaceDeclaration,
    /** Parent element, usually a file or another namespace. */
    parent: Element,
    /** So far queued `extends` clauses. */
    queuedExtends: ClassPrototype[],
    /** So far queued `implements` clauses. */
    queuedImplements: ClassPrototype[]
  ): DeclaredElement | null {
    var name = declaration.name.text;
    var original = new Namespace(
      name,
      parent,
      declaration,
      this.checkDecorators(declaration.decorators, DecoratorFlags.GLOBAL)
    );
    if (!parent.add(name, original)) return null;
    var element = assert(parent.lookupInSelf(name)); // possibly merged
    var members = declaration.members;
    for (let i = 0, k = members.length; i < k; ++i) {
      let member = members[i];
      switch (member.kind) {
        case NodeKind.CLASSDECLARATION: {
          this.initializeClass(<ClassDeclaration>member, original, queuedExtends, queuedImplements);
          break;
        }
        case NodeKind.ENUMDECLARATION: {
          this.initializeEnum(<EnumDeclaration>member, original);
          break;
        }
        case NodeKind.FUNCTIONDECLARATION: {
          this.initializeFunction(<FunctionDeclaration>member, original);
          break;
        }
        case NodeKind.INTERFACEDECLARATION: {
          this.initializeInterface(<InterfaceDeclaration>member, original, queuedExtends);
          break;
        }
        case NodeKind.NAMESPACEDECLARATION: {
          this.initializeNamespace(<NamespaceDeclaration>member, original, queuedExtends, queuedImplements);
          break;
        }
        case NodeKind.TYPEDECLARATION: {
          this.initializeTypeDefinition(<TypeDeclaration>member, original);
          break;
        }
        case NodeKind.VARIABLE: {
          this.initializeVariables(<VariableStatement>member, original);
          break;
        }
        default: assert(false); // namespace member expected
      }
    }
    if (original != element) copyMembers(original, element); // keep original parent
    return element;
  }

  /** Initializes a `type` definition. */
  private initializeTypeDefinition(
    /** The declaration to initialize. */
    declaration: TypeDeclaration,
    /** Parent element, usually a file or namespace. */
    parent: Element
  ): void {
    var name = declaration.name.text;
    var element = new TypeDefinition(
      name,
      parent,
      declaration,
      this.checkDecorators(declaration.decorators, DecoratorFlags.NONE)
    );
    parent.add(name, element); // reports
  }

  /** Initializes a variable statement. */
  private initializeVariables(
    /** The statement to initialize. */
    statement: VariableStatement,
    /** Parent element, usually a file or namespace. */
    parent: Element
  ): void {
    var declarations = statement.declarations;
    for (let i = 0, k = declarations.length; i < k; ++i) {
      let declaration = declarations[i];
      let name = declaration.name.text;
      let acceptedFlags = DecoratorFlags.GLOBAL | DecoratorFlags.LAZY;
      if (declaration.is(CommonFlags.DECLARE)) {
        acceptedFlags |= DecoratorFlags.EXTERNAL;
      }
      if (declaration.is(CommonFlags.CONST)) {
        acceptedFlags |= DecoratorFlags.INLINE;
      }
      let element = new Global(
        name,
        parent,
        this.checkDecorators(declaration.decorators, acceptedFlags),
        declaration
      );
      if (!parent.add(name, element)) continue; // reports
    }
  }

  /** Determines the element type of a built-in array. */
  // determineBuiltinArrayType(target: Class): Type | null {
  //   switch (target.internalName) {
  //     case BuiltinSymbols.Int8Array: return Type.i8;
  //     case BuiltinSymbols.Uint8ClampedArray:
  //     case BuiltinSymbols.Uint8Array: return Type.u8;
  //     case BuiltinSymbols.Int16Array: return Type.i16;
  //     case BuiltinSymbols.Uint16Array: return Type.u16;
  //     case BuiltinSymbols.Int32Array: return Type.i32;
  //     case BuiltinSymbols.Uint32Array: return Type.u32;
  //     case BuiltinSymbols.Int64Array: return Type.i64;
  //     case BuiltinSymbols.Uint64Array: return Type.u64;
  //     case BuiltinSymbols.Float32Array: return Type.f32;
  //     case BuiltinSymbols.Float64Array: return Type.f64;
  //   }
  //   var current: Class | null = target;
  //   var arrayPrototype = this.arrayPrototype;
  //   do {
  //     if (current.prototype == arrayPrototype) { // Array<T>
  //       let typeArguments = assert(current.typeArguments);
  //       assert(typeArguments.length == 1);
  //       return typeArguments[0];
  //     }
  //   } while (current = current.base);
  //   return null;
  // }
}

/** Indicates the specific kind of an {@link Element}. */
export enum ElementKind {
  /** A {@link Global}. */
  GLOBAL,
  /** A {@link Local}. */
  LOCAL,
  /** An {@link Enum}. */
  ENUM,
  /** An {@link EnumValue}. */
  ENUMVALUE,
  /** A {@link FunctionPrototype}. */
  FUNCTION_PROTOTYPE,
  /** A {@link Function}. */
  FUNCTION,
  /** A {@link ClassPrototype}. */
  CLASS_PROTOTYPE,
  /** A {@link Class}. */
  CLASS,
  /** An {@link InterfacePrototype}. */
  INTERFACE_PROTOTYPE,
  /** An {@link Interface}. */
  INTERFACE,
  /** A {@link FieldPrototype}. */
  FIELD_PROTOTYPE,
  /** A {@link Field}. */
  FIELD,
  /** A {@link PropertyPrototype}.  */
  PROPERTY_PROTOTYPE,
  /** A {@link Property}. */
  PROPERTY,
  /** A {@link Namespace}. */
  NAMESPACE,
  /** A {@link File}. */
  FILE,
  /** A {@link TypeDefinition}.  */
  TYPEDEFINITION,
  /** An {@link IndexSignature}. */
  INDEXSIGNATURE
}

/** Indicates built-in decorators that are present. */
export enum DecoratorFlags {
  /** No flags set. */
  NONE = 0,
  /** Is a program global. */
  GLOBAL = 1 << 0,
  /** Is a binary operator overload. */
  OPERATOR_BINARY = 1 << 1,
  /** Is a unary prefix operator overload. */
  OPERATOR_PREFIX = 1 << 2,
  /** Is a unary postfix operator overload. */
  OPERATOR_POSTFIX = 1 << 3,
  /** Is an unmanaged class. */
  UNMANAGED = 1 << 4,
  /** Is a final class. */
  FINAL = 1 << 5,
  /** Is always inlined. */
  INLINE = 1 << 6,
  /** Is using a different external name. */
  EXTERNAL = 1 << 7,
  /** Is a builtin. */
  BUILTIN = 1 << 8,
  /** Is compiled lazily. */
  LAZY = 1 << 9,
  /** Is considered unsafe code. */
  UNSAFE = 1 << 10
}

export namespace DecoratorFlags {

  /** Translates a decorator kind to the respective decorator flag. */
  export function fromKind(kind: DecoratorKind): DecoratorFlags {
    switch (kind) {
      case DecoratorKind.GLOBAL: return DecoratorFlags.GLOBAL;
      case DecoratorKind.OPERATOR:
      case DecoratorKind.OPERATOR_BINARY: return DecoratorFlags.OPERATOR_BINARY;
      case DecoratorKind.OPERATOR_PREFIX: return DecoratorFlags.OPERATOR_PREFIX;
      case DecoratorKind.OPERATOR_POSTFIX: return DecoratorFlags.OPERATOR_POSTFIX;
      case DecoratorKind.UNMANAGED: return DecoratorFlags.UNMANAGED;
      case DecoratorKind.FINAL: return DecoratorFlags.FINAL;
      case DecoratorKind.INLINE: return DecoratorFlags.INLINE;
      case DecoratorKind.EXTERNAL: return DecoratorFlags.EXTERNAL;
      case DecoratorKind.BUILTIN: return DecoratorFlags.BUILTIN;
      case DecoratorKind.LAZY: return DecoratorFlags.LAZY;
      case DecoratorKind.UNSAFE: return DecoratorFlags.UNSAFE;
      default: return DecoratorFlags.NONE;
    }
  }
}

/** Base class of all program elements. */
export abstract class Element {

  /** Parent element. */
  parent!: Element;
  /** Common flags indicating specific traits. */
  flags: CommonFlags = CommonFlags.NONE;
  /** Decorator flags indicating annotated traits. */
  decoratorFlags: DecoratorFlags = DecoratorFlags.NONE;
  /** Member elements. */
  members: Map<string,DeclaredElement> | null = null;
  /** Shadowing type in type space, if any. */
  shadowType: TypeDefinition | null = null;

  /** Constructs a new program element. */
  protected constructor(
    /** Specific element kind. */
    public kind: ElementKind,
    /** Simple name. */
    public name: string,
    /** Internal name referring to this element. */
    public internalName: string,
    /** Containing {@link Program}. */
    public program: Program,
    /** Parent element. */
    parent: Element | null
  ) {
    this.program = program;
    this.name = name;
    this.internalName = internalName;
    if (parent) {
      this.parent = parent;
    } else {
      assert(this.kind == ElementKind.FILE);
      this.parent = this; // special case to keep this.parent non-nullable
    }
  }

  /** Gets the enclosing file. */
  get file(): File {
    var current: Element = this;
    do {
      current = current.parent;
      if (current.kind == ElementKind.FILE) return <File>current;
    } while (true);
  }

  /** Tests if this element has a specific flag or flags. */
  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }
  /** Tests if this element has any of the specified flags. */
  isAny(flags: CommonFlags): bool { return (this.flags & flags) != 0; }
  /** Sets a specific flag or flags. */
  set(flag: CommonFlags): void { this.flags |= flag; }
  /** Unsets the specific flag or flags. */
  unset(flag: CommonFlags): void {this.flags &= ~flag; }
  /** Tests if this element has a specific decorator flag or flags. */
  hasDecorator(flag: DecoratorFlags): bool { return (this.decoratorFlags & flag) == flag; }

  /** Looks up the element with the specified name within this element. */
  lookupInSelf(name: string): DeclaredElement | null {
    var members = this.members;
    if (members !== null && members.has(name)) return assert(members.get(name));
    return null;
  }

  /** Looks up the element with the specified name relative to this element, like in JS. */
  abstract lookup(name: string): Element | null;

  /** Adds an element as a member of this one. Reports and returns `false` if a duplicate. */
  add(name: string, element: DeclaredElement, localIdentifierIfImport: IdentifierExpression | null = null): bool {
    var originalDeclaration = element.declaration;
    var members = this.members;
    if (!members) this.members = members = new Map();
    else if (members.has(name)) {
      let existing = assert(members.get(name));
      if (existing.parent !== this) {
        // override non-own element
      } else {
        let merged = tryMerge(existing, element);
        if (merged) {
          element = merged; // use merged element
        } else {
          let reportedIdentifier = localIdentifierIfImport
            ? localIdentifierIfImport
            : element.identifierNode;
          if (isDeclaredElement(existing.kind)) {
            this.program.errorRelated(
              DiagnosticCode.Duplicate_identifier_0,
              reportedIdentifier.range,
              (<DeclaredElement>existing).identifierNode.range,
              reportedIdentifier.text
            );
          } else {
            this.program.error(
              DiagnosticCode.Duplicate_identifier_0,
              reportedIdentifier.range, reportedIdentifier.text
            );
          }
          return false;
        }
      }
    }
    members.set(name, element);
    var program = this.program;
    if (element.kind != ElementKind.FUNCTION_PROTOTYPE || !(<FunctionPrototype>element).isBound) {
      // prefer unbound prototypes in global lookup maps
      program.elementsByName.set(element.internalName, element);
      program.elementsByDeclaration.set(originalDeclaration, element);
    }
    return true;
  }

  /** Checks if this element is public, explicitly or implicitly. */
  get isPublic(): bool {
    return !this.isAny(CommonFlags.PRIVATE | CommonFlags.PROTECTED);
  }

  /** Checks if this element is implicitly public, i.e. not explicitly declared to be. */
  get isImplicitlyPublic(): bool {
    return this.isPublic && !this.is(CommonFlags.PUBLIC);
  }

  /** Checks if the visibility of this element equals the specified. */
  visibilityEquals(other: Element): bool {
    if (this.isPublic == other.isPublic) return true;
    const vis = CommonFlags.PRIVATE | CommonFlags.PROTECTED;
    return (this.flags & vis) == (other.flags & vis);
  }

  /** Returns a string representation of this element. */
  toString(): string {
    return this.internalName + ", kind=" + this.kind.toString();
  }
}

// Kinds of all declared elements
var declaredElements = new Set<ElementKind>();

/** Tests if the specified element kind indicates a declared element. */
export function isDeclaredElement(kind: ElementKind): bool {
  return declaredElements.has(kind);
}

/** Base class of elements with an associated declaration statement. */
export abstract class DeclaredElement extends Element {

  /** Constructs a new declared program element. */
  protected constructor(
    /** Specific element kind. */
    kind: ElementKind,
    /** Simple name. */
    name: string,
    /** Internal name referring to this element. */
    internalName: string,
    /** Containing {@link Program}. */
    program: Program,
    /** Parent element. */
    parent: Element | null,
    /** Declaration reference. */
    public declaration: DeclarationStatement
  ) {
    super(kind, name, internalName, program, parent);
    declaredElements.add(kind);
    // It is necessary to have access to identifiers of all members and exports
    // for reporting purposes and this is the lowest common denominator. Comes
    // at the expense of not having more specific type information in derived
    // classes, though. Instead, derived classes implement getters for other
    // important AST nodes directly through manual casting, allowing the resolver
    // etc. to not worry about actual declarations.
    this.declaration = declaration;
    this.flags = declaration.flags; // inherit
  }

  /** Tests if this element is a library element. */
  get isDeclaredInLibrary(): bool {
    return this.declaration.range.source.isLibrary;
  }

  /** Gets the associated identifier node. */
  get identifierNode(): IdentifierExpression {
    return this.declaration.name;
  }

  /** Gets the signature node, if applicable, along the identifier node. */
  get identifierAndSignatureRange(): Range {
    var declaration = this.declaration;
    var identifierNode = declaration.name;
    if (declaration.kind == NodeKind.FUNCTIONDECLARATION || declaration.kind == NodeKind.METHODDECLARATION) {
      let signatureNode = (<FunctionDeclaration>declaration).signature;
      return Range.join(identifierNode.range, signatureNode.range);
    }
    return identifierNode.range;
  }

  /** Gets the assiciated decorator nodes. */
  get decoratorNodes(): DecoratorNode[] | null {
    return this.declaration.decorators;
  }

  /** Checks if this element is a compatible override of the specified. */
  isCompatibleOverride(base: DeclaredElement): bool {
    var self: DeclaredElement = this; // TS
    var kind = self.kind;
    if (kind == base.kind) {
      switch (kind) {
        case ElementKind.FUNCTION: {
          return (<Function>self).signature.isAssignableTo((<Function>base).signature, /* sameSize */ true);
        }
        case ElementKind.PROPERTY: {
          let selfProperty = <Property>self;
          let baseProperty = <Property>base;
          let selfGetter = selfProperty.getterInstance;
          let baseGetter = baseProperty.getterInstance;
          if (selfGetter) {
            if (!baseGetter || !selfGetter.signature.isAssignableTo(baseGetter.signature, true)) {
              return false;
            }
          } else if (baseGetter) {
            return false;
          }
          let selfSetter = selfProperty.setterInstance;
          let baseSetter = baseProperty.setterInstance;
          if (selfSetter) {
            if (!baseSetter || !selfSetter.signature.isAssignableTo(baseSetter.signature, true)) {
              return false;
            }
          } else if (baseSetter) {
            return false;
          }
          return true;
        }
      }
    }
    return false;
  }
}

// Kinds of all typed elements
var typedElements = new Set<ElementKind>();

/** Checks if the specified element kind indicates a typed element. */
export function isTypedElement(kind: ElementKind): bool {
  return typedElements.has(kind);
}

/** Base class of elements that can be resolved to a concrete type. */
export abstract class TypedElement extends DeclaredElement {

  /** Resolved type. Set once `is(RESOLVED)`, otherwise void. */
  type: Type = Type.void;

  constructor(
    /** Specific element kind. */
    kind: ElementKind,
    /** Simple name. */
    name: string,
    /** Internal name referring to this element. */
    internalName: string,
    /** Containing {@link Program}. */
    program: Program,
    /** Parent element. */
    parent: Element | null,
    /** Declaration reference. */
    declaration: DeclarationStatement
  ) {
    super(kind, name, internalName, program, parent, declaration);
    typedElements.add(kind);
  }

  /** Sets the resolved type of this element. */
  setType(type: Type): void {
    assert(!this.is(CommonFlags.RESOLVED));
    this.type = type;
    this.set(CommonFlags.RESOLVED);
  }
}

/** A file representing the implicit top-level namespace of a source. */
export class File extends Element {

  /** File exports. */
  exports: Map<string,DeclaredElement> | null = null;
  /** File re-exports. */
  exportsStar: File[] | null = null;
  /** Top-level start function of this file. */
  startFunction!: Function;
  /** Array of `import * as X` alias namespaces of this file. */
  aliasNamespaces: Array<Namespace> = new Array<Namespace>();

  /** Constructs a new file. */
  constructor(
    /** Program this file belongs to. */
    program: Program,
    /** Source of this file. */
    public source: Source
  ) {
    super(
      ElementKind.FILE,
      source.normalizedPath,
      source.internalPath,
      program,
      null // special case for files
    );
    this.source = source;
    assert(!program.filesByName.has(this.internalName));
    program.filesByName.set(this.internalName, this);
    var startFunction = this.program.makeNativeFunction(
      "start:" + this.internalName,
      new Signature(program, null, Type.void),
      this
    );
    startFunction.internalName = startFunction.name;
    this.startFunction = startFunction;
  }

  /* @override */
  add(name: string, element: DeclaredElement, localIdentifierIfImport: IdentifierExpression | null = null): bool {
    if (element.hasDecorator(DecoratorFlags.GLOBAL)) {
      element = this.program.ensureGlobal(name, element); // possibly merged globally
    }
    if (!super.add(name, element, localIdentifierIfImport)) return false;
    element = assert(this.lookupInSelf(name)); // possibly merged locally
    if (element.is(CommonFlags.EXPORT) && !localIdentifierIfImport) {
      this.ensureExport(
        element.name,
        element
      );
    }
    return true;
  }

  /* @override */
  lookupInSelf(name: string): DeclaredElement | null {
    var element = super.lookupInSelf(name);
    if (element) return element;
    var exportsStar = this.exportsStar;
    if (exportsStar) {
      for (let i = 0, k = exportsStar.length; i < k; ++i) {
        if (element = exportsStar[i].lookupInSelf(name)) return element;
      }
    }
    return null;
  }

  /* @override */
  lookup(name: string): Element | null {
    var element = this.lookupInSelf(name);
    if (element) return element;
    return this.program.lookup(name);
  }

  /** Ensures that an element is an export of this file. */
  ensureExport(name: string, element: DeclaredElement): void {
    var exports = this.exports;
    if (!exports) this.exports = exports = new Map();
    exports.set(name, element);
    if (this.source.sourceKind == SourceKind.LIBRARY_ENTRY) this.program.ensureGlobal(name, element);

    // Also, add to the namespaces that capture our exports
    for(let i = 0; i < this.aliasNamespaces.length; i++) {
      let ns = this.aliasNamespaces[i];
      ns.add(name, element);
    }
  }

  /** Ensures that another file is a re-export of this file. */
  ensureExportStar(file: File): void {
    var exportsStar = this.exportsStar;
    if (!exportsStar) this.exportsStar = exportsStar = [];
    else if (exportsStar.includes(file)) return;
    exportsStar.push(file);
  }

  /** Looks up the export of the specified name. */
  lookupExport(name: string): DeclaredElement | null {
    var exports = this.exports;
    if (exports !== null && exports.has(name)) return assert(exports.get(name));
    var exportsStar = this.exportsStar;
    if (exportsStar) {
      for (let i = 0, k = exportsStar.length; i < k; ++i) {
        let element = exportsStar[i].lookupExport(name);
        if (element) return element;
      }
    }
    return null;
  }

  /** Creates an imported namespace from this file. */
  asAliasNamespace(
    name: string,
    parent: Element,
    localIdentifier: IdentifierExpression
  ): Namespace {
    var declaration = this.program.makeNativeNamespaceDeclaration(name);
    declaration.name = localIdentifier;
    var ns = new Namespace(name, parent, declaration);
    ns.set(CommonFlags.SCOPED);
    this.copyExportsToNamespace(ns);
    // NOTE: Some exports are still queued, and can't yet be added here,
    // so we remember all the alias namespaces and add to them as well
    // when adding an element to the file.
    this.aliasNamespaces.push(ns);
    return ns;
  }

  /** Recursively copies the exports of this file to the specified namespace. */
  private copyExportsToNamespace(ns: Namespace): void {
    var exports = this.exports;
    if (exports) {
      // TODO: for (let [memberName, member] of exports) {
      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {
        let memberName = unchecked(_keys[i]);
        let member = assert(exports.get(memberName));
        ns.add(memberName, member);
      }
    }
    var exportsStar = this.exportsStar;
    if (exportsStar) {
      for (let i = 0, k = exportsStar.length; i < k; ++i) {
        exportsStar[i].copyExportsToNamespace(ns);
      }
    }
  }
}

/** A type definition. */
export class TypeDefinition extends TypedElement {

  /** Constructs a new type definition. */
  constructor(
    /** Simple name. */
    name: string,
    /** Parent element, usually a file or namespace. */
    parent: Element,
    /** Declaration reference. */
    declaration: TypeDeclaration,
    /** Pre-checked flags indicating built-in decorators. */
    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE
  ) {
    super(
      ElementKind.TYPEDEFINITION,
      name,
      mangleInternalName(name, parent, false),
      parent.program,
      parent,
      declaration
    );
    this.decoratorFlags = decoratorFlags;
  }

  /** Gets the associated type parameter nodes. */
  get typeParameterNodes(): TypeParameterNode[] | null {
    return (<TypeDeclaration>this.declaration).typeParameters;
  }

  /** Gets the associated type node. */
  get typeNode(): TypeNode {
    return (<TypeDeclaration>this.declaration).type;
  }

  /* @override */
  lookup(name: string): Element | null {
    return this.parent.lookup(name);
  }
}

/** A namespace that differs from a file in being user-declared with a name. */
export class Namespace extends DeclaredElement {

  /** Constructs a new namespace. */
  constructor(
    /** Simple name. */
    name: string,
    /** Parent element, usually a file or another namespace. */
    parent: Element,
    /** Declaration reference. */
    declaration: NamespaceDeclaration,
    /** Pre-checked flags indicating built-in decorators. */
    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE
  ) {
    super(
      ElementKind.NAMESPACE,
      name,
      mangleInternalName(name, parent, false),
      parent.program,
      parent,
      declaration
    );
    this.decoratorFlags = decoratorFlags;
  }

  /* @override */
  lookup(name: string): Element | null {
    var inSelf = this.lookupInSelf(name);
    if (inSelf) return inSelf;
    return this.parent.lookup(name);
  }
}

/** An enum. */
export class Enum extends TypedElement {

  /** Constructs a new enum. */
  constructor(
    /** Simple name. */
    name: string,
    /** Parent element, usually a file or namespace. */
    parent: Element,
    /** Declaration reference. */
    declaration: EnumDeclaration,
    /** Pre-checked flags indicating built-in decorators. */
    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE
  ) {
    super(
      ElementKind.ENUM,
      name,
      mangleInternalName(name, parent, false),
      parent.program,
      parent,
      declaration
    );
    this.decoratorFlags = decoratorFlags;
    this.setType(Type.i32);
  }

  /* @override */
  lookup(name: string): Element | null {
    var inSelf = this.lookupInSelf(name);
    if (inSelf) return inSelf;
    return this.parent.lookup(name);
  }
}

/** Indicates the kind of an inlined constant value. */
export const enum ConstantValueKind {
  /** No constant value. */
  NONE,
  /** Constant integer value. */
  INTEGER,
  /** Constant float value. */
  FLOAT
}

/** Base class of all variable-like program elements. */
export abstract class VariableLikeElement extends TypedElement {

  /** Constant value kind. */
  constantValueKind: ConstantValueKind = ConstantValueKind.NONE;
  /** Constant integer value, if applicable. */
  constantIntegerValue: i64 = i64_zero;
  /** Constant float value, if applicable. */
  constantFloatValue: f64 = 0;

  /** Constructs a new variable-like element. */
  protected constructor(
    /** Specific element kind. */
    kind: ElementKind,
    /** Simple name. */
    name: string,
    /** Parent element, usually a file, namespace or class. */
    parent: Element,
    /** Declaration reference. Creates a native declaration if omitted. */
    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)
  ) {
    super(
      kind,
      name,
      mangleInternalName(name, parent, false),
      parent.program,
      parent,
      declaration
    );
    this.flags = declaration.flags;
  }

  /** Gets the associated type node.s */
  get typeNode(): TypeNode | null {
    return (<VariableLikeDeclarationStatement>this.declaration).type;
  }

  /** Gets the associated initializer node. */
  get initializerNode(): Expression | null {
    return (<VariableLikeDeclarationStatement>this.declaration).initializer;
  }

  /** Applies a constant integer value to this element. */
  setConstantIntegerValue(value: i64, type: Type): void {
    assert(type.isIntegerInclReference);
    this.type = type;
    this.constantValueKind = ConstantValueKind.INTEGER;
    this.constantIntegerValue = value;
    this.set(CommonFlags.CONST | CommonFlags.INLINED | CommonFlags.RESOLVED);
  }

  /** Applies a constant float value to this element. */
  setConstantFloatValue(value: f64, type: Type): void {
    assert(type.isFloatValue);
    this.type = type;
    this.constantValueKind = ConstantValueKind.FLOAT;
    this.constantFloatValue = value;
    this.set(CommonFlags.CONST | CommonFlags.INLINED | CommonFlags.RESOLVED);
  }

  /** @override */
  lookup(name: string): Element | null {
    return this.parent.lookup(name);
  }
}

/** An enum value. */
export class EnumValue extends VariableLikeElement {

  /** Constructs a new enum value. */
  constructor(
    /** Simple name. */
    name: string,
    /** Parent enum. */
    parent: Enum,
    /** Declaration reference. */
    declaration: EnumValueDeclaration,
    /** Pre-checked flags indicating built-in decorators. */
    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE
  ) {
    super(
      ElementKind.ENUMVALUE,
      name,
      parent,
      declaration
    );
    this.decoratorFlags = decoratorFlags;
    this.setType(Type.i32);
  }

  /** Whether this enum value is immutable. */
  isImmutable: bool = false;

  /** Gets the associated value node. */
  get valueNode(): Expression | null {
    return (<EnumValueDeclaration>this.declaration).initializer;
  }

  /* @override */
  lookup(name: string): Element | null {
    return this.parent.lookup(name);
  }
}

/** A global variable. */
export class Global extends VariableLikeElement {

  /** Constructs a new global variable. */
  constructor(
    /** Simple name. */
    name: string,
    /** Parent element, usually a file, namespace or static class. */
    parent: Element,
    /** Pre-checked flags indicating built-in decorators. */
    decoratorFlags: DecoratorFlags,
    /** Declaration reference. Creates a native declaration if omitted. */
    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)
  ) {
    super(
      ElementKind.GLOBAL,
      name,
      parent,
      declaration
    );
    this.decoratorFlags = decoratorFlags;
  }
}

/** A function parameter. */
export class Parameter {
  /** Constructs a new function parameter. */
  constructor(
    /** Parameter name. */
    public name: string,
    /** Parameter type. */
    public type: Type,
    /** Parameter initializer, if present. */
    public initializer: Expression | null = null
  ) {}
}

/** A local variable. */
export class Local extends VariableLikeElement {

  /** Original name of the (temporary) local. */
  private originalName: string;

  /** Constructs a new local variable. */
  constructor(
    /** Simple name. */
    name: string,
    /** Zero-based index within the enclosing function. `-1` indicates a virtual local. */
    public index: i32,
    /** Resolved type. */
    type: Type,
    /** Parent function. */
    parent: Function,
    /** Declaration reference. */
    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)
  ) {
    super(
      ElementKind.LOCAL,
      name,
      parent,
      declaration
    );
    this.originalName = name;
    this.index = index;
    assert(type != Type.void);
    this.setType(type);
  }

  /** Sets the temporary name of this local. */
  setTemporaryName(name: string): void {
    this.name = name;
    this.internalName = mangleInternalName(name, this.parent, false);
  }

  /** Resets the temporary name of this local. */
  resetTemporaryName(): void {
    var name = this.originalName;
    this.name = name;
    this.internalName = mangleInternalName(name, this.parent, false);
  }
}

/** A yet unresolved function prototype. */
export class FunctionPrototype extends DeclaredElement {

  /** Operator kind, if an overload. */
  operatorKind: OperatorKind = OperatorKind.INVALID;
  /** Already resolved instances. */
  instances: Map<string,Function> | null = null;
  /** Methods overloading this one, if any. These are unbound. */
  overloads: Set<FunctionPrototype> | null = null;

  /** Clones of this prototype that are bounds to specific classes. */
  private boundPrototypes: Map<Class,FunctionPrototype> | null = null;

  /** Constructs a new function prototype. */
  constructor(
    /** Simple name */
    name: string,
    /** Parent element, usually a file, namespace or class (if a method). */
    parent: Element,
    /** Declaration reference. */
    declaration: FunctionDeclaration,
    /** Pre-checked flags indicating built-in decorators. */
    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE
  ) {
    super(
      ElementKind.FUNCTION_PROTOTYPE,
      name,
      mangleInternalName(name, parent, declaration.is(CommonFlags.INSTANCE)),
      parent.program,
      parent,
      declaration
    );
    this.decoratorFlags = decoratorFlags;
  }

  /** Gets the associated type parameter nodes. */
  get typeParameterNodes(): TypeParameterNode[] | null {
    return (<FunctionDeclaration>this.declaration).typeParameters;
  }

  /** Gets the associated function type node. */
  get functionTypeNode(): FunctionTypeNode {
    return (<FunctionDeclaration>this.declaration).signature;
  }

  /** Gets the associated body node. */
  get bodyNode(): Statement | null {
    return (<FunctionDeclaration>this.declaration).body;
  }

  /** Gets the arrow function kind. */
  get arrowKind(): ArrowKind {
    return (<FunctionDeclaration>this.declaration).arrowKind;
  }

  /** Tests if this prototype is bound to a class. */
  get isBound(): bool {
    var parent = this.parent;
    return parent.kind == ElementKind.CLASS ||
           parent.kind == ElementKind.PROPERTY_PROTOTYPE && (
             parent.parent.kind == ElementKind.CLASS ||
             parent.parent.kind == ElementKind.INTERFACE
           );
  }

  /** Creates a clone of this prototype that is bound to a concrete class instead. */
  toBound(classInstance: Class): FunctionPrototype {
    assert(this.is(CommonFlags.INSTANCE));
    assert(!this.isBound);
    var boundPrototypes = this.boundPrototypes;
    if (!boundPrototypes) this.boundPrototypes = boundPrototypes = new Map();
    else if (boundPrototypes.has(classInstance)) return assert(boundPrototypes.get(classInstance));
    var declaration = this.declaration;
    assert(declaration.kind == NodeKind.METHODDECLARATION);
    var bound = new FunctionPrototype(
      this.name,
      classInstance, // !
      <MethodDeclaration>declaration,
      this.decoratorFlags
    );
    bound.flags = this.flags;
    bound.operatorKind = this.operatorKind;
    bound.overloads = this.overloads;
    // NOTE: this.instances holds instances per bound class / unbound
    boundPrototypes.set(classInstance, bound);
    return bound;
  }

  /** Gets the resolved instance for the specified instance key, if already resolved. */
  getResolvedInstance(instanceKey: string): Function | null {
    var instances = this.instances;
    if (instances !== null && instances.has(instanceKey)) return assert(instances.get(instanceKey));
    return null;
  }

  /** Sets the resolved instance for the specified instance key. */
  setResolvedInstance(instanceKey: string, instance: Function): void {
    var instances = this.instances;
    if (!instances) this.instances = instances = new Map();
    else assert(!instances.has(instanceKey));
    instances.set(instanceKey, instance);
  }

  /* @override */
  lookup(name: string): Element | null {
    return this.parent.lookup(name);
  }
}

/** A resolved function. */
export class Function extends TypedElement {

  /** Function prototype. */
  prototype: FunctionPrototype;
  /** Function signature. */
  signature: Signature;
  /** Map of locals by name. */
  localsByName: Map<string,Local> = new Map();
  /** Array of locals by index. */
  localsByIndex: Local[] = [];
  /** List of additional non-parameter locals. */
  additionalLocals: Type[] = [];
  /** Concrete type arguments. */
  typeArguments: Type[] | null;
  /** Contextual type arguments. */
  contextualTypeArguments: Map<string,Type> | null;
  /** Default control flow. */
  flow!: Flow;
  /** Remembered debug locations. */
  debugLocations: Range[] = [];
  /** Function reference, if compiled. */
  ref: FunctionRef = 0;
  /** Varargs stub for calling with omitted arguments. */
  varargsStub: Function | null = null;
  /** Virtual stub for calling overloads. */
  virtualStub: Function | null = null;
  /** Runtime memory segment, if created. */
  memorySegment: MemorySegment | null = null;
  /** Original function, if a stub. Otherwise `this`. */
  original!: Function;

  /** Counting id of inline operations involving this function. */
  nextInlineId: i32 = 0;
  /** Counting id of anonymous inner functions. */
  nextAnonymousId: i32 = 0;

  /** Constructs a new concrete function. */
  constructor(
    /** Name incl. type parameters, i.e. `foo<i32>`. */
    nameInclTypeParameters: string,
    /** Respective function prototype. */
    prototype: FunctionPrototype,
    /** Concrete type arguments. */
    typeArguments: Type[] | null,
    /** Concrete signature. */
    signature: Signature, // pre-resolved
    /** Contextual type arguments inherited from its parent class, if any. */
    contextualTypeArguments: Map<string,Type> | null = null
  ) {
    super(
      ElementKind.FUNCTION,
      nameInclTypeParameters,
      mangleInternalName(nameInclTypeParameters, prototype.parent, prototype.is(CommonFlags.INSTANCE)),
      prototype.program,
      prototype.parent,
      prototype.declaration
    );
    this.prototype = prototype;
    this.typeArguments = typeArguments;
    this.signature = signature;
    this.flags = prototype.flags | CommonFlags.RESOLVED;
    this.decoratorFlags = prototype.decoratorFlags;
    this.contextualTypeArguments = contextualTypeArguments;
    this.original = this;
    var program = prototype.program;
    this.type = signature.type;
    if (!prototype.is(CommonFlags.AMBIENT)) {
      let localIndex = 0;
      let thisType = signature.thisType;
      if (thisType) {
        let local = new Local(
          CommonNames.this_,
          localIndex++,
          thisType,
          this
        );
        this.localsByName.set(CommonNames.this_, local);
        this.localsByIndex[local.index] = local;
      }
      let parameterTypes = signature.parameterTypes;
      for (let i = 0, k = parameterTypes.length; i < k; ++i) {
        let parameterType = parameterTypes[i];
        let parameterName = this.getParameterName(i);
        let local = new Local(
          parameterName,
          localIndex++,
          parameterType,
          this
        );
        this.localsByName.set(parameterName, local);
        this.localsByIndex[local.index] = local;
      }
    }
    this.flow = Flow.createParent(this);
    registerConcreteElement(program, this);
  }

  /** Gets the name of the parameter at the specified index. */
  getParameterName(index: i32): string {
    var parameters = (<FunctionDeclaration>this.declaration).signature.parameters;
    return parameters.length > index
      ? parameters[index].name.text
      : getDefaultParameterName(index);
  }

  /** Creates a stub for use with this function, i.e. for varargs or virtual calls. */
  newStub(postfix: string): Function {
    var stub = new Function(
      this.original.name + STUB_DELIMITER + postfix,
      this.prototype,
      this.typeArguments,
      this.signature.clone(),
      this.contextualTypeArguments
    );
    stub.original = this.original;
    stub.set(this.flags & ~CommonFlags.COMPILED | CommonFlags.STUB);
    return stub;
  }

  /** Adds a local of the specified type, with an optional name. */
  addLocal(type: Type, name: string | null = null, declaration: VariableDeclaration | null = null): Local {
    // if it has a name, check previously as this method will throw otherwise
    var localIndex = this.signature.parameterTypes.length + this.additionalLocals.length;
    if (this.is(CommonFlags.INSTANCE)) ++localIndex;
    var localName = name !== null
      ? name
      : "var$" + localIndex.toString();
    if (!declaration) declaration = this.program.makeNativeVariableDeclaration(localName);
    var local = new Local(
      localName,
      localIndex,
      type,
      this,
      declaration
    );
    if (name) {
      if (this.localsByName.has(name)) throw new Error("duplicate local name");
      this.localsByName.set(name, local);
    }
    this.localsByIndex[local.index] = local;
    this.additionalLocals.push(type);
    return local;
  }

  /* @override */
  lookup(name: string): Element | null {
    var locals = this.localsByName;
    if (locals.has(name)) return assert(locals.get(name));
    return this.parent.lookup(name);
  }

  // used by flows to keep track of temporary locals
  tempI32s: Local[] | null = null;
  tempI64s: Local[] | null = null;
  tempF32s: Local[] | null = null;
  tempF64s: Local[] | null = null;
  tempV128s: Local[] | null = null;
  tempFuncrefs: Local[] | null = null;
  tempExternrefs: Local[] | null = null;
  tempAnyrefs: Local[] | null = null;
  tempEqrefs: Local[] | null = null;
  tempI31refs: Local[] | null = null;
  tempDatarefs: Local[] | null = null;

  // used by flows to keep track of break labels
  nextBreakId: i32 = 0;
  breakStack: i32[] | null = null;
  breakLabel: string | null = null;

  /** Finalizes the function once compiled, releasing no longer needed resources. */
  finalize(module: Module, ref: FunctionRef): void {
    this.ref = ref;
    var breakStack = this.breakStack;
    assert(!breakStack || !breakStack.length); // internal error
    this.breakStack = breakStack = null;
    this.breakLabel = null;
    this.tempI32s = this.tempI64s = this.tempF32s = this.tempF64s = null;
    if (this.program.options.sourceMap) {
      let debugLocations = this.debugLocations;
      for (let i = 0, k = debugLocations.length; i < k; ++i) {
        let range = debugLocations[i];
        let source = range.source;
        module.setDebugLocation(
          ref,
          range.debugInfoRef,
          source.debugInfoIndex,
          source.lineAt(range.start),
          source.columnAt() - 1 // source maps are 0-based
        );
      }
    }
  }
}

/** A yet unresolved instance field prototype. */
export class FieldPrototype extends DeclaredElement {

  /** Constructs a new field prototype. */
  constructor(
    /** Simple name. */
    name: string,
    /** Parent class. */
    parent: ClassPrototype,
    /** Declaration reference. */
    declaration: FieldDeclaration,
    /** Pre-checked flags indicating built-in decorators. */
    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE
  ) {
    super(
      ElementKind.FIELD_PROTOTYPE,
      name,
      mangleInternalName(name, parent, assert(declaration.is(CommonFlags.INSTANCE))),
      parent.program,
      parent,
      declaration
    );
    this.decoratorFlags = decoratorFlags;
  }

  /** Gets the associated type node. */
  get typeNode(): TypeNode | null {
    return (<FieldDeclaration>this.declaration).type;
  }

  /** Gets the associated initializer node. */
  get initializerNode(): Expression | null {
    return (<FieldDeclaration>this.declaration).initializer;
  }

  /** Gets the associated parameter index. Set if declared as a constructor parameter, otherwise `-1`. */
  get parameterIndex(): i32 {
    return (<FieldDeclaration>this.declaration).parameterIndex;
  }

  /* @override */
  lookup(name: string): Element | null {
    return this.parent.lookup(name);
  }
}

/** A resolved instance field. */
export class Field extends VariableLikeElement {

  /** Field prototype reference. */
  prototype: FieldPrototype;
  /** Field memory offset, if an instance field. */
  memoryOffset: i32 = -1;
  /** Getter function reference, if compiled. */
  getterRef: FunctionRef = 0;
  /** Setter function reference, if compiled. */
  setterRef: FunctionRef = 0;

  /** Constructs a new field. */
  constructor(
    /** Respective field prototype. */
    prototype: FieldPrototype,
    /** Parent class. */
    parent: Class,
    /** Concrete type. */
    type: Type
  ) {
    super(
      ElementKind.FIELD,
      prototype.name,
      parent,
      <VariableLikeDeclarationStatement>prototype.declaration
    );
    this.prototype = prototype;
    this.flags = prototype.flags;
    this.decoratorFlags = prototype.decoratorFlags;
    assert(type != Type.void);
    this.setType(type);
    registerConcreteElement(this.program, this);
  }

  /** Gets the field's `this` type. */
  get thisType(): Type {
    var parent = this.parent;
    assert(parent.kind == ElementKind.CLASS);
    return (<Class>parent).type;
  }

  /** Gets the internal name of the respective getter function. */
  get internalGetterName(): string {
    var cached = this._internalGetterName;
    if (cached === null) this._internalGetterName = cached = this.parent.internalName + INSTANCE_DELIMITER + GETTER_PREFIX + this.name;
    return cached;
  }
  private _internalGetterName: string | null = null;

  /** Gets the internal name of the respective setter function. */
  get internalSetterName(): string {
    var cached = this._internalSetterName;
    if (cached === null) this._internalSetterName = cached = this.parent.internalName + INSTANCE_DELIMITER + SETTER_PREFIX + this.name;
    return cached;
  }
  private _internalSetterName: string | null = null;

  /** Gets the signature of the respective getter function. */
  get internalGetterSignature(): Signature {
    var cached = this._internalGetterSignature;
    if (!cached) this._internalGetterSignature = cached = new Signature(this.program, null, this.type, this.thisType);
    return cached;
  }
  private _internalGetterSignature: Signature | null = null;

  /** Gets the signature of the respective setter function. */
  get internalSetterSignature(): Signature {
    var cached = this._internalSetterSignature;
    if (!cached) this._internalGetterSignature = cached = new Signature(this.program, [ this.type ], Type.void, this.thisType);
    return cached;
  }
  private _internalSetterSignature: Signature | null = null;
}

/** A property comprised of a getter and a setter function. */
export class PropertyPrototype extends DeclaredElement {

  /** Getter prototype. */
  getterPrototype: FunctionPrototype | null = null;
  /** Setter prototype. */
  setterPrototype: FunctionPrototype | null = null;
  /** Property instance, if resolved. */
  instance: Property | null = null;

  /** Clones of this prototype that are bound to specific classes. */
  private boundPrototypes: Map<Class,PropertyPrototype> | null = null;

  /** Constructs a new property prototype. */
  constructor(
    /** Simple name. */
    name: string,
    /** Parent element. Either a class prototype or instance. */
    parent: Element,
    /** Declaration of the getter or setter introducing the property. */
    firstDeclaration: FunctionDeclaration
  ) {
    super(
      ElementKind.PROPERTY_PROTOTYPE,
      name,
      mangleInternalName(name, parent, firstDeclaration.is(CommonFlags.INSTANCE)),
      parent.program,
      parent,
      firstDeclaration
    );
    this.flags &= ~(CommonFlags.GET | CommonFlags.SET);
  }

  /* @override */
  lookup(name: string): Element | null {
    return this.parent.lookup(name);
  }

  /** Tests if this prototype is bound to a class. */
  get isBound(): bool {
    switch (this.parent.kind) {
      case ElementKind.CLASS:
      case ElementKind.INTERFACE: return true;
    }
    return false;
  }

  /** Creates a clone of this prototype that is bound to a concrete class instead. */
  toBound(classInstance: Class): PropertyPrototype {
    assert(this.is(CommonFlags.INSTANCE));
    assert(!this.isBound);
    var boundPrototypes = this.boundPrototypes;
    if (!boundPrototypes) this.boundPrototypes = boundPrototypes = new Map();
    else if (boundPrototypes.has(classInstance)) return assert(boundPrototypes.get(classInstance));
    var firstDeclaration = this.declaration;
    assert(firstDeclaration.kind == NodeKind.METHODDECLARATION);
    var bound = new PropertyPrototype(
      this.name,
      classInstance, // !
      <MethodDeclaration>firstDeclaration
    );
    bound.flags = this.flags;
    var getterPrototype = this.getterPrototype;
    if (getterPrototype) {
      bound.getterPrototype = getterPrototype.toBound(classInstance);
    }
    var setterPrototype = this.setterPrototype;
    if (setterPrototype) {
      bound.setterPrototype = setterPrototype.toBound(classInstance);
    }
    boundPrototypes.set(classInstance, bound);
    return bound;
  }
}

/** A resolved property. */
export class Property extends VariableLikeElement {

  /** Prototype reference. */
  prototype: PropertyPrototype;
  /** Getter instance. */
  getterInstance: Function | null = null;
  /** Setter instance. */
  setterInstance: Function | null = null;

  /** Constructs a new property prototype. */
  constructor(
    /** Respective property prototype. */
    prototype: PropertyPrototype,
    /** Parent element, usually a static class prototype or class instance. */
    parent: Element
  ) {
    super(
      ElementKind.PROPERTY,
      prototype.name,
      parent,
      Node.createVariableDeclaration(
        prototype.identifierNode,
        null,
        prototype.is(CommonFlags.INSTANCE)
          ? CommonFlags.INSTANCE
          : CommonFlags.NONE,
        null, null,
        prototype.identifierNode.range
      )
    );
    this.prototype = prototype;
    this.flags = prototype.flags;
    this.decoratorFlags = prototype.decoratorFlags;
    if (this.is(CommonFlags.INSTANCE)) {
      registerConcreteElement(this.program, this);
    }
  }

  /* @override */
  lookup(name: string): Element | null {
    return this.parent.lookup(name);
  }
}

/** A resolved index signature. */
export class IndexSignature extends TypedElement {

  /** Constructs a new index prototype. */
  constructor(
    /** Parent class. */
    parent: Class
  ) {
    super(
      ElementKind.INDEXSIGNATURE,
      "[]",
      parent.internalName + "[]",
      parent.program,
      parent,
      parent.program.makeNativeVariableDeclaration("[]") // is fine
    );
  }

  /** Obtains the getter instance. */
  getGetterInstance(isUnchecked: bool): Function | null {
    return (<Class>this.parent).lookupOverload(OperatorKind.INDEXED_GET, isUnchecked);
  }

  /** Obtains the setter instance. */
  getSetterInstance(isUnchecked: bool): Function | null {
    return (<Class>this.parent).lookupOverload(OperatorKind.INDEXED_SET, isUnchecked);
  }

  /* @override */
  lookup(name: string): Element | null {
    return this.parent.lookup(name);
  }
}

/** A yet unresolved class prototype. */
export class ClassPrototype extends DeclaredElement {

  /** Instance member prototypes. */
  instanceMembers: Map<string,DeclaredElement> | null = null;
  /** Base class prototype, if applicable. */
  basePrototype: ClassPrototype | null = null;
  /** Interface prototypes, if applicable. */
  interfacePrototypes: InterfacePrototype[] | null = null;
  /** Constructor prototype. */
  constructorPrototype: FunctionPrototype | null = null;
  /** Operator overload prototypes. */
  overloadPrototypes: Map<OperatorKind, FunctionPrototype> = new Map();
  /** Already resolved instances. */
  instances: Map<string,Class> | null = null;
  /** Classes extending this class. */
  extendees: Set<ClassPrototype> = new Set();

  constructor(
    /** Simple name. */
    name: string,
    /** Parent element, usually a file or namespace. */
    parent: Element,
    /** Declaration reference. */
    declaration: ClassDeclaration,
    /** Pre-checked flags indicating built-in decorators. */
    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE,
    _isInterface: bool = false // FIXME
  ) {
    super(
      _isInterface ? ElementKind.INTERFACE_PROTOTYPE : ElementKind.CLASS_PROTOTYPE,
      name,
      mangleInternalName(name, parent, declaration.is(CommonFlags.INSTANCE)),
      parent.program,
      parent,
      declaration
    );
    this.decoratorFlags = decoratorFlags;
  }

  /** Gets the associated type parameter nodes. */
  get typeParameterNodes(): TypeParameterNode[] | null {
    return (<ClassDeclaration>this.declaration).typeParameters;
  }
  /** Gets the associated extends node. */
  get extendsNode(): NamedTypeNode | null {
    return (<ClassDeclaration>this.declaration).extendsType;
  }
  /** Gets the associated implements nodes. */
  get implementsNodes(): NamedTypeNode[] | null {
    return (<ClassDeclaration>this.declaration).implementsTypes;
  }

  /** Tests if this prototype is of a builtin array type (Array/TypedArray). */
  get isBuiltinArray(): bool {
    var arrayBufferViewInstance = this.program.arrayBufferViewInstance;
    return arrayBufferViewInstance !== null
        && this.extends(arrayBufferViewInstance.prototype);
  }

  /** Tests if this prototype extends the specified. */
  extends(basePtototype: ClassPrototype | null): bool {
    var current: ClassPrototype | null = this;
    var seen = new Set<ClassPrototype>();
    do {
      // cannot directly or indirectly extend itself
      if (seen.has(current)) break;
      seen.add(current);
      if (current === basePtototype) return true;
      current = current.basePrototype;
    } while (current);
    return false;
  }

  /** Adds an element as an instance member of this one. Returns the previous element if a duplicate. */
  addInstance(name: string, element: DeclaredElement): bool {
    var originalDeclaration = element.declaration;
    var instanceMembers = this.instanceMembers;
    if (!instanceMembers) this.instanceMembers = instanceMembers = new Map();
    else if (instanceMembers.has(name)) {
      let existing = assert(instanceMembers.get(name));
      let merged = tryMerge(existing, element);
      if (!merged) {
        if (isDeclaredElement(existing.kind)) {
          this.program.errorRelated(
            DiagnosticCode.Duplicate_identifier_0,
            element.identifierNode.range,
            (<DeclaredElement>existing).declaration.name.range,
            element.identifierNode.text
          );
        } else {
          this.program.error(
            DiagnosticCode.Duplicate_identifier_0,
            element.identifierNode.range, element.identifierNode.text
          );
        }
        return false;
      }
      element = merged;
    }
    instanceMembers.set(name, element);
    if (element.is(CommonFlags.EXPORT) && this.is(CommonFlags.MODULE_EXPORT)) {
      element.set(CommonFlags.MODULE_EXPORT); // propagate
    }
    this.program.elementsByDeclaration.set(originalDeclaration, element);
    return true;
  }

  /** Gets the resolved instance for the specified instance key, if already resolved. */
  getResolvedInstance(instanceKey: string): Class | null {
    var instances = this.instances;
    if (instances !== null && instances.has(instanceKey)) return <Class>instances.get(instanceKey);
    return null;
  }

  /** Sets the resolved instance for the specified instance key. */
  setResolvedInstance(instanceKey: string, instance: Class): void {
    var instances = this.instances;
    if (!instances) this.instances = instances = new Map();
    else assert(!instances.has(instanceKey));
    instances.set(instanceKey, instance);
  }

  /* @override */
  lookup(name: string): Element | null {
    return this.parent.lookup(name);
  }
}

/** A resolved class. */
export class Class extends TypedElement {

  /** Class prototype. */
  prototype: ClassPrototype;
  /** Resolved type arguments. */
  typeArguments: Type[] | null;
  /** Base class, if applicable. */
  base: Class | null = null;
  /** Implemented interfaces, if applicable. */
  interfaces: Set<Interface> | null = null;
  /** Contextual type arguments for fields and methods. */
  contextualTypeArguments: Map<string,Type> | null = null;
  /** Current member memory offset. */
  nextMemoryOffset: u32 = 0;
  /** Constructor instance. */
  constructorInstance: Function | null = null;
  /** Operator overloads. */
  overloads: Map<OperatorKind,Function> | null = null;
  /** Index signature, if present. */
  indexSignature: IndexSignature | null = null;
  /** Unique class id. */
  private _id: u32 = 0;
  /** Runtime type information flags. */
  rttiFlags: u32 = 0;
  /** Wrapped type, if a wrapper for a basic type. */
  wrappedType: Type | null = null;
  /** Classes directly extending this class. */
  extendees: Set<Class> | null = null;
  /** Classes implementing this interface. */
  implementers: Set<Class> | null = null;
  /** Whether the field initialization check has already been performed. */
  didCheckFieldInitialization: bool = false;
  /** Runtime visitor function reference. */
  visitRef: FunctionRef = 0;

  /** Gets the unique runtime id of this class. */
  get id(): u32 {
    return this._id; // unmanaged remains 0 (=ArrayBuffer)
  }

  /** Tests if this class is of a builtin array type (Array/TypedArray). */
  get isBuiltinArray(): bool {
    return this.prototype.isBuiltinArray;
  }

  /** Tests if this class is array-like. */
  get isArrayLike(): bool {
    if (this.isBuiltinArray) return true;
    var lengthField = this.lookupInSelf("length");
    return lengthField !== null && (
      lengthField.kind == ElementKind.FIELD ||
      (
        lengthField.kind == ElementKind.PROPERTY_PROTOTYPE &&
        (<PropertyPrototype>lengthField).getterPrototype !== null // TODO: resolve & check type?
      )
    ) && (
      this.lookupOverload(OperatorKind.INDEXED_GET) !== null ||
      this.lookupOverload(OperatorKind.UNCHECKED_INDEXED_GET) !== null
    );
  }

  /** Constructs a new class. */
  constructor(
    /** Name incl. type parameters, i.e. `Foo<i32>`. */
    nameInclTypeParameters: string,
    /** The respective class prototype. */
    prototype: ClassPrototype,
    /** Concrete type arguments, if any. */
    typeArguments: Type[] | null = null,
    _isInterface: bool = false // FIXME
  ) {
    super(
      _isInterface ? ElementKind.INTERFACE : ElementKind.CLASS,
      nameInclTypeParameters,
      mangleInternalName(nameInclTypeParameters, prototype.parent, prototype.is(CommonFlags.INSTANCE)),
      prototype.program,
      prototype.parent,
      prototype.declaration
    );
    var program = this.program;
    this.prototype = prototype;
    this.flags = prototype.flags;
    this.decoratorFlags = prototype.decoratorFlags;
    this.typeArguments = typeArguments;
    var usizeType = program.options.usizeType;
    var type = new Type(usizeType.kind, usizeType.flags & ~TypeFlags.VALUE | TypeFlags.REFERENCE, usizeType.size);
    type.classReference = this;
    this.setType(type);

    if (!this.hasDecorator(DecoratorFlags.UNMANAGED)) {
      let id = program.nextClassId++;
      this._id = id;
      program.managedClasses.set(id, this);
    }

    // apply pre-checked instance-specific contextual type arguments
    var typeParameters = prototype.typeParameterNodes;
    if (typeArguments) {
      let numTypeArguments = typeArguments.length;
      if (!typeParameters || numTypeArguments != typeParameters.length) {
        throw new Error("type argument count mismatch");
      }
      if (numTypeArguments) {
        let contextualTypeArguments = this.contextualTypeArguments;
        if (!contextualTypeArguments) this.contextualTypeArguments = contextualTypeArguments = new Map();
        for (let i = 0; i < numTypeArguments; ++i) {
          contextualTypeArguments.set(typeParameters[i].name.text, typeArguments[i]);
        }
      }
    } else if (typeParameters !== null && typeParameters.length > 0) {
      throw new Error("type argument count mismatch");
    }
    registerConcreteElement(program, this);
  }

  /** Sets the base class. */
  setBase(base: Class): void {
    assert(!this.base);
    this.base = base;
    var extendees = base.extendees;
    if (!extendees) base.extendees = extendees = new Set();
    extendees.add(this);

    // Inherit contextual type arguments from base class
    var inheritedTypeArguments = base.contextualTypeArguments;
    if (inheritedTypeArguments) {
      let contextualTypeArguments = this.contextualTypeArguments;
      // TODO: for (let [baseName, baseType] of inheritedTypeArguments) {
      for (let _keys = Map_keys(inheritedTypeArguments), i = 0, k = _keys.length; i < k; ++i) {
        let baseName = unchecked(_keys[i]);
        let baseType = assert(inheritedTypeArguments.get(baseName));
        if (!contextualTypeArguments) {
          this.contextualTypeArguments = contextualTypeArguments = new Map();
          contextualTypeArguments.set(baseName, baseType);
        } else if (!contextualTypeArguments.has(baseName)) {
          contextualTypeArguments.set(baseName, baseType);
        }
      }
    }
  }

  /** Adds an interface. */
  addInterface(iface: Interface): void {
    var interfaces = this.interfaces;
    if (!interfaces) this.interfaces = interfaces = new Set();
    interfaces.add(iface);
    var implementers = iface.implementers;
    if (!implementers) iface.implementers = implementers = new Set();
    implementers.add(this);
  }

  /** Tests if a value of this class type is assignable to a target of the specified class type. */
  isAssignableTo(target: Class): bool {
    var current: Class | null = this;
    do {
      if (current == target) return true;
      if (target.kind == ElementKind.INTERFACE) {
        let interfaces = current.interfaces;
        if (interfaces) {
          for (let _values = Set_values(interfaces), i = 0, k = _values.length; i < k; ++i) {
            let iface = _values[i];
            if (iface.isAssignableTo(target)) return true;
          }
        }
      }
      current = current.base;
    } while (current);
    return false;
  }

  /** Looks up the operator overload of the specified kind. */
  lookupOverload(kind: OperatorKind, unchecked: bool = false): Function | null {
    if (unchecked) {
      switch (kind) {
        case OperatorKind.INDEXED_GET: {
          let uncheckedOverload = this.lookupOverload(OperatorKind.UNCHECKED_INDEXED_GET);
          if (uncheckedOverload) return uncheckedOverload;
          break;
        }
        case OperatorKind.INDEXED_SET: {
          let uncheckedOverload = this.lookupOverload(OperatorKind.UNCHECKED_INDEXED_SET);
          if (uncheckedOverload) return uncheckedOverload;
          break;
        }
        default: assert(false);
      }
    }
    var instance: Class | null = this;
    do {
      let overloads = instance.overloads;
      if (overloads != null && overloads.has(kind)) {
        return assert(overloads.get(kind));
      }
      instance = instance.base;
    } while (instance);
    return null;
  }

  /* @override */
  lookup(name: string): Element | null {
    return this.parent.lookup(name);
  }

  /** Gets the method of the specified name, resolved with the given type arguments. */
  getMethod(name: string, typeArguments: Type[] | null = null): Function | null {
    var members = this.members;
    if (members !== null && members.has(name)) {
      let bound = changetype<Element>(members.get(name));
      if (bound.kind == ElementKind.FUNCTION_PROTOTYPE) {
        return this.program.resolver.resolveFunction(<FunctionPrototype>bound, typeArguments);
      }
    }
    return null;
  }

  /** Calculates the memory offset of the specified field. */
  offsetof(fieldName: string): u32 {
    var members = assert(this.members);
    assert(members.has(fieldName));
    var field = <Element>members.get(fieldName);
    assert(field.kind == ElementKind.FIELD);
    return (<Field>field).memoryOffset;
  }

  /** Creates a buffer suitable to hold a runtime instance of this class. */
  createBuffer(overhead: i32 = 0): Uint8Array {
    var program = this.program;
    var payloadSize = this.nextMemoryOffset + overhead;
    var blockSize = program.computeBlockSize(payloadSize, true); // excl. overhead
    var buffer = new Uint8Array(program.blockOverhead + blockSize);
    var OBJECT = program.OBJECTInstance;
    OBJECT.writeField("mmInfo", blockSize, buffer, 0);
    OBJECT.writeField("gcInfo", 0, buffer, 0);
    OBJECT.writeField("gcInfo2", 0, buffer, 0);
    OBJECT.writeField("rtId", this.id, buffer, 0);
    OBJECT.writeField("rtSize", payloadSize, buffer, 0);
    return buffer;
  }

  /** Writes a field value to a buffer and returns the number of bytes written. */
  writeField<T>(name: string, value: T, buffer: Uint8Array, baseOffset: i32 = this.program.totalOverhead): i32 {
    var element = this.lookupInSelf(name);
    if (element !== null && element.kind == ElementKind.FIELD) {
      let fieldInstance = <Field>element;
      let offset = baseOffset + fieldInstance.memoryOffset;
      let typeKind = fieldInstance.type.kind;
      switch (typeKind) {
        case TypeKind.I8:
        case TypeKind.U8: {
          assert(!i64_is(value));
          writeI8(i32(value), buffer, offset);
          return 1;
        }
        case TypeKind.I16:
        case TypeKind.U16: {
          assert(!i64_is(value));
          writeI16(i32(value), buffer, offset);
          return 2;
        }
        case TypeKind.I32:
        case TypeKind.U32: {
          assert(!i64_is(value));
          writeI32(i32(value), buffer, offset);
          return 4;
        }
        case TypeKind.ISIZE:
        case TypeKind.USIZE: {
          if (this.program.options.isWasm64) {
            if (i64_is(value)) {
              writeI64(value, buffer, offset);
            } else {
              writeI32AsI64(i32(value), buffer, offset, typeKind == TypeKind.USIZE);
            }
            return 8;
          } else {
            if (i64_is(value)) {
              writeI64AsI32(value, buffer, offset, typeKind == TypeKind.USIZE);
            } else {
              writeI32(i32(value), buffer, offset);
            }
            return 4;
          }
        }
        case TypeKind.I64:
        case TypeKind.U64: {
          if (i64_is(value)) {
            writeI64(value, buffer, offset);
          } else {
            writeI32AsI64(i32(value), buffer, offset, typeKind == TypeKind.U64);
          }
          return 8;
        }
        case TypeKind.F32: {
          assert(!i64_is(value));
          writeF32(f32(value), buffer, offset);
          return 4;
        }
        case TypeKind.F64: {
          assert(!i64_is(value));
          writeF64(f64(value), buffer, offset);
          return 8;
        }
      }
    }
    assert(false);
    return 0;
  }

  /** Tests if this class extends the specified prototype. */
  extends(prototype: ClassPrototype): bool {
    return this.prototype.extends(prototype);
  }

  /** Gets the concrete type arguments to the specified extendend prototype. */
  getTypeArgumentsTo(extendedPrototype: ClassPrototype): Type[] | null {
    var current: Class | null = this;
    do {
      if (current.prototype === extendedPrototype) return current.typeArguments;
      current = current.base;
    } while (current);
    return null;
  }

  /** Gets the value type of an array. Must be an array. */
  getArrayValueType(): Type {
    var current: Class = this;
    var program = this.program;
    var arrayPrototype = program.arrayPrototype;
    if (this.extends(arrayPrototype)) {
      return this.getTypeArgumentsTo(arrayPrototype)![0];
    }
    var staticArrayPrototype = program.staticArrayPrototype;
    if (this.extends(staticArrayPrototype)) {
      return this.getTypeArgumentsTo(staticArrayPrototype)![0];
    }
    var abvInstance = program.arrayBufferViewInstance;
    while (current.base !== abvInstance) {
      current = assert(current.base);
    }
    var prototype = current.prototype;
    switch (prototype.name.charCodeAt(0)) {
      case CharCode.F: {
        if (prototype == program.float32ArrayPrototype) return Type.f32;
        if (prototype == program.float64ArrayPrototype) return Type.f64;
        break;
      }
      case CharCode.I: {
        if (prototype == program.int8ArrayPrototype) return Type.i8;
        if (prototype == program.int16ArrayPrototype) return Type.i16;
        if (prototype == program.int32ArrayPrototype) return Type.i32;
        if (prototype == program.int64ArrayPrototype) return Type.i64;
        break;
      }
      case CharCode.U: {
        if (prototype == program.uint8ArrayPrototype) return Type.u8;
        if (prototype == program.uint8ClampedArrayPrototype) return Type.u8;
        if (prototype == program.uint16ArrayPrototype) return Type.u16;
        if (prototype == program.uint32ArrayPrototype) return Type.u32;
        if (prototype == program.uint64ArrayPrototype) return Type.u64;
        break;
      }
    }
    assert(false);
    return Type.void;
  }

  /** Tests if this class is pointerfree. Useful to know for the GC. */
  get isPointerfree(): bool {
    var program = this.program;

    var instanceMembers = this.members;
    if (instanceMembers) {

      // Check that there are no managed instance fields
      for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {
        let member = unchecked(_values[i]);
        if (member.kind == ElementKind.FIELD) {
          let fieldType = (<Field>member).type;
          if (fieldType.isManaged) return false;
        }
      }

      // Check that this isn't a managed collection
      if (instanceMembers.has(CommonNames.visit)) {
        let prototype = this.prototype;
        if (
          prototype == program.arrayPrototype ||
          prototype == program.staticArrayPrototype ||
          prototype == program.setPrototype ||
          prototype == program.mapPrototype
        ) {
          // Note that we cannot know for sure anymore as soon as the collection
          // is extended, because user code may implement a custom visitor.
          let typeArguments = assert(this.getTypeArgumentsTo(prototype));
          for (let i = 0, k = typeArguments.length; i < k; ++i) {
            if (typeArguments[i].isManaged) return false;
          }
          return true;
        }
        return false; // has a custom __visit
      }
    }
    return true;
  }

  /** Gets all extendees of this class (that do not have the specified instance member). */
  getAllExtendees(exceptIfMember: string | null = null, out: Set<Class> = new Set()): Set<Class> {
    var extendees = this.extendees;
    if (extendees) {
      for (let _values = Set_values(extendees), i = 0, k = _values.length; i < k; ++i) {
        let extendee = _values[i];
        if (exceptIfMember) {
          let instanceMembers = extendee.prototype.instanceMembers;
          if (instanceMembers !== null && instanceMembers.has(exceptIfMember)) continue;
        }
        out.add(extendee);
        extendee.getAllExtendees(exceptIfMember, out);
      }
    }
    return out;
  }
}

/** A yet unresolved interface. */
export class InterfacePrototype extends ClassPrototype {

  /** Constructs a new interface prototype. */
  constructor(
    name: string,
    parent: Element,
    declaration: InterfaceDeclaration,
    decoratorFlags: DecoratorFlags
  ) {
    super(
      name,
      parent,
      declaration,
      decoratorFlags,
      true
    );
  }
}

/** A resolved interface. */
export class Interface extends Class { // FIXME

  /** Constructs a new interface. */
  constructor(
    /** Name incl. type parameters, i.e. `Foo<i32>`. */
    nameInclTypeParameters: string,
    /** The respective class prototype. */
    prototype: InterfacePrototype,
    /** Concrete type arguments, if any. */
    typeArguments: Type[] | null = null,
  ) {
    super(
      nameInclTypeParameters,
      prototype,
      typeArguments,
      true
    );
  }
}

/** Registers a concrete element with a program. */
function registerConcreteElement(program: Program, element: Element): void {
  assert(!program.instancesByName.has(element.internalName));
  program.instancesByName.set(element.internalName, element);
}

/** Attempts to merge two elements. Returns the merged element on success. */
function tryMerge(older: Element, newer: Element): DeclaredElement | null {
  // NOTE: some of the following cases are not supported by TS, not sure why exactly.
  // suggesting to just merge what seems to be possible for now and revisit later.
  assert(older.program === newer.program);
  if (newer.members) return null;
  var merged: DeclaredElement | null = null;
  switch (older.kind) {
    case ElementKind.FUNCTION_PROTOTYPE: {
      switch (newer.kind) {
        case ElementKind.NAMESPACE: {
          copyMembers(newer, older);
          merged = <DeclaredElement>older;
          break;
        }
        case ElementKind.TYPEDEFINITION: {
          if (!older.shadowType) {
            older.shadowType = <TypeDefinition>newer;
            copyMembers(newer, older);
            merged = <DeclaredElement>older;
          }
          break;
        }
      }
      break;
    }
    case ElementKind.CLASS_PROTOTYPE:
    case ElementKind.ENUM: {
      if (newer.kind == ElementKind.NAMESPACE) {
        copyMembers(newer, older);
        merged = <DeclaredElement>older;
        break;
      }
      break;
    }
    case ElementKind.NAMESPACE: {
      switch (newer.kind) {
        case ElementKind.ENUM:
        case ElementKind.CLASS_PROTOTYPE:      // TS2434
        case ElementKind.FUNCTION_PROTOTYPE: { // TS2434
          copyMembers(older, newer);
          merged = <DeclaredElement>newer;
          break;
        }
        case ElementKind.NAMESPACE: {
          copyMembers(newer, older);
          merged = <DeclaredElement>older;
          break;
        }
        case ElementKind.TYPEDEFINITION: {
          if (!older.shadowType) {
            older.shadowType = <TypeDefinition>newer;
            copyMembers(newer, older);
            merged = <DeclaredElement>older;
          }
          break;
        }
      }
      break;
    }
    case ElementKind.GLOBAL: {
      if (newer.kind == ElementKind.TYPEDEFINITION) {
        if (!older.shadowType) {
          older.shadowType = <TypeDefinition>newer;
          copyMembers(newer, older);
          merged = <DeclaredElement>older;
        }
      }
      break;
    }
    case ElementKind.TYPEDEFINITION: {
      switch (newer.kind) {
        case ElementKind.GLOBAL:
        case ElementKind.FUNCTION_PROTOTYPE:
        case ElementKind.NAMESPACE: {
          if (!newer.shadowType) {
            newer.shadowType = <TypeDefinition>older;
            copyMembers(older, newer);
            merged = <DeclaredElement>newer;
          }
          break;
        }
      }
      break;
    }
  }
  if (merged) {
    let olderIsExport = older.is(CommonFlags.EXPORT) || older.hasDecorator(DecoratorFlags.GLOBAL);
    let newerIsExport = newer.is(CommonFlags.EXPORT) || newer.hasDecorator(DecoratorFlags.GLOBAL);
    if (olderIsExport != newerIsExport) {
      older.program.error(
        DiagnosticCode.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local,
        merged.identifierNode.range, merged.identifierNode.text
      );
    }
  }
  return merged;
}

/** Copies the members of `src` to `dest`. */
function copyMembers(src: Element, dest: Element): void {
  var srcMembers = src.members;
  if (srcMembers) {
    let destMembers = dest.members;
    if (!destMembers) dest.members = destMembers = new Map();
    // TODO: for (let [memberName, member] of srcMembers) {
    for (let _keys = Map_keys(srcMembers), i = 0, k = _keys.length; i < k; ++i) {
      let memberName = unchecked(_keys[i]);
      let member = assert(srcMembers.get(memberName));
      destMembers.set(memberName, member);
    }
  }
}

/** Mangles the internal name of an element with the specified name that is a child of the given parent. */
export function mangleInternalName(name: string, parent: Element, isInstance: bool, asGlobal: bool = false): string {
  switch (parent.kind) {
    case ElementKind.FILE: {
      if (asGlobal) return name;
      return parent.internalName + PATH_DELIMITER + name;
    }
    case ElementKind.FUNCTION: {
      if (asGlobal) return name;
      assert(!isInstance);
      return parent.internalName + INNER_DELIMITER + name;
    }
    case ElementKind.PROPERTY_PROTOTYPE: // properties are just containers
    case ElementKind.PROPERTY: {         //
      parent = parent.parent;
      // fall-through
    }
    default: {
      return mangleInternalName(parent.name, parent.parent, parent.is(CommonFlags.INSTANCE), asGlobal)
           + (isInstance ? INSTANCE_DELIMITER : STATIC_DELIMITER) + name;
    }
  }
}

// Cached default parameter names used where names are unknown.
var cachedDefaultParameterNames: string[] = [];

/** Gets the cached default parameter name for the specified index. */
export function getDefaultParameterName(index: i32): string {
  for (let i = cachedDefaultParameterNames.length; i <= index; ++i) {
    cachedDefaultParameterNames.push("$" + i.toString());
  }
  return cachedDefaultParameterNames[index];
}

'''
'''--- src/resolver.ts ---
/**
 * @fileoverview Resolve infrastructure to obtain types and elements.
 *
 * Similar to the compiler making instructions of expressions, the resolver
 * obtains metadata of expressions. As such, for each `compileX` method in
 * the compiler there is one `lookupX` method in the resolver returning the
 * respective IR element, respectively one `resolveX` method returning the
 * respective type of an expression. It is also able to make new elements,
 * like instances of classes given its concrete type arguments.
 *
 * @license Apache-2.0
 */

import {
  DiagnosticEmitter,
  DiagnosticCode
} from "./diagnostics";

import {
  Program,
  ElementKind,
  OperatorKind,
  Element,
  Class,
  ClassPrototype,
  Interface,
  Function,
  FunctionPrototype,
  VariableLikeElement,
  Property,
  PropertyPrototype,
  Field,
  FieldPrototype,
  Global,
  TypeDefinition,
  TypedElement,
  IndexSignature,
  isTypedElement,
  InterfacePrototype,
  DeclaredElement
} from "./program";

import {
  Flow
} from "./flow";

import {
  Range
} from "./tokenizer";

import {
  FunctionTypeNode,
  ParameterKind,
  TypeNode,
  NodeKind,
  NamedTypeNode,
  TypeName,
  TypeParameterNode,
  Node,
  IdentifierExpression,
  CallExpression,
  ElementAccessExpression,
  PropertyAccessExpression,
  LiteralExpression,
  LiteralKind,
  ParenthesizedExpression,
  AssertionExpression,
  Expression,
  IntegerLiteralExpression,
  UnaryPrefixExpression,
  UnaryPostfixExpression,
  AssertionKind,
  BinaryExpression,
  ThisExpression,
  SuperExpression,
  CommaExpression,
  InstanceOfExpression,
  TernaryExpression,
  isTypeOmitted,
  FunctionExpression,
  NewExpression,
  ArrayLiteralExpression
} from "./ast";

import {
  Type,
  Signature,
  typesToString,
  TypeKind
} from "./types";

import {
  CommonFlags,
  CommonNames
} from "./common";

import {
  uniqueMap,
  isPowerOf2
} from "./util";

import {
  Token,
  operatorTokenToString
} from "./tokenizer";

import {
  BuiltinNames
} from "./builtins";

/** Indicates whether errors are reported or not. */
export enum ReportMode {
  /** Report errors. */
  REPORT,
  /** Swallow errors. */
  SWALLOW
}

/** Provides tools to resolve types and expressions. */
export class Resolver extends DiagnosticEmitter {

  /** The program this resolver belongs to. */
  program: Program;

  /** Target expression of the previously resolved property or element access. */
  currentThisExpression: Expression | null = null;
  /** Element expression of the previously resolved element access. */
  currentElementExpression : Expression | null = null;

  /** Constructs the resolver for the specified program. */
  constructor(
    /** The program to construct a resolver for. */
    program: Program
  ) {
    super(program.diagnostics);
    this.program = program;
  }

  // ====================================================== Types ======================================================

  /** Resolves a {@link TypeNode} to a concrete {@link Type}. */
  resolveType(
    /** The type to resolve. */
    node: TypeNode,
    /** Contextual element. */
    ctxElement: Element,
    /** Contextual types, i.e. `T`. */
    ctxTypes: Map<string,Type> | null = null,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type | null {
    switch (node.kind) {
      case NodeKind.NAMEDTYPE: {
        return this.resolveNamedType(
          <NamedTypeNode>node,
          ctxElement,
          ctxTypes,
          reportMode
        );
      }
      case NodeKind.FUNCTIONTYPE: {
        return this.resolveFunctionType(
          <FunctionTypeNode>node,
          ctxElement,
          ctxTypes,
          reportMode
        );
      }
      default: assert(false);
    }
    return null;
  }

  /** Resolves a {@link NamedTypeNode} to a concrete {@link Type}. */
  private resolveNamedType(
    /** The type to resolve. */
    node: NamedTypeNode,
    /** Contextual element. */
    ctxElement: Element,
    /** Contextual types, i.e. `T`. */
    ctxTypes: Map<string,Type> | null = null,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type | null {
    var nameNode = node.name;
    var typeArgumentNodes = node.typeArguments;
    var isSimpleType = !nameNode.next;

    // Look up in contextual types if a simple type
    if (isSimpleType) {
      let simpleName = nameNode.identifier.text;
      if (ctxTypes !== null && ctxTypes.has(simpleName)) {
        let type = assert(ctxTypes.get(simpleName));
        if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {
          if (reportMode == ReportMode.REPORT) {
            this.error(
              DiagnosticCode.Type_0_is_not_generic,
              node.range, type.toString()
            );
          }
        }
        if (node.isNullable) {
          if (type.isInternalReference) return type.asNullable();
          if (reportMode == ReportMode.REPORT) {
            this.error(
              DiagnosticCode.Type_0_cannot_be_nullable,
              node.range, type.toString()
            );
          }
        }
        return type;
      }
    }

    // Look up in context
    var element = this.resolveTypeName(nameNode, ctxElement, reportMode);
    if (!element) return null;

    // Use shadow type if present (i.e. namespace sharing a type)
    var shadowType = element.shadowType;
    if (shadowType) {
      element = shadowType;

    } else {

      // Handle enums (become i32)
      if (element.kind == ElementKind.ENUM) {
        if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {
          if (reportMode == ReportMode.REPORT) {
            this.error(
              DiagnosticCode.Type_0_is_not_generic,
              node.range, element.internalName
            );
          }
        }
        if (node.isNullable) {
          if (reportMode == ReportMode.REPORT) {
            this.error(
              DiagnosticCode.Type_0_cannot_be_nullable,
              node.range, element.name + "/i32"
            );
          }
        }
        return Type.i32;
      }

      // Handle classes and interfaces
      if (
        element.kind == ElementKind.CLASS_PROTOTYPE ||
        element.kind == ElementKind.INTERFACE_PROTOTYPE
      ) {
        let instance = this.resolveClassInclTypeArguments(
          <ClassPrototype>element,
          typeArgumentNodes,
          ctxElement,
          uniqueMap<string,Type>(ctxTypes), // don't inherit
          node,
          reportMode
        );
        if (!instance) return null;
        return node.isNullable ? instance.type.asNullable() : instance.type;
      }
    }

    // Handle type definitions
    if (element.kind == ElementKind.TYPEDEFINITION) {
      let typeDefinition = <TypeDefinition>element;

      // Shortcut already resolved (mostly builtins)
      if (element.is(CommonFlags.RESOLVED)) {
        if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {
          if (reportMode == ReportMode.REPORT) {
            this.error(
              DiagnosticCode.Type_0_is_not_generic,
              node.range, element.internalName
            );
          }
        }
        let type = typeDefinition.type;
        if (node.isNullable) {
          if (type.isInternalReference) return type.asNullable();
          if (reportMode == ReportMode.REPORT) {
            this.error(
              DiagnosticCode.Type_0_cannot_be_nullable,
              nameNode.range, nameNode.identifier.text
            );
          }
        }
        return type;
      }

      // Handle special built-in types
      if (isSimpleType) {
        let text = nameNode.identifier.text;
        if (text == CommonNames.native) return this.resolveBuiltinNativeType(node, ctxElement, ctxTypes, reportMode);
        if (text == CommonNames.indexof) return this.resolveBuiltinIndexofType(node, ctxElement, ctxTypes, reportMode);
        if (text == CommonNames.valueof) return this.resolveBuiltinValueofType(node, ctxElement, ctxTypes, reportMode);
        if (text == CommonNames.returnof) return this.resolveBuiltinReturnTypeType(node, ctxElement, ctxTypes, reportMode);
        if (text == CommonNames.nonnull) return this.resolveBuiltinNotNullableType(node, ctxElement, ctxTypes, reportMode);
      }

      // Resolve normally
      let typeParameterNodes = typeDefinition.typeParameterNodes;
      let typeArguments: Type[] | null = null;
      if (typeParameterNodes) {
        typeArguments = this.resolveTypeArguments(
          typeParameterNodes,
          typeArgumentNodes,
          ctxElement,
          ctxTypes = uniqueMap(ctxTypes), // update
          node,
          reportMode
        );
        if (!typeArguments) return null;
      } else if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {
        this.error(
          DiagnosticCode.Type_0_is_not_generic,
          node.range, nameNode.identifier.text
        );
      }
      let type = this.resolveType(
        typeDefinition.typeNode,
        element,
        ctxTypes,
        reportMode
      );
      if (!type) return null;
      if (node.isNullable) {
        if (type.isInternalReference) return type.asNullable();
        if (reportMode == ReportMode.REPORT) {
          this.error(
            DiagnosticCode.Type_0_cannot_be_nullable,
            nameNode.range, nameNode.identifier.text
          );
        }
      }
      return type;
    }
    if (reportMode == ReportMode.REPORT) {
      this.error(
        DiagnosticCode.Cannot_find_name_0,
        nameNode.range, nameNode.identifier.text
      );
    }
    return null;
  }

  /** Resolves a {@link FunctionTypeNode} to a concrete {@link Type}. */
  private resolveFunctionType(
    /** The type to resolve. */
    node: FunctionTypeNode,
    /** Contextual element. */
    ctxElement: Element,
    /** Contextual types, i.e. `T`. */
    ctxTypes: Map<string,Type> | null = null,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type | null {
    var explicitThisType = node.explicitThisType;
    var thisType: Type | null = null;
    if (explicitThisType) {
      thisType = this.resolveType(
        explicitThisType,
        ctxElement,
        ctxTypes,
        reportMode
      );
      if (!thisType) return null;
    }
    var parameterNodes = node.parameters;
    var numParameters = parameterNodes.length;
    var parameterTypes = new Array<Type>(numParameters);
    var requiredParameters = 0;
    var hasRest = false;
    for (let i = 0; i < numParameters; ++i) {
      let parameterNode = parameterNodes[i];
      switch (parameterNode.parameterKind) {
        case ParameterKind.DEFAULT: {
          requiredParameters = i + 1;
          break;
        }
        case ParameterKind.REST: {
          assert(i == numParameters);
          hasRest = true;
          break;
        }
      }
      let parameterTypeNode = parameterNode.type;
      if (isTypeOmitted(parameterTypeNode)) {
        if (reportMode == ReportMode.REPORT) {
          this.error(
            DiagnosticCode.Type_expected,
            parameterTypeNode.range
          );
        }
        return null;
      }
      let parameterType = this.resolveType(
        parameterTypeNode,
        ctxElement,
        ctxTypes,
        reportMode
      );
      if (!parameterType) return null;
      parameterTypes[i] = parameterType;
    }
    var returnTypeNode = node.returnType;
    var returnType: Type | null;
    if (isTypeOmitted(returnTypeNode)) {
      if (reportMode == ReportMode.REPORT) {
        this.error(
          DiagnosticCode.Type_expected,
          returnTypeNode.range
        );
      }
      returnType = Type.void;
    } else {
      returnType = this.resolveType(
        returnTypeNode,
        ctxElement,
        ctxTypes,
        reportMode
      );
      if (!returnType) return null;
    }
    var signature = new Signature(this.program, parameterTypes, returnType, thisType);
    signature.requiredParameters = requiredParameters;
    signature.hasRest = hasRest;
    return node.isNullable ? signature.type.asNullable() : signature.type;
  }

  private resolveBuiltinNativeType(
    /** The type to resolve. */
    node: NamedTypeNode,
    /** Contextual element. */
    ctxElement: Element,
    /** Contextual types, i.e. `T`. */
    ctxTypes: Map<string,Type> | null = null,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type | null {
    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);
    if (!typeArgumentNode) return null;
    var typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);
    if (!typeArgument) return null;
    switch (typeArgument.kind) {
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.I32: return Type.i32;
      case TypeKind.ISIZE: if (!this.program.options.isWasm64) return Type.i32;
      case TypeKind.I64: return Type.i64;
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.U32:
      case TypeKind.BOOL: return Type.u32;
      case TypeKind.USIZE: if (!this.program.options.isWasm64) return Type.u32;
      case TypeKind.U64: return Type.u64;
      case TypeKind.F32: return Type.f32;
      case TypeKind.F64: return Type.f64;
      case TypeKind.V128: return Type.v128;
      case TypeKind.VOID: return Type.void;
      default: assert(false);
    }
    return null;
  }

  private resolveBuiltinIndexofType(
    /** The type to resolve. */
    node: NamedTypeNode,
    /** Contextual element. */
    ctxElement: Element,
    /** Contextual types, i.e. `T`. */
    ctxTypes: Map<string,Type> | null = null,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type | null {
    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);
    if (!typeArgumentNode) return null;
    var typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);
    if (!typeArgument) return null;
    var classReference = typeArgument.classReference;
    if (!classReference) {
      if (reportMode == ReportMode.REPORT) {
        this.error(
          DiagnosticCode.Index_signature_is_missing_in_type_0,
          typeArgumentNode.range, typeArgument.toString()
        );
      }
      return null;
    }
    var overload = classReference.lookupOverload(OperatorKind.INDEXED_GET);
    if (overload) {
      if (overload.is(CommonFlags.STATIC)) {
        assert(overload.signature.parameterTypes.length == 2);
        return overload.signature.parameterTypes[1];
      } else {
        assert(overload.signature.parameterTypes.length == 1);
        return overload.signature.parameterTypes[0];
      }
    }
    if (reportMode == ReportMode.REPORT) {
      this.error(
        DiagnosticCode.Index_signature_is_missing_in_type_0,
        typeArgumentNode.range, typeArgument.toString()
      );
    }
    return null;
  }

  private resolveBuiltinValueofType(
    /** The type to resolve. */
    node: NamedTypeNode,
    /** Contextual element. */
    ctxElement: Element,
    /** Contextual types, i.e. `T`. */
    ctxTypes: Map<string,Type> | null = null,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type | null {
    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);
    if (!typeArgumentNode) return null;
    var typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);
    if (!typeArgument) return null;
    var classReference = typeArgument.getClassOrWrapper(this.program);
    if (classReference) {
      let overload = classReference.lookupOverload(OperatorKind.INDEXED_GET);
      if (overload) return overload.signature.returnType;
    }
    if (reportMode == ReportMode.REPORT) {
      this.error(
        DiagnosticCode.Index_signature_is_missing_in_type_0,
        typeArgumentNode.range, typeArgument.toString()
      );
    }
    return null;
  }

  private resolveBuiltinReturnTypeType(
    /** The type to resolve. */
    node: NamedTypeNode,
    /** Contextual element. */
    ctxElement: Element,
    /** Contextual types, i.e. `T`. */
    ctxTypes: Map<string,Type> | null = null,
    /** How to proceed with eventualy diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type | null {
    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);
    if (!typeArgumentNode) return null;
    var typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);
    if (!typeArgument) return null;
    var signatureReference = typeArgument.getSignature();
    if (signatureReference) return signatureReference.returnType;
    if (reportMode == ReportMode.REPORT) {
      this.error(
        DiagnosticCode.Type_0_has_no_call_signatures,
        typeArgumentNode.range, typeArgument.toString()
      );
    }
    return null;
  }

  private resolveBuiltinNotNullableType(
    /** The type to resolve. */
    node: NamedTypeNode,
    /** Contextual element. */
    ctxElement: Element,
    /** Contextual types, i.e. `T`. */
    ctxTypes: Map<string,Type> | null = null,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type | null {
    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);
    if (!typeArgumentNode) return null;
    var typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);
    if (!typeArgument) return null;
    if (!typeArgument.isNullableReference) return typeArgument;
    return typeArgument.nonNullableType;
  }

  /** Resolves a type name to the program element it refers to. */
  resolveTypeName(
    /** The type name to resolve. */
    node: TypeName,
    /** Contextual element. */
    ctxElement: Element,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Element | null {
    var element = ctxElement.lookup(node.identifier.text);
    if (!element) {
      if (reportMode == ReportMode.REPORT) {
        this.error(
          DiagnosticCode.Cannot_find_name_0,
          node.range, node.identifier.text
        );
      }
      return null;
    }
    var prev = node;
    var next = node.next;
    while (next) {
      if (!(element = element.lookupInSelf(next.identifier.text))) {
        if (reportMode == ReportMode.REPORT) {
          this.error(
            DiagnosticCode.Property_0_does_not_exist_on_type_1,
            next.range, next.identifier.text, prev.identifier.text
          );
        }
        return null;
      }
      prev = next;
      next = next.next;
    }
    return element;
  }

  /** Resolves an array of type arguments to concrete types. */
  resolveTypeArguments(
    /** Type parameter nodes present. */
    typeParameters: TypeParameterNode[],
    /** Type argument nodes provided. */
    typeArgumentNodes: TypeNode[] | null,
    /** Contextual element. */
    ctxElement: Element,
    /** Contextual types, i.e. `T`. Updated in place with the new set of contextual types. */
    ctxTypes: Map<string,Type> = uniqueMap<string,Type>(),
    /** Alternative report node in case of empty type arguments. */
    alternativeReportNode: Node | null = null,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type[] | null {
    var minParameterCount = 0;
    var maxParameterCount = 0;
    for (let i = 0, k = typeParameters.length; i < k; ++i) {
      if (!typeParameters[i].defaultType) ++minParameterCount;
      ++maxParameterCount;
    }
    var argumentCount = typeArgumentNodes ? typeArgumentNodes.length : 0;
    if (argumentCount < minParameterCount || argumentCount > maxParameterCount) {
      if (reportMode == ReportMode.REPORT) {
        this.error(
          DiagnosticCode.Expected_0_type_arguments_but_got_1,
          argumentCount
            ? Range.join(
                typeArgumentNodes![0].range,
                typeArgumentNodes![argumentCount - 1].range
              )
            : alternativeReportNode!.range,
          (argumentCount < minParameterCount ? minParameterCount : maxParameterCount).toString(),
          argumentCount.toString()
        );
      }
      return null;
    }
    var typeArguments = new Array<Type>(maxParameterCount);
    var oldCtxTypes = uniqueMap<string,Type>(ctxTypes);
    ctxTypes.clear();
    for (let i = 0; i < maxParameterCount; ++i) {
      let type = i < argumentCount
        ? this.resolveType( // reports
            typeArgumentNodes![i],
            ctxElement,
            oldCtxTypes, // update
            reportMode
          )
        : this.resolveType( // reports
            assert(typeParameters[i].defaultType),
            ctxElement,
            uniqueMap<string,Type>(ctxTypes), // don't update
            reportMode
          );
      if (!type) return null;
      // TODO: check extendsType
      ctxTypes.set(typeParameters[i].name.text, type);
      typeArguments[i] = type;
    }
    return typeArguments;
  }

  /** Resolves respectively infers the concrete instance of a function by call context. */
  maybeInferCall(
    node: CallExpression,
    prototype: FunctionPrototype,
    ctxFlow: Flow,
    reportMode: ReportMode = ReportMode.REPORT
  ): Function | null {
    var typeArguments = node.typeArguments;

    // resolve generic call if type arguments have been provided
    if (typeArguments) {
      if (!prototype.is(CommonFlags.GENERIC)) {
        if (reportMode == ReportMode.REPORT) {
          this.error(
            DiagnosticCode.Type_0_is_not_generic,
            node.expression.range, prototype.internalName
          );
        }
        return null;
      }
      return this.resolveFunctionInclTypeArguments(
        prototype,
        typeArguments,
        ctxFlow.actualFunction,
        uniqueMap(ctxFlow.contextualTypeArguments), // don't inherit
        node,
        reportMode
      );
    }

    // infer generic call if type arguments have been omitted
    if (prototype.is(CommonFlags.GENERIC)) {
      let contextualTypeArguments = uniqueMap<string,Type>(ctxFlow.contextualTypeArguments);

      // fill up contextual types with auto for each generic component
      let typeParameterNodes = assert(prototype.typeParameterNodes);
      let numTypeParameters = typeParameterNodes.length;
      let typeParameterNames = new Set<string>();
      for (let i = 0; i < numTypeParameters; ++i) {
        let name = typeParameterNodes[i].name.text;
        contextualTypeArguments.set(name, Type.auto);
        typeParameterNames.add(name);
      }

      let parameterNodes = prototype.functionTypeNode.parameters;
      let numParameters = parameterNodes.length;
      let argumentNodes = node.args;
      let numArguments = argumentNodes.length;

      // infer types with generic components while updating contextual types
      for (let i = 0; i < numParameters; ++i) {
        let argumentExpression = i < numArguments ? argumentNodes[i] : parameterNodes[i].initializer;
        if (!argumentExpression) { // missing initializer -> too few arguments
          if (reportMode == ReportMode.REPORT) {
            this.error(
              DiagnosticCode.Expected_0_arguments_but_got_1,
              node.range, numParameters.toString(), numArguments.toString()
            );
          }
          return null;
        }
        let typeNode = parameterNodes[i].type;
        if (typeNode.hasGenericComponent(typeParameterNodes)) {
          let type = this.resolveExpression(argumentExpression, ctxFlow, Type.auto, ReportMode.SWALLOW);
          if (type) this.propagateInferredGenericTypes(typeNode, type, ctxFlow, contextualTypeArguments, typeParameterNames);
        }
      }

      // apply concrete types to the generic function signature
      let resolvedTypeArguments = new Array<Type>(numTypeParameters);
      for (let i = 0; i < numTypeParameters; ++i) {
        let typeParameterNode = typeParameterNodes[i];
        let name = typeParameterNode.name.text;
        if (contextualTypeArguments.has(name)) {
          let inferredType = assert(contextualTypeArguments.get(name));
          if (inferredType != Type.auto) {
            resolvedTypeArguments[i] = inferredType;
            continue;
          }
          let defaultType = typeParameterNode.defaultType;
          if (defaultType) {
            let resolvedDefaultType = this.resolveType(defaultType, ctxFlow.actualFunction, contextualTypeArguments, reportMode);
            if (!resolvedDefaultType) return null;
            resolvedTypeArguments[i] = resolvedDefaultType;
            continue;
          }
        }
        // unused template, e.g. `function test<T>(): void {...}` called as `test()`
        // invalid because the type is effectively unknown inside the function body
        if (reportMode == ReportMode.REPORT) {
          this.error(
            DiagnosticCode.Type_argument_expected,
            node.expression.range.atEnd
          );
        }
        return null;
      }
      return this.resolveFunction(
        prototype,
        resolvedTypeArguments,
        uniqueMap<string,Type>(ctxFlow.contextualTypeArguments),
        reportMode
      );
    }

    // otherwise resolve the non-generic call as usual
    return this.resolveFunction(prototype, null, uniqueMap<string,Type>(), reportMode);
  }

  /** Updates contextual types with a possibly encapsulated inferred type. */
  private propagateInferredGenericTypes(
    /** The inferred type node. */
    node: TypeNode,
    /** The inferred type. */
    type: Type,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual types, i.e. `T`, with unknown types initialized to `auto`. */
    ctxTypes: Map<string,Type>,
    /** The names of the type parameters being inferred. */
    typeParameterNames: Set<string>
  ): void {
    if (node.kind == NodeKind.NAMEDTYPE) {
      let namedTypeNode = <NamedTypeNode>node;
      let typeArgumentNodes = namedTypeNode.typeArguments;
      if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) { // foo<T>(bar: Array<T>)
        let classReference = type.classReference;
        if (classReference) {
          let classPrototype = this.resolveTypeName(namedTypeNode.name, ctxFlow.actualFunction);
          if (!classPrototype || classPrototype.kind != ElementKind.CLASS_PROTOTYPE) return;
          if (classReference.prototype == <ClassPrototype>classPrototype) {
            let typeArguments = classReference.typeArguments;
            if (typeArguments !== null && typeArguments.length == typeArgumentNodes.length) {
              for (let i = 0, k = typeArguments.length; i < k; ++i) {
                this.propagateInferredGenericTypes(typeArgumentNodes[i], typeArguments[i], ctxFlow, ctxTypes, typeParameterNames);
              }
              return;
            }
          }
        }
      } else { // foo<T>(bar: T)
        let name = namedTypeNode.name.identifier.text;
        if (ctxTypes.has(name)) {
          let currentType = assert(ctxTypes.get(name));
          if (currentType == Type.auto || (typeParameterNames.has(name) && currentType.isAssignableTo(type))) {
            ctxTypes.set(name, type);
          }
        }
      }
    } else if (node.kind == NodeKind.FUNCTIONTYPE) { // foo<T>(bar: (baz: T) => i32))
      let functionTypeNode = <FunctionTypeNode>node;
      let parameterNodes = functionTypeNode.parameters;
      if (parameterNodes !== null && parameterNodes.length > 0) {
        let signatureReference = type.signatureReference;
        if (signatureReference) {
          let parameterTypes = signatureReference.parameterTypes;
          let thisType = signatureReference.thisType;
          if (parameterTypes.length == parameterNodes.length && !thisType == !functionTypeNode.explicitThisType) {
            for (let i = 0, k = parameterTypes.length; i < k; ++i) {
              this.propagateInferredGenericTypes(parameterNodes[i].type, parameterTypes[i], ctxFlow, ctxTypes, typeParameterNames);
            }
            this.propagateInferredGenericTypes(functionTypeNode.returnType, signatureReference.returnType, ctxFlow, ctxTypes, typeParameterNames);
            if (thisType) this.propagateInferredGenericTypes(functionTypeNode.explicitThisType!, thisType, ctxFlow, ctxTypes, typeParameterNames);
            return;
          }
        }
      }
    }
  }

  /** Gets the concrete type of an element. */
  getTypeOfElement(element: Element): Type | null {
    var kind = element.kind;
    if (kind == ElementKind.GLOBAL) {
      if (!this.ensureResolvedLazyGlobal(<Global>element, ReportMode.SWALLOW)) return null;
    }
    if (isTypedElement(kind)) {
      let type = (<TypedElement>element).type;
      let classReference = type.getClassOrWrapper(this.program);
      if (classReference) {
        let wrappedType = classReference.wrappedType;
        if (wrappedType) type = wrappedType;
      }
      return type;
    }
    return null;
  }

  /** Gets the element of a concrete type. */
  getElementOfType(type: Type): Element | null {
    let classReference = type.getClassOrWrapper(this.program);
    if (classReference) return classReference;
    return null;
  }

  // =================================================== Expressions ===================================================

  /** Looks up the program element the specified expression refers to. */
  lookupExpression(
    /** The expression to look up. */
    node: Expression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type = Type.auto,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Element | null {
    while (node.kind == NodeKind.PARENTHESIZED) { // skip
      node = (<ParenthesizedExpression>node).expression;
    }
    switch (node.kind) {
      case NodeKind.ASSERTION: {
        return this.lookupAssertionExpression(
          <AssertionExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.BINARY: {
        return this.lookupBinaryExpression(
          <BinaryExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.CALL: {
        return this.lookupCallExpression(
          <CallExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.COMMA: {
        return this.lookupCommaExpression(
          <CommaExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.ELEMENTACCESS: {
        return this.lookupElementAccessExpression(
          <ElementAccessExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.FUNCTION: {
        return this.lookupFunctionExpression(
          <FunctionExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.IDENTIFIER:
      case NodeKind.FALSE:
      case NodeKind.NULL:
      case NodeKind.TRUE: {
        return this.lookupIdentifierExpression(
          <IdentifierExpression>node,
          ctxFlow, ctxFlow.actualFunction, reportMode
        );
      }
      case NodeKind.THIS: {
        return this.lookupThisExpression(
          <ThisExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.SUPER: {
        return this.lookupSuperExpression(
          <SuperExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.INSTANCEOF: {
        return this.lookupInstanceOfExpression(
          <InstanceOfExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.LITERAL: {
        return this.lookupLiteralExpression(
          <LiteralExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.NEW: {
        return this.lookupNewExpression(
          <NewExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.PROPERTYACCESS: {
        return this.lookupPropertyAccessExpression(
          <PropertyAccessExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.TERNARY: {
        return this.lookupTernaryExpression(
          <TernaryExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.UNARYPOSTFIX: {
        return this.lookupUnaryPostfixExpression(
          <UnaryPostfixExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.UNARYPREFIX: {
        return this.lookupUnaryPrefixExpression(
          <UnaryPrefixExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
    }
    assert(false);
    return null;
  }

  /** Resolves an expression to its static type. */
  resolveExpression(
    /** The expression to resolve. */
    node: Expression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type = Type.auto,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type | null {
    while (node.kind == NodeKind.PARENTHESIZED) { // skip
      node = (<ParenthesizedExpression>node).expression;
    }
    switch (node.kind) {
      case NodeKind.ASSERTION: {
        return this.resolveAssertionExpression(
          <AssertionExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.BINARY: {
        return this.resolveBinaryExpression(
          <BinaryExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.CALL: {
        return this.resolveCallExpression(
          <CallExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.COMMA: {
        return this.resolveCommaExpression(
          <CommaExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.ELEMENTACCESS: {
        return this.resolveElementAccessExpression(
          <ElementAccessExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.FUNCTION: {
        return this.resolveFunctionExpression(
          <FunctionExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.IDENTIFIER:
      case NodeKind.FALSE:
      case NodeKind.NULL:
      case NodeKind.TRUE: {
        return this.resolveIdentifierExpression(
          <IdentifierExpression>node,
          ctxFlow, ctxType, ctxFlow.actualFunction, reportMode
        );
      }
      case NodeKind.THIS: {
        return this.resolveThisExpression(
          <ThisExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.SUPER: {
        return this.resolveSuperExpression(
          <SuperExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.INSTANCEOF: {
        return this.resolveInstanceOfExpression(
          <InstanceOfExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.LITERAL: {
        return this.resolveLiteralExpression(
          <LiteralExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.NEW: {
        return this.resolveNewExpression(
          <NewExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.PROPERTYACCESS: {
        return this.resolvePropertyAccessExpression(
          <PropertyAccessExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.TERNARY: {
        return this.resolveTernaryExpression(
          <TernaryExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.UNARYPOSTFIX: {
        return this.resolveUnaryPostfixExpression(
          <UnaryPostfixExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
      case NodeKind.UNARYPREFIX: {
        return this.resolveUnaryPrefixExpression(
          <UnaryPrefixExpression>node,
          ctxFlow, ctxType, reportMode
        );
      }
    }
    assert(false);
    return null;
  }

  /** Looks up the program element the specified identifier expression refers to. */
  lookupIdentifierExpression(
    /** The expression to look up. */
    node: IdentifierExpression,
    /** Flow to search for scoped locals. */
    ctxFlow: Flow,
    /** Element to search. */
    ctxElement: Element = ctxFlow.actualFunction, // differs for enums and namespaces
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Element | null {
    switch (node.kind) {
      case NodeKind.TRUE:
      case NodeKind.FALSE:
      case NodeKind.NULL: {
        let type = this.resolveIdentifierExpression(node, ctxFlow, Type.auto, ctxElement, reportMode);
        return type ? this.getElementOfType(type) : null;
      }
    }
    var name = node.text;
    var element: Element | null;
    if (element = ctxFlow.lookup(name)) {
      this.currentThisExpression = null;
      this.currentElementExpression = null;
      return element;
    }
    var outerFlow = ctxFlow.outer;
    if (outerFlow) {
      if (element = outerFlow.lookup(name)) {
        this.currentThisExpression = null;
        this.currentElementExpression = null;
        return element;
      }
    }
    if (element = ctxElement.lookup(name)) {
      this.currentThisExpression = null;
      this.currentElementExpression = null;
      return element;
    }
    if (element = this.program.lookup(name)) {
      this.currentThisExpression = null;
      this.currentElementExpression = null;
      return element;
    }
    if (reportMode == ReportMode.REPORT) {
      this.error(
        DiagnosticCode.Cannot_find_name_0,
        node.range, name
      );
    }
    return null;
  }

  /** Resolves an identifier to its static type. */
  private resolveIdentifierExpression(
    /** The expression to resolve. */
    node: IdentifierExpression,
    /** Flow to search for scoped locals. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type = Type.auto,
    /** Element to search. */
    ctxElement: Element = ctxFlow.actualFunction, // differs for enums and namespaces
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type | null {
    switch (node.kind) {
      case NodeKind.TRUE:
      case NodeKind.FALSE: return Type.bool;
      case NodeKind.NULL: {
        let classReference = ctxType.getClass();
        if (classReference) {
          return classReference.type.asNullable();
        } else {
          let signatureReference = ctxType.getSignature();
          if (signatureReference) {
            return signatureReference.type.asNullable();
          } else if (ctxType.isExternalReference) {
            return ctxType; // TODO: nullable?
          }
        }
        return this.program.options.usizeType;
      }
    }
    var element = this.lookupIdentifierExpression(node, ctxFlow, ctxElement, reportMode);
    if (!element) return null;
    if (element.kind == ElementKind.FUNCTION_PROTOTYPE) {
      let instance = this.resolveFunction(<FunctionPrototype>element, null, uniqueMap<string,Type>(), reportMode);
      if (!instance) return null;
      element = instance;
    }
    var type = this.getTypeOfElement(element);
    if (!type) {
      if (reportMode == ReportMode.REPORT) {
        this.error(
          DiagnosticCode.Expression_cannot_be_represented_by_a_type,
          node.range
        );
      }
    }
    return type;
  }

  /** Resolves a lazily compiled global, i.e. a static class field or annotated `@lazy`. */
  private ensureResolvedLazyGlobal(global: Global, reportMode: ReportMode = ReportMode.REPORT): bool {
    if (global.is(CommonFlags.RESOLVED)) return true;
    var type: Type | null;
    var typeNode = global.typeNode;
    if (typeNode) {
      type = this.resolveType(typeNode, global.parent, null, reportMode);
    } else {
      type = this.resolveExpression(assert(global.initializerNode), global.file.startFunction.flow, Type.auto, reportMode);
    }
    if (!type) return false;
    global.setType(type); // also sets resolved
    return true;
  }

  /** Looks up the program element the specified property access expression refers to. */
  private lookupPropertyAccessExpression(
    /** The expression to look up. */
    node: PropertyAccessExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Element | null {
    var targetNode = node.expression;
    var target = this.lookupExpression(targetNode, ctxFlow, ctxType, reportMode); // reports
    if (!target) return null;
    var propertyName = node.property.text;

    // Resolve variable-likes to their class type first
    switch (target.kind) {
      case ElementKind.GLOBAL: if (!this.ensureResolvedLazyGlobal(<Global>target, reportMode)) return null;
      case ElementKind.ENUMVALUE:
      case ElementKind.LOCAL:
      case ElementKind.FIELD: { // someVar.prop
        let variableLikeElement = <VariableLikeElement>target;
        let type = variableLikeElement.type;
        assert(type != Type.void);
        let classReference = type.getClassOrWrapper(this.program);
        if (!classReference) {
          if (reportMode == ReportMode.REPORT) {
            this.error(
              DiagnosticCode.Property_0_does_not_exist_on_type_1,
              node.property.range, propertyName, variableLikeElement.type.toString()
            );
          }
          return null;
        }
        target = classReference;
        break;
      }
      case ElementKind.PROPERTY_PROTOTYPE: { // SomeClass.prop
        let propertyInstance = this.resolveProperty(<PropertyPrototype>target, reportMode);
        if (!propertyInstance) return null;
        target = propertyInstance;
        // fall-through
      }
      case ElementKind.PROPERTY: { // someInstance.prop
        let propertyInstance = <Property>target;
        let getterInstance = assert(propertyInstance.getterInstance); // must have a getter
        let type = getterInstance.signature.returnType;
        let classReference = type.getClassOrWrapper(this.program);
        if (!classReference) {
          if (reportMode == ReportMode.REPORT) {
            this.error(
              DiagnosticCode.Property_0_does_not_exist_on_type_1,
              node.property.range, propertyName, type.toString()
            );
          }
          return null;
        }
        target = classReference;
        break;
      }
      case ElementKind.INDEXSIGNATURE: { // someInstance[x].prop
        let indexSignature = <IndexSignature>target;
        let parent = indexSignature.parent;
        assert(parent.kind == ElementKind.CLASS);
        let classInstance = <Class>parent;
        let elementExpression = assert(this.currentElementExpression);
        let indexedGet = classInstance.lookupOverload(OperatorKind.INDEXED_GET);
        if (!indexedGet) {
          if (reportMode == ReportMode.REPORT) {
            this.error(
              DiagnosticCode.Index_signature_is_missing_in_type_0,
              elementExpression.range, parent.internalName
            );
          }
          return null;
        }
        let returnType = indexedGet.signature.returnType;
        let classReference = returnType.getClassOrWrapper(this.program);
        if (!classReference) {
          if (reportMode == ReportMode.REPORT) {
            this.error(
              DiagnosticCode.Property_0_does_not_exist_on_type_1,
              node.property.range, propertyName, returnType.toString()
            );
          }
          return null;
        }
        target = classReference;
        break;
      }
      case ElementKind.FUNCTION_PROTOTYPE: {
        // Function with shadow type, i.e. function Symbol() + type Symbol = _Symbol
        let shadowType = target.shadowType;
        if (shadowType) {
          if (!shadowType.is(CommonFlags.RESOLVED)) {
            let resolvedType = this.resolveType(shadowType.typeNode, shadowType.parent, null, reportMode);
            if (resolvedType) shadowType.setType(resolvedType);
          }
          let classReference = shadowType.type.classReference;
          if (classReference) target = classReference.prototype;
          break;
        } else if (!target.is(CommonFlags.GENERIC)) {
          // Inherit from 'Function' if not overridden, i.e. fn.call
          let members = target.members;
          if (!members || !members.has(propertyName)) {
            let functionInstance = this.resolveFunction(<FunctionPrototype>target, null, uniqueMap<string,Type>(), ReportMode.SWALLOW);
            if (functionInstance) {
              let wrapper = functionInstance.type.getClassOrWrapper(this.program);
              if (wrapper) target = wrapper;
            }
          }
        }
        break;
      }
    }

    // Look up the member within
    switch (target.kind) {
      case ElementKind.CLASS_PROTOTYPE:
      case ElementKind.INTERFACE_PROTOTYPE:
      case ElementKind.CLASS:
      case ElementKind.INTERFACE: {
        do {
          let members = target.members;
          if (members !== null && members.has(propertyName)) {
            let member = assert(members.get(propertyName));
            if (member.kind == ElementKind.PROPERTY_PROTOTYPE) {
              let propertyInstance = this.resolveProperty(<PropertyPrototype>member, reportMode);
              if (!propertyInstance) return null;
              member = propertyInstance;
              if (propertyInstance.is(CommonFlags.STATIC)) {
                this.currentThisExpression = null;
              } else {
                this.currentThisExpression = targetNode;
              }
            } else {
              this.currentThisExpression = targetNode;
            }
            this.currentElementExpression = null;
            return member; // instance FIELD, static GLOBAL, FUNCTION_PROTOTYPE, PROPERTY...
          }
          // traverse inherited static members on the base prototype if target is a class prototype
          if (
            target.kind == ElementKind.CLASS_PROTOTYPE ||
            target.kind == ElementKind.INTERFACE_PROTOTYPE
          ) {
            let classPrototype = <ClassPrototype>target;
            let basePrototype = classPrototype.basePrototype;
            if (basePrototype) {
              target = basePrototype;
            } else {
              break;
            }
          // traverse inherited instance members on the base class if target is a class instance
          } else if (
            target.kind == ElementKind.CLASS ||
            target.kind == ElementKind.INTERFACE
          ) {
            let classInstance = <Class>target;
            let baseInstance = classInstance.base;
            if (baseInstance) {
              target = baseInstance;
            } else {
              break;
            }
          } else {
            break;
          }
        } while (true);
        break;
      }
      default: { // enums or other namespace-like elements
        let members = target.members;
        if (members !== null && members.has(propertyName)) {
          this.currentThisExpression = targetNode;
          this.currentElementExpression = null;
          return assert(members.get(propertyName)); // static ENUMVALUE, static GLOBAL, static FUNCTION_PROTOTYPE...
        }
        break;
      }
    }

    if (reportMode == ReportMode.REPORT) {
      this.error(
        DiagnosticCode.Property_0_does_not_exist_on_type_1,
        node.property.range, propertyName, target.internalName
      );
    }
    return null;
  }

  /** Resolves a property access expression to its static type. */
  private resolvePropertyAccessExpression(
    /** The expression to resolve. */
    node: PropertyAccessExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type | null {
    var element = this.lookupPropertyAccessExpression(node, ctxFlow, ctxType, reportMode);
    if (!element) return null;
    var type = this.getTypeOfElement(element);
    if (!type) {
      if (reportMode == ReportMode.REPORT) {
        this.error(
          DiagnosticCode.Expression_cannot_be_represented_by_a_type,
          node.range
        );
      }
    }
    return type;
  }

  /** Looks up the program element the specified element access expression refers to. */
  private lookupElementAccessExpression(
    /** The expression to look up. */
    node: ElementAccessExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Element | null {
    var targetExpression = node.expression;
    var targetType = this.resolveExpression(targetExpression, ctxFlow, ctxType, reportMode);
    if (!targetType) return null;
    let classReference = targetType.getClassOrWrapper(this.program);
    if (classReference) {
      do {
        let indexSignature = classReference.indexSignature;
        if (indexSignature) {
          this.currentThisExpression = targetExpression;
          this.currentElementExpression = node.elementExpression;
          return indexSignature;
        }
        classReference = classReference.base;
      } while(classReference);
    }
    if (reportMode == ReportMode.REPORT) {
      this.error(
        DiagnosticCode.Index_signature_is_missing_in_type_0,
        targetExpression.range, targetType.toString()
      );
    }
    return null;
  }

  /** Resolves an element access expression to its static type. */
  private resolveElementAccessExpression(
    /** The expression to resolve. */
    node: ElementAccessExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type | null {
    var element = this.lookupElementAccessExpression(node, ctxFlow, ctxType, reportMode);
    if (!element) return null;
    var type = this.getTypeOfElement(element);
    if (!type) {
      if (reportMode == ReportMode.REPORT) {
        this.error(
          DiagnosticCode.Expression_cannot_be_represented_by_a_type,
          node.range
        );
      }
    }
    return type;
  }

  /** Determines the final type of an integer literal given the specified contextual type. */
  determineIntegerLiteralType(
    /** Integer literal value. */
    intValue: i64,
    /** Contextual type. */
    ctxType: Type
  ): Type {
    if (ctxType.isValue) {
      // compile to contextual type if matching
      switch (ctxType.kind) {
        case TypeKind.I8: {
          if (i64_is_i8(intValue)) return Type.i8;
          break;
        }
        case TypeKind.U8: {
          if (i64_is_u8(intValue)) return Type.u8;
          break;
        }
        case TypeKind.I16: {
          if (i64_is_i16(intValue)) return Type.i16;
          break;
        }
        case TypeKind.U16: {
          if (i64_is_u16(intValue)) return Type.u16;
          break;
        }
        case TypeKind.I32: {
          if (i64_is_i32(intValue)) return Type.i32;
          break;
        }
        case TypeKind.U32: {
          if (i64_is_u32(intValue)) return Type.u32;
          break;
        }
        case TypeKind.BOOL: {
          if (i64_is_bool(intValue)) return Type.bool;
          break;
        }
        case TypeKind.ISIZE: {
          if (!this.program.options.isWasm64) {
            if (i64_is_i32(intValue)) return Type.isize32;
            break;
          }
          return Type.isize64;
        }
        case TypeKind.USIZE: {
          if (!this.program.options.isWasm64) {
            if (i64_is_u32(intValue)) return Type.usize32;
            break;
          }
          return Type.usize64;
        }
        case TypeKind.I64: return Type.i64;
        case TypeKind.U64: return Type.u64;
        case TypeKind.F32: return Type.f32;
        case TypeKind.F64: return Type.f64;
      }
    }
    // otherwise compile to best fitting type
    if (i64_is_i32(intValue)) return Type.i32;
    if (i64_is_u32(intValue)) return Type.u32;
    return Type.i64; // TODO: u64 if positive and larger than i64?
  }

  /** Looks up the program element the specified assertion expression refers to. */
  private lookupAssertionExpression(
    /** The expression to look up. */
    node: AssertionExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type = Type.auto,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Element | null {
    switch (node.assertionKind) {
      case AssertionKind.AS:
      case AssertionKind.PREFIX: {
        let type = this.resolveType(
          assert(node.toType), // must be set if not NONNULL
          ctxFlow.actualFunction,
          ctxFlow.contextualTypeArguments,
          reportMode
        );
        if (!type) return null;
        let element = this.getElementOfType(type);
        if (element) return element;
        if (reportMode == ReportMode.REPORT) {
          this.error(
            DiagnosticCode.Type_0_is_illegal_in_this_context,
            node.range, type.toString()
          );
        }
        this.currentThisExpression = null;
        this.currentElementExpression = null;
        return null;
      }
      case AssertionKind.NONNULL: {
        return this.lookupExpression(node.expression, ctxFlow, ctxType, reportMode);
      }
      case AssertionKind.CONST: {
        // TODO: decide on the layout of ReadonlyArray first
        // let element = this.lookupExpression(node.expression, ctxFlow, ctxType, reportMode);
        // if (!element) return null;
        // if (element.kind == ElementKind.CLASS && (<Class>element).extends(this.program.arrayPrototype)) {
        //   let elementType = assert((<Class>element).getTypeArgumentsTo(this.program.arrayPrototype))[0];
        //   return this.resolveClass(this.program.readonlyArrayPrototype, [ elementType ]);
        // }
        this.error(
          DiagnosticCode.Not_implemented_0,
          node.range,
          "Const assertion"
        );
        return null;
      }
    }
    assert(false);
    return null;
  }

  /** Resolves an assertion expression to its static type. */
  private resolveAssertionExpression(
    /** The expression to resolve. */
    node: AssertionExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type = Type.auto,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type | null {
    switch (node.assertionKind) {
      case AssertionKind.AS:
      case AssertionKind.PREFIX: {
        return this.resolveType(
          assert(node.toType),
          ctxFlow.actualFunction,
          ctxFlow.contextualTypeArguments,
          reportMode
        );
      }
      case AssertionKind.NONNULL: {
        let type = this.resolveExpression(node.expression, ctxFlow, ctxType, reportMode);
        return type ? type.nonNullableType : null;
      }
      case AssertionKind.CONST: {
        let element = this.lookupExpression(node, ctxFlow, ctxType, reportMode);
        if (!element) return null;
        let type = this.getTypeOfElement(element);
        if (!type) {
          if (reportMode == ReportMode.REPORT) {
            this.error(
              DiagnosticCode.Expression_cannot_be_represented_by_a_type,
              node.range
            );
          }
        }
        return type;
      }
      default: assert(false);
    }
    return null;
  }

  /** Looks up the program element the specified unary prefix expression refers to. */
  private lookupUnaryPrefixExpression(
    /** The expression to look up. */
    node: UnaryPrefixExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type = Type.auto,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Element | null {
    var type = this.resolveUnaryPrefixExpression(node, ctxFlow, ctxType, reportMode);
    if (!type) return null;
    var element = this.getElementOfType(type);
    if (!element) {
      if (reportMode == ReportMode.REPORT) {
        this.error(
          DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
          node.range, operatorTokenToString(node.operator), type.toString()
        );
      }
    }
    return element;
  }

  /** Resolves an unary prefix expression to its static type. */
  private resolveUnaryPrefixExpression(
    /** The expression to resolve. */
    node: UnaryPrefixExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type = Type.auto,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type | null {
    var operand = node.operand;
    var operator = node.operator;
    switch (operator) {
      case Token.MINUS: {
        // implicitly negate if an integer literal to distinguish between i32/u32/i64
        if (operand.isLiteralKind(LiteralKind.INTEGER)) {
          return this.determineIntegerLiteralType(i64_sub(i64_zero, (<IntegerLiteralExpression>operand).value), ctxType);
        }
        // fall-through
      }
      case Token.PLUS:
      case Token.PLUS_PLUS:
      case Token.MINUS_MINUS: {
        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);
        if (!type) return null;
        let classReference = type.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.fromUnaryPrefixToken(operator));
          if (overload) return overload.signature.returnType;
        }
        if (!type.isNumericValue) {
          if (reportMode == ReportMode.REPORT) {
            this.error(
              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
              node.range, operatorTokenToString(operator), type.toString()
            );
          }
          return null;
        }
        return type;
      }
      case Token.EXCLAMATION: {
        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);
        if (!type) return null;
        let classReference = type.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.NOT);
          if (overload) return overload.signature.returnType;
        }
        return Type.bool; // incl. references
      }
      case Token.TILDE: {
        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);
        if (!type) return null;
        let classReference = type.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.BITWISE_NOT);
          if (overload) return overload.signature.returnType;
        }
        if (!type.isNumericValue) {
          if (reportMode == ReportMode.REPORT) {
            this.error(
              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
              node.range, "~", type.toString()
            );
          }
          return null;
        }
        return type.intType;
      }
      case Token.DOT_DOT_DOT: {
        if (reportMode == ReportMode.REPORT) {
          this.error(
            DiagnosticCode.Not_implemented_0,
            node.range, "Spread operator"
          );
        }
        return null;
      }
      default: assert(false);
    }
    return null;
  }

  /** Looks up the program element the specified unary postfix expression refers to. */
  private lookupUnaryPostfixExpression(
    /** The expression to resolve. */
    node: UnaryPostfixExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type = Type.auto,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Element | null {
    var type = this.resolveUnaryPostfixExpression(node, ctxFlow, ctxType, reportMode);
    if (!type) return null;
    var element = this.getElementOfType(type);
    if (!element) {
      if (reportMode == ReportMode.REPORT) {
        this.error(
          DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
          node.range, operatorTokenToString(node.operator), type.toString()
        );
      }
    }
    return element;
  }

  /** Resolves an unary postfix expression to its static type. */
  private resolveUnaryPostfixExpression(
    /** The expression to resolve. */
    node: UnaryPostfixExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type = Type.auto,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type | null {
    var operator = node.operator;
    switch (operator) {
      case Token.PLUS_PLUS:
      case Token.MINUS_MINUS: {
        let type = this.resolveExpression(node.operand, ctxFlow, ctxType, reportMode);
        if (!type) return null;
        let classReference = type.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.fromUnaryPostfixToken(operator));
          if (overload) return overload.signature.returnType;
        }
        if (!type.isNumericValue) {
          if (reportMode == ReportMode.REPORT) {
            this.error(
              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
              node.range, operatorTokenToString(operator), type.toString()
            );
          }
          return null;
        }
        return type;
      }
    }
    assert(false);
    return null;
  }

  /** Looks up the program element the specified binary expression refers to. */
  private lookupBinaryExpression(
    /** The expression to look up. */
    node: BinaryExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type = Type.auto,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Element | null {
    var type = this.resolveBinaryExpression(node, ctxFlow, ctxType, reportMode);
    if (!type) return null;
    var element = this.getElementOfType(type);
    if (element) return element; // otherwise void
    if (reportMode == ReportMode.REPORT) {
      this.error(
        DiagnosticCode.Type_0_is_illegal_in_this_context,
        node.range, type.toString()
      );
    }
    return null;
  }

  /** Resolves a binary expression to its static type. */
  private resolveBinaryExpression(
    /** The expression to resolve. */
    node: BinaryExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type = Type.auto,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type | null {
    var left = node.left;
    var right = node.right;
    var operator = node.operator;

    switch (operator) {

      // assignment: result is the target's type

      case Token.EQUALS:
      case Token.PLUS_EQUALS:
      case Token.MINUS_EQUALS:
      case Token.ASTERISK_EQUALS:
      case Token.ASTERISK_ASTERISK_EQUALS:
      case Token.SLASH_EQUALS:
      case Token.PERCENT_EQUALS:
      case Token.LESSTHAN_LESSTHAN_EQUALS:
      case Token.GREATERTHAN_GREATERTHAN_EQUALS:
      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:
      case Token.AMPERSAND_EQUALS:
      case Token.BAR_EQUALS:
      case Token.CARET_EQUALS: {
        return this.resolveExpression(left, ctxFlow, ctxType, reportMode);
      }

      // comparison: result is Bool, preferring overloads, integer/float only

      case Token.LESSTHAN:
      case Token.GREATERTHAN:
      case Token.LESSTHAN_EQUALS:
      case Token.GREATERTHAN_EQUALS: {
        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);
        if (!leftType) return null;
        let classReference = leftType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));
          if (overload) return overload.signature.returnType;
        }
        if (!leftType.isNumericValue) {
          if (reportMode == ReportMode.REPORT) {
            this.error(
              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
              node.range, operatorTokenToString(operator), leftType.toString()
            );
          }
          return null;
        }
        return Type.bool;
      }

      // equality: result is Bool, preferring overloads, incl. references

      case Token.EQUALS_EQUALS:
      case Token.EXCLAMATION_EQUALS: {
        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);
        if (!leftType) return null;
        let classReference = leftType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));
          if (overload) return overload.signature.returnType;
        }
        return Type.bool;
      }

      // identity: result is Bool, not supporting overloads

      case Token.EQUALS_EQUALS_EQUALS:
      case Token.EXCLAMATION_EQUALS_EQUALS: {
        return Type.bool;
      }

      // arithmetics: result is common type of LHS and RHS, preferring overloads

      case Token.PLUS:
      case Token.MINUS:
      case Token.ASTERISK:
      case Token.SLASH:
      case Token.PERCENT: { // mod has special logic, but also behaves like this
        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);
        if (!leftType) return null;
        let classReference = leftType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));
          if (overload) return overload.signature.returnType;
        }
        let rightType = this.resolveExpression(right, ctxFlow, leftType, reportMode);
        if (!rightType) return null;
        let commonType = Type.commonDenominator(leftType, rightType, false);
        if (!commonType) {
          if (reportMode == ReportMode.REPORT) {
            this.error(
              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,
              node.range, leftType.toString(), rightType.toString()
            );
          }
        }
        return commonType;
      }

      // pow: result is common type of LHS and RHS, preferring overloads

      case Token.ASTERISK_ASTERISK: {
        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);
        if (!leftType) return null;
        let classReference = leftType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));
          if (overload) return overload.signature.returnType;
        }
        let rightType = this.resolveExpression(right, ctxFlow, leftType, reportMode);
        if (!rightType) return null;
        let commonType = Type.commonDenominator(leftType, rightType, false);
        if (!commonType) {
          if (reportMode == ReportMode.REPORT) {
            this.error(
              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,
              node.range, leftType.toString(), rightType.toString()
            );
          }
        }
        return commonType;
      }

      // shift: result is LHS (RHS is converted to LHS), preferring overloads

      case Token.LESSTHAN_LESSTHAN:
      case Token.GREATERTHAN_GREATERTHAN:
      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: {
        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);
        if (!leftType) return null;
        let classReference = leftType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));
          if (overload) return overload.signature.returnType;
        }
        if (!leftType.isIntegerValue) {
          if (reportMode == ReportMode.REPORT) {
            this.error(
              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,
              node.range, operatorTokenToString(operator), leftType.toString()
            );
          }
          return null;
        }
        return leftType;
      }

      // bitwise: result is common type of LHS and RHS with floats not being supported, preferring overloads

      case Token.AMPERSAND:
      case Token.BAR:
      case Token.CARET: {
        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);
        if (!leftType) return null;
        let classReference = leftType.getClassOrWrapper(this.program);
        if (classReference) {
          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));
          if (overload) return overload.signature.returnType;
        }
        let rightType = this.resolveExpression(right, ctxFlow, ctxType, reportMode);
        if (!rightType) return null;
        let commonType = Type.commonDenominator(leftType, rightType, false);
        if (!commonType || !commonType.isIntegerValue) {
          if (reportMode == ReportMode.REPORT) {
            this.error(
              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,
              node.range, operatorTokenToString(operator), leftType.toString(), rightType.toString()
            );
          }
        }
        return commonType;
      }

      // logical: result is LHS (RHS is converted to LHS), not supporting overloads

      case Token.AMPERSAND_AMPERSAND:
      case Token.BAR_BAR: {
        return this.resolveExpression(left, ctxFlow, ctxType, reportMode);
      }
    }
    assert(false);
    return null;
  }

  /** Looks up the program element the specified this expression refers to. */
  private lookupThisExpression(
    /** The expression to look up. */
    node: ThisExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type = Type.auto,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Element | null {
    if (ctxFlow.isInline) {
      let thisLocal = ctxFlow.lookupLocal(CommonNames.this_);
      if (thisLocal) {
        this.currentThisExpression = null;
        this.currentElementExpression = null;
        return thisLocal;
      }
    }
    var parent = ctxFlow.actualFunction.parent;
    if (parent) {
      this.currentThisExpression = null;
      this.currentElementExpression = null;
      return parent;
    }
    if (reportMode == ReportMode.REPORT) {
      this.error(
        DiagnosticCode._this_cannot_be_referenced_in_current_location,
        node.range
      );
    }
    return null;
  }

  /** Resolves a this expression to its static type. */
  private resolveThisExpression(
    /** The expression to resolve. */
    node: ThisExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type = Type.auto,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type | null {
    var element = this.lookupThisExpression(node, ctxFlow, ctxType, reportMode);
    if (!element) return null;
    var type = this.getTypeOfElement(element);
    if (!type) {
      if (reportMode == ReportMode.REPORT) {
        this.error(
          DiagnosticCode.Expression_cannot_be_represented_by_a_type,
          node.range
        );
      }
    }
    return type;
  }

  /** Looks up the program element the specified super expression refers to. */
  private lookupSuperExpression(
    /** The expression to look up. */
    node: SuperExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type = Type.auto,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Element | null {
    if (ctxFlow.isInline) {
      let superLocal = ctxFlow.lookupLocal(CommonNames.super_);
      if (superLocal) {
        this.currentThisExpression = null;
        this.currentElementExpression = null;
        return superLocal;
      }
    }
    var parent: Element | null = ctxFlow.actualFunction.parent;
    if (parent !== null && parent.kind == ElementKind.CLASS) {
      let base = (<Class>parent).base;
      if (base) {
        this.currentThisExpression = null;
        this.currentElementExpression = null;
        return base;
      }
    }
    if (reportMode == ReportMode.REPORT) {
      this.error(
        DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,
        node.range
      );
    }
    return null;
  }

  /** Resolves a super expression to its static type. */
  private resolveSuperExpression(
    /** The expression to resolve. */
    node: SuperExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type = Type.auto,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type | null {
    var element = this.lookupSuperExpression(node, ctxFlow, ctxType, reportMode);
    if (!element) return null;
    var type = this.getTypeOfElement(element);
    if (!type) {
      if (reportMode == ReportMode.REPORT) {
        this.error(
          DiagnosticCode.Expression_cannot_be_represented_by_a_type,
          node.range
        );
      }
    }
    return type;
  }

  /** Looks up the program element the specified literal expression refers to. */
  private lookupLiteralExpression(
    /** The expression to look up. */
    node: LiteralExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type = Type.auto,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Element | null {
    this.currentThisExpression = node;
    this.currentElementExpression = null;
    switch (node.literalKind) {
      case LiteralKind.INTEGER: {
        let intType = this.determineIntegerLiteralType(
          (<IntegerLiteralExpression>node).value,
          ctxType
        );
        return assert(intType.getClassOrWrapper(this.program));
      }
      case LiteralKind.FLOAT: {
        let fltType = ctxType == Type.f32 ? Type.f32 : Type.f64;
        return assert(fltType.getClassOrWrapper(this.program));
      }
      case LiteralKind.STRING:
      case LiteralKind.TEMPLATE: {
        return this.program.stringInstance;
      }
      case LiteralKind.ARRAY: {
        let classReference = ctxType.getClass();
        if (classReference !== null && classReference.prototype == this.program.arrayPrototype) {
          return this.getElementOfType(ctxType);
        }
        // otherwise infer, ignoring ctxType
        let expressions = (<ArrayLiteralExpression>node).elementExpressions;
        let length = expressions.length;
        let elementType = Type.auto;
        let numNullLiterals = 0;
        for (let i = 0, k = length; i < k; ++i) {
          let expression = expressions[i];
          if (expression) {
            if (expression.kind == NodeKind.NULL && length > 1) {
              ++numNullLiterals;
            } else {
              let currentType = this.resolveExpression(expression, ctxFlow, elementType);
              if (!currentType) return null;
              if (elementType == Type.auto) elementType = currentType;
              else if (currentType != elementType) {
                let commonType = Type.commonDenominator(elementType, currentType, false);
                if (commonType) elementType = commonType;
                // otherwise triggers error on compilation
              }
            }
          }
        }
        if (elementType /* still */ == Type.auto) {
          if (numNullLiterals == length) { // all nulls infers as usize
            elementType = this.program.options.usizeType;
          } else {
            if (reportMode == ReportMode.REPORT) {
              this.error(
                DiagnosticCode.The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly,
                node.range, "T"
              );
            }
            return null;
          }
        }
        if (
          numNullLiterals > 0 &&
          elementType.isInternalReference
        ) {
          elementType = elementType.asNullable();
        }
        return assert(this.resolveClass(this.program.arrayPrototype, [ elementType ]));
      }
      case LiteralKind.OBJECT: {
        if (ctxType.isClass) return ctxType.classReference;
        if (reportMode == ReportMode.REPORT) {
          this.error(
            DiagnosticCode.Expression_cannot_be_represented_by_a_type,
            node.range
          );
        }
        return null;
      }
    }
    assert(false);
    return null;
  }

  /** Resolves a literal expression to its static type. */
  private resolveLiteralExpression(
    /** The expression to resolve. */
    node: LiteralExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type = Type.auto,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type | null {
    var element = this.lookupLiteralExpression(node, ctxFlow, ctxType, reportMode);
    if (!element) return null;
    var type = this.getTypeOfElement(element);
    if (!type) {
      if (reportMode == ReportMode.REPORT) {
        this.error(
          DiagnosticCode.Expression_cannot_be_represented_by_a_type,
          node.range
        );
      }
    }
    return type;
  }

  /** Looks up the program element the specified call expression refers to. */
  private lookupCallExpression(
    /** The expression to look up. */
    node: CallExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type = Type.void,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Element | null {
    var type = this.resolveCallExpression(node, ctxFlow, ctxType, reportMode);
    if (!type) return null;
    var element = this.getElementOfType(type);
    if (!element) {
      if (reportMode == ReportMode.REPORT) {
        this.error(
          DiagnosticCode.Type_0_is_illegal_in_this_context,
          node.range, type.toString()
        );
      }
    }
    return element;
  }

  /** Resolves a call expression to its static type. */
  private resolveCallExpression(
    /** The expression to resolve. */
    node: CallExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type = Type.void,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type | null {
    var targetExpression = node.expression;
    var target = this.lookupExpression( // reports
      targetExpression,
      ctxFlow,
      ctxType,
      reportMode
    );
    if (!target) return null;
    switch (target.kind) {
      case ElementKind.FUNCTION_PROTOTYPE: {
        let functionPrototype = <FunctionPrototype>target;
        // `unchecked` behaves like parenthesized
        if (
          functionPrototype.internalName == BuiltinNames.unchecked &&
          node.args.length > 0
        ) {
          return this.resolveExpression(node.args[0], ctxFlow, ctxType, reportMode);
        }
        let instance = this.maybeInferCall(node, functionPrototype, ctxFlow, reportMode);
        if (!instance) return null;
        return instance.signature.returnType;
      }
      case ElementKind.GLOBAL:
      case ElementKind.LOCAL:
      case ElementKind.FIELD: {
        let varType = (<VariableLikeElement>target).type;
        let varElement = this.getElementOfType(varType);
        if (!varElement || varElement.kind != ElementKind.CLASS) {
          break;
        }
        target = varElement;
        // fall-through
      }
      case ElementKind.CLASS: {
        let typeArguments = (<Class>target).getTypeArgumentsTo(this.program.functionPrototype);
        if (typeArguments !== null && typeArguments.length > 0) {
          let ftype = typeArguments[0];
          let signatureReference = assert(ftype.signatureReference);
          return signatureReference.returnType;
        }
        break;
      }
    }
    if (reportMode == ReportMode.REPORT) {
      this.error(
        DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,
        targetExpression.range, target.internalName
      );
    }
    return null;
  }

  /** Looks up the program element the specified comma expression refers to. */
  private lookupCommaExpression(
    /** The expression to look up. */
    node: CommaExpression,
    /** Flow to search for scoped locals. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type = Type.auto,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Element | null {
    var expressions = node.expressions;
    return this.lookupExpression(expressions[assert(expressions.length) - 1], ctxFlow, ctxType, reportMode);
  }

  /** Resolves a comma expression to its static type. */
  private resolveCommaExpression(
    /** The expression to resolve. */
    node: CommaExpression,
    /** Flow to search for scoped locals. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type = Type.auto,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type | null {
    var expressions = node.expressions;
    return this.resolveExpression(expressions[assert(expressions.length) - 1], ctxFlow, ctxType, reportMode);
  }

  /** Looks up the program element the specified instanceof expression refers to. */
  private lookupInstanceOfExpression(
    /** The expression to look up. */
    node: InstanceOfExpression,
    /** Flow to search for scoped locals. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type = Type.auto,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Element | null {
    return assert(Type.bool.getClassOrWrapper(this.program));
  }

  /** Resolves an instanceof expression to its static type. */
  private resolveInstanceOfExpression(
    /** The expression to resolve. */
    node: InstanceOfExpression,
    /** Flow to search for scoped locals. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type = Type.auto,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type | null {
    return Type.bool;
  }

  /** Looks up the program element the specified ternary expression refers to. */
  private lookupTernaryExpression(
    /** The expression to look up. */
    node: TernaryExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Element | null {
    var type = this.resolveTernaryExpression(node, ctxFlow, ctxType, reportMode);
    if (!type) return null;
    var element = this.getElementOfType(type);
    if (!element) {
      if (reportMode == ReportMode.REPORT) {
        this.error(
          DiagnosticCode.Type_0_is_illegal_in_this_context,
          node.range, type.toString()
        );
      }
    }
    return element;
  }

  /** Resolves a ternary expression to its static type. */
  private resolveTernaryExpression(
    /** The expression to resolve. */
    node: TernaryExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type | null {
    var thenType = this.resolveExpression(node.ifThen, ctxFlow, ctxType, reportMode);
    if (!thenType) return null;
    var elseType = this.resolveExpression(node.ifElse, ctxFlow, thenType, reportMode);
    if (!elseType) return null;
    var commonType = Type.commonDenominator(thenType, elseType, false);
    if (!commonType) {
      if (reportMode == ReportMode.REPORT) {
        this.error(
          DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,
          node.range, "?:", thenType.toString(), elseType.toString()
        );
      }
    }
    return commonType;
  }

  /** Looks up the program element the specified new expression refers to. */
  private lookupNewExpression(
    /** The expression to look up. */
    node: NewExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Element | null {
    var element = this.resolveTypeName(node.typeName, ctxFlow.actualFunction, reportMode);
    if (!element) return null;
    if (element.kind == ElementKind.CLASS_PROTOTYPE) {
      return this.resolveClassInclTypeArguments(
        <ClassPrototype>element,
        node.typeArguments,
        ctxFlow.actualFunction,
        uniqueMap<string,Type>(ctxFlow.contextualTypeArguments),
        node,
        reportMode
      );
    }
    if (reportMode == ReportMode.REPORT) {
      this.error(
        DiagnosticCode.This_expression_is_not_constructable,
        node.range
      );
    }
    return null;
  }

  /** Resolves a new expression to its static type. */
  private resolveNewExpression(
    /** The expression to resolve. */
    node: NewExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type | null {
    var element = this.lookupNewExpression(node, ctxFlow, ctxType, reportMode);
    if (!element) return null;
    var type = this.getTypeOfElement(element);
    if (!type) {
      if (reportMode == ReportMode.REPORT) {
        this.error(
          DiagnosticCode.Expression_cannot_be_represented_by_a_type,
          node.range
        );
      }
    }
    return type;
  }

  /** Looks up the program element the specified function expression refers to. */
  private lookupFunctionExpression(
    /** The expression to look up. */
    node: FunctionExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Element | null {
    var type = this.resolveFunctionExpression(node, ctxFlow, ctxType, reportMode);
    if (!type) return null;
    var element = this.getElementOfType(type);
    if (!element) {
      if (reportMode == ReportMode.REPORT) {
        this.error(
          DiagnosticCode.Type_0_is_illegal_in_this_context,
          node.range, type.toString()
        );
      }
    }
    return element;
  }

  /** Resolves a function expression to its static type. */
  private resolveFunctionExpression(
    /** The expression to resolve. */
    node: FunctionExpression,
    /** Contextual flow. */
    ctxFlow: Flow,
    /** Contextual type. */
    ctxType: Type,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Type | null {
    return this.resolveFunctionType(node.declaration.signature, ctxFlow.actualFunction, ctxFlow.contextualTypeArguments, reportMode);
  }

  // ==================================================== Elements =====================================================

  /** Resolves a function prototype using the specified concrete type arguments. */
  resolveFunction(
    /** The prototype of the function. */
    prototype: FunctionPrototype,
    /** Type arguments provided. */
    typeArguments: Type[] | null,
    /** Contextual types, i.e. `T`. */
    ctxTypes: Map<string,Type> = uniqueMap<string,Type>(),
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Function | null {
    var actualParent = prototype.parent.kind == ElementKind.PROPERTY_PROTOTYPE
      ? prototype.parent.parent
      : prototype.parent;
    var classInstance: Class | null = null; // if an instance method
    var instanceKey = typeArguments ? typesToString(typeArguments) : "";

    // Instance method prototypes are pre-bound to their concrete class as their parent
    if (prototype.is(CommonFlags.INSTANCE)) {
      assert(actualParent.kind == ElementKind.CLASS || actualParent.kind == ElementKind.INTERFACE);
      classInstance = <Class>actualParent;

      // check if this exact concrete class and function combination is known already
      let resolvedInstance = prototype.getResolvedInstance(instanceKey);
      if (resolvedInstance) return resolvedInstance;

      // inherit class specific type arguments
      let classTypeArguments = classInstance.typeArguments;
      if (classTypeArguments) {
        let classTypeParameters = assert(classInstance.prototype.typeParameterNodes);
        let numClassTypeArguments = classTypeParameters.length;
        assert(numClassTypeArguments == classTypeParameters.length);
        for (let i = 0; i < numClassTypeArguments; ++i) {
          let classTypeParameterName = classTypeParameters[i].name.text;
          if (!ctxTypes.has(classTypeParameterName)) {
            ctxTypes.set(
              classTypeParameterName,
              classTypeArguments[i]
            );
          }
        }
      }
    } else {
      assert(actualParent.kind != ElementKind.CLASS); // must not be pre-bound
      let resolvedInstance = prototype.getResolvedInstance(instanceKey);
      if (resolvedInstance) return resolvedInstance;
    }

    // override whatever is contextual with actual function type arguments
    var signatureNode = prototype.functionTypeNode;
    var typeParameterNodes = prototype.typeParameterNodes;
    var numFunctionTypeArguments: i32;
    if (typeArguments !== null && (numFunctionTypeArguments = typeArguments.length) > 0) {
      assert(typeParameterNodes !== null && numFunctionTypeArguments == typeParameterNodes.length);
      for (let i = 0; i < numFunctionTypeArguments; ++i) {
        ctxTypes.set(
          (<TypeParameterNode[]>typeParameterNodes)[i].name.text,
          typeArguments[i]
        );
      }
    } else {
      assert(!typeParameterNodes || typeParameterNodes.length == 0);
    }

    // resolve `this` type if applicable
    var thisType: Type | null = null;
    var explicitThisType = signatureNode.explicitThisType;
    if (explicitThisType) {
      thisType = this.resolveType(
        explicitThisType,
        prototype.parent, // relative to function
        ctxTypes,
        reportMode
      );
      if (!thisType) return null;
      ctxTypes.set(CommonNames.this_, thisType);
    } else if (classInstance) {
      thisType = classInstance.type;
      ctxTypes.set(CommonNames.this_, thisType);
    }

    // resolve parameter types
    var signatureParameters = signatureNode.parameters;
    var numSignatureParameters = signatureParameters.length;
    var parameterTypes = new Array<Type>(numSignatureParameters);
    var requiredParameters = 0;
    for (let i = 0; i < numSignatureParameters; ++i) {
      let parameterDeclaration = signatureParameters[i];
      if (parameterDeclaration.parameterKind == ParameterKind.DEFAULT) {
        requiredParameters = i + 1;
      }
      let typeNode = parameterDeclaration.type;
      if (isTypeOmitted(typeNode)) {
        if (reportMode == ReportMode.REPORT) {
          this.error(
            DiagnosticCode.Type_expected,
            typeNode.range
          );
        }
        return null;
      }
      let parameterType = this.resolveType(
        typeNode,
        prototype.parent, // relative to function
        ctxTypes,
        reportMode
      );
      if (!parameterType) return null;
      if (parameterType == Type.void) {
        if (reportMode == ReportMode.REPORT) {
          this.error(
            DiagnosticCode.Type_expected,
            typeNode.range
          );
        }
        return null;
      }
      parameterTypes[i] = parameterType;
    }

    // resolve return type
    var returnType: Type;
    if (prototype.is(CommonFlags.SET)) {
      returnType = Type.void; // not annotated
    } else if (prototype.is(CommonFlags.CONSTRUCTOR)) {
      returnType = classInstance!.type; // not annotated
    } else {
      let typeNode = signatureNode.returnType;
      if (isTypeOmitted(typeNode)) {
        if (reportMode == ReportMode.REPORT) {
          this.error(
            DiagnosticCode.Type_expected,
            typeNode.range
          );
        }
        return null;
      }
      let type = this.resolveType(
        typeNode,
        prototype.parent, // relative to function
        ctxTypes,
        reportMode
      );
      if (!type) return null;
      returnType = type;
    }

    var signature = new Signature(this.program, parameterTypes, returnType, thisType);
    signature.requiredParameters = requiredParameters;

    var nameInclTypeParameters = prototype.name;
    if (instanceKey.length) nameInclTypeParameters += "<" + instanceKey + ">";
    var instance = new Function(
      nameInclTypeParameters,
      prototype,
      typeArguments,
      signature,
      ctxTypes
    );
    prototype.setResolvedInstance(instanceKey, instance);
    return instance;
  }

  /** Resolves a function prototypeby first resolving the specified type arguments. */
  resolveFunctionInclTypeArguments(
    /** The prototype of the function. */
    prototype: FunctionPrototype,
    /** Type arguments provided to be resolved. */
    typeArgumentNodes: TypeNode[] | null,
    /** Contextual element. */
    ctxElement: Element,
    /** Contextual types, i.e. `T`. */
    ctxTypes: Map<string,Type>,
    /** The node to use when reporting intermediate errors. */
    reportNode: Node,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Function | null {
    var actualParent = prototype.parent.kind == ElementKind.PROPERTY_PROTOTYPE
      ? prototype.parent.parent
      : prototype.parent;
    var resolvedTypeArguments: Type[] | null = null;

    // Resolve type arguments if generic
    if (prototype.is(CommonFlags.GENERIC)) {

      // If this is an instance method, first apply the class's type arguments
      if (prototype.is(CommonFlags.INSTANCE)) {
        assert(actualParent.kind == ElementKind.CLASS);
        let classInstance = <Class>actualParent;
        let classTypeArguments = classInstance.typeArguments;
        if (classTypeArguments) {
          let typeParameterNodes = assert(classInstance.prototype.typeParameterNodes);
          let numClassTypeArguments = classTypeArguments.length;
          assert(numClassTypeArguments == typeParameterNodes.length);
          for (let i = 0; i < numClassTypeArguments; ++i) {
            ctxTypes.set(
              typeParameterNodes[i].name.text,
              classTypeArguments[i]
            );
          }
        }
      }

      resolvedTypeArguments = this.resolveTypeArguments( // reports
        assert(prototype.typeParameterNodes),
        typeArgumentNodes,
        ctxElement,
        ctxTypes, // update
        reportNode,
        reportMode
      );
      if (!resolvedTypeArguments) return null;

    // Otherwise make sure that no type arguments have been specified
    } else {
      if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {
        if (reportMode == ReportMode.REPORT) {
          this.error(
            DiagnosticCode.Type_0_is_not_generic,
            reportNode.range, prototype.internalName
          );
        }
        return null;
      }
    }

    // Continue with concrete types
    return this.resolveFunction(
      prototype,
      resolvedTypeArguments,
      ctxTypes,
      reportMode
    );
  }

  /** Currently resolving classes. */
  private resolveClassPending: Set<Class> = new Set();

  /** Resolves a class prototype using the specified concrete type arguments. */
  resolveClass(
    /** The prototype of the class. */
    prototype: ClassPrototype,
    /** Type arguments provided. */
    typeArguments: Type[] | null,
    /** Contextual types, i.e. `T`. */
    ctxTypes: Map<string,Type> = uniqueMap<string,Type>(),
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Class | null {
    var instanceKey = typeArguments ? typesToString(typeArguments) : "";

    // Do not attempt to resolve the same class twice. This can return a class
    // that isn't fully resolved yet, but only on deeper levels of recursion.
    var instance = prototype.getResolvedInstance(instanceKey);
    if (instance) return instance;

    // Otherwise create
    var nameInclTypeParamters = prototype.name;
    if (instanceKey.length) nameInclTypeParamters += "<" + instanceKey + ">";
    if (prototype.kind == ElementKind.INTERFACE_PROTOTYPE) {
      instance = new Interface(nameInclTypeParamters, <InterfacePrototype>prototype, typeArguments);
    } else {
      instance = new Class(nameInclTypeParamters, prototype, typeArguments);
    }
    prototype.setResolvedInstance(instanceKey, instance);
    var pendingClasses = this.resolveClassPending;
    pendingClasses.add(instance);

    // Insert contextual type arguments for this operation. Internally, this method is always
    // called with matching type parameter / argument counts.
    if (typeArguments) {
      let typeParameterNodes = assert(prototype.typeParameterNodes);
      let numTypeParameters = typeParameterNodes.length;
      let numTypeArguments = typeArguments.length;
      assert(numTypeArguments == numTypeParameters);
      for (let i = 0; i < numTypeArguments; ++i) {
        ctxTypes.set(typeParameterNodes[i].name.text, typeArguments[i]);
      }
    } else {
      let typeParameterNodes = prototype.typeParameterNodes;
      assert(!(typeParameterNodes !== null && typeParameterNodes.length > 0));
    }
    instance.contextualTypeArguments = ctxTypes;

    var anyPending = false;

    // Resolve base class if applicable
    var basePrototype = prototype.basePrototype;
    if (basePrototype) {
      let current: ClassPrototype | null = basePrototype;
      do {
        if (current == prototype) {
          this.error(
            DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,
            prototype.identifierNode.range,
            prototype.internalName
          );
          return null;
        }
        current = current.basePrototype;
      } while (current);
      let extendsNode = assert(prototype.extendsNode); // must be present if it has a base prototype
      let base = this.resolveClassInclTypeArguments(
        basePrototype,
        extendsNode.typeArguments,
        prototype.parent, // relative to derived class
        uniqueMap(ctxTypes), // don't inherit
        extendsNode,
        reportMode
      );
      if (!base) return null;
      instance.setBase(base);

      // If the base class is still pending, yield here and instead resolve any
      // derived classes once the base class's `finishResolveClass` is done.
      // This is guaranteed to never happen at the entry of the recursion, i.e.
      // where `resolveClass` is called from other code.
      if (pendingClasses.has(base)) anyPending = true;
    }

    // Resolve interfaces if applicable
    var interfacePrototypes = prototype.interfacePrototypes;
    if (interfacePrototypes) {
      for (let i = 0, k = interfacePrototypes.length; i < k; ++i) {
        let interfacePrototype = interfacePrototypes[i];
        let current: ClassPrototype | null = interfacePrototype;
        do {
          if (current == prototype) {
            this.error(
              DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,
              prototype.identifierNode.range,
              prototype.internalName
            );
            return null;
          }
          current = current.basePrototype;
        } while (current);
        let implementsNode = assert(prototype.implementsNodes![i]);
        let iface = this.resolveClassInclTypeArguments(
          interfacePrototype,
          implementsNode.typeArguments,
          prototype.parent,
          uniqueMap(ctxTypes),
          implementsNode,
          reportMode
        );
        if (!iface) return null;
        assert(iface.kind == ElementKind.INTERFACE);
        instance.addInterface(<Interface>iface);

        // Like above, if any implemented interface is still pending, yield
        if (pendingClasses.has(iface)) anyPending = true;
      }
    }
    if (anyPending) return instance;

    // We only get here if the base class has been fully resolved already.
    this.finishResolveClass(instance, reportMode);
    return instance;
  }

  /** Finishes resolving the specified class. */
  private finishResolveClass(
    /** Class to finish resolving. */
    instance: Class,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode
  ): void {
    var members = instance.members;
    if (!members) instance.members = members = new Map();

    var pendingClasses = this.resolveClassPending;
    var unimplemented = new Map<string,DeclaredElement>();

    // Alias interface members
    var interfaces = instance.interfaces;
    if (interfaces) {
      for (let _values = Set_values(interfaces), i = 0, k = _values.length; i < k; ++i) {
        let iface = _values[i];
        assert(!pendingClasses.has(iface));
        let ifaceMembers = iface.members;
        if (ifaceMembers) {
          for (let _keys = Map_keys(ifaceMembers), i = 0, k = _keys.length; i < k; ++i) {
            let memberName = unchecked(_keys[i]);
            let member = assert(ifaceMembers.get(memberName));
            if (members.has(memberName)) {
              let existing = assert(members.get(memberName));
              if (!member.isCompatibleOverride(existing)) {
                this.errorRelated(
                  DiagnosticCode.This_overload_signature_is_not_compatible_with_its_implementation_signature,
                  member.identifierAndSignatureRange, existing.identifierAndSignatureRange
                );
                continue;
              }
            }
            members.set(memberName, member);
            unimplemented.set(memberName, member);
          }
        }
      }
    }

    // Alias base members
    var memoryOffset: u32 = 0;
    var base = instance.base;
    if (base) {
      assert(!pendingClasses.has(base));
      let baseMembers = base.members;
      if (baseMembers) {
        // TODO: for (let [baseMemberName, baseMember] of baseMembers) {
        for (let _keys = Map_keys(baseMembers), i = 0, k = _keys.length; i < k; ++i) {
          let memberName = unchecked(_keys[i]);
          let member = assert(baseMembers.get(memberName));
          if (members.has(memberName)) {
            let existing = assert(members.get(memberName));
            if (!member.isCompatibleOverride(existing)) {
              this.errorRelated(
                DiagnosticCode.This_overload_signature_is_not_compatible_with_its_implementation_signature,
                member.identifierAndSignatureRange, existing.identifierAndSignatureRange
              );
              continue;
            }
          }
          members.set(memberName, member);
          if (member.is(CommonFlags.ABSTRACT)) {
            unimplemented.set(memberName, member);
          } else {
            unimplemented.delete(memberName);
          }
        }
      }
      memoryOffset = base.nextMemoryOffset;
    }

    // Resolve instance members
    var prototype = instance.prototype;
    var instanceMemberPrototypes = prototype.instanceMembers;
    var properties = new Array<Property>();
    if (instanceMemberPrototypes) {
      // TODO: for (let member of instanceMemberPrototypes.values()) {
      for (let _values = Map_values(instanceMemberPrototypes), i = 0, k = _values.length; i < k; ++i) {
        let member = unchecked(_values[i]);
        let memberName = member.name;
        switch (member.kind) {

          case ElementKind.FIELD_PROTOTYPE: {
            let fieldPrototype = <FieldPrototype>member;
            let fieldTypeNode = fieldPrototype.typeNode;
            let fieldType: Type | null = null;
            // TODO: handle duplicate non-private fields specifically?
            if (!fieldTypeNode) {
              if (base) {
                let baseMembers = base.members;
                if (baseMembers !== null && baseMembers.has(fieldPrototype.name)) {
                  let baseField = assert(baseMembers.get(fieldPrototype.name));
                  if (!baseField.is(CommonFlags.PRIVATE)) {
                    assert(baseField.kind == ElementKind.FIELD);
                    fieldType = (<Field>baseField).type;
                  }
                }
              }
              if (!fieldType) {
                if (reportMode == ReportMode.REPORT) {
                  this.error(
                    DiagnosticCode.Type_expected,
                    fieldPrototype.identifierNode.range.atEnd
                  );
                }
              }
            } else {
              fieldType = this.resolveType(
                fieldTypeNode,
                prototype.parent, // relative to class
                instance.contextualTypeArguments,
                reportMode
              );
              if (fieldType == Type.void) {
                if (reportMode == ReportMode.REPORT) {
                  this.error(
                    DiagnosticCode.Type_expected,
                    fieldTypeNode.range
                  );
                }
                break;
              }
            }
            if (!fieldType) break; // did report above
            let fieldInstance = new Field(fieldPrototype, instance, fieldType);
            assert(isPowerOf2(fieldType.byteSize));
            let mask = fieldType.byteSize - 1;
            if (memoryOffset & mask) memoryOffset = (memoryOffset | mask) + 1;
            fieldInstance.memoryOffset = memoryOffset;
            memoryOffset += fieldType.byteSize;
            instance.add(memberName, fieldInstance); // reports
            break;
          }
          case ElementKind.FUNCTION_PROTOTYPE: {
            let boundPrototype = (<FunctionPrototype>member).toBound(instance);
            instance.add(boundPrototype.name, boundPrototype); // reports
            break;
          }
          case ElementKind.PROPERTY_PROTOTYPE: {
            let boundPrototype = (<PropertyPrototype>member).toBound(instance);
            instance.add(boundPrototype.name, boundPrototype); // reports
            break;
          }
          default: assert(false);
        }
        if (!member.is(CommonFlags.ABSTRACT)) {
          unimplemented.delete(memberName);
        }
      }
    }

    // Check that property getters and setters match
    for (let i = 0, k = properties.length; i < k; ++i) {
      let property = properties[i];
      let propertyGetter = property.getterInstance;
      if (!propertyGetter) {
        this.error(
          DiagnosticCode.Property_0_only_has_a_setter_and_is_missing_a_getter,
          property.identifierNode.range, property.name
        );
      } else {
        let propertySetter = property.setterInstance;
        if (propertySetter !== null && !propertyGetter.visibilityEquals(propertySetter)) {
          this.errorRelated(
            DiagnosticCode.Getter_and_setter_accessors_do_not_agree_in_visibility,
            propertyGetter.identifierNode.range, propertySetter.identifierNode.range
          );
        }
      }
    }

    if (instance.kind != ElementKind.INTERFACE) {

      // Check that all required members are implemented
      if (!instance.is(CommonFlags.ABSTRACT) && unimplemented.size > 0) {
        for (let _keys = Map_keys(unimplemented), i = 0, k = _keys.length; i < k; ++i) {
          let memberName = _keys[i];
          let member = assert(unimplemented.get(memberName));
          this.errorRelated(
            DiagnosticCode.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2,
            instance.identifierNode.range, member.identifierNode.range,
            instance.internalName, memberName, member.parent.internalName
          );
        }
      }

      // Finalize memory offset
      instance.nextMemoryOffset = memoryOffset;

      // Link _own_ constructor if present
      {
        let ctorPrototype = instance.lookupInSelf(CommonNames.constructor);
        if (ctorPrototype !== null && ctorPrototype.parent === instance) {
          assert(ctorPrototype.kind == ElementKind.FUNCTION_PROTOTYPE);
          let ctorInstance = this.resolveFunction(
            <FunctionPrototype>ctorPrototype,
            null,
            assert(instance.contextualTypeArguments),
            reportMode
          );
          if (ctorInstance) instance.constructorInstance = <Function>ctorInstance;
        }
      }
    }

    // Fully resolve operator overloads (don't have type parameters on their own)
    var overloadPrototypes = prototype.overloadPrototypes;
    // TODO: for (let [overloadKind, overloadPrototype] of overloadPrototypes) {
    for (let _keys = Map_keys(overloadPrototypes), i = 0, k = _keys.length; i < k; ++i) {
      let overloadKind = unchecked(_keys[i]);
      let overloadPrototype = assert(overloadPrototypes.get(overloadKind));
      assert(overloadKind != OperatorKind.INVALID);
      if (overloadPrototype.is(CommonFlags.GENERIC)) {
        // Already errored during initialization: AS212: Decorator '@operator' is not valid here
        continue;
      }
      let operatorInstance: Function | null;
      if (overloadPrototype.is(CommonFlags.INSTANCE)) {
        let boundPrototype = overloadPrototype.toBound(instance);
        operatorInstance = this.resolveFunction(
          boundPrototype,
          null,
          uniqueMap<string,Type>(),
          reportMode
        );
      } else {
        operatorInstance = this.resolveFunction(
          overloadPrototype,
          null,
          uniqueMap<string,Type>(),
          reportMode
        );
      }
      if (!operatorInstance) continue;
      let overloads = instance.overloads;
      if (!overloads) instance.overloads = overloads = new Map();
      // inc/dec are special in that an instance overload attempts to re-assign
      // the corresponding value, thus requiring a matching return type, while a
      // static overload works like any other overload.
      if (operatorInstance.is(CommonFlags.INSTANCE)) {
        switch (overloadKind) {
          case OperatorKind.PREFIX_INC:
          case OperatorKind.PREFIX_DEC:
          case OperatorKind.POSTFIX_INC:
          case OperatorKind.POSTFIX_DEC: {
            let returnType = operatorInstance.signature.returnType;
            if (!returnType.isAssignableTo(instance.type)) {
              if (reportMode == ReportMode.REPORT) {
                this.error(
                  DiagnosticCode.Type_0_is_not_assignable_to_type_1,
                  overloadPrototype.functionTypeNode.returnType.range, returnType.toString(), instance.type.toString()
                );
              }
            }
          }
        }
      }
      if (!overloads.has(overloadKind)) {
        overloads.set(overloadKind, operatorInstance);
        if (overloadKind == OperatorKind.INDEXED_GET || overloadKind == OperatorKind.INDEXED_SET) {
          let index = instance.indexSignature;
          if (!index) instance.indexSignature = index = new IndexSignature(instance);
          if (overloadKind == OperatorKind.INDEXED_GET) {
            index.setType(operatorInstance.signature.returnType);
          }
        }
      } else {
        if (reportMode == ReportMode.REPORT) {
          this.error(
            DiagnosticCode.Duplicate_decorator,
            operatorInstance.declaration.range
          );
        }
      }
    }

    // Remove this class from pending
    assert(pendingClasses.has(instance)); // must be pending
    pendingClasses.delete(instance);

    // Finish derived classes that we postponed in `resolveClass` due to the
    // base class still being pending, again triggering `finishResolveClass`
    // of any classes derived from those classes, ultimately leading to all
    // pending classes being resolved.
    for (let _values = Set_values(pendingClasses), i = 0, k = _values.length; i < k; ++i) {
      let pending = _values[i];
      let dependsOnInstance = pending.base === instance;
      let interfaces = pending.interfaces;
      if (interfaces) {
        let anyPending = false;
        for (let _values2 = Set_values(interfaces), j = 0, l = _values2.length; j < l; ++j) {
          let iface = _values2[j];
          if (iface === instance) dependsOnInstance = true;
          else if (pendingClasses.has(iface)) anyPending = true;
        }
        if (anyPending) continue;
      }
      if (dependsOnInstance) this.finishResolveClass(pending, reportMode);
    }
  }

  /** Resolves a class prototype by first resolving the specified type arguments. */
  resolveClassInclTypeArguments(
    /** The prototype of the class. */
    prototype: ClassPrototype,
    /** Type arguments provided to be resolved. */
    typeArgumentNodes: TypeNode[] | null,
    /** Contextual element. */
    ctxElement: Element,
    /** Contextual types, i.e. `T`. */
    ctxTypes: Map<string,Type>,
    /** The node to use when reporting intermediate errors. */
    reportNode: Node,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Class | null {
    var resolvedTypeArguments: Type[] | null = null;

    // Resolve type arguments if generic
    if (prototype.is(CommonFlags.GENERIC)) {
      resolvedTypeArguments = this.resolveTypeArguments( // reports
        assert(prototype.typeParameterNodes), // must be present if generic
        typeArgumentNodes,
        ctxElement,
        ctxTypes, // update
        reportNode,
        reportMode
      );
      if (!resolvedTypeArguments) return null;

    // Otherwise make sure that no type arguments have been specified
    } else {
      if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {
        if (reportMode == ReportMode.REPORT) {
          this.error(
            DiagnosticCode.Type_0_is_not_generic,
            reportNode.range, prototype.internalName
          );
        }
        return null;
      }
    }

    // Continue with concrete types
    return this.resolveClass(
      prototype,
      resolvedTypeArguments,
      ctxTypes,
      reportMode
    );
  }

  /** Resolves a property prototype. */
  resolveProperty(
    /** The prototype of the property. */
    prototype: PropertyPrototype,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): Property | null {
    var instance = prototype.instance;
    if (instance) return instance;
    prototype.instance = instance = new Property(prototype, prototype);
    var getterPrototype = prototype.getterPrototype;
    if (getterPrototype) {
      let getterInstance = this.resolveFunction(
        getterPrototype,
        null,
        uniqueMap<string,Type>(),
        reportMode
      );
      if (getterInstance) {
        instance.getterInstance = getterInstance;
        instance.setType(getterInstance.signature.returnType);
      }
    }
    var setterPrototype = prototype.setterPrototype;
    if (setterPrototype) {
      let setterInstance = this.resolveFunction(
        setterPrototype,
        null,
        uniqueMap<string,Type>(),
        reportMode
      );
      if (setterInstance) {
        instance.setterInstance = setterInstance;
        if (!instance.is(CommonFlags.RESOLVED)) {
          assert(setterInstance.signature.parameterTypes.length == 1);
          instance.setType(setterInstance.signature.parameterTypes[0]);
        }
      }
    }
    return instance;
  }

  private ensureOneTypeArgument(
    /** The type to resolve. */
    node: NamedTypeNode,
    /** How to proceed with eventual diagnostics. */
    reportMode: ReportMode = ReportMode.REPORT
  ): TypeNode | null {
    var typeArgumentNodes = node.typeArguments;
    let numTypeArguments = 0;
    if (!typeArgumentNodes || (numTypeArguments = typeArgumentNodes.length) != 1) {
      if (reportMode == ReportMode.REPORT) {
        this.error(
          DiagnosticCode.Expected_0_type_arguments_but_got_1,
          node.range, "1", numTypeArguments.toString()
        );
      }
      return null;
    }
    return typeArgumentNodes[0];
  }
}

'''
'''--- src/tokenizer.ts ---
/**
 * @fileoverview A TypeScript tokenizer modified for AssemblyScript.
 *
 * The `Tokenizer` scans over a source file and returns one syntactic token
 * at a time that the parser will combine to an abstract syntax tree.
 *
 * It skips over trivia like comments and whitespace and provides a general
 * mark/reset mechanism for the parser to utilize on ambiguous tokens, with
 * one token of lookahead otherwise.
 *
 * @license Apache-2.0
 */

import {
  DiagnosticCode,
  DiagnosticMessage,
  DiagnosticEmitter
} from "./diagnostics";

import {
  Source,
  CommentKind
} from "./ast";

import {
  CharCode,
  isLineBreak,
  isWhiteSpace,
  isIdentifierStart,
  isIdentifierPart,
  isDecimalDigit,
  isOctalDigit
} from "./util";

/** Named token types. */
export enum Token {

  // keywords
  // discarded: ANY, BOOLEAN, NEVER, NUMBER, STRING, SYMBOL, UNDEFINED, LESSTHAN_SLASH

  ABSTRACT,
  AS,
  ASYNC,
  AWAIT,        // ES2017
  BREAK,        // ES2017
  CASE,         // ES2017
  CATCH,        // ES2017
  CLASS,        // ES2017
  CONST,        // ES2017
  CONTINUE,     // ES2017
  CONSTRUCTOR,
  DEBUGGER,     // ES2017
  DECLARE,
  DEFAULT,      // ES2017
  DELETE,       // ES2017
  DO,           // ES2017
  ELSE,         // ES2017
  ENUM,         // ES2017 future
  EXPORT,       // ES2017
  EXTENDS,      // ES2017
  FALSE,        // ES
  FINALLY,      // ES2017
  FOR,          // ES2017
  FROM,         // AS possible identifier
  FUNCTION,     // ES2017
  GET,
  IF,           // ES2017
  IMPLEMENTS,   // ES2017 non-lexical
  IMPORT,       // ES2017
  IN,           // ES2017
  INSTANCEOF,   // ES2017
  INTERFACE,    // ES2017 non-lexical
  IS,
  KEYOF,
  LET,          // ES2017 non-lexical
  MODULE,       // AS possible identifier
  NAMESPACE,    // AS possible identifier
  NEW,          // ES2017
  NULL,         // ES
  OF,
  PACKAGE,      // ES2017 non-lexical
  PRIVATE,      // ES2017 non-lexical
  PROTECTED,    // ES2017 non-lexical
  PUBLIC,       // ES2017 non-lexical
  READONLY,
  RETURN,       // ES2017
  SET,
  STATIC,       // ES2017 non-lexical
  SUPER,        // ES2017
  SWITCH,       // ES2017
  THIS,         // ES2017
  THROW,        // ES2017
  TRUE,         // ES
  TRY,          // ES2017
  TYPE,         // AS possible identifier
  TYPEOF,       // ES2017
  VAR,          // ES2017
  VOID,         // ES2017
  WHILE,        // ES2017
  WITH,         // ES2017
  YIELD,        // ES2017

  // punctuation

  OPENBRACE,
  CLOSEBRACE,
  OPENPAREN,
  CLOSEPAREN,
  OPENBRACKET,
  CLOSEBRACKET,
  DOT,
  DOT_DOT_DOT,
  SEMICOLON,
  COMMA,
  LESSTHAN,
  GREATERTHAN,
  LESSTHAN_EQUALS,
  GREATERTHAN_EQUALS,
  EQUALS_EQUALS,
  EXCLAMATION_EQUALS,
  EQUALS_EQUALS_EQUALS,
  EXCLAMATION_EQUALS_EQUALS,
  EQUALS_GREATERTHAN,
  PLUS,
  MINUS,
  ASTERISK_ASTERISK,
  ASTERISK,
  SLASH,
  PERCENT,
  PLUS_PLUS,
  MINUS_MINUS,
  LESSTHAN_LESSTHAN,
  GREATERTHAN_GREATERTHAN,
  GREATERTHAN_GREATERTHAN_GREATERTHAN,
  AMPERSAND,
  BAR,
  CARET,
  EXCLAMATION,
  TILDE,
  AMPERSAND_AMPERSAND,
  BAR_BAR,
  QUESTION,
  COLON,
  EQUALS,
  PLUS_EQUALS,
  MINUS_EQUALS,
  ASTERISK_EQUALS,
  ASTERISK_ASTERISK_EQUALS,
  SLASH_EQUALS,
  PERCENT_EQUALS,
  LESSTHAN_LESSTHAN_EQUALS,
  GREATERTHAN_GREATERTHAN_EQUALS,
  GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS,
  AMPERSAND_EQUALS,
  BAR_EQUALS,
  CARET_EQUALS,
  AT,

  // literals

  IDENTIFIER,
  STRINGLITERAL,
  INTEGERLITERAL,
  FLOATLITERAL,
  TEMPLATELITERAL,

  // meta

  INVALID,
  ENDOFFILE
}

export enum IdentifierHandling {
  DEFAULT,
  PREFER,
  ALWAYS
}

export function tokenFromKeyword(text: string): Token {
  assert(text.length);
  switch (text.charCodeAt(0)) {
    case CharCode.a: {
      if (text == "abstract") return Token.ABSTRACT;
      if (text == "as") return Token.AS;
      if (text == "async") return Token.ASYNC;
      if (text == "await") return Token.AWAIT;
      break;
    }
    case CharCode.b: {
      if (text == "break") return Token.BREAK;
      break;
    }
    case CharCode.c: {
      if (text == "case") return Token.CASE;
      if (text == "catch") return Token.CATCH;
      if (text == "class") return Token.CLASS;
      if (text == "continue") return Token.CONTINUE;
      if (text == "const") return Token.CONST;
      if (text == "constructor") return Token.CONSTRUCTOR;
      break;
    }
    case CharCode.d: {
      if (text == "debugger") return Token.DEBUGGER;
      if (text == "declare") return Token.DECLARE;
      if (text == "default") return Token.DEFAULT;
      if (text == "delete") return Token.DELETE;
      if (text == "do") return Token.DO;
      break;
    }
    case CharCode.e: {
      if (text == "else") return Token.ELSE;
      if (text == "enum") return Token.ENUM;
      if (text == "export") return Token.EXPORT;
      if (text == "extends") return Token.EXTENDS;
      break;
    }
    case CharCode.f: {
      if (text == "false") return Token.FALSE;
      if (text == "finally") return Token.FINALLY;
      if (text == "for") return Token.FOR;
      if (text == "from") return Token.FROM;
      if (text == "function") return Token.FUNCTION;
      break;
    }
    case CharCode.g: {
      if (text == "get") return Token.GET;
      break;
    }
    case CharCode.i: {
      if (text == "if") return Token.IF;
      if (text == "implements") return Token.IMPLEMENTS;
      if (text == "import") return Token.IMPORT;
      if (text == "in") return Token.IN;
      if (text == "instanceof") return Token.INSTANCEOF;
      if (text == "interface") return Token.INTERFACE;
      if (text == "is") return Token.IS;
      break;
    }
    case CharCode.k: {
      if (text == "keyof") return Token.KEYOF;
      break;
    }
    case CharCode.l: {
      if (text == "let") return Token.LET;
      break;
    }
    case CharCode.m: {
      if (text == "module") return Token.MODULE;
      break;
    }
    case CharCode.n: {
      if (text == "namespace") return Token.NAMESPACE;
      if (text == "new") return Token.NEW;
      if (text == "null") return Token.NULL;
      break;
    }
    case CharCode.o: {
      if (text == "of") return Token.OF;
      break;
    }
    case CharCode.p: {
      if (text == "package") return Token.PACKAGE;
      if (text == "private") return Token.PRIVATE;
      if (text == "protected") return Token.PROTECTED;
      if (text == "public") return Token.PUBLIC;
      break;
    }
    case CharCode.r: {
      if (text == "readonly") return Token.READONLY;
      if (text == "return") return Token.RETURN;
      break;
    }
    case CharCode.s: {
      if (text == "set") return Token.SET;
      if (text == "static") return Token.STATIC;
      if (text == "super") return Token.SUPER;
      if (text == "switch") return Token.SWITCH;
      break;
    }
    case CharCode.t: {
      if (text == "this") return Token.THIS;
      if (text == "throw") return Token.THROW;
      if (text == "true") return Token.TRUE;
      if (text == "try") return Token.TRY;
      if (text == "type") return Token.TYPE;
      if (text == "typeof") return Token.TYPEOF;
      break;
    }
    case CharCode.v: {
      if (text == "var") return Token.VAR;
      if (text == "void") return Token.VOID;
      break;
    }
    case CharCode.w: {
      if (text == "while") return Token.WHILE;
      if (text == "with") return Token.WITH;
      break;
    }
    case CharCode.y: {
      if (text == "yield") return Token.YIELD;
      break;
    }
  }
  return Token.INVALID;
}

export function tokenIsAlsoIdentifier(token: Token): bool {
  switch (token) {
    case Token.ABSTRACT:
    case Token.AS:
    case Token.CONSTRUCTOR:
    case Token.DECLARE:
    case Token.DELETE:
    case Token.FROM:
    case Token.FOR:
    case Token.GET:
    case Token.INSTANCEOF:
    case Token.IS:
    case Token.KEYOF:
    case Token.MODULE:
    case Token.NAMESPACE:
    case Token.NULL:
    case Token.READONLY:
    case Token.SET:
    case Token.TYPE:
    case Token.VOID: return true;
    default: return false;
  }
}

export function isIllegalVariableIdentifier(name: string): bool {
  assert(name.length);
  switch (name.charCodeAt(0)) {
    case CharCode.d: return name == "delete";
    case CharCode.f: return name == "for";
    case CharCode.i: return name == "instanceof";
    case CharCode.n: return name == "null";
    case CharCode.v: return name == "void";
  }
  return false;
}

export function operatorTokenToString(token: Token): string {
  switch (token) {
    case Token.DELETE: return "delete";
    case Token.IN: return "in";
    case Token.INSTANCEOF: return "instanceof";
    case Token.NEW: return "new";
    case Token.TYPEOF: return "typeof";
    case Token.VOID: return "void";
    case Token.YIELD: return "yield";
    case Token.DOT_DOT_DOT: return "...";
    case Token.COMMA: return ",";
    case Token.LESSTHAN: return "<";
    case Token.GREATERTHAN: return ">";
    case Token.LESSTHAN_EQUALS: return "<=";
    case Token.GREATERTHAN_EQUALS: return ">=";
    case Token.EQUALS_EQUALS: return "==";
    case Token.EXCLAMATION_EQUALS: return "!=";
    case Token.EQUALS_EQUALS_EQUALS: return "===";
    case Token.EXCLAMATION_EQUALS_EQUALS: return "!==";
    case Token.PLUS: return "+";
    case Token.MINUS: return "-";
    case Token.ASTERISK_ASTERISK: return "**";
    case Token.ASTERISK: return "*";
    case Token.SLASH: return "/";
    case Token.PERCENT: return "%";
    case Token.PLUS_PLUS: return "++";
    case Token.MINUS_MINUS: return "--";
    case Token.LESSTHAN_LESSTHAN: return "<<";
    case Token.GREATERTHAN_GREATERTHAN: return ">>";
    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: return ">>>";
    case Token.AMPERSAND: return "&";
    case Token.BAR: return "|";
    case Token.CARET: return "^";
    case Token.EXCLAMATION: return "!";
    case Token.TILDE: return "~";
    case Token.AMPERSAND_AMPERSAND: return "&&";
    case Token.BAR_BAR: return "||";
    case Token.EQUALS: return "=";
    case Token.PLUS_EQUALS: return "+=";
    case Token.MINUS_EQUALS: return "-=";
    case Token.ASTERISK_EQUALS: return "*=";
    case Token.ASTERISK_ASTERISK_EQUALS: return "**=";
    case Token.SLASH_EQUALS: return "/=";
    case Token.PERCENT_EQUALS: return "%=";
    case Token.LESSTHAN_LESSTHAN_EQUALS: return "<<=";
    case Token.GREATERTHAN_GREATERTHAN_EQUALS: return ">>=";
    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS: return ">>>=";
    case Token.AMPERSAND_EQUALS: return "&=";
    case Token.BAR_EQUALS: return "|=";
    case Token.CARET_EQUALS: return "^=";
    default: {
      assert(false);
      return "";
    }
  }
}

export class Range {

  start: i32;
  end: i32;
  source!: Source;
  debugInfoRef: usize = 0;

  constructor(start: i32, end: i32) {
    this.start = start;
    this.end = end;
  }

  static join(a: Range, b: Range): Range {
    if (a.source != b.source) throw new Error("source mismatch");
    let range = new Range(
      a.start < b.start ? a.start : b.start,
      a.end > b.end ? a.end : b.end
    );
    range.source = a.source;
    return range;
  }

  equals(other: Range): bool {
    return this.source == other.source && this.start == other.start && this.end == other.end;
  }

  get atStart(): Range {
    let range = new Range(this.start, this.start);
    range.source = this.source;
    return range;
  }

  get atEnd(): Range {
    let range = new Range(this.end, this.end);
    range.source = this.source;
    return range;
  }

  toString(): string {
    return this.source.text.substring(this.start, this.end);
  }
}

/** Handler for intercepting comments while tokenizing. */
export type CommentHandler = (kind: CommentKind, text: string, range: Range) => void;

/** Tokenizes a source to individual {@link Token}s. */
export class Tokenizer extends DiagnosticEmitter {

  source: Source;
  end: i32 = 0;

  pos: i32 = 0;
  token: Token = -1;
  tokenPos: i32 = 0;

  nextToken: Token = -1;
  nextTokenPos: i32 = 0;
  nextTokenOnNewLine: bool = false;

  onComment: CommentHandler | null = null;

  /** Constructs a new tokenizer. */
  constructor(source: Source, diagnostics: DiagnosticMessage[] | null = null) {
    super(diagnostics);

    if (!diagnostics) diagnostics = [];
    this.diagnostics = diagnostics;
    this.source = source;

    var text = source.text;
    var end = text.length;
    var pos = 0;
    // skip bom
    if (
      pos < end &&
      text.charCodeAt(pos) == CharCode.BYTEORDERMARK
    ) {
      ++pos;
    }

    // skip shebang
    if (
      pos + 1 < end &&
      text.charCodeAt(pos) == CharCode.HASH &&
      text.charCodeAt(pos + 1) == CharCode.EXCLAMATION
    ) {
      pos += 2;
      while (
        pos < end &&
        text.charCodeAt(pos) != CharCode.LINEFEED
      ) {
        ++pos;
      }
      // 'next' now starts at lf or eof
    }
    this.pos = pos;
    this.end = end;
  }

  next(identifierHandling: IdentifierHandling = IdentifierHandling.DEFAULT): Token {
    this.nextToken = -1;
    var token: Token;
    do token = this.unsafeNext(identifierHandling);
    while (token == Token.INVALID);
    this.token = token;
    return token;
  }

  private unsafeNext(
    identifierHandling: IdentifierHandling = IdentifierHandling.DEFAULT,
    maxTokenLength: i32 = i32.MAX_VALUE
  ): Token {
    var text = this.source.text;
    var end = this.end;
    var pos = this.pos;
    while (pos < end) {
      this.tokenPos = pos;
      let c = text.charCodeAt(pos);
      switch (c) {
        case CharCode.CARRIAGERETURN: {
          if (!(
            ++pos < end &&
            text.charCodeAt(pos) == CharCode.LINEFEED
          )) break;
          // otherwise fall-through
        }
        case CharCode.LINEFEED:
        case CharCode.TAB:
        case CharCode.VERTICALTAB:
        case CharCode.FORMFEED:
        case CharCode.SPACE: {
          ++pos;
          break;
        }
        case CharCode.EXCLAMATION: {
          ++pos;
          if (
            maxTokenLength > 1 && pos < end &&
            text.charCodeAt(pos) == CharCode.EQUALS
          ) {
            ++pos;
            if (
              maxTokenLength > 2 && pos < end &&
              text.charCodeAt(pos) == CharCode.EQUALS
            ) {
              this.pos = pos + 1;
              return Token.EXCLAMATION_EQUALS_EQUALS;
            }
            this.pos = pos;
            return Token.EXCLAMATION_EQUALS;
          }
          this.pos = pos;
          return Token.EXCLAMATION;
        }
        case CharCode.DOUBLEQUOTE:
        case CharCode.SINGLEQUOTE: {
          this.pos = pos;
          return Token.STRINGLITERAL;
        }
        case CharCode.BACKTICK: {
          this.pos = pos;
          return Token.TEMPLATELITERAL;
        }
        case CharCode.PERCENT: {
          ++pos;
          if (
            maxTokenLength > 1 && pos < end &&
            text.charCodeAt(pos) == CharCode.EQUALS
          ) {
            this.pos = pos + 1;
            return Token.PERCENT_EQUALS;
          }
          this.pos = pos;
          return Token.PERCENT;
        }
        case CharCode.AMPERSAND: {
          ++pos;
          if (maxTokenLength > 1 && pos < end) {
            let chr = text.charCodeAt(pos);
            if (chr == CharCode.AMPERSAND) {
              this.pos = pos + 1;
              return Token.AMPERSAND_AMPERSAND;
            }
            if (chr == CharCode.EQUALS) {
              this.pos = pos + 1;
              return Token.AMPERSAND_EQUALS;
            }
          }
          this.pos = pos;
          return Token.AMPERSAND;
        }
        case CharCode.OPENPAREN: {
          this.pos = pos + 1;
          return Token.OPENPAREN;
        }
        case CharCode.CLOSEPAREN: {
          this.pos = pos + 1;
          return Token.CLOSEPAREN;
        }
        case CharCode.ASTERISK: {
          ++pos;
          if (maxTokenLength > 1 && pos < end) {
            let chr = text.charCodeAt(pos);
            if (chr == CharCode.EQUALS) {
              this.pos = pos + 1;
              return Token.ASTERISK_EQUALS;
            }
            if (chr == CharCode.ASTERISK) {
              ++pos;
              if (
                maxTokenLength > 2 && pos < end &&
                text.charCodeAt(pos) == CharCode.EQUALS
              ) {
                this.pos = pos + 1;
                return Token.ASTERISK_ASTERISK_EQUALS;
              }
              this.pos = pos;
              return Token.ASTERISK_ASTERISK;
            }
          }
          this.pos = pos;
          return Token.ASTERISK;
        }
        case CharCode.PLUS: {
          ++pos;
          if (maxTokenLength > 1 && pos < end) {
            let chr = text.charCodeAt(pos);
            if (chr == CharCode.PLUS) {
              this.pos = pos + 1;
              return Token.PLUS_PLUS;
            }
            if (chr == CharCode.EQUALS) {
              this.pos = pos + 1;
              return Token.PLUS_EQUALS;
            }
          }
          this.pos = pos;
          return Token.PLUS;
        }
        case CharCode.COMMA: {
          this.pos = pos + 1;
          return Token.COMMA;
        }
        case CharCode.MINUS: {
          ++pos;
          if (maxTokenLength > 1 && pos < end) {
            let chr = text.charCodeAt(pos);
            if (chr == CharCode.MINUS) {
              this.pos = pos + 1;
              return Token.MINUS_MINUS;
            }
            if (chr == CharCode.EQUALS) {
              this.pos = pos + 1;
              return Token.MINUS_EQUALS;
            }
          }
          this.pos = pos;
          return Token.MINUS;
        }
        case CharCode.DOT: {
          ++pos;
          if (maxTokenLength > 1 && pos < end) {
            let chr = text.charCodeAt(pos);
            if (isDecimalDigit(chr)) {
              this.pos = pos - 1;
              return Token.FLOATLITERAL; // expects a call to readFloat
            }
            if (
              maxTokenLength > 2 && pos + 1 < end &&
              chr == CharCode.DOT &&
              text.charCodeAt(pos + 1) == CharCode.DOT
            ) {
              this.pos = pos + 2;
              return Token.DOT_DOT_DOT;
            }
          }
          this.pos = pos;
          return Token.DOT;
        }
        case CharCode.SLASH: {
          let commentStartPos = pos;
          ++pos;
          if (maxTokenLength > 1 && pos < end) {
            let chr = text.charCodeAt(pos);
            if (chr == CharCode.SLASH) { // single-line
              let commentKind = CommentKind.LINE;
              if (
                pos + 1 < end &&
                text.charCodeAt(pos + 1) == CharCode.SLASH
              ) {
                ++pos;
                commentKind = CommentKind.TRIPLE;
              }
              while (++pos < end) {
                if (text.charCodeAt(pos) == CharCode.LINEFEED) {
                  ++pos;
                  break;
                }
              }
              if (this.onComment) {
                this.onComment(
                  commentKind,
                  text.substring(commentStartPos, pos),
                  this.range(commentStartPos, pos)
                );
              }
              break;
            }
            if (chr == CharCode.ASTERISK) { // multi-line
              let closed = false;
              while (++pos < end) {
                c = text.charCodeAt(pos);
                if (
                  c == CharCode.ASTERISK &&
                  pos + 1 < end &&
                  text.charCodeAt(pos + 1) == CharCode.SLASH
                ) {
                  pos += 2;
                  closed = true;
                  break;
                }
              }
              if (!closed) {
                this.error(
                  DiagnosticCode._0_expected,
                  this.range(pos), "*/"
                );
              } else if (this.onComment) {
                this.onComment(
                  CommentKind.BLOCK,
                  text.substring(commentStartPos, pos),
                  this.range(commentStartPos, pos)
                );
              }
              break;
            }
            if (chr == CharCode.EQUALS) {
              this.pos = pos + 1;
              return Token.SLASH_EQUALS;
            }
          }
          this.pos = pos;
          return Token.SLASH;
        }
        case CharCode._0:
        case CharCode._1:
        case CharCode._2:
        case CharCode._3:
        case CharCode._4:
        case CharCode._5:
        case CharCode._6:
        case CharCode._7:
        case CharCode._8:
        case CharCode._9: {
          this.pos = pos;
          return this.testInteger()
            ? Token.INTEGERLITERAL // expects a call to readInteger
            : Token.FLOATLITERAL;  // expects a call to readFloat
        }
        case CharCode.COLON: {
          this.pos = pos + 1;
          return Token.COLON;
        }
        case CharCode.SEMICOLON: {
          this.pos = pos + 1;
          return Token.SEMICOLON;
        }
        case CharCode.LESSTHAN: {
          ++pos;
          if (maxTokenLength > 1 && pos < end) {
            let chr = text.charCodeAt(pos);
            if (chr == CharCode.LESSTHAN) {
              ++pos;
              if (
                maxTokenLength > 2 &&
                pos < end &&
                text.charCodeAt(pos) == CharCode.EQUALS
              ) {
                this.pos = pos + 1;
                return Token.LESSTHAN_LESSTHAN_EQUALS;
              }
              this.pos = pos;
              return Token.LESSTHAN_LESSTHAN;
            }
            if (chr == CharCode.EQUALS) {
              this.pos = pos + 1;
              return Token.LESSTHAN_EQUALS;
            }
          }
          this.pos = pos;
          return Token.LESSTHAN;
        }
        case CharCode.EQUALS: {
          ++pos;
          if (maxTokenLength > 1 && pos < end) {
            let chr = text.charCodeAt(pos);
            if (chr == CharCode.EQUALS) {
              ++pos;
              if (
                maxTokenLength > 2 &&
                pos < end &&
                text.charCodeAt(pos) == CharCode.EQUALS
              ) {
                this.pos = pos + 1;
                return Token.EQUALS_EQUALS_EQUALS;
              }
              this.pos = pos;
              return Token.EQUALS_EQUALS;
            }
            if (chr == CharCode.GREATERTHAN) {
              this.pos = pos + 1;
              return Token.EQUALS_GREATERTHAN;
            }
          }
          this.pos = pos;
          return Token.EQUALS;
        }
        case CharCode.GREATERTHAN: {
          ++pos;
          if (maxTokenLength > 1 && pos < end) {
            let chr = text.charCodeAt(pos);
            if (chr == CharCode.GREATERTHAN) {
              ++pos;
              if (maxTokenLength > 2 && pos < end) {
                chr = text.charCodeAt(pos);
                if (chr == CharCode.GREATERTHAN) {
                  ++pos;
                  if (
                    maxTokenLength > 3 && pos < end &&
                    text.charCodeAt(pos) == CharCode.EQUALS
                  ) {
                    this.pos = pos + 1;
                    return Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS;
                  }
                  this.pos = pos;
                  return Token.GREATERTHAN_GREATERTHAN_GREATERTHAN;
                }
                if (chr == CharCode.EQUALS) {
                  this.pos = pos + 1;
                  return Token.GREATERTHAN_GREATERTHAN_EQUALS;
                }
              }
              this.pos = pos;
              return Token.GREATERTHAN_GREATERTHAN;
            }
            if (chr == CharCode.EQUALS) {
              this.pos = pos + 1;
              return Token.GREATERTHAN_EQUALS;
            }
          }
          this.pos = pos;
          return Token.GREATERTHAN;
        }
        case CharCode.QUESTION: {
          this.pos = pos + 1;
          return Token.QUESTION;
        }
        case CharCode.OPENBRACKET: {
          this.pos = pos + 1;
          return Token.OPENBRACKET;
        }
        case CharCode.CLOSEBRACKET: {
          this.pos = pos + 1;
          return Token.CLOSEBRACKET;
        }
        case CharCode.CARET: {
          ++pos;
          if (
            maxTokenLength > 1 && pos < end &&
            text.charCodeAt(pos) == CharCode.EQUALS
          ) {
            this.pos = pos + 1;
            return Token.CARET_EQUALS;
          }
          this.pos = pos;
          return Token.CARET;
        }
        case CharCode.OPENBRACE: {
          this.pos = pos + 1;
          return Token.OPENBRACE;
        }
        case CharCode.BAR: {
          ++pos;
          if (maxTokenLength > 1 && pos < end) {
            let chr = text.charCodeAt(pos);
            if (chr == CharCode.BAR) {
              this.pos = pos + 1;
              return Token.BAR_BAR;
            }
            if (chr == CharCode.EQUALS) {
              this.pos = pos + 1;
              return Token.BAR_EQUALS;
            }
          }
          this.pos = pos;
          return Token.BAR;
        }
        case CharCode.CLOSEBRACE: {
          this.pos = pos + 1;
          return Token.CLOSEBRACE;
        }
        case CharCode.TILDE: {
          this.pos = pos + 1;
          return Token.TILDE;
        }
        case CharCode.AT: {
          this.pos = pos + 1;
          return Token.AT;
        }
        default: {
          if (isIdentifierStart(c)) {
            let posBefore = pos;
            while (
              ++pos < end &&
              isIdentifierPart(c = text.charCodeAt(pos))
            ) { /* nop */ }
            if (identifierHandling != IdentifierHandling.ALWAYS) {
              let maybeKeywordToken = tokenFromKeyword(text.substring(posBefore, pos));
              if (
                maybeKeywordToken !== Token.INVALID &&
                !(
                  identifierHandling === IdentifierHandling.PREFER &&
                  tokenIsAlsoIdentifier(maybeKeywordToken)
                )
              ) {
                this.pos = pos;
                return maybeKeywordToken;
              }
            }
            this.pos = posBefore;
            return Token.IDENTIFIER;
          } else if (isWhiteSpace(c)) {
            ++pos;
            break;
          }
          let start = pos++;
          if ( // surrogate pair?
            (c & 0xFC00) == 0xD800 && pos < end &&
            ((text.charCodeAt(pos)) & 0xFC00) == 0xDC00
          ) ++pos;
          this.error(
            DiagnosticCode.Invalid_character,
            this.range(start, pos)
          );
          this.pos = pos;
          return Token.INVALID;
        }
      }
    }
    this.pos = pos;
    return Token.ENDOFFILE;
  }

  peek(
    checkOnNewLine: bool = false,
    identifierHandling: IdentifierHandling = IdentifierHandling.DEFAULT,
    maxCompoundLength: i32 = i32.MAX_VALUE
  ): Token {
    var text = this.source.text;
    if (this.nextToken < 0) {
      let posBefore = this.pos;
      let tokenBefore = this.token;
      let tokenPosBefore = this.tokenPos;
      let nextToken: Token;
      do nextToken = this.unsafeNext(identifierHandling, maxCompoundLength);
      while (nextToken == Token.INVALID);
      this.nextToken = nextToken;
      this.nextTokenPos = this.tokenPos;
      if (checkOnNewLine) {
        this.nextTokenOnNewLine = false;
        for (let pos = posBefore, end = this.nextTokenPos; pos < end; ++pos) {
          if (isLineBreak(text.charCodeAt(pos))) {
            this.nextTokenOnNewLine = true;
            break;
          }
        }
      }
      this.pos = posBefore;
      this.token = tokenBefore;
      this.tokenPos = tokenPosBefore;
    }
    return this.nextToken;
  }

  skipIdentifier(identifierHandling: IdentifierHandling = IdentifierHandling.PREFER): bool {
    return this.skip(Token.IDENTIFIER, identifierHandling);
  }

  skip(token: Token, identifierHandling: IdentifierHandling = IdentifierHandling.DEFAULT): bool {
    var posBefore = this.pos;
    var tokenBefore = this.token;
    var tokenPosBefore = this.tokenPos;
    var maxCompoundLength = i32.MAX_VALUE;
    if (token == Token.GREATERTHAN) {  // where parsing type arguments
      maxCompoundLength = 1;
    }
    var nextToken: Token;
    do nextToken = this.unsafeNext(identifierHandling, maxCompoundLength);
    while (nextToken == Token.INVALID);
    if (nextToken == token) {
      this.token = token;
      this.nextToken = -1;
      return true;
    } else {
      this.pos = posBefore;
      this.token = tokenBefore;
      this.tokenPos = tokenPosBefore;
      return false;
    }
  }

  mark(): State {
    var state = reusableState;
    if (state) {
      reusableState = null;
      state.pos = this.pos;
      state.token = this.token;
      state.tokenPos = this.tokenPos;
    } else {
      state = new State(this.pos, this.token, this.tokenPos);
    }
    return state;
  }

  discard(state: State): void {
    reusableState = state;
  }

  reset(state: State): void {
    this.pos = state.pos;
    this.token = state.token;
    this.tokenPos = state.tokenPos;
    this.nextToken = -1;
  }

  range(start: i32 = -1, end: i32 = -1): Range {
    if (start < 0) {
      start = this.tokenPos;
      end = this.pos;
    } else if (end < 0) {
      end = start;
    }
    let range = new Range(start, end);
    range.source = this.source;
    return range;
  }

  readIdentifier(): string {
    var text = this.source.text;
    var end = this.end;
    var pos = this.pos;
    var start = pos;
    while (
      ++pos < end &&
      isIdentifierPart(text.charCodeAt(pos))
    );
    this.pos = pos;
    return text.substring(start, pos);
  }

  readingTemplateString: bool = false;
  readStringStart: i32 = 0;
  readStringEnd: i32 = 0;

  readString(quote: i32 = 0, isTaggedTemplate: bool = false): string {
    var text = this.source.text;
    var end = this.end;
    var pos = this.pos;
    if (!quote) quote = text.charCodeAt(pos++);
    var start = pos;
    this.readStringStart = start;
    var result = "";

    while (true) {
      if (pos >= end) {
        result += text.substring(start, pos);
        this.error(
          DiagnosticCode.Unterminated_string_literal,
          this.range(start - 1, end)
        );
        this.readStringEnd = end;
        break;
      }
      let c = text.charCodeAt(pos);
      if (c == quote) {
        this.readStringEnd = pos;
        result += text.substring(start, pos++);
        break;
      }
      if (c == CharCode.BACKSLASH) {
        result += text.substring(start, pos);
        this.pos = pos; // save
        result += this.readEscapeSequence(isTaggedTemplate);
        pos = this.pos; // restore
        start = pos;
        continue;
      }
      if (quote == CharCode.BACKTICK) {
        if (c == CharCode.DOLLAR && pos + 1 < end && text.charCodeAt(pos + 1) == CharCode.OPENBRACE) {
          result += text.substring(start, pos);
          this.readStringEnd = pos;
          this.pos = pos + 2;
          this.readingTemplateString = true;
          return result;
        }
      } else if (isLineBreak(c)) {
        result += text.substring(start, pos);
        this.error(
          DiagnosticCode.Unterminated_string_literal,
          this.range(start - 1, pos)
        );
        this.readStringEnd = pos;
        break;
      }
      ++pos;
    }
    this.pos = pos;
    this.readingTemplateString = false;
    return result;
  }

  readEscapeSequence(isTaggedTemplate: bool = false): string {
    // for context on isTaggedTemplate, see: https://tc39.es/proposal-template-literal-revision/
    var start = this.pos;
    var end = this.end;
    if (++this.pos >= end) {
      this.error(
        DiagnosticCode.Unexpected_end_of_text,
        this.range(end)
      );
      return "";
    }

    var text = this.source.text;
    var c = text.charCodeAt(this.pos++);
    switch (c) {
      case CharCode._0: {
        if (isTaggedTemplate && this.pos < end && isDecimalDigit(text.charCodeAt(this.pos))) {
          ++this.pos;
          return text.substring(start, this.pos);
        }
        return "\0";
      }
      case CharCode.b: return "\b";
      case CharCode.t: return "\t";
      case CharCode.n: return "\n";
      case CharCode.v: return "\v";
      case CharCode.f: return "\f";
      case CharCode.r: return "\r";
      case CharCode.SINGLEQUOTE: return "'";
      case CharCode.DOUBLEQUOTE: return "\"";
      case CharCode.u: {
        if (
          this.pos < end &&
          text.charCodeAt(this.pos) == CharCode.OPENBRACE
        ) {
          ++this.pos;
          return this.readExtendedUnicodeEscape(isTaggedTemplate ? start : -1); // \u{DDDDDDDD}
        }
        return this.readUnicodeEscape(isTaggedTemplate ? start : -1); // \uDDDD
      }
      case CharCode.x: {
        return this.readHexadecimalEscape(2, isTaggedTemplate ? start : - 1); // \xDD
      }
      case CharCode.CARRIAGERETURN: {
        if (
          this.pos < end &&
          text.charCodeAt(this.pos) == CharCode.LINEFEED
        ) {
          ++this.pos;
        }
        // fall through
      }
      case CharCode.LINEFEED:
      case CharCode.LINESEPARATOR:
      case CharCode.PARAGRAPHSEPARATOR: return "";
      default: return String.fromCharCode(c);
    }
  }

  readRegexpPattern(): string {
    var text = this.source.text;
    var start = this.pos;
    var end = this.end;
    var escaped = false;
    while (true) {
      if (this.pos >= end) {
        this.error(
          DiagnosticCode.Unterminated_regular_expression_literal,
          this.range(start, end)
        );
        break;
      }
      if (text.charCodeAt(this.pos) == CharCode.BACKSLASH) {
        ++this.pos;
        escaped = true;
        continue;
      }
      let c = text.charCodeAt(this.pos);
      if (!escaped && c == CharCode.SLASH) break;
      if (isLineBreak(c)) {
        this.error(
          DiagnosticCode.Unterminated_regular_expression_literal,
          this.range(start, this.pos)
        );
        break;
      }
      ++this.pos;
      escaped = false;
    }
    return text.substring(start, this.pos);
  }

  readRegexpFlags(): string {
    var text = this.source.text;
    var start = this.pos;
    var end = this.end;
    var flags = 0;
    while (this.pos < end) {
      let c: i32 = text.charCodeAt(this.pos);
      if (!isIdentifierPart(c)) break;
      ++this.pos;

      // make sure each supported flag is unique
      switch (c) {
        case CharCode.g: {
          flags |= flags & 1 ? -1 : 1;
          break;
        }
        case CharCode.i: {
          flags |= flags & 2 ? -1 : 2;
          break;
        }
        case CharCode.m: {
          flags |= flags & 4 ? -1 : 4;
          break;
        }
        default: {
          flags = -1;
          break;
        }
      }
    }
    if (flags == -1) {
      this.error(
        DiagnosticCode.Invalid_regular_expression_flags,
        this.range(start, this.pos)
      );
    }
    return text.substring(start, this.pos);
  }

  testInteger(): bool {
    var text = this.source.text;
    var pos = this.pos;
    var end = this.end;
    if (pos + 1 < end && text.charCodeAt(pos) == CharCode._0) {
      switch (text.charCodeAt(pos + 2) | 32) {
        case CharCode.x:
        case CharCode.b:
        case CharCode.o: return true;
      }
    }
    while (pos < end) {
      let c = text.charCodeAt(pos);
      if (c == CharCode.DOT || (c | 32) == CharCode.e) return false;
      if (c != CharCode._ && (c < CharCode._0 || c > CharCode._9)) break;
      // does not validate separator placement (this is done in readXYInteger)
      pos++;
    }
    return true;
  }

  readInteger(): i64 {
    var text = this.source.text;
    var pos = this.pos;
    if (pos + 2 < this.end && text.charCodeAt(pos) == CharCode._0) {
      switch (text.charCodeAt(pos + 1) | 32) {
        case CharCode.x: {
          this.pos = pos + 2;
          return this.readHexInteger();
        }
        case CharCode.b: {
          this.pos = pos + 2;
          return this.readBinaryInteger();
        }
        case CharCode.o: {
          this.pos = pos + 2;
          return this.readOctalInteger();
        }
      }
      if (isOctalDigit(text.charCodeAt(pos + 1))) {
        let start = pos;
        this.pos = pos + 1;
        let value = this.readOctalInteger();
        this.error(
          DiagnosticCode.Octal_literals_are_not_allowed_in_strict_mode,
          this.range(start, this.pos)
        );
        return value;
      }
    }
    return this.readDecimalInteger();
  }

  readHexInteger(): i64 {
    var text = this.source.text;
    let pos = this.pos;
    var end = this.end;
    var start = pos;
    var sepEnd = start;
    var value = i64_new(0);
    var i64_4 = i64_new(4);
    while (pos < end) {
      let c = text.charCodeAt(pos);
      if (c >= CharCode._0 && c <= CharCode._9) {
        // value = (value << 4) + c - CharCode._0;
        value = i64_add(
          i64_shl(value, i64_4),
          i64_new(c - CharCode._0)
        );
      } else if (c >= CharCode.A && c <= CharCode.F) {
        // value = (value << 4) + 10 + c - CharCode.A;
        value = i64_add(
          i64_shl(value, i64_4),
          i64_new(10 + c - CharCode.A)
        );
      } else if (c >= CharCode.a && c <= CharCode.f) {
        // value = (value << 4) + 10 + c - CharCode.a;
        value = i64_add(
          i64_shl(value, i64_4),
          i64_new(10 + c - CharCode.a)
        );
      } else if (c == CharCode._) {
        if (sepEnd == pos) {
          this.error(
            sepEnd == start
              ? DiagnosticCode.Numeric_separators_are_not_allowed_here
              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,
            this.range(pos)
          );
        }
        sepEnd = pos + 1;
      } else {
        break;
      }
      ++pos;
    }
    if (pos == start) {
      this.error(
        DiagnosticCode.Hexadecimal_digit_expected,
        this.range(start)
      );
    } else if (sepEnd == pos) {
      this.error(
        DiagnosticCode.Numeric_separators_are_not_allowed_here,
        this.range(sepEnd - 1)
      );
    }
    this.pos = pos;
    return value;
  }

  readDecimalInteger(): i64 {
    var text = this.source.text;
    var pos = this.pos;
    var end = this.end;
    var start = pos;
    var sepEnd = start;
    var value = i64_new(0);
    var i64_10 = i64_new(10);
    while (pos < end) {
      let c = text.charCodeAt(pos);
      if (c >= CharCode._0 && c <= CharCode._9) {
        // value = value * 10 + c - CharCode._0;
        value = i64_add(
          i64_mul(value, i64_10),
          i64_new(c - CharCode._0)
        );
      } else if (c == CharCode._) {
        if (sepEnd == pos) {
          this.error(
            sepEnd == start
              ? DiagnosticCode.Numeric_separators_are_not_allowed_here
              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,
            this.range(pos)
          );
        } else if (pos - 1 == start && text.charCodeAt(pos - 1) == CharCode._0) {
          this.error(
            DiagnosticCode.Numeric_separators_are_not_allowed_here,
            this.range(pos)
          );
        }
        sepEnd = pos + 1;
      } else {
        break;
      }
      ++pos;
    }
    if (pos == start) {
      this.error(
        DiagnosticCode.Digit_expected,
        this.range(start)
      );
    } else if (sepEnd == pos) {
      this.error(
        DiagnosticCode.Numeric_separators_are_not_allowed_here,
        this.range(sepEnd - 1)
      );
    }
    this.pos = pos;
    return value;
  }

  readOctalInteger(): i64 {
    var text = this.source.text;
    var pos = this.pos;
    var end = this.end;
    var start = pos;
    var sepEnd = start;
    var value = i64_new(0);
    var i64_3 = i64_new(3);
    while (pos < end) {
      let c = text.charCodeAt(pos);
      if (c >= CharCode._0 && c <= CharCode._7) {
        // value = (value << 3) + c - CharCode._0;
        value = i64_add(
          i64_shl(value, i64_3),
          i64_new(c - CharCode._0)
        );
      } else if (c == CharCode._) {
        if (sepEnd == pos) {
          this.error(
            sepEnd == start
              ? DiagnosticCode.Numeric_separators_are_not_allowed_here
              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,
            this.range(pos)
          );
        }
        sepEnd = pos + 1;
      } else {
        break;
      }
      ++pos;
    }
    if (pos == start) {
      this.error(
        DiagnosticCode.Octal_digit_expected,
        this.range(start)
      );
    } else if (sepEnd == pos) {
      this.error(
        DiagnosticCode.Numeric_separators_are_not_allowed_here,
        this.range(sepEnd - 1)
      );
    }
    this.pos = pos;
    return value;
  }

  readBinaryInteger(): i64 {
    var text = this.source.text;
    var pos = this.pos;
    var end = this.end;
    var start = pos;
    var sepEnd = start;
    var value = i64_new(0);
    var i64_1 = i64_new(1);
    while (pos < end) {
      let c = text.charCodeAt(pos);
      if (c == CharCode._0) {
        // value = (value << 1);
        value = i64_shl(value, i64_1);
      } else if (c == CharCode._1) {
        // value = (value << 1) + 1;
        value = i64_add(
          i64_shl(value, i64_1),
          i64_1
        );
      } else if (c == CharCode._) {
        if (sepEnd == pos) {
          this.error(
            sepEnd == start
              ? DiagnosticCode.Numeric_separators_are_not_allowed_here
              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,
            this.range(pos)
          );
        }
        sepEnd = pos + 1;
      } else {
        break;
      }
      ++pos;
    }
    if (pos == start) {
      this.error(
        DiagnosticCode.Binary_digit_expected,
        this.range(start)
      );
    } else if (sepEnd == pos) {
      this.error(
        DiagnosticCode.Numeric_separators_are_not_allowed_here,
        this.range(sepEnd - 1)
      );
    }
    this.pos = pos;
    return value;
  }

  readFloat(): f64 {
    // var text = this.source.text;
    // if (text.charCodeAt(this.pos) == CharCode._0 && this.pos + 2 < this.end) {
    //   switch (text.charCodeAt(this.pos + 1)) {
    //     case CharCode.X:
    //     case CharCode.x: {
    //       this.pos += 2;
    //       return this.readHexFloat();
    //     }
    //   }
    // }
    return this.readDecimalFloat();
  }

  readDecimalFloat(): f64 {
    var text = this.source.text;
    var end = this.end;
    var start = this.pos;
    var sepCount = this.readDecimalFloatPartial(false);
    if (this.pos < end && text.charCodeAt(this.pos) == CharCode.DOT) {
      ++this.pos;
      sepCount += this.readDecimalFloatPartial();
    }
    if (this.pos < end) {
      let c = text.charCodeAt(this.pos);
      if ((c | 32) == CharCode.e) {
        if (
          ++this.pos < end &&
          (c = text.charCodeAt(this.pos)) == CharCode.MINUS || c == CharCode.PLUS &&
          isDecimalDigit(text.charCodeAt(this.pos + 1))
        ) {
          ++this.pos;
        }
        sepCount += this.readDecimalFloatPartial();
      }
    }
    let result = text.substring(start, this.pos);
    if (sepCount) result = result.replaceAll("_", "");
    return parseFloat(result);
  }

  /** Reads past one section of a decimal float literal. Returns the number of separators encountered. */
  private readDecimalFloatPartial(allowLeadingZeroSep: bool = true): u32 {
    var text = this.source.text;
    var pos = this.pos;
    var start = pos;
    var end = this.end;
    var sepEnd = start;
    var sepCount = 0;

    while (pos < end) {
      let c = text.charCodeAt(pos);

      if (c == CharCode._) {
        if (sepEnd == pos) {
          this.error(
            sepEnd == start
              ? DiagnosticCode.Numeric_separators_are_not_allowed_here
              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,
            this.range(pos)
          );
        } else if (!allowLeadingZeroSep && pos - 1 == start && text.charCodeAt(pos - 1) == CharCode._0) {
          this.error(
            DiagnosticCode.Numeric_separators_are_not_allowed_here,
            this.range(pos)
          );
        }
        sepEnd = pos + 1;
        ++sepCount;
      } else if (!isDecimalDigit(c)) {
        break;
      }
      ++pos;
    }

    if (pos != start && sepEnd == pos) {
      this.error(
        DiagnosticCode.Numeric_separators_are_not_allowed_here,
        this.range(sepEnd - 1)
      );
    }

    this.pos = pos;
    return sepCount;
  }

  readHexFloat(): f64 {
    throw new Error("not implemented"); // TBD
  }

  readHexadecimalEscape(remain: i32 = 2, startIfTaggedTemplate: i32 = -1): string {
    var value = 0;
    var text = this.source.text;
    var pos = this.pos;
    var end = this.end;
    while (pos < end) {
      let c = text.charCodeAt(pos++);
      if (c >= CharCode._0 && c <= CharCode._9) {
        value = (value << 4) + c - CharCode._0;
      } else if (c >= CharCode.A && c <= CharCode.F) {
        value = (value << 4) + c + (10 - CharCode.A);
      } else if (c >= CharCode.a && c <= CharCode.f) {
        value = (value << 4) + c + (10 - CharCode.a);
      } else if (~startIfTaggedTemplate) {
        this.pos = --pos;
        return text.substring(startIfTaggedTemplate, pos);
      } else {
        this.pos = pos;
        this.error(
          DiagnosticCode.Hexadecimal_digit_expected,
          this.range(pos - 1, pos)
        );
        return "";
      }
      if (--remain == 0) break;
    }
    if (remain) { // invalid
      this.pos = pos;
      if (~startIfTaggedTemplate) {
        return text.substring(startIfTaggedTemplate, pos);
      }
      this.error(
        DiagnosticCode.Unexpected_end_of_text,
        this.range(pos)
      );
      return "";
    }
    this.pos = pos;
    return String.fromCharCode(value);
  }

  checkForIdentifierStartAfterNumericLiteral(): void {
    // TODO: BigInt n
    var pos = this.pos;
    if (pos < this.end && isIdentifierStart(this.source.text.charCodeAt(pos))) {
      this.error(
        DiagnosticCode.An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal,
        this.range(pos)
      );
    }
  }

  readUnicodeEscape(startIfTaggedTemplate: i32 = -1): string {
    return this.readHexadecimalEscape(4, startIfTaggedTemplate);
  }

  private readExtendedUnicodeEscape(startIfTaggedTemplate: i32 = -1): string {
    var start = this.pos;
    var value = this.readHexInteger();
    var value32 = i64_low(value);
    var invalid = false;

    assert(!i64_high(value));
    if (value32 > 0x10FFFF) {
      if (startIfTaggedTemplate == -1) {
        this.error(
          DiagnosticCode.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive,
          this.range(start, this.pos)
        );
      }
      invalid = true;
    }

    var end = this.end;
    var text = this.source.text;
    if (this.pos >= end) {
      if (startIfTaggedTemplate == -1) {
        this.error(
          DiagnosticCode.Unexpected_end_of_text,
          this.range(start, end)
        );
      }
      invalid = true;
    } else if (text.charCodeAt(this.pos) == CharCode.CLOSEBRACE) {
      ++this.pos;
    } else {
      if (startIfTaggedTemplate == -1) {
        this.error(
          DiagnosticCode.Unterminated_Unicode_escape_sequence,
          this.range(start, this.pos)
        );
      }
      invalid = true;
    }

    if (invalid) {
      return ~startIfTaggedTemplate
        ? text.substring(startIfTaggedTemplate, this.pos)
        : "";
    }
    return value32 < 0x10000
      ? String.fromCharCode(value32)
      : String.fromCharCode(
        ((value32 - 0x10000) >>> 10) | 0xD800,
        ((value32 - 0x10000) & 1023) | 0xDC00
      );
  }
}

/** Tokenizer state as returned by {@link Tokenizer#mark} and consumed by {@link Tokenizer#reset}. */
export class State {
  constructor(
    /** Current position. */
    public pos: i32,
    /** Current token. */
    public token: Token,
    /** Current token's position. */
    public tokenPos: i32
  ) {}
}

// Reusable state object to reduce allocations
var reusableState: State | null = null;

'''
'''--- src/tsconfig.json ---
{
  "extends": "../std/portable.json",
  "compilerOptions": {
    "outDir": "../out",
    "allowJs": false,
    "sourceMap": true,
    "target": "esnext",
    "strict": true
  },
  "include": [
    "./**/*.ts"
  ],
  "exclude": [
    "./glue/wasm/**"
  ]
}

'''
'''--- src/types.ts ---
/**
 * @fileoverview Mappings from AssemblyScript types to WebAssembly types.
 * @license Apache-2.0
 */

import {
  Class,
  Program,
  DecoratorFlags
} from "./program";

import {
  TypeRef,
  createType
} from "./module";

/** Indicates the kind of a type. */
export const enum TypeKind {

  // signed integers

  /** An 8-bit signed integer. */
  I8,
  /** A 16-bit signed integer. */
  I16,
  /** A 32-bit signed integer. */
  I32,
  /** A 64-bit signed integer. */
  I64,
  /** A 32-bit/64-bit signed integer, depending on the target. */
  ISIZE,

  // unsigned integers

  /** An 8-bit unsigned integer. */
  U8,
  /** A 16-bit unsigned integer. */
  U16,
  /** A 32-bit unsigned integer. Also the base of function types. */
  U32,
  /** A 64-bit unsigned integer. */
  U64,
  /** A 32-bit/64-bit unsigned integer, depending on the target. Also the base of class types. */
  USIZE,
  /** A 1-bit unsigned integer. */
  BOOL, // sic

  // floats

  /** A 32-bit float. */
  F32,
  /** A 64-bit double. */
  F64,

  // vectors

  /** A 128-bit vector. */
  V128,

  // references

  /** Function reference. */
  FUNCREF,
  /** External reference. */
  EXTERNREF,
  /** Any reference. */
  ANYREF,
  /** Equatable reference. */
  EQREF,
  /** 31-bit integer reference. */
  I31REF,
  /** Data reference. */
  DATAREF,

  // other

  /** No return type. */
  VOID
}

/** Indicates capabilities of a type. */
export const enum TypeFlags {
  NONE = 0,
  /** Is a signed type that can represent negative values. */
  SIGNED = 1 << 0,
  /** Is an unsigned type that cannot represent negative values. */
  UNSIGNED = 1 << 1,
  /** Is an integer type. */
  INTEGER = 1 << 2,
  /** Is a floating point type. */
  FLOAT = 1 << 3,
  /** Is a varying (in size) type. */
  VARYING = 1 << 4,
  /** Is smaller than 32-bits. */
  SHORT = 1 << 5,
  /** Is larger than 32-bits. */
  LONG = 1 << 6,
  /** Is a value type. */
  VALUE = 1 << 7,
  /** Is a reference type (either a class or a function type). */
  REFERENCE = 1 << 8,
  /** Is a nullable type. */
  NULLABLE = 1 << 9,
  /** Is a vector type. */
  VECTOR = 1 << 10,
  /** Is an external type. */
  EXTERNAL = 1 << 11,
  /** Is a class. */
  CLASS = 1 << 12,
  /** Is a function. */
  FUNCTION = 1 << 13
}

/** Represents a resolved type. */
export class Type {

  /** Type kind. */
  kind: TypeKind;
  /** Type flags. */
  flags: TypeFlags;
  /** Size in bits. */
  size: i32;
  /** Size in bytes. */
  byteSize: i32;
  /** Underlying class reference, if a class type. */
  classReference: Class | null;
  /** Underlying signature reference, if a function type. */
  signatureReference: Signature | null;
  /** Respective non-nullable type, if nullable. */
  private _nonNullableType: Type | null = null;
  /** Respective nullable type, if non-nullable. */
  private _nullableType: Type | null = null;

  /** Constructs a new resolved type. */
  constructor(kind: TypeKind, flags: TypeFlags, size: u32) {
    this.kind = kind;
    this.flags = flags;
    this.size = size;
    this.byteSize = <i32>ceil<f64>(<f64>size / 8);
    this.classReference = null;
    this.signatureReference = null;
    if (!(flags & TypeFlags.NULLABLE)) {
      this._nonNullableType = this;
    } else {
      this._nullableType = this;
    }
  }

  /** Returns the closest int type representing this type. */
  get intType(): Type {
    if (this == Type.auto) return this; // keep auto as a hint
    switch (this.kind) {
      case TypeKind.I8: return Type.i8;
      case TypeKind.I16: return Type.i16;
      case TypeKind.F32:
      case TypeKind.I32: return Type.i32;
      case TypeKind.F64:
      case TypeKind.I64: return Type.i64;
      case TypeKind.ISIZE: return this.size == 64 ? Type.isize64 : Type.isize32;
      case TypeKind.U8: return Type.u8;
      case TypeKind.U16: return Type.u16;
      case TypeKind.U32: return Type.u32;
      case TypeKind.U64: return Type.u64;
      case TypeKind.USIZE: return this.size == 64 ? Type.usize64 : Type.usize32;
      case TypeKind.BOOL:
      default: return Type.i32;
    }
  }

  /** Substitutes this type with the auto type if this type is void. */
  get exceptVoid(): Type {
    if (this.kind == TypeKind.VOID) return Type.auto;
    return this;
  }

  /** Gets this type's logarithmic alignment in memory. */
  get alignLog2(): i32 {
    return 31 - clz<i32>(this.byteSize);
  }

  /** Tests if this type represents a basic value. */
  get isValue(): bool {
    return this.is(TypeFlags.VALUE);
  }

  /** Tests if this type represents an integer value. */
  get isIntegerValue(): bool {
    return this.is(TypeFlags.INTEGER | TypeFlags.VALUE);
  }

  /** Tests if this type represents a small (< 32 bits) integer value. */
  get isShortIntegerValue(): bool {
    return this.is(TypeFlags.SHORT | TypeFlags.INTEGER | TypeFlags.VALUE);
  }

  /** Tests if this type represents a long (> 32 bits) integer value. */
  get isLongIntegerValue(): bool {
    return this.is(TypeFlags.LONG | TypeFlags.INTEGER | TypeFlags.VALUE);
  }

  /** Tests if this type represents a signed integer value. */
  get isSignedIntegerValue(): bool {
    return this.is(TypeFlags.SIGNED | TypeFlags.INTEGER | TypeFlags.VALUE);
  }

  /** Tests if this type represents an unsigned integer value. */
  get isUnsignedIntegerValue(): bool {
    return this.is(TypeFlags.UNSIGNED | TypeFlags.INTEGER | TypeFlags.VALUE);
  }

  /** Tests if this type represents a varying (in size) integer value. */
  get isVaryingIntegerValue(): bool {
    return this.is(TypeFlags.VARYING | TypeFlags.INTEGER | TypeFlags.VALUE);
  }

  /** Tests if this type represents an integer, including references.  */
  get isIntegerInclReference(): bool {
    return this.is(TypeFlags.INTEGER);
  }

  /** Tests if this type represents a floating point value. */
  get isFloatValue(): bool {
    return this.is(TypeFlags.FLOAT | TypeFlags.VALUE);
  }
  
  /** Tests if this type represents a numeric (integer or floating point) value. */
  get isNumericValue(): bool {
    return this.isIntegerValue || this.isFloatValue;
  }

  /** Tests if this type represents a boolean value. */
  get isBooleanValue(): bool {
    return this == Type.bool;
  }

  /** Tests if this type represents a vector value. */
  get isVectorValue(): bool {
    return this.is(TypeFlags.VECTOR | TypeFlags.VALUE);
  }
  
  /** Tests if this type represents an internal or external reference. */
  get isReference(): bool {
    return this.is(TypeFlags.REFERENCE);
  }

  /** Tests if this type represents a nullable internal or external reference. */
  get isNullableReference(): bool {
    return this.is(TypeFlags.NULLABLE | TypeFlags.REFERENCE);
  }

  /** Tests if this type represents an internal object. */
  get isInternalReference(): bool {
    return this.is(TypeFlags.INTEGER | TypeFlags.REFERENCE);
  }

  /** Tests if this type represents an external object. */
  get isExternalReference(): bool {
    return this.is(TypeFlags.EXTERNAL | TypeFlags.REFERENCE);
  }

  /** Tests if this type represents a class. */
  get isClass(): bool {
    return this.isInternalReference
      ? this.classReference !== null
      : false;
  }

  /** Gets the underlying class of this type, if any. */
  getClass(): Class | null {
    return this.isInternalReference
      ? this.classReference
      : null;
  }

  /** Gets the underlying class or wrapper class of this type, if any. */
  getClassOrWrapper(program: Program): Class | null {
    let classReference = this.getClass();
    if (classReference) {
      // typical class
      return classReference;
    } else {
      let signatureReference = this.getSignature();
      if (signatureReference) {
        // function wrapper
        let type = signatureReference.type;
        let wrapper = assert(program.resolver.resolveClass(program.functionPrototype, [ type ]));
        wrapper.wrappedType = type;
        return wrapper;
      } else {
        let wrapperClasses = program.wrapperClasses;
        if (wrapperClasses.has(this)) {
          // value wrapper
          return assert(wrapperClasses.get(this));
        }
      }
    }
    return null;
  }

  /** Tests if this type represents a function. */
  get isFunction(): bool {
    return this.isInternalReference
      ? this.signatureReference !== null
      : false;
  }

  /** Gets the underlying function signature of this type, if any. */
  getSignature(): Signature | null {
    return this.isInternalReference
      ? this.signatureReference
      : null;
  }

  /** Tests if this is a managed type that needs GC hooks. */
  get isManaged(): bool {
    if (this.isInternalReference) {
      let classReference = this.classReference;
      if (classReference) return !classReference.hasDecorator(DecoratorFlags.UNMANAGED);
      return this.signatureReference !== null; // function references are managed
    }
    return false;
  }

  /** Tests if this is a class type explicitly annotated as unmanaged. */
  get isUnmanaged(): bool {
    var classReference = this.classReference;
    return classReference !== null && classReference.hasDecorator(DecoratorFlags.UNMANAGED);
  }

  /** Gets the corresponding non-nullable type. */
  get nonNullableType(): Type {
    if (this.isExternalReference) {
      return this; // TODO
    }
    return assert(this._nonNullableType); // set either in ctor or asNullable
  }

  /** Gets the corresponding nullable type, if applicable. */
  get nullableType(): Type | null {
    return this._nullableType; // set either in ctor or asNullable
  }

  /** Computes the sign-extending shift in the target type. */
  computeSmallIntegerShift(targetType: Type): i32 {
    return targetType.size - this.size;
  }

  /** Computes the truncating mask in the target type. */
  computeSmallIntegerMask(targetType: Type): i32 {
    var size = this.is(TypeFlags.UNSIGNED) ? this.size : this.size - 1;
    return ~0 >>> (targetType.size - size);
  }

  /** Tests if this type has (all of) the specified flags. */
  is(flags: TypeFlags): bool { return (this.flags & flags) == flags; }
  /** Tests if this type has any of the specified flags. */
  isAny(flags: TypeFlags): bool { return (this.flags & flags) != 0; }

  /** Composes the respective nullable type of this type. */
  asNullable(): Type {
    assert(this.isInternalReference);
    var nullableType = this._nullableType;
    if (!nullableType) {
      assert(!this.isNullableReference);
      this._nullableType = nullableType = new Type(this.kind, this.flags | TypeFlags.NULLABLE, this.size);
      nullableType.classReference = this.classReference;         // either a class reference
      nullableType.signatureReference = this.signatureReference; // or a function reference
      nullableType._nonNullableType = this;
    }
    return nullableType;
  }

  /** Tests if this type equals the specified. */
  equals(other: Type): bool {
    if (this.kind != other.kind) return false;
    if (this.isReference) {
      return (
        this.classReference == other.classReference &&
        this.signatureReference == other.signatureReference &&
        this.isNullableReference == other.isNullableReference
      );
    }
    return true;
  }

  /** Tests if a value of this type is assignable to the target type incl. implicit conversion. */
  isAssignableTo(target: Type, signednessIsRelevant: bool = false): bool {
    var currentClass: Class | null;
    var targetClass: Class | null;
    var currentFunction: Signature | null;
    var targetFunction: Signature | null;
    if (this.isReference) {
      if (target.isReference) {
        if (!this.isNullableReference || target.isNullableReference) {
          if (currentClass = this.getClass()) {
            if (targetClass = target.getClass()) {
              return currentClass.isAssignableTo(targetClass);
            }
          } else if (currentFunction = this.getSignature()) {
            if (targetFunction = target.getSignature()) {
              return currentFunction.isAssignableTo(targetFunction);
            }
          } else if (this.isExternalReference && (this.kind == target.kind || (target.kind == TypeKind.ANYREF && this.kind != TypeKind.EXTERNREF))) {
            return true;
          }
        }
      }
    } else if (!target.isReference) {
      if (this.isIntegerValue) {
        if (target.isIntegerValue) {
          if (
            !signednessIsRelevant ||
            this.isBooleanValue || // a bool (0 or 1) can be safely assigned to all sorts of integers
            this.isSignedIntegerValue == target.isSignedIntegerValue
          ) {
            return this.size <= target.size;
          }
        } else if (target.kind == TypeKind.F32) {
          return this.size <= 23; // mantissa bits
        } else if (target.kind == TypeKind.F64) {
          return this.size <= 52; // ^
        }
      } else if (this.isFloatValue) {
        if (target.isFloatValue) {
          return this.size <= target.size;
        }
      } else if (this.isVectorValue) {
        if (target.isVectorValue) {
          return this.size == target.size;
        }
      }
    }
    return false;
  }

  /** Tests if a value of this type is assignable to the target type excl. implicit conversion. */
  isStrictlyAssignableTo(target: Type, signednessIsRelevant: bool = false): bool {
    if (this.isReference) return this.isAssignableTo(target);
    else if (target.isReference) return false;
    // not dealing with references from here on
    if (this.isIntegerValue) {
      return target.isIntegerValue && target.size == this.size && (
        !signednessIsRelevant ||
        this.isSignedIntegerValue == target.isSignedIntegerValue
      );
    }
    return this.kind == target.kind;
  }

  /** Tests if a value of this type can be changed to the target type using `changetype`. */
  isChangeableTo(target: Type): bool {
    // special in that it allows integer references as well
    if (this.is(TypeFlags.INTEGER) && target.is(TypeFlags.INTEGER)) {
      let size = this.size;
      return size == target.size && (size >= 32 || this.is(TypeFlags.SIGNED) == target.is(TypeFlags.SIGNED));
    }
    return this.kind == target.kind;
  }

  /** Determines the common denominator type of two types, if there is any. */
  static commonDenominator(left: Type, right: Type, signednessIsImportant: bool): Type | null {
    if (right.isAssignableTo(left, signednessIsImportant)) return left;
    else if (left.isAssignableTo(right, signednessIsImportant)) return right;
    return null;
  }

  /** Converts this type to a string. */
  toString(validWat: bool = false): string {
    const nullablePostfix = validWat
      ? "|null"
      : " | null";
    if (this.isReference) {
      let classReference = this.getClass();
      if (classReference) {
        return this.isNullableReference
          ? classReference.internalName + nullablePostfix
          : classReference.internalName;
      } else {
        let signatureReference = this.getSignature();
        if (signatureReference) {
          return this.isNullableReference
            ? "(" + signatureReference.toString(validWat) + ")" + nullablePostfix
            : signatureReference.toString(validWat);
        }
      }
    }
    switch (this.kind) {
      case TypeKind.I8: return "i8";
      case TypeKind.I16: return "i16";
      case TypeKind.I32: return "i32";
      case TypeKind.I64: return "i64";
      case TypeKind.ISIZE: return "isize";
      case TypeKind.U8: return "u8";
      case TypeKind.U16: return "u16";
      case TypeKind.U32: return "u32";
      case TypeKind.U64: return "u64";
      case TypeKind.USIZE: return "usize";
      case TypeKind.BOOL: return "bool";
      case TypeKind.F32: return "f32";
      case TypeKind.F64: return "f64";
      case TypeKind.V128: return "v128";
      case TypeKind.FUNCREF: return "funcref";
      case TypeKind.EXTERNREF: return "externref";
      case TypeKind.ANYREF: return "anyref";
      case TypeKind.EQREF: return "eqref";
      case TypeKind.I31REF: return "i31ref";
      case TypeKind.DATAREF: return "dataref";
      default: assert(false);
      case TypeKind.VOID: return "void";
    }
  }

  // Binaryen specific

  /** Converts this type to its respective type reference. */
  toRef(): TypeRef {
    switch (this.kind) {
      default: assert(false);
      case TypeKind.I8:
      case TypeKind.I16:
      case TypeKind.I32:
      case TypeKind.U8:
      case TypeKind.U16:
      case TypeKind.U32:
      case TypeKind.BOOL: return TypeRef.I32;
      case TypeKind.ISIZE:
      case TypeKind.USIZE: if (this.size != 64) return TypeRef.I32;
      case TypeKind.I64:
      case TypeKind.U64: return TypeRef.I64;
      case TypeKind.F32: return TypeRef.F32;
      case TypeKind.F64: return TypeRef.F64;
      case TypeKind.V128: return TypeRef.V128;
      // TODO: nullable/non-nullable refs have different type refs
      case TypeKind.FUNCREF: return TypeRef.Funcref;
      case TypeKind.EXTERNREF: return TypeRef.Externref;
      case TypeKind.ANYREF: return TypeRef.Anyref;
      case TypeKind.EQREF: return TypeRef.Eqref;
      case TypeKind.I31REF: return TypeRef.I31ref;
      case TypeKind.DATAREF: return TypeRef.Dataref;
      case TypeKind.VOID: return TypeRef.None;
    }
  }

  // Types

  /** An 8-bit signed integer. */
  static readonly i8: Type  = new Type(TypeKind.I8,
    TypeFlags.SIGNED   |
    TypeFlags.SHORT    |
    TypeFlags.INTEGER  |
    TypeFlags.VALUE,   8
  );

  /** A 16-bit signed integer. */
  static readonly i16: Type = new Type(TypeKind.I16,
    TypeFlags.SIGNED   |
    TypeFlags.SHORT    |
    TypeFlags.INTEGER  |
    TypeFlags.VALUE,  16
  );

  /** A 32-bit signed integer. */
  static readonly i32: Type = new Type(TypeKind.I32,
    TypeFlags.SIGNED   |
    TypeFlags.INTEGER  |
    TypeFlags.VALUE,  32
  );

  /** A 64-bit signed integer. */
  static readonly i64: Type = new Type(TypeKind.I64,
    TypeFlags.SIGNED   |
    TypeFlags.LONG     |
    TypeFlags.INTEGER  |
    TypeFlags.VALUE,  64
  );

  /** A 32-bit signed size. WASM32 only. */
  static readonly isize32: Type = new Type(TypeKind.ISIZE,
    TypeFlags.SIGNED   |
    TypeFlags.INTEGER  |
    TypeFlags.VARYING  |
    TypeFlags.VALUE,  32
  );

  /** A 64-bit signed size. WASM64 only. */
  static readonly isize64: Type = new Type(TypeKind.ISIZE,
    TypeFlags.SIGNED   |
    TypeFlags.LONG     |
    TypeFlags.INTEGER  |
    TypeFlags.VARYING  |
    TypeFlags.VALUE,  64
  );

  /** An 8-bit unsigned integer. */
  static readonly u8: Type = new Type(TypeKind.U8,
    TypeFlags.UNSIGNED |
    TypeFlags.SHORT    |
    TypeFlags.INTEGER  |
    TypeFlags.VALUE,   8
  );

  /** A 16-bit unsigned integer. */
  static readonly u16: Type = new Type(TypeKind.U16,
    TypeFlags.UNSIGNED |
    TypeFlags.SHORT    |
    TypeFlags.INTEGER  |
    TypeFlags.VALUE,  16
  );

  /** A 32-bit unsigned integer. */
  static readonly u32: Type = new Type(TypeKind.U32,
    TypeFlags.UNSIGNED |
    TypeFlags.INTEGER  |
    TypeFlags.VALUE,  32
  );

  /** A 64-bit unsigned integer. */
  static readonly u64: Type = new Type(TypeKind.U64,
    TypeFlags.UNSIGNED |
    TypeFlags.LONG     |
    TypeFlags.INTEGER  |
    TypeFlags.VALUE,  64
  );

  /** A 32-bit unsigned size. WASM32 only. */
  static readonly usize32: Type = new Type(TypeKind.USIZE,
    TypeFlags.UNSIGNED |
    TypeFlags.INTEGER  |
    TypeFlags.VARYING  |
    TypeFlags.VALUE,  32
  );

  /** A 64-bit unsigned size. WASM64 only. */
  static readonly usize64: Type = new Type(TypeKind.USIZE,
    TypeFlags.UNSIGNED |
    TypeFlags.LONG     |
    TypeFlags.INTEGER  |
    TypeFlags.VARYING  |
    TypeFlags.VALUE,  64
  );

  /** A 1-bit unsigned integer. */
  static readonly bool: Type = new Type(TypeKind.BOOL,
    TypeFlags.UNSIGNED |
    TypeFlags.SHORT    |
    TypeFlags.INTEGER  |
    TypeFlags.VALUE,   1
  );

  /** A 32-bit float. */
  static readonly f32: Type = new Type(TypeKind.F32,
    TypeFlags.SIGNED   |
    TypeFlags.FLOAT    |
    TypeFlags.VALUE,  32
  );

  /** A 64-bit float. */
  static readonly f64: Type = new Type(TypeKind.F64,
    TypeFlags.SIGNED   |
    TypeFlags.LONG     |
    TypeFlags.FLOAT    |
    TypeFlags.VALUE,  64
  );

  /** A 128-bit vector. */
  static readonly v128: Type = new Type(TypeKind.V128,
    TypeFlags.VECTOR   |
    TypeFlags.VALUE, 128
  );

  /** Function reference. */
  static readonly funcref: Type = new Type(TypeKind.FUNCREF,
    TypeFlags.EXTERNAL   |
    TypeFlags.NULLABLE   |
    TypeFlags.REFERENCE, 0
  );

  /** External reference. */
  static readonly externref: Type = new Type(TypeKind.EXTERNREF,
    TypeFlags.EXTERNAL   |
    TypeFlags.NULLABLE   |
    TypeFlags.REFERENCE, 0
  );

  /** Any reference. */
  static readonly anyref: Type = new Type(TypeKind.ANYREF,
    TypeFlags.EXTERNAL   |
    TypeFlags.NULLABLE   |
    TypeFlags.REFERENCE, 0
  );

  /** Equatable reference. */
  static readonly eqref: Type = new Type(TypeKind.EQREF,
    TypeFlags.EXTERNAL   |
    TypeFlags.NULLABLE   |
    TypeFlags.REFERENCE, 0
  );

  /** 31-bit integer reference. */
  static readonly i31ref: Type = new Type(TypeKind.I31REF,
    TypeFlags.EXTERNAL   |
    TypeFlags.REFERENCE, 0
  );

  /** Data reference. */
  static readonly dataref: Type = new Type(TypeKind.DATAREF,
    TypeFlags.EXTERNAL   |
    TypeFlags.NULLABLE   |
    TypeFlags.REFERENCE, 0
  );

  /** No return type. */
  static readonly void: Type = new Type(TypeKind.VOID, TypeFlags.NONE, 0);

  /** Alias of i32 indicating type inference of locals and globals with just an initializer. */
  static readonly auto: Type = new Type(Type.i32.kind, Type.i32.flags, Type.i32.size);
}

/** Converts an array of types to an array of type references. */
export function typesToRefs(types: Type[]): TypeRef[] {
  var numTypes = types.length;
  var ret = new Array<TypeRef>(numTypes);
  for (let i = 0; i < numTypes; ++i) ret[i] = types[i].toRef();
  return ret;
}

/** Converts an array of types to its combined string representation. */
export function typesToString(types: Type[]): string {
  var numTypes = types.length;
  if (!numTypes) return "";
  var sb = new Array<string>(numTypes);
  for (let i = 0; i < numTypes; ++i) sb[i] = types[i].toString(true);
  return sb.join(",");
}

/** Represents a fully resolved function signature. */
export class Signature {
  /** Unique id representing this signature. */
  id: u32 = 0;
  /** Parameter types, if any, excluding `this`. */
  parameterTypes: Type[];
  /** Number of required parameters excluding `this`. Other parameters are considered optional. */
  requiredParameters: i32;
  /** Return type. */
  returnType: Type;
  /** This type, if an instance signature. */
  thisType: Type | null;
  /** Whether the last parameter is a rest parameter. */
  hasRest: bool;
  /** Respective function type. */
  type: Type;
  /** The program that created this signature. */
  program: Program;

  /** Constructs a new signature. */
  constructor(
    program: Program,
    parameterTypes: Type[] | null = null,
    returnType: Type | null = null,
    thisType: Type | null = null
  ) {
    this.parameterTypes = parameterTypes ? parameterTypes : [];
    this.requiredParameters = 0;
    this.returnType = returnType ? returnType : Type.void;
    this.thisType = thisType;
    this.program = program;
    this.hasRest = false;
    var usizeType = program.options.usizeType;
    var type = new Type(usizeType.kind, usizeType.flags & ~TypeFlags.VALUE | TypeFlags.REFERENCE, usizeType.size);
    this.type = type;
    type.signatureReference = this;

    var signatureTypes = program.uniqueSignatures;
    var length = signatureTypes.length;
    for (let i = 0; i < length; i++) {
      let compare = signatureTypes[i];
      if (this.equals(compare)) {
        this.id = compare.id;
        return this;
      }
    }
    this.id = program.nextSignatureId++;
    program.uniqueSignatures.push(this);
  }

  get paramRefs(): TypeRef {
    var thisType = this.thisType;
    var parameterTypes = this.parameterTypes;
    var numParameterTypes = parameterTypes.length;
    if (!numParameterTypes) {
      if (!thisType) return TypeRef.None;
      return thisType.toRef();
    }
    if (thisType) {
      let typeRefs = new Array<TypeRef>(1 + numParameterTypes);
      typeRefs[0] = thisType.toRef();
      for (let i = 0; i < numParameterTypes; ++i) {
        typeRefs[i + 1] = parameterTypes[i].toRef();
      }
      return createType(typeRefs);
    }
    return createType(typesToRefs(parameterTypes));
  }

  get resultRefs(): TypeRef {
    return this.returnType.toRef();
  }

  /** Tests if this signature equals the specified. */
  equals(other: Signature): bool {

    // check `this` type
    var thisThisType = this.thisType;
    var otherThisType = other.thisType;
    if (thisThisType !== null) {
      if (otherThisType === null || !thisThisType.equals(otherThisType)) return false;
    } else if (otherThisType) {
      return false;
    }

    // check rest parameter
    if (this.hasRest != other.hasRest) return false;

    // check parameter types
    var thisParameterTypes = this.parameterTypes;
    var otherParameterTypes = other.parameterTypes;
    var numParameters = thisParameterTypes.length;
    if (numParameters != otherParameterTypes.length) return false;
    for (let i = 0; i < numParameters; ++i) {
      if (!thisParameterTypes[i].equals(otherParameterTypes[i])) return false;
    }

    // check return type
    return this.returnType.equals(other.returnType);
  }

  /** Tests if a value of this function type is assignable to a target of the specified function type. */
  isAssignableTo(target: Signature, requireSameSize: bool = false): bool {

    // check `this` type
    var thisThisType = this.thisType;
    var targetThisType = target.thisType;
    if (thisThisType !== null) {
      if (targetThisType === null || !thisThisType.isAssignableTo(targetThisType)) return false;
    } else if (targetThisType) {
      return false;
    }

    // check rest parameter
    if (this.hasRest != target.hasRest) return false; // TODO

    // check parameter types
    var thisParameterTypes = this.parameterTypes;
    var targetParameterTypes = target.parameterTypes;
    var numParameters = thisParameterTypes.length;
    if (numParameters != targetParameterTypes.length) return false; // TODO
    for (let i = 0; i < numParameters; ++i) {
      let thisParameterType = thisParameterTypes[i];
      let targetParameterType = targetParameterTypes[i];
      if (!thisParameterType.isAssignableTo(targetParameterType)) return false;
    }

    // check return type
    var thisReturnType = this.returnType;
    var targetReturnType = target.returnType;
    return thisReturnType == targetReturnType || thisReturnType.isAssignableTo(targetReturnType);
  }

  /** Tests if this signature has at least one managed operand. */
  get hasManagedOperands(): bool {
    var thisType = this.thisType;
    if (thisType) {
      if (thisType.isManaged) return true;
    }
    var parameterTypes = this.parameterTypes;
    for (let i = 0, k = parameterTypes.length; i < k; ++i) {
      if (parameterTypes[i].isManaged) return true;
    }
    return false;
  }

  /** Gets the indices of all managed operands. */
  getManagedOperandIndices(): i32[] {
    var indices = new Array<i32>();
    var index = 0;
    var thisType = this.thisType;
    if (thisType) {
      if (thisType.isManaged) {
        indices.push(index);
      }
      ++index;
    }
    var parameterTypes = this.parameterTypes;
    for (let i = 0, k = parameterTypes.length; i < k; ++i) {
      if (parameterTypes[i].isManaged) {
        indices.push(index);
      }
      ++index;
    }
    return indices;
  }

  /** Converts this signature to a string. */
  toString(validWat: bool = false): string {
    var sb = new Array<string>();
    sb.push(validWat ? "%28" : "(");
    var index = 0;
    var thisType = this.thisType;
    if (thisType) {
      sb.push(validWat ? "this:" : "this: ");
      assert(!thisType.signatureReference);
      sb.push(thisType.toString(validWat));
      index = 1;
    }
    var parameters = this.parameterTypes;
    var numParameters = parameters.length;
    if (numParameters) {
      let optionalStart = this.requiredParameters;
      let restIndex = this.hasRest ? numParameters - 1 : -1;
      for (let i = 0; i < numParameters; ++i, ++index) {
        if (index) sb.push(validWat ? "%2C" : ", ");
        if (i == restIndex) sb.push("...");
        sb.push(parameters[i].toString(validWat));
        if (i >= optionalStart && i != restIndex) sb.push("?");
      }
    }
    sb.push(validWat ? "%29=>" : ") => ");
    sb.push(this.returnType.toString(validWat));
    return sb.join("");
  }

  /** Creates a clone of this signature that is safe to modify. */
  clone(): Signature {
    var parameterTypes = this.parameterTypes;
    var numParameterTypes = parameterTypes.length;
    var cloneParameterTypes = new Array<Type>(numParameterTypes);
    for (let i = 0; i < numParameterTypes; ++i) {
      cloneParameterTypes[i] = parameterTypes[i];
    }
    return new Signature(this.program, cloneParameterTypes, this.returnType, this.thisType);
  }
}

'''
'''--- src/util/binary.ts ---
/**
 * @fileoverview Various binary reading and writing utility.
 * @license Apache-2.0
 */

/** Reads an 8-bit integer from the specified buffer. */
export function readI8(buffer: Uint8Array, offset: i32): i32 {
  return buffer[offset];
}

/** Writes an 8-bit integer to the specified buffer. */
export function writeI8(value: i32, buffer: Uint8Array, offset: i32): void {
  buffer[offset] = value;
}

/** Reads a 16-bit integer from the specified buffer. */
export function readI16(buffer: Uint8Array, offset: i32): i32 {
  return i32(buffer[offset    ])
       | i32(buffer[offset + 1]) << 8;
}

/** Writes a 16-bit integer to the specified buffer. */
export function writeI16(value: i32, buffer: Uint8Array, offset: i32): void {
  buffer[offset    ] = value;
  buffer[offset + 1] = value >>> 8;
}

/** Reads a 32-bit integer from the specified buffer. */
export function readI32(buffer: Uint8Array, offset: i32): i32 {
  return i32(buffer[offset    ])
       | i32(buffer[offset + 1]) << 8
       | i32(buffer[offset + 2]) << 16
       | i32(buffer[offset + 3]) << 24;
}

/** Writes a 32-bit integer to the specified buffer. */
export function writeI32(value: i32, buffer: Uint8Array, offset: i32): void {
  buffer[offset    ] = value;
  buffer[offset + 1] = value >>> 8;
  buffer[offset + 2] = value >>> 16;
  buffer[offset + 3] = value >>> 24;
}

/** Writes a 32-bit integer as a 64-bit integer to the specified buffer. */
export function writeI32AsI64(value: i32, buffer: Uint8Array, offset: i32, unsigned: bool = false): void {
  writeI32(value, buffer, offset);
  writeI32(unsigned || value >= 0 ? 0 : -1, buffer, offset + 4);
}

/** Reads a 64-bit integer from the specified buffer. */
export function readI64(buffer: Uint8Array, offset: i32): i64 {
  var lo = readI32(buffer, offset);
  var hi = readI32(buffer, offset + 4);
  return i64_new(lo, hi);
}

/** Writes a 64-bit integer to the specified buffer. */
export function writeI64(value: i64, buffer: Uint8Array, offset: i32): void {
  writeI32(i64_low(value), buffer, offset);
  writeI32(i64_high(value), buffer, offset + 4);
}

/** Writes a 64-bit integer as a 32-bit integer to the specified buffer. */
export function writeI64AsI32(value: i64, buffer: Uint8Array, offset: i32, unsigned: bool = false): void {
  assert(unsigned ? i64_is_u32(value) : i64_is_i32(value));
  writeI32(i64_low(value), buffer, offset);
}

/** Reads a 32-bit float from the specified buffer. */
export function readF32(buffer: Uint8Array, offset: i32): f32 {
  return i32_as_f32(readI32(buffer, offset));
}

/** Writes a 32-bit float to the specified buffer. */
export function writeF32(value: f32, buffer: Uint8Array, offset: i32): void {
  writeI32(f32_as_i32(value), buffer, offset);
}

/** Reads a 64-bit float from the specified buffer. */
export function readF64(buffer: Uint8Array, offset: i32): f64 {
  return i64_as_f64(readI64(buffer, offset));
}

/** Writes a 64-bit float to the specified buffer. */
export function writeF64(value: f64, buffer: Uint8Array, offset: i32): void {
  var valueI64 = f64_as_i64(value);
  writeI32(i64_low(valueI64), buffer, offset);
  writeI32(i64_high(valueI64), buffer, offset + 4);
}

'''
'''--- src/util/collections.ts ---
/**
 * @fileoverview Various collections utility.
 * @license Apache-2.0
 */

/** Makes a unique map. Typically used to track contextual type arguemnts. */
export function uniqueMap<K,V>(original: Map<K,V> | null = null, overrides: Map<K,V> | null = null): Map<K,V> {
  var cloned = new Map<K,V>();
  if (original) {
    // TODO: for (let [k, v] of original) {
    for (let _keys = Map_keys(original), i = 0, k = _keys.length; i < k; ++i) {
      let k = unchecked(_keys[i]);
      let v = assert(original.get(k));
      cloned.set(k, v);
    }
  }
  if (overrides) {
    // TODO: for (let [k, v] of overrides) {
    for (let _keys = Map_keys(overrides), i = 0, k = _keys.length; i < k; ++i) {
      let k = unchecked(_keys[i]);
      let v = assert(overrides.get(k));
      cloned.set(k, v);
    }
  }
  return cloned;
}

'''
'''--- src/util/index.ts ---
/**
 * @fileoverview Various utility.
 * @license Apache-2.0
 */

export * from "./binary";
export * from "./collections";
export * from "./math";
export * from "./path";
export * from "./terminal";
export * from "./text";
export * from "./vector";

'''
'''--- src/util/math.ts ---
/**
 * @fileoverview Various math utility.
 * @license Apache-2.0
 */

/** Tests if `x` is a power of two. */
export function isPowerOf2(x: i32): bool {
  return x != 0 && (x & (x - 1)) == 0;
}

'''
'''--- src/util/path.ts ---
/**
 * @fileoverview Various file path utility.
 * @license Apache-2.0
 */

import {
  CharCode
} from "./text";

import {
  PATH_DELIMITER
} from "../common";

const separator = CharCode.SLASH;

/**
 * Normalizes the specified path, removing interior placeholders.
 * Expects a posix-compatible relative path (not Windows compatible).
 */
export function normalizePath(path: string): string {
  var pos = 0;
  var len = path.length;

  // trim leading './'
  while (pos + 1 < len &&
    path.charCodeAt(pos) == CharCode.DOT &&
    path.charCodeAt(pos + 1) == separator
  ) {
    pos += 2;
  }

  if (pos > 0 || len < path.length) {
    path = path.substring(pos, len);
    len -= pos;
    pos = 0;
  }

  var atEnd: bool;
  while (pos + 1 < len) {
    atEnd = false;

    // we are only interested in '/.' sequences ...
    if (
      path.charCodeAt(pos) == separator &&
      path.charCodeAt(pos + 1) == CharCode.DOT
    ) {
      // '/.' ( '/' | $ )
      atEnd = pos + 2 == len;
      if (atEnd ||
        pos + 2 < len &&
        path.charCodeAt(pos + 2) == separator
      ) {
        path = atEnd
          ? path.substring(0, pos)
          : path.substring(0, pos) + path.substring(pos + 2);
        len -= 2;
        continue;
      }

      // '/.' ( './' | '.' $ )
      atEnd = pos + 3 == len;
      if (atEnd && path.charCodeAt(pos + 2) == CharCode.DOT ||
        pos + 3 < len &&
        path.charCodeAt(pos + 2) == CharCode.DOT &&
        path.charCodeAt(pos + 3) == separator
      ) {
        // find preceeding '/'
        let ipos = pos;
        while (--ipos >= 0) {
          if (path.charCodeAt(ipos) == separator) {
            if (pos - ipos != 3 ||
              path.charCodeAt(ipos + 1) != CharCode.DOT ||
              path.charCodeAt(ipos + 2) != CharCode.DOT
            ) { // exclude '..' itself
              path = atEnd
                ? path.substring(0, ipos)
                : path.substring(0, ipos) + path.substring(pos + 3);
              len -= pos + 3 - ipos;
              pos = ipos - 1; // incremented again at end of loop
            }
            break;
          }
        }

        // if there's no preceeding '/', trim start if non-empty
        if (ipos < 0 && pos > 0) {
          if (pos != 2 ||
            path.charCodeAt(0) != CharCode.DOT ||
            path.charCodeAt(1) != CharCode.DOT
          ) { // exclude '..' itself
            path = path.substring(pos + 4);
            len = path.length;
            continue;
          }
        }
      }
    }
    pos++;
  }
  return len > 0 ? path : ".";
}

/** Resolves the specified path relative to the specified origin. */
export function resolvePath(normalizedPath: string, origin: string): string {
  if (normalizedPath.startsWith("std/")) {
    return normalizedPath;
  }
  return normalizePath(
    dirname(origin) + PATH_DELIMITER + normalizedPath
  );
}

/** Obtains the directory portion of a normalized path. */
export function dirname(normalizedPath: string): string {
  var pos = normalizedPath.length;
  if (pos <= 1) {
    if (pos == 0) return ".";
    if (normalizedPath.charCodeAt(0) == separator) {
      return normalizedPath;
    }
  }
  while (--pos > 0) {
    if (normalizedPath.charCodeAt(pos) == separator) {
      return normalizedPath.substring(0, pos);
    }
  }
  return ".";
}

'''
'''--- src/util/terminal.ts ---
/**
 * @fileoverview Terminal utility.
 * @license Apache-2.0
 */

/** Gray terminal color code. */
export const COLOR_GRAY = "\u001b[90m";
/** Red terminal color code. */
export const COLOR_RED = "\u001b[91m";
/** Green terminal color code. */
export const COLOR_GREEN = "\u001b[92m";
/** Yellow terminal color code. */
export const COLOR_YELLOW = "\u001b[93m";
/** Blue terminal color code. */
export const COLOR_BLUE = "\u001b[94m";
/** Magenta terminal color code. */
export const COLOR_MAGENTA = "\u001b[95m";
/** Cyan terminal color code. */
export const COLOR_CYAN = "\u001b[96m";
/** White terminal color code. */
export const COLOR_WHITE = "\u001b[97m";
/** Terminal color reset code. */
export const COLOR_RESET = "\u001b[0m";

/** Whether terminal colors are enabled or not. */
var colorsEnabled = true;

/** Checks whether terminal colors are enabled or not. */
export function isColorsEnabled(): bool {
  return colorsEnabled;
}

/** Sets whether terminal colors are enabled or not. */
export function setColorsEnabled(isEnabled: bool): bool {
  var wasEnabled = isEnabled;
  colorsEnabled = isEnabled;
  return wasEnabled;
}

/** Wraps the specified text in the specified terminal color code. */
export function colorize(text: string, color: string): string {
  return colorsEnabled ? color + text + COLOR_RESET : text;
}

'''
'''--- src/util/text.ts ---
/**
 * @fileoverview Various character and text utility.
 * @license Apache-2.0
 */

/** An enum of named character codes. */
export const enum CharCode {

  NULL = 0,
  LINEFEED = 0x0A,
  CARRIAGERETURN = 0x0D,
  LINESEPARATOR = 0x2028,
  PARAGRAPHSEPARATOR = 0x2029,
  NEXTLINE = 0x0085,

  SPACE = 0x20,
  NONBREAKINGSPACE = 0xA0,
  ENQUAD = 0x2000,
  EMQUAD = 0x2001,
  ENSPACE = 0x2002,
  EMSPACE = 0x2003,
  THREEPEREMSPACE = 0x2004,
  FOURPEREMSPACE = 0x2005,
  SIXPEREMSPACE = 0x2006,
  FIGURESPACE = 0x2007,
  PUNCTUATIONSPACE = 0x2008,
  THINSPACE = 0x2009,
  HAIRSPACE = 0x200A,
  ZEROWIDTHSPACE = 0x200B,
  NARROWNOBREAKSPACE = 0x202F,
  IDEOGRAPHICSPACE = 0x3000,
  MATHEMATICALSPACE = 0x205F,
  OGHAM = 0x1680,

  _ = 0x5F,

  _0 = 0x30,
  _1 = 0x31,
  _2 = 0x32,
  _3 = 0x33,
  _4 = 0x34,
  _5 = 0x35,
  _6 = 0x36,
  _7 = 0x37,
  _8 = 0x38,
  _9 = 0x39,

  a = 0x61,
  b = 0x62,
  c = 0x63,
  d = 0x64,
  e = 0x65,
  f = 0x66,
  g = 0x67,
  h = 0x68,
  i = 0x69,
  j = 0x6A,
  k = 0x6B,
  l = 0x6C,
  m = 0x6D,
  n = 0x6E,
  o = 0x6F,
  p = 0x70,
  q = 0x71,
  r = 0x72,
  s = 0x73,
  t = 0x74,
  u = 0x75,
  v = 0x76,
  w = 0x77,
  x = 0x78,
  y = 0x79,
  z = 0x7A,

  A = 0x41,
  B = 0x42,
  C = 0x43,
  D = 0x44,
  E = 0x45,
  F = 0x46,
  G = 0x47,
  H = 0x48,
  I = 0x49,
  J = 0x4A,
  K = 0x4B,
  L = 0x4C,
  M = 0x4D,
  N = 0x4E,
  O = 0x4F,
  P = 0x50,
  Q = 0x51,
  R = 0x52,
  S = 0x53,
  T = 0x54,
  U = 0x55,
  V = 0x56,
  W = 0x57,
  X = 0x58,
  Y = 0x59,
  Z = 0x5a,

  AMPERSAND = 0x26,
  ASTERISK = 0x2A,
  AT = 0x40,
  BACKSLASH = 0x5C,
  BACKTICK = 0x60,
  BAR = 0x7C,
  CARET = 0x5E,
  CLOSEBRACE = 0x7D,
  CLOSEBRACKET = 0x5D,
  CLOSEPAREN = 0x29,
  COLON = 0x3A,
  COMMA = 0x2C,
  DOLLAR = 0x24,
  DOT = 0x2E,
  DOUBLEQUOTE = 0x22,
  EQUALS = 0x3D,
  EXCLAMATION = 0x21,
  GREATERTHAN = 0x3E,
  HASH = 0x23,
  LESSTHAN = 0x3C,
  MINUS = 0x2D,
  OPENBRACE = 0x7B,
  OPENBRACKET = 0x5B,
  OPENPAREN = 0x28,
  PERCENT = 0x25,
  PLUS = 0x2B,
  QUESTION = 0x3F,
  SEMICOLON = 0x3B,
  SINGLEQUOTE = 0x27,
  SLASH = 0x2F,
  TILDE = 0x7E,

  BACKSPACE = 0x08,
  FORMFEED = 0x0C,
  BYTEORDERMARK = 0xFEFF,
  TAB = 0x09,
  VERTICALTAB = 0x0B
}

/** Tests if the specified character code is some sort of line break. */
export function isLineBreak(c: CharCode): bool {
  switch (c) {
    case CharCode.LINEFEED:
    case CharCode.CARRIAGERETURN:
    case CharCode.LINESEPARATOR:
    case CharCode.PARAGRAPHSEPARATOR: {
      return true;
    }
    default: {
      return false;
    }
  }
}

/** Tests if the specified character code is some sort of white space. */
export function isWhiteSpace(c: i32): bool {
  switch (c) {
    case CharCode.SPACE:
    case CharCode.TAB:
    case CharCode.VERTICALTAB:
    case CharCode.FORMFEED:
    case CharCode.NONBREAKINGSPACE:
    case CharCode.NEXTLINE:
    case CharCode.OGHAM:
    case CharCode.NARROWNOBREAKSPACE:
    case CharCode.MATHEMATICALSPACE:
    case CharCode.IDEOGRAPHICSPACE:
    case CharCode.BYTEORDERMARK: {
      return true;
    }
    default: {
      return c >= CharCode.ENQUAD && c <= CharCode.ZEROWIDTHSPACE;
    }
  }
}

/** Tests if the specified character code is a valid decimal digit. */
export function isDecimalDigit(c: i32): bool {
  return c >= CharCode._0 && c <= CharCode._9;
}

/** Tests if the specified character code is a valid octal digit. */
export function isOctalDigit(c: i32): bool {
  return c >= CharCode._0 && c <= CharCode._7;
}

/** Tests if the specified character code is a valid hexadecimal digit. */
export function isHexDigit(c: i32): bool {
  return isDecimalDigit(c) || ((c | 32) >= CharCode.a && (c | 32) <= CharCode.f);
}

/** Tests if the specified character code is trivially alphanumeric. */
export function isTrivialAlphanum(code: i32): bool {
  return code >= CharCode.a && code <= CharCode.z
      || code >= CharCode.A && code <= CharCode.Z
      || code >= CharCode._0 && code <= CharCode._9;
}

/** Tests if the specified character code is a valid start of an identifier. */
export function isIdentifierStart(c: i32): bool {
  let c0 = c | 32; // unify uppercases and lowercases a|A - z|Z
  return c0 >= CharCode.a && c0 <= CharCode.z
      || c == CharCode._
      || c == CharCode.DOLLAR
      || c > 0x7F && isUnicodeIdentifierStart(c);
}

/** Tests if the specified character code is a valid part of an identifier. */
export function isIdentifierPart(c: i32): bool {
  const c0 = c | 32; // unify uppercases and lowercases a|A - z|Z
  return c0 >= CharCode.a && c0 <= CharCode.z
      || c >= CharCode._0 && c <= CharCode._9
      || c == CharCode._
      || c == CharCode.DOLLAR
      || c > 0x7F && isUnicodeIdentifierPart(c);
}

// storing as u16 to save memory
const unicodeIdentifierStart: u16[] = [
  170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736,
  740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906,
  908, 908, 910, 929, 931,
  1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514,
  1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774,
  1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969,
  1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088,
  2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384,
  2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474,
  2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529,
  2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613,
  2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705,
  2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784,
  2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873,
  2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958,
  2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986,
  2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125,
  3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240,
  3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333,
  3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455,
  3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634,
  3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725,
  3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757,
  3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840,
  3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186,
  4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293,
  4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696,
  4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798,
  4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992,
  5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872,
  5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016,
  6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389,
  6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688,
  6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141,
  7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424,
  7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025,
  8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130,
  8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188,
  8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469,
  8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505,
  8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584,
  11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520,
  11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670,
  11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720,
  11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329,
  12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540,
  12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893,
  19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538,
  42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888,
  42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015,
  43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259,
  43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520,
  43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695,
  43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739,
  43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798,
  43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243,
  55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285,
  64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323,
  64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019,
  65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474,
  65479, 65482, 65487, 65490, 65495, 65498, 65500,
];
const unicodeIdentifierPart: u16[] = [
  170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736,
  740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906,
  908, 908, 910, 929, 931,
  1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415,
  1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520,
  1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788,
  1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112,
  2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423,
  2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482,
  2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525,
  2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602,
  2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632,
  2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693,
  2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757,
  2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821,
  2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884,
  2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929,
  2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972,
  2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018,
  3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088,
  3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157,
  3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216,
  3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285,
  3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340,
  3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424,
  3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515,
  3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570,
  3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720,
  3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751,
  3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789,
  3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895,
  3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028,
  4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304,
  4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744,
  4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808,
  4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108,
  5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902,
  5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099,
  6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272,
  6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516,
  6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783,
  6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155,
  7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676,
  7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027,
  8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134,
  8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205,
  8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417,
  8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477,
  8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517,
  8521, 8526, 8526, 8544, 8584,
  11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559,
  11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686,
  11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728,
  11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335,
  12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449,
  12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799,
  13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512,
  42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783,
  42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072,
  43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309,
  43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584,
  43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741,
  43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808,
  43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203,
  55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275,
  64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321,
  64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008,
  65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140,
  65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382,
  65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,
];

function lookupInUnicodeMap(code: u16, map: u16[]): bool {
  if (code < map[0]) return false;

  var lo = 0;
  var hi = map.length;
  var mid: i32;
  var midVal: u16;

  while (lo + 1 < hi) {
    mid = lo + ((hi - lo) >> 1);
    mid -= (mid & 1);
    midVal = map[mid];
    if (midVal <= code && code <= map[mid + 1]) {
      return true;
    }
    if (code < midVal) {
      hi = mid;
    } else {
      lo = mid + 2;
    }
  }
  return false;
}

function isUnicodeIdentifierStart(code: i32): bool {
  return code < 170 || code > 65500 ? false :
         lookupInUnicodeMap(code as u16, unicodeIdentifierStart);
}

function isUnicodeIdentifierPart(code: i32): bool {
  return code < 170 || code > 65500 ? false :
         lookupInUnicodeMap(code as u16, unicodeIdentifierPart);
}

const indentX1 = "  ";
const indentX2 = "    ";
const indentX4 = "        ";

/** Creates an indentation matching the number of specified levels. */
export function indent(sb: string[], level: i32): void {
  while (level >= 4) {
    sb.push(indentX4);
    level -= 4;
  }
  if (level >= 2) {
    sb.push(indentX2);
    level -= 2;
  }
  if (level) {
    sb.push(indentX1);
  }
}

'''
'''--- src/util/vector.ts ---
/**
 * @fileoverview Various vector utility.
 * @license Apache-2.0
 */

/** v128 zero constant. */
export const v128_zero = new Uint8Array(16);

'''
'''--- std/README.md ---
Standard library
================

Standard library components for use with `tsc` (portable) and `asc` (assembly).

Base configurations (.json) and definition files (.d.ts) are relevant to `tsc` only and not used by `asc`.

'''
'''--- std/assembly.json ---
{
  "extends": "../tsconfig-base.json",
  "compilerOptions": {
    "target": "esnext",
    "module": "commonjs",
    "noLib": true,
    "allowJs": false,
    "typeRoots": [ "types" ],
    "types": [ "assembly" ],
    "baseUrl": ".",
    "paths": {
      "*": [
        "./assembly/*"
      ]
    }
  }
}

'''
'''--- std/assembly/array.ts ---
/// <reference path="./rt/index.d.ts" />

import { BLOCK_MAXSIZE } from "./rt/common";
import { COMPARATOR, SORT } from "./util/sort";
import { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from "./util/string";
import { idof, isArray as builtin_isArray } from "./builtins";
import { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_ILLEGALGENTYPE, E_EMPTYARRAY, E_HOLEYARRAY } from "./util/error";

// @ts-ignore: decorator
@inline @lazy const MIN_SIZE: usize = 8;

/** Ensures that the given array has _at least_ the specified backing size. */
function ensureCapacity(array: usize, newSize: usize, alignLog2: u32, canGrow: bool = true): void {
  // Depends on the fact that Arrays mimic ArrayBufferView
  var oldCapacity = <usize>changetype<ArrayBufferView>(array).byteLength;
  if (newSize > oldCapacity >>> alignLog2) {
    if (newSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);
    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).buffer);
    // Grows old capacity by factor of two.
    // Make sure we don't reach BLOCK_MAXSIZE for new growed capacity.
    let newCapacity = max(newSize, MIN_SIZE) << alignLog2;
    if (canGrow) newCapacity = max(min(oldCapacity << 1, BLOCK_MAXSIZE), newCapacity);
    let newData = __renew(oldData, newCapacity);
    memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);
    if (newData !== oldData) { // oldData has been free'd
      store<usize>(array, newData, offsetof<ArrayBufferView>("buffer"));
      store<usize>(array, newData, offsetof<ArrayBufferView>("dataStart"));
      __link(array, changetype<usize>(newData), false);
    }
    store<u32>(array, <u32>newCapacity, offsetof<ArrayBufferView>("byteLength"));
  }
}

export class Array<T> {
  [key: number]: T;

  // Mimicking ArrayBufferView isn't strictly necessary here but is done to allow glue code
  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need
  // `dataStart` (equals `buffer`) and `byteLength` (equals computed `buffer.byteLength`), but the
  // block is 16 bytes anyway so it's fine to have a couple extra fields in there.

  private buffer: ArrayBuffer;
  @unsafe readonly dataStart: usize;
  private byteLength: i32; // Uses here as capacity

  // Also note that Array<T> with non-nullable T must guard against uninitialized null values
  // whenever an element is accessed. Otherwise, the compiler wouldn't be able to guarantee
  // type-safety anymore. For lack of a better word, such an array is "holey".

  private length_: i32;

  static isArray<U>(value: U): bool {
    return isReference<U>() ? builtin_isArray(value) && value !== null : false;
  }

  static create<T>(capacity: i32 = 0): Array<T> {
    WARNING("'Array.create' is deprecated. Use 'new Array' instead, making sure initial elements are initialized.");
    var array = new Array<T>(capacity);
    array.length = 0;
    return array;
  }

  constructor(length: i32 = 0) {
    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);
    // reserve capacity for at least MIN_SIZE elements
    var bufferSize = max(<usize>length, MIN_SIZE) << alignof<T>();
    var buffer = changetype<ArrayBuffer>(__new(bufferSize, idof<ArrayBuffer>()));
    memory.fill(changetype<usize>(buffer), 0, bufferSize);
    this.buffer = buffer; // links
    this.dataStart = changetype<usize>(buffer);
    this.byteLength = <i32>bufferSize;
    this.length_ = length;
  }

  get length(): i32 {
    return this.length_;
  }

  set length(newLength: i32) {
    ensureCapacity(changetype<usize>(this), newLength, alignof<T>(), false);
    this.length_ = newLength;
  }

  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {
    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {
      if (!fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return false;
    }
    return true;
  }

  findIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {
    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {
      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;
    }
    return -1;
  }

  findLastIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {
    for (let i = this.length_ - 1; i >= 0; --i) {
      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;
    }
    return -1;
  }

  @operator("[]") private __get(index: i32): T {
    if (<u32>index >= <u32>this.length_) throw new RangeError(E_INDEXOUTOFRANGE);
    var value = load<T>(this.dataStart + (<usize>index << alignof<T>()));
    if (isReference<T>()) {
      if (!isNullable<T>()) {
        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);
      }
    }
    return value;
  }

  @unsafe @operator("{}") private __uget(index: i32): T {
    return load<T>(this.dataStart + (<usize>index << alignof<T>()));
  }

  @operator("[]=") private __set(index: i32, value: T): void {
    if (<u32>index >= <u32>this.length_) {
      if (index < 0) throw new RangeError(E_INDEXOUTOFRANGE);
      ensureCapacity(changetype<usize>(this), index + 1, alignof<T>());
      this.length_ = index + 1;
    }
    this.__uset(index, value);
  }

  @unsafe @operator("{}=") private __uset(index: i32, value: T): void {
    store<T>(this.dataStart + (<usize>index << alignof<T>()), value);
    if (isManaged<T>()) {
      __link(changetype<usize>(this), changetype<usize>(value), true);
    }
  }

  at(index: i32): T {
    var len = this.length_;
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    var value = load<T>(this.dataStart + (<usize>index << alignof<T>()));
    if (isReference<T>()) {
      if (!isNullable<T>()) {
        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);
      }
    }
    return value;
  }

  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {
    var ptr = this.dataStart;
    var len = this.length_;
    start = start < 0 ? max(len + start, 0) : min(start, len);
    end   = end   < 0 ? max(len + end,   0) : min(end,   len);
    if (isManaged<T>()) {
      for (; start < end; ++start) {
        store<usize>(ptr + (<usize>start << alignof<T>()), changetype<usize>(value));
        __link(changetype<usize>(this), changetype<usize>(value), true);
      }
    } else if (sizeof<T>() == 1) {
      if (start < end) {
        memory.fill(
          ptr + <usize>start,
          u8(value),
          <usize>(end - start)
        );
      }
    } else {
      for (; start < end; ++start) {
        store<T>(ptr + (<usize>start << alignof<T>()), value);
      }
    }
    return this;
  }

  includes(value: T, fromIndex: i32 = 0): bool {
    if (isFloat<T>()) {
      let len = this.length_;
      if (len == 0 || fromIndex >= len) return false;
      if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);
      let ptr = this.dataStart;
      while (fromIndex < len) {
        let elem = load<T>(ptr + (<usize>fromIndex << alignof<T>()));
        // @ts-ignore
        if (elem == value || isNaN(elem) & isNaN(value)) return true;
        ++fromIndex;
      }
      return false;
    } else {
      return this.indexOf(value, fromIndex) >= 0;
    }
  }

  indexOf(value: T, fromIndex: i32 = 0): i32 {
    var len = this.length_;
    if (len == 0 || fromIndex >= len) return -1;
    if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);
    var ptr = this.dataStart;
    while (fromIndex < len) {
      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;
      ++fromIndex;
    }
    return -1;
  }

  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {
    var len = this.length_;
    if (len == 0) return -1;
    if (fromIndex < 0) fromIndex = len + fromIndex;
    else if (fromIndex >= len) fromIndex = len - 1;
    var ptr = this.dataStart;
    while (fromIndex >= 0) {
      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;
      --fromIndex;
    }
    return -1;
  }

  push(value: T): i32 {
    var oldLen = this.length_;
    var len = oldLen + 1;
    ensureCapacity(changetype<usize>(this), len, alignof<T>());
    if (isManaged<T>()) {
      store<usize>(this.dataStart + (<usize>oldLen << alignof<T>()), changetype<usize>(value));
      __link(changetype<usize>(this), changetype<usize>(value), true);
    } else {
      store<T>(this.dataStart + (<usize>oldLen << alignof<T>()), value);
    }
    this.length_ = len;
    return len;
  }

  concat(other: Array<T>): Array<T> {
    var thisLen = this.length_;
    var otherLen = select(0, other.length_, other === null);
    var outLen = thisLen + otherLen;
    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);
    var out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));
    var outStart = out.dataStart;
    var thisSize = <usize>thisLen << alignof<T>();
    if (isManaged<T>()) {
      let thisStart = this.dataStart;
      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {
        let ref = load<usize>(thisStart + offset);
        store<usize>(outStart + offset, ref);
        __link(changetype<usize>(out), ref, true);
      }
      outStart += thisSize;
      let otherStart = other.dataStart;
      let otherSize = <usize>otherLen << alignof<T>();
      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {
        let ref = load<usize>(otherStart + offset);
        store<usize>(outStart + offset, ref);
        __link(changetype<usize>(out), ref, true);
      }
    } else {
      memory.copy(outStart, this.dataStart, thisSize);
      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());
    }
    return out;
  }

  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {
    var ptr = this.dataStart;
    var len = this.length_;

    end = min<i32>(end, len);

    var to    = target < 0 ? max(len + target, 0) : min(target, len);
    var from  = start < 0 ? max(len + start, 0) : min(start, len);
    var last  = end < 0 ? max(len + end, 0) : min(end, len);
    var count = min(last - from, len - to);

    memory.copy( // is memmove
      ptr + (<usize>to << alignof<T>()),
      ptr + (<usize>from << alignof<T>()),
      <usize>count << alignof<T>()
    );
    return this;
  }

  pop(): T {
    var len = this.length_;
    if (len < 1) throw new RangeError(E_EMPTYARRAY);
    var val = load<T>(this.dataStart + (<usize>(--len) << alignof<T>()));
    this.length_ = len;
    return val;
  }

  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {
    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {
      fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);
    }
  }

  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {
    var len = this.length_;
    var out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));
    var outStart = out.dataStart;
    for (let i = 0; i < min(len, this.length_); ++i) {
      let result = fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);
      store<U>(outStart + (<usize>i << alignof<U>()), result);
      if (isManaged<U>()) {
        __link(changetype<usize>(out), changetype<usize>(result), true);
      }
    }
    return out;
  }

  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {
    var result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));
    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {
      let value = load<T>(this.dataStart + (<usize>i << alignof<T>()));
      if (fn(value, i, this)) result.push(value);
    }
    return result;
  }

  reduce<U>(
    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,
    initialValue: U
  ): U {
    var acc = initialValue;
    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {
      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);
    }
    return acc;
  }

  reduceRight<U>(
    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,
    initialValue: U
  ): U {
    var acc = initialValue;
    for (let i = this.length_ - 1; i >= 0; --i) {
      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);
    }
    return acc;
  }

  shift(): T {
    var len = this.length_;
    if (len < 1) throw new RangeError(E_EMPTYARRAY);
    var base = this.dataStart;
    var element = load<T>(base);
    var lastIndex = len - 1;
    memory.copy(
      base,
      base + sizeof<T>(),
      <usize>lastIndex << alignof<T>()
    );
    if (isReference<T>()) {
      store<usize>(base + (<usize>lastIndex << alignof<T>()), 0);
    } else {
      // @ts-ignore
      store<T>(base + (<usize>lastIndex << alignof<T>()), <T>0);
    }
    this.length_ = lastIndex;
    return element;
  }

  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {
    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {
      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return true;
    }
    return false;
  }

  unshift(value: T): i32 {
    var len = this.length_ + 1;
    ensureCapacity(changetype<usize>(this), len, alignof<T>());
    var ptr = this.dataStart;
    memory.copy(
      ptr + sizeof<T>(),
      ptr,
      <usize>(len - 1) << alignof<T>()
    );
    store<T>(ptr, value);
    if (isManaged<T>()) {
      __link(changetype<usize>(this), changetype<usize>(value), true);
    }
    this.length_ = len;
    return len;
  }

  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {
    var len = this.length_;
    start = start < 0 ? max(start + len, 0) : min(start, len);
    end   = end   < 0 ? max(end   + len, 0) : min(end  , len);
    len = max(end - start, 0);
    var slice = changetype<Array<T>>(__newArray(len, alignof<T>(), idof<Array<T>>()));
    var sliceBase = slice.dataStart;
    var thisBase = this.dataStart + (<usize>start << alignof<T>());
    if (isManaged<T>()) {
      let off = <usize>0;
      let end = <usize>len << alignof<usize>();
      while (off < end) {
        let ref = load<usize>(thisBase + off);
        store<usize>(sliceBase + off, ref);
        __link(changetype<usize>(slice), ref, true);
        off += sizeof<usize>();
      }
    } else {
      memory.copy(sliceBase, thisBase, len << alignof<T>());
    }
    return slice;
  }

  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {
    var len = this.length_;
    start       = start < 0 ? max<i32>(len + start, 0) : min<i32>(start, len);
    deleteCount = max<i32>(min<i32>(deleteCount, len - start), 0);
    var result  = changetype<Array<T>>(__newArray(deleteCount, alignof<T>(), idof<Array<T>>()));
    var resultStart = result.dataStart;
    var thisStart = this.dataStart;
    var thisBase  = thisStart + (<usize>start << alignof<T>());
    memory.copy(
      resultStart,
      thisBase,
      <usize>deleteCount << alignof<T>()
    );
    var offset = start + deleteCount;
    if (len != offset) {
      memory.copy(
        thisBase,
        thisStart + (<usize>offset << alignof<T>()),
        <usize>(len - offset) << alignof<T>()
      );
    }
    this.length_ = len - deleteCount;
    return result;
  }

  reverse(): Array<T> {
    var len = this.length_;
    if (len) {
      let front = this.dataStart;
      let back = this.dataStart + (<usize>(len - 1) << alignof<T>());
      while (front < back) {
        let temp = load<T>(front);
        store<T>(front, load<T>(back));
        store<T>(back, temp);
        front += sizeof<T>();
        back -= sizeof<T>();
      }
    }
    return this;
  }

  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {
    SORT<T>(this.dataStart, this.length_, comparator);
    return this;
  }

  join(separator: string = ","): string {
    var ptr = this.dataStart;
    var len = this.length_;
    if (isBoolean<T>())   return joinBooleanArray(ptr, len, separator);
    if (isInteger<T>())   return joinIntegerArray<T>(ptr, len, separator);
    if (isFloat<T>())     return joinFloatArray<T>(ptr, len, separator);

    if (ASC_SHRINK_LEVEL < 1) {
      if (isString<T>())  return joinStringArray(ptr, len, separator);
    }
    // For rest objects and arrays use general join routine
    if (isReference<T>()) return joinReferenceArray<T>(ptr, len, separator);
    ERROR("unspported element type");
    return <string>unreachable();
  }

  flat(): T {
    if (!isArray<T>()) {
      throw new TypeError(E_ILLEGALGENTYPE);
    }
    // Get the length and data start values
    var ptr = this.dataStart;
    var len = this.length_;

    // calculate the end size with an initial pass
    var size = 0;
    for (let i = 0; i < len; ++i) {
      let child = load<usize>(ptr + (i << alignof<T>()));
      size += child == 0 ? 0 : load<i32>(child, offsetof<T>("length_"));
    }

    // calculate the byteLength of the resulting backing ArrayBuffer
    var byteLength = <usize>size << usize(alignof<valueof<T>>());
    var outBuffer = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));

    // create the return value and initialize it
    var outArray = changetype<T>(__new(offsetof<T>(), idof<T>()));
    store<i32>(changetype<usize>(outArray), size, offsetof<T>("length_"));

    // byteLength, dataStart, and buffer are all readonly
    store<i32>(changetype<usize>(outArray), byteLength, offsetof<T>("byteLength"));
    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>("dataStart"));
    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>("buffer"));
    __link(changetype<usize>(outArray), changetype<usize>(outBuffer), false);

    // set the elements
    var resultOffset: usize = 0;
    for (let i = 0; i < len; ++i) { // for each child
      let child = load<usize>(ptr + (<usize>i << alignof<T>()));

      // ignore null arrays
      if (child == 0) continue;

      // copy the underlying buffer data to the result buffer
      let childDataLength = load<i32>(child, offsetof<T>("byteLength"));
      memory.copy(
        changetype<usize>(outBuffer) + resultOffset,
        load<usize>(child, offsetof<T>("dataStart")),
        <usize>childDataLength
      );

      // advance the result length
      resultOffset += childDataLength;
    }

    // if the `valueof<T>` type is managed, we must link each reference
    if (isManaged<valueof<T>>()) {
      for (let i = 0; i < size; ++i) {
        let ref = load<usize>(changetype<usize>(outBuffer) + (<usize>i << usize(alignof<valueof<T>>())));
        __link(changetype<usize>(outBuffer), ref, true);
      }
    }

    return outArray;
  }

  toString(): string {
    return this.join();
  }

  // RT integration

  @unsafe private __visit(cookie: u32): void {
    if (isManaged<T>()) {
      let cur = this.dataStart;
      let end = cur + (<usize>this.length_ << alignof<T>());
      while (cur < end) {
        let val = load<usize>(cur);
        if (val) __visit(val, cookie);
        cur += sizeof<usize>();
      }
    }
    __visit(changetype<usize>(this.buffer), cookie);
  }
}

'''
'''--- std/assembly/arraybuffer.ts ---
/// <reference path="./rt/index.d.ts" />

import { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from "./rt/common";
import { idof } from "./builtins";
import { E_INVALIDLENGTH } from "./util/error";

export abstract class ArrayBufferView {

  readonly buffer: ArrayBuffer;
  @unsafe readonly dataStart: usize;
  readonly byteLength: i32;

  get byteOffset(): i32 {
    return <i32>(this.dataStart - changetype<usize>(this.buffer));
  }

  protected constructor(length: i32, alignLog2: i32) {
    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);
    var buffer = changetype<ArrayBuffer>(__new(length = length << alignLog2, idof<ArrayBuffer>()));
    memory.fill(changetype<usize>(buffer), 0, <usize>length);
    this.buffer = buffer; // links
    this.dataStart = changetype<usize>(buffer);
    this.byteLength = length;
  }
}

@final export class ArrayBuffer {

  static isView<T>(value: T): bool {
    if (isNullable<T>()) {
      if (value === null) return false;
    }
    if (value instanceof Int8Array) return true;
    if (value instanceof Uint8Array) return true;
    if (value instanceof Uint8ClampedArray) return true;
    if (value instanceof Int16Array) return true;
    if (value instanceof Uint16Array) return true;
    if (value instanceof Int32Array) return true;
    if (value instanceof Uint32Array) return true;
    if (value instanceof Int64Array) return true;
    if (value instanceof Uint64Array) return true;
    if (value instanceof Float32Array) return true;
    if (value instanceof Float64Array) return true;
    if (value instanceof DataView) return true;
    return false;
  }

  constructor(length: i32) {
    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);
    var buffer = changetype<ArrayBuffer>(__new(<usize>length, idof<ArrayBuffer>()));
    memory.fill(changetype<usize>(buffer), 0, <usize>length);
    return buffer;
  }

  get byteLength(): i32 {
    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;
  }

  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {
    var length = this.byteLength;
    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);
    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);
    var outSize = <usize>max(end - begin, 0);
    var out = changetype<ArrayBuffer>(__new(outSize, idof<ArrayBuffer>()));
    memory.copy(changetype<usize>(out), changetype<usize>(this) + <usize>begin, outSize);
    return out;
  }

  toString(): string {
    return "[object ArrayBuffer]";
  }
}

'''
'''--- std/assembly/atomics.ts ---
import { ArrayBufferView } from "./arraybuffer";
import { E_INDEXOUTOFRANGE } from "./util/error";

export namespace Atomics {

  // @ts-ignore: decorator
  @inline
  export function load<T extends ArrayBufferView>(array: T, index: i32): valueof<T> {
    const align = alignof<valueof<T>>();
    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return atomic.load<valueof<T>>(
      changetype<usize>(array.buffer) + (index << align) + array.byteOffset
    );
  }

  // @ts-ignore: decorator
  @inline
  export function store<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): void {
    const align = alignof<valueof<T>>();
    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    atomic.store<valueof<T>>(
      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,
      value
    );
  }

  // @ts-ignore: decorator
  @inline
  export function add<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {
    const align = alignof<valueof<T>>();
    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return atomic.add<valueof<T>>(
      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,
      value
    );
  }

  // @ts-ignore: decorator
  @inline
  export function sub<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {
    const align = alignof<valueof<T>>();
    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return atomic.sub<valueof<T>>(
      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,
      value
    );
  }

  // @ts-ignore: decorator
  @inline
  export function and<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {
    const align = alignof<valueof<T>>();
    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return atomic.and<valueof<T>>(
      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,
      value
    );
  }

  // @ts-ignore: decorator
  @inline
  export function or<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {
    const align = alignof<valueof<T>>();
    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return atomic.or<valueof<T>>(
      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,
      value
    );
  }

  // @ts-ignore: decorator
  @inline
  export function xor<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {
    const align = alignof<valueof<T>>();
    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return atomic.xor<valueof<T>>(
      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,
      value
    );
  }

  // @ts-ignore: decorator
  @inline
  export function exchange<T extends ArrayBufferView>(array: T, index: i32, value: valueof<T>): valueof<T> {
    const align = alignof<valueof<T>>();
    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return atomic.xchg<valueof<T>>(
      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,
      value
    );
  }

  // @ts-ignore: decorator
  @inline
  export function compareExchange<T extends ArrayBufferView>(
    array: T,
    index: i32,
    expectedValue: valueof<T>,
    replacementValue: valueof<T>
  ): valueof<T> {
    const align = alignof<valueof<T>>();
    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return atomic.cmpxchg<valueof<T>>(
      changetype<usize>(array.buffer) + (index << align) + array.byteOffset,
      expectedValue,
      replacementValue
    );
  }

  // @ts-ignore: decorator
  @inline
  export function wait<T extends ArrayBufferView>(array: T, value: valueof<T>, timeout: i64 = -1): AtomicWaitResult {
    return atomic.wait<valueof<T>>(changetype<usize>(array.buffer) + array.byteOffset, value, timeout);
  }

  // @ts-ignore: decorator
  @inline
  export function notify<T extends ArrayBufferView>(array: T, index: i32, count: i32 = -1): i32 {
    const align = alignof<valueof<T>>();
    if (index < 0 || (index << align) >= array.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return atomic.notify(changetype<usize>(array.buffer) + (index << align) + array.byteOffset, count);
  }

  export function isLockFree(size: usize): bool {
    return size == 1 || size == 2 || size == 4;
  }
}

'''
'''--- std/assembly/bindings/Date.ts ---
export declare function now(): f64;

'''
'''--- std/assembly/bindings/Math.ts ---
export declare const E: f64;
export declare const LN2: f64;
export declare const LN10: f64;
export declare const LOG2E: f64;
export declare const LOG10E: f64;
export declare const PI: f64;
export declare const SQRT1_2: f64;
export declare const SQRT2: f64;

export declare function abs(x: f64): f64;
export declare function acos(x: f64): f64;
export declare function acosh(x: f64): f64;
export declare function asin(x: f64): f64;
export declare function asinh(x: f64): f64;
export declare function atan(x: f64): f64;
export declare function atan2(y: f64, x: f64): f64;
export declare function atanh(x: f64): f64;
export declare function cbrt(x: f64): f64;
export declare function ceil(x: f64): f64;
export declare function clz32(x: f64): f64;
export declare function cos(x: f64): f64;
export declare function cosh(x: f64): f64;
export declare function exp(x: f64): f64;
export declare function expm1(x: f64): f64;
export declare function floor(x: f64): f64;
export declare function fround(x: f64): f32;
export declare function hypot(value1: f64, value2: f64): f64; // TODO: rest
export declare function imul(a: f64, b: f64): f64;
export declare function log(x: f64): f64;
export declare function log10(x: f64): f64;
export declare function log1p(x: f64): f64;
export declare function log2(x: f64): f64;
export declare function max(value1: f64, value2: f64): f64; // TODO: rest
export declare function min(value1: f64, value2: f64): f64; // TODO: rest
export declare function pow(base: f64, exponent: f64): f64;
export declare function random(): f64;
export declare function round(x: f64): f64;
export declare function sign(x: f64): f64;
export declare function sin(x: f64): f64;
export declare function sinh(x: f64): f64;
export declare function sqrt(x: f64): f64;
export declare function tan(x: f64): f64;
export declare function tanh(x: f64): f64;
export declare function trunc(x: f64): f64;

'''
'''--- std/assembly/bindings/Reflect.ts ---
export declare function get(target: externref, propertyKey: externref/* , receiver: externref */): externref;
export declare function has(target: externref, propertyKey: externref): bool;
export declare function set(target: externref, propertyKey: externref, value: externref/* , receiver: externref */): externref;
export declare function apply(target: externref, thisArgument: externref, argumentsList: externref): externref;

'''
'''--- std/assembly/bindings/asyncify.ts ---
@unmanaged
export class StackDescriptor {
  /** The index in linear memory of the start of the â€œasyncify stackâ€. */
  stackStart: usize;
  /** The index of the end of that stack region, which implies how big it is. */
  stackEnd: usize;
}

/** Starts to unwind the call stack. */
export declare function start_unwind(data: StackDescriptor): void;
/** Stops unwinding the call stack. */
export declare function stop_unwind(): void;
/** Starts to rewind the call stack. */
export declare function start_rewind(data: StackDescriptor): void;
/** Stops rewinding the call stack. */
export declare function stop_rewind(): void;

'''
'''--- std/assembly/bindings/console.ts ---
export declare function assert(value: externref): void;
export declare function clear(): void;
export declare function error(value: externref): void;
export declare function info(value: externref): void;
export declare function log(value: externref): void;
export declare function time(label: externref): externref;
export declare function timeEnd(label: externref): void;
export declare function timeLog(label: externref): void;
export declare function trace(): void;
export declare function warn(value: externref): void;

'''
'''--- std/assembly/bindings/wasi.ts ---
export * from "./wasi_snapshot_preview1";

'''
'''--- std/assembly/bindings/wasi_snapshot_preview1.ts ---
// Phase: wasi_snapshot_preview1
// See: https://github.com/WebAssembly/WASI/tree/main/phases/snapshot/witx

// helper types to be more explicit
type char = u8;
type ptr<T> = usize; // all pointers are usize'd
type struct<T> = T;  // structs are references already in AS

/** Read command-line argument data. */
// @ts-ignore: decorator
@unsafe
export declare function args_get(
  /** Input: Pointer to a buffer to write the argument pointers. */
  argv: ptr<ptr<char>>,
  /** Input: Pointer to a buffer to write the argument string data. */
  argv_buf: ptr<char>
): errno;

/** Return command-line argument data sizes. */
// @ts-ignore: decorator
@unsafe
export declare function args_sizes_get(
  /** Output: Number of arguments. */
  argc: ptr<usize>,
  /** Output: Size of the argument string data. */
  argv_buf_size: ptr<usize>
): errno;

/** Return the resolution of a clock. */
// @ts-ignore: decorator
@unsafe
export declare function clock_res_get(
  /** Input: The clock for which to return the resolution. */
  clock: clockid,
  /** Output: The resolution of the clock. */
  resolution: ptr<timestamp>
): errno;

/** Return the time value of a clock. */
// @ts-ignore: decorator
@unsafe
export declare function clock_time_get(
  /** Input: Cock for which to return the time. */
  clock: clockid,
  /** Input: Maximum lag (exclusive) that the returned time value may have, compared to its actual value. */
  precision: timestamp,
  /** Output: Time value of the clock. */
  time: ptr<timestamp>
): errno;

/** Read environment variable data. */
// @ts-ignore: decorator
@unsafe
export declare function environ_get(
  /** Input: Pointer to a buffer to write the environment variable pointers. */
  environ: ptr<usize>,
  /** Input: Pointer to a buffer to write the environment variable string data. */
  environ_buf: usize
): errno;

/** Return command-line argument data sizes. */
// @ts-ignore: decorator
@unsafe
export declare function environ_sizes_get(
  /** Output: The number of environment variables. */
  environ_count: ptr<usize>,
  /** Output: The size of the environment variable string data. */
  environ_buf_size: ptr<usize>
): errno;

/** Provide file advisory information on a file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_advise(
  /** Input: The file descriptor for the file for which to provide file advisory information. */
  fd: fd,
  /** Input: The offset within the file to which the advisory applies. */
  offset: filesize,
  /** Input: The length of the region to which the advisory applies. */
  len: filesize,
  /** Input: The advice. */
  advice: advice
): errno;

/** Provide file advisory information on a file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_allocate(
  /** Input: The file descriptor for the file in which to allocate space. */
  fd: fd,
  /** Input: The offset at which to start the allocation. */
  offset: filesize,
  /** Input: The length of the area that is allocated. */
  len: filesize
): errno;

/** Close a file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_close(
  /** Input: The file descriptor to close. */
  fd: fd
): errno;

/** Synchronize the data of a file to disk. */
// @ts-ignore: decorator
@unsafe
export declare function fd_datasync(
  /** Input: The file descriptor of the file to synchronize to disk. */
  fd: fd
): errno;

/** Get the attributes of a file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_fdstat_get(
  /** Input: The file descriptor to inspect. */
  fd: fd,
  /** Input: The buffer where the file descriptor's attributes are stored. */
  buf: struct<fdstat>
): errno;

/** Adjust the flags associated with a file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_fdstat_set_flags(
  /** Input: The file descriptor to operate on. */
  fd: fd,
  /** Input: The desired values of the file descriptor flags. */
  flags: fdflags
): errno;

/** Adjust the rights associated with a file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_fdstat_set_rights(
  /** Input: The file descriptor to operate on. */
  fd: fd,
  /** Input: The desired rights of the file descriptor. */
  fs_rights_base: rights,
  /** Input: The desired rights of the file descriptor. */
  fs_rights_inheriting: rights
): errno;

/** Return the attributes of an open file. */
// @ts-ignore: decorator
@unsafe
export declare function fd_filestat_get(
  /** Input: The file descriptor to inspect. */
  fd: fd,
  /** Input: The buffer where the file's attributes are stored. */
  buf: struct<filestat>
): errno;

/** Adjust the size of an open file. If this increases the file's size, the extra bytes are filled with zeros. */
// @ts-ignore: decorator
@unsafe
export declare function fd_filestat_set_size(
  /** Input: A file descriptor for the file to adjust. */
  fd: fd,
  /** Input: The desired file size. */
  size: filesize
): errno;

/** Adjust the timestamps of an open file or directory. */
// @ts-ignore: decorator
@unsafe
export declare function fd_filestat_set_times(
  /** Input: The file descriptor to operate on. */
  fd: fd,
  /** Input: The desired values of the data access timestamp. */
  st_atim: timestamp,
  /** Input: The desired values of the data modification timestamp. */
  st_mtim: timestamp,
  /** Input: A bitmask indicating which timestamps to adjust. */
  fstflags: fstflags
): errno;

/** Read from a file descriptor, without using and updating the file descriptor's offset. */
// @ts-ignore: decorator
@unsafe
export declare function fd_pread(
  /** Input: The file descriptor from which to read data. */
  fd: fd,
  /** Input: List of scatter/gather vectors in which to store data. */
  iovs: ptr<struct<iovec>>,
  /** Input: Length of the list of scatter/gather vectors in which to store data. */
  iovs_len: usize,
  /** Input: The offset within the file at which to read. */
  offset: filesize,
  /** Output: The number of bytes read. */
  nread: ptr<usize>
): errno;

/** Return a description of the given preopened file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_prestat_get(
  /** Input: The file descriptor about which to retrieve information. */
  fd: fd,
  /** Input: The buffer where the description is stored. */
  buf: struct<prestat>
): errno;

/** Return a description of the given preopened file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_prestat_dir_name(
  /** Input: The file descriptor about which to retrieve information. */
  fd: fd,
  /** Input: Buffer into which to write the preopened directory name. */
  path: ptr<char>,
  /** Input: Length of the buffer into which to write the preopened directory name. */
  path_len: usize
): errno;

/** Write to a file descriptor, without using and updating the file descriptor's offset. */
// @ts-ignore: decorator
@unsafe
export declare function fd_pwrite(
  /** Input: The file descriptor to which to write data. */
  fd: fd,
  /** Input: List of scatter/gather vectors from which to retrieve data. */
  iovs: ptr<struct<iovec>>,
  /** Input: Length of the list of scatter/gather vectors from which to retrieve data. */
  iovs_len: usize,
  /** Input: The offset within the file at which to write. */
  offset: filesize,
  /** Output: The number of bytes written. */
  nwritten: ptr<usize>
): errno;

/** Read from a file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_read(
  /** Input: The file descriptor from which to read data. */
  fd: fd,
  /** Input: List of scatter/gather vectors to which to store data. */
  iovs: ptr<struct<iovec>>,
  /** Input: Length of the list of scatter/gather vectors to which to store data. */
  iovs_len: usize,
  /** Output: The number of bytes read. */
  nread: ptr<usize>
): errno;

/** Read directory entries from a directory. */
// @ts-ignore: decorator
@unsafe
export declare function fd_readdir(
  /** Input: Directory from which to read the directory entries. */
  fd: fd,
  /** Input: Buffer where directory entries are stored. */
  buf: ptr<struct<dirent>>,
  /** Input: Length of the buffer where directory entries are stored. */
  buf_len: usize,
  /** Input: Location within the directory to start reading. */
  cookie: dircookie,
  /** Output: Number of bytes stored in the read buffer. If less than the size of the read buffer, the end of the directory has been reached. */
  buf_used: ptr<usize>
): errno;

/** Atomically replace a file descriptor by renumbering another file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_renumber(
  /** Input: The file descriptor to renumber. */
  from: fd,
  /** Input: The file descriptor to overwrite. */
  to: fd
): errno;

/** Move the offset of a file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_seek(
  /** Input: The file descriptor to operate on. */
  fd: fd,
  /** Input: The number of bytes to move. */
  offset: filedelta,
  /** Input: The base from which the offset is relative. */
  whence: whence,
  /** Output: The new offset of the file descriptor, relative to the start of the file. */
  newoffset: ptr<filesize>
): errno;

/** Synchronize the data and metadata of a file to disk. */
// @ts-ignore: decorator
@unsafe
export declare function fd_sync(
  /** Input: The file descriptor of the file containing the data and metadata to synchronize to disk. */
  fd: fd
): errno;

/** Return the current offset of a file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_tell(
  /** Input: The file descriptor to inspect. */
  fd: fd,
  /** Output: The current offset of the file descriptor, relative to the start of the file. */
  newoffset: ptr<filesize>
): errno;

/** Write to a file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_write(
  /** Input: The file descriptor to which to write data. */
  fd: fd,
  /** Input: List of scatter/gather vectors from which to retrieve data. */
  iovs: ptr<struct<iovec>>,
  /** Input: List of scatter/gather vectors from which to retrieve data. */
  iovs_len: usize,
  /** Output: The number of bytes written. */
  nwritten: ptr<usize>
): errno;

/* Create a directory. */
// @ts-ignore: decorator
@unsafe
export declare function path_create_directory(
  /** Input: The working directory at which the resolution of the path starts. */
  fd: fd,
  /** Input: The path at which to create the directory. */
  path: ptr<char>,
  /** Input: The path at which to create the directory. */
  path_len: usize
): errno;

/** Return the attributes of a file or directory. */
// @ts-ignore: decorator
@unsafe
export declare function path_filestat_get(
  /** Input: The working directory at which the resolution of the path starts. */
  fd: fd,
  /** Input: Flags determining the method of how the path is resolved. */
  flags: lookupflags,
  /** Input: The path of the file or directory to inspect. */
  path: ptr<char>,
  /** Input: The path of the file or directory to inspect. */
  path_len: usize,
  /** Input: The buffer where the file's attributes are stored. */
  buf: struct<filestat>
): errno;

/** Adjust the timestamps of a file or directory. */
// @ts-ignore: decorator
@unsafe
export declare function path_filestat_set_times(
  /** Input: The working directory at which the resolution of the path starts. */
  fd: fd,
  /** Input: Flags determining the method of how the path is resolved. */
  flags: lookupflags,
  /** Input: The path of the file or directory to operate on. */
  path: ptr<char>,
  /** Input: The path of the file or directory to operate on. */
  path_len: usize,
  /** Input: The desired values of the data access timestamp. */
  st_atim: timestamp,
  /** Input: The desired values of the data modification timestamp. */
  st_mtim: timestamp,
  /** Input: A bitmask indicating which timestamps to adjust. */
  fstflags: fstflags
): errno;

/** Create a hard link. */
// @ts-ignore: decorator
@unsafe
export declare function path_link(
  /** Input: The working directory at which the resolution of the old path starts. */
  old_fd: fd,
  /** Input: Flags determining the method of how the path is resolved. */
  old_flags: lookupflags,
  /** Input: The source path from which to link. */
  old_path: ptr<char>,
  /** Input: The source path from which to link. */
  old_path_len: usize,
  /** Input: The working directory at which the resolution of the new path starts. */
  new_fd: fd,
  /** Input: The destination path at which to create the hard link. */
  new_path: ptr<char>,
  /** Input: The length of the destination path at which to create the hard link. */
  new_path_len: usize
): errno;

/** Open a file or directory. */
// @ts-ignore: decorator
@unsafe
export declare function path_open(
  /** Input: The working directory at which the resolution of the path starts. */
  dirfd: fd,
  /** Input: Flags determining the method of how the path is resolved. */
  dirflags: lookupflags,
  /** Input: The path of the file or directory to open. */
  path: ptr<char>,
  /** Input: The length of the path of the file or directory to open. */
  path_len: usize,
  /** Input: The method by which to open the file. */
  oflags: oflags,
  /** Input: The initial base rights that apply to operations using the file descriptor itself. */
  fs_rights_base: rights,
  /** Input: The initial inheriting rights that apply to file descriptors derived from it. */
  fs_rights_inheriting: rights,
  /** Input: The initial flags of the file descriptor. */
  fs_flags: fdflags,
  /** Output: The file descriptor of the file that has been opened. */
  fd: ptr<fd>
): errno;

/** Read the contents of a symbolic link. */
// @ts-ignore: decorator
@unsafe
export declare function path_readlink(
  /** Input: The working directory at which the resolution of the path starts. */
  fd: fd,
  /** Input: The path of the symbolic link from which to read. */
  path: ptr<char>,
  /** Input: The length of the path of the symbolic link from which to read. */
  path_len: usize,
  /** Input: The buffer to which to write the contents of the symbolic link. */
  buf: ptr<char>,
  /** Input: The length of the buffer to which to write the contents of the symbolic link. */
  buf_len: usize,
  /** Output: The number of bytes placed in the buffer. */
  buf_used: ptr<usize>
): errno;

/** Remove a directory. */
// @ts-ignore: decorator
@unsafe
export declare function path_remove_directory(
  /** Input: The working directory at which the resolution of the path starts. */
  fd: fd,
  /** Input: The path to a directory to remove. */
  path: ptr<char>,
  /** Input: The length of the path to a directory to remove. */
  path_len: usize
): errno;

/** Rename a file or directory. */
// @ts-ignore: decorator
@unsafe
export declare function path_rename(
  /** Input: The working directory at which the resolution of the old path starts. */
  old_fd: fd,
  /** Input: The source path of the file or directory to rename. */
  old_path: ptr<char>,
  /** Input: The length of the source path of the file or directory to rename. */
  old_path_len: usize,
  /** Input: The working directory at which the resolution of the new path starts. */
  new_fd: fd,
  /** Input: The destination path to which to rename the file or directory. */
  new_path: ptr<char>,
  /** Input: The length of the destination path to which to rename the file or directory. */
  new_path_len: usize
): errno;

/** Create a symbolic link. */
// @ts-ignore: decorator
@unsafe
export declare function path_symlink(
  /** Input: The contents of the symbolic link. */
  old_path: ptr<char>,
  /** Input: The length of the contents of the symbolic link. */
  old_path_len: usize,
  /** Input: The working directory at which the resolution of the path starts. */
  fd: fd,
  /** Input: The destination path at which to create the symbolic link. */
  new_path: ptr<char>,
  /** Input: The length of the destination path at which to create the symbolic link. */
  new_path_len: usize
): errno;

/** Unlink a file. */
// @ts-ignore: decorator
@unsafe
export declare function path_unlink_file(
  /** Input: The working directory at which the resolution of the path starts. */
  fd: fd,
  /** Input: The path to a file to unlink. */
  path: ptr<char>,
  /** Input: The length of the path to a file to unlink. */
  path_len: usize
): errno;

/** Concurrently poll for the occurrence of a set of events. */
// @ts-ignore: decorator
@unsafe
export declare function poll_oneoff(
  /** Input: The events to which to subscribe. */
  in_: ptr<struct<subscription>>,
  /** Input: The events that have occurred. */
  out: ptr<struct<event>>,
  /** Input: Both the number of subscriptions and events. */
  nsubscriptions: usize,
  /** Output: The number of events stored. */
  nevents: ptr<usize>
): errno;

/** Terminate the process normally. An exit code of 0 indicates successful termination of the program. The meanings of other values is dependent on the environment. */
// @ts-ignore: decorator
@unsafe
export declare function proc_exit(
  /** Input: The exit code returned by the process. */
  rval: u32
): void;

/** Send a signal to the process of the calling thread. */
// @ts-ignore: decorator
@unsafe
export declare function proc_raise(
  /** Input: The signal condition to trigger. */
  sig: signal
): errno;

/** Write high-quality random data into a buffer. */
// @ts-ignore: decorator
@unsafe
export declare function random_get(
  /** Input: The buffer to fill with random data. */
  buf: usize,
  /** Input: The length of the buffer to fill with random data. */
  buf_len: usize
): errno;

/** Temporarily yield execution of the calling thread. */
// @ts-ignore: decorator
@unsafe
export declare function sched_yield(): errno;

/** Receive a message from a socket. */
// @ts-ignore: decorator
@unsafe
export declare function sock_recv(
  /** Input: The socket on which to receive data. */
  sock: fd,
  /** Input: List of scatter/gather vectors to which to store data. */
  ri_data: ptr<struct<iovec>>,
  /** Input: The length of the list of scatter/gather vectors to which to store data. */
  ri_data_len: usize,
  /** Input: Message flags. */
  ri_flags: riflags,
  /** Output: Number of bytes stored in `ri_data`. */
  ro_datalen: ptr<usize>,
  /** Output: Message flags. */
  ro_flags: ptr<roflags>
): errno;

/** Send a message on a socket. */
// @ts-ignore: decorator
@unsafe
export declare function sock_send(
  /** Input: The socket on which to send data. */
  sock: fd,
  /** Input: List of scatter/gather vectors to which to retrieve data */
  si_data: ptr<struct<iovec>>,
  /** Input: The length of the list of scatter/gather vectors to which to retrieve data */
  si_data_len: usize,
  /** Input: Message flags. */
  si_flags: siflags,
  /** Output: Number of bytes transmitted. */
  so_datalen: ptr<usize>
): errno;

/** Shut down socket send and receive channels. */
// @ts-ignore: decorator
@unsafe
export declare function sock_shutdown(
  /** Input: The socket on which to shutdown channels. */
  sock: fd,
  /** Input: Which channels on the socket to shut down. */
  how: sdflags
): errno;

// === Types ======================================================================================

/** File or memory access pattern advisory information. */
export namespace advice {
  /** The application has no advice to give on its behavior with respect to the specified data. */
  // @ts-ignore: decorator
  @inline
  export const NORMAL: advice = 0;
  /** The application expects to access the specified data sequentially from lower offsets to higher offsets. */
  // @ts-ignore: decorator
  @inline
  export const SEQUENTIAL : advice = 1;
  /** The application expects to access the specified data in a random order. */
  // @ts-ignore: decorator
  @inline
  export const RANDOM: advice = 2;
  /** The application expects to access the specified data in the near future. */
  // @ts-ignore: decorator
  @inline
  export const WILLNEED: advice = 3;
  /** The application expects that it will not access the specified data in the near future. */
  // @ts-ignore: decorator
  @inline
  export const DONTNEED: advice = 4;
  /** The application expects to access the specified data once and then not reuse it thereafter. */
  // @ts-ignore: decorator
  @inline
  export const NOREUSE: advice = 5;
}
export type advice = u8;

/** Identifiers for clocks. */
export namespace clockid {
  /** The clock measuring real time. Time value zero corresponds with 1970-01-01T00:00:00Z. */
  // @ts-ignore: decorator
  @inline
  export const REALTIME: clockid = 0;
  /** The store-wide monotonic clock. Absolute value has no meaning. */
  // @ts-ignore: decorator
  @inline
  export const MONOTONIC: clockid = 1;
  /** The CPU-time clock associated with the current process. */
  // @ts-ignore: decorator
  @inline
  export const PROCESS_CPUTIME_ID: clockid = 2;
  /** The CPU-time clock associated with the current thread. */
  // @ts-ignore: decorator
  @inline
  export const THREAD_CPUTIME_ID: clockid = 3;
}
export type clockid = u32;

/** Identifier for a device containing a file system. Can be used in combination with `inode` to uniquely identify a file or directory in the filesystem. */
export type device = u64;

/** A reference to the offset of a directory entry. The value 0 signifies the start of the directory. */
export type dircookie = u64;

/** A directory entry. */
@unmanaged export class dirent {
  /** The offset of the next directory entry stored in this directory. */
  next: dircookie;
  /** The serial number of the file referred to by this directory entry. */
  ino: inode;
  /** The length of the name of the directory entry. */
  namlen: u32;
  /** The type of the file referred to by this directory entry. */
  type: filetype;
  private __padding0: u16;
}

/** Error codes returned by functions. */
export namespace errno {
  /** No error occurred. System call completed successfully. */
  // @ts-ignore: decorator
  @inline
  export const SUCCESS: errno = 0;
  /** Argument list too long. */
  // @ts-ignore: decorator
  @inline
  export const TOOBIG: errno = 1;
  /** Permission denied. */
  // @ts-ignore: decorator
  @inline
  export const ACCES: errno = 2;
  /** Address in use. */
  // @ts-ignore: decorator
  @inline
  export const ADDRINUSE: errno = 3;
  /** Address not available. */
  // @ts-ignore: decorator
  @inline
  export const ADDRNOTAVAIL: errno = 4;
  /** Address family not supported. */
  // @ts-ignore: decorator
  @inline
  export const AFNOSUPPORT: errno = 5;
  /** Resource unavailable, or operation would block. */
  // @ts-ignore: decorator
  @inline
  export const AGAIN: errno = 6;
  /** Connection already in progress. */
  // @ts-ignore: decorator
  @inline
  export const ALREADY: errno = 7;
  /** Bad file descriptor. */
  // @ts-ignore: decorator
  @inline
  export const BADF: errno = 8;
  /** Bad message. */
  // @ts-ignore: decorator
  @inline
  export const BADMSG: errno = 9;
  /** Device or resource busy. */
  // @ts-ignore: decorator
  @inline
  export const BUSY: errno = 10;
  /** Operation canceled. */
  // @ts-ignore: decorator
  @inline
  export const CANCELED: errno = 11;
  /** No child processes. */
  // @ts-ignore: decorator
  @inline
  export const CHILD: errno = 12;
  /** Connection aborted. */
  // @ts-ignore: decorator
  @inline
  export const CONNABORTED: errno = 13;
  /** Connection refused. */
  // @ts-ignore: decorator
  @inline
  export const CONNREFUSED: errno = 14;
  /** Connection reset. */
  // @ts-ignore: decorator
  @inline
  export const CONNRESET: errno = 15;
  /** Resource deadlock would occur. */
  // @ts-ignore: decorator
  @inline
  export const DEADLK: errno = 16;
  /** Destination address required. */
  // @ts-ignore: decorator
  @inline
  export const DESTADDRREQ: errno = 17;
  /** Mathematics argument out of domain of function. */
  // @ts-ignore: decorator
  @inline
  export const DOM: errno = 18;
  /** Reserved. */
  // @ts-ignore: decorator
  @inline
  export const DQUOT: errno = 19;
  /** File exists. */
  // @ts-ignore: decorator
  @inline
  export const EXIST: errno = 20;
  /** Bad address. */
  // @ts-ignore: decorator
  @inline
  export const FAULT: errno = 21;
  /** File too large. */
  // @ts-ignore: decorator
  @inline
  export const FBIG: errno = 22;
  /** Host is unreachable. */
  // @ts-ignore: decorator
  @inline
  export const HOSTUNREACH: errno = 23;
  /** Identifier removed. */
  // @ts-ignore: decorator
  @inline
  export const IDRM: errno = 24;
  /** Illegal byte sequence. */
  // @ts-ignore: decorator
  @inline
  export const ILSEQ: errno = 25;
  /** Operation in progress. */
  // @ts-ignore: decorator
  @inline
  export const INPROGRESS: errno = 26;
  /** Interrupted function. */
  // @ts-ignore: decorator
  @inline
  export const INTR: errno = 27;
  /** Invalid argument. */
  // @ts-ignore: decorator
  @inline
  export const INVAL: errno = 28;
  /** I/O error. */
  // @ts-ignore: decorator
  @inline
  export const IO: errno = 29;
  /** Socket is connected. */
  // @ts-ignore: decorator
  @inline
  export const ISCONN: errno = 30;
  /** Is a directory. */
  // @ts-ignore: decorator
  @inline
  export const ISDIR: errno = 31;
  /** Too many levels of symbolic links. */
  // @ts-ignore: decorator
  @inline
  export const LOOP: errno = 32;
  /** File descriptor value too large. */
  // @ts-ignore: decorator
  @inline
  export const MFILE: errno = 33;
  /** Too many links. */
  // @ts-ignore: decorator
  @inline
  export const MLINK: errno = 34;
  /** Message too large. */
  // @ts-ignore: decorator
  @inline
  export const MSGSIZE: errno = 35;
  /** Reserved. */
  // @ts-ignore: decorator
  @inline
  export const MULTIHOP: errno = 36;
  /** Filename too long. */
  // @ts-ignore: decorator
  @inline
  export const NAMETOOLONG: errno = 37;
  /** Network is down. */
  // @ts-ignore: decorator
  @inline
  export const NETDOWN: errno = 38;
  /** Connection aborted by network. */
  // @ts-ignore: decorator
  @inline
  export const NETRESET: errno = 39;
  /** Network unreachable. */
  // @ts-ignore: decorator
  @inline
  export const NETUNREACH: errno = 40;
  /** Too many files open in system. */
  // @ts-ignore: decorator
  @inline
  export const NFILE: errno = 41;
  /** No buffer space available. */
  // @ts-ignore: decorator
  @inline
  export const NOBUFS: errno = 42;
  /** No such device. */
  // @ts-ignore: decorator
  @inline
  export const NODEV: errno = 43;
  /** No such file or directory. */
  // @ts-ignore: decorator
  @inline
  export const NOENT: errno = 44;
  /** Executable file format error. */
  // @ts-ignore: decorator
  @inline
  export const NOEXEC: errno = 45;
  /** No locks available. */
  // @ts-ignore: decorator
  @inline
  export const NOLCK: errno = 46;
  /** Reserved. */
  // @ts-ignore: decorator
  @inline
  export const NOLINK: errno = 47;
  /** Not enough space. */
  // @ts-ignore: decorator
  @inline
  export const NOMEM: errno = 48;
  /** No message of the desired type. */
  // @ts-ignore: decorator
  @inline
  export const NOMSG: errno = 49;
  /** Protocol not available. */
  // @ts-ignore: decorator
  @inline
  export const NOPROTOOPT: errno = 50;
  /** No space left on device. */
  // @ts-ignore: decorator
  @inline
  export const NOSPC: errno = 51;
  /** Function not supported. */
  // @ts-ignore: decorator
  @inline
  export const NOSYS: errno = 52;
  /** The socket is not connected. */
  // @ts-ignore: decorator
  @inline
  export const NOTCONN: errno = 53;
  /** Not a directory or a symbolic link to a directory. */
  // @ts-ignore: decorator
  @inline
  export const NOTDIR: errno = 54;
  /** Directory not empty. */
  // @ts-ignore: decorator
  @inline
  export const NOTEMPTY: errno = 55;
  /** State not recoverable. */
  // @ts-ignore: decorator
  @inline
  export const NOTRECOVERABLE: errno = 56;
  /** Not a socket. */
  // @ts-ignore: decorator
  @inline
  export const NOTSOCK: errno = 57;
  /** Not supported, or operation not supported on socket. */
  // @ts-ignore: decorator
  @inline
  export const NOTSUP: errno = 58;
  /** Inappropriate I/O control operation. */
  // @ts-ignore: decorator
  @inline
  export const NOTTY: errno = 59;
  /** No such device or address. */
  // @ts-ignore: decorator
  @inline
  export const NXIO: errno = 60;
  /** Value too large to be stored in data type. */
  // @ts-ignore: decorator
  @inline
  export const OVERFLOW: errno = 61;
  /** Previous owner died. */
  // @ts-ignore: decorator
  @inline
  export const OWNERDEAD: errno = 62;
  /** Operation not permitted. */
  // @ts-ignore: decorator
  @inline
  export const PERM: errno = 63;
  /** Broken pipe. */
  // @ts-ignore: decorator
  @inline
  export const PIPE: errno = 64;
  /** Protocol error. */
  // @ts-ignore: decorator
  @inline
  export const PROTO: errno = 65;
  /** Protocol not supported. */
  // @ts-ignore: decorator
  @inline
  export const PROTONOSUPPORT: errno = 66;
  /** Protocol wrong type for socket. */
  // @ts-ignore: decorator
  @inline
  export const PROTOTYPE: errno = 67;
  /** Result too large. */
  // @ts-ignore: decorator
  @inline
  export const RANGE: errno = 68;
  /** Read-only file system. */
  // @ts-ignore: decorator
  @inline
  export const ROFS: errno = 69;
  /** Invalid seek. */
  // @ts-ignore: decorator
  @inline
  export const SPIPE: errno = 70;
  /** No such process. */
  // @ts-ignore: decorator
  @inline
  export const SRCH: errno = 71;
  /** Reserved. */
  // @ts-ignore: decorator
  @inline
  export const STALE: errno = 72;
  /** Connection timed out. */
  // @ts-ignore: decorator
  @inline
  export const TIMEDOUT: errno = 73;
  /** Text file busy. */
  // @ts-ignore: decorator
  @inline
  export const TXTBSY: errno = 74;
  /** Cross-device link. */
  // @ts-ignore: decorator
  @inline
  export const XDEV: errno = 75;
  /** Extension: Capabilities insufficient. */
  // @ts-ignore: decorator
  @inline
  export const NOTCAPABLE: errno = 76;
}
export type errno = u16;

/** Translates an error code to a string. */
export function errnoToString(err: errno): string {
  switch (err) {
    case errno.SUCCESS: return "SUCCESS";
    case errno.TOOBIG: return "TOOBIG";
    case errno.ACCES: return "ACCES";
    case errno.ADDRINUSE: return "ADDRINUSE";
    case errno.ADDRNOTAVAIL: return "ADDRNOTAVAIL";
    case errno.AFNOSUPPORT: return "AFNOSUPPORT";
    case errno.AGAIN: return "AGAIN";
    case errno.ALREADY: return "ALREADY";
    case errno.BADF: return "BADF";
    case errno.BADMSG: return "BADMSG";
    case errno.BUSY: return "BUSY";
    case errno.CANCELED: return "CANCELED";
    case errno.CHILD: return "CHILD";
    case errno.CONNABORTED: return "CONNABORTED";
    case errno.CONNREFUSED: return "CONNREFUSED";
    case errno.CONNRESET: return "CONNRESET";
    case errno.DEADLK: return "DEADLK";
    case errno.DESTADDRREQ: return "DESTADDRREQ";
    case errno.DOM: return "DOM";
    case errno.DQUOT: return "DQUOT";
    case errno.EXIST: return "EXIST";
    case errno.FAULT: return "FAULT";
    case errno.FBIG: return "FBIG";
    case errno.HOSTUNREACH: return "HOSTUNREACH";
    case errno.IDRM: return "IDRM";
    case errno.ILSEQ: return "ILSEQ";
    case errno.INPROGRESS: return "INPROGRESS";
    case errno.INTR: return "INTR";
    case errno.INVAL: return "INVAL";
    case errno.IO: return "IO";
    case errno.ISCONN: return "ISCONN";
    case errno.ISDIR: return "ISDIR";
    case errno.LOOP: return "LOOP";
    case errno.MFILE: return "MFILE";
    case errno.MLINK: return "MLINK";
    case errno.MSGSIZE: return "MSGSIZE";
    case errno.MULTIHOP: return "MULTIHOP";
    case errno.NAMETOOLONG: return "NAMETOOLONG";
    case errno.NETDOWN: return "NETDOWN";
    case errno.NETRESET: return "NETRESET";
    case errno.NETUNREACH: return "NETUNREACH";
    case errno.NFILE: return "NFILE";
    case errno.NOBUFS: return "NOBUFS";
    case errno.NODEV: return "NODEV";
    case errno.NOENT: return "NOENT";
    case errno.NOEXEC: return "NOEXEC";
    case errno.NOLCK: return "NOLCK";
    case errno.NOLINK: return "NOLINK";
    case errno.NOMEM: return "NOMEM";
    case errno.NOMSG: return "NOMSG";
    case errno.NOPROTOOPT: return "NOPROTOOPT";
    case errno.NOSPC: return "NOSPC";
    case errno.NOSYS: return "NOSYS";
    case errno.NOTCONN: return "NOTCONN";
    case errno.NOTDIR: return "NOTDIR";
    case errno.NOTEMPTY: return "NOTEMPTY";
    case errno.NOTRECOVERABLE: return "NOTRECOVERABLE";
    case errno.NOTSOCK: return "NOTSOCK";
    case errno.NOTSUP: return "NOTSUP";
    case errno.NOTTY: return "NOTTY";
    case errno.NXIO: return "NXIO";
    case errno.OVERFLOW: return "OVERFLOW";
    case errno.OWNERDEAD: return "OWNERDEAD";
    case errno.PERM: return "PERM";
    case errno.PIPE: return "PIPE";
    case errno.PROTO: return "PROTO";
    case errno.PROTONOSUPPORT: return "PROTONOSUPPORT";
    case errno.PROTOTYPE: return "PROTOTYPE";
    case errno.RANGE: return "RANGE";
    case errno.ROFS: return "ROFS";
    case errno.SPIPE: return "SPIPE";
    case errno.SRCH: return "SRCH";
    case errno.STALE: return "STALE";
    case errno.TIMEDOUT: return "TIMEDOUT";
    case errno.TXTBSY: return "TXTBSY";
    case errno.XDEV: return "XDEV";
    case errno.NOTCAPABLE: return "NOTCAPABLE";
  }
  return "UNKNOWN";
}

@unmanaged abstract class $event { // size=16/32
  /** User-provided value that got attached to `subscription#userdata`. */
  userdata: userdata;
  /** If non-zero, an error that occurred while processing the subscription request. */
  error: errno;
  /** The type of the event that occurred. */
  type: eventtype;

  private __padding0: u16;
}

/** An event that occurred. */
@unmanaged export abstract class event extends $event {
  private __padding1: u64;
  private __padding2: u64;
}

/** An event that occurred when type is `eventtype.FD_READ` or `eventtype.FD_WRITE`. */
@unmanaged export class event_fd_readwrite extends $event {
  /* The number of bytes available for reading or writing. */
  nbytes: filesize;
  /* The state of the file descriptor. */
  flags: eventrwflags;

  private __padding1: u32;
}

/** The state of the file descriptor subscribed to with `eventtype.FD_READ` or `eventtype.FD_WRITE`. */
export namespace eventrwflags {
  /** The peer of this socket has closed or disconnected. */
  // @ts-ignore: decorator
  @inline
  export const HANGUP: eventrwflags = 1;
}
export type eventrwflags = u16;

/** Type of a subscription to an event or its occurrence. */
export namespace eventtype {
  /** The time value of clock has reached the timestamp. */
  // @ts-ignore: decorator
  @inline
  export const CLOCK: eventtype = 0;
  /** File descriptor has data available for reading. */
  // @ts-ignore: decorator
  @inline
  export const FD_READ: eventtype = 1;
  /** File descriptor has capacity available for writing */
  // @ts-ignore: decorator
  @inline
  export const FD_WRITE: eventtype = 2;
}
export type eventtype = u8;

/** Exit code generated by a process when exiting. */
export type exitcode = u32;

/** A file descriptor number. */
export type fd = u32;

/** File descriptor flags. */
export namespace fdflags {
  /** Append mode: Data written to the file is always appended to the file's end. */
  // @ts-ignore: decorator
  @inline
  export const APPEND: fdflags = 1;
  /** Write according to synchronized I/O data integrity completion. Only the data stored in the file is synchronized. */
  // @ts-ignore: decorator
  @inline
  export const DSYNC: fdflags = 2;
  /** Non-blocking mode. */
  // @ts-ignore: decorator
  @inline
  export const NONBLOCK: fdflags = 4;
  /** Synchronized read I/O operations. */
  // @ts-ignore: decorator
  @inline
  export const RSYNC: fdflags = 8;
  /** Write according to synchronized I/O file integrity completion. */
  // @ts-ignore: decorator
  @inline
  export const SYNC: fdflags = 16;
}
export type fdflags = u16;

/** File descriptor attributes. */
@unmanaged export class fdstat {
  /** File type. */
  filetype: filetype;
  /** File descriptor flags. */
  flags: fdflags;
  /** Rights that apply to this file descriptor. */
  rights_base: rights;
  /** Maximum set of rights that may be installed on new file descriptors that are created through this file descriptor, e.g., through `path_open`. */
  rights_inheriting: rights;
}

/** Relative offset within a file. */
export type filedelta = i64;

/** Non-negative file size or length of a region within a file. */
export type filesize = u64;

/** File attributes. */
@unmanaged export class filestat {
  /** Device ID of device containing the file. */
  dev: device;
  /** File serial number. */
  ino: inode;
  /** File type. */
  filetype: filetype;
  /** Number of hard links to the file. */
  nlink: linkcount;
  /** For regular files, the file size in bytes. For symbolic links, the length in bytes of the pathname contained in the symbolic link. */
  size: filesize;
  /** Last data access timestamp. */
  atim: timestamp;
  /** Last data modification timestamp. */
  mtim: timestamp;
  /** Last file status change timestamp. */
  ctim: timestamp;
}

/** The type of a file descriptor or file. */
export namespace filetype {
  /** The type of the file descriptor or file is unknown or is different from any of the other types specified. */
  // @ts-ignore: decorator
  @inline
  export const UNKNOWN: filetype = 0;
  /** The file descriptor or file refers to a block device inode. */
  // @ts-ignore: decorator
  @inline
  export const BLOCK_DEVICE: filetype = 1;
  /** The file descriptor or file refers to a character device inode. */
  // @ts-ignore: decorator
  @inline
  export const CHARACTER_DEVICE: filetype = 2;
  /** The file descriptor or file refers to a directory inode. */
  // @ts-ignore: decorator
  @inline
  export const DIRECTORY: filetype = 3;
  /** The file descriptor or file refers to a regular file inode. */
  // @ts-ignore: decorator
  @inline
  export const REGULAR_FILE: filetype = 4;
  /** The file descriptor or file refers to a datagram socket. */
  // @ts-ignore: decorator
  @inline
  export const SOCKET_DGRAM: filetype = 5;
  /** The file descriptor or file refers to a byte-stream socket. */
  // @ts-ignore: decorator
  @inline
  export const SOCKET_STREAM: filetype = 6;
  /** The file refers to a symbolic link inode. */
  // @ts-ignore: decorator
  @inline
  export const SYMBOLIC_LINK: filetype = 7;
}
export type filetype = u8;

/** Which file time attributes to adjust. */
export namespace fstflags {
  /** Adjust the last data access timestamp to the value stored in `filestat#st_atim`. */
  // @ts-ignore: decorator
  @inline
  export const SET_ATIM: fstflags = 1;
  /** Adjust the last data access timestamp to the time of clock `clockid.REALTIME`. */
  // @ts-ignore: decorator
  @inline
  export const SET_ATIM_NOW: fstflags = 2;
  /** Adjust the last data modification timestamp to the value stored in `filestat#st_mtim`. */
  // @ts-ignore: decorator
  @inline
  export const SET_MTIM: fstflags = 4;
  /** Adjust the last data modification timestamp to the time of clock `clockid.REALTIME`. */
  // @ts-ignore: decorator
  @inline
  export const SET_MTIM_NOW: fstflags = 8;
}
export type fstflags = u16;

/** File serial number that is unique within its file system. */
export type inode = u64;

/** A region of memory for scatter/gather reads. */
@unmanaged export class iovec {
  /** The address of the buffer to be filled. */
  buf: usize;
  /** The length of the buffer to be filled. */
  buf_len: usize;
}

/** Number of hard links to an inode. */
export type linkcount = u64;

/** Flags determining the method of how paths are resolved. */
export namespace lookupflags {
  /** As long as the resolved path corresponds to a symbolic link, it is expanded. */
  // @ts-ignore: decorator
  @inline
  export const SYMLINK_FOLLOW: lookupflags = 1;
}
export type lookupflags = u32;

/** Open flags. */
export namespace oflags {
  /** Create file if it does not exist. */
  // @ts-ignore: decorator
  @inline
  export const CREAT: oflags = 1;
  /** Fail if not a directory. */
  // @ts-ignore: decorator
  @inline
  export const DIRECTORY: oflags = 2;
  /** Fail if file already exists. */
  // @ts-ignore: decorator
  @inline
  export const EXCL: oflags = 4;
  /** Truncate file to size 0. */
  // @ts-ignore: decorator
  @inline
  export const TRUNC: oflags = 8;
}
export type oflags = u16;

/** Identifiers for preopened capabilities. */
export namespace preopentype {
  /** A pre-opened directory. */
  // @ts-ignore: decorator
  @inline
  export const DIR: preopentype = 0;
}
export type preopentype = u8;

@unmanaged abstract class $prestat { // WASM32: size=1/8, WASM64: size=1/16
  /* The type of the pre-opened capability. */
  type: preopentype;
}

/* Information about a pre-opened capability. */
@unmanaged export abstract class prestat extends $prestat {
  private __padding0: usize;
}

/** The contents of a $prestat when type is `preopentype.DIR`. */
@unmanaged export class prestat_dir extends $prestat {
  /** The length of the directory name for use with `fd_prestat_dir_name`. */
  name_len: usize;
}

/** Flags provided to `sock_recv`. */
export namespace riflags {
  /** Returns the message without removing it from the socket's receive queue. */
  // @ts-ignore: decorator
  @inline
  export const PEEK: riflags = 1;
  /** On byte-stream sockets, block until the full amount of data can be returned. */
  // @ts-ignore: decorator
  @inline
  export const WAITALL: riflags = 2;
}
export type riflags = u16;

/** File descriptor rights, determining which actions may be performed. */
export namespace rights {
  /** The right to invoke `fd_datasync`. */
  // @ts-ignore: decorator
  @inline
  export const FD_DATASYNC: rights = 1;
  /** The right to invoke `fd_read` and `sock_recv`. */
  // @ts-ignore: decorator
  @inline
  export const FD_READ: rights = 2;
  /** The right to invoke `fd_seek`. This flag implies `rights.FD_TELL`. */
  // @ts-ignore: decorator
  @inline
  export const FD_SEEK: rights = 4;
  /** The right to invoke `fd_fdstat_set_flags`. */
  // @ts-ignore: decorator
  @inline
  export const FD_FDSTAT_SET_FLAGS: rights = 8;
  /** The right to invoke `fd_sync`. */
  // @ts-ignore: decorator
  @inline
  export const FD_SYNC: rights = 16;
  /** The right to invoke `fd_seek` in such a way that the file offset remains unaltered (i.e., `whence.CUR` with offset zero), or to invoke `fd_tell`). */
  // @ts-ignore: decorator
  @inline
  export const FD_TELL: rights = 32;
  /** The right to invoke `fd_write` and `sock_send`. If `rights.FD_SEEK` is set, includes the right to invoke `fd_pwrite`. */
  // @ts-ignore: decorator
  @inline
  export const FD_WRITE: rights = 64;
  /** The right to invoke `fd_advise`. */
  // @ts-ignore: decorator
  @inline
  export const FD_ADVISE: rights = 128;
  /** The right to invoke `fd_allocate`. */
  // @ts-ignore: decorator
  @inline
  export const FD_ALLOCATE: rights = 256;
  /** The right to invoke `path_create_directory`. */
  // @ts-ignore: decorator
  @inline
  export const PATH_CREATE_DIRECTORY: rights = 512;
  /** If `rights.PATH_OPEN` is set, the right to invoke `path_open` with `oflags.CREAT`. */
  // @ts-ignore: decorator
  @inline
  export const PATH_CREATE_FILE: rights = 1024;
  /** The right to invoke `path_link` with the file descriptor as the source directory. */
  // @ts-ignore: decorator
  @inline
  export const PATH_LINK_SOURCE: rights = 2048;
  /** The right to invoke `path_link` with the file descriptor as the target directory. */
  // @ts-ignore: decorator
  @inline
  export const PATH_LINK_TARGET: rights = 4096;
  /** The right to invoke `path_open`. */
  // @ts-ignore: decorator
  @inline
  export const PATH_OPEN: rights = 8192;
  /** The right to invoke `fd_readdir`. */
  // @ts-ignore: decorator
  @inline
  export const FD_READDIR: rights = 16384;
  /** The right to invoke `path_readlink`. */
  // @ts-ignore: decorator
  @inline
  export const PATH_READLINK: rights = 32768;
  /** The right to invoke `path_rename` with the file descriptor as the source directory. */
  // @ts-ignore: decorator
  @inline
  export const PATH_RENAME_SOURCE: rights = 65536;
  /** The right to invoke `path_rename` with the file descriptor as the target directory. */
  // @ts-ignore: decorator
  @inline
  export const PATH_RENAME_TARGET: rights = 131072;
  /** The right to invoke `path_filestat_get`. */
  // @ts-ignore: decorator
  @inline
  export const PATH_FILESTAT_GET: rights = 262144;
  /** The right to change a file's size (there is no `path_filestat_set_size`). If `rights.PATH_OPEN` is set, includes the right to invoke `path_open` with `oflags.TRUNC`. */
  // @ts-ignore: decorator
  @inline
  export const PATH_FILESTAT_SET_SIZE: rights = 524288;
  /** The right to invoke `path_filestat_set_times`. */
  // @ts-ignore: decorator
  @inline
  export const PATH_FILESTAT_SET_TIMES: rights = 1048576;
  /** The right to invoke `fd_filestat_get`. */
  // @ts-ignore: decorator
  @inline
  export const FD_FILESTAT_GET: rights = 2097152;
  /** The right to invoke `fd_filestat_set_size`. */
  // @ts-ignore: decorator
  @inline
  export const FD_FILESTAT_SET_SIZE: rights = 4194304;
  /** The right to invoke `fd_filestat_set_times`. */
  // @ts-ignore: decorator
  @inline
  export const FD_FILESTAT_SET_TIMES: rights = 8388608;
  /** The right to invoke `path_symlink`. */
  // @ts-ignore: decorator
  @inline
  export const RIGHT_PATH_SYMLINK: rights = 16777216;
  /** The right to invoke `path_remove_directory`. */
  // @ts-ignore: decorator
  @inline
  export const PATH_REMOVE_DIRECTORY: rights = 33554432;
  /** The right to invoke `path_unlink_file`. */
  // @ts-ignore: decorator
  @inline
  export const PATH_UNLINK_FILE: rights = 67108864;
  /** If `rights.FD_READ` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype.FD_READ`. If `rights.FD_WRITE` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype.FD_WRITE`. */
  // @ts-ignore: decorator
  @inline
  export const POLL_FD_READWRITE: rights = 134217728;
  /** The right to invoke `sock_shutdown`. */
  // @ts-ignore: decorator
  @inline
  export const SOCK_SHUTDOWN: rights = 268435456;
}
export type rights = u64;

/** Flags returned by `sock_recv`. */
export namespace roflags {
  /** Message data has been truncated. */
  // @ts-ignore: decorator
  @inline
  export const DATA_TRUNCATED: roflags = 1;
}
export type roflags = u16;

/** Which channels on a socket to shut down. */
export namespace sdflags {
  /** Disables further receive operations. */
  // @ts-ignore: decorator
  @inline
  export const RD: sdflags = 1;
  /** Disables further send operations. */
  // @ts-ignore: decorator
  @inline
  export const WR: sdflags = 2;
}
export type sdflags = u8;

/** Flags provided to `sock_send`. */
export namespace siflags {
  // As there are currently no flags defined, it must be set to zero.
}
export type siflags = u16;

/** Signal condition. */
export namespace signal {
  /** Hangup. */
  // @ts-ignore: decorator
  @inline
  export const HUP: signal = 1;
  /** Terminate interrupt signal. */
  // @ts-ignore: decorator
  @inline
  export const INT: signal = 2;
  /** Terminal quit signal. */
  // @ts-ignore: decorator
  @inline
  export const QUIT: signal = 3;
  /** Illegal instruction. */
  // @ts-ignore: decorator
  @inline
  export const ILL: signal = 4;
  /** Trace/breakpoint trap. */
  // @ts-ignore: decorator
  @inline
  export const TRAP: signal = 5;
  /** Process abort signal. */
  // @ts-ignore: decorator
  @inline
  export const ABRT: signal = 6;
  /** Access to an undefined portion of a memory object. */
  // @ts-ignore: decorator
  @inline
  export const BUS: signal = 7;
  /** Erroneous arithmetic operation. */
  // @ts-ignore: decorator
  @inline
  export const FPE: signal = 8;
  /** Kill. */
  // @ts-ignore: decorator
  @inline
  export const KILL: signal = 9;
  /** User-defined signal 1. */
  // @ts-ignore: decorator
  @inline
  export const USR1: signal = 10;
  /** Invalid memory reference. */
  // @ts-ignore: decorator
  @inline
  export const SEGV: signal = 11;
  /** User-defined signal 2. */
  // @ts-ignore: decorator
  @inline
  export const USR2: signal = 12;
  /** Write on a pipe with no one to read it. */
  // @ts-ignore: decorator
  @inline
  export const PIPE: signal = 13;
  /** Alarm clock. */
  // @ts-ignore: decorator
  @inline
  export const ALRM: signal = 14;
  /** Termination signal. */
  // @ts-ignore: decorator
  @inline
  export const TERM: signal = 15;
  /** Child process terminated, stopped, or continued. */
  // @ts-ignore: decorator
  @inline
  export const CHLD: signal = 16;
  /** Continue executing, if stopped. */
  // @ts-ignore: decorator
  @inline
  export const CONT: signal = 17;
  /** Stop executing. */
  // @ts-ignore: decorator
  @inline
  export const STOP: signal = 18;
  /** Terminal stop signal. */
  // @ts-ignore: decorator
  @inline
  export const TSTP: signal = 19;
  /** Background process attempting read. */
  // @ts-ignore: decorator
  @inline
  export const TTIN: signal = 20;
  /** Background process attempting write. */
  // @ts-ignore: decorator
  @inline
  export const TTOU: signal = 21;
  /** High bandwidth data is available at a socket. */
  // @ts-ignore: decorator
  @inline
  export const URG: signal = 22;
  /** CPU time limit exceeded. */
  // @ts-ignore: decorator
  @inline
  export const XCPU: signal = 23;
  /** File size limit exceeded. */
  // @ts-ignore: decorator
  @inline
  export const XFSZ: signal = 24;
  /** Virtual timer expired. */
  // @ts-ignore: decorator
  @inline
  export const VTALRM: signal = 25;
  // @ts-ignore: decorator
  @inline
  export const PROF: signal = 26;
  // @ts-ignore: decorator
  @inline
  export const WINCH: signal = 27;
  // @ts-ignore: decorator
  @inline
  export const POLL: signal = 28;
  // @ts-ignore: decorator
  @inline
  export const PWR: signal = 29;
  /** Bad system call. */
  // @ts-ignore: decorator
  @inline
  export const SYS: signal = 30;
}
export type signal = u8;

/** Flags determining how to interpret the timestamp provided in `subscription_t::u.clock.timeout. */
export namespace subclockflags {
  /** If set, treat the timestamp provided in `clocksubscription` as an absolute timestamp. */
  // @ts-ignore: decorator
  @inline
  export const ABSTIME: subclockflags = 1;
}
export type subclockflags = u16;

@unmanaged abstract class $subscription { // size=16/48
  /** User-provided value that is attached to the subscription. */
  userdata: userdata;
  /** The type of the event to which to subscribe. */
  type: eventtype;

  private __padding0: u32;
}

/** Subscription to an event. */
@unmanaged export abstract class subscription extends $subscription {
  private __padding1: u64;
  private __padding2: u64;
  private __padding3: u64;
  private __padding4: u64;
}

/* Subscription to an event of type `eventtype.CLOCK`.**/
@unmanaged export class subscription_clock extends $subscription {
  /** The clock against which to compare the timestamp. */
  clock_id: clockid;
  /** The absolute or relative timestamp. */
  timeout: timestamp;
  /** The amount of time that the implementation may wait additionally to coalesce with other events. */
  precision: timestamp;
  /** Flags specifying whether the timeout is absolute or relative. */
  flags: subclockflags;

  private __padding1: u32;
}

/* Subscription to an event of type `eventtype.FD_READ` or `eventtype.FD_WRITE`.**/
@unmanaged export class subscription_fd_readwrite extends $subscription {
  /** The file descriptor on which to wait for it to become ready for reading or writing. */
  file_descriptor: fd;

  private __padding1: u64;
  private __padding2: u64;
  private __padding3: u64;
}

/** Timestamp in nanoseconds. */
export type timestamp = u64;

/** User-provided value that may be attached to objects that is retained when extracted from the implementation. */
export type userdata = u64;

/** The position relative to which to set the offset of the file descriptor. */
export namespace whence {
  /** Seek relative to start-of-file. */
  // @ts-ignore: decorator
  @inline
  export const SET: whence = 0;
  /** Seek relative to current position. */
  // @ts-ignore: decorator
  @inline
  export const CUR: whence = 1;
  /** Seek relative to end-of-file. */
  // @ts-ignore: decorator
  @inline
  export const END: whence = 2;
}

export type whence = u8;

'''
'''--- std/assembly/bindings/wasi_unstable.ts ---
// Phase: wasi_unstable / wasi_snapshot_preview0
// See: https://github.com/WebAssembly/WASI/tree/main/phases/old/snapshot_0/witx

// helper types to be more explicit
type char = u8;
type ptr<T> = usize; // all pointers are usize'd
type struct<T> = T;  // structs are references already in AS

/** Read command-line argument data. */
// @ts-ignore: decorator
@unsafe
export declare function args_get(
  /** Input: Pointer to a buffer to write the argument pointers. */
  argv: ptr<ptr<char>>,
  /** Input: Pointer to a buffer to write the argument string data. */
  argv_buf: ptr<char>
): errno;

/** Return command-line argument data sizes. */
// @ts-ignore: decorator
@unsafe
export declare function args_sizes_get(
  /** Output: Number of arguments. */
  argc: ptr<usize>,
  /** Output: Size of the argument string data. */
  argv_buf_size: ptr<usize>
): errno;

/** Return the resolution of a clock. */
// @ts-ignore: decorator
@unsafe
export declare function clock_res_get(
  /** Input: The clock for which to return the resolution. */
  clock: clockid,
  /** Output: The resolution of the clock. */
  resolution: ptr<timestamp>
): errno;

/** Return the time value of a clock. */
// @ts-ignore: decorator
@unsafe
export declare function clock_time_get(
  /** Input: Cock for which to return the time. */
  clock: clockid,
  /** Input: Maximum lag (exclusive) that the returned time value may have, compared to its actual value. */
  precision: timestamp,
  /** Output: Time value of the clock. */
  time: ptr<timestamp>
): errno;

/** Read environment variable data. */
// @ts-ignore: decorator
@unsafe
export declare function environ_get(
  /** Input: Pointer to a buffer to write the environment variable pointers. */
  environ: ptr<usize>,
  /** Input: Pointer to a buffer to write the environment variable string data. */
  environ_buf: usize
): errno;

/** Return command-line argument data sizes. */
// @ts-ignore: decorator
@unsafe
export declare function environ_sizes_get(
  /** Output: The number of environment variables. */
  environ_count: ptr<usize>,
  /** Output: The size of the environment variable string data. */
  environ_buf_size: ptr<usize>
): errno;

/** Provide file advisory information on a file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_advise(
  /** Input: The file descriptor for the file for which to provide file advisory information. */
  fd: fd,
  /** Input: The offset within the file to which the advisory applies. */
  offset: filesize,
  /** Input: The length of the region to which the advisory applies. */
  len: filesize,
  /** Input: The advice. */
  advice: advice
): errno;

/** Provide file advisory information on a file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_allocate(
  /** Input: The file descriptor for the file in which to allocate space. */
  fd: fd,
  /** Input: The offset at which to start the allocation. */
  offset: filesize,
  /** Input: The length of the area that is allocated. */
  len: filesize
): errno;

/** Close a file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_close(
  /** Input: The file descriptor to close. */
  fd: fd
): errno;

/** Synchronize the data of a file to disk. */
// @ts-ignore: decorator
@unsafe
export declare function fd_datasync(
  /** Input: The file descriptor of the file to synchronize to disk. */
  fd: fd
): errno;

/** Get the attributes of a file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_fdstat_get(
  /** Input: The file descriptor to inspect. */
  fd: fd,
  /** Input: The buffer where the file descriptor's attributes are stored. */
  buf: struct<fdstat>
): errno;

/** Adjust the flags associated with a file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_fdstat_set_flags(
  /** Input: The file descriptor to operate on. */
  fd: fd,
  /** Input: The desired values of the file descriptor flags. */
  flags: fdflags
): errno;

/** Adjust the rights associated with a file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_fdstat_set_rights(
  /** Input: The file descriptor to operate on. */
  fd: fd,
  /** Input: The desired rights of the file descriptor. */
  fs_rights_base: rights,
  /** Input: The desired rights of the file descriptor. */
  fs_rights_inheriting: rights
): errno;

/** Return the attributes of an open file. */
// @ts-ignore: decorator
@unsafe
export declare function fd_filestat_get(
  /** Input: The file descriptor to inspect. */
  fd: fd,
  /** Input: The buffer where the file's attributes are stored. */
  buf: struct<filestat>
): errno;

/** Adjust the size of an open file. If this increases the file's size, the extra bytes are filled with zeros. */
// @ts-ignore: decorator
@unsafe
export declare function fd_filestat_set_size(
  /** Input: A file descriptor for the file to adjust. */
  fd: fd,
  /** Input: The desired file size. */
  size: filesize
): errno;

/** Adjust the timestamps of an open file or directory. */
// @ts-ignore: decorator
@unsafe
export declare function fd_filestat_set_times(
  /** Input: The file descriptor to operate on. */
  fd: fd,
  /** Input: The desired values of the data access timestamp. */
  st_atim: timestamp,
  /** Input: The desired values of the data modification timestamp. */
  st_mtim: timestamp,
  /** Input: A bitmask indicating which timestamps to adjust. */
  fstflags: fstflags
): errno;

/** Read from a file descriptor, without using and updating the file descriptor's offset. */
// @ts-ignore: decorator
@unsafe
export declare function fd_pread(
  /** Input: The file descriptor from which to read data. */
  fd: fd,
  /** Input: List of scatter/gather vectors in which to store data. */
  iovs: ptr<struct<iovec>>,
  /** Input: Length of the list of scatter/gather vectors in which to store data. */
  iovs_len: usize,
  /** Input: The offset within the file at which to read. */
  offset: filesize,
  /** Output: The number of bytes read. */
  nread: ptr<usize>
): errno;

/** Return a description of the given preopened file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_prestat_get(
  /** Input: The file descriptor about which to retrieve information. */
  fd: fd,
  /** Input: The buffer where the description is stored. */
  buf: struct<prestat>
): errno;

/** Return a description of the given preopened file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_prestat_dir_name(
  /** Input: The file descriptor about which to retrieve information. */
  fd: fd,
  /** Input: Buffer into which to write the preopened directory name. */
  path: ptr<char>,
  /** Input: Length of the buffer into which to write the preopened directory name. */
  path_len: usize
): errno;

/** Write to a file descriptor, without using and updating the file descriptor's offset. */
// @ts-ignore: decorator
@unsafe
export declare function fd_pwrite(
  /** Input: The file descriptor to which to write data. */
  fd: fd,
  /** Input: List of scatter/gather vectors from which to retrieve data. */
  iovs: ptr<struct<iovec>>,
  /** Input: Length of the list of scatter/gather vectors from which to retrieve data. */
  iovs_len: usize,
  /** Input: The offset within the file at which to write. */
  offset: filesize,
  /** Output: The number of bytes written. */
  nwritten: ptr<usize>
): errno;

/** Read from a file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_read(
  /** Input: The file descriptor from which to read data. */
  fd: fd,
  /** Input: List of scatter/gather vectors to which to store data. */
  iovs: ptr<struct<iovec>>,
  /** Input: Length of the list of scatter/gather vectors to which to store data. */
  iovs_len: usize,
  /** Output: The number of bytes read. */
  nread: ptr<usize>
): errno;

/** Read directory entries from a directory. */
// @ts-ignore: decorator
@unsafe
export declare function fd_readdir(
  /** Input: Directory from which to read the directory entries. */
  fd: fd,
  /** Input: Buffer where directory entries are stored. */
  buf: ptr<struct<dirent>>,
  /** Input: Length of the buffer where directory entries are stored. */
  buf_len: usize,
  /** Input: Location within the directory to start reading. */
  cookie: dircookie,
  /** Output: Number of bytes stored in the read buffer. If less than the size of the read buffer, the end of the directory has been reached. */
  buf_used: ptr<usize>
): errno;

/** Atomically replace a file descriptor by renumbering another file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_renumber(
  /** Input: The file descriptor to renumber. */
  from: fd,
  /** Input: The file descriptor to overwrite. */
  to: fd
): errno;

/** Move the offset of a file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_seek(
  /** Input: The file descriptor to operate on. */
  fd: fd,
  /** Input: The number of bytes to move. */
  offset: filedelta,
  /** Input: The base from which the offset is relative. */
  whence: whence,
  /** Output: The new offset of the file descriptor, relative to the start of the file. */
  newoffset: ptr<filesize>
): errno;

/** Synchronize the data and metadata of a file to disk. */
// @ts-ignore: decorator
@unsafe
export declare function fd_sync(
  /** Input: The file descriptor of the file containing the data and metadata to synchronize to disk. */
  fd: fd
): errno;

/** Return the current offset of a file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_tell(
  /** Input: The file descriptor to inspect. */
  fd: fd,
  /** Output: The current offset of the file descriptor, relative to the start of the file. */
  newoffset: ptr<filesize>
): errno;

/** Write to a file descriptor. */
// @ts-ignore: decorator
@unsafe
export declare function fd_write(
  /** Input: The file descriptor to which to write data. */
  fd: fd,
  /** Input: List of scatter/gather vectors from which to retrieve data. */
  iovs: ptr<struct<iovec>>,
  /** Input: List of scatter/gather vectors from which to retrieve data. */
  iovs_len: usize,
  /** Output: The number of bytes written. */
  nwritten: ptr<usize>
): errno;

/* Create a directory. */
// @ts-ignore: decorator
@unsafe
export declare function path_create_directory(
  /** Input: The working directory at which the resolution of the path starts. */
  fd: fd,
  /** Input: The path at which to create the directory. */
  path: ptr<char>,
  /** Input: The path at which to create the directory. */
  path_len: usize
): errno;

/** Return the attributes of a file or directory. */
// @ts-ignore: decorator
@unsafe
export declare function path_filestat_get(
  /** Input: The working directory at which the resolution of the path starts. */
  fd: fd,
  /** Input: Flags determining the method of how the path is resolved. */
  flags: lookupflags,
  /** Input: The path of the file or directory to inspect. */
  path: ptr<char>,
  /** Input: The path of the file or directory to inspect. */
  path_len: usize,
  /** Input: The buffer where the file's attributes are stored. */
  buf: struct<filestat>
): errno;

/** Adjust the timestamps of a file or directory. */
// @ts-ignore: decorator
@unsafe
export declare function path_filestat_set_times(
  /** Input: The working directory at which the resolution of the path starts. */
  fd: fd,
  /** Input: Flags determining the method of how the path is resolved. */
  flags: lookupflags,
  /** Input: The path of the file or directory to operate on. */
  path: ptr<char>,
  /** Input: The path of the file or directory to operate on. */
  path_len: usize,
  /** Input: The desired values of the data access timestamp. */
  st_atim: timestamp,
  /** Input: The desired values of the data modification timestamp. */
  st_mtim: timestamp,
  /** Input: A bitmask indicating which timestamps to adjust. */
  fstflags: fstflags
): errno;

/** Create a hard link. */
// @ts-ignore: decorator
@unsafe
export declare function path_link(
  /** Input: The working directory at which the resolution of the old path starts. */
  old_fd: fd,
  /** Input: Flags determining the method of how the path is resolved. */
  old_flags: lookupflags,
  /** Input: The source path from which to link. */
  old_path: ptr<char>,
  /** Input: The source path from which to link. */
  old_path_len: usize,
  /** Input: The working directory at which the resolution of the new path starts. */
  new_fd: fd,
  /** Input: The destination path at which to create the hard link. */
  new_path: ptr<char>,
  /** Input: The length of the destination path at which to create the hard link. */
  new_path_len: usize
): errno;

/** Open a file or directory. */
// @ts-ignore: decorator
@unsafe
export declare function path_open(
  /** Input: The working directory at which the resolution of the path starts. */
  dirfd: fd,
  /** Input: Flags determining the method of how the path is resolved. */
  dirflags: lookupflags,
  /** Input: The path of the file or directory to open. */
  path: ptr<char>,
  /** Input: The length of the path of the file or directory to open. */
  path_len: usize,
  /** Input: The method by which to open the file. */
  oflags: oflags,
  /** Input: The initial base rights that apply to operations using the file descriptor itself. */
  fs_rights_base: rights,
  /** Input: The initial inheriting rights that apply to file descriptors derived from it. */
  fs_rights_inheriting: rights,
  /** Input: The initial flags of the file descriptor. */
  fs_flags: fdflags,
  /** Output: The file descriptor of the file that has been opened. */
  fd: ptr<fd>
): errno;

/** Read the contents of a symbolic link. */
// @ts-ignore: decorator
@unsafe
export declare function path_readlink(
  /** Input: The working directory at which the resolution of the path starts. */
  fd: fd,
  /** Input: The path of the symbolic link from which to read. */
  path: ptr<char>,
  /** Input: The length of the path of the symbolic link from which to read. */
  path_len: usize,
  /** Input: The buffer to which to write the contents of the symbolic link. */
  buf: ptr<char>,
  /** Input: The length of the buffer to which to write the contents of the symbolic link. */
  buf_len: usize,
  /** Output: The number of bytes placed in the buffer. */
  buf_used: ptr<usize>
): errno;

/** Remove a directory. */
// @ts-ignore: decorator
@unsafe
export declare function path_remove_directory(
  /** Input: The working directory at which the resolution of the path starts. */
  fd: fd,
  /** Input: The path to a directory to remove. */
  path: ptr<char>,
  /** Input: The length of the path to a directory to remove. */
  path_len: usize
): errno;

/** Rename a file or directory. */
// @ts-ignore: decorator
@unsafe
export declare function path_rename(
  /** Input: The working directory at which the resolution of the old path starts. */
  old_fd: fd,
  /** Input: The source path of the file or directory to rename. */
  old_path: ptr<char>,
  /** Input: The length of the source path of the file or directory to rename. */
  old_path_len: usize,
  /** Input: The working directory at which the resolution of the new path starts. */
  new_fd: fd,
  /** Input: The destination path to which to rename the file or directory. */
  new_path: ptr<char>,
  /** Input: The length of the destination path to which to rename the file or directory. */
  new_path_len: usize
): errno;

/** Create a symbolic link. */
// @ts-ignore: decorator
@unsafe
export declare function path_symlink(
  /** Input: The contents of the symbolic link. */
  old_path: ptr<char>,
  /** Input: The length of the contents of the symbolic link. */
  old_path_len: usize,
  /** Input: The working directory at which the resolution of the path starts. */
  fd: fd,
  /** Input: The destination path at which to create the symbolic link. */
  new_path: ptr<char>,
  /** Input: The length of the destination path at which to create the symbolic link. */
  new_path_len: usize
): errno;

/** Unlink a file. */
// @ts-ignore: decorator
@unsafe
export declare function path_unlink_file(
  /** Input: The working directory at which the resolution of the path starts. */
  fd: fd,
  /** Input: The path to a file to unlink. */
  path: ptr<char>,
  /** Input: The length of the path to a file to unlink. */
  path_len: usize
): errno;

/** Concurrently poll for the occurrence of a set of events. */
// @ts-ignore: decorator
@unsafe
export declare function poll_oneoff(
  /** Input: The events to which to subscribe. */
  in_: ptr<struct<subscription>>,
  /** Input: The events that have occurred. */
  out: ptr<struct<event>>,
  /** Input: Both the number of subscriptions and events. */
  nsubscriptions: usize,
  /** Output: The number of events stored. */
  nevents: ptr<usize>
): errno;

/** Terminate the process normally. An exit code of 0 indicates successful termination of the program. The meanings of other values is dependent on the environment. */
// @ts-ignore: decorator
@unsafe
export declare function proc_exit(
  /** Input: The exit code returned by the process. */
  rval: u32
): void;

/** Send a signal to the process of the calling thread. */
// @ts-ignore: decorator
@unsafe
export declare function proc_raise(
  /** Input: The signal condition to trigger. */
  sig: signal
): errno;

/** Write high-quality random data into a buffer. */
// @ts-ignore: decorator
@unsafe
export declare function random_get(
  /** Input: The buffer to fill with random data. */
  buf: usize,
  /** Input: The length of the buffer to fill with random data. */
  buf_len: usize
): errno;

/** Temporarily yield execution of the calling thread. */
// @ts-ignore: decorator
@unsafe
export declare function sched_yield(): errno;

/** Receive a message from a socket. */
// @ts-ignore: decorator
@unsafe
export declare function sock_recv(
  /** Input: The socket on which to receive data. */
  sock: fd,
  /** Input: List of scatter/gather vectors to which to store data. */
  ri_data: ptr<struct<iovec>>,
  /** Input: The length of the list of scatter/gather vectors to which to store data. */
  ri_data_len: usize,
  /** Input: Message flags. */
  ri_flags: riflags,
  /** Output: Number of bytes stored in `ri_data`. */
  ro_datalen: ptr<usize>,
  /** Output: Message flags. */
  ro_flags: ptr<roflags>
): errno;

/** Send a message on a socket. */
// @ts-ignore: decorator
@unsafe
export declare function sock_send(
  /** Input: The socket on which to send data. */
  sock: fd,
  /** Input: List of scatter/gather vectors to which to retrieve data */
  si_data: ptr<struct<iovec>>,
  /** Input: The length of the list of scatter/gather vectors to which to retrieve data */
  si_data_len: usize,
  /** Input: Message flags. */
  si_flags: siflags,
  /** Output: Number of bytes transmitted. */
  so_datalen: ptr<usize>
): errno;

/** Shut down socket send and receive channels. */
// @ts-ignore: decorator
@unsafe
export declare function sock_shutdown(
  /** Input: The socket on which to shutdown channels. */
  sock: fd,
  /** Input: Which channels on the socket to shut down. */
  how: sdflags
): errno;

// === Types ======================================================================================

/** File or memory access pattern advisory information. */
export namespace advice {
  /** The application has no advice to give on its behavior with respect to the specified data. */
  // @ts-ignore: decorator
  @inline
  export const NORMAL: advice = 0;
  /** The application expects to access the specified data sequentially from lower offsets to higher offsets. */
  // @ts-ignore: decorator
  @inline
  export const SEQUENTIAL : advice = 1;
  /** The application expects to access the specified data in a random order. */
  // @ts-ignore: decorator
  @inline
  export const RANDOM: advice = 2;
  /** The application expects to access the specified data in the near future. */
  // @ts-ignore: decorator
  @inline
  export const WILLNEED: advice = 3;
  /** The application expects that it will not access the specified data in the near future. */
  // @ts-ignore: decorator
  @inline
  export const DONTNEED: advice = 4;
  /** The application expects to access the specified data once and then not reuse it thereafter. */
  // @ts-ignore: decorator
  @inline
  export const NOREUSE: advice = 5;
}
export type advice = u8;

/** Identifiers for clocks. */
export namespace clockid {
  /** The clock measuring real time. Time value zero corresponds with 1970-01-01T00:00:00Z. */
  // @ts-ignore: decorator
  @inline
  export const REALTIME: clockid = 0;
  /** The store-wide monotonic clock. Absolute value has no meaning. */
  // @ts-ignore: decorator
  @inline
  export const MONOTONIC: clockid = 1;
  /** The CPU-time clock associated with the current process. */
  // @ts-ignore: decorator
  @inline
  export const PROCESS_CPUTIME_ID: clockid = 2;
  /** The CPU-time clock associated with the current thread. */
  // @ts-ignore: decorator
  @inline
  export const THREAD_CPUTIME_ID: clockid = 3;
}
export type clockid = u32;

/** Identifier for a device containing a file system. Can be used in combination with `inode` to uniquely identify a file or directory in the filesystem. */
export type device = u64;

/** A reference to the offset of a directory entry. */
export type dircookie = u64;

/** A directory entry. */
@unmanaged export class dirent {
  /** The offset of the next directory entry stored in this directory. */
  next: dircookie;
  /** The serial number of the file referred to by this directory entry. */
  ino: inode;
  /** The length of the name of the directory entry. */
  namlen: u32;
  /** The type of the file referred to by this directory entry. */
  type: filetype;
  private __padding0: u16;
}

/** Error codes returned by functions. */
export namespace errno {
  /** No error occurred. System call completed successfully. */
  // @ts-ignore: decorator
  @inline
  export const SUCCESS: errno = 0;
  /** Argument list too long. */
  // @ts-ignore: decorator
  @inline
  export const TOOBIG: errno = 1;
  /** Permission denied. */
  // @ts-ignore: decorator
  @inline
  export const ACCES: errno = 2;
  /** Address in use. */
  // @ts-ignore: decorator
  @inline
  export const ADDRINUSE: errno = 3;
  /** Address not available. */
  // @ts-ignore: decorator
  @inline
  export const ADDRNOTAVAIL: errno = 4;
  /** Address family not supported. */
  // @ts-ignore: decorator
  @inline
  export const AFNOSUPPORT: errno = 5;
  /** Resource unavailable, or operation would block. */
  // @ts-ignore: decorator
  @inline
  export const AGAIN: errno = 6;
  /** Connection already in progress. */
  // @ts-ignore: decorator
  @inline
  export const ALREADY: errno = 7;
  /** Bad file descriptor. */
  // @ts-ignore: decorator
  @inline
  export const BADF: errno = 8;
  /** Bad message. */
  // @ts-ignore: decorator
  @inline
  export const BADMSG: errno = 9;
  /** Device or resource busy. */
  // @ts-ignore: decorator
  @inline
  export const BUSY: errno = 10;
  /** Operation canceled. */
  // @ts-ignore: decorator
  @inline
  export const CANCELED: errno = 11;
  /** No child processes. */
  // @ts-ignore: decorator
  @inline
  export const CHILD: errno = 12;
  /** Connection aborted. */
  // @ts-ignore: decorator
  @inline
  export const CONNABORTED: errno = 13;
  /** Connection refused. */
  // @ts-ignore: decorator
  @inline
  export const CONNREFUSED: errno = 14;
  /** Connection reset. */
  // @ts-ignore: decorator
  @inline
  export const CONNRESET: errno = 15;
  /** Resource deadlock would occur. */
  // @ts-ignore: decorator
  @inline
  export const DEADLK: errno = 16;
  /** Destination address required. */
  // @ts-ignore: decorator
  @inline
  export const DESTADDRREQ: errno = 17;
  /** Mathematics argument out of domain of function. */
  // @ts-ignore: decorator
  @inline
  export const DOM: errno = 18;
  /** Reserved. */
  // @ts-ignore: decorator
  @inline
  export const DQUOT: errno = 19;
  /** File exists. */
  // @ts-ignore: decorator
  @inline
  export const EXIST: errno = 20;
  /** Bad address. */
  // @ts-ignore: decorator
  @inline
  export const FAULT: errno = 21;
  /** File too large. */
  // @ts-ignore: decorator
  @inline
  export const FBIG: errno = 22;
  /** Host is unreachable. */
  // @ts-ignore: decorator
  @inline
  export const HOSTUNREACH: errno = 23;
  /** Identifier removed. */
  // @ts-ignore: decorator
  @inline
  export const IDRM: errno = 24;
  /** Illegal byte sequence. */
  // @ts-ignore: decorator
  @inline
  export const ILSEQ: errno = 25;
  /** Operation in progress. */
  // @ts-ignore: decorator
  @inline
  export const INPROGRESS: errno = 26;
  /** Interrupted function. */
  // @ts-ignore: decorator
  @inline
  export const INTR: errno = 27;
  /** Invalid argument. */
  // @ts-ignore: decorator
  @inline
  export const INVAL: errno = 28;
  /** I/O error. */
  // @ts-ignore: decorator
  @inline
  export const IO: errno = 29;
  /** Socket is connected. */
  // @ts-ignore: decorator
  @inline
  export const ISCONN: errno = 30;
  /** Is a directory. */
  // @ts-ignore: decorator
  @inline
  export const ISDIR: errno = 31;
  /** Too many levels of symbolic links. */
  // @ts-ignore: decorator
  @inline
  export const LOOP: errno = 32;
  /** File descriptor value too large. */
  // @ts-ignore: decorator
  @inline
  export const MFILE: errno = 33;
  /** Too many links. */
  // @ts-ignore: decorator
  @inline
  export const MLINK: errno = 34;
  /** Message too large. */
  // @ts-ignore: decorator
  @inline
  export const MSGSIZE: errno = 35;
  /** Reserved. */
  // @ts-ignore: decorator
  @inline
  export const MULTIHOP: errno = 36;
  /** Filename too long. */
  // @ts-ignore: decorator
  @inline
  export const NAMETOOLONG: errno = 37;
  /** Network is down. */
  // @ts-ignore: decorator
  @inline
  export const NETDOWN: errno = 38;
  /** Connection aborted by network. */
  // @ts-ignore: decorator
  @inline
  export const NETRESET: errno = 39;
  /** Network unreachable. */
  // @ts-ignore: decorator
  @inline
  export const NETUNREACH: errno = 40;
  /** Too many files open in system. */
  // @ts-ignore: decorator
  @inline
  export const NFILE: errno = 41;
  /** No buffer space available. */
  // @ts-ignore: decorator
  @inline
  export const NOBUFS: errno = 42;
  /** No such device. */
  // @ts-ignore: decorator
  @inline
  export const NODEV: errno = 43;
  /** No such file or directory. */
  // @ts-ignore: decorator
  @inline
  export const NOENT: errno = 44;
  /** Executable file format error. */
  // @ts-ignore: decorator
  @inline
  export const NOEXEC: errno = 45;
  /** No locks available. */
  // @ts-ignore: decorator
  @inline
  export const NOLCK: errno = 46;
  /** Reserved. */
  // @ts-ignore: decorator
  @inline
  export const NOLINK: errno = 47;
  /** Not enough space. */
  // @ts-ignore: decorator
  @inline
  export const NOMEM: errno = 48;
  /** No message of the desired type. */
  // @ts-ignore: decorator
  @inline
  export const NOMSG: errno = 49;
  /** Protocol not available. */
  // @ts-ignore: decorator
  @inline
  export const NOPROTOOPT: errno = 50;
  /** No space left on device. */
  // @ts-ignore: decorator
  @inline
  export const NOSPC: errno = 51;
  /** Function not supported. */
  // @ts-ignore: decorator
  @inline
  export const NOSYS: errno = 52;
  /** The socket is not connected. */
  // @ts-ignore: decorator
  @inline
  export const NOTCONN: errno = 53;
  /** Not a directory or a symbolic link to a directory. */
  // @ts-ignore: decorator
  @inline
  export const NOTDIR: errno = 54;
  /** Directory not empty. */
  // @ts-ignore: decorator
  @inline
  export const NOTEMPTY: errno = 55;
  /** State not recoverable. */
  // @ts-ignore: decorator
  @inline
  export const NOTRECOVERABLE: errno = 56;
  /** Not a socket. */
  // @ts-ignore: decorator
  @inline
  export const NOTSOCK: errno = 57;
  /** Not supported, or operation not supported on socket. */
  // @ts-ignore: decorator
  @inline
  export const NOTSUP: errno = 58;
  /** Inappropriate I/O control operation. */
  // @ts-ignore: decorator
  @inline
  export const NOTTY: errno = 59;
  /** No such device or address. */
  // @ts-ignore: decorator
  @inline
  export const NXIO: errno = 60;
  /** Value too large to be stored in data type. */
  // @ts-ignore: decorator
  @inline
  export const OVERFLOW: errno = 61;
  /** Previous owner died. */
  // @ts-ignore: decorator
  @inline
  export const OWNERDEAD: errno = 62;
  /** Operation not permitted. */
  // @ts-ignore: decorator
  @inline
  export const PERM: errno = 63;
  /** Broken pipe. */
  // @ts-ignore: decorator
  @inline
  export const PIPE: errno = 64;
  /** Protocol error. */
  // @ts-ignore: decorator
  @inline
  export const PROTO: errno = 65;
  /** Protocol not supported. */
  // @ts-ignore: decorator
  @inline
  export const PROTONOSUPPORT: errno = 66;
  /** Protocol wrong type for socket. */
  // @ts-ignore: decorator
  @inline
  export const PROTOTYPE: errno = 67;
  /** Result too large. */
  // @ts-ignore: decorator
  @inline
  export const RANGE: errno = 68;
  /** Read-only file system. */
  // @ts-ignore: decorator
  @inline
  export const ROFS: errno = 69;
  /** Invalid seek. */
  // @ts-ignore: decorator
  @inline
  export const SPIPE: errno = 70;
  /** No such process. */
  // @ts-ignore: decorator
  @inline
  export const SRCH: errno = 71;
  /** Reserved. */
  // @ts-ignore: decorator
  @inline
  export const STALE: errno = 72;
  /** Connection timed out. */
  // @ts-ignore: decorator
  @inline
  export const TIMEDOUT: errno = 73;
  /** Text file busy. */
  // @ts-ignore: decorator
  @inline
  export const TXTBSY: errno = 74;
  /** Cross-device link. */
  // @ts-ignore: decorator
  @inline
  export const XDEV: errno = 75;
  /** Extension: Capabilities insufficient. */
  // @ts-ignore: decorator
  @inline
  export const NOTCAPABLE: errno = 76;
}
export type errno = u16;

/** An event that occurred. */
@unmanaged export abstract class event {
  /** User-provided value that got attached to `subscription#userdata`. */
  userdata: userdata;
  /** If non-zero, an error that occurred while processing the subscription request. */
  error: errno;
  /* The type of the event that occurred. */
  type: eventtype;
  private __padding0: u16;
}

/** An event that occurred when type is `eventtype.FD_READ` or `eventtype.FD_WRITE`. */
@unmanaged export class rwevent extends event {
  /* The number of bytes available for reading or writing. */
  nbytes: filesize;
  /* The state of the file descriptor. */
  flags: eventrwflags;
  private __padding1: u32;
}

/** The state of the file descriptor subscribed to with `eventtype.FD_READ` or `eventtype.FD_WRITE`. */
export namespace eventrwflags {
  /** The peer of this socket has closed or disconnected. */
  // @ts-ignore: decorator
  @inline
  export const HANGUP: eventrwflags = 1;
}
export type eventrwflags = u16;

/** Type of a subscription to an event or its occurrence. */
export namespace eventtype {
  /** The time value of clock has reached the timestamp. */
  // @ts-ignore: decorator
  @inline
  export const CLOCK: eventtype = 0;
  /** File descriptor has data available for reading. */
  // @ts-ignore: decorator
  @inline
  export const FD_READ: eventtype = 1;
  /** File descriptor has capacity available for writing */
  // @ts-ignore: decorator
  @inline
  export const FD_WRITE: eventtype = 2;
}
export type eventtype = u8;

/** Exit code generated by a process when exiting. */
export type exitcode = u32;

/** A file descriptor number. */
export type fd = u32;

/** File descriptor flags. */
export namespace fdflags {
  /** Append mode: Data written to the file is always appended to the file's end. */
  // @ts-ignore: decorator
  @inline
  export const APPEND: fdflags = 1;
  /** Write according to synchronized I/O data integrity completion. Only the data stored in the file is synchronized. */
  // @ts-ignore: decorator
  @inline
  export const DSYNC: fdflags = 2;
  /** Non-blocking mode. */
  // @ts-ignore: decorator
  @inline
  export const NONBLOCK: fdflags = 4;
  /** Synchronized read I/O operations. */
  // @ts-ignore: decorator
  @inline
  export const RSYNC: fdflags = 8;
  /** Write according to synchronized I/O file integrity completion. */
  // @ts-ignore: decorator
  @inline
  export const SYNC: fdflags = 16;
}
export type fdflags = u16;

/** File descriptor attributes. */
@unmanaged export class fdstat {
  /** File type. */
  filetype: filetype;
  /** File descriptor flags. */
  flags: fdflags;
  /** Rights that apply to this file descriptor. */
  rights_base: rights;
  /** Maximum set of rights that may be installed on new file descriptors that are created through this file descriptor, e.g., through `path_open`. */
  rights_inheriting: rights;
}

/** Relative offset within a file. */
export type filedelta = i64;

/** Non-negative file size or length of a region within a file. */
export type filesize = u64;

/** File attributes. */
@unmanaged export class filestat {
  /** Device ID of device containing the file. */
  dev: device;
  /** File serial number. */
  ino: inode;
  /** File type. */
  filetype: filetype;
  /** Number of hard links to the file. */
  nlink: linkcount;
  /** For regular files, the file size in bytes. For symbolic links, the length in bytes of the pathname contained in the symbolic link. */
  size: filesize;
  /** Last data access timestamp. */
  atim: timestamp;
  /** Last data modification timestamp. */
  mtim: timestamp;
  /** Last file status change timestamp. */
  ctim: timestamp;
}

/** The type of a file descriptor or file. */
export namespace filetype {
  /** The type of the file descriptor or file is unknown or is different from any of the other types specified. */
  // @ts-ignore: decorator
  @inline
  export const UNKNOWN: filetype = 0;
  /** The file descriptor or file refers to a block device inode. */
  // @ts-ignore: decorator
  @inline
  export const BLOCK_DEVICE: filetype = 1;
  /** The file descriptor or file refers to a character device inode. */
  // @ts-ignore: decorator
  @inline
  export const CHARACTER_DEVICE: filetype = 2;
  /** The file descriptor or file refers to a directory inode. */
  // @ts-ignore: decorator
  @inline
  export const DIRECTORY: filetype = 3;
  /** The file descriptor or file refers to a regular file inode. */
  // @ts-ignore: decorator
  @inline
  export const REGULAR_FILE: filetype = 4;
  /** The file descriptor or file refers to a datagram socket. */
  // @ts-ignore: decorator
  @inline
  export const SOCKET_DGRAM: filetype = 5;
  /** The file descriptor or file refers to a byte-stream socket. */
  // @ts-ignore: decorator
  @inline
  export const SOCKET_STREAM: filetype = 6;
  /** The file refers to a symbolic link inode. */
  // @ts-ignore: decorator
  @inline
  export const SYMBOLIC_LINK: filetype = 7;
}
export type filetype = u8;

/** Which file time attributes to adjust. */
export namespace fstflags {
  /** Adjust the last data access timestamp to the value stored in `filestat#st_atim`. */
  // @ts-ignore: decorator
  @inline
  export const SET_ATIM: fstflags = 1;
  /** Adjust the last data access timestamp to the time of clock `clockid.REALTIME`. */
  // @ts-ignore: decorator
  @inline
  export const SET_ATIM_NOW: fstflags = 2;
  /** Adjust the last data modification timestamp to the value stored in `filestat#st_mtim`. */
  // @ts-ignore: decorator
  @inline
  export const SET_MTIM: fstflags = 4;
  /** Adjust the last data modification timestamp to the time of clock `clockid.REALTIME`. */
  // @ts-ignore: decorator
  @inline
  export const SET_MTIM_NOW: fstflags = 8;
}
export type fstflags = u16;

/** File serial number that is unique within its file system. */
export type inode = u64;

/** A region of memory for scatter/gather reads. */
@unmanaged export class iovec {
  /** The address of the buffer to be filled. */
  buf: usize;
  /** The length of the buffer to be filled. */
  buf_len: usize;
}

/** Number of hard links to an inode. */
export type linkcount = u32;

/** Flags determining the method of how paths are resolved. */
export namespace lookupflags {
  /** As long as the resolved path corresponds to a symbolic link, it is expanded. */
  // @ts-ignore: decorator
  @inline
  export const SYMLINK_FOLLOW: lookupflags = 1;
}
export type lookupflags = u32;

/** Open flags. */
export namespace oflags {
  /** Create file if it does not exist. */
  // @ts-ignore: decorator
  @inline
  export const CREAT: oflags = 1;
  /** Fail if not a directory. */
  // @ts-ignore: decorator
  @inline
  export const DIRECTORY: oflags = 2;
  /** Fail if file already exists. */
  // @ts-ignore: decorator
  @inline
  export const EXCL: oflags = 4;
  /** Truncate file to size 0. */
  // @ts-ignore: decorator
  @inline
  export const TRUNC: oflags = 8;
}
export type oflags = u16;

// TODO: undocumented
export namespace preopentype {
  // @ts-ignore: decorator
  @inline
  export const DIR: preopentype = 0;
}
export type preopentype = u8;

// TODO: undocumented
export abstract class prestat {
  type: preopentype;
}

// TODO: undocumented
export class dirprestat extends prestat {
  name_len: usize;
}

/** Flags provided to `sock_recv`. */
export namespace riflags {
  /** Returns the message without removing it from the socket's receive queue. */
  // @ts-ignore: decorator
  @inline
  export const PEEK: riflags = 1;
  /** On byte-stream sockets, block until the full amount of data can be returned. */
  // @ts-ignore: decorator
  @inline
  export const WAITALL: riflags = 2;
}
export type riflags = u16;

/** File descriptor rights, determining which actions may be performed. */
export namespace rights {
  /** The right to invoke `fd_datasync`. */
  // @ts-ignore: decorator
  @inline
  export const FD_DATASYNC: rights = 1;
  /** The right to invoke `fd_read` and `sock_recv`. */
  // @ts-ignore: decorator
  @inline
  export const FD_READ: rights = 2;
  /** The right to invoke `fd_seek`. This flag implies `rights.FD_TELL`. */
  // @ts-ignore: decorator
  @inline
  export const FD_SEEK: rights = 4;
  /** The right to invoke `fd_fdstat_set_flags`. */
  // @ts-ignore: decorator
  @inline
  export const FD_FDSTAT_SET_FLAGS: rights = 8;
  /** The right to invoke `fd_sync`. */
  // @ts-ignore: decorator
  @inline
  export const FD_SYNC: rights = 16;
  /** The right to invoke `fd_seek` in such a way that the file offset remains unaltered (i.e., `whence.CUR` with offset zero), or to invoke `fd_tell`). */
  // @ts-ignore: decorator
  @inline
  export const FD_TELL: rights = 32;
  /** The right to invoke `fd_write` and `sock_send`. If `rights.FD_SEEK` is set, includes the right to invoke `fd_pwrite`. */
  // @ts-ignore: decorator
  @inline
  export const FD_WRITE: rights = 64;
  /** The right to invoke `fd_advise`. */
  // @ts-ignore: decorator
  @inline
  export const FD_ADVISE: rights = 128;
  /** The right to invoke `fd_allocate`. */
  // @ts-ignore: decorator
  @inline
  export const FD_ALLOCATE: rights = 256;
  /** The right to invoke `path_create_directory`. */
  // @ts-ignore: decorator
  @inline
  export const PATH_CREATE_DIRECTORY: rights = 512;
  /** If `rights.PATH_OPEN` is set, the right to invoke `path_open` with `oflags.CREAT`. */
  // @ts-ignore: decorator
  @inline
  export const PATH_CREATE_FILE: rights = 1024;
  /** The right to invoke `path_link` with the file descriptor as the source directory. */
  // @ts-ignore: decorator
  @inline
  export const PATH_LINK_SOURCE: rights = 2048;
  /** The right to invoke `path_link` with the file descriptor as the target directory. */
  // @ts-ignore: decorator
  @inline
  export const PATH_LINK_TARGET: rights = 4096;
  /** The right to invoke `path_open`. */
  // @ts-ignore: decorator
  @inline
  export const PATH_OPEN: rights = 8192;
  /** The right to invoke `fd_readdir`. */
  // @ts-ignore: decorator
  @inline
  export const FD_READDIR: rights = 16384;
  /** The right to invoke `path_readlink`. */
  // @ts-ignore: decorator
  @inline
  export const PATH_READLINK: rights = 32768;
  /** The right to invoke `path_rename` with the file descriptor as the source directory. */
  // @ts-ignore: decorator
  @inline
  export const PATH_RENAME_SOURCE: rights = 65536;
  /** The right to invoke `path_rename` with the file descriptor as the target directory. */
  // @ts-ignore: decorator
  @inline
  export const PATH_RENAME_TARGET: rights = 131072;
  /** The right to invoke `path_filestat_get`. */
  // @ts-ignore: decorator
  @inline
  export const PATH_FILESTAT_GET: rights = 262144;
  /** The right to change a file's size (there is no `path_filestat_set_size`). If `rights.PATH_OPEN` is set, includes the right to invoke `path_open` with `oflags.TRUNC`. */
  // @ts-ignore: decorator
  @inline
  export const PATH_FILESTAT_SET_SIZE: rights = 524288;
  /** The right to invoke `path_filestat_set_times`. */
  // @ts-ignore: decorator
  @inline
  export const PATH_FILESTAT_SET_TIMES: rights = 1048576;
  /** The right to invoke `fd_filestat_get`. */
  // @ts-ignore: decorator
  @inline
  export const FD_FILESTAT_GET: rights = 2097152;
  /** The right to invoke `fd_filestat_set_size`. */
  // @ts-ignore: decorator
  @inline
  export const FD_FILESTAT_SET_SIZE: rights = 4194304;
  /** The right to invoke `fd_filestat_set_times`. */
  // @ts-ignore: decorator
  @inline
  export const FD_FILESTAT_SET_TIMES: rights = 8388608;
  /** The right to invoke `path_symlink`. */
  // @ts-ignore: decorator
  @inline
  export const RIGHT_PATH_SYMLINK: rights = 16777216;
  /** The right to invoke `path_remove_directory`. */
  // @ts-ignore: decorator
  @inline
  export const PATH_REMOVE_DIRECTORY: rights = 33554432;
  /** The right to invoke `path_unlink_file`. */
  // @ts-ignore: decorator
  @inline
  export const PATH_UNLINK_FILE: rights = 67108864;
  /** If `rights.FD_READ` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype.FD_READ`. If `rights.FD_WRITE` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype.FD_WRITE`. */
  // @ts-ignore: decorator
  @inline
  export const POLL_FD_READWRITE: rights = 134217728;
  /** The right to invoke `sock_shutdown`. */
  // @ts-ignore: decorator
  @inline
  export const SOCK_SHUTDOWN: rights = 268435456;
}
export type rights = u64;

/** Flags returned by `sock_recv`. */
export namespace roflags {
  /** Message data has been truncated. */
  // @ts-ignore: decorator
  @inline
  export const DATA_TRUNCATED: roflags = 1;
}
export type roflags = u16;

/** Which channels on a socket to shut down. */
export namespace sdflags {
  /** Disables further receive operations. */
  // @ts-ignore: decorator
  @inline
  export const RD: sdflags = 1;
  /** Disables further send operations. */
  // @ts-ignore: decorator
  @inline
  export const WR: sdflags = 2;
}
export type sdflags = u8;

/** Flags provided to `sock_send`. */
export namespace siflags {
  // As there are currently no flags defined, it must be set to zero.
}
export type siflags = u16;

/** Signal condition. */
export namespace signal {
  /** Hangup. */
  // @ts-ignore: decorator
  @inline
  export const HUP: signal = 1;
  /** Terminate interrupt signal. */
  // @ts-ignore: decorator
  @inline
  export const INT: signal = 2;
  /** Terminal quit signal. */
  // @ts-ignore: decorator
  @inline
  export const QUIT: signal = 3;
  /** Illegal instruction. */
  // @ts-ignore: decorator
  @inline
  export const ILL: signal = 4;
  /** Trace/breakpoint trap. */
  // @ts-ignore: decorator
  @inline
  export const TRAP: signal = 5;
  /** Process abort signal. */
  // @ts-ignore: decorator
  @inline
  export const ABRT: signal = 6;
  /** Access to an undefined portion of a memory object. */
  // @ts-ignore: decorator
  @inline
  export const BUS: signal = 7;
  /** Erroneous arithmetic operation. */
  // @ts-ignore: decorator
  @inline
  export const FPE: signal = 8;
  /** Kill. */
  // @ts-ignore: decorator
  @inline
  export const KILL: signal = 9;
  /** User-defined signal 1. */
  // @ts-ignore: decorator
  @inline
  export const USR1: signal = 10;
  /** Invalid memory reference. */
  // @ts-ignore: decorator
  @inline
  export const SEGV: signal = 11;
  /** User-defined signal 2. */
  // @ts-ignore: decorator
  @inline
  export const USR2: signal = 12;
  /** Write on a pipe with no one to read it. */
  // @ts-ignore: decorator
  @inline
  export const PIPE: signal = 13;
  /** Alarm clock. */
  // @ts-ignore: decorator
  @inline
  export const ALRM: signal = 14;
  /** Termination signal. */
  // @ts-ignore: decorator
  @inline
  export const TERM: signal = 15;
  /** Child process terminated, stopped, or continued. */
  // @ts-ignore: decorator
  @inline
  export const CHLD: signal = 16;
  /** Continue executing, if stopped. */
  // @ts-ignore: decorator
  @inline
  export const CONT: signal = 17;
  /** Stop executing. */
  // @ts-ignore: decorator
  @inline
  export const STOP: signal = 18;
  /** Terminal stop signal. */
  // @ts-ignore: decorator
  @inline
  export const TSTP: signal = 19;
  /** Background process attempting read. */
  // @ts-ignore: decorator
  @inline
  export const TTIN: signal = 20;
  /** Background process attempting write. */
  // @ts-ignore: decorator
  @inline
  export const TTOU: signal = 21;
  /** High bandwidth data is available at a socket. */
  // @ts-ignore: decorator
  @inline
  export const URG: signal = 22;
  /** CPU time limit exceeded. */
  // @ts-ignore: decorator
  @inline
  export const XCPU: signal = 23;
  /** File size limit exceeded. */
  // @ts-ignore: decorator
  @inline
  export const XFSZ: signal = 24;
  /** Virtual timer expired. */
  // @ts-ignore: decorator
  @inline
  export const VTALRM: signal = 25;
  // @ts-ignore: decorator
  @inline
  export const PROF: signal = 26;
  // @ts-ignore: decorator
  @inline
  export const WINCH: signal = 27;
  // @ts-ignore: decorator
  @inline
  export const POLL: signal = 28;
  // @ts-ignore: decorator
  @inline
  export const PWR: signal = 29;
  /** Bad system call. */
  // @ts-ignore: decorator
  @inline
  export const SYS: signal = 30;
}
export type signal = u8;

/** Flags determining how to interpret the timestamp provided in `subscription_t::u.clock.timeout. */
export namespace subclockflags {
  /** If set, treat the timestamp provided in `clocksubscription` as an absolute timestamp. */
  // @ts-ignore: decorator
  @inline
  export const ABSTIME: subclockflags = 1;
}
export type subclockflags = u16;

/** Subscription to an event. */
@unmanaged export abstract class subscription {
  /** User-provided value that is attached to the subscription. */
  userdata: userdata;
  /** The type of the event to which to subscribe. */
  type: eventtype;
  private __padding0: u32;
}

/* Subscription to an event of type `eventtype.CLOCK`.**/
@unmanaged export class clocksubscription extends subscription {
  /** The user-defined unique identifier of the clock. */
  identifier: userdata;
  /** The clock against which to compare the timestamp. */
  clock_id: clockid;
  /** The absolute or relative timestamp. */
  timeout: timestamp;
  /** The amount of time that the implementation may wait additionally to coalesce with other events. */
  precision: timestamp;
  /** Flags specifying whether the timeout is absolute or relative. */
  flags: subclockflags;
  private __padding1: u32;
}

/* Subscription to an event of type `eventtype.FD_READ` or `eventtype.FD_WRITE`.**/
@unmanaged export class fdsubscription extends subscription {
  /** The file descriptor on which to wait for it to become ready for reading or writing. */
  fd: fd;
}

/** Timestamp in nanoseconds. */
export type timestamp = u64;

/** User-provided value that may be attached to objects that is retained when extracted from the implementation. */
export type userdata = u64;

/** The position relative to which to set the offset of the file descriptor. */
export namespace whence {
  /** Seek relative to current position. */
  // @ts-ignore: decorator
  @inline
  export const CUR: whence = 0;
  /** Seek relative to end-of-file. */
  // @ts-ignore: decorator
  @inline
  export const END: whence = 1;
  /** Seek relative to start-of-file. */
  // @ts-ignore: decorator
  @inline
  export const SET: whence = 2;
}
export type whence = u8;
'''
'''--- std/assembly/builtins.ts ---
type auto = i32;

// @ts-ignore: decorator
@builtin
export declare function isInteger<T>(value?: T): bool;

// @ts-ignore: decorator
@builtin
export declare function isFloat<T>(value?: T): bool;

// @ts-ignore: decorator
@builtin
export declare function isBoolean<T>(value?: T): bool;

// @ts-ignore: decorator
@builtin
export declare function isSigned<T>(value?: T): bool;

// @ts-ignore: decorator
@builtin
export declare function isReference<T>(value?: T): bool;

// @ts-ignore: decorator
@builtin
export declare function isString<T>(value?: T): bool;

// @ts-ignore: decorator
@builtin
export declare function isArray<T>(value?: T): bool;

// @ts-ignore: decorator
@builtin
export declare function isArrayLike<T>(value?: T): bool;

// @ts-ignore: decorator
@builtin
export declare function isFunction<T>(value?: T): bool;

// @ts-ignore: decorator
@builtin
export declare function isNullable<T>(value?: T): bool;

// @ts-ignore: decorator
@builtin
export declare function isDefined(expression: auto): bool;

// @ts-ignore: decorator
@builtin
export declare function isConstant(expression: auto): bool;

// @ts-ignore: decorator
@builtin
export declare function isManaged<T>(value?: T): bool;

// @ts-ignore: decorator
@builtin
export declare function isVoid<T>(): bool;

// @ts-ignore
@builtin
export declare function lengthof<T>(func?: T): i32;

// @ts-ignore: decorator
@builtin
export declare function clz<T>(value: T): T;

// @ts-ignore: decorator
@builtin
export declare function ctz<T>(value: T): T;

// @ts-ignore: decorator
@builtin
export declare function popcnt<T>(value: T): T;

// @ts-ignore: decorator
@builtin
export declare function rotl<T>(value: T, shift: T): T;

// @ts-ignore: decorator
@builtin
export declare function rotr<T>(value: T, shift: T): T;

// @ts-ignore: decorator
@builtin
export declare function abs<T>(value: T): T;

// @ts-ignore: decorator
@builtin
export declare function max<T>(left: T, right: T): T;

// @ts-ignore: decorator
@builtin
export declare function min<T>(left: T, right: T): T;

// @ts-ignore: decorator
@builtin
export declare function ceil<T>(value: T): T;

// @ts-ignore: decorator
@builtin
export declare function floor<T>(value: T): T;

// @ts-ignore: decorator
@builtin
export declare function copysign<T>(left: T, right: T): T;

// @ts-ignore: decorator
@builtin
export declare function nearest<T>(value: T): T;

// @ts-ignore: decorator
@builtin
export declare function reinterpret<T>(value: number): T;

// @ts-ignore: decorator
@builtin
export declare function sqrt<T>(value: T): T;

// @ts-ignore: decorator
@builtin
export declare function trunc<T>(value: T): T;

// @ts-ignore: decorator
@builtin
export declare function add<T>(left: T, right: T): T;

// @ts-ignore: decorator
@builtin
export declare function sub<T>(left: T, right: T): T;

// @ts-ignore: decorator
@builtin
export declare function mul<T>(left: T, right: T): T;

// @ts-ignore: decorator
@builtin
export declare function div<T>(left: T, right: T): T;

// @ts-ignore: decorator
@unsafe @builtin
export declare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;

// @ts-ignore: decorator
@unsafe @builtin
export declare function store<T>(ptr: usize, value: auto, immOffset?: usize, immAlign?: usize): void;

// @ts-ignore: decorator
@builtin
export declare function sizeof<T>(): usize; // | u32 / u64

// @ts-ignore: decorator
@builtin
export declare function alignof<T>(): usize; // | u32 / u64

// @ts-ignore: decorator
@builtin
export declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64

// @ts-ignore: decorator
@builtin
export declare function idof<T>(): u32;

// @ts-ignore
@builtin
export declare function nameof<T>(): string;

// @ts-ignore: decorator
@builtin
export declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;

// @ts-ignore: decorator
@unsafe @builtin
export declare function unreachable(): auto;

// @ts-ignore: decorator
@builtin
export declare function changetype<T>(value: auto): T;

// @ts-ignore: decorator
@builtin
export declare function assert<T>(isTrueish: T, message?: string): T;

// @ts-ignore: decorator
@unsafe @builtin
export declare function unchecked<T>(expr: T): T;

// @ts-ignore: decorator
@unsafe @builtin
export declare function call_indirect<T>(index: u32, ...args: auto[]): T;

// @ts-ignore: decorator
@builtin
export declare function instantiate<T>(...args: auto[]): T;

export namespace atomic {
  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load<T>(ptr: usize, immOffset?: usize): T;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store<T>(ptr: usize, value: T, immOffset?: usize): void;

  // @ts-ignore: decorator
  @builtin
  export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;

  // @ts-ignore: decorator
  @builtin
  export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;

  // @ts-ignore: decorator
  @builtin
  export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;

  // @ts-ignore: decorator
  @builtin
  export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;

  // @ts-ignore: decorator
  @builtin
  export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;

  // @ts-ignore: decorator
  @builtin
  export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;

  // @ts-ignore: decorator
  @builtin
  export declare function notify(ptr: usize, count: i32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function fence(): void;
}

// @ts-ignore: decorator
@lazy
export const enum AtomicWaitResult {
  OK = 0,
  NOT_EQUAL = 1,
  TIMED_OUT = 2
}

// @ts-ignore: decorator
@builtin
export declare function i8(value: auto): i8;

export namespace i8 {

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE: i8 = -128;

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE: i8 =  127;
}

// @ts-ignore: decorator
@builtin
export declare function i16(value: auto): i16;

export namespace i16 {

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE: i16 = -32768;

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE: i16 =  32767;
}

// @ts-ignore: decorator
@builtin
export declare function i32(value: auto): i32;

export namespace i32 {

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE: i32 = -2147483648;

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE: i32 =  2147483647;

  // @ts-ignore: decorator
  @builtin
  export declare function clz(value: i32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function ctz(value: i32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function popcnt(value: i32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function add(left: i32, right:i32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function sub(left: i32, right:i32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function mul(left: i32, right:i32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function div_s(left: i32, right:i32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function div_u(left: i32, right:i32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function rotl(value: i32, shift: i32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function rotr(value: i32, shift: i32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function reinterpret_f32(value: f32): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;

  export namespace atomic {

    // @ts-ignore: decorator
    @builtin
    export declare function load8_u(ptr: usize, immOffset?: usize): i32;

    // @ts-ignore: decorator
    @builtin
    export declare function load16_u(ptr: usize, immOffset?: usize): i32;

    // @ts-ignore: decorator
    @builtin
    export declare function load(ptr: usize, immOffset?: usize): i32;

    // @ts-ignore: decorator
    @unsafe @builtin
    export declare function store8(ptr: usize, value: i32, immOffset?: usize): void;

    // @ts-ignore: decorator
    @unsafe @builtin
    export declare function store16(ptr: usize, value: i32, immOffset?: usize): void;

    // @ts-ignore: decorator
    @unsafe @builtin
    export declare function store(ptr: usize, value: i32, immOffset?: usize): void;

    // @ts-ignore: decorator
    @builtin
    export declare function wait(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;

    export namespace rmw8 {

      // @ts-ignore: decorator
      @builtin
      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @builtin
      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @builtin
      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @builtin
      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @builtin
      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;
    }

    export namespace rmw16 {

      // @ts-ignore: decorator
      @builtin
      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @builtin
      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @builtin
      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @builtin
      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @builtin
      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;
    }

    export namespace rmw {

      // @ts-ignore: decorator
      @builtin
      export declare function add(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @builtin
      export declare function sub(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @builtin
      export declare function and(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @builtin
      export declare function or(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @builtin
      export declare function xor(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function xchg(ptr: usize, value: i32, immOffset?: usize): i32;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;
    }
  }
}

// @ts-ignore: decorator
@builtin
export declare function i64(value: auto): i64;

export namespace i64 {

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE: i64 = -9223372036854775808;

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE: i64 =  9223372036854775807;

  // @ts-ignore: decorator
  @builtin
  export declare function clz(value: i64): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function ctz(value: i64): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function add(left: i64, right:i64): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function sub(left: i64, right:i64): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function mul(left: i64, right:i64): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function div_s(left: i64, right:i64): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function div_u(left: i64, right:i64): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function load(ptr: usize, immOffset?: usize): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function popcnt(value: i64): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function rotl(value: i64, shift: i64): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function rotr(value: i64, shift: i64): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function reinterpret_f64(value: f64): i64;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;

  export namespace atomic {

    // @ts-ignore: decorator
    @builtin
    export declare function load8_u(ptr: usize, immOffset?: usize): i64;

    // @ts-ignore: decorator
    @builtin
    export declare function load16_u(ptr: usize, immOffset?: usize): i64;

    // @ts-ignore: decorator
    @builtin
    export declare function load32_u(ptr: usize, immOffset?: usize): i64;

    // @ts-ignore: decorator
    @builtin
    export declare function load(ptr: usize, immOffset?: usize): i64;

    // @ts-ignore: decorator
    @unsafe @builtin
    export declare function store8(ptr: usize, value: i64, immOffset?: usize): void;

    // @ts-ignore: decorator
    @unsafe @builtin
    export declare function store16(ptr: usize, value: i64, immOffset?: usize): void;

    // @ts-ignore: decorator
    @unsafe @builtin
    export declare function store32(ptr: usize, value: i64, immOffset?: usize): void;

    // @ts-ignore: decorator
    @unsafe @builtin
    export declare function store(ptr: usize, value: i64, immOffset?: usize): void;

    // @ts-ignore: decorator
    @builtin
    export declare function wait(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;

    export namespace rmw8 {

      // @ts-ignore: decorator
      @builtin
      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;
    }

    export namespace rmw16 {

      // @ts-ignore: decorator
      @builtin
      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;
    }

    export namespace rmw32 {

      // @ts-ignore: decorator
      @builtin
      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;
    }

    export namespace rmw {

      // @ts-ignore: decorator
      @builtin
      export declare function add(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function sub(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function and(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function or(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @builtin
      export declare function xor(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function xchg(ptr: usize, value: i64, immOffset?: usize): i64;

      // @ts-ignore: decorator
      @unsafe @builtin
      export declare function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;
    }
  }
}

// @ts-ignore: decorator
@builtin
export declare function isize(value: auto): isize;

export namespace isize {

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()
    ? -2147483648
    : <isize>-9223372036854775808;

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()
    ? 2147483647
    : <isize>9223372036854775807;
}

// @ts-ignore: decorator
@builtin
export declare function u8(value: auto): u8;

export namespace u8 {

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE: u8 = 0;

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE: u8 = 255;
}

// @ts-ignore: decorator
@builtin
export declare function u16(value: auto): u16;

export namespace u16 {

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE: u16 = 0;

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE: u16 = 65535;
}

// @ts-ignore: decorator
@builtin
export declare function u32(value: auto): u32;

export namespace u32 {

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE: u32 = 0;

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE: u32 = 4294967295;
}

// @ts-ignore: decorator
@builtin
export declare function u64(value: auto): u64;

export namespace u64 {

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE: u64 = 0;

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE: u64 = 18446744073709551615;
}

// @ts-ignore: decorator
@builtin
export declare function usize(value: auto): usize;

export namespace usize {

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE: usize = 0;

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()
    ? 4294967295
    : <usize>18446744073709551615;
}

// @ts-ignore: decorator
@builtin
export declare function bool(value: auto): bool;

export namespace bool {

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE: bool = false;

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE: bool = true;
}

// @ts-ignore: decorator
@builtin
export declare function f32(value: auto): f32;

export namespace f32 {

  // @ts-ignore: decorator
  @lazy
  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f

  // @ts-ignore: decorator
  @lazy
  export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f

  // @ts-ignore: decorator
  @lazy
  export const MIN_SAFE_INTEGER: f32 = -16777215;

  // @ts-ignore: decorator
  @lazy
  export const MAX_SAFE_INTEGER: f32 =  16777215;

  // @ts-ignore: decorator
  @lazy
  export const POSITIVE_INFINITY: f32 =  Infinity;

  // @ts-ignore: decorator
  @lazy
  export const NEGATIVE_INFINITY: f32 = -Infinity;

  // @ts-ignore: decorator
  @lazy
  export const NaN: f32 = 0.0 / 0.0;

  // @ts-ignore: decorator
  @builtin
  export declare function abs(value: f32): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function ceil(value: f32): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function copysign(x: f32, y: f32): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function floor(value: f32): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function max(left: f32, right: f32): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function min(left: f32, right: f32): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function nearest(value: f32): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function reinterpret_i32(value: i32): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function sqrt(value: f32): f32;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;

  // @ts-ignore: decorator
  @builtin
  export declare function trunc(value: f32): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function add(left: f32, right: f32): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function sub(left: f32, right: f32): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function mul(left: f32, right: f32): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function div(left: f32, right: f32): f32;
}

// @ts-ignore: decorator
@builtin
export declare function f64(value: auto): f64;

export namespace f64 {

  // @ts-ignore: decorator
  @lazy
  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52

  // @ts-ignore: decorator
  @lazy
  export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0

  // @ts-ignore: decorator
  @lazy
  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023

  // @ts-ignore: decorator
  @lazy
  export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022

  // @ts-ignore: decorator
  @lazy
  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;

  // @ts-ignore: decorator
  @lazy
  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;

  // @ts-ignore: decorator
  @lazy
  export const POSITIVE_INFINITY: f64 =  Infinity;

  // @ts-ignore: decorator
  @lazy
  export const NEGATIVE_INFINITY: f64 = -Infinity;

  // @ts-ignore: decorator
  @lazy
  export const NaN: f64 = 0.0 / 0.0;

  // @ts-ignore: decorator
  @builtin
  export declare function abs(value: f64): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function ceil(value: f64): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function copysign(x: f64, y: f64): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function floor(value: f64): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function max(left: f64, right: f64): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function min(left: f64, right: f64): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function nearest(value: f64): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function reinterpret_i64(value: i64): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function sqrt(value: f64): f64;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;

  // @ts-ignore: decorator
  @builtin
  export declare function trunc(value: f64): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function add(left: f64, right: f64): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function sub(left: f64, right: f64): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function mul(left: f64, right: f64): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function div(left: f64, right: f64): f64;
}

// @ts-ignore: decorator
@builtin
export declare function v128(
  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,
  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8
): v128;

export namespace v128 {

  // @ts-ignore: decorator
  @builtin
  export declare function splat<T>(x: T): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extract_lane<T>(x: v128, idx: u8): T;

  // @ts-ignore: decorator
  @builtin
  export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function swizzle(a: v128, s: v128): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load_zero<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load8_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load16_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load32_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load64_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load32_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load64_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function load64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;

  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;

  // @ts-ignore: decorator
  @builtin
  export declare function add<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sub<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function mul<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only

  // @ts-ignore: decorator
  @builtin
  export declare function neg<T>(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function add_sat<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sub_sat<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shl<T>(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shr<T>(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function and(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function or(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function xor(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function andnot(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function not(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function bitselect(v1: v128, v2: v128, c: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function any_true(a: v128): bool;

  // @ts-ignore: decorator
  @builtin
  export declare function all_true<T>(a: v128): bool;

  // @ts-ignore: decorator
  @builtin
  export declare function bitmask<T>(a: v128): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function popcnt<T>(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function min<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function max<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function pmin<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function pmax<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function dot<T>(a: v128, b: v128): v128; // i16 only

  // @ts-ignore: decorator
  @builtin
  export declare function avgr<T>(a: v128, b: v128): v128; // u8, u16 only

  // @ts-ignore: decorator
  @builtin
  export declare function abs<T>(a: v128): v128; // f32, f64 only

  // @ts-ignore: decorator
  @builtin
  export declare function sqrt<T>(a: v128): v128; // f32, f64 only

  // @ts-ignore: decorator
  @builtin
  export declare function ceil<T>(a: v128): v128; // f32, f64 only

  // @ts-ignore: decorator
  @builtin
  export declare function floor<T>(a: v128): v128; // f32, f64 only

  // @ts-ignore: decorator
  @builtin
  export declare function trunc<T>(a: v128): v128; // f32, f64 only

  // @ts-ignore: decorator
  @builtin
  export declare function nearest<T>(a: v128): v128; // f32, f64 only

  // @ts-ignore: decorator
  @builtin
  export declare function eq<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ne<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function lt<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function le<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function gt<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ge<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function convert<T>(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function convert_low<T>(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function trunc_sat<T>(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function trunc_sat_zero<T>(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function narrow<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_low<T>(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_high<T>(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extadd_pairwise<T>(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function demote_zero<T = f64>(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function promote_low<T = f32>(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function q15mulr_sat<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_low<T>(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_high<T>(a: v128, b: v128): v128;
}

// @ts-ignore: decorator
@builtin
export declare function i8x16(
  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,
  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8
): v128;

export namespace i8x16 {

  // @ts-ignore: decorator
  @builtin
  export declare function splat(x: i8): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extract_lane_s(x: v128, idx: u8): i8;

  // @ts-ignore: decorator
  @builtin
  export declare function extract_lane_u(x: v128, idx: u8): u8;

  // @ts-ignore: decorator
  @builtin
  export declare function replace_lane(x: v128, idx: u8, value: i8): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function add(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sub(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function min_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function min_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function max_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function max_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function avgr_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function abs(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function neg(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function add_sat_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function add_sat_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sub_sat_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sub_sat_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shl(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shr_s(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shr_u(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function all_true(a: v128): bool;

  // @ts-ignore: decorator
  @builtin
  export declare function bitmask(a: v128): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function popcnt(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function eq(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ne(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function lt_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function lt_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function le_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function le_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function gt_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function gt_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ge_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ge_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function narrow_i16x8_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function narrow_i16x8_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shuffle(
    a: v128, b: v128,
    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8,
    l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8
  ): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function swizzle(a: v128, s: v128): v128;
}

// @ts-ignore: decorator
@builtin
export declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;

export namespace i16x8 {

  // @ts-ignore: decorator
  @builtin
  export declare function splat(x: i16): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extract_lane_s(x: v128, idx: u8): i16;

  // @ts-ignore: decorator
  @builtin
  export declare function extract_lane_u(x: v128, idx: u8): u16;

  // @ts-ignore: decorator
  @builtin
  export declare function replace_lane(x: v128, idx: u8, value: i16): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function add(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sub(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function mul(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function min_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function min_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function max_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function max_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function avgr_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function abs(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function neg(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function add_sat_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function add_sat_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sub_sat_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sub_sat_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shl(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shr_s(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shr_u(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function all_true(a: v128): bool;

  // @ts-ignore: decorator
  @builtin
  export declare function bitmask(a: v128): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function eq(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ne(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function lt_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function lt_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function le_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function le_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function gt_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function gt_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ge_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ge_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function narrow_i32x4_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function narrow_i32x4_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_low_i8x16_s(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_low_i8x16_u(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_high_i8x16_s(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_high_i8x16_u(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extadd_pairwise_i8x16_s(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extadd_pairwise_i8x16_u(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function q15mulr_sat_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_low_i8x16_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_low_i8x16_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_high_i8x16_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_high_i8x16_u(a: v128, b: v128): v128;
}

// @ts-ignore: decorator
@builtin
export declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;

export namespace i32x4 {

  // @ts-ignore: decorator
  @builtin
  export declare function splat(x: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extract_lane(x: v128, idx: u8): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function replace_lane(x: v128, idx: u8, value: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function add(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sub(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function mul(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function min_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function min_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function max_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function max_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function dot_i16x8_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function abs(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function neg(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shl(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shr_s(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shr_u(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function all_true(a: v128): bool;

  // @ts-ignore: decorator
  @builtin
  export declare function bitmask(a: v128): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function eq(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ne(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function lt_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function lt_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function le_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function le_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function gt_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function gt_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ge_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ge_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function trunc_sat_f32x4_s(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function trunc_sat_f32x4_u(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function trunc_sat_f64x2_s_zero(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function trunc_sat_f64x2_u_zero(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_low_i16x8_s(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_low_i16x8_u(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_high_i16x8_s(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_high_i16x8_u(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extadd_pairwise_i16x8_s(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extadd_pairwise_i16x8_u(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_low_i16x8_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_low_i16x8_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_high_i16x8_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_high_i16x8_u(a: v128, b: v128): v128;
}

// @ts-ignore: decorator
@builtin
export declare function i64x2(a: i64, b: i64): v128;

export namespace i64x2 {

  // @ts-ignore: decorator
  @builtin
  export declare function splat(x: i64): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extract_lane(x: v128, idx: u8): i64;

  // @ts-ignore: decorator
  @builtin
  export declare function replace_lane(x: v128, idx: u8, value: i64): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function add(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sub(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function mul(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function abs(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function neg(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shl(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shr_s(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function shr_u(a: v128, b: i32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function all_true(a: v128): bool;

  // @ts-ignore: decorator
  @builtin
  export declare function bitmask(a: v128): i32;

  // @ts-ignore: decorator
  @builtin
  export declare function eq(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ne(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function lt_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function le_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function gt_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ge_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_low_i32x4_s(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_low_i32x4_u(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_high_i32x4_s(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extend_high_i32x4_u(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_low_i32x4_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_low_i32x4_u(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_high_i32x4_s(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extmul_high_i32x4_u(a: v128, b: v128): v128;
}

// @ts-ignore: decorator
@builtin
export declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;

export namespace f32x4 {

  // @ts-ignore: decorator
  @builtin
  export declare function splat(x: f32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extract_lane(x: v128, idx: u8): f32;

  // @ts-ignore: decorator
  @builtin
  export declare function replace_lane(x: v128, idx: u8, value: f32): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function add(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sub(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function mul(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function div(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function neg(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function min(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function max(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function pmin(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function pmax(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function abs(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sqrt(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ceil(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function floor(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function trunc(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function nearest(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function eq(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ne(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function lt(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function le(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function gt(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ge(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function convert_i32x4_s(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function convert_i32x4_u(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function demote_f64x2_zero(a: v128): v128;
}

// @ts-ignore: decorator
@builtin
export declare function f64x2(a: f64, b: f64): v128;

export namespace f64x2 {

  // @ts-ignore: decorator
  @builtin
  export declare function splat(x: f64): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function extract_lane(x: v128, idx: u8): f64;

  // @ts-ignore: decorator
  @builtin
  export declare function replace_lane(x: v128, idx: u8, value: f64): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function add(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sub(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function mul(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function div(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function neg(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function min(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function max(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function pmin(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function pmax(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function abs(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function sqrt(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ceil(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function floor(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function trunc(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function nearest(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function eq(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ne(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function lt(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function le(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function gt(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function ge(a: v128, b: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function convert_low_i32x4_s(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function convert_low_i32x4_u(a: v128): v128;

  // @ts-ignore: decorator
  @builtin
  export declare function promote_low_f32x4(a: v128): v128;
}

@final
export abstract class i31 { // FIXME: usage of 'new' requires a class :(

  // @ts-ignore: decorator
  @builtin
  static new(value: i32): i31ref { return changetype<i31ref>(unreachable()); }

  // @ts-ignore: decorator
  @builtin
  static get(i31expr: i31ref): i32 { return unreachable(); }
}

/* eslint-disable @typescript-eslint/no-unused-vars */

// @ts-ignore: decorator
@external("env", "abort")
declare function abort(
  message?: string | null,
  fileName?: string | null,
  lineNumber?: u32,
  columnNumber?: u32
): void;

// @ts-ignore: decorator
@external("env", "trace")
declare function trace(
  message: string,
  n?: i32,
  a0?: f64,
  a1?: f64,
  a2?: f64,
  a3?: f64,
  a4?: f64
): void;

// @ts-ignore: decorator
@external("env", "seed")
declare function seed(): f64;

/* eslint-enable @typescript-eslint/no-unused-vars */

'''
'''--- std/assembly/compat.ts ---
export type ReturnType<T> = returnof<T>;
export type NonNullable<T> = nonnull<T>;

'''
'''--- std/assembly/console.ts ---
import {
  process
} from "./process";

// @ts-ignore: decorator
@lazy var timers = new Map<string,u64>();

export namespace console {

  export function assert<T>(condition: T, message: string): void {
    if (!condition) {
      let stderr = process.stderr;
      stderr.write("Assertion failed: ");
      stderr.write(message);
      stderr.write("\n");
    }
  }

  export function log(message: string): void {
    var stdout = process.stdout;
    stdout.write(message);
    stdout.write("\n");
  }

  export function debug(message: string): void {
    var stdout = process.stdout;
    stdout.write("Debug: ");
    stdout.write(message);
    stdout.write("\n");
  }

  export function info(message: string): void {
    var stdout = process.stdout;
    stdout.write("Info: ");
    stdout.write(message);
    stdout.write("\n");
  }

  export function warn(message: string): void {
    var stdout = process.stdout;
    stdout.write("Warning: ");
    stdout.write(message);
    stdout.write("\n");
  }

  export function error(message: string): void {
    var stdout = process.stdout;
    stdout.write("Error: ");
    stdout.write(message);
    stdout.write("\n");
  }

  export function time(label: string): void {
    var stdout = process.stdout;
    if (timers.has(label)) {
      stdout.write("Warning: Label '");
      stdout.write(label);
      stdout.write("' already exists for console.time()\n");
      return;
    }
    timers.set(label, process.hrtime());
  }

  export function timeLog(label: string): void {
    var stdout = process.stdout;
    if (!timers.has(label)) {
      stdout.write("Warning: No such label '");
      stdout.write(label);
      stdout.write("' for console.timeLog()\n");
      return;
    }
    timeLogImpl(label);
  }

  export function timeEnd(label: string): void {
    var stdout = process.stdout;
    if (!timers.has(label)) {
      stdout.write("Warning: No such label '");
      stdout.write(label);
      stdout.write("' for console.timeEnd()\n");
      return;
    }
    timeLogImpl(label);
    timers.delete(label);
  }
}

function timeLogImpl(label: string): void {
  var start = changetype<u64>(timers.get(label));
  var end = process.hrtime();
  var nanos = end - start;
  var millis = nanos / 1000000;
  var millisStr = millis.toString();
  var stdout = process.stdout;
  stdout.write(label);
  stdout.write(": ");
  stdout.write(millisStr);
  stdout.write("ms\n");
  // __dispose(changetype<usize>(millisStr));
}

'''
'''--- std/assembly/crypto.ts ---
import {
  errnoToString,
  random_get
} from "bindings/wasi_snapshot_preview1";

export namespace crypto {
  export function getRandomValues(array: Uint8Array): void {
    var err = random_get(changetype<usize>(array.buffer) + <usize>array.byteOffset, <usize>array.byteLength);
    if (err) throw new Error(errnoToString(err));
  }
}

'''
'''--- std/assembly/dataview.ts ---
import { BLOCK_MAXSIZE } from "./rt/common";
import { ArrayBuffer } from "./arraybuffer";
import { E_INDEXOUTOFRANGE, E_INVALIDLENGTH } from "./util/error";

// TODO: there is probably a smarter way to check byteOffset for accesses larger than 1 byte

export class DataView {

  readonly buffer: ArrayBuffer;
  @unsafe readonly dataStart: usize;
  readonly byteLength: i32;

  get byteOffset(): i32 {
    return <i32>(this.dataStart - changetype<usize>(this.buffer));
  }

  constructor(
    buffer: ArrayBuffer,
    byteOffset: i32 = 0,
    byteLength: i32 = buffer.byteLength
  ) {
    if (
      i32(<u32>byteLength > <u32>BLOCK_MAXSIZE) |
      i32(<u32>byteOffset + byteLength > <u32>buffer.byteLength)
    ) throw new RangeError(E_INVALIDLENGTH);
    this.buffer = buffer; // links
    var dataStart = changetype<usize>(buffer) + <usize>byteOffset;
    this.dataStart = dataStart;
    this.byteLength = byteLength;
  }

  getFloat32(byteOffset: i32, littleEndian: bool = false): f32 {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    return littleEndian
      ? load<f32>(this.dataStart + <usize>byteOffset)
      : reinterpret<f32>(bswap<u32>(load<u32>(this.dataStart + <usize>byteOffset)));
  }

  getFloat64(byteOffset: i32, littleEndian: bool = false): f64 {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    return littleEndian
      ? load<f64>(this.dataStart + <usize>byteOffset)
      : reinterpret<f64>(bswap<u64>(load<u64>(this.dataStart + <usize>byteOffset)));
  }

  getInt8(byteOffset: i32): i8 {
    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<i8>(this.dataStart + <usize>byteOffset);
  }

  getInt16(byteOffset: i32, littleEndian: bool = false): i16 {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    var result: i16 = load<i16>(this.dataStart + <usize>byteOffset);
    return littleEndian ? result : bswap<u16>(result);
  }

  getInt32(byteOffset: i32, littleEndian: bool = false): i32 {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    var result: i32 = load<i32>(this.dataStart + <usize>byteOffset);
    return littleEndian ? result : bswap<u32>(result);
  }

  getUint8(byteOffset: i32): u8 {
    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<u8>(this.dataStart + <usize>byteOffset);
  }

  getUint16(byteOffset: i32, littleEndian: bool = false): u16 {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    var result: u16 = load<u16>(this.dataStart + <usize>byteOffset);
    return littleEndian ? result : bswap<u16>(result);
  }

  getUint32(byteOffset: i32, littleEndian: bool = false): u32 {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    var result: u32 = load<u32>(this.dataStart + <usize>byteOffset);
    return littleEndian ? result : bswap<u32>(result);
  }

  setFloat32(byteOffset: i32, value: f32, littleEndian: bool = false): void {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    if (littleEndian) store<f32>(this.dataStart + <usize>byteOffset, value);
    else store<u32>(this.dataStart + <usize>byteOffset, bswap<u32>(reinterpret<u32>(value)));
  }

  setFloat64(byteOffset: i32, value: f64, littleEndian: bool = false): void {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    if (littleEndian) store<f64>(this.dataStart + <usize>byteOffset, value);
    else store<u64>(this.dataStart + <usize>byteOffset, bswap<u64>(reinterpret<u64>(value)));
  }

  setInt8(byteOffset: i32, value: i8): void {
    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    store<i8>(this.dataStart + <usize>byteOffset, value);
  }

  setInt16(byteOffset: i32, value: i16, littleEndian: bool = false): void {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    store<i16>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u16>(value));
  }

  setInt32(byteOffset: i32, value: i32, littleEndian: bool = false): void {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    store<i32>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u32>(value));
  }

  setUint8(byteOffset: i32, value: u8): void {
    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    store<u8>(this.dataStart + <usize>byteOffset, value);
  }

  setUint16(byteOffset: i32, value: u16, littleEndian: bool = false): void {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    store<u16>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u16>(value));
  }

  setUint32(byteOffset: i32, value: u32, littleEndian: bool = false): void {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    store<u32>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u32>(value));
  }

  // Non-standard additions that make sense in WebAssembly, but won't work in JS:

  getInt64(byteOffset: i32, littleEndian: bool = false): i64 {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    var result: i64 = load<i64>(this.dataStart + <usize>byteOffset);
    return littleEndian ? result : bswap<u64>(result);
  }

  getUint64(byteOffset: i32, littleEndian: bool = false): u64 {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    var result = load<u64>(this.dataStart + <usize>byteOffset);
    return littleEndian ? result : bswap<u64>(result);
  }

  setInt64(byteOffset: i32, value: i64, littleEndian: bool = false): void {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    store<i64>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u64>(value));
  }

  setUint64(byteOffset: i32, value: u64, littleEndian: bool = false): void {
    if (
      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)
    ) throw new RangeError(E_INDEXOUTOFRANGE);
    store<u64>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u64>(value));
  }

  toString(): string {
    return "[object DataView]";
  }
}

'''
'''--- std/assembly/date.ts ---
import { E_INVALIDDATE } from "util/error";
import { now as Date_now } from "./bindings/Date";

// @ts-ignore: decorator
@inline const
  MILLIS_PER_DAY    = 1000 * 60 * 60 * 24,
  MILLIS_PER_HOUR   = 1000 * 60 * 60,
  MILLIS_PER_MINUTE = 1000 * 60,
  MILLIS_PER_SECOND = 1000;

// ymdFromEpochDays returns values via globals to avoid allocations
// @ts-ignore: decorator
@lazy let _month: i32, _day: i32;

export class Date {
  private year: i32 = 0;
  private month: i32 = 0;
  private day: i32 = 0;

  @inline static UTC(
    year: i32,
    month: i32 = 0,
    day: i32 = 1,
    hour: i32 = 0,
    minute: i32 = 0,
    second: i32 = 0,
    millisecond: i32 = 0
  ): i64 {
    if (year >= 0 && year <= 99) year += 1900;
    var ms = epochMillis(year, month + 1, day, hour, minute, second, millisecond);
    if (invalidDate(ms)) throw new RangeError(E_INVALIDDATE);
    return ms;
  }

  @inline static now(): i64 {
    return <i64>Date_now();
  }

  // It can parse only ISO 8601 inputs like YYYY-MM-DDTHH:MM:SS.000Z
  @inline static parse(dateString: string): Date {
    return this.fromString(dateString);
  }

  static fromString(dateTimeString: string): Date {
    if (!dateTimeString.length) throw new RangeError(E_INVALIDDATE);
    var
      hour: i32 = 0,
      min: i32 = 0,
      sec: i32 = 0,
      ms: i32 = 0;

    var dateString = dateTimeString;
    var posT = dateTimeString.indexOf("T");
    if (~posT) {
      // includes a time component
      let timeString: string;
      dateString = dateTimeString.substring(0, posT);
      timeString = dateTimeString.substring(posT + 1);
      // parse the HH-MM-SS component
      let timeParts = timeString.split(":");
      let len = timeParts.length;
      if (len <= 1) throw new RangeError(E_INVALIDDATE);

      hour = I32.parseInt(timeParts[0]);
      min  = I32.parseInt(timeParts[1]);
      if (len >= 3) {
        let secAndMs = timeParts[2];
        let posDot = secAndMs.indexOf(".");
        if (~posDot) {
          // includes milliseconds
          sec = I32.parseInt(secAndMs.substring(0, posDot));
          ms  = I32.parseInt(secAndMs.substring(posDot + 1));
        } else {
          sec = I32.parseInt(secAndMs);
        }
      }
    }
    // parse the YYYY-MM-DD component
    var parts = dateString.split("-");
    var year = I32.parseInt(parts[0]);
    var month = 1, day = 1;
    var len = parts.length;
    if (len >= 2) {
      month = I32.parseInt(parts[1]);
      if (len >= 3) {
        day = I32.parseInt(parts[2]);
      }
    }
    return new Date(epochMillis(year, month, day, hour, min, sec, ms));
  }

  constructor(private epochMillis: i64) {
    // this differs from JavaScript which prefer return NaN or "Invalid Date" string
    // instead throwing exception.
    if (invalidDate(epochMillis)) throw new RangeError(E_INVALIDDATE);

    this.year = ymdFromEpochDays(i32(floorDiv(epochMillis, MILLIS_PER_DAY)));
    this.month = _month;
    this.day = _day;
  }

  @inline getTime(): i64 {
    return this.epochMillis;
  }

  setTime(time: i64): i64 {
    if (invalidDate(time)) throw new RangeError(E_INVALIDDATE);

    this.epochMillis = time;
    this.year = ymdFromEpochDays(i32(floorDiv(time, MILLIS_PER_DAY)));
    this.month = _month;
    this.day = _day;

    return time;
  }

  @inline getUTCFullYear(): i32 {
    return this.year;
  }

  @inline getUTCMonth(): i32 {
    return this.month - 1;
  }

  @inline getUTCDate(): i32 {
    return this.day;
  }

  @inline getUTCDay(): i32 {
    return dayOfWeek(this.year, this.month, this.day);
  }

  getUTCHours(): i32 {
    return i32(euclidRem(this.epochMillis, MILLIS_PER_DAY)) / MILLIS_PER_HOUR;
  }

  getUTCMinutes(): i32 {
    return i32(euclidRem(this.epochMillis, MILLIS_PER_HOUR)) / MILLIS_PER_MINUTE;
  }

  getUTCSeconds(): i32 {
    return i32(euclidRem(this.epochMillis, MILLIS_PER_MINUTE)) / MILLIS_PER_SECOND;
  }

  getUTCMilliseconds(): i32 {
    return i32(euclidRem(this.epochMillis, MILLIS_PER_SECOND));
  }

  setUTCMilliseconds(millis: i32): void {
    this.setTime(this.epochMillis + (millis - this.getUTCMilliseconds()));
  }

  setUTCSeconds(seconds: i32): void {
    this.setTime(this.epochMillis + (seconds - this.getUTCSeconds()) * MILLIS_PER_SECOND);
  }

  setUTCMinutes(minutes: i32): void {
    this.setTime(this.epochMillis + (minutes - this.getUTCMinutes()) * MILLIS_PER_MINUTE);
  }

  setUTCHours(hours: i32): void {
    this.setTime(this.epochMillis + (hours - this.getUTCHours()) * MILLIS_PER_HOUR);
  }

  setUTCDate(day: i32): void {
    if (this.day == day) return;
    var ms = euclidRem(this.epochMillis, MILLIS_PER_DAY);
    this.setTime(i64(daysSinceEpoch(this.year, this.month, day)) * MILLIS_PER_DAY + ms);
  }

  setUTCMonth(month: i32): void {
    if (this.month == month) return;
    var ms = euclidRem(this.epochMillis, MILLIS_PER_DAY);
    this.setTime(i64(daysSinceEpoch(this.year, month + 1, this.day)) * MILLIS_PER_DAY + ms);
  }

  setUTCFullYear(year: i32): void {
    if (this.year == year) return;
    var ms = euclidRem(this.epochMillis, MILLIS_PER_DAY);
    this.setTime(i64(daysSinceEpoch(year, this.month, this.day)) * MILLIS_PER_DAY + ms);
  }

  toISOString(): string {
    // TODO: add more low-level helper which combine toString and padStart without extra allocation
    var yearStr: string;
    var year = this.year;
    var isNeg = year < 0;
    if (isNeg || year >= 10000) {
      yearStr = (isNeg ? "-" : "+") + abs(year).toString().padStart(6, "0");
    } else {
      yearStr = year.toString().padStart(4, "0");
    }

    return (
      yearStr +
      "-" +
      this.month.toString().padStart(2, "0") +
      "-" +
      this.day.toString().padStart(2, "0") +
      "T" +
      this.getUTCHours().toString().padStart(2, "0") +
      ":" +
      this.getUTCMinutes().toString().padStart(2, "0") +
      ":" +
      this.getUTCSeconds().toString().padStart(2, "0") +
      "." +
      this.getUTCMilliseconds().toString().padStart(3, "0") +
      "Z"
    );
  }

  toUTCString(): string {
    const weeks: StaticArray<string> = [
      "Sun, ", "Mon, ", "Tue, ", "Wed, ", "Thu, ", "Fri, ", "Sat, "
    ];

    const months: StaticArray<string> = [
      " Jan ", " Feb ", " Mar ", " Apr ", " May ", " Jun ",
      " Jul ", " Aug ", " Sep ", " Oct ", " Nov ", " Dec "
    ];

    var mo = this.month;
    var da = this.day;
    var yr = this.year;
    var wd = dayOfWeek(yr, mo, da);
    var year = abs(yr).toString().padStart(4, "0");
    if (yr < 0) year = "-" + year;

    return (
      unchecked(weeks[wd]) +
      da.toString().padStart(2, "0") +
      unchecked(months[mo - 1]) +
      year +
      " " +
      this.getUTCHours().toString().padStart(2, "0") +
      ":" +
      this.getUTCMinutes().toString().padStart(2, "0") +
      ":" +
      this.getUTCSeconds().toString().padStart(2, "0") +
      " GMT"
    );
  }

  toDateString(): string {
    // TODO: use u64 static data instead 4 chars
    // also use stream itoa variants.
    const weeks: StaticArray<string> = [
      "Sun ", "Mon ", "Tue ", "Wed ", "Thu ", "Fri ", "Sat "
    ];

    const months: StaticArray<string> = [
      "Jan ", "Feb ", "Mar ", "Apr ", "May ", "Jun ",
      "Jul ", "Aug ", "Sep ", "Oct ", "Nov ", "Dec "
    ];

    var mo = this.month;
    var da = this.day;
    var yr = this.year;
    var wd = dayOfWeek(yr, mo, da);
    var year = abs(yr).toString().padStart(4, "0");
    if (yr < 0) year = "-" + year;

    return (
      unchecked(weeks[wd]) +
      unchecked(months[mo - 1]) +
      da.toString().padStart(2, "0") +
      " " + year
    );
  }

  // Note: it uses UTC time instead local time (without timezone offset)
  toTimeString(): string {
    // TODO: add timezone
    return (
      this.getUTCHours().toString().padStart(2, "0") +
      ":" +
      this.getUTCMinutes().toString().padStart(2, "0") +
      ":" +
      this.getUTCSeconds().toString().padStart(2, "0")
    );
  }

  // Note: it uses UTC datetime instead local datetime (without timezone offset)
  toString(): string {
    return this.toDateString() + " " + this.toTimeString();
  }
}

function epochMillis(
  year: i32,
  month: i32,
  day: i32,
  hour: i32,
  minute: i32,
  second: i32,
  milliseconds: i32
): i64 {
  return (
    i64(daysSinceEpoch(year, month, day)) * MILLIS_PER_DAY +
    hour * MILLIS_PER_HOUR +
    minute * MILLIS_PER_MINUTE +
    second * MILLIS_PER_SECOND +
    milliseconds
  );
}

// @ts-ignore: decorator
@inline function floorDiv<T extends number>(a: T, b: T): T {
  return (a >= 0 ? a : a - b + 1) / b as T;
}

// @ts-ignore: decorator
@inline function euclidRem<T extends number>(a: T, b: T): T {
  var m = a % b;
  return m + (m < 0 ? b : 0) as T;
}

function invalidDate(millis: i64): bool {
  // @ts-ignore
  return (millis < -8640000000000000) | (millis > 8640000000000000);
}

// see: http://howardhinnant.github.io/date_algorithms.html#civil_from_days
function ymdFromEpochDays(z: i32): i32 {
  z += 719468;
  var era = <u32>floorDiv(z, 146097);
  var doe = <u32>z - era * 146097; // [0, 146096]
  var yoe = (doe - doe / 1460 + doe / 36524 - doe / 146096) / 365; // [0, 399]
  var year = yoe + era * 400;
  var doy = doe - (365 * yoe + yoe / 4 - yoe / 100); // [0, 365]
  var mo = (5 * doy + 2) / 153; // [0, 11]
  _day = doy - (153 * mo + 2) / 5 + 1; // [1, 31]
  mo += mo < 10 ? 3 : -9; // [1, 12]
  _month = mo;
  year += u32(mo <= 2);
  return year;
}

// http://howardhinnant.github.io/date_algorithms.html#days_from_civil
function daysSinceEpoch(y: i32, m: i32, d: i32): i32 {
  y -= i32(m <= 2);
  var era = <u32>floorDiv(y, 400);
  var yoe = <u32>y - era * 400; // [0, 399]
  var doy = <u32>(153 * (m + (m > 2 ? -3 : 9)) + 2) / 5 + d - 1; // [0, 365]
  var doe = yoe * 365 + yoe / 4 - yoe / 100 + doy; // [0, 146096]
  return era * 146097 + doe - 719468;
}

// TomohikoSakamoto algorithm from https://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week
function dayOfWeek(year: i32, month: i32, day: i32): i32 {
  const tab = memory.data<u8>([0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4]);

  year -= i32(month < 3);
  year += floorDiv(year, 4) - floorDiv(year, 100) + floorDiv(year, 400);
  month = <i32>load<u8>(tab + month - 1);
  return euclidRem(year + month + day, 7);
}

'''
'''--- std/assembly/diagnostics.ts ---
// @ts-ignore: decorator
@builtin
export declare function ERROR(message?: string): void;

// @ts-ignore: decorator
@builtin
export declare function WARNING(message?: string): void;

// @ts-ignore: decorator
@builtin
export declare function INFO(message?: string): void;

'''
'''--- std/assembly/error.ts ---
export class Error {

  name: string  = "Error";
  stack: string = ""; // TODO

  constructor(
    public message: string = ""
  ) {}

  toString(): string {
    var message = this.message;
    return message.length
      ? this.name + ": " + message
      : this.name;
  }
}

export class RangeError extends Error {
  constructor(message: string = "") {
    super(message);
    this.name = "RangeError";
  }
}

export class TypeError extends Error {
  constructor(message: string = "") {
    super(message);
    this.name = "TypeError";
  }
}

export class SyntaxError extends Error {
  constructor(message: string = "") {
    super(message);
    this.name = "SyntaxError";
  }
}

export class URIError extends Error {
  constructor(message: string = "") {
    super(message);
    this.name = "URIError";
  }
}

'''
'''--- std/assembly/function.ts ---
type auto = i32;

@final export abstract class Function<T> {
  private _index: u32;
  private _env: usize;

  // @ts-ignore: this on getter
  get index(this: T): u32 {
    return load<u32>(changetype<usize>(this), offsetof<Function<T>>("_index"));
  }

  // @ts-ignore: this on getter
  get name(this: T): string {
    return "";
  }

  // @ts-ignore: this on getter
  get length(this: T): i32 {
    // @ts-ignore: T is function
    return lengthof<T>();
  }

  // @ts-ignore: T is function
  @builtin call(thisArg: thisof<T> | null, ...args: auto[]): returnof<T> {
    return unreachable();
  }

  toString(this: T): string {
    return "function() { [native code] }";
  }

  // RT integration

  @unsafe private __visit(cookie: u32): void {
    // Env is either `null` (nop) or compiler-generated
    __visit(this._env, cookie);
  }
}

'''
'''--- std/assembly/index.d.ts ---
/**
 * Environment definitions for compiling AssemblyScript to WebAssembly using asc.
 * @module std/assembly
 *//***/

/// <reference no-default-lib="true"/>

// Types

/** An 8-bit signed integer. */
declare type i8 = number;
/** A 16-bit signed integer. */
declare type i16 = number;
/** A 32-bit signed integer. */
declare type i32 = number;
/** A 64-bit signed integer. */
declare type i64 = number;
/** A 32-bit signed integer when targeting 32-bit WebAssembly or a 64-bit signed integer when targeting 64-bit WebAssembly. */
declare type isize = number;
/** An 8-bit unsigned integer. */
declare type u8 = number;
/** A 16-bit unsigned integer. */
declare type u16 = number;
/** A 32-bit unsigned integer. */
declare type u32 = number;
/** A 64-bit unsigned integer. */
declare type u64 = number;
/** A 32-bit unsigned integer when targeting 32-bit WebAssembly or a 64-bit unsigned integer when targeting 64-bit WebAssembly. */
declare type usize = number;
/** A 1-bit unsigned integer. */
declare type bool = boolean | number;
/** A 32-bit float. */
declare type f32 = number;
/** A 64-bit float. */
declare type f64 = number;
/** A 128-bit vector. */
declare type v128 = object;
/** Function reference. */
declare type funcref = object | null;
/** External reference. */
declare type externref = object | null;
/** Any reference. */
declare type anyref = object | null;
/** Equatable reference. */
declare type eqref = object | null;
/** 31-bit integer reference. */
declare type i31ref = object | null;
/** Data reference. */
declare type dataref = object | null;

// Compiler hints

/** Compiler target. 0 = JS, 1 = WASM32, 2 = WASM64. */
declare const ASC_TARGET: i32;
/** Provided noAssert option. */
declare const ASC_NO_ASSERT: bool;
/** Provided memoryBase option. */
declare const ASC_MEMORY_BASE: i32;
/** Provided tableBase option. */
declare const ASC_TABLE_BASE: i32;
/** Provided optimizeLevel option. */
declare const ASC_OPTIMIZE_LEVEL: i32;
/** Provided shrinkLevel option. */
declare const ASC_SHRINK_LEVEL: i32;
/** Provided lowMemoryLimit option. */
declare const ASC_LOW_MEMORY_LIMIT: i32;
/** Provided noExportRuntime option. */
declare const ASC_NO_EXPORT_RUNTIME: i32;
/** Whether the sign extension feature is enabled. */
declare const ASC_FEATURE_SIGN_EXTENSION: bool;
/** Whether the mutable globals feature is enabled. */
declare const ASC_FEATURE_MUTABLE_GLOBALS: bool;
/** Whether the non-trapping float-to-int feature is enabled. */
declare const ASC_FEATURE_NONTRAPPING_F2I: bool;
/** Whether the bulk memory feature is enabled. */
declare const ASC_FEATURE_BULK_MEMORY: bool;
/** Whether the SIMD feature is enabled. */
declare const ASC_FEATURE_SIMD: bool;
/** Whether the threads feature is enabled. */
declare const ASC_FEATURE_THREADS: bool;
/** Whether the exception handling feature is enabled. */
declare const ASC_FEATURE_EXCEPTION_HANDLING: bool;
/** Whether the tail calls feature is enabled. */
declare const ASC_FEATURE_TAIL_CALLS: bool;
/** Whether the reference types feature is enabled. */
declare const ASC_FEATURE_REFERENCE_TYPES: bool;
/** Whether the multi value types feature is enabled. */
declare const ASC_FEATURE_MULTI_VALUE: bool;
/** Whether the garbage collection feature is enabled. */
declare const ASC_FEATURE_GC: bool;
/** Whether the memory64 feature is enabled. */
declare const ASC_FEATURE_MEMORY64: bool;
/** Major version of the compiler. */
declare const ASC_VERSION_MAJOR: i32;
/** Minor version of the compiler. */
declare const ASC_VERSION_MINOR: i32;
/** Patch version of the compiler. */
declare const ASC_VERSION_PATCH: i32;

// Builtins

/** Performs the sign-agnostic count leading zero bits operation on a 32-bit or 64-bit integer. All zero bits are considered leading if the value is zero. */
declare function clz<T extends i32 | i64>(value: T): T;
/** Performs the sign-agnostic count tailing zero bits operation on a 32-bit or 64-bit integer. All zero bits are considered trailing if the value is zero. */
declare function ctz<T extends i32 | i64>(value: T): T;
/** Performs the sign-agnostic count number of one bits operation on a 32-bit or 64-bit integer. */
declare function popcnt<T extends i32 | i64>(value: T): T;
/** Performs the sign-agnostic rotate left operation on a 32-bit or 64-bit integer. */
declare function rotl<T extends i32 | i64>(value: T, shift: T): T;
/** Performs the sign-agnostic rotate right operation on a 32-bit or 64-bit integer. */
declare function rotr<T extends i32 | i64>(value: T, shift: T): T;
/** Computes the absolute value of an integer or float. */
declare function abs<T extends i32 | i64 | f32 | f64>(value: T): T;
/** Determines the maximum of two integers or floats. If either operand is `NaN`, returns `NaN`. */
declare function max<T extends i32 | i64 | f32 | f64>(left: T, right: T): T;
/** Determines the minimum of two integers or floats. If either operand is `NaN`, returns `NaN`. */
declare function min<T extends i32 | i64 | f32 | f64>(left: T, right: T): T;
/** Performs the ceiling operation on a 32-bit or 64-bit float. */
declare function ceil<T extends f32 | f64>(value: T): T;
/** Composes a 32-bit or 64-bit float from the magnitude of `x` and the sign of `y`. */
declare function copysign<T extends f32 | f64>(x: T, y: T): T;
/** Performs the floor operation on a 32-bit or 64-bit float. */
declare function floor<T extends f32 | f64>(value: T): T;
/** Rounds to the nearest integer tied to even of a 32-bit or 64-bit float. */
declare function nearest<T extends f32 | f64>(value: T): T;
/** Reinterprets the bits of the specified value as type `T`. Valid reinterpretations are u32/i32 to/from f32 and u64/i64 to/from f64. */
declare function reinterpret<T extends i32 | i64 | f32 | f64>(value: number): T;
/** Selects one of two pre-evaluated values depending on the condition. */
declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;
/** Calculates the square root of a 32-bit or 64-bit float. */
declare function sqrt<T extends f32 | f64>(value: T): T;
/** Rounds to the nearest integer towards zero of a 32-bit or 64-bit float. */
declare function trunc<T extends f32 | f64>(value: T): T;
/** Computes the sum of two integers or floats. */
declare function add<T extends i32 | i64 | f32 | f64>(left: T, right: T): T;
/** Computes the difference of two integers or floats. */
declare function sub<T extends i32 | i64 | f32 | f64>(left: T, right: T): T;
/** Computes the product of two integers or floats. */
declare function mul<T extends i32 | i64 | f32 | f64>(left: T, right: T): T;
/** Computes the quotient of two integers or floats. */
declare function div<T extends i32 | i64 | f32 | f64>(left: T, right: T): T;
/** Loads a value of the specified type from memory. Equivalent to dereferncing a pointer in other languages. */
declare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;
/** Stores a value of the specified type to memory. Equivalent to dereferencing a pointer in other languages when assigning a value. */
declare function store<T>(ptr: usize, value: T, immOffset?: usize, immAlign?: usize): void;
/** Emits an unreachable operation that results in a runtime error when executed. Both a statement and an expression. */
declare function unreachable(): never;

/** NaN (not a number) as a 32-bit or 64-bit float depending on context. */
declare const NaN: f32 | f64;
/** Positive infinity as a 32-bit or 64-bit float depending on context. */
declare const Infinity: f32 | f64;
/** Data end offset. */
declare const __data_end: usize;
/** Stack pointer offset. */
declare var __stack_pointer: usize;
/** Heap base offset. */
declare const __heap_base: usize;
/** Determines the byte size of the specified underlying core type. Compiles to a constant. */
declare function sizeof<T>(): usize;
/** Determines the alignment (log2) of the specified underlying core type. Compiles to a constant. */
declare function alignof<T>(): usize;
/** Determines the end offset of the given class type. Compiles to a constant. */
declare function offsetof<T>(): usize;
/** Determines the offset of the specified field within the given class type. Compiles to a constant. */
declare function offsetof<T>(fieldName: keyof T | string): usize;
/** Determines the offset of the specified field within the given class type. Returns the class type's end offset if field name has been omitted. Compiles to a constant. */
declare function offsetof<T>(fieldName?: string): usize;
/** Determines the name of a given type. */
declare function nameof<T>(value?: T): string;
/** Determines the unique runtime id of a class type. Compiles to a constant. */
declare function idof<T>(): u32;
/** Changes the type of any value of `usize` kind to another one of `usize` kind. Useful for casting class instances to their pointer values and vice-versa. Beware that this is unsafe.*/
declare function changetype<T>(value: any): T;
/** Explicitly requests no bounds checks on the provided expression. Useful for array accesses. */
declare function unchecked<T>(value: T): T;
/** Emits a `call_indirect` instruction, calling the specified function in the function table by index with the specified arguments. Does result in a runtime error if the arguments do not match the called function. */
declare function call_indirect<T>(index: u32, ...args: unknown[]): T;
/** Instantiates a new instance of `T` using the specified constructor arguments. */
declare function instantiate<T>(...args: any[]): T;
/** Tests if a 32-bit or 64-bit float is `NaN`. */
declare function isNaN<T extends f32 | f64>(value: T): bool;
/** Tests if a 32-bit or 64-bit float is finite, that is not `NaN` or +/-`Infinity`. */
declare function isFinite<T extends f32 | f64>(value: T): bool;
/** Tests if the specified type *or* expression is of an integer type and not a reference. Compiles to a constant. */
declare function isInteger<T>(value?: any): value is number;
/** Tests if the specified type *or* expression is of a float type. Compiles to a constant. */
declare function isFloat<T>(value?: any): value is number;
/** Tests if the specified type *or* expression is of a boolean type. */
declare function isBoolean<T>(value?: any): value is number;
/** Tests if the specified type *or* expression can represent negative numbers. Compiles to a constant. */
declare function isSigned<T>(value?: any): value is number;
/** Tests if the specified type *or* expression is of a reference type. Compiles to a constant. */
declare function isReference<T>(value?: any): value is object | string;
/** Tests if the specified type *or* expression can be used as a string. Compiles to a constant. */
declare function isString<T>(value?: any): value is string | String;
/** Tests if the specified type *or* expression can be used as an array. Compiles to a constant. */
declare function isArray<T>(value?: any): value is Array<any>;
/** Tests if the specified type *or* expression can be used as an array like object. Compiles to a constant. */
declare function isArrayLike<T>(value?: any): value is ArrayLike<any>;
/** Tests if the specified type *or* expression is of a function type. Compiles to a constant. */
declare function isFunction<T>(value?: any): value is (...args: any) => any;
/** Tests if the specified type *or* expression is of a nullable reference type. Compiles to a constant. */
declare function isNullable<T>(value?: any): bool;
/** Tests if the specified expression resolves to a defined element. Compiles to a constant. */
declare function isDefined(expression: any): bool;
/** Tests if the specified expression evaluates to a constant value. Compiles to a constant. */
declare function isConstant(expression: any): bool;
/** Tests if the specified type *or* expression is of a managed type. Compiles to a constant. */
declare function isManaged<T>(value?: any): bool;
/** Tests if the specified type is void. Compiles to a constant. */
declare function isVoid<T>(): bool;
/** Traps if the specified value is not true-ish, otherwise returns the (non-nullable) value. */
declare function assert<T>(isTrueish: T, message?: string): T & (object | string | number); // any better way to model `: T != null`?
/** Parses an integer string to a 64-bit float. */
declare function parseInt(str: string, radix?: i32): f64;
/** Parses a string to a 64-bit float. */
declare function parseFloat(str: string): f64;
/** Returns the 64-bit floating-point remainder of `x/y`. */
declare function fmod(x: f64, y: f64): f64;
/** Returns the 32-bit floating-point remainder of `x/y`. */
declare function fmodf(x: f32, y: f32): f32;
/** Returns the number of parameters in the given function signature type. */
declare function lengthof<T extends (...args: any[]) => any>(func?: T): i32;
/** Encodes a text string as a valid Uniform Resource Identifier (URI). */
declare function encodeURI(str: string): string;
/** Encodes a text string as a valid component of a Uniform Resource Identifier (URI). */
declare function encodeURIComponent(str: string): string;
/** Decodes a Uniform Resource Identifier (URI) previously created by encodeURI. */
declare function decodeURI(str: string): string;
/** Decodes a Uniform Resource Identifier (URI) component previously created by encodeURIComponent. */
declare function decodeURIComponent(str: string): string;

/** Atomic operations. */
declare namespace atomic {
  /** Atomically loads an integer value from memory and returns it. */
  export function load<T>(ptr: usize, immOffset?: usize): T;
  /** Atomically stores an integer value to memory. */
  export function store<T>(ptr: usize, value: T, immOffset?: usize): void;
  /** Atomically adds an integer value in memory. */
  export function add<T>(ptr: usize, value: T, immOffset?: usize): T;
  /** Atomically subtracts an integer value in memory. */
  export function sub<T>(ptr: usize, value: T, immOffset?: usize): T;
  /** Atomically performs a bitwise AND operation on an integer value in memory. */
  export function and<T>(ptr: usize, value: T, immOffset?: usize): T;
  /** Atomically performs a bitwise OR operation on an integer value in memory. */
  export function or<T>(ptr: usize, value: T, immOffset?: usize): T;
  /** Atomically performs a bitwise XOR operation on an integer value in memory. */
  export function xor<T>(ptr: usize, value: T, immOffset?: usize): T;
  /** Atomically exchanges an integer value in memory. */
  export function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;
  /** Atomically compares and exchanges an integer value in memory if the condition is met. */
  export function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;
  /** Performs a wait operation on an address in memory suspending this agent if the integer condition is met. */
  export function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;
  /** Performs a notify operation on an address in memory waking up suspended agents. */
  export function notify(ptr: usize, count: i32): i32;
  /** Performs a fence operation, preserving synchronization guarantees of higher level languages. */
  export function fence(): void;
}

/** Describes the result of an atomic wait operation. */
declare enum AtomicWaitResult {
  /** Woken by another agent. */
  OK,
  /** Loaded value did not match the expected value. */
  NOT_EQUAL,
  /** Not woken before the timeout expired. */
  TIMED_OUT
}

/** Converts any other numeric value to an 8-bit signed integer. */
declare function i8(value: any): i8;
declare namespace i8 {
  /** Smallest representable value. */
  export const MIN_VALUE: i8;
  /** Largest representable value. */
  export const MAX_VALUE: i8;
}
/** Converts any other numeric value to a 16-bit signed integer. */
declare function i16(value: any): i16;
declare namespace i16 {
  /** Smallest representable value. */
  export const MIN_VALUE: i16;
  /** Largest representable value. */
  export const MAX_VALUE: i16;
}
/** Converts any other numeric value to a 32-bit signed integer. */
declare function i32(value: any): i32;
declare namespace i32 {
  /** Smallest representable value. */
  export const MIN_VALUE: i32;
  /** Largest representable value. */
  export const MAX_VALUE: i32;
  /** Loads an 8-bit signed integer value from memory and returns it as a 32-bit integer. */
  export function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;
  /** Loads an 8-bit unsigned integer value from memory and returns it as a 32-bit integer. */
  export function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;
  /** Loads a 16-bit signed integer value from memory and returns it as a 32-bit integer. */
  export function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;
  /** Loads a 16-bit unsigned integer value from memory and returns it as a 32-bit integer. */
  export function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;
  /** Loads a 32-bit integer value from memory. */
  export function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;
  /** Stores a 32-bit integer value to memory as an 8-bit integer. */
  export function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;
  /** Stores a 32-bit integer value to memory as a 16-bit integer. */
  export function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;
  /** Stores a 32-bit integer value to memory. */
  export function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;
  /** Performs the sign-agnostic count leading zero bits operation on a 32-bit integer. All zero bits are considered leading if the value is zero. */
  export function clz(value: i32): i32;
  /** Performs the sign-agnostic count tailing zero bits operation on a 32-bit integer. All zero bits are considered trailing if the value is zero. */
  export function ctz(value: i32): i32;
  /** Performs the sign-agnostic count number of one bits operation on a 32-bit integer. */
  export function popcnt(value: i32): i32;
  /** Performs the sign-agnostic rotate left operation on a 32-bit integer. */
  export function rotl(value: i32, shift: i32): i32;
  /** Performs the sign-agnostic rotate right operation on a 32-bit integer. */
  export function rotr(value: i32, shift: i32): i32;
  /** Reinterprets the bits of the specified 32-bit float as a 32-bit integer. */
  export function reinterpret_f32(value: f32): i32;
  /** Computes the sum of two 32-bit integers. */
  export function add(left: i32, right: i32): i32;
  /** Computes the difference of two 32-bit integers. */
  export function sub(left: i32, right: i32): i32;
  /** Computes the product of two 32-bit integers. */
  export function mul(left: i32, right: i32): i32;
  /** Computes the signed quotient of two 32-bit integers. */
  export function div_s(left: i32, right: i32): i32;
  /** Computes the unsigned quotient of two 32-bit integers. */
  export function div_u(left: i32, right: i32): i32;
  /** Atomic 32-bit integer operations. */
  export namespace atomic {
    /** Atomically loads an 8-bit unsigned integer value from memory and returns it as a 32-bit integer. */
    export function load8_u(ptr: usize, immOffset?: usize): i32;
    /** Atomically loads a 16-bit unsigned integer value from memory and returns it as a 32-bit integer. */
    export function load16_u(ptr: usize, immOffset?: usize): i32;
    /** Atomically loads a 32-bit integer value from memory and returns it. */
    export function load(ptr: usize, immOffset?: usize): i32;
    /** Atomically stores a 32-bit integer value to memory as an 8-bit integer. */
    export function store8(ptr: usize, value: i32, immOffset?: usize): void;
    /** Atomically stores a 32-bit integer value to memory as a 16-bit integer. */
    export function store16(ptr: usize, value: i32, immOffset?: usize): void;
    /** Atomically stores a 32-bit integer value to memory. */
    export function store(ptr: usize, value: i32, immOffset?: usize): void;
    /** Performs a wait operation on a 32-bit integer value in memory suspending this agent if the condition is met. */
    export function wait(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;
    /** Atomic 32-bit integer read-modify-write operations on 8-bit values. */
    export namespace rmw8 {
      /** Atomically adds an 8-bit unsigned integer value in memory. */
      export function add_u(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically subtracts an 8-bit unsigned integer value in memory. */
      export function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically performs a bitwise AND operation an 8-bit unsigned integer value in memory. */
      export function and_u(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically performs a bitwise OR operation an 8-bit unsigned integer value in memory. */
      export function or_u(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically performs a bitwise XOR operation an 8-bit unsigned integer value in memory. */
      export function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically exchanges an 8-bit unsigned integer value in memory. */
      export function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically compares and exchanges an 8-bit unsigned integer value in memory if the condition is met. */
      export function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;
    }
    /** Atomic 32-bit integer read-modify-write operations on 16-bit values. */
    export namespace rmw16 {
      /** Atomically adds a 16-bit unsigned integer value in memory. */
      export function add_u(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically adds a 16-bit unsigned integer value in memory. */
      export function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically performs a bitwise AND operation a 16-bit unsigned integer value in memory. */
      export function and_u(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically performs a bitwise OR operation a 16-bit unsigned integer value in memory. */
      export function or_u(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically performs a bitwise XOR operation a 16-bit unsigned integer value in memory. */
      export function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically exchanges a 16-bit unsigned integer value in memory. */
      export function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically compares and exchanges a 16-bit unsigned integer value in memory if the condition is met. */
      export function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;
    }
    /** Atomic 32-bit integer read-modify-write operations. */
    export namespace rmw {
      /** Atomically adds a 32-bit integer value in memory. */
      export function add(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically subtracts a 32-bit integer value in memory. */
      export function sub(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically performs a bitwise AND operation a 32-bit integer value in memory. */
      export function and(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically performs a bitwise OR operation a 32-bit integer value in memory. */
      export function or(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically performs a bitwise XOR operation a 32-bit integer value in memory. */
      export function xor(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically exchanges a 32-bit integer value in memory. */
      export function xchg(ptr: usize, value: i32, immOffset?: usize): i32;
      /** Atomically compares and exchanges a 32-bit integer value in memory if the condition is met. */
      export function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;
    }
  }
}
/** Converts any other numeric value to a 64-bit signed integer. */
declare function i64(value: any): i64;
declare namespace i64 {
  /** Smallest representable value. */
  export const MIN_VALUE: i64;
  /** Largest representable value. */
  export const MAX_VALUE: i64;
  /** Loads an 8-bit signed integer value from memory and returns it as a 64-bit integer. */
  export function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;
  /** Loads an 8-bit unsigned integer value from memory and returns it as a 64-bit integer. */
  export function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;
  /** Loads a 16-bit signed integer value from memory and returns it as a 64-bit integer. */
  export function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;
  /** Loads a 16-bit unsigned integer value from memory and returns it as a 64-bit integer. */
  export function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;
  /** Loads a 32-bit signed integer value from memory and returns it as a 64-bit integer. */
  export function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;
  /** Loads a 32-bit unsigned integer value from memory and returns it as a 64-bit integer. */
  export function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;
  /** Loads a 64-bit unsigned integer value from memory. */
  export function load(ptr: usize, immOffset?: usize, immAlign?: usize): i64;
  /** Stores a 64-bit integer value to memory as an 8-bit integer. */
  export function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;
  /** Stores a 64-bit integer value to memory as a 16-bit integer. */
  export function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;
  /** Stores a 64-bit integer value to memory as a 32-bit integer. */
  export function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;
  /** Stores a 64-bit integer value to memory. */
  export function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;
  /** Performs the sign-agnostic count leading zero bits operation on a 64-bit integer. All zero bits are considered leading if the value is zero. */
  export function clz(value: i64): i64;
  /** Performs the sign-agnostic count tailing zero bits operation on a 64-bit integer. All zero bits are considered trailing if the value is zero. */
  export function ctz(value: i64): i64;
  /** Performs the sign-agnostic count number of one bits operation on a 64-bit integer. */
  export function popcnt(value: i64): i64;
  /** Performs the sign-agnostic rotate left operation on a 64-bit integer. */
  export function rotl(value: i64, shift: i64): i64;
  /** Performs the sign-agnostic rotate right operation on a 64-bit integer. */
  export function rotr(value: i64, shift: i64): i64;
  /** Reinterprets the bits of the specified 64-bit float as a 64-bit integer. */
  export function reinterpret_f64(value: f64): i64;
  /** Computes the sum of two 64-bit integers. */
  export function add(left: i64, right: i64): i64;
  /** Computes the difference of two 64-bit integers. */
  export function sub(left: i64, right: i64): i64;
  /** Computes the product of two 64-bit integers. */
  export function mul(left: i64, right: i64): i64;
  /** Computes the signed quotient of two 64-bit integers. */
  export function div_s(left: i64, right: i64): i64;
  /** Computes the unsigned quotient of two 64-bit integers. */
  export function div_u(left: i64, right: i64): i64;
  /** Atomic 64-bit integer operations. */
  export namespace atomic {
    /** Atomically loads an 8-bit unsigned integer value from memory and returns it as a 64-bit integer. */
    export function load8_u(ptr: usize, immOffset?: usize): i64;
    /** Atomically loads a 16-bit unsigned integer value from memory and returns it as a 64-bit integer. */
    export function load16_u(ptr: usize, immOffset?: usize): i64;
    /** Atomically loads a 32-bit unsigned integer value from memory and returns it as a 64-bit integer. */
    export function load32_u(ptr: usize, immOffset?: usize): i64;
    /** Atomically loads a 64-bit integer value from memory and returns it. */
    export function load(ptr: usize, immOffset?: usize): i64;
    /** Atomically stores a 64-bit integer value to memory as an 8-bit integer. */
    export function store8(ptr: usize, value: i64, immOffset?: usize): void;
    /** Atomically stores a 64-bit integer value to memory as a 16-bit integer. */
    export function store16(ptr: usize, value: i64, immOffset?: usize): void;
    /** Atomically stores a 64-bit integer value to memory as a 32-bit integer. */
    export function store32(ptr: usize, value: i64, immOffset?: usize): void;
    /** Atomically stores a 64-bit integer value to memory. */
    export function store(ptr: usize, value: i64, immOffset?: usize): void;
    /** Performs a wait operation on a 64-bit integer value in memory suspending this agent if the condition is met. */
    export function wait(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;
    /** Atomic 64-bit integer read-modify-write operations on 8-bit values. */
    export namespace rmw8 {
      /** Atomically adds an 8-bit unsigned integer value in memory. */
      export function add_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically subtracts an 8-bit unsigned integer value in memory. */
      export function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically performs a bitwise AND operation on an 8-bit unsigned integer value in memory. */
      export function and_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically performs a bitwise OR operation on an 8-bit unsigned integer value in memory. */
      export function or_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically performs a bitwise XOR operation on an 8-bit unsigned integer value in memory. */
      export function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically exchanges an 8-bit unsigned integer value in memory. */
      export function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically compares and exchanges an 8-bit unsigned integer value in memory if the condition is met. */
      export function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;
    }
    /** Atomic 64-bit integer read-modify-write operations on 16-bit values. */
    export namespace rmw16 {
      /** Atomically adds a 16-bit unsigned integer value in memory. */
      export function add_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically subtracts a 16-bit unsigned integer value in memory. */
      export function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically performs a bitwise AND operation on a 16-bit unsigned integer value in memory. */
      export function and_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically performs a bitwise OR operation on a 16-bit unsigned integer value in memory. */
      export function or_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically performs a bitwise XOR operation on a 16-bit unsigned integer value in memory. */
      export function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically exchanges a 16-bit unsigned integer value in memory. */
      export function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically compares and exchanges a 16-bit unsigned integer value in memory if the condition is met. */
      export function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;
    }
    /** Atomic 64-bit integer read-modify-write operations on 32-bit values. */
    export namespace rmw32 {
      /** Atomically adds a 32-bit unsigned integer value in memory. */
      export function add_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically subtracts a 32-bit unsigned integer value in memory. */
      export function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically performs a bitwise AND operation on a 32-bit unsigned integer value in memory. */
      export function and_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically performs a bitwise OR operation on a 32-bit unsigned integer value in memory. */
      export function or_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically performs a bitwise XOR operation on a 32-bit unsigned integer value in memory. */
      export function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically exchanges a 32-bit unsigned integer value in memory. */
      export function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically compares and exchanges a 32-bit unsigned integer value in memory if the condition is met. */
      export function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;
    }
    /** Atomic 64-bit integer read-modify-write operations. */
    export namespace rmw {
      /** Atomically adds a 64-bit integer value in memory. */
      export function add(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically subtracts a 64-bit integer value in memory. */
      export function sub(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically performs a bitwise AND operation on a 64-bit integer value in memory. */
      export function and(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically performs a bitwise OR operation on a 64-bit integer value in memory. */
      export function or(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically performs a bitwise XOR operation on a 64-bit integer value in memory. */
      export function xor(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically exchanges a 64-bit integer value in memory. */
      export function xchg(ptr: usize, value: i64, immOffset?: usize): i64;
      /** Atomically compares and exchanges a 64-bit integer value in memory if the condition is met. */
      export function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;
    }
  }
}
/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) signed integer. */
declare var isize: typeof i32 | typeof i64;
/** Converts any other numeric value to an 8-bit unsigned integer. */
declare function u8(value: any): u8;
declare namespace u8 {
  /** Smallest representable value. */
  export const MIN_VALUE: u8;
  /** Largest representable value. */
  export const MAX_VALUE: u8;
}
/** Converts any other numeric value to a 16-bit unsigned integer. */
declare function u16(value: any): u16;
declare namespace u16 {
  /** Smallest representable value. */
  export const MIN_VALUE: u16;
  /** Largest representable value. */
  export const MAX_VALUE: u16;
}
/** Converts any other numeric value to a 32-bit unsigned integer. */
declare function u32(value: any): u32;
declare namespace u32 {
  /** Smallest representable value. */
  export const MIN_VALUE: u32;
  /** Largest representable value. */
  export const MAX_VALUE: u32;
}
/** Converts any other numeric value to a 64-bit unsigned integer. */
declare function u64(value: any): u64;
declare namespace u64 {
  /** Smallest representable value. */
  export const MIN_VALUE: u64;
  /** Largest representable value. */
  export const MAX_VALUE: u64;
}
/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) unsigned integer. */
declare var usize: typeof u32 | typeof u64;
/** Converts any other numeric value to a 1-bit unsigned integer. */
declare function bool(value: any): bool;
declare namespace bool {
  /** Smallest representable value. */
  export const MIN_VALUE: bool;
  /** Largest representable value. */
  export const MAX_VALUE: bool;
}
/** Converts any other numeric value to a 32-bit float. */
declare function f32(value: any): f32;
declare namespace f32 {
  /** Smallest representable value. */
  export const MIN_VALUE: f32;
  /** Largest representable value. */
  export const MAX_VALUE: f32;
  /** Smallest normalized positive value. */
  export const MIN_NORMAL_VALUE: f32;
  /** Smallest safely representable integer value. */
  export const MIN_SAFE_INTEGER: f32;
  /** Largest safely representable integer value. */
  export const MAX_SAFE_INTEGER: f32;
  /** Positive infinity value. */
  export const POSITIVE_INFINITY: f32;
  /** Negative infinity value. */
  export const NEGATIVE_INFINITY: f32;
  /** Not a number value. */
  export const NaN: f32;
  /** Difference between 1 and the smallest representable value greater than 1. */
  export const EPSILON: f32;
  /** Loads a 32-bit float from memory. */
  export function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;
  /** Stores a 32-bit float to memory. */
  export function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;
  /** Computes the sum of two 32-bit floats. */
  export function add(left: f32, right: f32): f32;
  /** Computes the difference of two 32-bit floats. */
  export function sub(left: f32, right: f32): f32;
  /** Computes the product of two 32-bit floats. */
  export function mul(left: f32, right: f32): f32;
  /** Computes the quotient of two 32-bit floats. */
  export function div(left: f32, right: f32): f32;
  /** Computes the absolute value of a 32-bit float. */
  export function abs(value: f32): f32;
  /** Determines the maximum of two 32-bit floats. If either operand is `NaN`, returns `NaN`. */
  export function max(left: f32, right: f32): f32;
  /** Determines the minimum of two 32-bit floats. If either operand is `NaN`, returns `NaN`. */
  export function min(left: f32, right: f32): f32;
  /** Performs the ceiling operation on a 32-bit float. */
  export function ceil(value: f32): f32;
  /** Composes a 32-bit float from the magnitude of `x` and the sign of `y`. */
  export function copysign(x: f32, y: f32): f32;
  /** Performs the floor operation on a 32-bit float. */
  export function floor(value: f32): f32;
  /** Rounds to the nearest integer tied to even of a 32-bit float. */
  export function nearest(value: f32): f32;
  /** Reinterprets the bits of the specified 32-bit integer as a 32-bit float. */
  export function reinterpret_i32(value: i32): f32;
  /** Calculates the square root of a 32-bit float. */
  export function sqrt(value: f32): f32;
  /** Rounds to the nearest integer towards zero of a 32-bit float. */
  export function trunc(value: f32): f32;
}
/** Converts any other numeric value to a 64-bit float. */
declare function f64(value: any): f64;
declare namespace f64 {
  /** Smallest representable value. */
  export const MIN_VALUE: f64;
  /** Largest representable value. */
  export const MAX_VALUE: f64;
  /** Smallest normalized positive value. */
  export const MIN_NORMAL_VALUE: f64;
  /** Smallest safely representable integer value. */
  export const MIN_SAFE_INTEGER: f64;
  /** Largest safely representable integer value. */
  export const MAX_SAFE_INTEGER: f64;
  /** Positive infinity value. */
  export const POSITIVE_INFINITY: f64;
  /** Negative infinity value. */
  export const NEGATIVE_INFINITY: f64;
  /** Not a number value. */
  export const NaN: f64;
  /** Difference between 1 and the smallest representable value greater than 1. */
  export const EPSILON: f64;
  /** Loads a 64-bit float from memory. */
  export function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;
  /** Stores a 64-bit float to memory. */
  export function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;
  /** Computes the sum of two 64-bit floats. */
  export function add(left: f64, right: f64): f64;
  /** Computes the difference of two 64-bit floats. */
  export function sub(left: f64, right: f64): f64;
  /** Computes the product of two 64-bit floats. */
  export function mul(left: f64, right: f64): f64;
  /** Computes the quotient of two 64-bit floats. */
  export function div(left: f64, right: f64): f64;
  /** Computes the absolute value of a 64-bit float. */
  export function abs(value: f64): f64;
  /** Determines the maximum of two 64-bit floats. If either operand is `NaN`, returns `NaN`. */
  export function max(left: f64, right: f64): f64;
  /** Determines the minimum of two 64-bit floats. If either operand is `NaN`, returns `NaN`. */
  export function min(left: f64, right: f64): f64;
  /** Performs the ceiling operation on a 64-bit float. */
  export function ceil(value: f64): f64;
  /** Composes a 64-bit float from the magnitude of `x` and the sign of `y`. */
  export function copysign(x: f64, y: f64): f64;
  /** Performs the floor operation on a 64-bit float. */
  export function floor(value: f64): f64;
  /** Rounds to the nearest integer tied to even of a 64-bit float. */
  export function nearest(value: f64): f64;
  /** Reinterprets the bits of the specified 64-bit integer as a 64-bit float. */
  export function reinterpret_i64(value: i64): f64;
  /** Calculates the square root of a 64-bit float. */
  export function sqrt(value: f64): f64;
  /** Rounds to the nearest integer towards zero of a 64-bit float. */
  export function trunc(value: f64): f64;
}
/** Initializes a 128-bit vector from sixteen 8-bit integer values. Arguments must be compile-time constants. */
declare function v128(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8, i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8): v128;
declare namespace v128 {
  /** Creates a vector with identical lanes. */
  export function splat<T>(x: T): v128;
  /** Extracts one lane as a scalar. */
  export function extract_lane<T>(x: v128, idx: u8): T;
  /** Replaces one lane. */
  export function replace_lane<T>(x: v128, idx: u8, value: T): v128;
  /** Selects lanes from either vector according to the specified lane indexes. */
  export function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;
  /** Selects 8-bit lanes from the first vector according to the indexes [0-15] specified by the 8-bit lanes of the second vector. */
  export function swizzle(a: v128, s: v128): v128;
  /** Loads a vector from memory. */
  export function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;
  /** Creates a vector by loading the lanes of the specified type and extending each to the next larger type. */
  export function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;
  /** Creates a vector by loading a value of the specified type into the lowest bits and initializing all other bits of the vector to zero. */
  export function load_zero<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;
  /** Loads a single lane from memory into the specified lane of the given vector. Other lanes are bypassed as is. */
  export function load_lane<T>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;
  /** Stores the single lane at the specified index of the given vector to memory. */
  export function store_lane<T>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;
  /** Creates a vector with eight 16-bit integer lanes by loading and sign extending eight 8-bit integers. */
  export function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;
  /** Creates a vector with eight 16-bit integer lanes by loading and zero extending eight 8-bit integers. */
  export function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;
  /** Creates a vector with four 32-bit integer lanes by loading and sign extending four 16-bit integers. */
  export function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;
  /** Creates a vector with four 32-bit integer lanes by loading and zero extending four 16-bit integers. */
  export function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;
  /** Creates a vector with two 64-bit integer lanes by loading and sign extending two 32-bit integers. */
  export function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;
  /** Creates a vector with two 64-bit integer lanes by loading and zero extending two 32-bit integers. */
  export function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;
  /** Creates a vector with identical lanes by loading the splatted value. */
  export function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;
  /** Loads an 8-bit integer and splats it sixteen times forming a new vector. */
  export function load8_splat(ptr: usize, immOffset?: usize, immAlign?: usize): v128;
  /** Loads a 16-bit integer and splats it eight times forming a new vector. */
  export function load16_splat(ptr: usize, immOffset?: usize, immAlign?: usize): v128;
  /** Loads a 32-bit integer and splats it four times forming a new vector. */
  export function load32_splat(ptr: usize, immOffset?: usize, immAlign?: usize): v128;
  /** Loads a 64-bit integer and splats it two times forming a new vector. */
  export function load64_splat(ptr: usize, immOffset?: usize, immAlign?: usize): v128;
  /** Creates a vector by loading a 32-bit value into the lowest bits and initializing all other bits of the vector to zero. */
  export function load32_zero(ptr: usize, immOffset?: usize, immAlign?: usize): v128;
  /** Creates a vector by loading a 64-bit value into the lowest bits and initializing all other bits of the vector to zero. */
  export function load64_zero(ptr: usize, immOffset?: usize, immAlign?: usize): v128;
  /** Loads a single 8-bit lane from memory into the specified lane of the given vector. Other lanes are bypassed as is. */
  export function load8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;
  /** Loads a single 16-bit lane from memory into the specified lane of the given vector. Other lanes are bypassed as is. */
  export function load16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;
  /** Loads a single 32-bit lane from memory into the specified lane of the given vector. Other lanes are bypassed as is. */
  export function load32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;
  /** Loads a single 64-bit lane from memory into the specified lane of the given vector. Other lanes are bypassed as is. */
  export function load64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;
  /** Stores the 8-bit lane at the specified lane of the given vector to memory. */
  export function store8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;
  /** Stores the 16-bit lane at the specified lane of the given vector to memory. */
  export function store16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;
  /** Stores the 32-bit lane at the specified lane of the given vector to memory. */
  export function store32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;
  /** Stores the 64-bit lane at the specified lane of the given vector to memory. */
  export function store64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;
  /** Stores a vector to memory. */
  export function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;
  /** Adds each lane. */
  export function add<T>(a: v128, b: v128): v128;
  /** Subtracts each lane. */
  export function sub<T>(a: v128, b: v128): v128;
  /** Multiplies each lane. */
  export function mul<T>(a: v128, b: v128): v128; // except i64
  /** Divides each lane. */
  export function div<T extends f32 | f64>(a: v128, b: v128): v128;
  /** Negates each lane of a vector. */
  export function neg<T>(a: v128): v128;
  /** Adds each lane using saturation. */
  export function add_sat<T>(a: v128, b: v128): v128;
  /** Subtracts each lane using saturation. */
  export function sub_sat<T>(a: v128, b: v128): v128;
  /** Performs a bitwise left shift on each lane of a vector by a scalar. */
  export function shl<T>(a: v128, b: i32): v128;
  /** Performs a bitwise right shift on each lane of a vector by a scalar. */
  export function shr<T>(a: v128, b: i32): v128;
  /** Performs the bitwise AND operation on two vectors. */
  export function and(a: v128, b: v128): v128;
  /** Performs the bitwise OR operation on two vectors. */
  export function or(a: v128, b: v128): v128;
  /** Performs the bitwise XOR operation on two vectors. */
  export function xor(a: v128, b: v128): v128;
  /** Performs the bitwise ANDNOT operation on two vectors. */
  export function andnot(a: v128, b: v128): v128;
  /** Performs the bitwise NOT operation on a vector. */
  export function not(a: v128): v128;
  /** Selects bits of either vector according to the specified mask. */
  export function bitselect(v1: v128, v2: v128, mask: v128): v128;
  /** Reduces a vector to a scalar indicating whether any lane is considered `true`. */
  export function any_true(a: v128): bool;
  /** Reduces a vector to a scalar indicating whether all lanes are considered `true`. */
  export function all_true<T>(a: v128): bool;
  /** Extracts the high bit of each lane and produces a scalar mask with all bits concatenated. */
  export function bitmask<T>(a: v128): i32;
  /** Counts the number of bits set to one within each lane. */
  export function popcnt<T>(a: v128): v128;
  /** Computes the minimum of each lane. */
  export function min<T>(a: v128, b: v128): v128;
  /** Computes the maximum of each lane. */
  export function max<T>(a: v128, b: v128): v128;
  /** Computes the pseudo-minimum of each lane. */
  export function pmin<T>(a: v128, b: v128): v128;
  /** Computes the pseudo-maximum of each lane. */
  export function pmax<T>(a: v128, b: v128): v128;
  /** Computes the dot product of two lanes each, yielding lanes one size wider than the input. */
  export function dot<T extends i16>(a: v128, b: v128): v128;
  /** Computes the average of each lane. */
  export function avgr<T extends u8 | u16>(a: v128, b: v128): v128;
  /** Computes the absolute value of each lane. */
  export function abs<T extends f32 | f64>(a: v128): v128;
  /** Computes the square root of each lane. */
  export function sqrt<T extends f32 | f64>(a: v128): v128;
  /** Performs the ceiling operation on each lane. */
  export function ceil<T extends f32 | f64>(a: v128): v128;
  /** Performs the floor operation on each lane. */
  export function floor<T extends f32 | f64>(a: v128): v128;
  /** Rounds to the nearest integer towards zero of each lane. */
  export function trunc<T extends f32 | f64>(a: v128): v128;
  /** Rounds to the nearest integer tied to even of each lane. */
  export function nearest<T extends f32 | f64>(a: v128): v128;
  /** Computes which lanes are equal. */
  export function eq<T>(a: v128, b: v128): v128;
  /** Computes which lanes are not equal. */
  export function ne<T>(a: v128, b: v128): v128;
  /** Computes which lanes of the first vector are less than those of the second. */
  export function lt<T>(a: v128, b: v128): v128;
  /** Computes which lanes of the first vector are less than or equal those of the second. */
  export function le<T>(a: v128, b: v128): v128;
  /** Computes which lanes of the first vector are greater than those of the second. */
  export function gt<T>(a: v128, b: v128): v128;
  /** Computes which lanes of the first vector are greater than or equal those of the second. */
  export function ge<T>(a: v128, b: v128): v128;
  /** Converts each lane of a vector from integer to single-precision floating point. */
  export function convert<TFrom extends i32 | u32>(a: v128): v128;
  /** Converts the low lanes of a vector from integer to double-precision floating point. */
  export function convert_low<TFrom extends i32 | u32>(a: v128): v128;
  /** Truncates each lane of a vector from single-precision floating point to integer with saturation. Takes the target type. */
  export function trunc_sat<TTo extends i32 | u32>(a: v128): v128;
  /** Truncates each lane of a vector from double-precision floating point to integer with saturation. Takes the target type. */
  export function trunc_sat_zero<TTo extends i32 | u32>(a: v128): v128;
  /** Narrows each lane to their respective narrower lanes. */
  export function narrow<TFrom extends i16 | i32>(a: v128, b: v128): v128;
  /** Extends the low lanes of a vector to their respective wider lanes. */
  export function extend_low<TFrom extends i8 | u8 | i16 | u16 | i32 | u32>(a: v128): v128;
  /** Extends the high lanes of a vector to their respective wider lanes. */
  export function extend_high<TFrom extends i8 | u8 | i16 | u16 | i32 | u32>(a: v128): v128;
  /** Adds lanes pairwise producing twice wider extended results. */
  export function extadd_pairwise<TFrom extends i8 | u8 | i16 | u16>(a: v128): v128;
  /** Demotes each float lane to lower precision. The higher lanes of the result are initialized to zero. */
  export function demote_zero<T extends f64 = f64>(a: v128): v128;
  /** Promotes the lower float lanes to higher precision. */
  export function promote_low<T extends f32 = f32>(a: v128): v128;
  /** Performs the line-wise saturating rounding multiplication in Q15 format. */
  export function q15mulr_sat<T extends i16>(a: v128, b: v128): v128;
  /** Performs the lane-wise integer extended multiplication of the lower lanes producing a twice wider result than the inputs. */
  export function extmul_low<T extends i8 | u8 | i16 | u16 | i32 | u32>(a: v128, b: v128): v128;
  /** Performs the lane-wise integer extended multiplication of the higher lanes producing a twice wider result than the inputs. */
  export function extmul_high<T extends i8 | u8 | i16 | u16 | i32 | u32>(a: v128, b: v128): v128;
}
/** Initializes a 128-bit vector from sixteen 8-bit integer values. Arguments must be compile-time constants. */
declare function i8x16(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8, i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8): v128;
declare namespace i8x16 {
  /** Creates a vector with sixteen identical 8-bit integer lanes. */
  export function splat(x: i8): v128;
  /** Extracts one 8-bit integer lane as a signed scalar. */
  export function extract_lane_s(x: v128, idx: u8): i8;
  /** Extracts one 8-bit integer lane as an unsigned scalar. */
  export function extract_lane_u(x: v128, idx: u8): u8;
  /** Replaces one 8-bit integer lane. */
  export function replace_lane(x: v128, idx: u8, value: i8): v128;
  /** Adds each 8-bit integer lane. */
  export function add(a: v128, b: v128): v128;
  /** Subtracts each 8-bit integer lane. */
  export function sub(a: v128, b: v128): v128;
  /** Computes the signed minimum of each 8-bit integer lane. */
  export function min_s(a: v128, b: v128): v128;
  /** Computes the unsigned minimum of each 8-bit integer lane. */
  export function min_u(a: v128, b: v128): v128;
  /** Computes the signed maximum of each 8-bit integer lane. */
  export function max_s(a: v128, b: v128): v128;
  /** Computes the unsigned maximum of each 8-bit integer lane. */
  export function max_u(a: v128, b: v128): v128;
  /** Computes the unsigned average of each 8-bit integer lane. */
  export function avgr_u(a: v128, b: v128): v128;
  /** Computes the absolute value of each 8-bit integer lane. */
  export function abs(a: v128): v128;
  /** Negates each 8-bit integer lane. */
  export function neg(a: v128): v128;
  /** Adds each 8-bit integer lane using signed saturation. */
  export function add_sat_s(a: v128, b: v128): v128;
  /** Adds each 8-bit integer lane using unsigned saturation. */
  export function add_sat_u(a: v128, b: v128): v128;
  /** Subtracts each 8-bit integer lane using signed saturation. */
  export function sub_sat_s(a: v128, b: v128): v128;
  /** Subtracts each 8-bit integer lane using unsigned saturation. */
  export function sub_sat_u(a: v128, b: v128): v128;
  /** Performs a bitwise left shift on each 8-bit integer lane by a scalar. */
  export function shl(a: v128, b: i32): v128;
  /** Performs a bitwise arithmetic right shift on each 8-bit integer lane by a scalar. */
  export function shr_s(a: v128, b: i32): v128;
  /** Performs a bitwise logical right shift on each 8-bit integer lane by a scalar. */
  export function shr_u(a: v128, b: i32): v128;
  /** Reduces a vector to a scalar indicating whether all 8-bit integer lanes are considered `true`. */
  export function all_true(a: v128): bool;
  /** Extracts the high bit of each 8-bit integer lane and produces a scalar mask with all bits concatenated. */
  export function bitmask(a: v128): i32;
  /** Counts the number of bits set to one within each 8-bit integer lane. */
  export function popcnt(a: v128): v128;
  /** Computes which 8-bit integer lanes are equal. */
  export function eq(a: v128, b: v128): v128;
  /** Computes which 8-bit integer lanes are not equal. */
  export function ne(a: v128, b: v128): v128;
  /** Computes which 8-bit signed integer lanes of the first vector are less than those of the second. */
  export function lt_s(a: v128, b: v128): v128;
  /** Computes which 8-bit unsigned integer lanes of the first vector are less than those of the second. */
  export function lt_u(a: v128, b: v128): v128;
  /** Computes which 8-bit signed integer lanes of the first vector are less than or equal those of the second. */
  export function le_s(a: v128, b: v128): v128;
  /** Computes which 8-bit unsigned integer lanes of the first vector are less than or equal those of the second. */
  export function le_u(a: v128, b: v128): v128;
  /** Computes which 8-bit signed integer lanes of the first vector are greater than those of the second. */
  export function gt_s(a: v128, b: v128): v128;
  /** Computes which 8-bit unsigned integer lanes of the first vector are greater than those of the second. */
  export function gt_u(a: v128, b: v128): v128;
  /** Computes which 8-bit signed integer lanes of the first vector are greater than or equal those of the second. */
  export function ge_s(a: v128, b: v128): v128;
  /** Computes which 8-bit unsigned integer lanes of the first vector are greater than or equal those of the second. */
  export function ge_u(a: v128, b: v128): v128;
  /** Narrows each 16-bit signed integer lane to 8-bit signed integer lanes. */
  export function narrow_i16x8_s(a: v128, b: v128): v128;
  /** Narrows each 16-bit signed integer lane to 8-bit unsigned integer lanes. */
  export function narrow_i16x8_u(a: v128, b: v128): v128;
  /** Selects 8-bit lanes from either vector according to the specified [0-15] respectively [16-31] lane indexes. */
  export function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8, l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8): v128;
  /** Selects 8-bit lanes from the first vector according to the indexes [0-15] specified by the 8-bit lanes of the second vector. */
  export function swizzle(a: v128, s: v128): v128;
}
/** Initializes a 128-bit vector from eight 16-bit integer values. Arguments must be compile-time constants. */
declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;
declare namespace i16x8 {
  /** Creates a vector with eight identical 16-bit integer lanes. */
  export function splat(x: i16): v128;
  /** Extracts one 16-bit integer lane as a signed scalar. */
  export function extract_lane_s(x: v128, idx: u8): i16;
  /** Extracts one 16-bit integer lane as an unsigned scalar. */
  export function extract_lane_u(x: v128, idx: u8): u16;
  /** Replaces one 16-bit integer lane. */
  export function replace_lane(x: v128, idx: u8, value: i16): v128;
  /** Adds each 16-bit integer lane. */
  export function add(a: v128, b: v128): v128;
  /** Subtracts each 16-bit integer lane. */
  export function sub(a: v128, b: v128): v128;
  /** Multiplies each 16-bit integer lane. */
  export function mul(a: v128, b: v128): v128;
  /** Computes the signed minimum of each 16-bit integer lane. */
  export function min_s(a: v128, b: v128): v128;
  /** Computes the unsigned minimum of each 16-bit integer lane. */
  export function min_u(a: v128, b: v128): v128;
  /** Computes the signed maximum of each 16-bit integer lane. */
  export function max_s(a: v128, b: v128): v128;
  /** Computes the unsigned maximum of each 16-bit integer lane. */
  export function max_u(a: v128, b: v128): v128;
  /** Computes the unsigned average of each 16-bit integer lane. */
  export function avgr_u(a: v128, b: v128): v128;
  /** Computes the absolute value of each 16-bit integer lane. */
  export function abs(a: v128): v128;
  /** Negates each 16-bit integer lane. */
  export function neg(a: v128): v128;
  /** Adds each 16-bit integer lane using signed saturation. */
  export function add_sat_s(a: v128, b: v128): v128;
  /** Adds each 16-bit integer lane using unsigned saturation. */
  export function add_sat_u(a: v128, b: v128): v128;
  /** Subtracts each 16-bit integer lane using signed saturation. */
  export function sub_sat_s(a: v128, b: v128): v128;
  /** Subtracts each 16-bit integer lane using unsigned saturation. */
  export function sub_sat_u(a: v128, b: v128): v128;
  /** Performs a bitwise left shift on each 16-bit integer lane by a scalar. */
  export function shl(a: v128, b: i32): v128;
  /** Performs a bitwise arithmetic right shift each 16-bit integer lane by a scalar. */
  export function shr_s(a: v128, b: i32): v128;
  /** Performs a bitwise logical right shift on each 16-bit integer lane by a scalar. */
  export function shr_u(a: v128, b: i32): v128;
  /** Reduces a vector to a scalar indicating whether all 16-bit integer lanes are considered `true`. */
  export function all_true(a: v128): bool;
  /** Extracts the high bit of each 16-bit integer lane and produces a scalar mask with all bits concatenated. */
  export function bitmask(a: v128): i32;
  /** Computes which 16-bit integer lanes are equal. */
  export function eq(a: v128, b: v128): v128;
  /** Computes which 16-bit integer lanes are not equal. */
  export function ne(a: v128, b: v128): v128;
  /** Computes which 16-bit signed integer lanes of the first vector are less than those of the second. */
  export function lt_s(a: v128, b: v128): v128;
  /** Computes which 16-bit unsigned integer lanes of the first vector are less than those of the second. */
  export function lt_u(a: v128, b: v128): v128;
  /** Computes which 16-bit signed integer lanes of the first vector are less than or equal those of the second. */
  export function le_s(a: v128, b: v128): v128;
  /** Computes which 16-bit unsigned integer lanes of the first vector are less than or equal those of the second. */
  export function le_u(a: v128, b: v128): v128;
  /** Computes which 16-bit signed integer lanes of the first vector are greater than those of the second. */
  export function gt_s(a: v128, b: v128): v128;
  /** Computes which 16-bit unsigned integer lanes of the first vector are greater than those of the second. */
  export function gt_u(a: v128, b: v128): v128;
  /** Computes which 16-bit signed integer lanes of the first vector are greater than or equal those of the second. */
  export function ge_s(a: v128, b: v128): v128;
  /** Computes which 16-bit unsigned integer lanes of the first vector are greater than or equal those of the second. */
  export function ge_u(a: v128, b: v128): v128;
  /** Narrows each 32-bit signed integer lane to 16-bit signed integer lanes. */
  export function narrow_i32x4_s(a: v128, b: v128): v128;
  /** Narrows each 32-bit signed integer lane to 16-bit unsigned integer lanes. */
  export function narrow_i32x4_u(a: v128, b: v128): v128;
  /** Extends the low 8-bit signed integer lanes to 16-bit signed integer lanes. */
  export function extend_low_i8x16_s(a: v128): v128;
  /** Extends the low 8-bit unsigned integer lanes to 16-bit unsigned integer lanes. */
  export function extend_low_i8x16_u(a: v128): v128;
  /** Extends the high 8-bit signed integer lanes to 16-bit signed integer lanes. */
  export function extend_high_i8x16_s(a: v128): v128;
  /** Extends the high 8-bit unsigned integer lanes to 16-bit unsigned integer lanes. */
  export function extend_high_i8x16_u(a: v128): v128;
  /** Adds the sixteen 8-bit signed integer lanes pairwise producing eight 16-bit signed integer results. */
  export function extadd_pairwise_i8x16_s(a: v128): v128;
  /** Adds the sixteen 8-bit unsigned integer lanes pairwise producing eight 16-bit unsigned integer results. */
  export function extadd_pairwise_i8x16_u(a: v128): v128;
  /** Performs the line-wise 16-bit signed integer saturating rounding multiplication in Q15 format. */
  export function q15mulr_sat_s(a: v128, b: v128): v128;
  /** Performs the lane-wise 8-bit signed integer extended multiplication of the eight lower lanes producing twice wider 16-bit integer results. */
  export function extmul_low_i8x16_s(a: v128, b: v128): v128;
  /** Performs the lane-wise 8-bit unsigned integer extended multiplication of the eight lower lanes producing twice wider 16-bit integer results. */
  export function extmul_low_i8x16_u(a: v128, b: v128): v128;
  /** Performs the lane-wise 8-bit signed integer extended multiplication of the eight higher lanes producing twice wider 16-bit integer results. */
  export function extmul_high_i8x16_s(a: v128, b: v128): v128;
  /** Performs the lane-wise 8-bit unsigned integer extended multiplication of the eight higher lanes producing twice wider 16-bit integer results. */
  export function extmul_high_i8x16_u(a: v128, b: v128): v128;
}
/** Initializes a 128-bit vector from four 32-bit integer values. Arguments must be compile-time constants. */
declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;
declare namespace i32x4 {
  /** Creates a vector with four identical 32-bit integer lanes. */
  export function splat(x: i32): v128;
  /** Extracts one 32-bit integer lane as a scalar. */
  export function extract_lane(x: v128, idx: u8): i32;
  /** Replaces one 32-bit integer lane. */
  export function replace_lane(x: v128, idx: u8, value: i32): v128;
  /** Adds each 32-bit integer lane. */
  export function add(a: v128, b: v128): v128;
  /** Subtracts each 32-bit integer lane. */
  export function sub(a: v128, b: v128): v128;
  /** Multiplies each 32-bit integer lane. */
  export function mul(a: v128, b: v128): v128;
  /** Computes the signed minimum of each 32-bit integer lane. */
  export function min_s(a: v128, b: v128): v128;
  /** Computes the unsigned minimum of each 32-bit integer lane. */
  export function min_u(a: v128, b: v128): v128;
  /** Computes the signed maximum of each 32-bit integer lane. */
  export function max_s(a: v128, b: v128): v128;
  /** Computes the unsigned maximum of each 32-bit integer lane. */
  export function max_u(a: v128, b: v128): v128;
  /** Computes the dot product of two 16-bit integer lanes each, yielding 32-bit integer lanes. */
  export function dot_i16x8_s(a: v128, b: v128): v128;
  /** Computes the absolute value of each 32-bit integer lane. */
  export function abs(a: v128): v128;
  /** Negates each 32-bit integer lane. */
  export function neg(a: v128): v128;
  /** Performs a bitwise left shift on each 32-bit integer lane by a scalar. */
  export function shl(a: v128, b: i32): v128;
  /** Performs a bitwise arithmetic right shift on each 32-bit integer lane by a scalar. */
  export function shr_s(a: v128, b: i32): v128;
  /** Performs a bitwise logical right shift on each 32-bit integer lane by a scalar. */
  export function shr_u(a: v128, b: i32): v128;
  /** Reduces a vector to a scalar indicating whether all 32-bit integer lanes are considered `true`. */
  export function all_true(a: v128): bool;
  /** Extracts the high bit of each 32-bit integer lane and produces a scalar mask with all bits concatenated. */
  export function bitmask(a: v128): i32;
  /** Computes which 32-bit integer lanes are equal. */
  export function eq(a: v128, b: v128): v128;
  /** Computes which 32-bit integer lanes are not equal. */
  export function ne(a: v128, b: v128): v128;
  /** Computes which 32-bit signed integer lanes of the first vector are less than those of the second. */
  export function lt_s(a: v128, b: v128): v128;
  /** Computes which 32-bit unsigned integer lanes of the first vector are less than those of the second. */
  export function lt_u(a: v128, b: v128): v128;
  /** Computes which 32-bit signed integer lanes of the first vector are less than or equal those of the second. */
  export function le_s(a: v128, b: v128): v128;
  /** Computes which 32-bit unsigned integer lanes of the first vector are less than or equal those of the second. */
  export function le_u(a: v128, b: v128): v128;
  /** Computes which 32-bit signed integer lanes of the first vector are greater than those of the second. */
  export function gt_s(a: v128, b: v128): v128;
  /** Computes which 32-bit unsigned integer lanes of the first vector are greater than those of the second. */
  export function gt_u(a: v128, b: v128): v128;
  /** Computes which 32-bit signed integer lanes of the first vector are greater than or equal those of the second. */
  export function ge_s(a: v128, b: v128): v128;
  /** Computes which 32-bit unsigned integer lanes of the first vector are greater than or equal those of the second. */
  export function ge_u(a: v128, b: v128): v128;
  /** Truncates each 32-bit float lane to a signed integer with saturation. */
  export function trunc_sat_f32x4_s(a: v128): v128;
  /** Truncates each 32-bit float lane to an unsigned integer with saturation. */
  export function trunc_sat_f32x4_u(a: v128): v128;
  /** Truncates the two 64-bit float lanes to the two lower signed integer lanes with saturation. The two higher integer lanes of the result are initialized to zero. */
  export function trunc_sat_f64x2_s_zero(a: v128): v128;
  /** Truncates the two 64-bit float lanes to the two lower unsigned integer lanes with saturation. The two higher integer lanes of the result are initialized to zero. */
  export function trunc_sat_f64x2_u_zero(a: v128): v128;
  /** Extends the low 16-bit signed integer lanes to 32-bit signed integer lanes. */
  export function extend_low_i16x8_s(a: v128): v128;
  /** Extends the low 16-bit unsigned integer lane to 32-bit unsigned integer lanes. */
  export function extend_low_i16x8_u(a: v128): v128;
  /** Extends the high 16-bit signed integer lanes to 32-bit signed integer lanes. */
  export function extend_high_i16x8_s(a: v128): v128;
  /** Extends the high 16-bit unsigned integer lanes to 32-bit unsigned integer lanes. */
  export function extend_high_i16x8_u(a: v128): v128;
  /** Adds the eight 16-bit signed integer lanes pairwise producing four 32-bit signed integer results. */
  export function extadd_pairwise_i16x8_s(a: v128): v128;
  /** Adds the eight 16-bit unsigned integer lanes pairwise producing four 32-bit unsigned integer results. */
  export function extadd_pairwise_i16x8_u(a: v128): v128;
  /** Performs the lane-wise 16-bit signed integer extended multiplication of the four lower lanes producing twice wider 32-bit integer results. */
  export function extmul_low_i16x8_s(a: v128, b: v128): v128;
  /** Performs the lane-wise 16-bit unsigned integer extended multiplication of the four lower lanes producing twice wider 32-bit integer results. */
  export function extmul_low_i16x8_u(a: v128, b: v128): v128;
  /** Performs the lane-wise 16-bit signed integer extended multiplication of the four higher lanes producing twice wider 32-bit integer results. */
  export function extmul_high_i16x8_s(a: v128, b: v128): v128;
  /** Performs the lane-wise 16-bit unsigned integer extended multiplication of the four higher lanes producing twice wider 32-bit integer results. */
  export function extmul_high_i16x8_u(a: v128, b: v128): v128;
}
/** Initializes a 128-bit vector from two 64-bit integer values. Arguments must be compile-time constants. */
declare function i64x2(a: i64, b: i64): v128;
declare namespace i64x2 {
  /** Creates a vector with two identical 64-bit integer lanes. */
  export function splat(x: i64): v128;
  /** Extracts one 64-bit integer lane as a scalar. */
  export function extract_lane(x: v128, idx: u8): i64;
  /** Replaces one 64-bit integer lane. */
  export function replace_lane(x: v128, idx: u8, value: i64): v128;
  /** Adds each 64-bit integer lane. */
  export function add(a: v128, b: v128): v128;
  /** Subtracts each 64-bit integer lane. */
  export function sub(a: v128, b: v128): v128;
  /** Multiplies each 64-bit integer lane. */
  export function mul(a: v128, b: v128): v128;
  /** Computes the absolute value of each 64-bit integer lane. */
  export function abs(a: v128): v128;
  /** Negates each 64-bit integer lane. */
  export function neg(a: v128): v128;
  /** Performs a bitwise left shift on each 64-bit integer lane by a scalar. */
  export function shl(a: v128, b: i32): v128;
  /** Performs a bitwise arithmetic right shift on each 64-bit integer lane by a scalar. */
  export function shr_s(a: v128, b: i32): v128;
  /** Performs a bitwise logical right shift on each 64-bit integer lane by a scalar. */
  export function shr_u(a: v128, b: i32): v128;
  /** Reduces a vector to a scalar indicating whether all 64-bit integer lanes are considered `true`. */
  export function all_true(a: v128): bool;
  /** Extracts the high bit of each 64-bit integer lane and produces a scalar mask with all bits concatenated. */
  export function bitmask(a: v128): i32;
  /** Computes which 64-bit integer lanes are equal. */
  export function eq(a: v128, b: v128): v128;
  /** Computes which 64-bit integer lanes are not equal. */
  export function ne(a: v128, b: v128): v128;
  /** Computes which 64-bit signed integer lanes of the first vector are less than those of the second. */
  export function lt_s(a: v128, b: v128): v128;
  /** Computes which 64-bit signed integer lanes of the first vector are less than or equal those of the second. */
  export function le_s(a: v128, b: v128): v128;
  /** Computes which 64-bit signed integer lanes of the first vector are greater than those of the second. */
  export function gt_s(a: v128, b: v128): v128;
  /** Computes which 64-bit signed integer lanes of the first vector are greater than or equal those of the second. */
  export function ge_s(a: v128, b: v128): v128;
  /** Extends the low 32-bit signed integer lanes to 64-bit signed integer lanes. */
  export function extend_low_i32x4_s(a: v128): v128;
  /** Extends the low 32-bit unsigned integer lane to 64-bit unsigned integer lanes. */
  export function extend_low_i32x4_u(a: v128): v128;
  /** Extends the high 32-bit signed integer lanes to 64-bit signed integer lanes. */
  export function extend_high_i32x4_s(a: v128): v128;
  /** Extends the high 32-bit unsigned integer lanes to 64-bit unsigned integer lanes. */
  export function extend_high_i32x4_u(a: v128): v128;
  /** Performs the lane-wise 32-bit signed integer extended multiplication of the two lower lanes producing twice wider 64-bit integer results. */
  export function extmul_low_i32x4_s(a: v128, b: v128): v128;
  /** Performs the lane-wise 32-bit unsigned integer extended multiplication of the two lower lanes producing twice wider 64-bit integer results. */
  export function extmul_low_i32x4_u(a: v128, b: v128): v128;
  /** Performs the lane-wise 32-bit signed integer extended multiplication of the two higher lanes producing twice wider 64-bit integer results. */
  export function extmul_high_i32x4_s(a: v128, b: v128): v128;
  /** Performs the lane-wise 32-bit unsigned integer extended multiplication of the two higher lanes producing twice wider 64-bit integer results. */
  export function extmul_high_i32x4_u(a: v128, b: v128): v128;
}
/** Initializes a 128-bit vector from four 32-bit float values. Arguments must be compile-time constants. */
declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;
declare namespace f32x4 {
  /** Creates a vector with four identical 32-bit float lanes. */
  export function splat(x: f32): v128;
  /** Extracts one 32-bit float lane as a scalar. */
  export function extract_lane(x: v128, idx: u8): f32;
  /** Replaces one 32-bit float lane. */
  export function replace_lane(x: v128, idx: u8, value: f32): v128;
  /** Adds each 32-bit float lane. */
  export function add(a: v128, b: v128): v128;
  /** Subtracts each 32-bit float lane. */
  export function sub(a: v128, b: v128): v128;
  /** Multiplies each 32-bit float lane. */
  export function mul(a: v128, b: v128): v128;
  /** Divides each 32-bit float lane. */
  export function div(a: v128, b: v128): v128;
  /** Negates each 32-bit float lane. */
  export function neg(a: v128): v128;
  /** Computes the minimum of each 32-bit float lane. */
  export function min(a: v128, b: v128): v128;
  /** Computes the maximum of each 32-bit float lane. */
  export function max(a: v128, b: v128): v128;
  /** Computes the pseudo-minimum of each 32-bit float lane. */
  export function pmin(a: v128, b: v128): v128;
  /** Computes the pseudo-maximum of each 32-bit float lane. */
  export function pmax(a: v128, b: v128): v128;
  /** Computes the absolute value of each 32-bit float lane. */
  export function abs(a: v128): v128;
  /** Computes the square root of each 32-bit float lane. */
  export function sqrt(a: v128): v128;
  /** Performs the ceiling operation on each 32-bit float lane. */
  export function ceil(a: v128): v128;
  /** Performs the floor operation on each each 32-bit float lane. */
  export function floor(a: v128): v128;
  /** Rounds to the nearest integer towards zero of each 32-bit float lane. */
  export function trunc(a: v128): v128;
  /** Rounds to the nearest integer tied to even of each 32-bit float lane. */
  export function nearest(a: v128): v128;
  /** Computes which 32-bit float lanes are equal. */
  export function eq(a: v128, b: v128): v128;
  /** Computes which 32-bit float lanes are not equal. */
  export function ne(a: v128, b: v128): v128;
  /** Computes which 32-bit float lanes of the first vector are less than those of the second. */
  export function lt(a: v128, b: v128): v128;
  /** Computes which 32-bit float lanes of the first vector are less than or equal those of the second. */
  export function le(a: v128, b: v128): v128;
  /** Computes which 32-bit float lanes of the first vector are greater than those of the second. */
  export function gt(a: v128, b: v128): v128;
  /** Computes which 32-bit float lanes of the first vector are greater than or equal those of the second. */
  export function ge(a: v128, b: v128): v128;
  /** Converts each 32-bit signed integer lane of a vector to single-precision floating point. */
  export function convert_i32x4_s(a: v128): v128;
  /** Converts each 32-bit unsigned integer lane of a vector to single-precision floating point. */
  export function convert_i32x4_u(a: v128): v128;
  /** Demotes each 64-bit float lane of a vector to single-precision. The higher lanes of the result are initialized to zero. */
  export function demote_f64x2_zero(a: v128): v128;
}
/** Initializes a 128-bit vector from two 64-bit float values. Arguments must be compile-time constants. */
declare function f64x2(a: f64, b: f64): v128;
declare namespace f64x2 {
  /** Creates a vector with two identical 64-bit float lanes. */
  export function splat(x: f64): v128;
  /** Extracts one 64-bit float lane as a scalar. */
  export function extract_lane(x: v128, idx: u8): f64;
  /** Replaces one 64-bit float lane. */
  export function replace_lane(x: v128, idx: u8, value: f64): v128;
  /** Adds each 64-bit float lane. */
  export function add(a: v128, b: v128): v128;
  /** Subtracts each 64-bit float lane. */
  export function sub(a: v128, b: v128): v128;
  /** Multiplies each 64-bit float lane. */
  export function mul(a: v128, b: v128): v128;
  /** Divides each 64-bit float lane. */
  export function div(a: v128, b: v128): v128;
  /** Negates each 64-bit float lane. */
  export function neg(a: v128): v128;
  /** Computes the minimum of each 64-bit float lane. */
  export function min(a: v128, b: v128): v128;
  /** Computes the maximum of each 64-bit float lane. */
  export function max(a: v128, b: v128): v128;
  /** Computes the pseudo-minimum of each 64-bit float lane. */
  export function pmin(a: v128, b: v128): v128;
  /** Computes the pseudo-maximum of each 64-bit float lane. */
  export function pmax(a: v128, b: v128): v128;
  /** Computes the absolute value of each 64-bit float lane. */
  export function abs(a: v128): v128;
  /** Computes the square root of each 64-bit float lane. */
  export function sqrt(a: v128): v128;
  /** Performs the ceiling operation on each 64-bit float lane. */
  export function ceil(a: v128): v128;
  /** Performs the floor operation on each each 64-bit float lane. */
  export function floor(a: v128): v128;
  /** Rounds to the nearest integer towards zero of each 64-bit float lane. */
  export function trunc(a: v128): v128;
  /** Rounds to the nearest integer tied to even of each 64-bit float lane. */
  export function nearest(a: v128): v128;
  /** Computes which 64-bit float lanes are equal. */
  export function eq(a: v128, b: v128): v128;
  /** Computes which 64-bit float lanes are not equal. */
  export function ne(a: v128, b: v128): v128;
  /** Computes which 64-bit float lanes of the first vector are less than those of the second. */
  export function lt(a: v128, b: v128): v128;
  /** Computes which 64-bit float lanes of the first vector are less than or equal those of the second. */
  export function le(a: v128, b: v128): v128;
  /** Computes which 64-bit float lanes of the first vector are greater than those of the second. */
  export function gt(a: v128, b: v128): v128;
  /** Computes which 64-bit float lanes of the first vector are greater than or equal those of the second. */
  export function ge(a: v128, b: v128): v128;
  /** Converts the low 32-bit signed integer lanes of a vector to double-precision floating point. */
  export function convert_low_i32x4_s(a: v128): v128;
  /** Converts the low 32-bit unsigned integer lanes of a vector to double-precision floating point. */
  export function convert_low_i32x4_u(a: v128): v128;
  /** Promotes the low 32-bit float lanes of a vector to double-precision. */
  export function promote_low_f32x4(a: v128): v128;
}

declare abstract class i31 {
  /** Creates a new i31ref from the specified integer value. */
  static new(value: i32): i31ref;
  /** Gets the integer value of an i31ref. */
  static get(i31expr: i31ref): i32;
}

/** Macro type evaluating to the underlying native WebAssembly type. */
declare type native<T> = T;
/** Special type evaluating the indexed access index type. */
declare type indexof<T extends unknown[]> = keyof T;
/** Special type evaluating the indexed access value type. */
declare type valueof<T extends unknown[]> = T[0];
/** A special type evaluated to the return type of T if T is a callable function. */
declare type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;
/** A special type evaluated to the return type of T if T is a callable function. */
declare type returnof<T extends (...args: any) => any> = ReturnType<T>;
/** A special type that excludes null and undefined from T. */
declare type NonNullable<T> = T extends null | undefined ? never : T;
/** A special type that excludes null and undefined from T. */
declare type nonnull<T> = NonNullable<T>;

/** Pseudo-class representing the backing class of integer types. */
declare class _Integer {
  /** Smallest representable value. */
  static readonly MIN_VALUE: number;
  /** Largest representable value. */
  static readonly MAX_VALUE: number;
  /** Converts a string to an integer of this type. */
  static parseInt(value: string, radix?: number): number;
  /** Converts this integer to a string. */
  toString(radix?: number): string;
}

/** Pseudo-class representing the backing class of floating-point types. */
declare class _Float {
  /** Difference between 1 and the smallest representable value greater than 1. */
  static readonly EPSILON: f32 | f64;
  /** Smallest representable value. */
  static readonly MIN_VALUE: f32 | f64;
  /** Largest representable value. */
  static readonly MAX_VALUE: f32 | f64;
  /** Smallest safely representable integer value. */
  static readonly MIN_SAFE_INTEGER: f32 | f64;
  /** Largest safely representable integer value. */
  static readonly MAX_SAFE_INTEGER: f32 | f64;
  /** Value representing positive infinity. */
  static readonly POSITIVE_INFINITY: f32 | f64;
  /** Value representing negative infinity. */
  static readonly NEGATIVE_INFINITY: f32 | f64;
  /** Value representing 'not a number'. */
  static readonly NaN: f32 | f64;
  /** Returns a boolean value that indicates whether a value is the reserved value NaN (not a number). */
  static isNaN(value: f32 | f64): bool;
  /** Returns true if passed value is finite. */
  static isFinite(value: f32 | f64): bool;
  /** Returns true if the value passed is a safe integer. */
  static isSafeInteger(value: f32 | f64): bool;
  /** Returns true if the value passed is an integer, false otherwise. */
  static isInteger(value: f32 | f64): bool;
  /** Converts a string to an integer. */
  static parseInt(value: string, radix?: i32): f32 | f64;
  /** Converts a string to a floating-point number. */
  static parseFloat(value: string): f32 | f64;
  /** Converts this floating-point number to a string. */
  toString(radix?: number): string;
}

/** Backing class of signed 8-bit integers. */
declare const I8: typeof _Integer;
/** Backing class of signed 16-bit integers. */
declare const I16: typeof _Integer;
/** Backing class of signed 32-bit integers. */
declare const I32: typeof _Integer;
/** Backing class of signed 64-bit integers. */
declare const I64: typeof _Integer;
/** Backing class of signed size integers. */
declare const Isize: typeof _Integer;
/** Backing class of unsigned 8-bit integers. */
declare const U8: typeof _Integer;
/** Backing class of unsigned 16-bit integers. */
declare const U16: typeof _Integer;
/** Backing class of unsigned 32-bit integers. */
declare const U32: typeof _Integer;
/** Backing class of unsigned 64-bit integers. */
declare const U64: typeof _Integer;
/** Backing class of unsigned size integers. */
declare const Usize: typeof _Integer;
/** Backing class of 32-bit floating-point values. */
declare const F32: typeof _Float;
/** Backing class of 64-bit floating-point values. */
declare const F64: typeof _Float;

// User-defined diagnostic macros

/** Emits a user-defined diagnostic error when encountered. */
declare function ERROR(message?: any): never;
/** Emits a user-defined diagnostic warning when encountered. */
declare function WARNING(message?: any): void;
/** Emits a user-defined diagnostic info when encountered. */
declare function INFO(message?: any): void;

// Polyfills

/** Performs the sign-agnostic reverse bytes **/
declare function bswap<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64 | isize | usize>(value: T): T;
/** Performs the sign-agnostic reverse bytes only for last 16-bit **/
declare function bswap16<T extends i8 | u8 | i16 | u16 | i32 | u32>(value: T): T;

// Standard library

/** Memory operations. */
declare namespace memory {
  /** Whether the memory managed interface is implemented. */
  export const implemented: bool;
  /** Returns the current memory size in units of pages. One page is 64kb. */
  export function size(): i32;
  /** Grows linear memory by a given unsigned delta of pages. One page is 64kb. Returns the previous memory size in units of pages or `-1` on failure. */
  export function grow(value: i32): i32;
  /** Sets n bytes beginning at the specified destination in memory to the specified byte value. */
  export function fill(dst: usize, value: u8, count: usize): void;
  /** Copies n bytes from the specified source to the specified destination in memory. These regions may overlap. */
  export function copy(dst: usize, src: usize, n: usize): void;
  /** Repeats `src` of length `srcLength` `count` times at `dst`. */
  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void;
  /** Copies elements from a passive element segment to a table. */
  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void;
  /** Prevents further use of a passive element segment. */
  export function drop(segmentIndex: u32): void;
  /** Compares two chunks of memory. Returns `0` if equal, otherwise the difference of the first differing bytes. */
  export function compare(vl: usize, vr: usize, n: usize): i32;
  /** Gets a pointer to a zeroed static chunk of memory of the given size. Alignment defaults to `16`. Arguments must be compile-time constants. */
  export function data(size: i32, align?: i32): usize;
  /** Gets a pointer to a pre-initialized static chunk of memory. Alignment defaults to the size of `T`. Arguments must be compile-time constants. */
  export function data<T>(values: T[], align?: i32): usize;
}

/** Heap memory interface. */
declare namespace heap {
  /** Allocates a chunk of memory of at least the specified size. */
  export function alloc(size: usize): usize;
  /** Reallocates a chunk of memory to have at least the specified size. */
  export function realloc(ptr: usize, size: usize): usize;
  /** Frees a chunk of memory. Does hardly anything (most recent block only) with the stub/none runtime. */
  export function free(ptr: usize): void;
}

/** Table operations. */
declare namespace table {
  /** Copies elements from a passive element segment to a table. */
  export function init(elementIndex: u32, srcOffset: u32, dstOffset: u32, n: u32): void;
  /** Prevents further use of a passive element segment. */
  export function drop(elementIndex: u32): void;
  /** Copies elements from one region of a table to another region. */
  export function copy(dest: u32, src: u32, n: u32): void;
}

declare namespace Atomics {
  export function load<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32): T;
  export function store<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): void;
  export function add<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;
  export function sub<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;
  export function and<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;
  export function or<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;
  export function xor<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;
  export function exchange<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, value: T): T;
  export function compareExchange<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, expectedValue: T, replacementValue: T): T;
  export function wait<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, value: T, timeout?: i64): AtomicWaitResult;
  export function notify<T extends i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64>(array: TypedArray<T>, index: i32, count?: i32): i32;
  /** The static Atomics.isLockFree() method is used to determine whether to use locks or atomic operations. It returns true, if the given size is one of the BYTES_PER_ELEMENT */
  export function isLockFree(size: usize): bool;
}

/** Class representing a generic, fixed-length raw binary data buffer. */
declare class ArrayBuffer {
  /** The size, in bytes, of the array. */
  readonly byteLength: i32;
  /** Returns true if value is one of the ArrayBuffer views, such as typed array or a DataView **/
  static isView<T>(value: T): bool;
  /** Constructs a new array buffer of the given length in bytes. */
  constructor(length: i32);
  /** Returns a copy of this array buffer's bytes from begin, inclusive, up to end, exclusive. */
  slice(begin?: i32, end?: i32): ArrayBuffer;
  /** Returns a string representation of ArrayBuffer. */
  toString(): string;
}

/** The `DataView` view provides a low-level interface for reading and writing multiple number types in a binary `ArrayBuffer`, without having to care about the platform's endianness. */
declare class DataView {
  /** The `buffer` accessor property represents the `ArrayBuffer` or `SharedArrayBuffer` referenced by the `DataView` at construction time. */
  readonly buffer: ArrayBuffer;
  /** The `byteLength` accessor property represents the length (in bytes) of this view from the start of its `ArrayBuffer` or `SharedArrayBuffer`. */
  readonly byteLength: i32;
  /** The `byteOffset` accessor property represents the offset (in bytes) of this view from the start of its `ArrayBuffer` or `SharedArrayBuffer`. */
  readonly byteOffset: i32;
  /** Constructs a new `DataView` with the given properties */
  constructor(buffer: ArrayBuffer, byteOffset?: i32, byteLength?: i32);
  /** The `getFloat32()` method gets a signed 32-bit float (float) at the specified byte offset from the start of the `DataView`. */
  getFloat32(byteOffset: i32, littleEndian?: bool): f32;
  /** The `getFloat64()` method gets a signed 64-bit float (double) at the specified byte offset from the start of the `DataView`. */
  getFloat64(byteOffset: i32, littleEndian?: bool): f64;
  /** The `getInt8()` method gets a signed 8-bit integer (byte) at the specified byte offset from the start of the `DataView`. */
  getInt8(byteOffset: i32): i8;
  /** The `getInt16()` method gets a signed 16-bit integer (short) at the specified byte offset from the start of the `DataView`. */
  getInt16(byteOffset: i32, littleEndian?: bool): i16;
  /** The `getInt32()` method gets a signed 32-bit integer (long) at the specified byte offset from the start of the `DataView`. */
  getInt32(byteOffset: i32, littleEndian?: bool): i32;
  /** The `getInt64()` method gets a signed 64-bit integer (long long) at the specified byte offset from the start of the `DataView`. */
  getInt64(byteOffset: i32, littleEndian?: bool): i64;
  /** The `getUint8()` method gets an unsigned 8-bit integer (unsigned byte) at the specified byte offset from the start of the `DataView`. */
  getUint8(byteOffset: i32): u8;
  /** The `getUint16()` method gets an unsigned 16-bit integer (unsigned short) at the specified byte offset from the start of the `DataView`. */
  getUint16(byteOffset: i32, littleEndian?: bool): u16;
  /** The `getUint32()` method gets an unsigned 32-bit integer (unsigned long) at the specified byte offset from the start of the `DataView`. */
  getUint32(byteOffset: i32, littleEndian?: bool): u32;
  /** The `getUint64()` method gets an unsigned 64-bit integer (unsigned long long) at the specified byte offset from the start of the `DataView`. */
  getUint64(byteOffset: i32, littleEndian?: bool): u64;
  /** The `setFloat32()` method stores a signed 32-bit float (float) value at the specified byte offset from the start of the `DataView`. */
  setFloat32(byteOffset: i32, value: f32, littleEndian?: bool): void;
  /** The `setFloat64()` method stores a signed 64-bit float (double) value at the specified byte offset from the start of the `DataView`. */
  setFloat64(byteOffset: i32, value: f64, littleEndian?: bool): void;
  /** The `setInt8()` method stores a signed 8-bit integer (byte) value at the specified byte offset from the start of the `DataView`. */
  setInt8(byteOffset: i32, value: i8): void;
  /** The `setInt16()` method stores a signed 16-bit integer (short) value at the specified byte offset from the start of the `DataView`. */
  setInt16(byteOffset: i32, value: i16, littleEndian?: bool): void;
  /** The `setInt32()` method stores a signed 32-bit integer (long) value at the specified byte offset from the start of the `DataView`. */
  setInt32(byteOffset: i32, value: i32, littleEndian?: bool): void;
  /** The `setInt64()` method stores a signed 64-bit integer (long long) value at the specified byte offset from the start of the `DataView`. */
  setInt64(byteOffset: i32, value: i64, littleEndian?: bool): void;
  /** The `setUint8()` method stores an unsigned 8-bit integer (byte) value at the specified byte offset from the start of the `DataView`. */
  setUint8(byteOffset: i32, value: u8): void;
  /** The `setUint16()` method stores an unsigned 16-bit integer (unsigned short) value at the specified byte offset from the start of the `DataView`. */
  setUint16(byteOffset: i32, value: u16, littleEndian?: bool): void;
  /** The `setUint32()` method stores an unsigned 32-bit integer (unsigned long) value at the specified byte offset from the start of the `DataView`. */
  setUint32(byteOffset: i32, value: u32, littleEndian?: bool): void;
  /** The `setUint64()` method stores an unsigned 64-bit integer (unsigned long long) value at the specified byte offset from the start of the `DataView`. */
  setUint64(byteOffset: i32, value: u64, littleEndian?: bool): void;
  /** Returns a string representation of DataView. */
  toString(): string;
}

interface ArrayLike<T> {
  [key: number]: T;
  length: i32;
}

/** Interface for a typed view on an array buffer. */
interface ArrayBufferView {
  /** The {@link ArrayBuffer} referenced by this view. */
  readonly buffer: ArrayBuffer;
  /** The offset in bytes from the start of the referenced {@link ArrayBuffer}. */
  readonly byteOffset: i32;
  /** The length in bytes from the start of the referenced {@link ArrayBuffer}. */
  readonly byteLength: i32;
  /** Returns raw pointer to data storage including offset (unsafe). */
  readonly dataStart: usize;
}

/* @internal */
declare abstract class TypedArray<T> implements ArrayBufferView {
  [key: number]: T;
  /** Number of bytes per element. */
  static readonly BYTES_PER_ELEMENT: usize;
  /** Constructs a new typed array. */
  constructor(length: i32);
  /** The {@link ArrayBuffer} referenced by this view. */
  readonly buffer: ArrayBuffer;
  /** The offset in bytes from the start of the referenced {@link ArrayBuffer}. */
  readonly byteOffset: i32;
  /** The length in bytes from the start of the referenced {@link ArrayBuffer}. */
  readonly byteLength: i32;
  /** Returns raw pointer to data storage including offset (unsafe). */
  readonly dataStart: usize;
  /** The length (in elements). */
  readonly length: i32;
  /** Returns value using relative indexing. Index may be negative */
  at(index: i32): T;
  /** The includes() method determines whether a typed array includes a certain element, returning true or false as appropriate. */
  includes(searchElement: T, fromIndex?: i32): bool;
  /** The indexOf() method returns the first index at which a given element can be found in the typed array, or -1 if it is not present. */
  indexOf(searchElement: T, fromIndex?: i32): i32;
  /** The lastIndexOf() method returns the last index at which a given element can be found in the typed array, or -1 if it is not present. The typed array is searched backwards, starting at fromIndex. */
  lastIndexOf(searchElement: T, fromIndex?: i32): i32;
  /** Returns copied section of an TypedArray from begin inclusive to end exclusive */
  slice(begin?: i32, end?: i32): TypedArray<T>;
  /** Returns a new TypedArray of this type on the same ArrayBuffer from begin inclusive to end exclusive. */
  subarray(begin?: i32, end?: i32): TypedArray<T>;
  /** The copyWithin() method copies the sequence of array elements within the array to the position starting at target. The copy is taken from the index positions of the second and third arguments start and end. The end argument is optional and defaults to the length of the array. */
  copyWithin(target: i32, start: i32, end?: i32): this;
  /**  The reduce() method applies a function against an accumulator and each value of the typed array (from left-to-right) has to reduce it to a single value. This method has the same algorithm as Array.prototype.reduce(). */
  reduce<U>(callbackfn: (accumulator: U, value: T, index: i32, self: this) => U, initialValue: U): U;
  /**  The reduceRight() method applies a function against an accumulator and each value of the typed array (from left-to-right) has to reduce it to a single value, starting from the end of the array. This method has the same algorithm as Array.prototype.reduceRight(). */
  reduceRight<U>(callbackfn: (accumulator: U, value: T, index: i32, self: this) => U, initialValue: U): U;
  /** The some() method tests whether some element in the typed array passes the test implemented by the provided function. This method has the same algorithm as Array.prototype.some().*/
  some(callbackfn: (value: T, index: i32, self: this) => bool): bool;
  /** The map() method creates a new typed array with the results of calling a provided function on every element in this typed array. This method has the same algorithm as Array.prototype.map().*/
  map(callbackfn: (value: T, index: i32, self: this) => T): TypedArray<T>;
  /** The filter() method creates a new typed array with all elements that pass the test implemented by the provided function. This method has the same algorithm as Array.prototype.filter(). */
  filter(callbackfn: (value: T, index: i32, self: this) => bool): TypedArray<T>;
  /** The sort() method sorts the elements of a typed array numerically in place and returns the typed array. This method has the same algorithm as Array.prototype.sort(), except that sorts the values numerically instead of as strings. TypedArray is one of the typed array types here. */
  sort(callback?: (a: T, b: T) => i32): this;
  /** The fill() method fills all the elements of a typed array from a start index to an end index with a static value. This method has the same algorithm as Array.prototype.fill(). */
  fill(value: T, start?: i32, end?: i32): this;
  /** The findIndex() method returns an index in the typed array, if an element in the typed array satisfies the provided testing function. Otherwise -1 is returned. See also the find() [not implemented] method, which returns the value of a found element in the typed array instead of its index. */
  findIndex(callbackfn: (value: T, index: i32, self: this) => bool): i32;
  /** The findLastIndex() method returns an index start searching from the end in the typed array, if an element in the typed array satisfies the provided testing function. Otherwise -1 is returned. See also the find() [not implemented] method, which returns the value of a found element in the typed array instead of its index. */
  findLastIndex(callbackfn: (value: T, index: i32, self: this) => bool): i32;
  /** The every() method tests whether all elements in the typed array pass the test implemented by the provided function. This method has the same algorithm as Array.prototype.every(). */
  every(callbackfn: (value: T, index: i32, self: this) => bool): bool;
  /** The forEach() method executes a provided function once per array element. This method has the same algorithm as Array.prototype.forEach().*/
  forEach(callbackfn: (value: T, index: i32, self: this) => void): void;
  /** The reverse() method reverses a typed array in place. The first typed array element becomes the last and the last becomes the first. This method has the same algorithm as Array.prototype.reverse(). */
  reverse(): this;
  /** The join() method joins all elements of an array into a string. This method has the same algorithm as Array.prototype.join(). */
  join(separator?: string): string;
  /** The set() method stores multiple values in the typed array, reading input values from a specified array. */
  set<U extends ArrayBufferView>(source: U, offset?: i32): void
  /** The toString() method returns a string representing the specified array and its elements. This method has the same algorithm as Array.prototype.toString() */
  toString(): string;
}

/** An array of twos-complement 8-bit signed integers. */
declare class Int8Array extends TypedArray<i8> {
  /** Wrap an ArrayBuffer */
  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int8Array;
}
/** An array of 8-bit unsigned integers. */
declare class Uint8Array extends TypedArray<u8> {
  /** Wrap an ArrayBuffer */
  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint8Array;
}
/** A clamped array of 8-bit unsigned integers. */
declare class Uint8ClampedArray extends TypedArray<u8> {
  /** Wrap an ArrayBuffer */
  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint8ClampedArray;
}
/** An array of twos-complement 16-bit signed integers. */
declare class Int16Array extends TypedArray<i16> {
  /** Wrap an ArrayBuffer */
  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int16Array;
}
/** An array of 16-bit unsigned integers. */
declare class Uint16Array extends TypedArray<u16> {
  /** Wrap an ArrayBuffer */
  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint16Array;
}
/** An array of twos-complement 32-bit signed integers. */
declare class Int32Array extends TypedArray<i32> {
  /** Wrap an ArrayBuffer */
  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int32Array;
}
/** An array of 32-bit unsigned integers. */
declare class Uint32Array extends TypedArray<u32> {
  /** Wrap an ArrayBuffer */
  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint32Array;
}
/** An array of twos-complement 64-bit signed integers. */
declare class Int64Array extends TypedArray<i64> {
  /** Wrap an ArrayBuffer */
  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int64Array;
}
/** An array of 64-bit unsigned integers. */
declare class Uint64Array extends TypedArray<u64> {
  /** Wrap an ArrayBuffer */
  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint64Array;
}
/** An array of 32-bit floating point numbers. */
declare class Float32Array extends TypedArray<f32> {
  /** Wrap an ArrayBuffer */
  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Float32Array;
}
/** An array of 64-bit floating point numbers. */
declare class Float64Array extends TypedArray<f64> {
  /** Wrap an ArrayBuffer */
  static wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Float64Array;
}

/** Class representing a sequence of values of type `T`. */
declare class Array<T> {

  /** Tests if a value is an array. */
  static isArray<U>(value: any): value is Array<any>;

  [key: number]: T;
  /** Current length of the array. */
  length: i32;
  /** Returns raw pointer to data storage (unsafe). */
  readonly dataStart: usize;
  /** Constructs a new array. */
  constructor(length?: i32);
  at(index: i32): T;
  fill(value: T, start?: i32, end?: i32): this;
  every(callbackfn: (element: T, index: i32, array?: Array<T>) => bool): bool;
  findIndex(callbackfn: (element: T, index: i32, array?: Array<T>) => bool): i32;
  findLastIndex(callbackfn: (element: T, index: i32, array?: Array<T>) => bool): i32;
  includes(searchElement: T, fromIndex?: i32): bool;
  indexOf(searchElement: T, fromIndex?: i32): i32;
  lastIndexOf(searchElement: T, fromIndex?: i32): i32;
  push(element: T): i32;
  concat(items: T[]): T[];
  copyWithin(target: i32, start: i32, end?: i32): this;
  pop(): T;
  forEach(callbackfn: (value: T, index: i32, array: Array<T>) => void): void;
  map<U>(callbackfn: (value: T, index: i32, array: Array<T>) => U): Array<U>;
  filter(callbackfn: (value: T, index: i32, array: Array<T>) => bool): Array<T>;
  reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U, initialValue: U): U;
  reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U, initialValue: U): U;
  shift(): T;
  some(callbackfn: (element: T, index: i32, array?: Array<T>) => bool): bool;
  unshift(element: T): i32;
  slice(from: i32, to?: i32): Array<T>;
  splice(start: i32, deleteCount?: i32): Array<T>;
  sort(comparator?: (a: T, b: T) => i32): this;
  join(separator?: string): string;
  reverse(): T[];
  /** Flattens an array of arrays. If any null entries exist in the array, they are ignored, unlike JavaScript's version of Array#flat(). */
  flat(): T extends unknown[] ? T : never;
  toString(): string;
}

/** Class representing a static (not resizable) sequence of values of type `T`. This class is @final. */
declare class StaticArray<T> {
  [key: number]: T;
  static fromArray<T>(source: Array<T>): StaticArray<T>;
  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T>;
  static slice<T>(source: StaticArray<T>, start?: i32, end?: i32): StaticArray<T>;
  readonly length: i32;
  constructor(length?: i32);
  at(index: i32): T;
  includes(searchElement: T, fromIndex?: i32): bool;
  indexOf(searchElement: T, fromIndex?: i32): i32;
  lastIndexOf(searchElement: T, fromIndex?: i32): i32;
  concat(items: Array<T>): Array<T>;
  slice(from: i32, to?: i32): Array<T>;
  join(separator?: string): string;
  toString(): string;
}

/** Class representing a sequence of characters. */
declare class String {
  static fromCharCode(ls: i32, hs?: i32): string;
  static fromCharCodes(arr: u16[]): string;
  static fromCodePoint(code: i32): string;
  static fromCodePoints(arr: i32[]): string;
  static raw(parts: TemplateStringsArray, ...args: any[]): string;
  readonly length: i32;
  at(index: i32): string;
  charAt(index: i32): string;
  charCodeAt(index: i32): i32;
  codePointAt(index: i32): i32;
  concat(other: string): string;
  endsWith(other: string): bool;
  indexOf(other: string, fromIndex?: i32): i32;
  lastIndexOf(other: string, fromIndex?: i32): i32;
  localeCompare(other: string): i32;
  includes(other: string): bool;
  startsWith(other: string): bool;
  substr(start: i32, length?: i32): string;
  substring(start: i32, end?: i32): string;
  trim(): string;
  trimLeft(): string;
  trimRight(): string;
  trimStart(): string;
  trimEnd(): string;
  padStart(targetLength: i32, padString?: string): string;
  padEnd(targetLength: i32, padString?: string): string;
  repeat(count?: i32): string;
  replace(search: string, replacement: string): string;
  replaceAll(search: string, replacement: string): string;
  slice(beginIndex: i32, endIndex?: i32): string;
  split(separator?: string, limit?: i32): string[];
  toLowerCase(): string;
  toUpperCase(): string;
  toString(): string;
}

declare namespace String {
  /** Encoding helpers for UTF-8. */
  export namespace UTF8 {
    /** UTF-8 encoding error modes. */
    export const enum ErrorMode {
      /** Keeps unpaired surrogates as of WTF-8. This is the default. */
      WTF8,
      /** Replaces unpaired surrogates with the replacement character (U+FFFD). */
      REPLACE,
      /** Throws an error on unpaired surrogates. */
      ERROR
    }
    /** Calculates the byte length of the specified string when encoded as UTF-8, optionally null terminated. */
    export function byteLength(str: string, nullTerminated?: bool): i32;
    /** Encodes the specified string to UTF-8 bytes, optionally null terminated. ErrorMode defaults to WTF-8. */
    export function encode(str: string, nullTerminated?: bool, errorMode?: ErrorMode): ArrayBuffer;
    /** Encodes the specified raw string to UTF-8 bytes, opionally null terminated. ErrorMode defaults to WTF-8. Returns the number of bytes written. */
    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated?: bool, errorMode?: ErrorMode): usize;
    /** Decodes the specified buffer from UTF-8 bytes to a string, optionally null terminated. */
    export function decode(buf: ArrayBuffer, nullTerminated?: bool): string;
    /** Decodes raw UTF-8 bytes to a string, optionally null terminated. */
    export function decodeUnsafe(buf: usize, len: usize, nullTerminated?: bool): string;
  }
  /** Encoding helpers for UTF-16. */
  export namespace UTF16 {
    /** Calculates the byte length of the specified string when encoded as UTF-16. */
    export function byteLength(str: string): i32;
    /** Encodes the specified string to UTF-16 bytes. */
    export function encode(str: string): ArrayBuffer;
    /** Encodes the specified raw string to UTF-16 bytes. Returns the number of bytes written. */
    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize;
    /** Decodes the specified buffer from UTF-16 bytes to a string. */
    export function decode(buf: ArrayBuffer): string;
    /** Decodes raw UTF-16 bytes to a string. */
    export function decodeUnsafe(buf: usize, len: usize): string;
  }
}

declare class TemplateStringsArray extends Array<string> {
  readonly raw: string[];
}

declare class Object {
  /** The Object.is() method determines whether two values are the same value. */
  static is<T>(value1: T, value2: T): bool;
}

declare class Date {
  /** Returns the UTC timestamp in milliseconds of the specified date. */
  static UTC(
    year: i32,
    month: i32,
    day: i32,
    hour: i32,
    minute: i32,
    second: i32,
    millisecond: i32
  ): i64;
  /** Returns the current UTC timestamp in milliseconds. */
  static now(): i64;
  /** Parses a string representation of a date, and returns the number of milliseconds since January 1, 1970, 00:00:00 UTC. */
  static parse(dateString: string): Date;
  static fromString(dateString: string): Date;
  /** Constructs a new date object from an UTC timestamp in milliseconds. */
  constructor(value: i64);
  /** Returns the UTC timestamp of this date in milliseconds. */
  getTime(): i64;
  /** Sets the UTC timestamp of this date in milliseconds. */
  setTime(value: i64): i64;

  getUTCFullYear(): i32;
  getUTCMonth(): i32;
  getUTCDate(): i32;
  getUTCDay(): i32;
  getUTCHours(): i32;
  getUTCMinutes(): i32;
  getUTCSeconds(): i32;
  getUTCMilliseconds(): i32;

  setUTCFullYear(value: i32): void;
  setUTCMonth(value: i32): void;
  setUTCDate(value: i32): void;
  setUTCHours(value: i32): void;
  setUTCMinutes(value: i32): void;
  setUTCSeconds(value: i32): void;
  setUTCMilliseconds(value: i32): void;

  toString(): string;
  toISOString(): string;
  toUTCString(): string;
  toDateString(): string;
  toTimeString(): string;
}

/** Class for representing a runtime error. Base class of all errors. */
declare class Error {

  /** Error name. */
  name: string;

  /** Message provided on construction. */
  message: string;

  /** Stack trace. */
  stack?: string;

  /** Constructs a new error, optionally with a message. */
  constructor(message?: string);

  /** Method returns a string representing the specified Error class. */
  toString(): string;
}

/** Class for indicating an error when a value is not in the set or range of allowed values. */
declare class RangeError extends Error { }

/** Class for indicating an error when a value is not of the expected type. */
declare class TypeError extends Error { }

/** Class for indicating an error when trying to interpret syntactically invalid code. */
declare class SyntaxError extends Error { }

/** Class for indicating an error when a global URI handling function was used in a wrong way. */
declare class URIError extends Error { }

interface Boolean {
  toString(radix?: number): string;
}

interface Number {
  toString(radix?: number): string;
}

interface Function {
  /** Function table index. */
  readonly index: u32;
  /** Function name. Always an empty string. */
  readonly name: string;
  /** Number of expected parameters. */
  readonly length: u32;
  /** Calls this function indirectly with the specified arguments. */
  call(thisArg: unknown, ...args: unknown[]): any;
  /** Returns a string representation of this function. */
  toString(): string;
}
interface IArguments {}
interface RegExp {}

declare class Map<K,V> {
  readonly size: i32;
  has(key: K): bool;
  set(key: K, value: V): this;
  get(key: K): V;
  delete(key: K): bool;
  clear(): void;
  keys(): K[]; // preliminary
  values(): V[]; // preliminary
  toString(): string;
}

declare class Set<K> {
  readonly size: i32;
  has(value: K): bool;
  add(value: K): this;
  delete(value: K): bool;
  clear(): void;
  values(): K[]; // preliminary
  toString(): string;
}

interface SymbolConstructor {
  readonly hasInstance: symbol;
  readonly isConcatSpreadable: symbol;
  readonly isRegExp: symbol;
  readonly iterator: symbol;
  readonly match: symbol;
  readonly replace: symbol;
  readonly search: symbol;
  readonly species: symbol;
  readonly split: symbol;
  readonly toPrimitive: symbol;
  readonly toStringTag: symbol;
  readonly unscopables: symbol;
  (description?: string | null): symbol;
  for(key: string): symbol;
  keyFor(sym: symbol): string | null;
}

declare const Symbol: SymbolConstructor;

interface IMath<T> {
  /** The base of natural logarithms, e, approximately 2.718. */
  readonly E: T;
  /** The natural logarithm of 2, approximately 0.693. */
  readonly LN2: T;
  /** The natural logarithm of 10, approximately 2.302. */
  readonly LN10: T;
  /** The base 2 logarithm of e, approximately 1.442. */
  readonly LOG2E: T;
  /** The base 10 logarithm of e, approximately 0.434. */
  readonly LOG10E: T;
  /** The ratio of the circumference of a circle to its diameter, approximately 3.14159. */
  readonly PI: T;
  /** The square root of 1/2, approximately 0.707. */
  readonly SQRT1_2: T;
  /** The square root of 2, approximately 1.414. */
  readonly SQRT2: T;
  /** Returns the absolute value of `x`. */
  abs(x: T): T;
  /** Returns the arccosine (in radians) of `x`. */
  acos(x: T): T;
  /** Returns the hyperbolic arc-cosine of `x`. */
  acosh(x: T): T;
  /** Returns the arcsine (in radians) of `x`. */
  asin(x: T): T;
  /** Returns the hyperbolic arcsine of `x`. */
  asinh(x: T): T;
  /** Returns the arctangent (in radians) of `x`. */
  atan(x: T): T;
  /** Returns the arctangent of the quotient of its arguments. */
  atan2(y: T, x: T): T;
  /** Returns the hyperbolic arctangent of `x`. */
  atanh(x: T): T;
  /** Returns the cube root of `x`. */
  cbrt(x: T): T;
  /** Returns the smallest integer greater than or equal to `x`. */
  ceil(x: T): T;
  /** Returns the number of leading zero bits in the 32-bit binary representation of `x`. */
  clz32(x: T): T;
  /** Returns the cosine (in radians) of `x`. */
  cos(x: T): T;
  /** Returns the hyperbolic cosine of `x`. */
  cosh(x: T): T;
  /** Returns e to the power of `x`. */
  exp(x: T): T;
  /** Returns e to the power of `x`, minus 1. */
  expm1(x: T): T;
  /** Returns the largest integer less than or equal to `x`. */
  floor(x: T): T;
  /** Returns the nearest 32-bit single precision float representation of `x`. */
  fround(x: T): T;
  /** Returns the square root of the sum of squares of its arguments. */
  hypot(value1: T, value2: T): T; // TODO: rest
  /** Returns the result of the C-like 32-bit multiplication of `a` and `b`. */
  imul(a: T, b: T): T;
  /** Returns the natural logarithm (base e) of `x`. */
  log(x: T): T;
  /** Returns the base 10 logarithm of `x`. */
  log10(x: T): T;
  /** Returns the natural logarithm (base e) of 1 + `x`. */
  log1p(x: T): T;
  /** Returns the base 2 logarithm of `x`. */
  log2(x: T): T;
  /** Returns the largest-valued number of its arguments. */
  max(value1: T, value2: T): T; // TODO: rest
  /** Returns the lowest-valued number of its arguments. */
  min(value1: T, value2: T): T; // TODO: rest
  /** Returns `base` to the power of `exponent`. */
  pow(base: T, exponent: T): T;
  /** Returns a pseudo-random number in the range from 0.0 inclusive up to but not including 1.0. */
  random(): T;
  /** Returns the value of `x` rounded to the nearest integer. */
  round(x: T): T;
  /** Returns the sign of `x`, indicating whether the number is positive, negative or zero. */
  sign(x: T): T;
  /** Returns whether the sign bit of `x` is set. */
  signbit(x: T): bool;
  /** Returns the sine of `x`. */
  sin(x: T): T;
  /** Returns the hyperbolic sine of `x`. */
  sinh(x: T): T;
  /** Returns the square root of `x`. */
  sqrt(x: T): T;
  /** Returns the tangent of `x`. */
  tan(x: T): T;
  /** Returns the hyperbolic tangent of `x`. */
  tanh(x: T): T;
  /** Returns the integer part of `x` by removing any fractional digits. */
  trunc(x: T): T;
}

interface INativeMath<T> extends IMath<T> {
  /** Contains sin value produced after Math/Mathf.sincos */
  sincos_sin: T;
  /** Contains cos value produced after Math/Mathf.sincos */
  sincos_cos: T;
  /** Seeds the random number generator. */
  seedRandom(value: i64): void;
  /** Multiplies a floating point `x` by 2 raised to power exp `n`. */
  scalbn(x: T, n: i32): T;
  /** Returns the floating-point remainder of `x / y` (rounded towards zero). */
  mod(x: T, y: T): T;
  /** Returns the floating-point remainder of `x / y` (rounded to nearest). */
  rem(x: T, y: T): T;
  /** Returns sin and cos simultaneously for same angle. Results stored to `sincos_s32/64` and `sincos_c32/64` globals */
  sincos(x: T): void;
  /** Returns 2 raised to the given power x. Equivalent to 2 ** x. */
  exp2(x: T): T;
}

/** Double precision math imported from JavaScript. */
declare const JSMath: IMath<f64>;
/** Double precision math implemented natively. */
declare const NativeMath: INativeMath<f64>;
/** Single precision math implemented natively. */
declare const NativeMathf: INativeMath<f32>;
/** Alias of {@link NativeMath} or {@link JSMath} respectively. Defaults to `NativeMath`. */
declare const Math: IMath<f64>;
/** Alias of {@link NativeMathf} or {@link JSMath} respectively. Defaults to `NativeMathf`. */
declare const Mathf: IMath<f32>;

/** Environmental abort function. */
declare function abort(msg?: string | null, fileName?: string | null, lineNumber?: i32, columnNumber?: i32): never;
/** Environmental tracing function. */
declare function trace(msg: string, n?: i32, a0?: f64, a1?: f64, a2?: f64, a3?: f64, a4?: f64): void;
/** Environmental seeding function. */
declare function seed(): f64;

/** Node-like process on top of WASI. */
declare namespace process {
  /** String representing the CPU architecture for which the binary was compiled. Either `wasm32` or `wasm64`. */
  export const arch: string;
  /** String representing the operating system platform for which the binary was compiled. Always `wasm`. */
  export const platform: string;
  /** Array of command line arguments passed to the binary upon instantiation. */
  export const argv: string[];
  /** Map of variables in the binary's user environment. */
  export const env: Map<string,string>;
  /** Process exit code to use when the process exits gracefully. Defaults to `0`. */
  export var exitCode: i32;
  /** Terminates the process with either the given exit code, or `process.exitCode` if omitted. */
  export function exit(code?: i32): void;
  /** Stream connected to `stdin` (fd `0`). */
  export const stdin: ReadableStream;
  /** Stream connected to `stdout` (fd `1`). */
  export const stdout: WritableStream;
  /** Stream connected to `stderr` (fd `2`). */
  export const stderr: WritableStream;
  /** Obtains the system's current time of day, in milliseconds since Unix epoch. */
  export function time(): i64;
  /** Obtains the system's monotonic high resolution time, in nanoseconds since an arbitrary time in the past. */
  export function hrtime(): u64;

  interface Stream {
    /** Closes the stream. Throws if already closed or if the stream cannot be closed. */
    close(): void;
  }
  interface ReadableStream extends Stream {
    /** Reads available data from the stream, into `buffer` at offset `offset`, returning the number of bytes read. */
    read(buffer: ArrayBuffer, offset?: isize): i32;
  }
  interface WritableStream extends Stream {
    /** Writes string or buffer to the stream. */
    write<T extends string | ArrayBuffer>(data: T): void;
  }
}

/** Browser-like console on top of WASI. */
declare namespace console {
  /** Logs `message` to console if `assertion` is false-ish. */
  export function assert<T>(assertion: T, message: string): void;
  /** Outputs `message` to the console. */
  export function log(message: string): void;
  /** Outputs `message` to the console, prefixed with "Debug:". */
  export function debug(message: string): void;
  /** Outputs `message` to the console, prefixed with "Info:". */
  export function info(message: string): void;
  /** Outputs `message` to the console, prefixed with "Warning:". */
  export function warn(message: string): void;
  /** Outputs `message` to the console, prefixed with "Error:". */
  export function error(message: string): void;
  /** Starts a new timer using the specified `label`. */
  export function time(label: string): void;
  /** Logs the current value of a timer previously started with `console.time`. */
  export function timeLog(label: string): void;
  /** Logs the current value of a timer previously started with `console.time` and discards the timer. */
  export function timeEnd(label: string): void;
}

/** Browser-like crypto utilities on top of WASI. */
declare namespace crypto {
  /** Fills `array` with cryptographically strong random values. */
  export function getRandomValues(array: Uint8Array): void;
}

// Decorators

interface TypedPropertyDescriptor<T> {
  configurable?: boolean;
  enumerable?: boolean;
  writable?: boolean;
  value?: T;
  get?(): T;
  set?(value: T): void;
}

/** Annotates a method as a binary operator overload for the specified `token`. */
declare function operator(token:
  "[]" | "[]=" | "{}" | "{}=" | "==" | "!=" | ">" | "<" | "<=" | ">=" |
  ">>" | ">>>" | "<<" |  "&"  | "|"  | "^"  | "+" | "-" | "*"  | "**" | "/"  | "%"
): (
  target: any,
  propertyKey: string,
  descriptor: TypedPropertyDescriptor<any>
) => TypedPropertyDescriptor<any> | void;

declare namespace operator {
  /** Annotates a method as a binary operator overload for the specified `token`. */
  export function binary(token:
    "[]" | "[]=" | "{}" | "{}=" | "==" | "!=" | ">" | "<" | "<=" | ">=" |
    ">>" | ">>>" | "<<" |  "&"  | "|"  | "^"  | "+" | "-" | "*"  | "**" | "/"  | "%"
  ): (
    target: any,
    propertyKey: string,
    descriptor: TypedPropertyDescriptor<any>
  ) => TypedPropertyDescriptor<any> | void;
  /** Annotates a method as an unary prefix operator overload for the specified `token`. */
  export function prefix(token: "!" | "~" | "+" | "-" | "++" | "--"): (
    target: any,
    propertyKey: string,
    descriptor: TypedPropertyDescriptor<any>
  ) => TypedPropertyDescriptor<any> | void;
  /** Annotates a method as an unary postfix operator overload for the specified `token`. */
  export function postfix(token: "++" | "--"): (
    target: any,
    propertyKey: string,
    descriptor: TypedPropertyDescriptor<any>
  ) => TypedPropertyDescriptor<any> | void;
}

/** Annotates an element as a program global. */
declare function global(...args: any[]): any;

/** Annotates a class as being unmanaged with limited capabilities. */
declare function unmanaged(constructor: Function): void;

/** Annotates a class as being final / non-derivable. */
declare function final(constructor: Function): void;

/** Annotates a method, function or constant global as always inlined. */
declare function inline(...args: any[]): any;

/** Annotates a method, function or constant global as unsafe. */
declare function unsafe(...args: any[]): any;

/** Annotates an explicit external name of a function or global. */
declare function external(...args: any[]): any;

/** Annotates a global for lazy compilation. */
declare function lazy(...args: any[]): any;

'''
'''--- std/assembly/iterator.ts ---
export abstract class Iterable<T> {
  // ?
}

@final
export abstract class Iterator<T> {

  // private constructor(iterable: Iterable<T>) {
  // }

  // TODO: these need to evaluate the classId at the respective reference in order to obtain the
  // next value, i.e. arrays work differently than maps. we'd then have:
  //
  // â•’â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Iterator layout (32-bit) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â••
  //    3                   2                   1
  //  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits
  // â”œâ”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”¤
  // â”‚                             index                             â”‚
  // â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”¤
  // â”‚                           reference                     â”‚ 0 â”‚Dâ”‚
  // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”´â”€â”˜
  // D: Done flag

  // get value(this: u64): T {
  //   ?
  // }

  // next(this: u64): Iterator<T> {
  //   ?
  // }

  done(this: u64): bool {
    return <bool>(this & 1);
  }
}

'''
'''--- std/assembly/map.ts ---
/// <reference path="./rt/index.d.ts" />

import { HASH } from "./util/hash";
import { E_KEYNOTFOUND } from "./util/error";

// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht

// @ts-ignore: decorator
@inline const INITIAL_CAPACITY = 4;

// @ts-ignore: decorator
@inline const FILL_FACTOR_N = 8;

// @ts-ignore: decorator
@inline const FILL_FACTOR_D = 3;

// @ts-ignore: decorator
@inline const FREE_FACTOR_N = 3;

// @ts-ignore: decorator
@inline const FREE_FACTOR_D = 4;

/** Structure of a map entry. */
@unmanaged class MapEntry<K,V> {
  key: K;
  value: V;
  taggedNext: usize; // LSB=1 indicates EMPTY
}

/** Empty bit. */
// @ts-ignore: decorator
@inline const EMPTY: usize = 1 << 0;

/** Size of a bucket. */
// @ts-ignore: decorator
@inline const BUCKET_SIZE = sizeof<usize>();

/** Computes the alignment of an entry. */
// @ts-ignore: decorator
@inline
function ENTRY_ALIGN<K,V>(): usize {
  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits
  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();
  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;
  return align;
}

/** Computes the aligned size of an entry. */
// @ts-ignore: decorator
@inline
function ENTRY_SIZE<K,V>(): usize {
  const align = ENTRY_ALIGN<K,V>();
  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;
  return size;
}

export class Map<K,V> {

  // buckets referencing their respective first entry, usize[bucketsMask + 1]
  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);
  private bucketsMask: u32 = INITIAL_CAPACITY - 1;

  // entries in insertion order, MapEntry<K,V>[entriesCapacity]
  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());
  private entriesCapacity: i32 = INITIAL_CAPACITY;
  private entriesOffset: i32 = 0;
  private entriesCount: i32 = 0;

  constructor() {
    /* nop */
  }

  get size(): i32 {
    return this.entriesCount;
  }

  clear(): void {
    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);
    this.bucketsMask = INITIAL_CAPACITY - 1;
    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());
    this.entriesCapacity = INITIAL_CAPACITY;
    this.entriesOffset = 0;
    this.entriesCount = 0;
  }

  private find(key: K, hashCode: u32): MapEntry<K,V> | null {
    var entry = load<MapEntry<K,V>>( // unmanaged!
      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE
    );
    while (entry) {
      let taggedNext = entry.taggedNext;
      if (!(taggedNext & EMPTY) && entry.key == key) return entry;
      entry = changetype<MapEntry<K,V>>(taggedNext & ~EMPTY);
    }
    return null;
  }

  has(key: K): bool {
    return this.find(key, HASH<K>(key)) !== null;
  }

  @operator("[]")
  get(key: K): V {
    var entry = this.find(key, HASH<K>(key));
    if (!entry) throw new Error(E_KEYNOTFOUND); // cannot represent `undefined`
    return entry.value;
  }

  @operator("[]=")
  set(key: K, value: V): this {
    var hashCode = HASH<K>(key);
    var entry = this.find(key, hashCode); // unmanaged!
    if (entry) {
      entry.value = value;
      if (isManaged<V>()) {
        __link(changetype<usize>(this), changetype<usize>(value), true);
      }
    } else {
      // check if rehashing is necessary
      if (this.entriesOffset == this.entriesCapacity) {
        this.rehash(
          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D
            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty
            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N
        );
      }
      // append new entry
      let entries = this.entries;
      entry = changetype<MapEntry<K,V>>(changetype<usize>(entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<K,V>());
      // link with the map
      entry.key = key;
      if (isManaged<K>()) {
        __link(changetype<usize>(this), changetype<usize>(key), true);
      }
      entry.value = value;
      if (isManaged<V>()) {
        __link(changetype<usize>(this), changetype<usize>(value), true);
      }
      ++this.entriesCount;
      // link with previous entry in bucket
      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;
      entry.taggedNext = load<usize>(bucketPtrBase);
      store<usize>(bucketPtrBase, changetype<usize>(entry));
    }
    return this;
  }

  delete(key: K): bool {
    var entry = this.find(key, HASH<K>(key));
    if (!entry) return false;
    entry.taggedNext |= EMPTY;
    --this.entriesCount;
    // check if rehashing is appropriate
    var halfBucketsMask = this.bucketsMask >> 1;
    if (
      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&
      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D
    ) this.rehash(halfBucketsMask);
    return true;
  }

  private rehash(newBucketsMask: u32): void {
    var newBucketsCapacity = <i32>(newBucketsMask + 1);
    var newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);
    var newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;
    var newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>());

    // copy old entries to new entries
    var oldPtr = changetype<usize>(this.entries);
    var oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();
    var newPtr = changetype<usize>(newEntries);
    while (oldPtr != oldEnd) {
      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);
      if (!(oldEntry.taggedNext & EMPTY)) {
        let newEntry = changetype<MapEntry<K,V>>(newPtr);
        let oldEntryKey = oldEntry.key;
        newEntry.key = oldEntryKey;
        newEntry.value = oldEntry.value;
        let newBucketIndex = HASH<K>(oldEntryKey) & newBucketsMask;
        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;
        newEntry.taggedNext = load<usize>(newBucketPtrBase);
        store<usize>(newBucketPtrBase, newPtr);
        newPtr += ENTRY_SIZE<K,V>();
      }
      oldPtr += ENTRY_SIZE<K,V>();
    }

    this.buckets = newBuckets;
    this.bucketsMask = newBucketsMask;
    this.entries = newEntries;
    this.entriesCapacity = newEntriesCapacity;
    this.entriesOffset = this.entriesCount;
  }

  keys(): K[] {
    // FIXME: this is preliminary, needs iterators/closures
    var start = changetype<usize>(this.entries);
    var size = this.entriesOffset;
    var keys = new Array<K>(size);
    var length = 0;
    for (let i = 0; i < size; ++i) {
      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());
      if (!(entry.taggedNext & EMPTY)) {
        keys[length++] = entry.key;
      }
    }
    keys.length = length;
    return keys;
  }

  values(): V[] {
    // FIXME: this is preliminary, needs iterators/closures
    var start = changetype<usize>(this.entries);
    var size = this.entriesOffset;
    var values = new Array<V>(size);
    var length = 0;
    for (let i = 0; i < size; ++i) {
      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());
      if (!(entry.taggedNext & EMPTY)) {
        values[length++] = entry.value;
      }
    }
    values.length = length;
    return values;
  }

  toString(): string {
    return "[object Map]";
  }

  // RT integration

  @unsafe private __visit(cookie: u32): void {
    __visit(changetype<usize>(this.buckets), cookie);
    var entries = changetype<usize>(this.entries);
    if (isManaged<K>() || isManaged<V>()) {
      let cur = entries;
      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();
      while (cur < end) {
        let entry = changetype<MapEntry<K,V>>(cur);
        if (!(entry.taggedNext & EMPTY)) {
          if (isManaged<K>()) {
            let val = changetype<usize>(entry.key);
            if (isNullable<K>()) {
              if (val) __visit(val, cookie);
            } else __visit(val, cookie);
          }
          if (isManaged<V>()) {
            let val = changetype<usize>(entry.value);
            if (isNullable<V>()) {
              if (val) __visit(val, cookie);
            } else __visit(val, cookie);
          }
        }
        cur += ENTRY_SIZE<K,V>();
      }
    }
    __visit(entries, cookie);
  }
}

'''
'''--- std/assembly/math.ts ---
import * as JSMath from "./bindings/Math";
export { JSMath };

import {
  pow_lut, exp_lut, exp2_lut, log_lut, log2_lut,
  powf_lut, expf_lut, exp2f_lut, logf_lut, log2f_lut
} from "./util/math";

import {
  abs as builtin_abs,
  ceil as builtin_ceil,
  clz as builtin_clz,
  copysign as builtin_copysign,
  floor as builtin_floor,
  max as builtin_max,
  min as builtin_min,
  sqrt as builtin_sqrt,
  trunc as builtin_trunc
} from "./builtins";

// SUN COPYRIGHT NOTICE
//
// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
// Developed at SunPro, a Sun Microsystems, Inc. business.
// Permission to use, copy, modify, and distribute this software
// is freely granted, provided that this notice is preserved.
//
// Applies to all functions marked with a comment referring here.

/** @internal */
// @ts-ignore: decorator
@lazy var rempio2_y0: f64, rempio2_y1: f64, res128_hi: u64;

/** @internal */
// @ts-ignore: decorator
@lazy @inline const PIO2_TABLE = memory.data<u64>([
  0x00000000A2F9836E, 0x4E441529FC2757D1, 0xF534DDC0DB629599, 0x3C439041FE5163AB,
  0xDEBBC561B7246E3A, 0x424DD2E006492EEA, 0x09D1921CFE1DEB1C, 0xB129A73EE88235F5,
  0x2EBB4484E99C7026, 0xB45F7E413991D639, 0x835339F49C845F8B, 0xBDF9283B1FF897FF,
  0xDE05980FEF2F118B, 0x5A0A6D1F6D367ECF, 0x27CB09B74F463F66, 0x9E5FEA2D7527BAC7,
  0xEBE5F17B3D0739F7, 0x8A5292EA6BFB5FB1, 0x1F8D5D0856033046, 0xFC7B6BABF0CFBC20,
  0x9AF4361DA9E39161, 0x5EE61B086599855F, 0x14A068408DFFD880, 0x4D73273106061557
]);

/** @internal */
function R(z: f64): f64 { // Rational approximation of (asin(x)-x)/x^3
  const                   // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above
    pS0 = reinterpret<f64>(0x3FC5555555555555), //  1.66666666666666657415e-01
    pS1 = reinterpret<f64>(0xBFD4D61203EB6F7D), // -3.25565818622400915405e-01
    pS2 = reinterpret<f64>(0x3FC9C1550E884455), //  2.01212532134862925881e-01
    pS3 = reinterpret<f64>(0xBFA48228B5688F3B), // -4.00555345006794114027e-02
    pS4 = reinterpret<f64>(0x3F49EFE07501B288), //  7.91534994289814532176e-04
    pS5 = reinterpret<f64>(0x3F023DE10DFDF709), //  3.47933107596021167570e-05
    qS1 = reinterpret<f64>(0xC0033A271C8A2D4B), // -2.40339491173441421878e+00
    qS2 = reinterpret<f64>(0x40002AE59C598AC8), //  2.02094576023350569471e+00
    qS3 = reinterpret<f64>(0xBFE6066C1B8D0159), // -6.88283971605453293030e-01
    qS4 = reinterpret<f64>(0x3FB3B8C5B12E9282); //  7.70381505559019352791e-02

  var p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));
  var q = 1.0 + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));
  return p / q;
}

/** @internal */
// @ts-ignore: decorator
@inline
function expo2(x: f64, sign: f64): f64 { // exp(x)/2 for x >= log(DBL_MAX)
  const                       // see: musl/src/math/__expo2.c
    k    = <u32>2043,
    kln2 = reinterpret<f64>(0x40962066151ADD8B); // 0x1.62066151add8bp+10
  var scale = reinterpret<f64>(<u64>((<u32>0x3FF + k / 2) << 20) << 32);
  // in directed rounding correct sign before rounding or overflow is important
  return NativeMath.exp(x - kln2) * (sign * scale) * scale;
}

/** @internal */
/* Helper function to eventually get bits of Ï€/2 * |x|
 *
 * y = Ï€/4 * (frac << clz(frac) >> 11)
 * return clz(frac)
 *
 * Right shift 11 bits to make upper half fit in `double`
 */
// @ts-ignore: decorator
@inline
function pio2_right(q0: u64, q1: u64): u64 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c
  // Bits of Ï€/4
  const p0: u64 = 0xC4C6628B80DC1CD1;
  const p1: u64 = 0xC90FDAA22168C234;

  const Ox1p_64 = reinterpret<f64>(0x3BF0000000000000); // 0x1p-64
  const Ox1p_75 = reinterpret<f64>(0x3B40000000000000); // 0x1p-75

  var shift = clz(q1);

  q1 = q1 << shift | q0 >> (64 - shift);
  q0 <<= shift;

  var lo = umuldi(p1, q1);
  var hi = res128_hi;

  var ahi = hi >> 11;
  var alo = lo >> 11 | hi << 53;
  var blo = <u64>(Ox1p_75 * <f64>p0 * <f64>q1 + Ox1p_75 * <f64>p1 * <f64>q0);

  rempio2_y0 = <f64>(ahi + u64(lo < blo));
  rempio2_y1 = Ox1p_64 * <f64>(alo + blo);

  return shift;
}

/** @internal */
// @ts-ignore: decorator
@inline
function umuldi(u: u64, v: u64): u64 {
  var u1: u64 , v1: u64, w0: u64, w1: u64, t: u64;

  u1 = u & 0xFFFFFFFF;
  v1 = v & 0xFFFFFFFF;

  u >>= 32;
  v >>= 32;

  t  = u1 * v1;
  w0 = t & 0xFFFFFFFF;
  t  = u * v1 + (t >> 32);
  w1 = t >> 32;
  t  = u1 * v + (t & 0xFFFFFFFF);

  res128_hi = u * v + w1 + (t >> 32);
  return (t << 32) + w0;
}

/** @internal */
function pio2_large_quot(x: f64, u: i64): i32 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c
  var magnitude = u & 0x7FFFFFFFFFFFFFFF;
  var offset = (magnitude >> 52) - 1045;
  var shift  = offset & 63;
  var tblPtr = PIO2_TABLE + (<i32>(offset >> 6) << 3);
  var s0: u64, s1: u64, s2: u64;

  var b0 = load<u64>(tblPtr, 0 << 3);
  var b1 = load<u64>(tblPtr, 1 << 3);
  var b2 = load<u64>(tblPtr, 2 << 3);

  // Get 192 bits of 0x1p-31 / Ï€ with `offset` bits skipped
  if (shift) {
    let rshift = 64 - shift;
    let b3 = load<u64>(tblPtr, 3 << 3);
    s0 = b1 >> rshift | b0 << shift;
    s1 = b2 >> rshift | b1 << shift;
    s2 = b3 >> rshift | b2 << shift;
  } else {
    s0 = b0;
    s1 = b1;
    s2 = b2;
  }

  var significand = (u & 0x000FFFFFFFFFFFFF) | 0x0010000000000000;

  // First 128 bits of fractional part of x/(2Ï€)
  var blo = umuldi(s1, significand);
  var bhi = res128_hi;

  var ahi = s0 * significand;
  var clo = (s2 >> 32) * (significand >> 32);
  var plo = blo + clo;
  var phi = ahi + bhi + u64(plo < clo);

  // r: u128 = p << 2
  var rlo = plo << 2;
  var rhi = phi << 2 | plo >> 62;

  // s: i128 = r >> 127
  var slo = <i64>rhi >> 63;
  var shi = slo >> 1;
  var q   = (<i64>phi >> 62) - slo;

  var shifter = 0x3CB0000000000000 - (pio2_right(rlo ^ slo, rhi ^ shi) << 52);
  var signbit = (u ^ rhi) & 0x8000000000000000;
  var coeff   = reinterpret<f64>(shifter | signbit);

  rempio2_y0 *= coeff;
  rempio2_y1 *= coeff;

  return <i32>q;
}

/** @internal */
// @ts-ignore: decorator
@inline
function rempio2(x: f64, u: u64, sign: i32): i32 {
  const
    pio2_1  = reinterpret<f64>(0x3FF921FB54400000), // 1.57079632673412561417e+00
    pio2_1t = reinterpret<f64>(0x3DD0B4611A626331), // 6.07710050650619224932e-11
    pio2_2  = reinterpret<f64>(0x3DD0B4611A600000), // 6.07710050630396597660e-11
    pio2_2t = reinterpret<f64>(0x3BA3198A2E037073), // 2.02226624879595063154e-21
    pio2_3  = reinterpret<f64>(0x3BA3198A2E000000), // 2.02226624871116645580e-21
    pio2_3t = reinterpret<f64>(0x397B839A252049C1), // 8.47842766036889956997e-32
    invpio2 = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308

  var ix = <u32>(u >> 32) & 0x7FFFFFFF;

  if (ASC_SHRINK_LEVEL < 1) {
    if (ix < 0x4002D97C) { // |x| < 3pi/4, special case with n=+-1
      let q = 1, z: f64, y0: f64, y1: f64;
      if (!sign) {
        z = x - pio2_1;
        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough
          y0 = z - pio2_1t;
          y1 = (z - y0) - pio2_1t;
        } else { // near pi/2, use 33+33+53 bit pi
          z -= pio2_2;
          y0 = z - pio2_2t;
          y1 = (z - y0) - pio2_2t;
        }
      } else { // negative x
        z = x + pio2_1;
        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough
          y0 = z + pio2_1t;
          y1 = (z - y0) + pio2_1t;
        } else { // near pi/2, use 33+33+53 bit pi
          z += pio2_2;
          y0 = z + pio2_2t;
          y1 = (z - y0) + pio2_2t;
        }
        q = -1;
      }
      rempio2_y0 = y0;
      rempio2_y1 = y1;
      return q;
    }
  }

  if (ix < 0x413921FB) { // |x| ~< 2^20*pi/2 (1647099)
    // Use precise Cody Waite scheme
    let q  = nearest(x * invpio2);
    let r  = x - q * pio2_1;
    let w  = q * pio2_1t; // 1st round good to 85 bit
    let j  = ix >> 20;
    let y0 = r - w;
    let hi = <u32>(reinterpret<u64>(y0) >> 32);
    let i  = j - ((hi >> 20) & 0x7FF);

    if (i > 16) { // 2nd iteration needed, good to 118
      let t = r;
      w  = q * pio2_2;
      r  = t - w;
      w  = q * pio2_2t - ((t - r) - w);
      y0 = r - w;
      hi = <u32>(reinterpret<u64>(y0) >> 32);
      i = j - ((hi >> 20) & 0x7FF);
      if (i > 49) { // 3rd iteration need, 151 bits acc
        let t = r;
        w  = q * pio2_3;
        r  = t - w;
        w  = q * pio2_3t - ((t - r) - w);
        y0 = r - w;
      }
    }
    let y1 = (r - y0) - w;
    rempio2_y0 = y0;
    rempio2_y1 = y1;
    return <i32>q;
  }
  var q = pio2_large_quot(x, u);
  return select(-q, q, sign);
}

/** @internal */
// @ts-ignore: decorator
@inline
function sin_kern(x: f64, y: f64, iy: i32): f64 { // see: musl/tree/src/math/__sin.c
  const
    S1 = reinterpret<f64>(0xBFC5555555555549), // -1.66666666666666324348e-01
    S2 = reinterpret<f64>(0x3F8111111110F8A6), //  8.33333333332248946124e-03
    S3 = reinterpret<f64>(0xBF2A01A019C161D5), // -1.98412698298579493134e-04
    S4 = reinterpret<f64>(0x3EC71DE357B1FE7D), //  2.75573137070700676789e-06
    S5 = reinterpret<f64>(0xBE5AE5E68A2B9CEB), // -2.50507602534068634195e-08
    S6 = reinterpret<f64>(0x3DE5D93A5ACFD57C); //  1.58969099521155010221e-10

  var z = x * x;
  var w = z * z;
  var r = S2 + z * (S3 + z * S4) + z * w * (S5 + z * S6);
  var v = z * x;
  if (!iy) {
    return x + v * (S1 + z * r);
  } else {
    return x - ((z * (0.5 * y - v * r) - y) - v * S1);
  }
}

/** @internal */
// @ts-ignore: decorator
@inline
function cos_kern(x: f64, y: f64): f64 { // see: musl/tree/src/math/__cos.c
  const
    C1 = reinterpret<f64>(0x3FA555555555554C), //  4.16666666666666019037e-02
    C2 = reinterpret<f64>(0xBF56C16C16C15177), // -1.38888888888741095749e-03
    C3 = reinterpret<f64>(0x3EFA01A019CB1590), //  2.48015872894767294178e-05
    C4 = reinterpret<f64>(0xBE927E4F809C52AD), // -2.75573143513906633035e-07
    C5 = reinterpret<f64>(0x3E21EE9EBDB4B1C4), //  2.08757232129817482790e-09
    C6 = reinterpret<f64>(0xBDA8FAE9BE8838D4); // -1.13596475577881948265e-11

  var z = x * x;
  var w = z * z;
  var r = z * (C1 + z * (C2 + z * C3)) + w * w * (C4 + z * (C5 + z * C6));
  var hz = 0.5 * z;
  w = 1.0 - hz;
  return w + (((1.0 - w) - hz) + (z * r - x * y));
}

/** @internal */
function tan_kern(x: f64, y: f64, iy: i32): f64 { // see: src/lib/msun/src/k_tan.c
  const
    T0  = reinterpret<f64>(0x3FD5555555555563), //  3.33333333333334091986e-01
    T1  = reinterpret<f64>(0x3FC111111110FE7A), //  1.33333333333201242699e-01
    T2  = reinterpret<f64>(0x3FABA1BA1BB341FE), //  5.39682539762260521377e-02
    T3  = reinterpret<f64>(0x3F9664F48406D637), //  2.18694882948595424599e-02
    T4  = reinterpret<f64>(0x3F8226E3E96E8493), //  8.86323982359930005737e-03
    T5  = reinterpret<f64>(0x3F6D6D22C9560328), //  3.59207910759131235356e-03
    T6  = reinterpret<f64>(0x3F57DBC8FEE08315), //  1.45620945432529025516e-03
    T7  = reinterpret<f64>(0x3F4344D8F2F26501), //  5.88041240820264096874e-04
    T8  = reinterpret<f64>(0x3F3026F71A8D1068), //  2.46463134818469906812e-04
    T9  = reinterpret<f64>(0x3F147E88A03792A6), //  7.81794442939557092300e-05
    T10 = reinterpret<f64>(0x3F12B80F32F0A7E9), //  7.14072491382608190305e-05
    T11 = reinterpret<f64>(0xBEF375CBDB605373), // -1.85586374855275456654e-05
    T12 = reinterpret<f64>(0x3EFB2A7074BF7AD4); //  2.59073051863633712884e-05

  const
    one    = reinterpret<f64>(0x3FF0000000000000), // 1.00000000000000000000e+00
    pio4   = reinterpret<f64>(0x3FE921FB54442D18), // 7.85398163397448278999e-01
    pio4lo = reinterpret<f64>(0x3C81A62633145C07); // 3.06161699786838301793e-17

  var z: f64, r: f64, v: f64, w: f64, s: f64;
  var hx = <i32>(reinterpret<u64>(x) >> 32); // high word of x
  var ix = hx & 0x7FFFFFFF; // high word of |x|
  var big = ix >= 0x3FE59428;
  if (big) { // |x| >= 0.6744
    if (hx < 0) { x = -x, y = -y; }
    z = pio4 - x;
    w = pio4lo - y;
    x = z + w;
    y = 0.0;
  }
  z = x * x;
  w = z * z;
  r = T1 + w * (T3 + w * (T5 + w * (T7 + w * (T9 + w * T11))));
  v = z * (T2 + w * (T4 + w * (T6 + w * (T8 + w * (T10 + w * T12)))));
  s = z * x;
  r = y + z * (s * (r + v) + y);
  r += T0 * s;
  w = x + r;
  if (big) {
    v = iy;
    return (1 - ((hx >> 30) & 2)) * (v - 2.0 * (x - (w * w / (w + v) - r)));
  }
  if (iy == 1) return w;
  var a: f64, t: f64;
  z = w;
  z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF00000000);
  v = r - (z - x);  // z + v = r + x
  t = a = -one / w; // a = -1.0 / w
  t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);
  s = one + t * z;
  return t + a * (s + t * v);
}

/** @internal */
function dtoi32(x: f64): i32 {
  if (ASC_SHRINK_LEVEL > 0) {
    const inv32 = 1.0 / 4294967296;
    return <i32><i64>(x - 4294967296 * floor(x * inv32));
  } else {
    let result = 0;
    let u = reinterpret<u64>(x);
    let e = (u >> 52) & 0x7FF;
    if (e <= 1023 + 30) {
      result = <i32>x;
    } else if (e <= 1023 + 30 + 53) {
      let v = (u & ((<u64>1 << 52) - 1)) | (<u64>1 << 52);
      v = v << e - 1023 - 52 + 32;
      result = <i32>(v >> 32);
      result = select<i32>(-result, result, u >> 63);
    }
    return result;
  }
}

// @ts-ignore: decorator
@lazy var random_seeded = false;

// @ts-ignore: decorator
@lazy var random_state0_64: u64, random_state1_64: u64;

// @ts-ignore: decorator
@lazy var random_state0_32: u32, random_state1_32: u32;

function murmurHash3(h: u64): u64 { // Force all bits of a hash block to avalanche
  h ^= h >> 33;                     // see: https://github.com/aappleby/smhasher
  h *= 0xFF51AFD7ED558CCD;
  h ^= h >> 33;
  h *= 0xC4CEB9FE1A85EC53;
  h ^= h >> 33;
  return h;
}

function splitMix32(h: u32): u32 {
  h += 0x6D2B79F5;
  h  = (h ^ (h >> 15)) * (h | 1);
  h ^= h + (h ^ (h >> 7)) * (h | 61);
  return h ^ (h >> 14);
}

export namespace NativeMath {

  // @ts-ignore: decorator
  @lazy
  export const E       = reinterpret<f64>(0x4005BF0A8B145769); // 2.7182818284590452354

  // @ts-ignore: decorator
  @lazy
  export const LN2     = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.69314718055994530942

  // @ts-ignore: decorator
  @lazy
  export const LN10    = reinterpret<f64>(0x40026BB1BBB55516); // 2.30258509299404568402

  // @ts-ignore: decorator
  @lazy
  export const LOG2E   = reinterpret<f64>(0x3FF71547652B82FE); // 1.4426950408889634074

  // @ts-ignore: decorator
  @lazy
  export const LOG10E  = reinterpret<f64>(0x3FDBCB7B1526E50E); // 0.43429448190325182765

  // @ts-ignore: decorator
  @lazy
  export const PI      = reinterpret<f64>(0x400921FB54442D18); // 3.14159265358979323846

  // @ts-ignore: decorator
  @lazy
  export const SQRT1_2 = reinterpret<f64>(0x3FE6A09E667F3BCD); // 0.70710678118654752440

  // @ts-ignore: decorator
  @lazy
  export const SQRT2   = reinterpret<f64>(0x3FF6A09E667F3BCD); // 1.41421356237309504880

  // @ts-ignore: decorator
  @lazy
  export var sincos_sin: f64 = 0;

  // @ts-ignore: decorator
  @lazy
  export var sincos_cos: f64 = 0;

  // @ts-ignore: decorator
  @inline export function abs(x: f64): f64 {
    return builtin_abs<f64>(x);
  }

  export function acos(x: f64): f64 { // see: musl/src/math/acos.c and SUN COPYRIGHT NOTICE above
    const
      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00
      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17
      Ox1p_120f = reinterpret<f32>(0x03800000);

    var hx = <u32>(reinterpret<u64>(x) >> 32);
    var ix = hx & 0x7FFFFFFF;
    if (ix >= 0x3FF00000) {
      let lx = <u32>reinterpret<u64>(x);
      if ((ix - 0x3FF00000 | lx) == 0) {
        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;
        return 0;
      }
      return 0 / (x - x);
    }
    if (ix < 0x3FE00000) {
      if (ix <= 0x3C600000) return pio2_hi + Ox1p_120f;
      return pio2_hi - (x - (pio2_lo - x * R(x * x)));
    }
    var s: f64, w: f64, z: f64;
    if (hx >> 31) {
      // z = (1.0 + x) * 0.5;
      z = 0.5 + x * 0.5;
      s = builtin_sqrt<f64>(z);
      w = R(z) * s - pio2_lo;
      return 2 * (pio2_hi - (s + w));
    }
    // z = (1.0 - x) * 0.5;
    z = 0.5 - x * 0.5;
    s = builtin_sqrt<f64>(z);
    var df = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);
    var c = (z - df * df) / (s + df);
    w = R(z) * s + c;
    return 2 * (df + w);
  }

  export function acosh(x: f64): f64 { // see: musl/src/math/acosh.c
    const s = reinterpret<f64>(0x3FE62E42FEFA39EF);
    var u = reinterpret<u64>(x);
    // Prevent propagation for all input values less than 1.0.
    // Note musl lib didn't fix this yet.
    if (<i64>u < 0x3FF0000000000000) return (x - x) / 0.0;
    var e = u >> 52 & 0x7FF;
    if (e < 0x3FF + 1) return log1p(x - 1 + builtin_sqrt<f64>((x - 1) * (x - 1) + 2 * (x - 1)));
    if (e < 0x3FF + 26) return log(2 * x - 1 / (x + builtin_sqrt<f64>(x * x - 1)));
    return log(x) + s;
  }

  export function asin(x: f64): f64 { // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above
    const
      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00
      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17
      Ox1p_120f = reinterpret<f32>(0x03800000);

    var hx = <u32>(reinterpret<u64>(x) >> 32);
    var ix = hx & 0x7FFFFFFF;
    if (ix >= 0x3FF00000) {
      let lx = <u32>reinterpret<u64>(x);
      if ((ix - 0x3FF00000 | lx) == 0) return x * pio2_hi + Ox1p_120f;
      return 0 / (x - x);
    }
    if (ix < 0x3FE00000) {
      if (ix < 0x3E500000 && ix >= 0x00100000) return x;
      return x + x * R(x * x);
    }
    // var z = (1.0 - builtin_abs<f64>(x)) * 0.5;
    var z = 0.5 - builtin_abs<f64>(x) * 0.5;
    var s = builtin_sqrt<f64>(z);
    var r = R(z);
    if (ix >= 0x3FEF3333) x = pio2_hi - (2 * (s + s * r) - pio2_lo);
    else {
      let f = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);
      let c = (z - f * f) / (s + f);
      x = 0.5 * pio2_hi - (2 * s * r - (pio2_lo - 2 * c) - (0.5 * pio2_hi - 2 * f));
    }
    if (hx >> 31) return -x;
    return x;
  }

  export function asinh(x: f64): f64 { // see: musl/src/math/asinh.c
    const c = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.693147180559945309417232121458176568
    var u = reinterpret<u64>(x);
    var e = u >> 52 & 0x7FF;
    var y = reinterpret<f64>(u & 0x7FFFFFFFFFFFFFFF);
    if (e >= 0x3FF + 26) y = log(y) + c;
    else if (e >= 0x3FF + 1)  y =   log(2 * y + 1 / (builtin_sqrt<f64>(y * y + 1) + y));
    else if (e >= 0x3FF - 26) y = log1p(y + y * y / (builtin_sqrt<f64>(y * y + 1) + 1));
    return builtin_copysign(y, x);
  }

  export function atan(x: f64): f64 { // see musl/src/math/atan.c and SUN COPYRIGHT NOTICE above
    const
      atanhi0   = reinterpret<f64>(0x3FDDAC670561BB4F), //  4.63647609000806093515e-01
      atanhi1   = reinterpret<f64>(0x3FE921FB54442D18), //  7.85398163397448278999e-01
      atanhi2   = reinterpret<f64>(0x3FEF730BD281F69B), //  9.82793723247329054082e-01
      atanhi3   = reinterpret<f64>(0x3FF921FB54442D18), //  1.57079632679489655800e+00
      atanlo0   = reinterpret<f64>(0x3C7A2B7F222F65E2), //  2.26987774529616870924e-17
      atanlo1   = reinterpret<f64>(0x3C81A62633145C07), //  3.06161699786838301793e-17
      atanlo2   = reinterpret<f64>(0x3C7007887AF0CBBD), //  1.39033110312309984516e-17
      atanlo3   = reinterpret<f64>(0x3C91A62633145C07), //  6.12323399573676603587e-17
      aT0       = reinterpret<f64>(0x3FD555555555550D), //  3.33333333333329318027e-01
      aT1       = reinterpret<f64>(0xBFC999999998EBC4), // -1.99999999998764832476e-01
      aT2       = reinterpret<f64>(0x3FC24924920083FF), //  1.42857142725034663711e-01
      aT3       = reinterpret<f64>(0xBFBC71C6FE231671), // -1.11111104054623557880e-01,
      aT4       = reinterpret<f64>(0x3FB745CDC54C206E), //  9.09088713343650656196e-02
      aT5       = reinterpret<f64>(0xBFB3B0F2AF749A6D), // -7.69187620504482999495e-02
      aT6       = reinterpret<f64>(0x3FB10D66A0D03D51), //  6.66107313738753120669e-02
      aT7       = reinterpret<f64>(0xBFADDE2D52DEFD9A), // -5.83357013379057348645e-02
      aT8       = reinterpret<f64>(0x3FA97B4B24760DEB), //  4.97687799461593236017e-02
      aT9       = reinterpret<f64>(0xBFA2B4442C6A6C2F), // -3.65315727442169155270e-02
      aT10      = reinterpret<f64>(0x3F90AD3AE322DA11), //  1.62858201153657823623e-02
      Ox1p_120f = reinterpret<f32>(0x03800000);

    var ix = <u32>(reinterpret<u64>(x) >> 32);
    var sx = x;
    ix &= 0x7FFFFFFF;
    var z: f64;
    if (ix >= 0x44100000) {
      if (isNaN(x)) return x;
      z = atanhi3 + Ox1p_120f;
      return builtin_copysign<f64>(z, sx);
    }
    var id: i32;
    if (ix < 0x3FDC0000) {
      if (ix < 0x3E400000) return x;
      id = -1;
    } else {
      x = builtin_abs<f64>(x);
      if (ix < 0x3FF30000) {
        if (ix < 0x3FE60000) {
          id = 0;
          x = (2.0 * x - 1.0) / (2.0 + x);
        } else {
          id = 1;
          x = (x - 1.0) / (x + 1.0);
        }
      } else {
        if (ix < 0x40038000) {
          id = 2;
          x = (x - 1.5) / (1.0 + 1.5 * x);
        } else {
          id = 3;
          x = -1.0 / x;
        }
      }
    }
    z = x * x;
    var w = z * z;
    var s1 = z * (aT0 + w * (aT2 + w * (aT4 + w * (aT6 + w * (aT8 + w * aT10)))));
    var s2 = w * (aT1 + w * (aT3 + w * (aT5 + w * (aT7 + w * aT9))));
    var s3 = x * (s1 + s2);
    if (id < 0) return x - s3;
    switch (id) {
      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }
      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }
      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }
      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }
      default: unreachable();
    }
    return builtin_copysign<f64>(z, sx);
  }

  export function atanh(x: f64): f64 { // see: musl/src/math/atanh.c
    var u = reinterpret<u64>(x);
    var e = u >> 52 & 0x7FF;
    var y = builtin_abs(x);
    if (e < 0x3FF - 1) {
      if (e >= 0x3FF - 32) y = 0.5 * log1p(2 * y + 2 * y * y / (1 - y));
    } else {
      y = 0.5 * log1p(2 * (y / (1 - y)));
    }
    return builtin_copysign<f64>(y, x);
  }

  export function atan2(y: f64, x: f64): f64 { // see: musl/src/math/atan2.c and SUN COPYRIGHT NOTICE above
    const pi_lo = reinterpret<f64>(0x3CA1A62633145C07); // 1.2246467991473531772E-16
    if (isNaN(x) || isNaN(y)) return x + y;
    var u = reinterpret<u64>(x);
    var ix = <u32>(u >> 32);
    var lx = <u32>u;
    u = reinterpret<u64>(y);
    var iy = <u32>(u >> 32);
    var ly = <u32>u;
    if ((ix - 0x3FF00000 | lx) == 0) return atan(y);
    var m = ((iy >> 31) & 1) | ((ix >> 30) & 2);
    ix = ix & 0x7FFFFFFF;
    iy = iy & 0x7FFFFFFF;
    if ((iy | ly) == 0) {
      switch (m) {
        case 0:
        case 1: return  y;
        case 2: return  PI;
        case 3: return -PI;
      }
    }
    if ((ix | lx) == 0) return m & 1 ? -PI / 2 : PI / 2;
    if (ix == 0x7FF00000) {
      if (iy == 0x7FF00000) {
        let t = m & 2 ? 3 * PI / 4 : PI / 4;
        return m & 1 ? -t : t;
      } else {
        let t = m & 2 ? PI : 0;
        return m & 1 ? -t : t;
      }
    }
    var z: f64;
    if (ix + (64 << 20) < iy || iy == 0x7FF00000) return m & 1 ? -PI / 2 : PI / 2;
    if ((m & 2) && iy + (64 << 20) < ix) z = 0;
    else z = atan(builtin_abs<f64>(y / x));
    switch (m) {
      case 0: return  z;
      case 1: return -z;
      case 2: return PI - (z - pi_lo);
      case 3: return (z - pi_lo) - PI;
    }
    unreachable();
    return 0;
  }

  export function cbrt(x: f64): f64 { // see: musl/src/math/cbrt.c and SUN COPYRIGHT NOTICE above
    const
      B1     = <u32>715094163,
      B2     = <u32>696219795,
      P0     = reinterpret<f64>(0x3FFE03E60F61E692), //  1.87595182427177009643
      P1     = reinterpret<f64>(0xBFFE28E092F02420), // -1.88497979543377169875
      P2     = reinterpret<f64>(0x3FF9F1604A49D6C2), //  1.621429720105354466140
      P3     = reinterpret<f64>(0xBFE844CBBEE751D9), // -0.758397934778766047437
      P4     = reinterpret<f64>(0x3FC2B000D4E4EDD7), //  0.145996192886612446982
      Ox1p54 = reinterpret<f64>(0x4350000000000000); //  0x1p54

    var u = reinterpret<u64>(x);
    var hx = <u32>(u >> 32) & 0x7FFFFFFF;
    if (hx >= 0x7FF00000) return x + x;
    if (hx < 0x00100000) {
      u = reinterpret<u64>(x * Ox1p54);
      hx = <u32>(u >> 32) & 0x7FFFFFFF;
      if (hx == 0) return x;
      hx = hx / 3 + B2;
    } else {
      hx = hx / 3 + B1;
    }
    u &= 1 << 63;
    u |= <u64>hx << 32;
    var t = reinterpret<f64>(u);
    var r = (t * t) * (t / x);
    t = t * ((P0 + r * (P1 + r * P2)) + ((r * r) * r) * (P3 + r * P4));
    t = reinterpret<f64>((reinterpret<u64>(t) + 0x80000000) & 0xFFFFFFFFC0000000);
    var s = t * t;
    r = x / s;
    r = (r - t) / (2 * t + r);
    t = t + t * r;
    return t;
  }

  // @ts-ignore: decorator
  @inline
  export function ceil(x: f64): f64 {
    return builtin_ceil<f64>(x);
  }

  export function clz32(x: f64): f64 {
    if (!isFinite(x)) return 32;
    /*
     * Wasm (MVP) and JS have different approaches for double->int conversions.
     *
     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT
     * our float-point arguments before actual convertion to integers.
     */
    return builtin_clz(dtoi32(x));
  }

  export function cos(x: f64): f64 { // see: musl/src/math/cos.c
    var u  = reinterpret<u64>(x);
    var ix = <u32>(u >> 32);
    var sign = ix >> 31;

    ix &= 0x7FFFFFFF;

    // |x| ~< pi/4
    if (ix <= 0x3FE921FB) {
      if (ix < 0x3E46A09E) {  // |x| < 2**-27 * sqrt(2)
        return 1.0;
      }
      return cos_kern(x, 0);
    }

    // sin(Inf or NaN) is NaN
    if (ix >= 0x7FF00000) return x - x;

    // argument reduction needed
    var n  = rempio2(x, u, sign);
    var y0 = rempio2_y0;
    var y1 = rempio2_y1;

    x = n & 1 ? sin_kern(y0, y1, 1) : cos_kern(y0, y1);
    return (n + 1) & 2 ? -x : x;
  }

  export function cosh(x: f64): f64 { // see: musl/src/math/cosh.c
    var u = reinterpret<u64>(x);
    u &= 0x7FFFFFFFFFFFFFFF;
    x = reinterpret<f64>(u);
    var w = <u32>(u >> 32);
    var t: f64;
    if (w < 0x3FE62E42) {
      if (w < 0x3FF00000 - (26 << 20)) return 1;
      t = expm1(x);
      // return 1 + t * t / (2 * (1 + t));
      return 1 + t * t / (2 + 2 * t);
    }
    if (w < 0x40862E42) {
      t = exp(x);
      return 0.5 * (t + 1 / t);
    }
    t = expo2(x, 1);
    return t;
  }

  export function exp(x: f64): f64 { // see: musl/src/math/exp.c and SUN COPYRIGHT NOTICE above
    if (ASC_SHRINK_LEVEL < 1) {
      return exp_lut(x);
    } else {
      const
        ln2hi     = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01
        ln2lo     = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10
        invln2    = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00
        P1        = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01
        P2        = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03
        P3        = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05
        P4        = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06
        P5        = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08
        overflow  = reinterpret<f64>(0x40862E42FEFA39EF), //  709.782712893383973096
        underflow = reinterpret<f64>(0xC0874910D52D3051), // -745.13321910194110842
        Ox1p1023  = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023

      let hx = <u32>(reinterpret<u64>(x) >> 32);
      let sign_ = <i32>(hx >> 31);
      hx &= 0x7FFFFFFF;
      if (hx >= 0x4086232B) {
        if (isNaN(x)) return x;
        if (x > overflow)  return x * Ox1p1023;
        if (x < underflow) return 0;
      }
      let hi: f64, lo: f64 = 0;
      let k = 0;
      if (hx > 0x3FD62E42) {
        if (hx >= 0x3FF0A2B2) {
          k = <i32>(invln2 * x + builtin_copysign<f64>(0.5, x));
        } else {
          k = 1 - (sign_ << 1);
        }
        hi = x - k * ln2hi;
        lo = k * ln2lo;
        x = hi - lo;
      } else if (hx > 0x3E300000) {
        hi = x;
      } else return 1.0 + x;
      let xs = x * x;
      // var c = x - xp2 * (P1 + xp2 * (P2 + xp2 * (P3 + xp2 * (P4 + xp2 * P5))));
      let xq = xs * xs;
      let c = x - (xs * P1 + xq * ((P2 + xs * P3) + xq * (P4 + xs * P5)));
      let y = 1.0 + (x * c / (2 - c) - lo + hi);
      return k == 0 ? y : scalbn(y, k);
    }
  }

  export function exp2(x: f64): f64 {
    return exp2_lut(x);
  }

  export function expm1(x: f64): f64 { // see: musl/src/math/expm1.c and SUN COPYRIGHT NOTICE above
    const
      o_threshold = reinterpret<f64>(0x40862E42FEFA39EF), //  7.09782712893383973096e+02
      ln2_hi      = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01
      ln2_lo      = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10
      invln2      = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00
      Q1          = reinterpret<f64>(0xBFA11111111110F4), // -3.33333333333331316428e-02
      Q2          = reinterpret<f64>(0x3F5A01A019FE5585), //  1.58730158725481460165e-03
      Q3          = reinterpret<f64>(0xBF14CE199EAADBB7), // -7.93650757867487942473e-05
      Q4          = reinterpret<f64>(0x3ED0CFCA86E65239), //  4.00821782732936239552e-06
      Q5          = reinterpret<f64>(0xBE8AFDB76E09C32D), // -2.01099218183624371326e-07
      Ox1p1023    = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023

    var u = reinterpret<u64>(x);
    var hx = <u32>(u >> 32 & 0x7FFFFFFF);
    var k = 0, sign_ = <i32>(u >> 63);
    if (hx >= 0x4043687A) {
      if (isNaN(x)) return x;
      if (sign_) return -1;
      if (x > o_threshold) return x * Ox1p1023;
    }
    var c = 0.0, t: f64;
    if (hx > 0x3FD62E42) {
      k = select<i32>(
        1 - (sign_ << 1),
        <i32>(invln2 * x + builtin_copysign<f64>(0.5, x)),
        hx < 0x3FF0A2B2
      );
      t = <f64>k;
      let hi = x - t * ln2_hi;
      let lo = t * ln2_lo;
      x = hi - lo;
      c = (hi - x) - lo;
    } else if (hx < 0x3C900000) return x;
    var hfx = 0.5 * x;
    var hxs = x * hfx;
    // var r1 = 1.0 + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));
    var hxq = hxs * hxs;
    var r1 = (1.0 + hxs * Q1) + hxq * ((Q2 + hxs * Q3) + hxq * (Q4 + hxs * Q5));
    t = 3.0 - r1 * hfx;
    var e = hxs * ((r1 - t) / (6.0 - x * t));
    if (k == 0) return x - (x * e - hxs);
    e = x * (e - c) - c;
    e -= hxs;
    if (k == -1) return 0.5 * (x - e) - 0.5;
    if (k == 1) {
      if (x < -0.25) return -2.0 * (e - (x + 0.5));
      return 1.0 + 2.0 * (x - e);
    }
    u = (0x3FF + k) << 52;
    var twopk = reinterpret<f64>(u);
    var y: f64;
    if (k < 0 || k > 56) {
      y = x - e + 1.0;
      if (k == 1024) y = y * 2.0 * Ox1p1023;
      else y = y * twopk;
      return y - 1.0;
    }
    u = (0x3FF - k) << 52;
    y = reinterpret<f64>(u);
    if (k < 20) y = (1 - y) - e;
    else y = 1 - (e + y);
    return (x + y) * twopk;
  }

  // @ts-ignore: decorator
  @inline
  export function floor(x: f64): f64 {
    return builtin_floor<f64>(x);
  }

  // @ts-ignore: decorator
  @inline
  export function fround(x: f64): f64 {
    return <f32>x;
  }

  export function hypot(x: f64, y: f64): f64 { // see: musl/src/math/hypot.c
    const
      SPLIT    = reinterpret<f64>(0x41A0000000000000) + 1, // 0x1p27 + 1
      Ox1p700  = reinterpret<f64>(0x6BB0000000000000),
      Ox1p_700 = reinterpret<f64>(0x1430000000000000);

    var ux = reinterpret<u64>(x);
    var uy = reinterpret<u64>(y);
    ux &= 0x7FFFFFFFFFFFFFFF;
    uy &= 0x7FFFFFFFFFFFFFFF;
    if (ux < uy) {
      let ut = ux;
      ux = uy;
      uy = ut;
    }
    var ex = <i32>(ux >> 52);
    var ey = <i32>(uy >> 52);
    y = reinterpret<f64>(uy);
    if (ey == 0x7FF) return y;
    x = reinterpret<f64>(ux);
    if (ex == 0x7FF || uy == 0) return x;
    if (ex - ey > 64) return x + y;
    var z = 1.0;
    if (ex > 0x3FF + 510) {
      z  = Ox1p700;
      x *= Ox1p_700;
      y *= Ox1p_700;
    } else if (ey < 0x3FF - 450) {
      z  = Ox1p_700;
      x *= Ox1p700;
      y *= Ox1p700;
    }
    var c = x * SPLIT;
    var h = x - c + c;
    var l = x - h;
    var hx = x * x;
    var lx = h * h - hx + (2 * h + l) * l;
    c = y * SPLIT;
    h = y - c + c;
    l = y - h;
    var hy = y * y;
    var ly = h * h - hy + (2 * h + l) * l;
    return z * builtin_sqrt(ly + lx + hy + hx);
  }

  export function imul(x: f64, y: f64): f64 {
    /*
     * Wasm (MVP) and JS have different approaches for double->int conversions.
     *
     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT
     * our float-point arguments before actual convertion to integers.
     */
    if (!isFinite(x + y)) return 0;
    return dtoi32(x) * dtoi32(y);
  }

  export function log(x: f64): f64 { // see: musl/src/math/log.c and SUN COPYRIGHT NOTICE above
    if (ASC_SHRINK_LEVEL < 1) {
      return log_lut(x);
    } else {
      const
        ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01
        ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10
        Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01
        Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01
        Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01
        Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01
        Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01
        Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01
        Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01
        Ox1p54 = reinterpret<f64>(0x4350000000000000); // 0x1p54

      let u = reinterpret<u64>(x);
      let hx = <u32>(u >> 32);
      let k = 0;
      if (hx < 0x00100000 || <bool>(hx >> 31)) {
        if (u << 1 == 0) return -1 / (x * x);
        if (hx >> 31)    return (x - x) / 0.0;
        k -= 54;
        x *= Ox1p54;
        u = reinterpret<u64>(x);
        hx = <u32>(u >> 32);
      } else if (hx >= 0x7FF00000) {
        return x;
      } else if (hx == 0x3FF00000 && u << 32 == 0) {
        return 0;
      }
      hx += 0x3FF00000 - 0x3FE6A09E;
      k += (<i32>hx >> 20) - 0x3FF;
      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;
      u = <u64>hx << 32 | (u & 0xFFFFFFFF);
      x = reinterpret<f64>(u);
      let f = x - 1.0;
      let hfsq = 0.5 * f * f;
      let s = f / (2.0 + f);
      let z = s * s;
      let w = z * z;
      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));
      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));
      let r = t2 + t1;
      let dk = <f64>k;
      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;
    }
  }

  export function log10(x: f64): f64 { // see: musl/src/math/log10.c and SUN COPYRIGHT NOTICE above
    const
      ivln10hi  = reinterpret<f64>(0x3FDBCB7B15200000), // 4.34294481878168880939e-01
      ivln10lo  = reinterpret<f64>(0x3DBB9438CA9AADD5), // 2.50829467116452752298e-11
      log10_2hi = reinterpret<f64>(0x3FD34413509F6000), // 3.01029995663611771306e-01
      log10_2lo = reinterpret<f64>(0x3D59FEF311F12B36), // 3.69423907715893078616e-13
      Lg1       = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01
      Lg2       = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01
      Lg3       = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01
      Lg4       = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01
      Lg5       = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01
      Lg6       = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01
      Lg7       = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01
      Ox1p54    = reinterpret<f64>(0x4350000000000000); // 0x1p54

    var u = reinterpret<u64>(x);
    var hx = <u32>(u >> 32);
    var k = 0;
    if (hx < 0x00100000 || <bool>(hx >> 31)) {
      if (u << 1 == 0) return -1 / (x * x);
      if (hx >> 31) return (x - x) / 0.0;
      k -= 54;
      x *= Ox1p54;
      u = reinterpret<u64>(x);
      hx = <u32>(u >> 32);
    } else if (hx >= 0x7FF00000) {
      return x;
    } else if (hx == 0x3FF00000 && u << 32 == 0) {
      return 0;
    }
    hx += 0x3FF00000 - 0x3FE6A09E;
    k += <i32>(hx >> 20) - 0x3FF;
    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;
    u = <u64>hx << 32 | (u & 0xFFFFFFFF);
    x = reinterpret<f64>(u);
    var f = x - 1.0;
    var hfsq = 0.5 * f * f;
    var s = f / (2.0 + f);
    var z = s * s;
    var w = z * z;
    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));
    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));
    var r = t2 + t1;
    var hi = f - hfsq;
    u = reinterpret<u64>(hi);
    u &= 0xFFFFFFFF00000000;
    hi = reinterpret<f64>(u);
    var lo = f - hi - hfsq + s * (hfsq + r);
    var val_hi = hi * ivln10hi;
    var dk = <f64>k;
    var y = dk * log10_2hi;
    var val_lo = dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi;
    w = y + val_hi;
    val_lo += (y - w) + val_hi;
    return val_lo + w;
  }

  export function log1p(x: f64): f64 { // see: musl/src/math/log1p.c and SUN COPYRIGHT NOTICE above
    const
      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01
      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10
      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01
      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01
      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01
      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01
      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01
      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01
      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244); // 1.479819860511658591e-01

    var u = reinterpret<u64>(x);
    var hx = <u32>(u >> 32);
    var k = 1;
    var c = 0.0, f = 0.0;
    if (hx < 0x3FDA827A || <bool>(hx >> 31)) {
      if (hx >= 0xBFF00000) {
        if (x == -1) return x / 0.0;
        return (x - x) / 0.0;
      }
      if (hx << 1 < 0x3CA00000 << 1) return x;
      if (hx <= 0xBFD2BEC4) {
        k = 0;
        c = 0;
        f = x;
      }
    } else if (hx >= 0x7FF00000) return x;
    if (k) {
      u = reinterpret<u64>(1 + x);
      let hu = <u32>(u >> 32);
      hu += 0x3FF00000 - 0x3FE6A09E;
      k = <i32>(hu >> 20) - 0x3FF;
      if (k < 54) {
        let uf = reinterpret<f64>(u);
        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);
        c /= uf;
      } else c = 0;
      hu = (hu & 0x000FFFFF) + 0x3FE6A09E;
      u = <u64>hu << 32 | (u & 0xFFFFFFFF);
      f = reinterpret<f64>(u) - 1;
    }
    var hfsq = 0.5 * f * f;
    var s = f / (2.0 + f);
    var z = s * s;
    var w = z * z;
    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));
    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));
    var r = t2 + t1;
    var dk = <f64>k;
    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;
  }

  export function log2(x: f64): f64 { // see: musl/src/math/log2.c and SUN COPYRIGHT NOTICE above
    if (ASC_SHRINK_LEVEL < 1) {
      return log2_lut(x);
    } else {
      const
        ivln2hi = reinterpret<f64>(0x3FF7154765200000), // 1.44269504072144627571e+00
        ivln2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 1.67517131648865118353e-10
        Lg1     = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01
        Lg2     = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01
        Lg3     = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01
        Lg4     = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01
        Lg5     = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01
        Lg6     = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01
        Lg7     = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01
        Ox1p54  = reinterpret<f64>(0x4350000000000000); // 1p54

      let u = reinterpret<u64>(x);
      let hx = <u32>(u >> 32);
      let k = 0;
      if (hx < 0x00100000 || <bool>(hx >> 31)) {
        if (u << 1 == 0) return -1 / (x * x);
        if (hx >> 31) return (x - x) / 0.0;
        k -= 54;
        x *= Ox1p54;
        u = reinterpret<u64>(x);
        hx = <u32>(u >> 32);
      } else if (hx >= 0x7FF00000) {
        return x;
      } else if (hx == 0x3FF00000 && u << 32 == 0) {
        return 0;
      }
      hx += 0x3FF00000 - 0x3FE6A09E;
      k += <i32>(hx >> 20) - 0x3FF;
      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;
      u = <u64>hx << 32 | (u & 0xFFFFFFFF);
      x = reinterpret<f64>(u);
      let f = x - 1.0;
      let hfsq = 0.5 * f * f;
      let s = f / (2.0 + f);
      let z = s * s;
      let w = z * z;
      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));
      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));
      let r = t2 + t1;
      let hi = f - hfsq;
      u = reinterpret<u64>(hi);
      u &= 0xFFFFFFFF00000000;
      hi = reinterpret<f64>(u);
      let lo = f - hi - hfsq + s * (hfsq + r);
      let val_hi = hi * ivln2hi;
      let val_lo = (lo + hi) * ivln2lo + lo * ivln2hi;
      let y = <f64>k;
      w = y + val_hi;
      val_lo += (y - w) + val_hi;
      val_hi = w;
      return val_lo + val_hi;
    }
  }

  // @ts-ignore: decorator
  @inline
  export function max(value1: f64, value2: f64): f64 {
    return builtin_max<f64>(value1, value2);
  }

  // @ts-ignore: decorator
  @inline
  export function min(value1: f64, value2: f64): f64 {
    return builtin_min<f64>(value1, value2);
  }

  export function pow(x: f64, y: f64): f64 { // see: musl/src/math/pow.c and SUN COPYRIGHT NOTICE above
    // TODO: remove this fast pathes after introduced own mid-end IR with "stdlib call simplify" transforms
    if (builtin_abs<f64>(y) <= 2) {
      if (y == 2.0) return x * x;
      if (y == 0.5) {
        return select<f64>(
          builtin_abs<f64>(builtin_sqrt<f64>(x)),
          Infinity,
          x != -Infinity
        );
      }
      if (y == -1.0) return 1 / x;
      if (y == 1.0) return x;
      if (y == 0.0) return 1.0;
    }
    if (ASC_SHRINK_LEVEL < 1) {
      return pow_lut(x, y);
    } else {
      const
        dp_h1   = reinterpret<f64>(0x3FE2B80340000000), //  5.84962487220764160156e-01
        dp_l1   = reinterpret<f64>(0x3E4CFDEB43CFD006), //  1.35003920212974897128e-08
        two53   = reinterpret<f64>(0x4340000000000000), //  9007199254740992.0
        huge    = reinterpret<f64>(0x7E37E43C8800759C), //  1e+300
        tiny    = reinterpret<f64>(0x01A56E1FC2F8F359), //  1e-300
        L1      = reinterpret<f64>(0x3FE3333333333303), //  5.99999999999994648725e-01
        L2      = reinterpret<f64>(0x3FDB6DB6DB6FABFF), //  4.28571428578550184252e-01
        L3      = reinterpret<f64>(0x3FD55555518F264D), //  3.33333329818377432918e-01
        L4      = reinterpret<f64>(0x3FD17460A91D4101), //  2.72728123808534006489e-01
        L5      = reinterpret<f64>(0x3FCD864A93C9DB65), //  2.30660745775561754067e-01
        L6      = reinterpret<f64>(0x3FCA7E284A454EEF), //  2.06975017800338417784e-01
        P1      = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01
        P2      = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03
        P3      = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05
        P4      = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06
        P5      = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08
        lg2     = reinterpret<f64>(0x3FE62E42FEFA39EF), //  6.93147180559945286227e-01
        lg2_h   = reinterpret<f64>(0x3FE62E4300000000), //  6.93147182464599609375e-01
        lg2_l   = reinterpret<f64>(0xBE205C610CA86C39), // -1.90465429995776804525e-09
        ovt     = reinterpret<f64>(0x3C971547652B82FE), //  8.0085662595372944372e-017
        cp      = reinterpret<f64>(0x3FEEC709DC3A03FD), //  9.61796693925975554329e-01
        cp_h    = reinterpret<f64>(0x3FEEC709E0000000), //  9.61796700954437255859e-01
        cp_l    = reinterpret<f64>(0xBE3E2FE0145B01F5), // -7.02846165095275826516e-09
        ivln2   = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00
        ivln2_h = reinterpret<f64>(0x3FF7154760000000), //  1.44269502162933349609e+00
        ivln2_l = reinterpret<f64>(0x3E54AE0BF85DDF44), //  1.92596299112661746887e-08
        inv3    = reinterpret<f64>(0x3FD5555555555555); //  0.3333333333333333333333

      let u_ = reinterpret<u64>(x);
      let hx = <i32>(u_ >> 32);
      let lx = <u32>u_;
      u_ = reinterpret<u64>(y);
      let hy = <i32>(u_ >> 32);
      let ly = <u32>u_;
      let ix = hx & 0x7FFFFFFF;
      let iy = hy & 0x7FFFFFFF;
      if ((iy | ly) == 0) return 1.0; // x**0 = 1, even if x is NaN
      // if (hx == 0x3FF00000 && lx == 0) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN
      if ( // NaN if either arg is NaN
        ix > 0x7FF00000 || (ix == 0x7FF00000 && lx != 0) ||
        iy > 0x7FF00000 || (iy == 0x7FF00000 && ly != 0)
      ) return x + y;
      let yisint = 0, k: i32;
      if (hx < 0) {
        if (iy >= 0x43400000) yisint = 2;
        else if (iy >= 0x3FF00000) {
          k = (iy >> 20) - 0x3FF;
          let offset = select<u32>(52, 20, k > 20) - k;
          let Ly = select<u32>(ly, iy, k > 20);
          let jj = Ly >> offset;
          if ((jj << offset) == Ly) yisint = 2 - (jj & 1);
        }
      }
      if (ly == 0) {
        if (iy == 0x7FF00000) { // y is +-inf
          if (((ix - 0x3FF00000) | lx) == 0) return NaN; // C: (-1)**+-inf is 1, JS: NaN
          else if (ix >= 0x3FF00000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0
          else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf
        }
        if (iy == 0x3FF00000) {
          if (hy >= 0) return x;
          return 1 / x;
        }
        if (hy == 0x40000000) return x * x;
        if (hy == 0x3FE00000) {
          if (hx >= 0) return builtin_sqrt(x);
        }
      }
      let ax = builtin_abs<f64>(x), z: f64;
      if (lx == 0) {
        if (ix == 0 || ix == 0x7FF00000 || ix == 0x3FF00000) {
          z = ax;
          if (hy < 0) z = 1.0 / z;
          if (hx < 0) {
            if (((ix - 0x3FF00000) | yisint) == 0) {
              let d = z - z;
              z = d / d;
            } else if (yisint == 1) z = -z;
          }
          return z;
        }
      }
      let s = 1.0;
      if (hx < 0) {
        if (yisint == 0) {
          let d = x - x;
          return d / d;
        }
        if (yisint == 1) s = -1.0;
      }
      let t1: f64, t2: f64, p_h: f64, p_l: f64, r: f64, t: f64, u: f64, v: f64, w: f64;
      let j: i32, n: i32;
      if (iy > 0x41E00000) {
        if (iy > 0x43F00000) {
          if (ix <= 0x3FEFFFFF) return hy < 0 ? huge * huge : tiny * tiny;
          if (ix >= 0x3FF00000) return hy > 0 ? huge * huge : tiny * tiny;
        }
        if (ix < 0x3FEFFFFF) return hy < 0 ? s * huge * huge : s * tiny * tiny;
        if (ix > 0x3FF00000) return hy > 0 ? s * huge * huge : s * tiny * tiny;
        t = ax - 1.0;
        w = (t * t) * (0.5 - t * (inv3 - t * 0.25));
        u = ivln2_h * t;
        v = t * ivln2_l - w * ivln2;
        t1 = u + v;
        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);
        t2 = v - (t1 - u);
      } else {
        let ss: f64, s2: f64, s_h: f64, s_l: f64, t_h: f64, t_l: f64;
        n = 0;
        if (ix < 0x00100000) {
          ax *= two53;
          n -= 53;
          ix = <u32>(reinterpret<u64>(ax) >> 32);
        }
        n += (ix >> 20) - 0x3FF;
        j = ix & 0x000FFFFF;
        ix = j | 0x3FF00000;
        if (j <= 0x3988E) k = 0;
        else if (j < 0xBB67A) k = 1;
        else {
          k = 0;
          n += 1;
          ix -= 0x00100000;
        }
        ax = reinterpret<f64>(reinterpret<u64>(ax) & 0xFFFFFFFF | (<u64>ix << 32));
        let bp = select<f64>(1.5, 1.0, k); // k ? 1.5 : 1.0
        u = ax - bp;
        v = 1.0 / (ax + bp);
        ss = u * v;
        s_h = ss;
        s_h = reinterpret<f64>(reinterpret<u64>(s_h) & 0xFFFFFFFF00000000);
        t_h = reinterpret<f64>(<u64>(((ix >> 1) | 0x20000000) + 0x00080000 + (k << 18)) << 32);
        t_l = ax - (t_h - bp);
        s_l = v * ((u - s_h * t_h) - s_h * t_l);
        s2 = ss * ss;
        r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));
        r += s_l * (s_h + ss);
        s2 = s_h * s_h;
        t_h = 3.0 + s2 + r;
        t_h = reinterpret<f64>(reinterpret<u64>(t_h) & 0xFFFFFFFF00000000);
        t_l = r - ((t_h - 3.0) - s2);
        u = s_h * t_h;
        v = s_l * t_h + t_l * ss;
        p_h = u + v;
        p_h = reinterpret<f64>(reinterpret<u64>(p_h) & 0xFFFFFFFF00000000);
        p_l = v - (p_h - u);
        let z_h = cp_h * p_h;
        let dp_l = select<f64>(dp_l1, 0.0, k);
        let z_l = cp_l * p_h + p_l * cp + dp_l;
        t = <f64>n;
        let dp_h = select<f64>(dp_h1, 0.0, k);
        t1 = ((z_h + z_l) + dp_h) + t;
        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);
        t2 = z_l - (((t1 - t) - dp_h) - z_h);
      }
      let y1 = y;
      y1 = reinterpret<f64>(reinterpret<u64>(y1) & 0xFFFFFFFF00000000);
      p_l = (y - y1) * t1 + y * t2;
      p_h = y1 * t1;
      z = p_l + p_h;
      u_ = reinterpret<u64>(z);
      j = <u32>(u_ >> 32);
      let i = <i32>u_;
      if (j >= 0x40900000) {
        if (((j - 0x40900000) | i) != 0) return s * huge * huge;
        if (p_l + ovt > z - p_h) return s * huge * huge;
      } else if ((j & 0x7FFFFFFF) >= 0x4090CC00) {
        if (((j - 0xC090CC00) | i) != 0) return s * tiny * tiny;
        if (p_l <= z - p_h) return s * tiny * tiny;
      }
      i = j & 0x7FFFFFFF;
      k = (i >> 20) - 0x3FF;
      n = 0;
      if (i > 0x3FE00000) {
        n = j + (0x00100000 >> (k + 1));
        k = ((n & 0x7FFFFFFF) >> 20) - 0x3FF;
        t = 0.0;
        t = reinterpret<f64>(<u64>(n & ~(0x000FFFFF >> k)) << 32);
        n = ((n & 0x000FFFFF) | 0x00100000) >> (20 - k);
        if (j < 0) n = -n;
        p_h -= t;
      }
      t = p_l + p_h;
      t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);
      u = t * lg2_h;
      v = (p_l - (t - p_h)) * lg2 + t * lg2_l;
      z = u + v;
      w = v - (z - u);
      t = z * z;
      t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));
      r = (z * t1) / (t1 - 2.0) - (w + z * w);
      z = 1.0 - (r - z);
      j = <u32>(reinterpret<u64>(z) >> 32);
      j += n << 20;
      if ((j >> 20) <= 0) z = scalbn(z, n);
      else z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF | (<u64>j << 32));
      return s * z;
    }
  }

  export function seedRandom(value: i64): void {
    random_seeded = true;
    random_state0_64 = murmurHash3(value);
    random_state1_64 = murmurHash3(~random_state0_64);
    random_state0_32 = splitMix32(<u32>value);
    random_state1_32 = splitMix32(random_state0_32);
    assert(
      random_state0_64 != 0 && random_state1_64 != 0 &&
      random_state0_32 != 0 && random_state1_32 != 0
    );
  }

  export function random(): f64 { // see: v8/src/base/utils/random-number-generator.cc
    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));
    var s1 = random_state0_64;
    var s0 = random_state1_64;
    random_state0_64 = s0;
    s1 ^= s1 << 23;
    s1 ^= s1 >> 17;
    s1 ^= s0;
    s1 ^= s0 >> 26;
    random_state1_64 = s1;
    var r = (s0 >> 12) | 0x3FF0000000000000;
    return reinterpret<f64>(r) - 1;
  }

  // @ts-ignore: decorator
  @inline
  export function round(x: f64): f64 {
    let roundUp = builtin_ceil<f64>(x);
    return select<f64>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);
  }

  // @ts-ignore: decorator
  @inline
  export function sign(x: f64): f64 {
    if (ASC_SHRINK_LEVEL > 0) {
      return builtin_abs(x) > 0 ? builtin_copysign<f64>(1, x) : x;
    } else {
      return x > 0 ? 1 : x < 0 ? -1 : x;
    }
  }

  // @ts-ignore: decorator
  @inline
  export function signbit(x: f64): bool {
    return <bool>(reinterpret<u64>(x) >>> 63);
  }

  export function sin(x: f64): f64 { // see: musl/src/math/sin.c
    var u  = reinterpret<u64>(x);
    var ix = <u32>(u >> 32);
    var sign = ix >> 31;

    ix &= 0x7FFFFFFF;

    // |x| ~< pi/4
    if (ix <= 0x3FE921FB) {
      if (ix < 0x3E500000) { // |x| < 2**-26
        return x;
      }
      return sin_kern(x, 0.0, 0);
    }

    // sin(Inf or NaN) is NaN
    if (ix >= 0x7FF00000) return x - x;

    // argument reduction needed
    var n  = rempio2(x, u, sign);
    var y0 = rempio2_y0;
    var y1 = rempio2_y1;

    x = n & 1 ? cos_kern(y0, y1) : sin_kern(y0, y1, 1);
    return n & 2 ? -x : x;
  }

  export function sinh(x: f64): f64 { // see: musl/src/math/sinh.c
    var u = reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF;
    var a = reinterpret<f64>(u);
    var w = <u32>(u >> 32);
    var h = builtin_copysign(0.5, x);
    if (w < 0x40862E42) {
      let t = expm1(a);
      if (w < 0x3FF00000) {
        if (w < 0x3FF00000 - (26 << 20)) return x;
        return h * (2 * t - t * t / (t + 1));
      }
      return h * (t + t / (t + 1));
    }
    return expo2(a, 2 * h);
  }

  // @ts-ignore: decorator
  @inline
  export function sqrt(x: f64): f64 {
    return builtin_sqrt<f64>(x);
  }

  export function tan(x: f64): f64 { // see: musl/src/math/tan.c
    var u = reinterpret<u64>(x);
    var ix = <i32>(u >> 32);
    var sign = ix >>> 31;

    ix &= 0x7FFFFFFF;

    // |x| ~< pi/4
    if (ix <= 0x3FE921FB) {
      if (ix < 0x3E400000) { // |x| < 2**-27
        return x;
      }
      return tan_kern(x, 0.0, 1);
    }

    // tan(Inf or NaN) is NaN
    if (ix >= 0x7FF00000) return x - x;

    var n = rempio2(x, u, sign);
    return tan_kern(rempio2_y0, rempio2_y1, 1 - ((n & 1) << 1));
  }

  export function tanh(x: f64): f64 { // see: musl/src/math/tanh.c
    var u = reinterpret<u64>(x);
    u &= 0x7FFFFFFFFFFFFFFF;
    var y = reinterpret<f64>(u);
    var w = <u32>(u >> 32);
    var t: f64;
    if (w > 0x3FE193EA) {
      if (w > 0x40340000) {
        t = 1 - 0 / y;
      } else {
        t = expm1(2 * y);
        t = 1 - 2 / (t + 2);
      }
    } else if (w > 0x3FD058AE) {
      t = expm1(2 * y);
      t = t / (t + 2);
    } else if (w >= 0x00100000) {
      t = expm1(-2 * y);
      t = -t / (t + 2);
    } else t = y;
    return builtin_copysign<f64>(t, x);
  }

  // @ts-ignore: decorator
  @inline
  export function trunc(x: f64): f64 {
    return builtin_trunc<f64>(x);
  }

  export function scalbn(x: f64, n: i32): f64 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbn.c
    const
      Ox1p53    = reinterpret<f64>(0x4340000000000000),
      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000),
      Ox1p_1022 = reinterpret<f64>(0x0010000000000000);

    var y = x;
    if (n > 1023) {
      y *= Ox1p1023;
      n -= 1023;
      if (n > 1023) {
        y *= Ox1p1023;
        n = builtin_min<i32>(n - 1023, 1023);
      }
    } else if (n < -1022) {
      // make sure final n < -53 to avoid double
      // rounding in the subnormal range
      y *= Ox1p_1022 * Ox1p53;
      n += 1022 - 53;
      if (n < -1022) {
        y *= Ox1p_1022 * Ox1p53;
        n = builtin_max<i32>(n + 1022 - 53, -1022);
      }
    }
    return y * reinterpret<f64>(<u64>(0x3FF + n) << 52);
  }

  export function mod(x: f64, y: f64): f64 { // see: musl/src/math/fmod.c
    if (builtin_abs<f64>(y) == 1.0) {
      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))
      // TODO: move this rule to compiler's optimization pass.
      // It could be apply for any x % C_pot, where "C_pot" is pow of two const.
      return builtin_copysign<f64>(x - builtin_trunc<f64>(x), x);
    }
    var ux = reinterpret<u64>(x);
    var uy = reinterpret<u64>(y);
    var ex = <i64>(ux >> 52 & 0x7FF);
    var ey = <i64>(uy >> 52 & 0x7FF);
    var sx = ux >> 63;
    var uy1 = uy << 1;
    if (uy1 == 0 || ex == 0x7FF || isNaN<f64>(y)) {
      let m = x * y;
      return m / m;
    }
    var ux1 = ux << 1;
    if (ux1 <= uy1) {
      return x * f64(ux1 != uy1);
    }
    if (!ex) {
      ex -= builtin_clz<i64>(ux << 12);
      ux <<= 1 - ex;
    } else {
      ux &= <u64>-1 >> 12;
      ux |= 1 << 52;
    }
    if (!ey) {
      ey -= builtin_clz<i64>(uy << 12);
      uy <<= 1 - ey;
    } else {
      uy &= <u64>-1 >> 12;
      uy |= 1 << 52;
    }
    while (ex > ey) {
      if (ux >= uy) {
        if (ux == uy) return 0 * x;
        ux -= uy;
      }
      ux <<= 1;
      --ex;
    }
    if (ux >= uy) {
      if (ux == uy) return 0 * x;
      ux -= uy;
    }
    // for (; !(ux >> 52); ux <<= 1) --ex;
    var shift = builtin_clz<i64>(ux << 11);
    ex -= shift;
    ux <<= shift;
    if (ex > 0) {
      ux -= 1 << 52;
      ux |= ex << 52;
    } else {
      ux >>= -ex + 1;
    }
    return reinterpret<f64>(ux | (sx << 63));
  }

  export function rem(x: f64, y: f64): f64 { // see: musl/src/math/remquo.c
    var ux = reinterpret<u64>(x);
    var uy = reinterpret<u64>(y);
    var ex = <i64>(ux >> 52 & 0x7FF);
    var ey = <i64>(uy >> 52 & 0x7FF);
    var sx = <i32>(ux >> 63);
    if (uy << 1 == 0 || ex == 0x7FF || isNaN(y)) {
      let m = x * y;
      return m / m;
    }
    if (ux << 1 == 0) return x;
    var uxi = ux;
    if (!ex) {
      ex -= builtin_clz<i64>(uxi << 12);
      uxi <<= 1 - ex;
    } else {
      uxi &= <u64>-1 >> 12;
      uxi |= 1 << 52;
    }
    if (!ey) {
      ey -= builtin_clz<i64>(uy << 12);
      uy <<= 1 - ey;
    } else {
      uy &= <u64>-1 >> 12;
      uy |= 1 << 52;
    }
    var q: u32 = 0;
    do {
      if (ex < ey) {
        if (ex + 1 == ey) break; // goto end
        return x;
      }
      while (ex > ey) {
        if (uxi >= uy) {
          uxi -= uy;
          ++q;
        }
        uxi <<= 1;
        q <<= 1;
        --ex;
      }
      if (uxi >= uy) {
        uxi -= uy;
        ++q;
      }
      if (uxi == 0) ex = -60;
      else {
        let shift = builtin_clz<i64>(uxi << 11);
        ex -= shift;
        uxi <<= shift;
      }
      break;
    } while (false);
    // end:
    if (ex > 0) {
      uxi -= 1 << 52;
      uxi |= ex << 52;
    } else {
      uxi >>= -ex + 1;
    }
    x = reinterpret<f64>(uxi);
    y = builtin_abs<f64>(y);
    var x2 = x + x;
    if (ex == ey || (ex + 1 == ey && (x2 > y || (x2 == y && <bool>(q & 1))))) {
      x -= y;
      // ++q;
    }
    return sx ? -x : x;
  }

  export function sincos(x: f64): void { // see: musl/tree/src/math/sincos.c
    var u = reinterpret<u64>(x);
    var ix = <u32>(u >> 32);
    var sign = ix >> 31;
    ix &= 0x7FFFFFFF;

    if (ix <= 0x3FE921FB) {  // |x| ~<= Ï€/4
      if (ix < 0x3E46A09E) { // if |x| < 2**-27 * sqrt(2)
        sincos_sin = x;
        sincos_cos = 1;
        return;
      }
      sincos_sin = sin_kern(x, 0, 0);
      sincos_cos = cos_kern(x, 0);
      return;
    }
    // sin(Inf or NaN) is NaN
    if (ix >= 0x7F800000) {
      let xx = x - x;
      sincos_sin = xx;
      sincos_cos = xx;
      return;
    }
    // general argument reduction needed
    var n = rempio2(x, u, sign);
    var y0 = rempio2_y0;
    var y1 = rempio2_y1;
    var s = sin_kern(y0, y1, 1);
    var c = cos_kern(y0, y1);
    var sin = s, cos = c;
    if (n & 1) {
      sin =  c;
      cos = -s;
    }
    if (n & 2) {
      sin = -sin;
      cos = -cos;
    }
    sincos_sin = sin;
    sincos_cos = cos;
  }
}

// @ts-ignore: decorator
@lazy var rempio2f_y: f64;

// @ts-ignore: decorator
@lazy @inline const PIO2F_TABLE = memory.data<u64>([
  0xA2F9836E4E441529,
  0xFC2757D1F534DDC0,
  0xDB6295993C439041,
  0xFE5163ABDEBBC561
]);

function Rf(z: f32): f32 { // Rational approximation of (asin(x)-x)/x^3
  const                    // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above
    pS0 = reinterpret<f32>(0x3E2AAA75), //  1.6666586697e-01f
    pS1 = reinterpret<f32>(0xBD2F13BA), // -4.2743422091e-02f
    pS2 = reinterpret<f32>(0xBC0DD36B), // -8.6563630030e-03f
    qS1 = reinterpret<f32>(0xBF34E5AE); // -7.0662963390e-01f

  var p = z * (pS0 + z * (pS1 + z * pS2));
  var q: f32 = 1 + z * qS1;
  return p / q;
}

// @ts-ignore: decorator
@inline
function expo2f(x: f32, sign: f32): f32 { // exp(x)/2 for x >= log(DBL_MAX)
  const                                // see: musl/src/math/__expo2f.c
    k    = <u32>235,
    kln2 = reinterpret<f32>(0x4322E3BC); // 0x1.45c778p+7f
  var scale = reinterpret<f32>(<u32>(0x7F + (k >> 1)) << 23);
  // in directed rounding correct sign before rounding or overflow is important
  return NativeMathf.exp(x - kln2) * (sign * scale) * scale;
}

// @ts-ignore: decorator
@inline
function pio2f_large_quot(x: f32, u: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c
  const coeff = reinterpret<f64>(0x3BF921FB54442D18); // Ï€ * 0x1p-65 = 8.51530395021638647334e-20

  var offset = (u >> 23) - 152;
  var shift  = <u64>(offset & 63);
  var tblPtr = PIO2F_TABLE + (offset >> 6 << 3);

  var b0 = load<u64>(tblPtr, 0 << 3);
  var b1 = load<u64>(tblPtr, 1 << 3);
  var lo: u64;

  if (shift > 32) {
    let b2 = load<u64>(tblPtr, 2 << 3);
    lo  = b2 >> (96 - shift);
    lo |= b1 << (shift - 32);
  } else {
    lo = b1 >> (32 - shift);
  }

  var hi = (b1 >> (64 - shift)) | (b0 << shift);
  var mantissa: u64 = (u & 0x007FFFFF) | 0x00800000;
  var product = mantissa * hi + (mantissa * lo >> 32);
  var r: i64 = product << 2;
  var q = <i32>((product >> 62) + (r >>> 63));
  rempio2f_y = copysign<f64>(coeff, x) * <f64>r;
  return q;
}

// @ts-ignore: decorator
@inline
function rempio2f(x: f32, u: u32, sign: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c
  const
    pi2hi = reinterpret<f64>(0x3FF921FB50000000), // 1.57079631090164184570
    pi2lo = reinterpret<f64>(0x3E5110B4611A6263), // 1.58932547735281966916e-8
    _2_pi = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308

  if (u < 0x4DC90FDB) { // Ï€ * 0x1p28
    let q = nearest(x * _2_pi);
    rempio2f_y = x - q * pi2hi - q * pi2lo;
    return <i32>q;
  }

  var q = pio2f_large_quot(x, u);
  return select(-q, q, sign);
}

// |sin(x)/x - s(x)| < 2**-37.5 (~[-4.89e-12, 4.824e-12]).
// @ts-ignore: decorator
@inline
function sin_kernf(x: f64): f32 { // see: musl/tree/src/math/__sindf.c
  const
    S1 = reinterpret<f64>(0xBFC5555554CBAC77), // -0x15555554cbac77.0p-55
    S2 = reinterpret<f64>(0x3F811110896EFBB2), //  0x111110896efbb2.0p-59
    S3 = reinterpret<f64>(0xBF2A00F9E2CAE774), // -0x1a00f9e2cae774.0p-65
    S4 = reinterpret<f64>(0x3EC6CD878C3B46A7); //  0x16cd878c3b46a7.0p-71

  var z = x * x;
  var w = z * z;
  var r = S3 + z * S4;
  var s = z * x;
  return <f32>((x + s * (S1 + z * S2)) + s * w * r);
}

// |cos(x) - c(x)| < 2**-34.1 (~[-5.37e-11, 5.295e-11]).
// @ts-ignore: decorator
@inline
function cos_kernf(x: f64): f32 { // see: musl/tree/src/math/__cosdf.c
  const
    C0 = reinterpret<f64>(0xBFDFFFFFFD0C5E81), // -0x1ffffffd0c5e81.0p-54
    C1 = reinterpret<f64>(0x3FA55553E1053A42), //  0x155553e1053a42.0p-57
    C2 = reinterpret<f64>(0xBF56C087E80F1E27), // -0x16c087e80f1e27.0p-62
    C3 = reinterpret<f64>(0x3EF99342E0EE5069); //  0x199342e0ee5069.0p-68

  var z = x * x;
  var w = z * z;
  var r = C2 + z * C3;
  return <f32>(((1 + z * C0) + w * C1) + (w * z) * r);
}

// |tan(x)/x - t(x)| < 2**-25.5 (~[-2e-08, 2e-08]).
// @ts-ignore: decorator
@inline
function tan_kernf(x: f64, odd: i32): f32 { // see: musl/tree/src/math/__tandf.c
  const
    T0 = reinterpret<f64>(0x3FD5554D3418C99F), // 0x15554d3418c99f.0p-54
    T1 = reinterpret<f64>(0x3FC112FD38999F72), // 0x1112fd38999f72.0p-55
    T2 = reinterpret<f64>(0x3FAB54C91D865AFE), // 0x1b54c91d865afe.0p-57
    T3 = reinterpret<f64>(0x3F991DF3908C33CE), // 0x191df3908c33ce.0p-58
    T4 = reinterpret<f64>(0x3F685DADFCECF44E), // 0x185dadfcecf44e.0p-61
    T5 = reinterpret<f64>(0x3F8362B9BF971BCD); // 0x1362b9bf971bcd.0p-59

  var z = x * x;
  var r = T4 + z * T5;
  var t = T2 + z * T3;
  var w = z * z;
  var s = z * x;
  var u = T0 + z * T1;

  r = (x + s * u) + (s * w) * (t + w * r);
  return <f32>(odd ? -1 / r : r);
}

// See: jdh8/metallic/src/math/float/log2f.c and jdh8/metallic/src/math/float/kernel/atanh.h
// @ts-ignore: decorator
@inline
function log2f(x: f64): f64 {
  const
    log2e = reinterpret<f64>(0x3FF71547652B82FE), // 1.44269504088896340736
    c0 = reinterpret<f64>(0x3FD555554FD9CAEF),    // 0.33333332822728226129
    c1 = reinterpret<f64>(0x3FC999A7A8AF4132),    // 0.20000167595436263505
    c2 = reinterpret<f64>(0x3FC2438D79437030),    // 0.14268654271188685375
    c3 = reinterpret<f64>(0x3FBE2F663B001C97);    // 0.11791075649681414150

  var i = reinterpret<i64>(x);
  var exponent = (i - 0x3FE6A09E667F3BCD) >> 52;
  x = reinterpret<f64>(i - (exponent << 52));
  x = (x - 1) / (x + 1);
  var xx = x * x;
  var y = x + x * xx * (c0 + c1 * xx + (c2 + c3 * xx) * (xx * xx));
  return (2 * log2e) * y + <f64>exponent;
}

// See: jdh8/metallic/src/math/float/exp2f.h and jdh8/metallic/blob/master/src/math/float/kernel/exp2f.h
// @ts-ignore: decorator
@inline
function exp2f(x: f64): f64 {
  const
    c0 = reinterpret<f64>(0x3FE62E4302FCC24A), // 6.931471880289532425e-1
    c1 = reinterpret<f64>(0x3FCEBFBE07D97B91), // 2.402265108421173406e-1
    c2 = reinterpret<f64>(0x3FAC6AF6CCFC1A65), // 5.550357105498874537e-2
    c3 = reinterpret<f64>(0x3F83B29E3CE9AEF6), // 9.618030771171497658e-3
    c4 = reinterpret<f64>(0x3F55F0896145A89F), // 1.339086685300950937e-3
    c5 = reinterpret<f64>(0x3F2446C81E384864); // 1.546973499989028719e-4

  if (x < -1022) return 0;
  if (x >= 1024) return Infinity;

  var n = nearest(x);
  x -= n;
  var xx = x * x;
  var y = 1 + x * (c0 + c1 * x + (c2 + c3 * x) * xx + (c4 + c5 * x) * (xx * xx));
  return reinterpret<f64>(reinterpret<i64>(y) + (<i64>n << 52));
}

export namespace NativeMathf {

  // @ts-ignore: decorator
  @lazy
  export const E       = <f32>NativeMath.E;

  // @ts-ignore: decorator
  @lazy
  export const LN2     = <f32>NativeMath.LN2;

  // @ts-ignore: decorator
  @lazy
  export const LN10    = <f32>NativeMath.LN10;

  // @ts-ignore: decorator
  @lazy
  export const LOG2E   = <f32>NativeMath.LOG2E;

  // @ts-ignore: decorator
  @lazy
  export const LOG10E  = <f32>NativeMath.LOG10E;

  // @ts-ignore: decorator
  @lazy
  export const PI      = <f32>NativeMath.PI;

  // @ts-ignore: decorator
  @lazy
  export const SQRT1_2 = <f32>NativeMath.SQRT1_2;

  // @ts-ignore: decorator
  @lazy
  export const SQRT2   = <f32>NativeMath.SQRT2;

  // @ts-ignore: decorator
  @lazy
  export var sincos_sin: f32 = 0;

  // @ts-ignore: decorator
  @lazy
  export var sincos_cos: f32 = 0;

  // @ts-ignore: decorator
  @inline
  export function abs(x: f32): f32 {
    return builtin_abs<f32>(x);
  }

  export function acos(x: f32): f32 { // see: musl/src/math/acosf.c and SUN COPYRIGHT NOTICE above
    const
      pio2_hi   = reinterpret<f32>(0x3FC90FDA), // 1.5707962513e+00f
      pio2_lo   = reinterpret<f32>(0x33A22168), // 7.5497894159e-08f
      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f

    var hx = reinterpret<u32>(x);
    var ix = hx & 0x7FFFFFFF;
    if (ix >= 0x3F800000) {
      if (ix == 0x3F800000) {
        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;
        return 0;
      }
      return 0 / (x - x);
    }
    if (ix < 0x3F000000) {
      if (ix <= 0x32800000) return pio2_hi + Ox1p_120f;
      return pio2_hi - (x - (pio2_lo - x * Rf(x * x)));
    }
    var z: f32, w: f32, s: f32;
    if (hx >> 31) {
      // z = (1 + x) * 0.5;
      z = 0.5 + x * 0.5;
      s = builtin_sqrt<f32>(z);
      w = Rf(z) * s - pio2_lo;
      return 2 * (pio2_hi - (s + w));
    }
    // z = (1 - x) * 0.5;
    z = 0.5 - x * 0.5;
    s = builtin_sqrt<f32>(z);
    hx = reinterpret<u32>(s);
    var df = reinterpret<f32>(hx & 0xFFFFF000);
    var c = (z - df * df) / (s + df);
    w = Rf(z) * s + c;
    return 2 * (df + w);
  }

  export function acosh(x: f32): f32 { // see: musl/src/math/acoshf.c
    const s = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f
    var u = reinterpret<u32>(x);
    var a = u & 0x7FFFFFFF;
    if (a < 0x3F800000 + (1 << 23)) { // |x| < 2, invalid if x < 1
      let xm1 = x - 1;
      return log1p(xm1 + builtin_sqrt(xm1 * (xm1 + 2)));
    }
    if (u < 0x3F800000 + (12 << 23)) { // 2 <= x < 0x1p12
      return log(2 * x - 1 / (x + builtin_sqrt<f32>(x * x - 1)));
    }
    // x >= 0x1p12 or x <= -2 or NaN
    return log(x) + s;
  }

  export function asin(x: f32): f32 { // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above
    const
      pio2      = reinterpret<f32>(0x3FC90FDB), // 1.570796326794896558e+00f
      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f

    var sx = x;
    var hx = reinterpret<u32>(x) & 0x7FFFFFFF;
    if (hx >= 0x3F800000) {
      if (hx == 0x3F800000) return x * pio2 + Ox1p_120f;
      return 0 / (x - x);
    }
    if (hx < 0x3F000000) {
      if (hx < 0x39800000 && hx >= 0x00800000) return x;
      return x + x * Rf(x * x);
    }
    // var z: f32 = (1 - builtin_abs<f32>(x)) * 0.5;
    var z: f32 = 0.5 - builtin_abs<f32>(x) * 0.5;
    var s = builtin_sqrt<f64>(z); // sic
    x = <f32>(pio2 - 2 * (s + s * Rf(z)));
    return builtin_copysign(x, sx);
  }

  export function asinh(x: f32): f32 { // see: musl/src/math/asinhf.c
    const c = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f
    var u = reinterpret<u32>(x) & 0x7FFFFFFF;
    var y = reinterpret<f32>(u);
    if (u >= 0x3F800000 + (12 << 23)) y = log(y) + c;
    else if (u >= 0x3F800000 + (1 << 23))  y =   log(2 * y + 1 / (builtin_sqrt<f32>(y * y + 1) + y));
    else if (u >= 0x3F800000 - (12 << 23)) y = log1p(y + y * y / (builtin_sqrt<f32>(y * y + 1) + 1));
    return builtin_copysign(y, x);
  }

  export function atan(x: f32): f32 { // see: musl/src/math/atanf.c and SUN COPYRIGHT NOTICE above
    const
      atanhi0   = reinterpret<f32>(0x3EED6338), //  4.6364760399e-01f
      atanhi1   = reinterpret<f32>(0x3F490FDA), //  7.8539812565e-01f
      atanhi2   = reinterpret<f32>(0x3F7B985E), //  9.8279368877e-01f
      atanhi3   = reinterpret<f32>(0x3FC90FDA), //  1.5707962513e+00f
      atanlo0   = reinterpret<f32>(0x31AC3769), //  5.0121582440e-09f
      atanlo1   = reinterpret<f32>(0x33222168), //  3.7748947079e-08f
      atanlo2   = reinterpret<f32>(0x33140FB4), //  3.4473217170e-08f
      atanlo3   = reinterpret<f32>(0x33A22168), //  7.5497894159e-08f
      aT0       = reinterpret<f32>(0x3EAAAAA9), //  3.3333328366e-01f
      aT1       = reinterpret<f32>(0xBE4CCA98), // -1.9999158382e-01f
      aT2       = reinterpret<f32>(0x3E11F50D), //  1.4253635705e-01f
      aT3       = reinterpret<f32>(0xBDDA1247), // -1.0648017377e-01f
      aT4       = reinterpret<f32>(0x3D7CAC25), //  6.1687607318e-02f
      Ox1p_120f = reinterpret<f32>(0x03800000); //  0x1p-120f

    var ix = reinterpret<u32>(x);
    var sx = x;
    ix &= 0x7FFFFFFF;
    var z: f32;
    if (ix >= 0x4C800000) {
      if (isNaN(x)) return x;
      z = atanhi3 + Ox1p_120f;
      return builtin_copysign(z, sx);
    }
    var id: i32;
    if (ix < 0x3EE00000) {
      if (ix < 0x39800000) return x;
      id = -1;
    } else {
      x = builtin_abs<f32>(x);
      if (ix < 0x3F980000) {
        if (ix < 0x3F300000) {
          id = 0;
          x = (2.0 * x - 1.0) / (2.0 + x);
        } else {
          id = 1;
          x = (x - 1.0) / (x + 1.0);
        }
      } else {
        if (ix < 0x401C0000) {
          id = 2;
          x = (x - 1.5) / (1.0 + 1.5 * x);
        } else {
          id = 3;
          x = -1.0 / x;
        }
      }
    }
    z = x * x;
    var w = z * z;
    var s1 = z * (aT0 + w * (aT2 + w * aT4));
    var s2 = w * (aT1 + w * aT3);
    var s3 = x * (s1 + s2);
    if (id < 0) return x - s3;
    switch (id) {
      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }
      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }
      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }
      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }
      default: unreachable();
    }
    return builtin_copysign(z, sx);
  }

  export function atanh(x: f32): f32 { // see: musl/src/math/atanhf.c
    var u = reinterpret<u32>(x);
    var y = builtin_abs(x);
    if (u < 0x3F800000 - (1 << 23)) {
      if (u >= 0x3F800000 - (32 << 23)) y = 0.5 * log1p(2 * y * (1.0 + y / (1 - y)));
    } else y = 0.5 * log1p(2 * (y / (1 - y)));
    return builtin_copysign(y, x);
  }

  export function atan2(y: f32, x: f32): f32 { // see: musl/src/math/atan2f.c and SUN COPYRIGHT NOTICE above
    const
      pi    = reinterpret<f32>(0x40490FDB), //  3.1415927410e+00f
      pi_lo = reinterpret<f32>(0xB3BBBD2E); // -8.7422776573e-08f

    if (isNaN(x) || isNaN(y)) return x + y;
    var ix = reinterpret<u32>(x);
    var iy = reinterpret<u32>(y);
    if (ix == 0x3F800000) return atan(y);
    var m = <u32>(((iy >> 31) & 1) | ((ix >> 30) & 2));
    ix &= 0x7FFFFFFF;
    iy &= 0x7FFFFFFF;
    if (iy == 0) {
      switch (m) {
        case 0:
        case 1: return  y;
        case 2: return  pi;
        case 3: return -pi;
      }
    }
    if (ix == 0) return m & 1 ? -pi / 2 : pi / 2;
    if (ix == 0x7F800000) {
      if (iy == 0x7F800000) {
        let t: f32 = m & 2 ? 3 * pi / 4 : pi / 4;
        return m & 1 ? -t : t;
      } else {
        let t: f32 = m & 2 ? pi : 0.0;
        return m & 1 ? -t : t;
      }
    }
    if (ix + (26 << 23) < iy || iy == 0x7F800000) return m & 1 ? -pi / 2 : pi / 2;
    var z: f32;
    if ((m & 2) && iy + (26 << 23) < ix) z = 0.0;
    else z = atan(builtin_abs<f32>(y / x));
    switch (m) {
      case 0: return  z;
      case 1: return -z;
      case 2: return pi - (z - pi_lo);
      case 3: return (z - pi_lo) - pi;
    }
    unreachable();
    return 0;
  }

  export function cbrt(x: f32): f32 { // see: musl/src/math/cbrtf.c and SUN COPYRIGHT NOTICE above
    const
      B1      = <u32>709958130,
      B2      = <u32>642849266,
      Ox1p24f = reinterpret<f32>(0x4B800000);

    var u = reinterpret<u32>(x);
    var hx = u & 0x7FFFFFFF;
    if (hx >= 0x7F800000) return x + x;
    if (hx < 0x00800000) {
      if (hx == 0) return x;
      u = reinterpret<u32>(x * Ox1p24f);
      hx = u & 0x7FFFFFFF;
      hx = hx / 3 + B2;
    } else {
      hx = hx / 3 + B1;
    }
    u &= 0x80000000;
    u |= hx;
    var t = <f64>reinterpret<f32>(u);
    var r = t * t * t;
    t = t * (<f64>x + x + r) / (x + r + r);
    r = t * t * t;
    t = t * (<f64>x + x + r) / (x + r + r);
    return <f32>t;
  }

  // @ts-ignore: decorator
  @inline
  export function ceil(x: f32): f32 {
    return builtin_ceil<f32>(x);
  }

  export function clz32(x: f32): f32 {
    if (!isFinite(x)) return 32;
    return <f32>builtin_clz(dtoi32(x));
  }

  export function cos(x: f32): f32 { // see: musl/src/math/cosf.c
    const
      c1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1
      c2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2
      c3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3
      c4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4

    var ix = reinterpret<u32>(x);
    var sign = ix >> 31;
    ix &= 0x7FFFFFFF;

    if (ix <= 0x3F490FDA) {  // |x| ~<= Ï€/4
      if (ix < 0x39800000) { // |x| < 2**-12
        // raise inexact if x != 0
        return 1;
      }
      return cos_kernf(x);
    }

    if (ASC_SHRINK_LEVEL < 1) {
      if (ix <= 0x407B53D1) {  // |x| ~<= 5Ï€/4
        if (ix > 0x4016CBE3) { // |x|  ~> 3Ï€/4
          return -cos_kernf(sign ? x + c2pio2 : x - c2pio2);
        } else {
          return sign ? sin_kernf(x + c1pio2) : sin_kernf(c1pio2 - x);
        }
      }
      if (ix <= 0x40E231D5) {  // |x| ~<= 9Ï€/4
        if (ix > 0x40AFEDDF) { // |x|  ~> 7Ï€/4
          return cos_kernf(sign ? x + c4pio2 : x - c4pio2);
        } else {
          return sign ? sin_kernf(-x - c3pio2) : sin_kernf(x - c3pio2);
        }
      }
    }

    // cos(Inf or NaN) is NaN
    if (ix >= 0x7F800000) return x - x;

    // general argument reduction needed
    var n = rempio2f(x, ix, sign);
    var y = rempio2f_y;

    var t = n & 1 ? sin_kernf(y) : cos_kernf(y);
    return (n + 1) & 2 ? -t : t;
  }

  export function cosh(x: f32): f32 { // see: musl/src/math/coshf.c
    var u = reinterpret<u32>(x);
    u &= 0x7FFFFFFF;
    x = reinterpret<f32>(u);
    if (u < 0x3F317217) {
      if (u < 0x3F800000 - (12 << 23)) return 1;
      let t = expm1(x);
      // return 1 + t * t / (2 * (1 + t));
      return 1 + t * t / (2 + 2 * t);
    }
    if (u < 0x42B17217) {
      let t = exp(x);
      // return 0.5 * (t + 1 / t);
      return 0.5 * t + 0.5 / t;
    }
    return expo2f(x, 1);
  }

  // @ts-ignore: decorator
  @inline
  export function floor(x: f32): f32 {
    return builtin_floor<f32>(x);
  }

  export function exp(x: f32): f32 { // see: musl/src/math/expf.c and SUN COPYRIGHT NOTICE above
    if (ASC_SHRINK_LEVEL < 1) {
      return expf_lut(x);
    } else {
      const
        ln2hi    = reinterpret<f32>(0x3F317200), //  6.9314575195e-1f
        ln2lo    = reinterpret<f32>(0x35BFBE8E), //  1.4286067653e-6f
        invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+0f
        P1       = reinterpret<f32>(0x3E2AAA8F), //  1.6666625440e-1f
        P2       = reinterpret<f32>(0xBB355215), // -2.7667332906e-3f
        Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f

      let hx = reinterpret<u32>(x);
      let sign_ = <i32>(hx >> 31);
      hx &= 0x7FFFFFFF;
      if (hx >= 0x42AEAC50) {
        if (hx > 0x7F800000) return x; // NaN
        if (hx >= 0x42B17218) {
          if (!sign_) return x * Ox1p127f;
          else if (hx >= 0x42CFF1B5) return 0;
        }
      }
      let hi: f32, lo: f32;
      let k: i32;
      if (hx > 0x3EB17218) {
        if (hx > 0x3F851592) {
          k = <i32>(invln2 * x + builtin_copysign<f32>(0.5, x));
        } else {
          k = 1 - (sign_ << 1);
        }
        hi = x - <f32>k * ln2hi;
        lo = <f32>k * ln2lo;
        x = hi - lo;
      } else if (hx > 0x39000000) {
        k = 0;
        hi = x;
        lo = 0;
      } else {
        return 1 + x;
      }
      let xx = x * x;
      let c = x - xx * (P1 + xx * P2);
      let y: f32 = 1 + (x * c / (2 - c) - lo + hi);
      return k == 0 ? y : scalbn(y, k);
    }
  }

  export function exp2(x: f32): f32 {
    return exp2f_lut(x);
  }

  export function expm1(x: f32): f32 { // see: musl/src/math/expm1f.c and SUN COPYRIGHT NOTICE above
    const
      ln2_hi   = reinterpret<f32>(0x3F317180), //  6.9313812256e-01f
      ln2_lo   = reinterpret<f32>(0x3717F7D1), //  9.0580006145e-06f
      invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00f
      Q1       = reinterpret<f32>(0xBD088868), // -3.3333212137e-02f
      Q2       = reinterpret<f32>(0x3ACF3010), //  1.5807170421e-03f
      Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f

    var u = reinterpret<u32>(x);
    var hx = u & 0x7FFFFFFF;
    var sign_ = <i32>(u >> 31);
    if (hx >= 0x4195B844) {
      if (hx > 0x7F800000) return x;
      if (sign_) return -1;
      if (hx > 0x42B17217) { // x > log(FLT_MAX)
        x *= Ox1p127f;
        return x;
      }
    }
    var c: f32 = 0.0, t: f32, k: i32;
    if (hx > 0x3EB17218) {
      k = select<i32>(
        1 - (sign_ << 1),
        <i32>(invln2 * x + builtin_copysign<f32>(0.5, x)),
        hx < 0x3F851592
      );
      t = <f32>k;
      let hi = x - t * ln2_hi;
      let lo = t * ln2_lo;
      x = hi - lo;
      c = (hi - x) - lo;
    } else if (hx < 0x33000000) {
      return x;
    } else k = 0;
    var hfx: f32 = 0.5 * x;
    var hxs: f32 = x * hfx;
    var r1: f32 = 1.0 + hxs * (Q1 + hxs * Q2);
    t  = 3.0 - r1 * hfx;
    var e = hxs * ((r1 - t) / (6.0 - x * t));
    if (k == 0) return x - (x * e - hxs);
    e  = x * (e - c) - c;
    e -= hxs;
    if (k == -1) return 0.5 * (x - e) - 0.5;
    if (k == 1) {
      if (x < -0.25) return -2.0 * (e - (x + 0.5));
      return 1.0 + 2.0 * (x - e);
    }
    u = (0x7F + k) << 23;
    var twopk = reinterpret<f32>(u);
    var y: f32;
    if (k < 0 || k > 56) {
      y = x - e + 1.0;
      if (k == 128) y = y * 2.0 * Ox1p127f;
      else y = y * twopk;
      return y - 1.0;
    }
    u = (0x7F - k) << 23;
    y = reinterpret<f32>(u);
    if (k < 20) y = (1 - y) - e;
    else y = 1 - (e + y);
    return (x + y) * twopk;
  }

  // @ts-ignore: decorator
  @inline
  export function fround(x: f32): f32 {
    return x;
  }

  export function hypot(x: f32, y: f32): f32 { // see: musl/src/math/hypotf.c
    const
      Ox1p90f  = reinterpret<f32>(0x6C800000),
      Ox1p_90f = reinterpret<f32>(0x12800000);

    var ux = reinterpret<u32>(x);
    var uy = reinterpret<u32>(y);
    ux &= 0x7FFFFFFF;
    uy &= 0x7FFFFFFF;
    if (ux < uy) {
      let ut = ux;
      ux = uy;
      uy = ut;
    }
    x = reinterpret<f32>(ux);
    y = reinterpret<f32>(uy);
    if (uy == 0xFF << 23) return y;
    if (ux >= 0xFF << 23 || uy == 0 || ux - uy >= 25 << 23) return x + y;
    var z: f32 = 1;
    if (ux >= (0x7F + 60) << 23) {
      z  = Ox1p90f;
      x *= Ox1p_90f;
      y *= Ox1p_90f;
    } else if (uy < (0x7F - 60) << 23) {
      z  = Ox1p_90f;
      x *= Ox1p90f;
      y *= Ox1p90f;
    }
    return z * builtin_sqrt<f32>(<f32>(<f64>x * x + <f64>y * y));
  }

  // @ts-ignore: decorator
  @inline
  export function imul(x: f32, y: f32): f32 {
    /*
     * Wasm (MVP) and JS have different approaches for double->int conversions.
     *
     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT
     * our float-point arguments before actual convertion to integers.
     */
    if (!isFinite(x + y)) return 0;
    return <f32>(dtoi32(x) * dtoi32(y));
  }

  export function log(x: f32): f32 { // see: musl/src/math/logf.c and SUN COPYRIGHT NOTICE above
    if (ASC_SHRINK_LEVEL < 1) {
      return logf_lut(x);
    } else {
      const
        ln2_hi  = reinterpret<f32>(0x3F317180), // 6.9313812256e-01f
        ln2_lo  = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06f
        Lg1     = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f
        Lg2     = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f
        Lg3     = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f
        Lg4     = reinterpret<f32>(0x3E789E26), // 0xf89e26.0p-26f
        Ox1p25f = reinterpret<f32>(0x4C000000);

      let u = reinterpret<u32>(x);
      let k = 0;
      if (u < 0x00800000 || <bool>(u >> 31)) {
        if (u << 1 == 0) return -1 / (x * x);
        if (u >> 31) return (x - x) / 0;
        k -= 25;
        x *= Ox1p25f;
        u = reinterpret<u32>(x);
      } else if (u >= 0x7F800000) {
        return x;
      } else if (u == 0x3F800000) {
        return 0;
      }
      u += 0x3F800000 - 0x3F3504F3;
      k += <u32>(<i32>u >> 23) - 0x7F;
      u = (u & 0x007FFFFF) + 0x3F3504F3;
      x = reinterpret<f32>(u);
      let f = x - 1.0;
      let s = f / (2.0 + f);
      let z = s * s;
      let w = z * z;
      let t1 = w * (Lg2 + w * Lg4);
      let t2 = z * (Lg1 + w * Lg3);
      let r = t2 + t1;
      let hfsq = <f32>0.5 * f * f;
      let dk = <f32>k;
      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;
    }
  }

  export function log10(x: f32): f32 { // see: musl/src/math/log10f.c and SUN COPYRIGHT NOTICE above
    const
      ivln10hi  = reinterpret<f32>(0x3EDE6000), //  4.3432617188e-01f
      ivln10lo  = reinterpret<f32>(0xB804EAD9), // -3.1689971365e-05f
      log10_2hi = reinterpret<f32>(0x3E9A2080), //  3.0102920532e-01f
      log10_2lo = reinterpret<f32>(0x355427DB), //  7.9034151668e-07f
      Lg1       = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f
      Lg2       = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f
      Lg3       = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f
      Lg4       = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f
      Ox1p25f   = reinterpret<f32>(0x4C000000); //  0x1p25f

    var ix = reinterpret<u32>(x);
    var k = 0;
    if (ix < 0x00800000 || <bool>(ix >> 31)) {
      if (ix << 1 == 0) return -1 / (x * x);
      if (ix >> 31) return (x - x) / 0.0;
      k -= 25;
      x *= Ox1p25f;
      ix = reinterpret<u32>(x);
    } else if (ix >= 0x7F800000) {
      return x;
    } else if (ix == 0x3F800000) {
      return 0;
    }
    ix += 0x3F800000 - 0x3F3504F3;
    k += <i32>(ix >> 23) - 0x7F;
    ix = (ix & 0x007FFFFF) + 0x3F3504F3;
    x = reinterpret<f32>(ix);
    var f = x - 1.0;
    var s = f / (2.0 + f);
    var z = s * s;
    var w = z * z;
    var t1 = w * (Lg2 + w * Lg4);
    var t2 = z * (Lg1 + w * Lg3);
    var r = t2 + t1;
    var hfsq: f32 = 0.5 * f * f;
    var hi = f - hfsq;
    ix = reinterpret<u32>(hi);
    ix &= 0xFFFFF000;
    hi = reinterpret<f32>(ix);
    var lo = f - hi - hfsq + s * (hfsq + r);
    var dk = <f32>k;
    return dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi + hi * ivln10hi + dk * log10_2hi;
  }

  export function log1p(x: f32): f32 { // see: musl/src/math/log1pf.c and SUN COPYRIGHT NOTICE above
    const
      ln2_hi = reinterpret<f32>(0x3F317180), // 6.9313812256e-01
      ln2_lo = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06
      Lg1    = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f, 0.66666662693f
      Lg2    = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f, 0.40000972152f
      Lg3    = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f, 0.28498786688f
      Lg4    = reinterpret<f32>(0x3E789E26); // 0xf89e26.0p-26f, 0.24279078841f

    var ix = reinterpret<u32>(x);
    var c: f32 = 0, f: f32 = 0;
    var k: i32 = 1;
    if (ix < 0x3ED413D0 || <bool>(ix >> 31)) {
      if (ix >= 0xBF800000) {
        if (x == -1) return x / 0.0;
        return (x - x) / 0.0;
      }
      if (ix << 1 < 0x33800000 << 1) return x;
      if (ix <= 0xBE95F619) {
        k = 0;
        c = 0;
        f = x;
      }
    } else if (ix >= 0x7F800000) return x;
    if (k) {
      let uf: f32 = 1 + x;
      let iu = reinterpret<u32>(uf);
      iu += 0x3F800000 - 0x3F3504F3;
      k = <i32>(iu >> 23) - 0x7F;
      if (k < 25) {
        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);
        c /= uf;
      } else c = 0;
      iu = (iu & 0x007FFFFF) + 0x3F3504F3;
      f = reinterpret<f32>(iu) - 1;
    }
    var s = f / (2.0 + f);
    var z = s * s;
    var w = z * z;
    var t1 = w * (Lg2 + w * Lg4);
    var t2 = z * (Lg1 + w * Lg3);
    var r = t2 + t1;
    var hfsq: f32 = 0.5 * f * f;
    var dk = <f32>k;
    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;
  }

  export function log2(x: f32): f32 { // see: musl/src/math/log2f.c and SUN COPYRIGHT NOTICE above
    if (ASC_SHRINK_LEVEL < 1) {
      return log2f_lut(x);
    } else {
      const
        ivln2hi = reinterpret<f32>(0x3FB8B000), //  1.4428710938e+00f
        ivln2lo = reinterpret<f32>(0xB9389AD4), // -1.7605285393e-04
        Lg1     = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f
        Lg2     = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f
        Lg3     = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f
        Lg4     = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f
        Ox1p25f = reinterpret<f32>(0x4C000000); //  0x1p25f

      let ix = reinterpret<u32>(x);
      let k: i32 = 0;
      if (ix < 0x00800000 || <bool>(ix >> 31)) {
        if (ix << 1 == 0) return -1 / (x * x);
        if (ix >> 31) return (x - x) / 0.0;
        k -= 25;
        x *= Ox1p25f;
        ix = reinterpret<u32>(x);
      } else if (ix >= 0x7F800000) {
        return x;
      } else if (ix == 0x3F800000) {
        return 0;
      }
      ix += 0x3F800000 - 0x3F3504F3;
      k += <i32>(ix >> 23) - 0x7F;
      ix = (ix & 0x007FFFFF) + 0x3F3504F3;
      x = reinterpret<f32>(ix);
      let f = x - 1.0;
      let s = f / (2.0 + f);
      let z = s * s;
      let w = z * z;
      let t1 = w * (Lg2 + w * Lg4);
      let t2 = z * (Lg1 + w * Lg3);
      let r = t2 + t1;
      let hfsq: f32 = 0.5 * f * f;
      let hi = f - hfsq;
      let u = reinterpret<u32>(hi);
      u &= 0xFFFFF000;
      hi = reinterpret<f32>(u);
      let lo: f32 = f - hi - hfsq + s * (hfsq + r);
      let dk = <f32>k;
      return (lo + hi) * ivln2lo + lo * ivln2hi + hi * ivln2hi + dk;
    }
  }

  // @ts-ignore: decorator
  @inline
  export function max(value1: f32, value2: f32): f32 {
    return builtin_max<f32>(value1, value2);
  }

  // @ts-ignore: decorator
  @inline
  export function min(value1: f32, value2: f32): f32 {
    return builtin_min<f32>(value1, value2);
  }

  export function pow(x: f32, y: f32): f32 {
    // TODO: remove this fast pathes after introduced own mid-end IR with "stdlib call simplify" transforms
    if (builtin_abs<f32>(y) <= 2) {
      if (y == 2.0) return x * x;
      if (y == 0.5) {
        return select<f32>(
          builtin_abs<f32>(builtin_sqrt<f32>(x)),
          Infinity,
          x != -Infinity
        );
      }
      if (y == -1.0) return 1 / x;
      if (y == 1.0) return x;
      if (y == 0.0) return 1.0;
    }
    if (ASC_SHRINK_LEVEL < 1) {
      // see: musl/src/math/powf.c
      return powf_lut(x, y);
    } else {
      // based on:  jdh8/metallic/src/math/float/powf.c
      if (y == 0) return 1;
      // @ts-ignore: cast
      if (isNaN(x) | isNaN(y)) {
        return NaN;
      }
      let sign: u32 = 0;
      let uy = reinterpret<u32>(y);
      let ux = reinterpret<u32>(x);
      let sx = ux >> 31;
      ux &= 0x7FFFFFFF;
      if (sx && nearest(y) == y) {
        x = -x;
        sx = 0;
        sign = u32(nearest(y * 0.5) != y * 0.5) << 31;
      }
      let m: u32;
      if (ux == 0x3F800000) { // x == 1
        m = sx | u32((uy & 0x7FFFFFFF) == 0x7F800000) ? 0x7FC00000 : 0x3F800000;
      } else if (ux == 0) {
        m = uy >> 31 ? 0x7F800000 : 0;
      } else if (ux == 0x7F800000) {
        m = uy >> 31 ? 0 : 0x7F800000;
      } else if (sx) {
        m = 0x7FC00000;
      } else {
        m = reinterpret<u32>(<f32>exp2f(<f64>y * log2f(x)));
      }
      return reinterpret<f32>(m | sign);
    }
  }

  // @ts-ignore: decorator
  @inline
  export function seedRandom(value: i64): void {
    NativeMath.seedRandom(value);
  }

  // Using xoroshiro64starstar from http://xoshiro.di.unimi.it/xoroshiro64starstar.c
  export function random(): f32 {
    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));

    var s0 = random_state0_32;
    var s1 = random_state1_32;
    var r  = rotl<u32>(s0 * 0x9E3779BB, 5) * 5;

    s1 ^= s0;
    random_state0_32 = rotl<u32>(s0, 26) ^ s1 ^ (s1 << 9);
    random_state1_32 = rotl<u32>(s1, 13);

    return reinterpret<f32>((r >> 9) | (127 << 23)) - 1.0;
  }

  // @ts-ignore: decorator
  @inline
  export function round(x: f32): f32 {
    let roundUp = builtin_ceil<f32>(x);
    return select<f32>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);
  }

  // @ts-ignore: decorator
  @inline
  export function sign(x: f32): f32 {
    if (ASC_SHRINK_LEVEL > 0) {
      return builtin_abs(x) > 0 ? builtin_copysign<f32>(1, x) : x;
    } else {
      return x > 0 ? 1 : x < 0 ? -1 : x;
    }
  }

  // @ts-ignore: decorator
  @inline
  export function signbit(x: f32): bool {
    return <bool>(reinterpret<u32>(x) >>> 31);
  }

  export function sin(x: f32): f32 { // see: musl/src/math/sinf.c
    const
      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1
      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2
      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3
      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4

    var ix = reinterpret<u32>(x);
    var sign = ix >> 31;
    ix &= 0x7FFFFFFF;

    if (ix <= 0x3F490FDA) {  // |x| ~<= Ï€/4
      if (ix < 0x39800000) { // |x| < 2**-12
        return x;
      }
      return sin_kernf(x);
    }

    if (ASC_SHRINK_LEVEL < 1) {
      if (ix <= 0x407B53D1) {   // |x| ~<= 5Ï€/4
        if (ix <= 0x4016CBE3) { // |x| ~<= 3Ï€/4
          return sign ? -cos_kernf(x + s1pio2) : cos_kernf(x - s1pio2);
        }
        return sin_kernf(-(sign ? x + s2pio2 : x - s2pio2));
      }

      if (ix <= 0x40E231D5) {   // |x| ~<= 9Ï€/4
        if (ix <= 0x40AFEDDF) { // |x| ~<= 7Ï€/4
          return sign ? cos_kernf(x + s3pio2) : -cos_kernf(x - s3pio2);
        }
        return sin_kernf(sign ? x + s4pio2 : x - s4pio2);
      }
    }

    // sin(Inf or NaN) is NaN
    if (ix >= 0x7F800000) return x - x;

    var n = rempio2f(x, ix, sign);
    var y = rempio2f_y;

    var t = n & 1 ? cos_kernf(y) : sin_kernf(y);
    return n & 2 ? -t : t;
  }

  export function sinh(x: f32): f32 { // see: musl/src/math/sinhf.c
    var u = reinterpret<u32>(x) & 0x7FFFFFFF;
    var a = reinterpret<f32>(u);
    var h = builtin_copysign<f32>(0.5, x);
    if (u < 0x42B17217) {
      let t = expm1(a);
      if (u < 0x3F800000) {
        if (u < 0x3F800000 - (12 << 23)) return x;
        return h * (2 * t - t * t / (t + 1));
      }
      return h * (t + t / (t + 1));
    }
    return expo2f(a, 2 * h);
  }

  // @ts-ignore: decorator
  @inline
  export function sqrt(x: f32): f32 {
    return builtin_sqrt<f32>(x);
  }

  export function tan(x: f32): f32 { // see: musl/src/math/tanf.c
    const
      t1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2
      t2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2
      t3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2
      t4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2

    var ix = reinterpret<u32>(x);
    var sign = ix >> 31;
    ix &= 0x7FFFFFFF;

    if (ix <= 0x3F490FDA) {  // |x| ~<= Ï€/4
      if (ix < 0x39800000) { // |x| < 2**-12
        return x;
      }
      return tan_kernf(x, 0);
    }

    if (ASC_SHRINK_LEVEL < 1) {
      if (ix <= 0x407B53D1) {   // |x| ~<= 5Ï€/4
        if (ix <= 0x4016CBE3) { // |x| ~<= 3Ï€/4
          return tan_kernf((sign ? x + t1pio2 : x - t1pio2), 1);
        } else {
          return tan_kernf((sign ? x + t2pio2 : x - t2pio2), 0);
        }
      }
      if (ix <= 0x40E231D5) {   // |x| ~<= 9Ï€/4
        if (ix <= 0x40AFEDDF) { // |x| ~<= 7Ï€/4
          return tan_kernf((sign ? x + t3pio2 : x - t3pio2), 1);
        } else {
          return tan_kernf((sign ? x + t4pio2 : x - t4pio2), 0);
        }
      }
    }

    // tan(Inf or NaN) is NaN
    if (ix >= 0x7F800000) return x - x;

    // argument reduction
    var n = rempio2f(x, ix, sign);
    var y = rempio2f_y;
    return tan_kernf(y, n & 1);
  }

  export function tanh(x: f32): f32 { // see: musl/src/math/tanhf.c
    var u = reinterpret<u32>(x);
    u &= 0x7FFFFFFF;
    var y = reinterpret<f32>(u);
    var t: f32;
    if (u > 0x3F0C9F54) {
      if (u > 0x41200000) t = 1 + 0 / y;
      else {
        t = expm1(2 * y);
        t = 1 - 2 / (t + 2);
      }
    } else if (u > 0x3E82C578) {
      t = expm1(2 * y);
      t = t / (t + 2);
    } else if (u >= 0x00800000) {
      t = expm1(-2 * y);
      t = -t / (t + 2);
    } else t = y;
    return builtin_copysign<f32>(t, x);
  }

  // @ts-ignore: decorator
  @inline
  export function trunc(x: f32): f32 {
    return builtin_trunc<f32>(x);
  }

  export function scalbn(x: f32, n: i32): f32 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbnf.c
    const
      Ox1p24f   = reinterpret<f32>(0x4B800000),
      Ox1p127f  = reinterpret<f32>(0x7F000000),
      Ox1p_126f = reinterpret<f32>(0x00800000);

    var y = x;
    if (n > 127) {
      y *= Ox1p127f;
      n -= 127;
      if (n > 127) {
        y *= Ox1p127f;
        n = builtin_min<i32>(n - 127, 127);
      }
    } else if (n < -126) {
      y *= Ox1p_126f * Ox1p24f;
      n += 126 - 24;
      if (n < -126) {
        y *= Ox1p_126f * Ox1p24f;
        n = builtin_max<i32>(n + 126 - 24, -126);
      }
    }
    return y * reinterpret<f32>(<u32>(0x7F + n) << 23);
  }

  export function mod(x: f32, y: f32): f32 { // see: musl/src/math/fmodf.c
    if (builtin_abs<f32>(y) == 1.0) {
      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))
      // TODO: move this rule to compiler's optimization pass.
      // It could be apply for any x % C_pot, where "C_pot" is pow of two const.
      return builtin_copysign<f32>(x - builtin_trunc<f32>(x), x);
    }
    var ux = reinterpret<u32>(x);
    var uy = reinterpret<u32>(y);
    var ex = <i32>(ux >> 23 & 0xFF);
    var ey = <i32>(uy >> 23 & 0xFF);
    var sm = ux & 0x80000000;
    var uy1 = uy << 1;
    if (uy1 == 0 || ex == 0xFF || isNaN<f32>(y)) {
      let m = x * y;
      return m / m;
    }
    var ux1 = ux << 1;
    if (ux1 <= uy1) {
      return x * f32(ux1 != uy1);
    }
    if (!ex) {
      ex -= builtin_clz<u32>(ux << 9);
      ux <<= 1 - ex;
    } else {
      ux &= <u32>-1 >> 9;
      ux |= 1 << 23;
    }
    if (!ey) {
      ey -= builtin_clz<u32>(uy << 9);
      uy <<= 1 - ey;
    } else {
      uy &= <u32>-1 >> 9;
      uy |= 1 << 23;
    }
    while (ex > ey) {
      if (ux >= uy) {
        if (ux == uy) return 0 * x;
        ux -= uy;
      }
      ux <<= 1;
      --ex;
    }
    if (ux >= uy) {
      if (ux == uy) return 0 * x;
      ux -= uy;
    }
    // for (; !(ux >> 23); ux <<= 1) --ex;
    var shift = <i32>builtin_clz<u32>(ux << 8);
    ex -= shift;
    ux <<= shift;
    if (ex > 0) {
      ux -= 1 << 23;
      ux |= <u32>ex << 23;
    } else {
      ux >>= -ex + 1;
    }
    return reinterpret<f32>(ux | sm);
  }

  export function rem(x: f32, y: f32): f32 { // see: musl/src/math/remquof.c
    var ux = reinterpret<u32>(x);
    var uy = reinterpret<u32>(y);
    var ex = <i32>(ux >> 23 & 0xFF);
    var ey = <i32>(uy >> 23 & 0xFF);
    var sx = <i32>(ux >> 31);
    var uxi = ux;
    if (uy << 1 == 0 || ex == 0xFF || isNaN(y)) return (x * y) / (x * y);
    if (ux << 1 == 0) return x;
    if (!ex) {
      ex -= builtin_clz<u32>(uxi << 9);
      uxi <<= 1 - ex;
    } else {
      uxi &= <u32>-1 >> 9;
      uxi |= 1 << 23;
    }
    if (!ey) {
      ey -= builtin_clz<u32>(uy << 9);
      uy <<= 1 - ey;
    } else {
      uy &= <u32>-1 >> 9;
      uy |= 1 << 23;
    }
    var q = 0;
    do {
      if (ex < ey) {
        if (ex + 1 == ey) break; // goto end
        return x;
      }
      while (ex > ey) {
        if (uxi >= uy) {
          uxi -= uy;
          ++q;
        }
        uxi <<= 1;
        q <<= 1;
        --ex;
      }
      if (uxi >= uy) {
        uxi -= uy;
        ++q;
      }
      if (uxi == 0) ex = -30;
      else {
        let shift = builtin_clz<i32>(uxi << 8);
        ex -= shift;
        uxi <<= shift;
      }
      break;
    } while (false);
    // end:
    if (ex > 0) {
      uxi -= 1 << 23;
      uxi |= <u32>ex << 23;
    } else {
      uxi >>= -ex + 1;
    }
    x = reinterpret<f32>(uxi);
    y = builtin_abs<f32>(y);
    var x2 = x + x;
    if (ex == ey || (ex + 1 == ey && (<f32>x2 > y || (<f32>x2 == y && <bool>(q & 1))))) {
      x -= y;
      // q++;
    }
    return sx ? -x : x;
  }

  export function sincos(x: f32): void { // see: musl/tree/src/math/sincosf.c
    const
      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2
      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2
      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2
      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2

    var ix = reinterpret<u32>(x);
    var sign = ix >> 31;
    ix &= 0x7FFFFFFF;

    if (ix <= 0x3F490FDA) {  // |x| ~<= Ï€/4
      if (ix < 0x39800000) { // |x| < 2**-12
        sincos_sin = x;
        sincos_cos = 1;
        return;
      }
      sincos_sin = sin_kernf(x);
      sincos_cos = cos_kernf(x);
      return;
    }
    if (ASC_SHRINK_LEVEL < 1) {
      if (ix <= 0x407B53D1) {   // |x| ~<= 5Ï€/4
        if (ix <= 0x4016CBE3) { // |x| ~<= 3Ï€/4
          if (sign) {
            sincos_sin = -cos_kernf(x + s1pio2);
            sincos_cos =  sin_kernf(x + s1pio2);
          } else {
            sincos_sin = cos_kernf(s1pio2 - x);
            sincos_cos = sin_kernf(s1pio2 - x);
          }
          return;
        }
        // -sin(x + c) is not correct if x+c could be 0: -0 vs +0
        sincos_sin = -sin_kernf(sign ? x + s2pio2 : x - s2pio2);
        sincos_cos = -cos_kernf(sign ? x + s2pio2 : x - s2pio2);
        return;
      }
      if (ix <= 0x40E231D5) {   // |x| ~<= 9Ï€/4
        if (ix <= 0x40AFEDDF) { // |x| ~<= 7Ï€/4
          if (sign) {
            sincos_sin =  cos_kernf(x + s3pio2);
            sincos_cos = -sin_kernf(x + s3pio2);
          } else {
            sincos_sin = -cos_kernf(x - s3pio2);
            sincos_cos =  sin_kernf(x - s3pio2);
          }
          return;
        }
        sincos_sin = sin_kernf(sign ? x + s4pio2 : x - s4pio2);
        sincos_cos = cos_kernf(sign ? x + s4pio2 : x - s4pio2);
        return;
      }
    }
    // sin(Inf or NaN) is NaN
    if (ix >= 0x7F800000) {
      let xx = x - x;
      sincos_sin = xx;
      sincos_cos = xx;
      return;
    }
    // general argument reduction needed
    var n = rempio2f(x, ix, sign);
    var y = rempio2f_y;
    var s = sin_kernf(y);
    var c = cos_kernf(y);
    var sin = s, cos = c;
    if (n & 1) {
      sin =  c;
      cos = -s;
    }
    if (n & 2) {
      sin = -sin;
      cos = -cos;
    }
    sincos_sin = sin;
    sincos_cos = cos;
  }
}

export function ipow32(x: i32, e: i32): i32 {
  var out = 1;
  if (ASC_SHRINK_LEVEL < 1) {
    if (x == 2) {
      return select<i32>(1 << e, 0, <u32>e < 32);
    }
    if (e <= 0) {
      if (x == -1) return select<i32>(-1, 1, e & 1);
      return i32(e == 0) | i32(x == 1);
    }
    else if (e == 1) return x;
    else if (e == 2) return x * x;
    else if (e < 32) {
      let log = 32 - clz(e);
      // 32 = 2 ^ 5, so need only five cases.
      // But some extra cases needs for properly overflowing
      switch (log) {
        case 5: {
          if (e & 1) out *= x;
          e >>>= 1;
          x *= x;
        }
        case 4: {
          if (e & 1) out *= x;
          e >>>= 1;
          x *= x;
        }
        case 3: {
          if (e & 1) out *= x;
          e >>>= 1;
          x *= x;
        }
        case 2: {
          if (e & 1) out *= x;
          e >>>= 1;
          x *= x;
        }
        case 1: {
          if (e & 1) out *= x;
        }
      }
      return out;
    }
  }
  while (e) {
    if (e & 1) out *= x;
    e >>>= 1;
    x *= x;
  }
  return out;
}

export function ipow64(x: i64, e: i64): i64 {
  var out: i64 = 1;
  if (ASC_SHRINK_LEVEL < 1) {
    if (x == 2) {
      return select<i64>(1 << e, 0, <u64>e < 64);
    }
    if (e <= 0) {
      if (x == -1) return select<i64>(-1, 1, e & 1);
      return i64(e == 0) | i64(x == 1);
    }
    else if (e == 1) return x;
    else if (e == 2) return x * x;
    else if (e < 64) {
      let log = 64 - <i32>clz(e);
      // 64 = 2 ^ 6, so need only six cases.
      // But some extra cases needs for properly overflowing
      switch (log) {
        case 6: {
          if (e & 1) out *= x;
          e >>>= 1;
          x *= x;
        }
        case 5: {
          if (e & 1) out *= x;
          e >>>= 1;
          x *= x;
        }
        case 4: {
          if (e & 1) out *= x;
          e >>>= 1;
          x *= x;
        }
        case 3: {
          if (e & 1) out *= x;
          e >>>= 1;
          x *= x;
        }
        case 2: {
          if (e & 1) out *= x;
          e >>>= 1;
          x *= x;
        }
        case 1: {
          if (e & 1) out *= x;
        }
      }
      return out;
    }
  }
  while (e) {
    if (e & 1) out *= x;
    e >>>= 1;
    x *= x;
  }
  return out;
}

/*
TODO:
In compile time if only exponent is constant we could replace ipow32/ipow64 by shortest addition chains
which usually faster than exponentiation by squaring

for ipow32 and e < 32:

let b: i32, c: i32, d: i32, h: i32, k: i32, g: i32;
switch (e) {
  case  1: return x;
  case  2: return x * x;
  case  3: return x * x * x;
  case  4: return (b = x * x) * b;
  case  5: return (b = x * x) * b * x;
  case  6: return (b = x * x) * b * b;
  case  7: return (b = x * x) * b * b * x;
  case  8: return (d = (b = x * x) * b) * d;
  case  9: return (c = x * x * x) * c * c;
  case 10: return (d = (b = x * x) * b) * d * b;
  case 11: return (d = (b = x * x) * b) * d * b * x;
  case 12: return (d = (b = x * x) * b) * d * d;
  case 13: return (d = (b = x * x) * b) * d * d * x;
  case 14: return (d = (b = x * x) * b) * d * d * b;
  case 15: return (k = (b = x * x) * b * x) * k * k;
  case 16: return (h = (d = (b = x * x) * b) * d) * h;
  case 17: return (h = (d = (b = x * x) * b) * d) * h * x;
  case 18: return (h = (d = (b = x * x) * b) * d * x) * h;
  case 19: return (h = (d = (b = x * x) * b) * d * x) * h * x;
  case 20: return (h = (k = (b = x * x) * b * x) * k) * h;
  case 21: return (h = (k = (b = x * x) * b * x) * k) * h * x;
  case 22: return (g = (h = (k = (b = x * x) * b * x) * k) * x) * g;
  case 23: return (h = (d = (c = (b = x * x) * x) * b) * d) * h * c;
  case 24: return (h = (d = (c = x * x * x) * c) * d) * h;
  case 25: return (h = (d = (c = x * x * x) * c) * d) * h * x;
  case 26: return (g = (h = (d = (c = x * x * x) * c) * d) * x) * g;
  case 27: return (h = (d = (c = x * x * x) * c) * d) * h * c;
  case 28: return (h = (d = (c = x * x * x) * c * x) * d) * h;
  case 29: return (h = (d = (c = x * x * x) * c * x) * d) * h * x;
  case 30: return (h = (d = (c = x * x * x) * c) * d * c) * h;
  case 31: return (h = (d = (c = x * x * x) * c) * d * c) * h * x;
}

for ipow64: TODO
switch (e) {
  case 32:
  ...
  case 63:
}
*/

'''
'''--- std/assembly/memory.ts ---
import { memcmp, memmove, memset } from "./util/memory";
import { E_NOTIMPLEMENTED } from "./util/error";

/** Memory manager interface. */
export namespace memory {

  /** Gets the size of the memory in pages. */
  // @ts-ignore: decorator
  @builtin
  export declare function size(): i32;

  /** Grows the memory by the given size in pages and returns the previous size in pages. */
  // @ts-ignore: decorator
  @unsafe @builtin
  export declare function grow(pages: i32): i32;

  /** Fills a section in memory with the specified byte value. */
  // @ts-ignore: decorator
  @unsafe @builtin
  export function fill(dst: usize, c: u8, n: usize): void {
    memset(dst, c, n); // fallback if "bulk-memory" isn't enabled
  }

  /** Copies a section of memory to another. Has move semantics. */
  // @ts-ignore: decorator
  @unsafe @builtin
  export function copy(dst: usize, src: usize, n: usize): void {
    memmove(dst, src, n); // fallback if "bulk-memory" isn't enabled
  }

  /** Initializes a memory segment. */
  // @ts-ignore: decorator
  @unsafe
  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {
    throw new Error(E_NOTIMPLEMENTED);
  }

  /** Drops a memory segment. */
  // @ts-ignore: decorator
  @unsafe
  export function drop(segmentIndex: u32): void {
    throw new Error(E_NOTIMPLEMENTED);
  }

  /** Repeats a section of memory at a specific address. */
  // @ts-ignore: decorator
  @unsafe
  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {
    var index: usize = 0;
    var total = srcLength * count;
    while (index < total) {
      memory.copy(dst + index, src, srcLength);
      index += srcLength;
    }
  }

  /** Compares a section of memory to another. */
  // @ts-ignore: decorator
  @inline
  export function compare(vl: usize, vr: usize, n: usize): i32 {
    return memcmp(vl, vr, n);
  }

  /** Gets a pointer to a static chunk of memory of the given size. */
  // @ts-ignore: decorator
  @builtin
  export declare function data<T>(size: T, align?: i32): usize;
}

// @ts-ignore: decorator
@builtin
export declare const __data_end: usize;

// @ts-ignore: decorator
@builtin
export declare var __stack_pointer: usize;

// @ts-ignore: decorator
@builtin
export declare const __heap_base: usize;

/** Heap memory interface. */
export namespace heap {

  /** Allocates a chunk of memory of at least the specified size. */
  // @ts-ignore: decorator
  @unsafe export function alloc(size: usize): usize {
    return __alloc(size);
  }

  /** Reallocates a chunk of memory to have at least the specified size. */
  // @ts-ignore: decorator
  @unsafe export function realloc(ptr: usize, size: usize): usize {
    return __realloc(ptr, size);
  }

  /** Frees a chunk of memory. Does hardly anything (most recent block only) with the stub runtime. */
  // @ts-ignore: decorator
  @unsafe export function free(ptr: usize): void {
    __free(ptr);
  }

  /** Dangerously resets the entire heap. Specific to the stub runtime. */
  // @ts-ignore: decorator
  @unsafe export function reset(): void {
    if (isDefined(__reset)) {
      __reset();
    } else {
      throw new Error(E_NOTIMPLEMENTED);
    }
  }
}

'''
'''--- std/assembly/number.ts ---
import { itoa32, utoa32, itoa64, utoa64, dtoa } from "./util/number";
import { strtol } from "./util/string";

// @ts-ignore: decorator
@builtin @inline
export const NaN: f64 = 0 / 0;

// @ts-ignore: decorator
@builtin @inline
export const Infinity: f64 = 1 / 0;

// @ts-ignore: decorator
@builtin
export declare function isNaN<T extends number>(value: T): bool;

// @ts-ignore: decorator
@builtin
export declare function isFinite<T extends number>(value: T): bool;

@final @unmanaged
export abstract class I8 {

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;

  static parseInt(value: string, radix: i32 = 0): i8 {
    return <i8>strtol<i32>(value, radix);
  }

  toString(this: i8, radix: i32 = 10): String {
    return itoa32(this, radix);
  }
}

@final @unmanaged
export abstract class I16 {

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;

  static parseInt(value: string, radix: i32 = 0): i16 {
    return <i16>strtol<i32>(value, radix);
  }

  toString(this: i16, radix: i32 = 10): String {
    return itoa32(this, radix);
  }
}

@final @unmanaged
export abstract class I32 {

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;

  static parseInt(value: string, radix: i32 = 0): i32 {
    return <i32>strtol<i32>(value, radix);
  }

  toString(this: i32, radix: i32 = 10): String {
    return itoa32(this, radix);
  }
}

@final @unmanaged
export abstract class I64 {

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;

  static parseInt(value: string, radix: i32 = 0): i64 {
    return strtol<i64>(value, radix);
  }

  toString(this: i64, radix: i32 = 10): String {
    return itoa64(this, radix);
  }
}

@final @unmanaged
export abstract class Isize {

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: isize = isize.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: isize = isize.MAX_VALUE;

  static parseInt(value: string, radix: i32 = 0): isize {
    return <isize>strtol<i64>(value, radix);
  }

  toString(this: isize, radix: i32 = 10): String {
    if (sizeof<isize>() == 4) {
      return itoa32(<i32>this, radix);
    } else {
      return itoa64(<i64>this, radix);
    }
  }
}

@final @unmanaged
export abstract class U8 {

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;

  static parseInt(value: string, radix: i32 = 0): u8 {
    return <u8>strtol<i32>(value, radix);
  }

  toString(this: u8, radix: i32 = 10): String {
    return utoa32(this, radix);
  }
}

@final @unmanaged
export abstract class U16 {

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;

  static parseInt(value: string, radix: i32 = 0): u16 {
    return <u16>strtol<i32>(value, radix);
  }

  toString(this: u16, radix: i32 = 10): String {
    return utoa32(this, radix);
  }
}

@final @unmanaged
export abstract class U32 {

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;

  static parseInt(value: string, radix: i32 = 0): u32 {
    return <u32>strtol<i32>(value, radix);
  }

  toString(this: u32, radix: i32 = 10): String {
    return utoa32(this, radix);
  }
}

@final @unmanaged
export abstract class U64 {

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;

  static parseInt(value: string, radix: i32 = 0): u64 {
    return <u64>strtol<i64>(value, radix);
  }

  toString(this: u64, radix: i32 = 10): String {
    return utoa64(this, radix);
  }
}

@final @unmanaged
export abstract class Usize {

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: usize = usize.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: usize = usize.MAX_VALUE;

  static parseInt(value: string, radix: i32 = 0): usize {
    return <usize>strtol<i64>(value, radix);
  }

  toString(this: usize, radix: i32 = 10): String {
    if (sizeof<usize>() == 4) {
      return utoa32(<u32>this, radix);
    } else {
      return utoa64(<u64>this, radix);
    }
  }
}

@final @unmanaged
export abstract class Bool {

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: bool = bool.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: bool = bool.MAX_VALUE;

  toString(this: bool, radix: i32 = 0): String {
    return this ? "true" : "false";
  }
}

export { Bool as Boolean };

@final @unmanaged
export abstract class F32 {

  // @ts-ignore: decorator
  @lazy
  static readonly EPSILON: f32 = f32.EPSILON;

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;

  // @ts-ignore: decorator
  @lazy
  static readonly POSITIVE_INFINITY: f32 = f32.POSITIVE_INFINITY;

  // @ts-ignore: decorator
  @lazy
  static readonly NEGATIVE_INFINITY: f32 = f32.NEGATIVE_INFINITY;

  // @ts-ignore: decorator
  @lazy
  static readonly NaN: f32 = f32.NaN;

  static isNaN(value: f32): bool {
    return isNaN<f32>(value);
  }

  static isFinite(value: f32): bool {
    return isFinite<f32>(value);
  }

  static isSafeInteger(value: f32): bool {
    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;
  }

  static isInteger(value: f32): bool {
    return isFinite<f32>(value) && trunc<f32>(value) == value;
  }

  static parseInt(value: string, radix: i32 = 0): f32 {
    return <f32>strtol<f64>(value, radix);
  }

  static parseFloat(value: string): f32 {
    return <f32>parseFloat(value);
  }

  toString(this: f32, radix: i32 = 0): String {
    return dtoa(this);
  }
}

@final @unmanaged
export abstract class F64 {

  // @ts-ignore: decorator
  @lazy
  static readonly EPSILON: f64 = f64.EPSILON;

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;

  // @ts-ignore: decorator
  @lazy
  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;

  // @ts-ignore: decorator
  @lazy
  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;

  // @ts-ignore: decorator
  @lazy
  static readonly POSITIVE_INFINITY: f64 = f64.POSITIVE_INFINITY;

  // @ts-ignore: decorator
  @lazy
  static readonly NEGATIVE_INFINITY: f64 = f64.NEGATIVE_INFINITY;

  // @ts-ignore: decorator
  @lazy
  static readonly NaN: f64 = f64.NaN;

  static isNaN(value: f64): bool {
    return isNaN<f64>(value);
  }

  static isFinite(value: f64): bool {
    return isFinite<f64>(value);
  }

  static isSafeInteger(value: f64): bool {
    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;
  }

  static isInteger(value: f64): bool {
    return isFinite<f64>(value) && trunc<f64>(value) == value;
  }

  static parseInt(value: string, radix: i32 = 0): f64 {
    return strtol<f64>(value, radix);
  }

  static parseFloat(value: string): f64 {
    return parseFloat(value);
  }

  toString(this: f64, radix: i32 = 0): String {
    return dtoa(this);
  }
}

export { F64 as Number };

'''
'''--- std/assembly/object.ts ---
export class Object {
  static is<T>(value1: T, value2: T): bool {
    if (isFloat<T>()) {
      if (value1 == value2) {
        // 0 === -0, but they are not identical
        if (sizeof<T>() == 8) {
          // @ts-ignore: typecast
          return reinterpret<u64>(value1) == reinterpret<u64>(value2);
        } else {
          // @ts-ignore: typecast
          return reinterpret<u32>(value1) == reinterpret<u32>(value2);
        }
      }
      // NaN !== NaN, but they are identical.
      // @ts-ignore: typecast
      return bool(i32(isNaN(value1)) & i32(isNaN(value2)));
    }
    // For references, strings, integers and booleans
    return value1 == value2;
  }
}

'''
'''--- std/assembly/polyfills.ts ---
export function bswap<T extends number>(value: T): T {
  if (isInteger<T>()) {
    if (sizeof<T>() == 2) {
      return <T>((value << 8) | ((value >>> 8) & <T>0x00FF));
    }
    if (sizeof<T>() == 4) {
      return <T>(
        rotl<u32>(value & 0xFF00FF00, 8) |
        rotr<u32>(value & 0x00FF00FF, 8)
      );
    }
    if (sizeof<T>() == 8) {
      let a = (<u64>value >> 8) & 0x00FF00FF00FF00FF;
      let b = (<u64>value & 0x00FF00FF00FF00FF) << 8;
      let v = a | b;

      a = (v >> 16) & 0x0000FFFF0000FFFF;
      b = (v & 0x0000FFFF0000FFFF) << 16;

      return <T>rotr<u64>(a | b, 32);
    }
    return value;
  }
  assert(false);
  return value;
}

export function bswap16<T extends number>(value: T): T {
  if (isInteger<T>() && sizeof<T>() <= 4) {
    if (sizeof<T>() == 2) {
      return <T>((value << 8) | ((value >>> 8) & <T>0x00FF));
    } else if (sizeof<T>() == 4) {
      return <T>(((value << 8) & <T>0xFF00) | ((value >>> 8) & <T>0x00FF) | (value & <T>0xFFFF0000));
    }
    return value;
  }
  assert(false);
  return value;
}

'''
'''--- std/assembly/process.ts ---
import {
  args_get,
  args_sizes_get,
  environ_get,
  environ_sizes_get,
  proc_exit,
  fd_write,
  fd_close,
  fd_read,
  clock_time_get,
  clockid,
  errnoToString,
  fd
} from "bindings/wasi_snapshot_preview1";

import {
  E_INDEXOUTOFRANGE
} from "util/error";

// @ts-ignore: decorator
@lazy const iobuf = memory.data(4 * sizeof<usize>());

export namespace process {

  // @ts-ignore: decorator
  @lazy export const arch = sizeof<usize>() == 4 ? "wasm32" : "wasm64";

  // @ts-ignore: decorator
  @lazy export const platform = "wasm";

  // @ts-ignore: decorator
  @lazy export const argv = lazyArgv();

  // @ts-ignore: decorator
  @lazy export const env = lazyEnv();

  // @ts-ignore: decorator
  @lazy export var exitCode = 0;

  export function exit(code: i32 = exitCode): void {
    proc_exit(code);
  }

  // @ts-ignore: decorator
  @lazy export const stdin = changetype<ReadableStream>(0);
  // @ts-ignore: decorator
  @lazy export const stdout = changetype<WritableStream>(1);
  // @ts-ignore: decorator
  @lazy export const stderr = changetype<WritableStream>(2);

  export function time(): i64 {
    var err = clock_time_get(clockid.REALTIME, 1000000, iobuf);
    if (err) throw new Error(errnoToString(err));
    return load<u64>(iobuf) / 1000000;
  }

  export function hrtime(): u64 {
    var err = clock_time_get(clockid.MONOTONIC, 0, iobuf);
    if (err) throw new Error(errnoToString(err));
    return load<u64>(iobuf);
  }
}

function lazyArgv(): string[] {
  var err = args_sizes_get(iobuf, iobuf + sizeof<usize>());
  if (err) throw new Error(errnoToString(err));
  var count = load<usize>(iobuf);
  var ptrsSize = count * sizeof<usize>();
  var dataSize = load<usize>(iobuf, sizeof<usize>());
  var bufSize = ptrsSize + dataSize;
  var buf = __alloc(bufSize);
  err = args_get(buf, buf + ptrsSize);
  if (err) throw new Error(errnoToString(err));
  var count32 = <i32>count;
  var argv = new Array<string>(count32);
  for (let i = 0; i < count32; ++i) {
    let ptr = load<usize>(buf + i * sizeof<usize>());
    let str = String.UTF8.decodeUnsafe(ptr, ptr + bufSize - buf, true);
    argv[i] = str;
  }
  __free(buf);
  return argv;
}

function lazyEnv(): Map<string,string> {
  var err = environ_sizes_get(iobuf, iobuf + 4);
  if (err) throw new Error(errnoToString(err));
  var count = load<usize>(iobuf);
  var ptrsSize = count * sizeof<usize>();
  var dataSize = load<usize>(iobuf, sizeof<usize>());
  var bufSize = ptrsSize + dataSize;
  var buf = __alloc(bufSize);
  err = environ_get(buf, buf + ptrsSize);
  if (err) throw new Error(errnoToString(err));
  var env = new Map<string,string>();
  for (let i: usize = 0; i < count; ++i) {
    let ptr = load<usize>(buf + i * sizeof<usize>());
    let str = String.UTF8.decodeUnsafe(ptr, ptr + bufSize - buf, true);
    let pos = str.indexOf("=");
    if (~pos) {
      env.set(str.substring(0, pos), str.substring(pos + 1));
      // __dispose(changetype<usize>(str));
    } else {
      env.set(str, "");
    }
  }
  __free(buf);
  return env;
}

@unmanaged
abstract class Stream {
  close(): void {
    var err = fd_close(<u32>changetype<usize>(this));
    if (err) throw new Error(errnoToString(err));
  }
}

@unmanaged
abstract class WritableStream extends Stream {
  write<T>(data: T): void {
    if (isString<T>()) {
      writeString(<u32>changetype<usize>(this), changetype<string>(data));
    } else if (data instanceof ArrayBuffer) {
      writeBuffer(<u32>changetype<usize>(this), data);
    } else {
      ERROR("String or ArrayBuffer expected");
    }
  }
}

@unmanaged
abstract class ReadableStream extends Stream {
  read(buffer: ArrayBuffer, offset: isize = 0): i32 {
    var end = <usize>buffer.byteLength;
    if (offset < 0 || <usize>offset > end) {
      throw new Error(E_INDEXOUTOFRANGE);
    }
    store<usize>(iobuf, changetype<usize>(buffer) + offset);
    store<usize>(iobuf, end - offset, sizeof<usize>());
    var err = fd_read(<u32>changetype<usize>(this), iobuf, 1, iobuf + 2 * sizeof<usize>());
    if (err) throw new Error(errnoToString(err));
    return <i32>load<isize>(iobuf, 2 * sizeof<usize>());
  }
}

function writeBuffer(fd: fd, data: ArrayBuffer): void {
  store<usize>(iobuf, changetype<usize>(data));
  store<usize>(iobuf, data.byteLength, sizeof<usize>());
  var err = fd_write(<u32>fd, iobuf, 1, iobuf + 2 * sizeof<usize>());
  if (err) throw new Error(errnoToString(err));
}

function writeString(fd: fd, data: string): void {
  var char2 = -1;
  var char3 = -1;
  var char4 = -1;
  switch (data.length) {
    case 4: { // "null"
      char4 = <i32>load<u16>(changetype<usize>(data), 6);
      if (char4 >= 0x80) break;
    }
    case 3: { // "ms\n"
      char3 = <i32>load<u16>(changetype<usize>(data), 4);
      if (char3 >= 0x80) break;
    }
    case 2: { // "\r\n"
      char2 = <i32>load<u16>(changetype<usize>(data), 2);
      if (char2 >= 0x80) break;
    }
    case 1: { // "\n"
      let char1 = <i32>load<u16>(changetype<usize>(data));
      if (char1 >= 0x80) break;
      store<usize>(iobuf, iobuf + 2 * sizeof<usize>());
      store<usize>(iobuf, <i32>1 + i32(char2 != -1) + i32(char3 != -1) + i32(char4 != -1), sizeof<usize>());
      store<u32>(iobuf, char1 | char2 << 8 | char3 << 16 | char4 << 24, 2 * sizeof<usize>());
      let err = fd_write(<u32>fd, iobuf, 1, iobuf + 3 * sizeof<usize>());
      if (err) throw new Error(errnoToString(err));
    }
    case 0: return;
  }
  var utf8len = <usize>String.UTF8.byteLength(data);
  var utf8buf = __alloc(utf8len);
  assert(String.UTF8.encodeUnsafe(changetype<usize>(data), data.length, utf8buf) == utf8len);
  store<usize>(iobuf, utf8buf);
  store<usize>(iobuf, utf8len, sizeof<usize>());
  var err = fd_write(<u32>fd, iobuf, 1, iobuf + 2 * sizeof<usize>());
  __free(utf8buf);
  if (err) throw new Error(errnoToString(err));
}

'''
'''--- std/assembly/reference.ts ---
@unmanaged
abstract class Ref {
}

@final @unmanaged
export abstract class Funcref extends Ref {
}

@final @unmanaged
export abstract class Externref extends Ref {
}

@final @unmanaged
export abstract class Anyref extends Ref {
}

@final @unmanaged
export abstract class Eqref extends Ref {
}

@final @unmanaged
export abstract class I31ref extends Ref {
}

@final @unmanaged
export abstract class Dataref extends Ref {
}

'''
'''--- std/assembly/regexp.ts ---
export class RegExp {

  // @binding(CALL_NEW, [ STRING, STRING], OBJECT_HANDLE)
  constructor(pattern: string, flags: string = "") { throw new Error("unreachable"); }

  // @binding(CALL_THIS, [ STRING ], PASS_THRU)
  test(search: string): bool { throw new Error("unreachable"); }

  // @binding(CALL_THIS, [], STRING)
  toString(): string { throw new Error("unreachable"); }

}

'''
'''--- std/assembly/rt.ts ---
import { Typeinfo, TypeinfoFlags } from "./shared/typeinfo";
import { E_INDEXOUTOFRANGE } from "./util/error";
import { OBJECT, TOTAL_OVERHEAD } from "./rt/common";
import { ArrayBufferView } from "./arraybuffer";

// @ts-ignore: decorator
@builtin
export declare const __rtti_base: usize;

// @ts-ignore: decorator
@builtin @unsafe
export declare function __visit_globals(cookie: u32): void;

// @ts-ignore: decorator
@builtin @unsafe
export declare function __visit_members(ref: usize, cookie: u32): void;

// @ts-ignore: decorator
@unsafe
export function __typeinfo(id: u32): TypeinfoFlags {
  var ptr = __rtti_base;
  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);
  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;
}

// @ts-ignore: decorator
@unsafe
export function __instanceof(ptr: usize, classId: u32): bool { // keyword
  var id = changetype<OBJECT>(ptr - TOTAL_OVERHEAD).rtId;
  var rttiBase = __rtti_base;
  if (id <= load<u32>(rttiBase)) {
    do if (id == classId) return true;
    while (id = changetype<Typeinfo>(rttiBase + sizeof<u32>() + id * offsetof<Typeinfo>()).base);
  }
  return false;
}

// @ts-ignore: decorator
@unsafe
export function __newBuffer(size: usize, id: u32, data: usize = 0): usize {
  var buffer = __new(size, id);
  if (data) memory.copy(buffer, data, size);
  return buffer;
}

// @ts-ignore: decorator
@unsafe
export function __newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {
  var bufferSize = <usize>length << alignLog2;
  // make sure `buffer` is tracked by the shadow stack
  var buffer = changetype<ArrayBuffer>(__newBuffer(bufferSize, idof<ArrayBuffer>(), data));
  // ...since allocating the array may trigger GC steps
  var array = __new(offsetof<i32[]>(), id);
  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>("buffer"));
  __link(array, changetype<usize>(buffer), false);
  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>("dataStart"));
  store<i32>(array, bufferSize, offsetof<ArrayBufferView>("byteLength"));
  store<i32>(array, length, offsetof<i32[]>("length_"));
  return array;
}

// @ts-ignore: decorator
@global @unsafe
function __tostack(ptr: usize): usize { // eslint-disable-line
  return ptr;
}

// These are provided by the respective implementation, included as another entry file by asc:

// // @ts-ignore: decorator
// @builtin @unsafe
// export declare function __alloc(size: usize): usize;

// // @ts-ignore: decorator
// @builtin @unsafe
// export declare function __realloc(ptr: usize, size: usize): usize;

// // @ts-ignore: decorator
// @builtin @unsafe
// export declare function __free(ptr: usize): void;

// // @ts-ignore: decorator
// @builtin @unsafe
// export declare function __new(size: usize, id: u32): usize;

// // @ts-ignore: decorator
// @builtin @unsafe
// export declare function __renew(ptr: usize, size: usize): usize;

// // @ts-ignore: decorator
// @builtin @unsafe
// export declare function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void;

// // @ts-ignore: decorator
// @builtin @unsafe
// export declare function __collect(): void;

// // @ts-ignore: decorator
// @builtin @unsafe
// export declare function __visit(ptr: usize, cookie: u32): void;

'''
'''--- std/assembly/rt/README.md ---
The AssemblyScript Runtime
==========================

The runtime provides the functionality necessary to dynamically allocate and deallocate memory of objects, arrays and buffers, as well as collect garbage that is no longer used. The current implementation is either a Two-Color Mark & Sweep (TCMS) garbage collector that must be called manually when the execution stack is unwound or an Incremental Tri-Color Mark & Sweep (ITCMS) garbage collector that is fully automated with a shadow stack, implemented on top of a Two-Level Segregate Fit (TLSF) memory manager. It's not designed to be the fastest of its kind, but intentionally focuses on simplicity and ease of integration until we can replace it with the real deal, i.e. Wasm GC.

Interface
---------

### Garbage collector / `--exportRuntime`

* **__new**(size: `usize`, id: `u32` = 0): `usize`<br />
  Dynamically allocates a GC object of at least the specified size and returns its address.
  Alignment is guaranteed to be 16 bytes to fit up to v128 values naturally.
  GC-allocated objects cannot be used with `__realloc` and `__free`.

* **__pin**(ptr: `usize`): `usize`<br />
  Pins the object pointed to by `ptr` externally so it and its directly reachable members and indirectly reachable objects do not become garbage collected.

* **__unpin**(ptr: `usize`): `void`<br />
  Unpins the object pointed to by `ptr` externally so it can become garbage collected.

* **__collect**(): `void`<br />
  Performs a full garbage collection.

### Internals

* **__alloc**(size: `usize`): `usize`<br />
  Dynamically allocates a chunk of memory of at least the specified size and returns its address.
  Alignment is guaranteed to be 16 bytes to fit up to v128 values naturally.

* **__realloc**(ptr: `usize`, size: `usize`): `usize`<br />
  Dynamically changes the size of a chunk of memory, possibly moving it to a new address.

* **__free**(ptr: `usize`): `void`<br />
  Frees a dynamically allocated chunk of memory by its address.

* **__renew**(ptr: `usize`, size: `usize`): `usize`<br />
  Like `__realloc`, but for `__new`ed GC objects.

* **__link**(parentPtr: `usize`, childPtr: `usize`, expectMultiple: `bool`): `void`<br />
  Introduces a link from a parent object to a child object, i.e. upon `parent.field = child`.

* **__visit**(ptr: `usize`, cookie: `u32`): `void`<br />
  Concrete visitor implementation called during traversal. Cookie can be used to indicate one of multiple operations.

* **__visit_globals**(cookie: `u32`): `void`<br />
  Calls `__visit` on each global that is of a managed type.

* **__visit_members**(ptr: `usize`, cookie: `u32`): `void`<br />
  Calls `__visit` on each member of the object pointed to by `ptr`.

* **__typeinfo**(id: `u32`): `RTTIFlags`<br />
  Obtains the runtime type information for objects with the specified runtime id. Runtime type information is a set of flags indicating whether a type is managed, an array or similar, and what the relevant alignments when creating an instance externally are etc.

* **__instanceof**(ptr: `usize`, classId: `u32`): `bool`<br />
  Tests if the object pointed to by `ptr` is an instance of the specified class id.

ITCMS / `--runtime incremental`
-----

The Incremental Tri-Color Mark & Sweep garbage collector maintains a separate shadow stack of managed values in the background to achieve full automation. Maintaining another stack introduces some overhead compared to the simpler Two-Color Mark & Sweep garbage collector, but makes it independent of whether the execution stack is unwound or not when it is invoked, so the garbage collector can run interleaved with the program.

There are several constants one can experiment with to tweak ITCMS's automation:

* `--use ASC_GC_GRANULARITY=1024`<br />
  How often to interrupt. The default of 1024 means "interrupt each 1024 bytes allocated".
* `--use ASC_GC_STEPFACTOR=200`<br />
  How long to interrupt. The default of 200% means "run at double the speed of allocations".
* `--use ASC_GC_IDLEFACTOR=200`<br />
  How long to idle. The default of 200% means "wait for memory to double before kicking in again".
* `--use ASC_GC_MARKCOST=1`<br />
  How costly it is to mark one object. Budget per interrupt is `GRANULARITY * STEPFACTOR / 100`.
* `--use ASC_GC_SWEEPCOST=10`<br />
  How costly it is to sweep one object. Budget per interrupt is `GRANULARITY * STEPFACTOR / 100`.

TCMS / `--runtime minimal`
----

If automation and low pause times aren't strictly necessary, using the Two-Color Mark & Sweep garbage collector instead by invoking collection manually at appropriate times when the execution stack is unwound may be more performant as it simpler and has less overhead. The execution stack is typically unwound when invoking the collector externally, at a place that is not indirectly called from Wasm.

STUB / `--runtime stub`
----

The stub is a maximally minimal runtime substitute, consisting of a simple and fast bump allocator with no means of freeing up memory again, except when freeing the respective most recently allocated object on top of the bump. Useful where memory is not a concern, and/or where it is sufficient to destroy the whole module including any potential garbage after execution.

See also: [Garbage collection](https://www.assemblyscript.org/garbage-collection.html)

'''
'''--- std/assembly/rt/common.ts ---
// Alignment guarantees

// @ts-ignore: decorator
@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128
// @ts-ignore: decorator
@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;
// @ts-ignore: decorator
@inline export const AL_MASK: usize = AL_SIZE - 1;

// Extra debugging

// @ts-ignore: decorator
@inline export const DEBUG = true;
// @ts-ignore: decorator
@inline export const TRACE = false;
// @ts-ignore: decorator
@inline export const RTRACE = isDefined(ASC_RTRACE);
// @ts-ignore: decorator
@inline export const PROFILE = isDefined(ASC_PROFILE);

// Memory manager

// â•’â•â•â•â•â•â•â•â•â•â•â•â• Memory manager block layout (32-bit) â•â•â•â•â•â•â•â•â•â•â•â•â•â••
//    3                   2                   1
//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits
// â”œâ”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”¤
// â”‚                           MM info                             â”‚ -4
// â•ž>ptrâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡
// â”‚                              ...                              â”‚
@unmanaged export class BLOCK {
  /** Memory manager info. */
  mmInfo: usize;
}

/** Overhead of a memory manager block. */
// @ts-ignore: decorator
@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();

/** Maximum size of a memory manager block's payload. */
// @ts-ignore: decorator
@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;

// Garbage collector

// â•’â•â•â•â•â•â•â•â•â•â• Garbage collector object layout (32-bit) â•â•â•â•â•â•â•â•â•â•â•â••
//    3                   2                   1
//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits
// â”œâ”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”¤
// â”‚                     Memory manager block                      â”‚ -20
// â•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡
// â”‚                            GC info                            â”‚ -16
// â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
// â”‚                            GC info                            â”‚ -12
// â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
// â”‚                            RT id                              â”‚ -8
// â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
// â”‚                            RT size                            â”‚ -4
// â•ž>ptrâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡
// â”‚                              ...                              â”‚
@unmanaged export class OBJECT extends BLOCK {
  /** Garbage collector info. */
  gcInfo: u32;
  /** Garbage collector info. */
  gcInfo2: u32;
  /** Runtime class id. */
  rtId: u32;
  /** Runtime object size. */
  rtSize: u32;
}

/** Overhead of a garbage collector object. Excludes memory manager block overhead. */
// @ts-ignore: decorator
@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;

/** Maximum size of a garbage collector object's payload. */
// @ts-ignore: decorator
@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;

/** Total of memory manager and garbage collector overhead. */
// @ts-ignore: decorator
@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;

'''
'''--- std/assembly/rt/index-incremental.ts ---
import "rt/tlsf";
import "rt/itcms";

'''
'''--- std/assembly/rt/index-minimal.ts ---
import "rt/tlsf";
import "rt/tcms";

'''
'''--- std/assembly/rt/index-stub.ts ---
import "rt/stub";

'''
'''--- std/assembly/rt/index.d.ts ---
// Memory manager
declare function __alloc(size: usize): usize;
declare function __realloc(ptr: usize, size: usize): usize;
declare function __free(ptr: usize): void;
declare function __reset(): void;

// Garbage collector
declare function __new(size: usize, id: u32): usize;
declare function __renew(ptr: usize, size: usize): usize;
declare function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void;
declare function __collect(): void;

// Runtime type info
declare function __typeinfo(id: u32): u32;
declare function __instanceof(ptr: usize, superId: u32): bool;

// Visitors
declare function __visit(ptr: usize, cookie: i32): void;
declare function __visit_globals(cookie: u32): void;
declare function __visit_members(ptr: usize, cookie: u32): void;

// Allocation helpers
declare function __newBuffer(size: usize, id: u32, data?: usize): usize;
declare function __newArray(length: i32, alignLog2: usize, id: u32, data?: usize): usize;

// Finalization
declare function __finalize(ptr: usize): void;

// Debugging
declare const ASC_RTRACE: bool;
declare const ASC_PROFILE: bool;

// Incremental GC constants
declare const ASC_GC_GRANULARITY: i32;
declare const ASC_GC_SWEEPFACTOR: i32;
declare const ASC_GC_IDLEFACTOR: i32;
declare const ASC_GC_MARKCOST: i32;
declare const ASC_GC_SWEEPCOST: i32;

'''
'''--- std/assembly/rt/itcms.ts ---
import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE, PROFILE } from "./common";
import { onvisit, oncollect, oninterrupt, onyield } from "./rtrace";
import { TypeinfoFlags } from "../shared/typeinfo";
import { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from "../util/error";

// === ITCMS: An incremental Tri-Color Mark & Sweep garbage collector ===
// Adapted from Bach Le's Î¼gc, see: https://github.com/bullno1/ugc

// â•’â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•â•â• Colors â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â••
// â”‚ Color       â”‚ Meaning                                         â”‚
// â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
// â”‚ WHITE*      â”‚ Unprocessed                                     â”‚
// â”‚ BLACK*      â”‚ Processed                                       â”‚
// â”‚ GRAY        â”‚ Processed with unprocessed children             â”‚
// â”‚ TRANSPARENT â”‚ Manually pinned (always reachable)              â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
// * flipped between cycles

// @ts-ignore: decorator
@lazy var white = 0;
// @ts-ignore: decorator
@inline const gray = 2;
// @ts-ignore: decorator
@inline const transparent = 3;
// @ts-ignore: decorator
@inline const COLOR_MASK = 3;

/** Size in memory of all objects currently managed by the GC. */
// @ts-ignore: decorator
@lazy var total: usize = 0;

/** Currently transitioning from SWEEP to MARK state. */
// @ts-ignore: decorator
@inline const STATE_IDLE = 0;
/** Currently marking reachable objects. */
// @ts-ignore: decorator
@inline const STATE_MARK = 1;
/** Currently sweeping unreachable objects. */
// @ts-ignore: decorator
@inline const STATE_SWEEP = 2;
/** Current collector state. */
// @ts-ignore: decorator
@lazy var state = STATE_IDLE;

// @ts-ignore: decorator
@lazy var fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));
// @ts-ignore: decorator
@lazy var toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));
// @ts-ignore: decorator
@lazy var pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));
// @ts-ignore: decorator
@lazy var iter: Object; // null

function initLazy(space: Object): Object {
  space.nextWithColor = changetype<usize>(space);
  space.prev = space;
  return space;
}

/** Visit cookie indicating scanning of an object. */
// @ts-ignore: decorator
@inline const VISIT_SCAN = 0;

// â•’â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Managed object layout (32-bit) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â••
//    3                   2                   1
//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits
// â”œâ”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”¤
// â”‚                      Memory manager block                     â”‚
// â•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•¡
// â”‚                              next                         â”‚ C â”‚ = nextWithColor
// â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”¤
// â”‚                              prev                             â”‚
// â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
// â”‚                              rtId                             â”‚
// â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
// â”‚                              rtSize                           â”‚
// â•ž>ptrâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡
// â”‚                               ...                             â”‚
// C: color

/** Represents a managed object in memory, consisting of a header followed by the object's data. */
@unmanaged class Object extends BLOCK {
  /** Pointer to the next object with color flags stored in the alignment bits. */
  nextWithColor: usize; // *u32
  /** Pointer to the previous object. */
  prev: Object; // *u32
  /** Runtime id. */
  rtId: u32;
  /** Runtime size. */
  rtSize: u32;

  /** Gets the pointer to the next object. */
  get next(): Object {
    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);
  }

  /** Sets the pointer to the next object. */
  set next(obj: Object) {
    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);
  }

  /** Gets this object's color. */
  get color(): i32 {
    return i32(this.nextWithColor & COLOR_MASK);
  }

  /** Sets this object's color. */
  set color(color: i32) {
    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;
  }

  /** Gets the size of this object in memory. */
  get size(): usize {
    return BLOCK_OVERHEAD + (this.mmInfo & ~3);
  }

  /** Tests if this object is pointerfree. */
  get isPointerfree(): bool {
    var rtId = this.rtId;
    return rtId <= idof<string>() || (__typeinfo(rtId) & TypeinfoFlags.POINTERFREE) != 0;
  }

  /** Unlinks this object from its list. */
  unlink(): void {
    var next = this.next;
    if (next == null) {
      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);
      return; // static data not yet linked
    }
    var prev = this.prev;
    if (DEBUG) assert(prev);
    next.prev = prev;
    prev.next = next;
  }

  /** Links this object to the specified list, with the given color. */
  linkTo(list: Object, withColor: i32): void {
    let prev = list.prev;
    this.nextWithColor = changetype<usize>(list) | withColor;
    this.prev = prev;
    prev.next = this;
    list.prev = this;
  }

  /** Marks this object as gray, that is reachable with unscanned children. */
  makeGray(): void {
    if (this == iter) iter = assert(this.prev);
    this.unlink();
    this.linkTo(toSpace, this.isPointerfree ? i32(!white) : gray);
  }
}

/** Visits all objects considered to be program roots. */
function visitRoots(cookie: u32): void {
  __visit_globals(cookie);
  var pn = pinSpace;
  var iter = pn.next;
  while (iter != pn) {
    if (DEBUG) assert(iter.color == transparent);
    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, cookie);
    iter = iter.next;
  }
}

/** Visits all objects on the stack. */
function visitStack(cookie: u32): void {
  var ptr = __stack_pointer;
  while (ptr < __heap_base) {
    __visit(load<usize>(ptr), cookie);
    ptr += sizeof<usize>();
  }
}

/** Performs a single step according to the current state. */
function step(): usize {
  // Magic constants responsible for pause times. Obtained experimentally
  // using the compiler compiling itself. 2048 budget pro run by default.
  const MARKCOST = isDefined(ASC_GC_MARKCOST) ? ASC_GC_MARKCOST : 1;
  const SWEEPCOST = isDefined(ASC_GC_SWEEPCOST) ? ASC_GC_SWEEPCOST : 10;
  var obj: Object;
  switch (state) {
    case STATE_IDLE: {
      state = STATE_MARK;
      visitCount = 0;
      visitRoots(VISIT_SCAN);
      iter = toSpace;
      return visitCount * MARKCOST;
    }
    case STATE_MARK: {
      let black = i32(!white);
      obj = iter.next;
      while (obj != toSpace) {
        iter = obj;
        if (obj.color != black) { // skip already-blacks (pointerfree)
          obj.color = black;
          visitCount = 0;
          __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);
          return visitCount * MARKCOST;
        }
        obj = obj.next;
      }
      visitCount = 0;
      visitRoots(VISIT_SCAN);
      obj = iter.next;
      if (obj == toSpace) {
        visitStack(VISIT_SCAN);
        obj = iter.next;
        while (obj != toSpace) {
          if (obj.color != black) {
            obj.color = black;
            __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);
          }
          obj = obj.next;
        }
        let from = fromSpace;
        fromSpace = toSpace;
        toSpace = from;
        white = black;
        iter = from.next;
        state = STATE_SWEEP;
      }
      return visitCount * MARKCOST;
    }
    case STATE_SWEEP: {
      obj = iter;
      if (obj != toSpace) {
        iter = obj.next;
        if (DEBUG) assert(obj.color == i32(!white)); // old white
        free(obj);
        return SWEEPCOST;
      }
      toSpace.nextWithColor = changetype<usize>(toSpace);
      toSpace.prev = toSpace;
      state = STATE_IDLE;
      break;
    }
  }
  return 0;
}

/** Frees an object. */
function free(obj: Object): void {
  if (changetype<usize>(obj) < __heap_base) {
    obj.nextWithColor = 0; // may become linked again
    obj.prev = changetype<Object>(0);
  } else {
    total -= obj.size;
    if (isDefined(__finalize)) {
      __finalize(changetype<usize>(obj) + TOTAL_OVERHEAD);
    }
    __free(changetype<usize>(obj) + BLOCK_OVERHEAD);
  }
}

// Garbage collector interface

// @ts-ignore: decorator
@global @unsafe
export function __new(size: usize, id: i32): usize {
  if (size >= OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);
  if (total >= threshold) interrupt();
  var obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);
  obj.rtId = id;
  obj.rtSize = <u32>size;
  obj.linkTo(fromSpace, white); // inits next/prev
  total += obj.size;
  var ptr = changetype<usize>(obj) + TOTAL_OVERHEAD;
  // may be visited before being fully initialized, so must fill
  memory.fill(ptr, 0, size);
  return ptr;
}

// @ts-ignore: decorator
@global @unsafe
export function __renew(oldPtr: usize, size: usize): usize {
  var oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);
  // Update object size if its block is large enough
  if (size <= (oldObj.mmInfo & ~3) - OBJECT_OVERHEAD) {
    oldObj.rtSize = <u32>size;
    return oldPtr;
  }
  // If not the same object anymore, we have to move it move it due to the
  // shadow stack potentially still referencing the old object
  var newPtr = __new(size, oldObj.rtId);
  memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));
  return newPtr;
}

// @ts-ignore: decorator
@global @unsafe
export function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {
  // Write barrier is unnecessary if non-incremental
  if (!childPtr) return;
  if (DEBUG) assert(parentPtr);
  var child = changetype<Object>(childPtr - TOTAL_OVERHEAD);
  if (child.color == white) {
    let parent = changetype<Object>(parentPtr - TOTAL_OVERHEAD);
    let parentColor = parent.color;
    if (parentColor == i32(!white)) {
      // Maintain the invariant that no black object may point to a white object.
      if (expectMultiple) {
        // Move the barrier "backward". Suitable for containers receiving multiple stores.
        // Avoids a barrier for subsequent objects stored into the same container.
        parent.makeGray();
      } else {
        // Move the barrier "forward". Suitable for objects receiving isolated stores.
        child.makeGray();
      }
    } else if (parentColor == transparent && state == STATE_MARK) {
      // Pinned objects are considered 'black' during the mark phase.
      child.makeGray();
    }
  }
}

// @ts-ignore: decorator
@lazy var visitCount = 0;

// @ts-ignore: decorator
@global @unsafe
export function __visit(ptr: usize, cookie: i32): void {
  if (!ptr) return;
  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);
  if (RTRACE) if (!onvisit(obj)) return;
  if (obj.color == white) {
    obj.makeGray();
    ++visitCount;
  }
}

// @ts-ignore: decorator
@global @unsafe
export function __pin(ptr: usize): usize {
  if (ptr) {
    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);
    if (obj.color == transparent) {
      throw new Error(E_ALREADY_PINNED);
    }
    obj.unlink(); // from fromSpace
    obj.linkTo(pinSpace, transparent);
  }
  return ptr;
}

// @ts-ignore: decorator
@global @unsafe
export function __unpin(ptr: usize): void {
  if (!ptr) return;
  var obj = changetype<Object>(ptr - TOTAL_OVERHEAD);
  if (obj.color != transparent) {
    throw new Error(E_NOT_PINNED);
  }
  if (state == STATE_MARK) {
    // We may be right at the point after marking roots for the second time and
    // entering the sweep phase, in which case the object would be missed if it
    // is not only pinned but also a root. Make sure it isn't missed.
    obj.makeGray();
  } else {
    obj.unlink();
    obj.linkTo(fromSpace, white);
  }
}

// @ts-ignore: decorator
@global @unsafe
export function __collect(): void {
  if (TRACE) trace("GC (full) at", 1, total);
  if (state > STATE_IDLE) {
    // finish current cycle
    while (state != STATE_IDLE) step();
  }
  // perform a full cycle
  step();
  while (state != STATE_IDLE) step();
  threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;
  if (TRACE) trace("GC (full) done at cur/max", 2, total, memory.size() << 16);
  if (RTRACE || PROFILE) oncollect(total);
}

// Garbage collector automation

/** How often to interrupt. The default of 1024 means "interrupt each 1024 bytes allocated". */
// @ts-ignore: decorator
@inline const GRANULARITY: usize = isDefined(ASC_GC_GRANULARITY) ? ASC_GC_GRANULARITY : 1024;
/** How long to interrupt. The default of 200% means "run at double the speed of allocations". */
// @ts-ignore: decorator
@inline const STEPFACTOR: usize = isDefined(ASC_GC_SWEEPFACTOR) ? ASC_GC_SWEEPFACTOR : 200;
/** How long to idle. The default of 200% means "wait for memory to double before kicking in again". */
// @ts-ignore: decorator
@inline const IDLEFACTOR: usize = isDefined(ASC_GC_IDLEFACTOR) ? ASC_GC_IDLEFACTOR : 200;

/** Threshold of memory used by objects to exceed before interrupting again. */
// @ts-ignore: decorator
@lazy var threshold: usize = ((<usize>memory.size() << 16) - __heap_base) >> 1;

/** Performs a reasonable amount of incremental GC steps. */
function interrupt(): void {
  if (PROFILE) oninterrupt(total);
  if (TRACE) trace("GC (auto) at", 1, total);
  var budget: isize = GRANULARITY * STEPFACTOR / 100;
  do {
    budget -= step();
    if (state == STATE_IDLE) {
      if (TRACE) trace("â”” GC (auto) done at cur/max", 2, total, memory.size() << 16);
      threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;
      if (PROFILE) onyield(total);
      return;
    }
  } while (budget > 0);
  if (TRACE) trace("â”” GC (auto) ongoing at", 1, total);
  threshold = total + GRANULARITY * usize(total - threshold < GRANULARITY);
  if (PROFILE) onyield(total);
}

'''
'''--- std/assembly/rt/rtrace.ts ---
import { BLOCK } from "./common";

export declare function oninit(heapBase: usize): void;

// Memory Allocator
export declare function onalloc(block: BLOCK): void;
export declare function onresize(block: BLOCK, oldSizeInclOverhead: usize): void;
export declare function onmove(oldBlock: BLOCK, newBlock: BLOCK): void;
export declare function onfree(block: BLOCK): void;

// Garbage collector
export declare function onvisit(block: BLOCK): bool;
export declare function oncollect(total: usize): void;
export declare function oninterrupt(total: usize): void;
export declare function onyield(total: usize): void;

'''
'''--- std/assembly/rt/stub.ts ---
import { AL_MASK, OBJECT, OBJECT_OVERHEAD, BLOCK_MAXSIZE, BLOCK_OVERHEAD, BLOCK, OBJECT_MAXSIZE } from "./common";
import { E_ALLOCATION_TOO_LARGE } from "../util/error";

// === A minimal runtime stub ===

// @ts-ignore: decorator
@lazy var startOffset: usize = ((__heap_base + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;
// @ts-ignore: decorator
@lazy var offset: usize = startOffset;

function maybeGrowMemory(newOffset: usize): void {
  // assumes newOffset is aligned
  var pagesBefore = memory.size();
  var maxOffset = ((<usize>pagesBefore << 16) + AL_MASK) & ~AL_MASK;
  if (newOffset > maxOffset) {
    let pagesNeeded = <i32>(((newOffset - maxOffset + 0xffff) & ~0xffff) >>> 16);
    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory
    if (memory.grow(pagesWanted) < 0) {
      if (memory.grow(pagesNeeded) < 0) unreachable(); // out of memory
    }
  }
  offset = newOffset;
}

// @ts-ignore: decorator
@inline function computeSize(size: usize): usize {
  return ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;
}

// @ts-ignore: decorator
@unsafe @global
export function __alloc(size: usize): usize {
  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);
  var block = changetype<BLOCK>(offset);
  var ptr = offset + BLOCK_OVERHEAD;
  var payloadSize = computeSize(size);
  maybeGrowMemory(ptr + payloadSize);
  block.mmInfo = payloadSize;
  return ptr;
}

// @ts-ignore: decorator
@unsafe @global
export function __realloc(ptr: usize, size: usize): usize {
  assert(ptr != 0 && !(ptr & AL_MASK)); // must exist and be aligned
  var block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);
  var actualSize = block.mmInfo;
  var isLast = ptr + actualSize == offset;
  var payloadSize = computeSize(size);
  if (size > actualSize) {
    if (isLast) { // last block: grow
      if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);
      maybeGrowMemory(ptr + payloadSize);
      block.mmInfo = payloadSize;
    } else { // copy to new block at least double the size
      let newPtr = __alloc(max<usize>(payloadSize, actualSize << 1));
      memory.copy(newPtr, ptr, actualSize);
      block = changetype<BLOCK>((ptr = newPtr) - BLOCK_OVERHEAD);
    }
  } else if (isLast) { // last block: shrink
    offset = ptr + payloadSize;
    block.mmInfo = payloadSize;
  }
  return ptr;
}

// @ts-ignore: decorator
@unsafe @global
export function __free(ptr: usize): void {
  assert(ptr != 0 && !(ptr & AL_MASK)); // must exist and be aligned
  var block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);
  if (ptr + block.mmInfo == offset) { // last block: discard
    offset = changetype<usize>(block);
  }
}

// @ts-ignore: decorator
@unsafe @global
export function __reset(): void { // special
  offset = startOffset;
}

// @ts-ignore: decorator
@unsafe @global
export function __new(size: usize, id: u32): usize {
  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);
  var ptr = __alloc(OBJECT_OVERHEAD + size);
  var object = changetype<OBJECT>(ptr - BLOCK_OVERHEAD);
  object.gcInfo = 0;
  object.gcInfo2 = 0;
  object.rtId = id;
  object.rtSize = <u32>size;
  return ptr + OBJECT_OVERHEAD;
}

// @ts-ignore: decorator
@unsafe @global
export function __renew(oldPtr: usize, size: usize): usize {
  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);
  var newPtr = __realloc(oldPtr - OBJECT_OVERHEAD, OBJECT_OVERHEAD + size);
  changetype<OBJECT>(newPtr - BLOCK_OVERHEAD).rtSize = <u32>size;
  return newPtr + OBJECT_OVERHEAD;
}

// @ts-ignore: decorator
@global @unsafe
export function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {
  // nop
}

// @ts-ignore: decorator
@global @unsafe
export function __pin(ptr: usize): usize {
  return ptr;
}

// @ts-ignore: decorator
@global @unsafe
export function __unpin(ptr: usize): void {
  // nop
}

// @ts-ignore: decorator
@global @unsafe
function __visit(ptr: usize, cookie: u32): void { // eslint-disable-line @typescript-eslint/no-unused-vars
  // nop
}

// @ts-ignore: decorator
@global @unsafe
export function __collect(): void {
  // nop
}

'''
'''--- std/assembly/rt/tcms.ts ---
import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE } from "./common";
import { onvisit, oncollect } from "./rtrace";
import { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from "../util/error";

// === TCMS: A Two-Color Mark & Sweep garbage collector ===

// â•’â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•â•â• Colors â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â••
// â”‚ Color       â”‚ Meaning                                         â”‚
// â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
// â”‚ WHITE*      â”‚ Unreachable                                     â”‚
// â”‚ BLACK*      â”‚ Reachable                                       â”‚
// â”‚ TRANSPARENT â”‚ Manually pinned (always reachable)              â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
// * flipped between cycles

// @ts-ignore: decorator
@lazy var white = 0;
// @ts-ignore: decorator
@inline const transparent = 3;
// @ts-ignore: decorator
@inline const COLOR_MASK = 3;

/** Size in memory of all objects currently managed by the GC. */
// @ts-ignore: decorator
@lazy var total: usize = 0;

// @ts-ignore: decorator
@lazy var fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));
// @ts-ignore: decorator
@lazy var toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));
// @ts-ignore: decorator
@lazy var pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));

function initLazy(space: Object): Object {
  space.nextWithColor = changetype<usize>(space);
  space.prev = space;
  return space;
}

/** Visit cookie indicating scanning of an object. */
// @ts-ignore: decorator
@inline const VISIT_SCAN = 0;

// â•’â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Managed object layout (32-bit) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â••
//    3                   2                   1
//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits
// â”œâ”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”¤
// â”‚                      Memory manager block                     â”‚
// â•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•¡
// â”‚                              next                         â”‚ C â”‚ = nextWithColor
// â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”¤
// â”‚                              prev                             â”‚
// â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
// â”‚                              rtId                             â”‚
// â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
// â”‚                              rtSize                           â”‚
// â•ž>ptrâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡
// â”‚                               ...                             â”‚
// C: color

/** Represents a managed object in memory, consisting of a header followed by the object's data. */
@unmanaged class Object extends BLOCK {
  /** Pointer to the next object with color flags stored in the alignment bits. */
  nextWithColor: usize; // *u32
  /** Pointer to the previous object. */
  prev: Object; // *u32
  /** Runtime id. */
  rtId: u32;
  /** Runtime size. */
  rtSize: u32;

  /** Gets the pointer to the next object. */
  get next(): Object {
    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);
  }

  /** Sets the pointer to the next object. */
  set next(obj: Object) {
    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);
  }

  /** Gets this object's color. */
  get color(): i32 {
    return i32(this.nextWithColor & COLOR_MASK);
  }

  /** Sets this object's color. */
  set color(color: i32) {
    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;
  }

  /** Gets the size of this object in memory. */
  get size(): usize {
    return BLOCK_OVERHEAD + (this.mmInfo & ~3);
  }

  /** Unlinks this object from its list. */
  unlink(): void {
    let next = this.next;
    if (next == null) {
      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);
      return; // static data not yet linked
    }
    let prev = this.prev;
    if (DEBUG) assert(prev);
    next.prev = prev;
    prev.next = next;
  }

  /** Links this object to the specified list, with the given color. */
  linkTo(list: Object, withColor: i32): void {
    let prev = list.prev;
    this.nextWithColor = changetype<usize>(list) | withColor;
    this.prev = prev;
    prev.next = this;
    list.prev = this;
  }
}

// Garbage collector interface

// @ts-ignore: decorator
@global @unsafe
export function __new(size: usize, id: i32): usize {
  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);
  var obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);
  obj.rtId = id;
  obj.rtSize = <u32>size;
  obj.linkTo(fromSpace, white);
  total += obj.size;
  return changetype<usize>(obj) + TOTAL_OVERHEAD;
}

// @ts-ignore: decorator
@global @unsafe
export function __renew(oldPtr: usize, size: usize): usize {
  var oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);
  if (oldPtr < __heap_base) { // move to heap for simplicity
    let newPtr = __new(size, oldObj.rtId);
    memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));
    return newPtr;
  }
  if (size > OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);
  total -= oldObj.size;
  var newPtr = __realloc(oldPtr - OBJECT_OVERHEAD, OBJECT_OVERHEAD + size) + OBJECT_OVERHEAD;
  var newObj = changetype<Object>(newPtr - TOTAL_OVERHEAD);
  newObj.rtSize = <u32>size;

  // Replace with new object
  newObj.next.prev = newObj;
  newObj.prev.next = newObj;

  total += newObj.size;
  return newPtr;
}

// @ts-ignore: decorator
@global @unsafe
export function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {
  // nop
}

// @ts-ignore: decorator
@global @unsafe
export function __visit(ptr: usize, cookie: i32): void {
  if (!ptr) return;
  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);
  if (RTRACE) if (!onvisit(obj)) return;
  if (obj.color == white) {
    obj.unlink(); // from fromSpace
    obj.linkTo(toSpace, i32(!white));
  }
}

// @ts-ignore: decorator
@global @unsafe
export function __pin(ptr: usize): usize {
  if (ptr) {
    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);
    if (obj.color == transparent) {
      throw new Error(E_ALREADY_PINNED);
    }
    obj.unlink(); // from fromSpace
    obj.linkTo(pinSpace, transparent);
  }
  return ptr;
}

// @ts-ignore: decorator
@global @unsafe
export function __unpin(ptr: usize): void {
  if (!ptr) return;
  var obj = changetype<Object>(ptr - TOTAL_OVERHEAD);
  if (obj.color != transparent) {
    throw new Error(E_NOT_PINNED);
  }
  obj.unlink(); // from pinSpace
  obj.linkTo(fromSpace, white);
}

// @ts-ignore: decorator
@global @unsafe
export function __collect(): void {
  if (TRACE) trace("GC at", 1, total);

  // Mark roots (add to toSpace)
  __visit_globals(VISIT_SCAN);

  // Mark direct members of pinned objects (add to toSpace)
  var pn = pinSpace;
  var iter = pn.next;
  while (iter != pn) {
    if (DEBUG) assert(iter.color == transparent);
    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, VISIT_SCAN);
    iter = iter.next;
  }

  // Mark what's reachable from toSpace
  var black = i32(!white);
  var to = toSpace;
  iter = to.next;
  while (iter != to) {
    if (DEBUG) assert(iter.color == black);
    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, VISIT_SCAN);
    iter = iter.next;
  }

  // Sweep what's left in fromSpace
  var from = fromSpace;
  iter = from.next;
  while (iter != from) {
    if (DEBUG) assert(iter.color == white);
    let newNext = iter.next;
    if (changetype<usize>(iter) < __heap_base) {
      iter.nextWithColor = 0; // may become linked again
      iter.prev = changetype<Object>(0);
    } else {
      total -= iter.size;
      if (isDefined(__finalize)) __finalize(changetype<usize>(iter) + TOTAL_OVERHEAD);
      __free(changetype<usize>(iter) + BLOCK_OVERHEAD);
    }
    iter = newNext;
  }
  from.nextWithColor = changetype<usize>(from);
  from.prev = from;

  // Flip spaces and colors
  fromSpace = to;
  toSpace = from;
  white = black;

  if (TRACE) trace("GC done at", 1, total);
  if (RTRACE) oncollect(total);
}

'''
'''--- std/assembly/rt/tlsf.ts ---
import { AL_BITS, AL_SIZE, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from "./common";
import { oninit, onalloc, onresize, onmove, onfree } from "./rtrace";
import { E_ALLOCATION_TOO_LARGE } from "../util/error";

// === The TLSF (Two-Level Segregate Fit) memory allocator ===
// see: http://www.gii.upv.es/tlsf/

// - `ffs(x)` is equivalent to `ctz(x)` with x != 0
// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`

// â•’â•â•â•â•â•â•â•â•â•â•â•â•â•â• Block size interpretation (32-bit) â•â•â•â•â•â•â•â•â•â•â•â•â•â••
//    3                   2                   1
//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits
// â”œâ”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”¼â”€â”´â”€â”´â”€â”´â”€â•«â”€â”´â”€â”´â”€â”´â”€â”¤
// â”‚ |                    FL                       â”‚ SB = SL + AL  â”‚ â—„â”€ usize
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â•¨â”€â”€â”€â”€â”€â”€â”€â”˜
// FL: first level, SL: second level, AL: alignment, SB: small block

// @ts-ignore: decorator
@inline const SL_BITS: u32 = 4;
// @ts-ignore: decorator
@inline const SL_SIZE: u32 = 1 << SL_BITS;

// @ts-ignore: decorator
@inline const SB_BITS: u32 = SL_BITS + AL_BITS;
// @ts-ignore: decorator
@inline const SB_SIZE: u32 = 1 << SB_BITS;

// @ts-ignore: decorator
@inline const FL_BITS: u32 = 31 - SB_BITS;

// [00]: < 256B (SB)  [12]: < 1M
// [01]: < 512B       [13]: < 2M
// [02]: < 1K         [14]: < 4M
// [03]: < 2K         [15]: < 8M
// [04]: < 4K         [16]: < 16M
// [05]: < 8K         [17]: < 32M
// [06]: < 16K        [18]: < 64M
// [07]: < 32K        [19]: < 128M
// [08]: < 64K        [20]: < 256M
// [09]: < 128K       [21]: < 512M
// [10]: < 256K       [22]: <= 1G - OVERHEAD
// [11]: < 512K
// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead

// Tags stored in otherwise unused alignment bits

// @ts-ignore: decorator
@inline const FREE: usize = 1 << 0;
// @ts-ignore: decorator
@inline const LEFTFREE: usize = 1 << 1;
// @ts-ignore: decorator
@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK

// â•’â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Block layout (32-bit) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â••
//    3                   2                   1
//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits
// â”œâ”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”¼â”€â”¼â”€â”¤            â”
// â”‚                          size                             â”‚Lâ”‚Fâ”‚ â—„â”€â” info   overhead
// â•ž>ptrâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•§â•â•¡   â”‚        â”˜
// â”‚                        if free: â—„ prev                        â”‚ â—„â”€â”¤ usize
// â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
// â”‚                        if free: next â–º                        â”‚ â—„â”€â”¤
// â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
// â”‚                             ...                               â”‚   â”‚ >= 0
// â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
// â”‚                        if free: back â–²                        â”‚ â—„â”€â”˜
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ >= MIN SIZE
// F: FREE, L: LEFTFREE
@unmanaged export class Block extends BLOCK {

  /** Previous free block, if any. Only valid if free, otherwise part of payload. */
  prev: Block | null;
  /** Next free block, if any. Only valid if free, otherwise part of payload. */
  next: Block | null;

  // If the block is free, there is a 'back'reference at its end pointing at its start.
}

// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,
// `next` and `back` if free.

// @ts-ignore: decorator
@inline const BLOCK_MINSIZE: usize = ((3 * sizeof<usize>() + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD; // prev + next + back
// @ts-ignore: decorator
// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts

/** Gets the left block of a block. Only valid if the left block is free. */
// @ts-ignore: decorator
@inline function GETFREELEFT(block: Block): Block {
  return load<Block>(changetype<usize>(block) - sizeof<usize>());
}

/** Gets the right block of a block by advancing to the right by its size. */
// @ts-ignore: decorator
@inline function GETRIGHT(block: Block): Block {
  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));
}

// â•’â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Root layout (32-bit) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â••
//    3                   2                   1
//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits
// â”œâ”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”¤          â”
// â”‚        0        |           flMap                            Sâ”‚ â—„â”€â”€â”€â”€â”
// â•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡      â”‚
// â”‚                           slMap[0] S                          â”‚ â—„â”€â”  â”‚
// â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚  â”‚
// â”‚                           slMap[1]                            â”‚ â—„â”€â”¤  â”‚
// â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  u32 â”‚
// â”‚                           slMap[22]                           â”‚ â—„â”€â”˜  â”‚
// â•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡    usize
// â”‚                            head[0]                            â”‚ â—„â”€â”€â”€â”€â”¤
// â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤      â”‚
// â”‚                              ...                              â”‚ â—„â”€â”€â”€â”€â”¤
// â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤      â”‚
// â”‚                           head[367]                           â”‚ â—„â”€â”€â”€â”€â”¤
// â•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡      â”‚
// â”‚                             tail                              â”‚ â—„â”€â”€â”€â”€â”˜
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   SIZE   â”˜
// S: Small blocks map
@unmanaged class Root {
  /** First level bitmap. */
  flMap: usize;
}

// Root constants. Where stuff is stored inside of the root structure.

// @ts-ignore: decorator
@inline const SL_START: usize = sizeof<usize>();
// @ts-ignore: decorator
@inline const SL_END: usize = SL_START + (FL_BITS << alignof<u32>());
// @ts-ignore: decorator
@inline const HL_START: usize = (SL_END + AL_MASK) & ~AL_MASK;
// @ts-ignore: decorator
@inline const HL_END: usize = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();
// @ts-ignore: decorator
@inline const ROOT_SIZE: usize = HL_END + sizeof<usize>();

// @ts-ignore: decorator
@lazy export var ROOT: Root;

/** Gets the second level map of the specified first level. */
// @ts-ignore: decorator
@inline function GETSL(root: Root, fl: usize): u32 {
  return load<u32>(
    changetype<usize>(root) + (fl << alignof<u32>()),
    SL_START
  );
}

/** Sets the second level map of the specified first level. */
// @ts-ignore: decorator
@inline function SETSL(root: Root, fl: usize, slMap: u32): void {
  store<u32>(
    changetype<usize>(root) + (fl << alignof<u32>()),
    slMap,
    SL_START
  );
}

/** Gets the head of the free list for the specified combination of first and second level. */
// @ts-ignore: decorator
@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {
  return load<Block>(
    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),
    HL_START
  );
}

/** Sets the head of the free list for the specified combination of first and second level. */
// @ts-ignore: decorator
@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {
  store<Block | null>(
    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),
    head,
    HL_START
  );
}

/** Gets the tail block.. */
// @ts-ignore: decorator
@inline function GETTAIL(root: Root): Block {
  return load<Block>(
    changetype<usize>(root),
    HL_END
  );
}

/** Sets the tail block. */
// @ts-ignore: decorator
@inline function SETTAIL(root: Root, tail: Block): void {
  store<Block>(
    changetype<usize>(root),
    tail,
    HL_END
  );
}

/** Inserts a previously used block back into the free list. */
function insertBlock(root: Root, block: Block): void {
  if (DEBUG) assert(block); // cannot be null
  var blockInfo = block.mmInfo;
  if (DEBUG) assert(blockInfo & FREE); // must be free

  var right = GETRIGHT(block);
  var rightInfo = right.mmInfo;

  // merge with right block if also free
  if (rightInfo & FREE) {
    removeBlock(root, right);
    block.mmInfo = blockInfo = blockInfo + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK); // keep block tags
    right = GETRIGHT(block);
    rightInfo = right.mmInfo;
    // 'back' is set below
  }

  // merge with left block if also free
  if (blockInfo & LEFTFREE) {
    let left = GETFREELEFT(block);
    let leftInfo = left.mmInfo;
    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags
    removeBlock(root, left);
    block = left;
    block.mmInfo = blockInfo = leftInfo + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK); // keep left tags
    // 'back' is set below
  }

  right.mmInfo = rightInfo | LEFTFREE;
  // reference to right is no longer used now, hence rightInfo is not synced

  // we now know the size of the block
  var size = blockInfo & ~TAGS_MASK;
  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be a valid size
  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match

  // set 'back' to itself at the end of block
  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);

  // mapping_insert
  var fl: usize, sl: u32;
  if (size < SB_SIZE) {
    fl = 0;
    sl = <u32>(size >> AL_BITS);
  } else {
    const inv: usize = sizeof<usize>() * 8 - 1;
    let boundedSize = min(size, BLOCK_MAXSIZE);
    fl = inv - clz<usize>(boundedSize);
    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));
    fl -= SB_BITS - 1;
  }
  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range

  // perform insertion
  var head = GETHEAD(root, fl, sl);
  block.prev = null;
  block.next = head;
  if (head) head.prev = block;
  SETHEAD(root, fl, sl, block);

  // update first and second level maps
  root.flMap |= (1 << fl);
  SETSL(root, fl, GETSL(root, fl) | (1 << sl));
}

/** Removes a free block from internal lists. */
function removeBlock(root: Root, block: Block): void {
  var blockInfo = block.mmInfo;
  if (DEBUG) assert(blockInfo & FREE); // must be free
  var size = blockInfo & ~TAGS_MASK;
  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be valid

  // mapping_insert
  var fl: usize, sl: u32;
  if (size < SB_SIZE) {
    fl = 0;
    sl = <u32>(size >> AL_BITS);
  } else {
    const inv: usize = sizeof<usize>() * 8 - 1;
    let boundedSize = min(size, BLOCK_MAXSIZE);
    fl = inv - clz<usize>(boundedSize);
    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));
    fl -= SB_BITS - 1;
  }
  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range

  // link previous and next free block
  var prev = block.prev;
  var next = block.next;
  if (prev) prev.next = next;
  if (next) next.prev = prev;

  // update head if we are removing it
  if (block == GETHEAD(root, fl, sl)) {
    SETHEAD(root, fl, sl, next);

    // clear second level map if head is empty now
    if (!next) {
      let slMap = GETSL(root, fl);
      SETSL(root, fl, slMap &= ~(1 << sl));

      // clear first level map if second level is empty now
      if (!slMap) root.flMap &= ~(1 << fl);
    }
  }
  // note: does not alter left/back because it is likely that splitting
  // is performed afterwards, invalidating those changes. so, the caller
  // must perform those updates.
}

/** Searches for a free block of at least the specified size. */
function searchBlock(root: Root, size: usize): Block | null {
  // size was already asserted by caller

  // mapping_search
  var fl: usize, sl: u32;
  if (size < SB_SIZE) {
    fl = 0;
    sl = <u32>(size >> AL_BITS);
  } else {
    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl
    const inv: usize = sizeof<usize>() * 8 - 1;
    const invRound = inv - SL_BITS;
    let requestSize = size < halfMaxSize
      ? size + (1 << (invRound - clz<usize>(size))) - 1
      : size;
    fl = inv - clz<usize>(requestSize);
    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));
    fl -= SB_BITS - 1;
  }
  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range

  // search second level
  var slMap = GETSL(root, fl) & (~0 << sl);
  var head: Block | null = null;
  if (!slMap) {
    // search next larger first level
    let flMap = root.flMap & (~0 << (fl + 1));
    if (!flMap) {
      head = null;
    } else {
      fl = ctz<usize>(flMap);
      slMap = GETSL(root, fl);
      if (DEBUG) assert(slMap);  // can't be zero if fl points here
      head = GETHEAD(root, fl, ctz<u32>(slMap));
    }
  } else {
    head = GETHEAD(root, fl, ctz<u32>(slMap));
  }
  return head;
}

/** Prepares the specified block before (re-)use, possibly splitting it. */
function prepareBlock(root: Root, block: Block, size: usize): void {
  // size was already asserted by caller

  var blockInfo = block.mmInfo;
  if (DEBUG) assert(!((size + BLOCK_OVERHEAD) & AL_MASK)); // size must be aligned so the new block is

  // split if the block can hold another MINSIZE block incl. overhead
  var remaining = (blockInfo & ~TAGS_MASK) - size;
  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {
    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE

    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);
    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE
    insertBlock(root, spare); // also sets 'back'

  // otherwise tag block as no longer FREE and right as no longer LEFTFREE
  } else {
    block.mmInfo = blockInfo & ~FREE;
    GETRIGHT(block).mmInfo &= ~LEFTFREE;
  }
}

/** Adds more memory to the pool. */
function addMemory(root: Root, start: usize, end: usize): bool {
  if (DEBUG) assert(start <= end); // must be valid
  start = ((start + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;
  end &= ~AL_MASK;

  var tail = GETTAIL(root);
  var tailInfo: usize = 0;
  if (tail) { // more memory
    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);

    // merge with current tail if adjacent
    const offsetToTail = AL_SIZE;
    if (start - offsetToTail == changetype<usize>(tail)) {
      start -= offsetToTail;
      tailInfo = tail.mmInfo;
    } else {
      // We don't do this, but a user might `memory.grow` manually
      // leading to non-adjacent pages managed by TLSF.
    }

  } else if (DEBUG) { // first memory
    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root
  }

  // check if size is large enough for a free block and the tail block
  var size = end - start;
  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {
    return false;
  }

  // left size is total minus its own and the zero-length tail's header
  var leftSize = size - 2 * BLOCK_OVERHEAD;
  var left = changetype<Block>(start);
  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);
  left.prev = null;
  left.next = null;

  // tail is a zero-length used block
  tail = changetype<Block>(start + BLOCK_OVERHEAD + leftSize);
  tail.mmInfo = 0 | LEFTFREE;
  SETTAIL(root, tail);

  insertBlock(root, left); // also merges with free left before tail / sets 'back'

  return true;
}

/** Grows memory to fit at least another block of the specified size. */
function growMemory(root: Root, size: usize): void {
  if (ASC_LOW_MEMORY_LIMIT) {
    unreachable();
    return;
  }
  // Here, both rounding performed in searchBlock ...
  const halfMaxSize = BLOCK_MAXSIZE >> 1;
  if (size < halfMaxSize) { // don't round last fl
    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;
    size += (1 << (invRound - clz<usize>(size))) - 1;
  }
  // and additional BLOCK_OVERHEAD must be taken into account. If we are going
  // to merge with the tail block, that's one time, otherwise it's two times.
  var pagesBefore = memory.size();
  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));
  var pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);
  var pagesWanted = max(pagesBefore, pagesNeeded); // double memory
  if (memory.grow(pagesWanted) < 0) {
    if (memory.grow(pagesNeeded) < 0) unreachable();
  }
  var pagesAfter = memory.size();
  addMemory(root, <usize>pagesBefore << 16, <usize>pagesAfter << 16);
}

/** Computes the size (excl. header) of a block. */
function computeSize(size: usize): usize {
  // Size must be large enough and aligned minus preceeding overhead
  return size <= BLOCK_MINSIZE
    ? BLOCK_MINSIZE
    : ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;
}

/** Prepares and checks an allocation size. */
function prepareSize(size: usize): usize {
  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);
  return computeSize(size);
}

/** Initializes the root structure. */
function initialize(): void {
  if (isDefined(ASC_RTRACE)) oninit(__heap_base);
  var rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;
  var pagesBefore = memory.size();
  var pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);
  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();
  var root = changetype<Root>(rootOffset);
  root.flMap = 0;
  SETTAIL(root, changetype<Block>(0));
  for (let fl: usize = 0; fl < FL_BITS; ++fl) {
    SETSL(root, fl, 0);
    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {
      SETHEAD(root, fl, sl, null);
    }
  }
  var memStart = rootOffset + ROOT_SIZE;
  if (ASC_LOW_MEMORY_LIMIT) {
    const memEnd = <usize>ASC_LOW_MEMORY_LIMIT & ~AL_MASK;
    if (memStart <= memEnd) addMemory(root, memStart, memEnd);
    else unreachable(); // low memory limit already exceeded
  } else {
    addMemory(root, memStart, memory.size() << 16);
  }
  ROOT = root;
}

/** Allocates a block of the specified size. */
export function allocateBlock(root: Root, size: usize): Block {
  var payloadSize = prepareSize(size);
  var block = searchBlock(root, payloadSize);
  if (!block) {
    growMemory(root, payloadSize);
    block = changetype<Block>(searchBlock(root, payloadSize));
    if (DEBUG) assert(block); // must be found now
  }
  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit
  removeBlock(root, <Block>block);
  prepareBlock(root, <Block>block, payloadSize);
  if (isDefined(ASC_RTRACE)) onalloc(block);
  return <Block>block;
}

/** Reallocates a block to the specified size. */
export function reallocateBlock(root: Root, block: Block, size: usize): Block {
  var payloadSize = prepareSize(size);
  var blockInfo = block.mmInfo;
  var blockSize = blockInfo & ~TAGS_MASK;

  // possibly split and update runtime size if it still fits
  if (payloadSize <= blockSize) {
    prepareBlock(root, block, payloadSize);
    if (isDefined(ASC_RTRACE)) {
      if (payloadSize != blockSize) onresize(block, BLOCK_OVERHEAD + blockSize);
    }
    return block;
  }

  // merge with right free block if merger is large enough
  var right = GETRIGHT(block);
  var rightInfo = right.mmInfo;
  if (rightInfo & FREE) {
    let mergeSize = blockSize + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);
    if (mergeSize >= payloadSize) {
      removeBlock(root, right);
      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;
      prepareBlock(root, block, payloadSize);
      if (isDefined(ASC_RTRACE)) onresize(block, BLOCK_OVERHEAD + blockSize);
      return block;
    }
  }

  // otherwise move the block
  return moveBlock(root, block, size);
}

/** Moves a block to a new one of the specified size. */
function moveBlock(root: Root, block: Block, newSize: usize): Block {
  var newBlock = allocateBlock(root, newSize);
  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, block.mmInfo & ~TAGS_MASK);
  if (changetype<usize>(block) >= __heap_base) {
    if (isDefined(ASC_RTRACE)) onmove(block, newBlock);
    freeBlock(root, block);
  }
  return newBlock;
}

/** Frees a block. */
export function freeBlock(root: Root, block: Block): void {
  if (isDefined(ASC_RTRACE)) onfree(block);
  block.mmInfo = block.mmInfo | FREE;
  insertBlock(root, block);
}

/** Checks that a used block is valid to be freed or reallocated. */
function checkUsedBlock(ptr: usize): Block {
  var block = changetype<Block>(ptr - BLOCK_OVERHEAD);
  assert(
    ptr != 0 && !(ptr & AL_MASK) &&  // must exist and be aligned
    !(block.mmInfo & FREE)           // must be used
  );
  return block;
}

// @ts-ignore: decorator
@global @unsafe
export function __alloc(size: usize): usize {
  if (!ROOT) initialize();
  return changetype<usize>(allocateBlock(ROOT, size)) + BLOCK_OVERHEAD;
}

// @ts-ignore: decorator
@global @unsafe
export function __realloc(ptr: usize, size: usize): usize {
  if (!ROOT) initialize();
  return (ptr < __heap_base
    ? changetype<usize>(moveBlock(ROOT, checkUsedBlock(ptr), size))
    : changetype<usize>(reallocateBlock(ROOT, checkUsedBlock(ptr), size))
  ) + BLOCK_OVERHEAD;
}

// @ts-ignore: decorator
@global @unsafe
export function __free(ptr: usize): void {
  if (ptr < __heap_base) return;
  if (!ROOT) initialize();
  freeBlock(ROOT, checkUsedBlock(ptr));
}

'''
'''--- std/assembly/set.ts ---
/// <reference path="./rt/index.d.ts" />

import { HASH } from "./util/hash";

// A deterministic hash set based on CloseTable from https://github.com/jorendorff/dht

// @ts-ignore: decorator
@inline const INITIAL_CAPACITY = 4;

// @ts-ignore: decorator
@inline const FILL_FACTOR_N = 8;

// @ts-ignore: decorator
@inline const FILL_FACTOR_D = 3;

// @ts-ignore: decorator
@inline const FREE_FACTOR_N = 3;

// @ts-ignore: decorator
@inline const FREE_FACTOR_D = 4;

/** Structure of a set entry. */
@unmanaged class SetEntry<K> {
  key: K;
  taggedNext: usize; // LSB=1 indicates EMPTY
}

/** Empty bit. */
// @ts-ignore: decorator
@inline const EMPTY: usize = 1 << 0;

/** Size of a bucket. */
// @ts-ignore: decorator
@inline const BUCKET_SIZE = sizeof<usize>();

/** Computes the alignment of an entry. */
// @ts-ignore: decorator
@inline
function ENTRY_ALIGN<T>(): usize {
  // can align to 4 instead of 8 if 32-bit and K is <= 32-bits
  const align = (sizeof<T>() > sizeof<usize>() ? sizeof<T>() : sizeof<usize>()) - 1;
  return align;
}

/** Computes the aligned size of an entry. */
// @ts-ignore: decorator
@inline
function ENTRY_SIZE<T>(): usize {
  const align = ENTRY_ALIGN<T>();
  const size = (offsetof<SetEntry<T>>() + align) & ~align;
  return size;
}

export class Set<T> {

  // buckets referencing their respective first entry, usize[bucketsMask + 1]
  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);
  private bucketsMask: u32 = INITIAL_CAPACITY - 1;

  // entries in insertion order, SetEntry<K>[entriesCapacity]
  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<T>());
  private entriesCapacity: i32 = INITIAL_CAPACITY;
  private entriesOffset: i32 = 0;
  private entriesCount: i32 = 0;

  constructor() {
    /* nop */
  }

  get size(): i32 {
    return this.entriesCount;
  }

  clear(): void {
    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);
    this.bucketsMask = INITIAL_CAPACITY - 1;
    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<T>());
    this.entriesCapacity = INITIAL_CAPACITY;
    this.entriesOffset = 0;
    this.entriesCount = 0;
  }

  private find(key: T, hashCode: u32): SetEntry<T> | null {
    var entry = load<SetEntry<T>>( // unmanaged!
      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE
    );
    while (entry) {
      let taggedNext = entry.taggedNext;
      if (!(taggedNext & EMPTY) && entry.key == key) return entry;
      entry = changetype<SetEntry<T>>(taggedNext & ~EMPTY);
    }
    return null;
  }

  @operator("[]")
  has(key: T): bool {
    return this.find(key, HASH<T>(key)) !== null;
  }

  add(key: T): this {
    var hashCode = HASH<T>(key);
    var entry = this.find(key, hashCode); // unmanaged!
    if (!entry) {
      // check if rehashing is necessary
      if (this.entriesOffset == this.entriesCapacity) {
        this.rehash(
          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D
            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty
            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N
        );
      }
      // append new entry
      entry = changetype<SetEntry<T>>(changetype<usize>(this.entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<T>());
      entry.key = key;
      if (isManaged<T>()) {
        __link(changetype<usize>(this), changetype<usize>(key), true);
      }
      ++this.entriesCount;
      // link with previous entry in bucket
      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;
      entry.taggedNext = load<usize>(bucketPtrBase);
      store<usize>(bucketPtrBase, changetype<usize>(entry));
    }
    return this;
  }

  @operator("[]=")
  private __set(key: T, value: bool): void {
    if (value) this.add(key);
    else this.delete(key);
  }

  delete(key: T): bool {
    var entry = this.find(key, HASH<T>(key)); // unmanaged!
    if (!entry) return false;
    entry.taggedNext |= EMPTY;
    --this.entriesCount;
    // check if rehashing is appropriate
    var halfBucketsMask = this.bucketsMask >> 1;
    if (
      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&
      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D
    ) this.rehash(halfBucketsMask);
    return true;
  }

  private rehash(newBucketsMask: u32): void {
    var newBucketsCapacity = <i32>(newBucketsMask + 1);
    var newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);
    var newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;
    var newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<T>());

    // copy old entries to new entries
    var oldPtr = changetype<usize>(this.entries);
    var oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<T>();
    var newPtr = changetype<usize>(newEntries);
    while (oldPtr != oldEnd) {
      let oldEntry = changetype<SetEntry<T>>(oldPtr); // unmanaged!
      if (!(oldEntry.taggedNext & EMPTY)) {
        let newEntry = changetype<SetEntry<T>>(newPtr); // unmanaged!
        let oldEntryKey = oldEntry.key;
        newEntry.key = oldEntryKey;
        let newBucketIndex = HASH<T>(oldEntryKey) & newBucketsMask;
        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;
        newEntry.taggedNext = load<usize>(newBucketPtrBase);
        store<usize>(newBucketPtrBase, newPtr);
        newPtr += ENTRY_SIZE<T>();
      }
      oldPtr += ENTRY_SIZE<T>();
    }

    this.buckets = newBuckets;
    this.bucketsMask = newBucketsMask;
    this.entries = newEntries;
    this.entriesCapacity = newEntriesCapacity;
    this.entriesOffset = this.entriesCount;
  }

  values(): T[] {
    // FIXME: this is preliminary, needs iterators/closures
    var start = changetype<usize>(this.entries);
    var size = this.entriesOffset;
    var values = new Array<T>(size);
    var length = 0;
    for (let i = 0; i < size; ++i) {
      let entry = changetype<SetEntry<T>>(start + <usize>i * ENTRY_SIZE<T>());
      if (!(entry.taggedNext & EMPTY)) {
        values[length++] = entry.key;
      }
    }
    values.length = length;
    return values;
  }

  toString(): string {
    return "[object Set]";
  }

  // RT integration

  @unsafe private __visit(cookie: u32): void {
    __visit(changetype<usize>(this.buckets), cookie);
    var entries = changetype<usize>(this.entries);
    if (isManaged<T>()) {
      let cur = entries;
      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<T>();
      while (cur < end) {
        let entry = changetype<SetEntry<T>>(cur);
        if (!(entry.taggedNext & EMPTY)) {
          let val = changetype<usize>(entry.key);
          if (isNullable<T>()) {
            if (val) __visit(val, cookie);
          } else __visit(val, cookie);
        }
        cur += ENTRY_SIZE<T>();
      }
    }
    __visit(entries, cookie);
  }
}

'''
'''--- std/assembly/shared/feature.ts ---
// This file is shared with the compiler and must remain portable

/** Indicates specific features to activate. */
export const enum Feature {
  /** No additional features. */
  NONE = 0,
  /** Sign extension operations. */
  SIGN_EXTENSION = 1 << 0, // see: https://github.com/WebAssembly/sign-extension-ops
  /** Mutable global imports and exports. */
  MUTABLE_GLOBALS = 1 << 1, // see: https://github.com/WebAssembly/mutable-global
  /** Non-trapping float to integer operations. */
  NONTRAPPING_F2I = 1 << 2, // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions
  /** Bulk memory operations. */
  BULK_MEMORY = 1 << 3, // see: https://github.com/WebAssembly/bulk-memory-operations
  /** SIMD types and operations. */
  SIMD = 1 << 4, // see: https://github.com/WebAssembly/simd
  /** Threading and atomic operations. */
  THREADS = 1 << 5, // see: https://github.com/WebAssembly/threads
  /** Exception handling operations. */
  EXCEPTION_HANDLING = 1 << 6, // see: https://github.com/WebAssembly/exception-handling
  /** Tail call operations. */
  TAIL_CALLS = 1 << 7, // see: https://github.com/WebAssembly/tail-call
  /** Reference types. */
  REFERENCE_TYPES = 1 << 8, // see: https://github.com/WebAssembly/reference-types
  /** Multi value types. */
  MULTI_VALUE = 1 << 9, // see: https://github.com/WebAssembly/multi-value
  /** Garbage collection. */
  GC = 1 << 10, // see: https://github.com/WebAssembly/gc
  /** Memory64. */
  MEMORY64 = 1 << 11 // see: https://github.com/WebAssembly/memory64
}

/** Gets the name of the specified feature one would specify on the command line. */
export function featureToString(feature: Feature): string {
  switch (feature) {
    case Feature.SIGN_EXTENSION: return "sign-extension";
    case Feature.MUTABLE_GLOBALS: return "mutable-globals";
    case Feature.NONTRAPPING_F2I: return "nontrapping-f2i";
    case Feature.BULK_MEMORY: return "bulk-memory";
    case Feature.SIMD: return "simd";
    case Feature.THREADS: return "threads";
    case Feature.EXCEPTION_HANDLING: return "exception-handling";
    case Feature.TAIL_CALLS: return "tail-calls";
    case Feature.REFERENCE_TYPES: return "reference-types";
    case Feature.MULTI_VALUE: return "multi-value";
    case Feature.GC: return "gc";
    case Feature.MEMORY64: return "memory64";
  }
  assert(false);
  return "";
}

'''
'''--- std/assembly/shared/target.ts ---
// This file is shared with the compiler and must remain portable

/** Compilation target. */
export enum Target {
  /** Portable. */
  JS = 0,
  /** WebAssembly with 32-bit pointers. */
  WASM32 = 1,
  /** WebAssembly with 64-bit pointers. Experimental and not supported by any runtime yet. */
  WASM64 = 2,
}

'''
'''--- std/assembly/shared/tsconfig.json ---
{
  "extends": "../../portable.json",
  "compilerOptions": {
    "outDir": "../../../out",
    "allowJs": false,
    "sourceMap": true
  },
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- std/assembly/shared/typeinfo.ts ---
// This file is shared with the compiler and must remain portable

// â•’â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Typeinfo interpretation â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â••
//    3                   2                   1
//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits
// â”œâ”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”¤ â—„â”€ __rtti_base
// â”‚                             count                             â”‚
// â•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡ â”
// â”‚                      Typeinfo#flags [id=0]                    â”‚ id < count
// â”œ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”¤
// â”‚                      Typeinfo#base  [id=0]                    â”‚
// â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
// â”‚                              ...                              â”‚

/** Runtime type information data structure. */
@unmanaged
export class Typeinfo {
  /** Flags describing the shape of this class type. */
  flags: TypeinfoFlags = TypeinfoFlags.NONE;
  /** Base class id or `0` if none. */
  base: u32 = 0;
}

/** Runtime type information flags. */
export const enum TypeinfoFlags {
  /** No specific flags. */
  NONE = 0,
  /** Type is an `ArrayBufferView`. */
  ARRAYBUFFERVIEW = 1 << 0,
  /** Type is an `Array`. */
  ARRAY = 1 << 1,
  /** Type is a `StaticArray`. */
  STATICARRAY = 1 << 2,
  /** Type is a `Set`. */
  SET = 1 << 3,
  /** Type is a `Map`. */
  MAP = 1 << 4,
  /** Type has no outgoing pointers. */
  POINTERFREE = 1 << 5,
  /** Value alignment of 1 byte. */
  VALUE_ALIGN_0 = 1 << 6,
  /** Value alignment of 2 bytes. */
  VALUE_ALIGN_1 = 1 << 7,
  /** Value alignment of 4 bytes. */
  VALUE_ALIGN_2 = 1 << 8,
  /** Value alignment of 8 bytes. */
  VALUE_ALIGN_3 = 1 << 9,
  /** Value alignment of 16 bytes. */
  VALUE_ALIGN_4 = 1 << 10,
  /** Value is a signed type. */
  VALUE_SIGNED = 1 << 11,
  /** Value is a float type. */
  VALUE_FLOAT = 1 << 12,
  /** Value type is nullable. */
  VALUE_NULLABLE = 1 << 13,
  /** Value type is managed. */
  VALUE_MANAGED = 1 << 14,
  /** Key alignment of 1 byte. */
  KEY_ALIGN_0 = 1 << 15,
  /** Key alignment of 2 bytes. */
  KEY_ALIGN_1 = 1 << 16,
  /** Key alignment of 4 bytes. */
  KEY_ALIGN_2 = 1 << 17,
  /** Key alignment of 8 bytes. */
  KEY_ALIGN_3 = 1 << 18,
  /** Key alignment of 16 bytes. */
  KEY_ALIGN_4 = 1 << 19,
  /** Key is a signed type. */
  KEY_SIGNED = 1 << 20,
  /** Key is a float type. */
  KEY_FLOAT = 1 << 21,
  /** Key type is nullable. */
  KEY_NULLABLE = 1 << 22,
  /** Key type is managed. */
  KEY_MANAGED = 1 << 23
}

'''
'''--- std/assembly/staticarray.ts ---
/// <reference path="./rt/index.d.ts" />

import { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from "./rt/common";
import { idof } from "./builtins";
import { Array } from "./array";
import { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_HOLEYARRAY } from "./util/error";
import { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from "./util/string";

@final
export class StaticArray<T> {
  [key: number]: T;

  // Note that the interface of StaticArray instances must be a semantically
  // compatible subset of Array<T> in order for syntax highlighting to work
  // properly, for instance when creating static arrays from array literals.
  // The additionally provided static methods take care of dealing with static
  // arrays exclusively, without having to convert to Array<T> first.

  static fromArray<T>(source: Array<T>): StaticArray<T> {
    var length = source.length;
    var outSize = <usize>length << alignof<T>();
    var out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));
    if (isManaged<T>()) {
      let sourcePtr = source.dataStart;
      for (let i = 0; i < length; ++i) {
        let off = <usize>i << alignof<T>();
        let ref = load<usize>(sourcePtr + off);
        store<usize>(changetype<usize>(out) + off, ref);
        __link(changetype<usize>(out), ref, true);
      }
    } else {
      memory.copy(changetype<usize>(out), source.dataStart, outSize);
    }
    return out;
  }

  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T> {
    var sourceLen = source.length;
    var otherLen = select(0, other.length, other === null);
    var outLen = sourceLen + otherLen;
    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);
    var out = changetype<StaticArray<T>>(__new(<usize>outLen << alignof<T>(), idof<StaticArray<T>>()));
    var outStart = changetype<usize>(out);
    var sourceSize = <usize>sourceLen << alignof<T>();
    if (isManaged<T>()) {
      for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {
        let ref = load<usize>(changetype<usize>(source) + offset);
        store<usize>(outStart + offset, ref);
        __link(changetype<usize>(out), ref, true);
      }
      outStart += sourceSize;
      let otherSize = <usize>otherLen << alignof<T>();
      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {
        let ref = load<usize>(changetype<usize>(other) + offset);
        store<usize>(outStart + offset, ref);
        __link(changetype<usize>(out), ref, true);
      }
    } else {
      memory.copy(outStart, changetype<usize>(source), sourceSize);
      memory.copy(outStart + sourceSize, changetype<usize>(other), <usize>otherLen << alignof<T>());
    }
    return out;
  }

  static slice<T>(source: StaticArray<T>, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {
    var length = source.length;
    start = start < 0 ? max(start + length, 0) : min(start, length);
    end   = end   < 0 ? max(end   + length, 0) : min(end  , length);
    length = max(end - start, 0);
    var sliceSize = <usize>length << alignof<T>();
    var slice = changetype<StaticArray<T>>(__new(sliceSize, idof<StaticArray<T>>()));
    var sourcePtr = changetype<usize>(source) + (<usize>start << alignof<T>());
    if (isManaged<T>()) {
      let off: usize = 0;
      while (off < sliceSize) {
        let ref = load<usize>(sourcePtr + off);
        store<usize>(changetype<usize>(slice) + off, ref);
        __link(changetype<usize>(slice), ref, true);
        off += sizeof<usize>();
      }
    } else {
      memory.copy(changetype<usize>(slice), sourcePtr, sliceSize);
    }
    return slice;
  }

  constructor(length: i32) {
    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);
    var outSize = <usize>length << alignof<T>();
    var out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));
    memory.fill(changetype<usize>(out), 0, outSize);
    return out;
  }

  get length(): i32 {
    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >>> alignof<T>();
  }

  at(index: i32): T {
    var len = this.length;
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    var value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));
    if (isReference<T>()) {
      if (!isNullable<T>()) {
        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);
      }
    }
    return value;
  }

  @operator("[]") private __get(index: i32): T {
    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);
    var value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));
    if (isReference<T>()) {
      if (!isNullable<T>()) {
        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);
      }
    }
    return value;
  }

  @unsafe @operator("{}") private __uget(index: i32): T {
    return load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));
  }

  @operator("[]=") private __set(index: i32, value: T): void {
    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);
    this.__uset(index, value);
  }

  @unsafe @operator("{}=") private __uset(index: i32, value: T): void {
    store<T>(changetype<usize>(this) + (<usize>index << alignof<T>()), value);
    if (isManaged<T>()) {
      __link(changetype<usize>(this), changetype<usize>(value), true);
    }
  }

  includes(value: T, fromIndex: i32 = 0): bool {
    if (isFloat<T>()) {
      let length = this.length;
      if (length == 0 || fromIndex >= length) return false;
      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);
      while (fromIndex < length) {
        let elem = load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>()));
        // @ts-ignore
        if (elem == value || isNaN(elem) & isNaN(value)) return true;
        ++fromIndex;
      }
      return false;
    } else {
      return this.indexOf(value, fromIndex) >= 0;
    }
  }

  indexOf(value: T, fromIndex: i32 = 0): i32 {
    var length = this.length;
    if (length == 0 || fromIndex >= length) return -1;
    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);
    while (fromIndex < length) {
      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;
      ++fromIndex;
    }
    return -1;
  }

  lastIndexOf(value: T, fromIndex: i32 = this.length): i32 {
    var length = this.length;
    if (length == 0) return -1;
    if (fromIndex < 0) fromIndex = length + fromIndex;
    else if (fromIndex >= length) fromIndex = length - 1;
    while (fromIndex >= 0) {
      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;
      --fromIndex;
    }
    return -1;
  }

  concat(other: Array<T>): Array<T> {
    var thisLen = this.length;
    var otherLen = select(0, other.length, other === null);
    var outLen = thisLen + otherLen;
    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);
    var out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));
    var outStart = out.dataStart;
    var thisSize = <usize>thisLen << alignof<T>();
    if (isManaged<T>()) {
      let thisStart = changetype<usize>(this);
      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {
        let ref = load<usize>(thisStart + offset);
        store<usize>(outStart + offset, ref);
        __link(changetype<usize>(out), ref, true);
      }
      outStart += thisSize;
      let otherStart = other.dataStart;
      let otherSize = <usize>otherLen << alignof<T>();
      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {
        let ref = load<usize>(otherStart + offset);
        store<usize>(outStart + offset, ref);
        __link(changetype<usize>(out), ref, true);
      }
    } else {
      memory.copy(outStart, changetype<usize>(this), thisSize);
      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());
    }
    return out;
  }

  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {
    var length = this.length;
    start = start < 0 ? max(start + length, 0) : min(start, length);
    end   = end   < 0 ? max(end   + length, 0) : min(end  , length);
    length = max(end - start, 0);
    var slice = changetype<Array<T>>(__newArray(length, alignof<T>(), idof<Array<T>>()));
    var sliceBase = slice.dataStart;
    var thisBase = changetype<usize>(this) + (<usize>start << alignof<T>());
    if (isManaged<T>()) {
      let off = <usize>0;
      let end = <usize>length << alignof<usize>();
      while (off < end) {
        let ref = load<usize>(thisBase + off);
        store<usize>(sliceBase + off, ref);
        __link(changetype<usize>(slice), ref, true);
        off += sizeof<usize>();
      }
    } else {
      memory.copy(sliceBase, thisBase, length << alignof<T>());
    }
    return slice;
  }

  join(separator: string = ","): string {
    if (isBoolean<T>())   return joinBooleanArray(changetype<usize>(this), this.length, separator);
    if (isInteger<T>())   return joinIntegerArray<T>(changetype<usize>(this), this.length, separator);
    if (isFloat<T>())     return joinFloatArray<T>(changetype<usize>(this), this.length, separator);
    if (ASC_SHRINK_LEVEL < 1) {
      if (isString<T>())  return joinStringArray(changetype<usize>(this), this.length, separator);
    }
    if (isReference<T>()) return joinReferenceArray<T>(changetype<usize>(this), this.length, separator);
    ERROR("unspported element type");
    return <string>unreachable();
  }

  toString(): string {
    return this.join();
  }

  // RT integration

  @unsafe private __visit(cookie: u32): void {
    if (isManaged<T>()) {
      let cur = changetype<usize>(this);
      let end = cur + changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;
      while (cur < end) {
        let val = load<usize>(cur);
        if (val) __visit(val, cookie);
        cur += sizeof<usize>();
      }
    }
  }
}

'''
'''--- std/assembly/string.ts ---
/// <reference path="./rt/index.d.ts" />

import { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from "./rt/common";
import { compareImpl, strtol, strtod, isSpace, isAscii, isFinalSigma, toLower8, toUpper8 } from "./util/string";
import { SPECIALS_UPPER, casemap, bsearch } from "./util/casemap";
import { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_UNPAIRED_SURROGATE } from "./util/error";
import { idof } from "./builtins";
import { Array } from "./array";

@final export abstract class String {

  @lazy static readonly MAX_LENGTH: i32 = <i32>(BLOCK_MAXSIZE >>> alignof<u16>());

  static fromCharCode(unit: i32, surr: i32 = -1): String {
    var hasSur = surr > 0;
    var out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));
    store<u16>(changetype<usize>(out), <u16>unit);
    if (hasSur) store<u16>(changetype<usize>(out), <u16>surr, 2);
    return out;
  }

  static fromCharCodes(units: Array<i32>): String {
    var length = units.length;
    var out = changetype<String>(__new(<usize>length << 1, idof<String>()));
    var ptr = units.dataStart;
    for (let i = 0; i < length; ++i) {
      store<u16>(changetype<usize>(out) + (<usize>i << 1), load<i32>(ptr + (<usize>i << 2)));
    }
    return out;
  }

  static fromCodePoint(code: i32): String {
    var hasSur = <u32>code > 0xFFFF;
    var out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));
    if (!hasSur) {
      store<u16>(changetype<usize>(out), <u16>code);
    } else {
      // Checks valid code point range
      assert(<u32>code <= 0x10FFFF);
      code -= 0x10000;
      let hi = (code & 0x03FF) | 0xDC00;
      let lo = code >>> 10 | 0xD800;
      store<u32>(changetype<usize>(out), lo | hi << 16);
    }
    return out;
  }

  @builtin static raw(parts: TemplateStringsArray, ...args: unknown[]): string { return unreachable(); }

  get length(): i32 {
    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >> 1;
  }

  at(pos: i32): String {
    var len = this.length;
    pos += select(0, len, pos >= 0);
    if (<u32>pos >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    var out = __new(2, idof<String>());
    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));
    return changetype<String>(out); // retains
  }

  @operator("[]") charAt(pos: i32): String {
    if (<u32>pos >= <u32>this.length) return changetype<String>("");
    var out = changetype<String>(__new(2, idof<String>()));
    store<u16>(changetype<usize>(out), load<u16>(changetype<usize>(this) + (<usize>pos << 1)));
    return out;
  }

  charCodeAt(pos: i32): i32 {
    if (<u32>pos >= <u32>this.length) return -1; // (NaN)
    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));
  }

  codePointAt(pos: i32): i32 {
    var len = this.length;
    if (<u32>pos >= <u32>len) return -1; // (undefined)
    var first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));
    if ((first & 0xFC00) != 0xD800 || pos + 1 == len) return first;
    var second = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1), 2);
    if ((second & 0xFC00) != 0xDC00) return first;
    return (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  }

  @operator("+") private static __concat(left: String, right: String): String {
    return left.concat(right);
  }

  concat(other: String): String {
    var thisSize: isize = this.length << 1;
    var otherSize: isize = other.length << 1;
    var outSize: usize = thisSize + otherSize;
    if (outSize == 0) return changetype<String>("");
    var out = changetype<String>(__new(outSize, idof<String>()));
    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);
    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);
    return out;
  }

  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {
    end = min(max(end, 0), this.length);
    var searchLength = <isize>search.length;
    var searchStart = <isize>end - searchLength;
    if (searchStart < 0) return false;
    // @ts-ignore: string <-> String
    return !compareImpl(this, searchStart, search, 0, searchLength);
  }

  @operator("==") private static __eq(left: String | null, right: String | null): bool {
    if (left === right) return true;
    if (left === null || right === null) return false;
    var leftLength = left.length;
    if (leftLength != right.length) return false;
    // @ts-ignore: string <-> String
    return !compareImpl(left, 0, right, 0, leftLength);
  }

  @operator.prefix("!")
  private static __not(str: String | null): bool {
    return str === null || !str.length;
  }

  @operator("!=")
  private static __ne(left: String | null, right: String | null): bool {
    return !this.__eq(left, right);
  }

  @operator(">") private static __gt(left: String, right: String): bool {
    if (left === right) return false;
    var leftLength  = left.length;
    if (!leftLength) return false;
    var rightLength = right.length;
    if (!rightLength) return true;
    // @ts-ignore: string <-> String
    var res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));
    return res ? res > 0 : leftLength > rightLength;
  }

  @operator(">=") private static __gte(left: String, right: String): bool {
    return !this.__lt(left, right);
  }

  @operator("<") private static __lt(left: String, right: String): bool {
    if (left === right) return false;
    var rightLength = right.length;
    if (!rightLength) return false;
    var leftLength  = left.length;
    if (!leftLength) return true;
    // @ts-ignore: string <-> String
    var res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));
    return res ? res < 0 : leftLength < rightLength;
  }

  @operator("<=") private static __lte(left: String, right: String): bool {
    return !this.__gt(left, right);
  }

  includes(search: String, start: i32 = 0): bool {
    return this.indexOf(search, start) != -1;
  }

  indexOf(search: String, start: i32 = 0): i32 {
    var searchLen = <isize>search.length;
    if (!searchLen) return 0;
    var len = <isize>this.length;
    if (!len) return -1;
    var searchStart = min(max(<isize>start, 0), len);
    for (len -= searchLen; searchStart <= len; ++searchStart) {
      // @ts-ignore: string <-> String
      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;
    }
    return -1;
  }

  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {
    var searchLen = <isize>search.length;
    if (!searchLen) return this.length;
    var len = this.length;
    if (!len) return -1;
    var searchStart = min(max(<isize>start, 0), <isize>len - searchLen);
    for (; searchStart >= 0; --searchStart) {
      // @ts-ignore: string <-> String
      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;
    }
    return -1;
  }

  // TODO: implement full locale comparison with locales and Collator options
  localeCompare(other: String): i32 {
    if (other === this) return 0; // compare pointers
    var len: isize = this.length;
    var otherLen: isize = other.length;
    if (otherLen != len) return select(1, -1, len > otherLen);
    if (!otherLen) return 0; // "" == ""
    // @ts-ignore: string <-> String
    return compareImpl(this, 0, other, 0, otherLen);
  }

  startsWith(search: String, start: i32 = 0): bool {
    var len = <isize>this.length;
    var searchStart = min(max(<isize>start, 0), len);
    var searchLength = <isize>search.length;
    if (searchLength + searchStart > len) return false;
    // @ts-ignore: string <-> String
    return !compareImpl(this, searchStart, search, 0, searchLength);
  }

  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy
    var intStart: isize = start;
    var end: isize = length;
    var len: isize = this.length;
    if (intStart < 0) intStart = max(len + intStart, 0);
    var size = min(max(end, 0), len - intStart) << 1;
    if (size <= 0) return changetype<String>("");
    var out = changetype<String>(__new(size, idof<String>()));
    memory.copy(changetype<usize>(out), changetype<usize>(this) + (intStart << 1), size);
    return out;
  }

  substring(start: i32, end: i32 = i32.MAX_VALUE): String {
    var len: isize = this.length;
    var finalStart = min<isize>(max(start, 0), len);
    var finalEnd = min<isize>(max(end, 0), len);
    var fromPos = min<isize>(finalStart, finalEnd) << 1;
    var toPos = max<isize>(finalStart, finalEnd) << 1;
    var size = toPos - fromPos;
    if (!size) return changetype<String>("");
    if (!fromPos && toPos == len << 1) return this;
    var out = changetype<String>(__new(size, idof<String>()));
    memory.copy(changetype<usize>(out), changetype<usize>(this) + fromPos, size);
    return out;
  }

  trim(): String {
    var len = this.length;
    var size: usize = len << 1;
    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {
      size -= 2;
    }
    var offset: usize = 0;
    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {
      offset += 2; size -= 2;
    }
    if (!size) return changetype<String>("");
    if (!offset && size == len << 1) return this;
    var out = changetype<String>(__new(size, idof<String>()));
    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);
    return out;
  }

  @inline
  trimLeft(): String {
    return this.trimStart();
  }

  @inline
  trimRight(): String {
    return this.trimEnd();
  }

  trimStart(): String {
    var size = <usize>this.length << 1;
    var offset: usize = 0;
    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {
      offset += 2;
    }
    if (!offset) return this;
    size -= offset;
    if (!size) return changetype<String>("");
    var out = changetype<String>(__new(size, idof<String>()));
    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);
    return out;
  }

  trimEnd(): String {
    var originalSize = <usize>this.length << 1;
    var size = originalSize;
    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {
      size -= 2;
    }
    if (!size) return changetype<String>("");
    if (size == originalSize) return this;
    var out = changetype<String>(__new(size, idof<String>()));
    memory.copy(changetype<usize>(out), changetype<usize>(this), size);
    return out;
  }

  padStart(length: i32, pad: string = " "): String {
    var thisSize = <usize>this.length << 1;
    var targetSize = <usize>length << 1;
    var padSize = <usize>pad.length << 1;
    if (targetSize < thisSize || !padSize) return this;
    var prependSize = targetSize - thisSize;
    var out = changetype<String>(__new(targetSize, idof<String>()));
    if (prependSize > padSize) {
      let repeatCount = (prependSize - 2) / padSize;
      let restBase = repeatCount * padSize;
      let restSize = prependSize - restBase;
      memory.repeat(changetype<usize>(out), changetype<usize>(pad), padSize, repeatCount);
      memory.copy(changetype<usize>(out) + restBase, changetype<usize>(pad), restSize);
    } else {
      memory.copy(changetype<usize>(out), changetype<usize>(pad), prependSize);
    }
    memory.copy(changetype<usize>(out) + prependSize, changetype<usize>(this), thisSize);
    return out;
  }

  padEnd(length: i32, pad: string = " "): String {
    var thisSize = <usize>this.length << 1;
    var targetSize = <usize>length << 1;
    var padSize = <usize>pad.length << 1;
    if (targetSize < thisSize || !padSize) return this;
    var appendSize = targetSize - thisSize;
    var out = changetype<String>(__new(targetSize, idof<String>()));
    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);
    if (appendSize > padSize) {
      let repeatCount = (appendSize - 2) / padSize;
      let restBase = repeatCount * padSize;
      let restSize = appendSize - restBase;
      memory.repeat(changetype<usize>(out) + thisSize, changetype<usize>(pad), padSize, repeatCount);
      memory.copy(changetype<usize>(out) + thisSize + restBase, changetype<usize>(pad), restSize);
    } else {
      memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(pad), appendSize);
    }
    return out;
  }

  repeat(count: i32 = 0): String {
    var length = this.length;

    // Most browsers can't handle strings 1 << 28 chars or longer
    if (count < 0 || <u64>length * count > (1 << 28)) {
      throw new RangeError(E_INVALIDLENGTH);
    }

    if (count == 0 || !length) return changetype<String>("");
    if (count == 1) return this;
    var out = changetype<String>(__new((length * count) << 1, idof<String>()));
    memory.repeat(changetype<usize>(out), changetype<usize>(this), <usize>length << 1, count);
    return out;
  }

  replace(search: String, replacement: String): String {
    var len: usize = this.length;
    var slen: usize = search.length;
    if (len <= slen) {
      return len < slen ? this : select<String>(replacement, this, search == this);
    }
    var index: isize = this.indexOf(search);
    if (~index) {
      let rlen: usize = replacement.length;
      len -= slen;
      let olen = len + rlen;
      if (olen) {
        let out = changetype<String>(__new(olen << 1, idof<String>()));
        memory.copy(changetype<usize>(out), changetype<usize>(this), index << 1);
        memory.copy(
          changetype<usize>(out) + (index << 1),
          changetype<usize>(replacement),
          rlen << 1
        );
        memory.copy(
          changetype<usize>(out) + ((index + rlen) << 1),
          changetype<usize>(this) + ((index + slen) << 1),
          (len - index) << 1
        );
        return out;
      }
    }
    return this;
  }

  replaceAll(search: String, replacement: String): String {
    var thisLen: usize = this.length;
    var searchLen: usize = search.length;
    if (thisLen <= searchLen) {
      return thisLen < searchLen
        ? this
        : select<String>(replacement, this, search == this);
    }
    var replaceLen: usize = replacement.length;
    if (!searchLen) {
      if (!replaceLen) return this;
      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'
      let out = changetype<String>(__new((thisLen + (thisLen + 1) * replaceLen) << 1, idof<String>()));
      memory.copy(changetype<usize>(out), changetype<usize>(replacement), replaceLen << 1);
      let offset = replaceLen;
      for (let i: usize = 0; i < thisLen; ++i) {
        store<u16>(
          changetype<usize>(out) + (offset++ << 1),
          load<u16>(changetype<usize>(this) + (i << 1))
        );
        memory.copy(
          changetype<usize>(out) + (offset << 1),
          changetype<usize>(replacement),
          replaceLen << 1
        );
        offset += replaceLen;
      }
      return out;
    }
    var prev: isize = 0, next: isize = 0;
    if (searchLen == replaceLen) {
      // Fast path when search and replacement have same length
      let outSize = thisLen << 1;
      let out = changetype<String>(__new(outSize, idof<String>()));
      memory.copy(changetype<usize>(out), changetype<usize>(this), outSize);
      while (~(next = <isize>this.indexOf(search, <i32>prev))) {
        memory.copy(changetype<usize>(out) + (next << 1), changetype<usize>(replacement), replaceLen << 1);
        prev = next + searchLen;
      }
      return out;
    }
    var out: String | null = null, offset: usize = 0, outSize = thisLen;
    while (~(next = <isize>this.indexOf(search, <i32>prev))) {
      if (!out) out = changetype<String>(__new(thisLen << 1, idof<String>()));
      let chunk = next - prev;
      if (offset + chunk + replaceLen > outSize) {
        outSize <<= 1;
        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));
      }
      memory.copy(
        changetype<usize>(out) + (offset << 1),
        changetype<usize>(this) + (prev << 1),
        chunk << 1
      );
      offset += chunk;
      memory.copy(
        changetype<usize>(out) + (offset << 1),
        changetype<usize>(replacement),
        replaceLen << 1
      );
      offset += replaceLen;
      prev = next + searchLen;
    }
    if (out) {
      let rest = thisLen - prev;
      if (offset + rest > outSize) {
        outSize <<= 1;
        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));
      }
      if (rest) {
        memory.copy(
          changetype<usize>(out) + (offset << 1),
          changetype<usize>(this) + (prev << 1),
          rest << 1
        );
      }
      rest += offset;
      if (outSize > rest) {
        out = changetype<String>(__renew(changetype<usize>(out), rest << 1));
      }
      return out;
    }
    return this;
  }

  slice(start: i32, end: i32 = i32.MAX_VALUE): String {
    var len = this.length;
    start = start < 0 ? max(start + len, 0) : min(start, len);
    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);
    len   = end - start;
    if (len <= 0) return changetype<String>("");
    var out = changetype<String>(__new(len << 1, idof<String>()));
    memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);
    return out;
  }

  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {
    if (!limit) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));
    if (separator === null) return [this];
    var length: isize = this.length;
    var sepLen = separator.length;
    if (limit < 0) limit = i32.MAX_VALUE;
    if (!sepLen) {
      if (!length) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));
      // split by chars
      length = min<isize>(length, <isize>limit);
      let result = changetype<String[]>(__newArray(<i32>length, alignof<String>(), idof<Array<String>>()));
      // @ts-ignore: cast
      let resultStart = result.dataStart as usize;
      for (let i: isize = 0; i < length; ++i) {
        let charStr = changetype<String>(__new(2, idof<String>()));
        store<u16>(changetype<usize>(charStr), load<u16>(changetype<usize>(this) + (<usize>i << 1)));
        store<usize>(resultStart + (<usize>i << alignof<usize>()), changetype<usize>(charStr)); // result[i] = charStr
        __link(changetype<usize>(result), changetype<usize>(charStr), true);
      }
      return result;
    } else if (!length) {
      let result = changetype<String[]>(__newArray(1, alignof<String>(), idof<Array<String>>()));
      // @ts-ignore: cast
      store<usize>(result.dataStart as usize, changetype<usize>("")); // static ""
      return result;
    }
    var result = changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));
    var end = 0, start = 0, i = 0;
    while (~(end = this.indexOf(separator, start))) {
      let len = end - start;
      if (len > 0) {
        let out = changetype<String>(__new(<usize>len << 1, idof<String>()));
        memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);
        result.push(out);
      } else {
        result.push(changetype<String>(""));
      }
      if (++i == limit) return result;
      start = end + sepLen;
    }
    if (!start) { // also means: loop above didn't do anything
      result.push(this);
      return result;
    }
    var len = length - start;
    if (len > 0) {
      let out = changetype<String>(__new(<usize>len << 1, idof<String>()));
      memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);
      result.push(out);
    } else {
      result.push(changetype<String>("")); // static ""
    }
    return result;
  }

  toLowerCase(): String {
    var len = <usize>this.length;
    if (!len) return this;
    var codes = changetype<String>(__new(len * 2 * 2, idof<String>()));
    var j: usize = 0;
    for (let i: usize = 0; i < len; ++i, ++j) {
      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));
      if (isAscii(c)) {
        store<u16>(changetype<usize>(codes) + (j << 1), toLower8(c));
      } else {
        // check and read surrogate pair
        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {
          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);
          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {
            let c0 = c;
            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;
            ++i;
            if (c >= 0x20000) {
              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));
              ++j;
              continue;
            }
          }
        }
        // check special casing for lower table. It has one ently so instead lookup we just inline this.
        if (c == 0x0130) {
          // 0x0130 -> [0x0069, 0x0307]
          store<u32>(changetype<usize>(codes) + (j << 1), (0x0307 << 16) | 0x0069);
          ++j;
        } else if (c == 0x03A3) { // 'Î£'
          // Î£ maps to Ïƒ but except at the end of a word where it maps to Ï‚
          let sigma = 0x03C3; // Ïƒ
          if (len > 1 && isFinalSigma(changetype<usize>(this), i, len)) {
            sigma = 0x03C2; // Ï‚
          }
          store<u16>(changetype<usize>(codes) + (j << 1), sigma);
        } else if (c - 0x24B6 <= 0x24CF - 0x24B6) {
          // Range 0x24B6 <= c <= 0x24CF not covered by casemap and require special early handling
          store<u16>(changetype<usize>(codes) + (j << 1), c + 26);
        } else {
          let code = casemap(c, 0) & 0x1FFFFF;
          if (code < 0x10000) {
            store<u16>(changetype<usize>(codes) + (j << 1), code);
          } else {
            // store as surrogare pair
            code -= 0x10000;
            let lo = (code >>> 10) | 0xD800;
            let hi = (code & 0x03FF) | 0xDC00;
            store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));
            ++j;
          }
        }
      }
    }
    return changetype<String>(__renew(changetype<usize>(codes), j << 1));
  }

  toUpperCase(): String {
    var len = <usize>this.length;
    if (!len) return this;
    var codes = changetype<String>(__new(len * 3 * 2, idof<String>()));
    var specialsPtr = changetype<usize>(SPECIALS_UPPER);
    var specialsLen = SPECIALS_UPPER.length;
    var j: usize = 0;
    for (let i: usize = 0; i < len; ++i, ++j) {
      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));
      if (isAscii(c)) {
        store<u16>(changetype<usize>(codes) + (j << 1), toUpper8(c));
      } else {
        // check and read surrogate pair
        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {
          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);
          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {
            let c0 = c;
            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;
            ++i;
            if (c >= 0x20000) {
              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));
              ++j;
              continue;
            }
          }
        }
        // Range 0x24D0 <= c <= 0x24E9 not covered by casemap and require special early handling
        if (c - 0x24D0 <= 0x24E9 - 0x24D0) {
          // monkey patch
          store<u16>(changetype<usize>(codes) + (j << 1), c - 26);
        } else {
          let index: usize = -1;
          // Fast range check. See first and last rows in specialsUpper table
          if (c - 0x00DF <= 0xFB17 - 0x00DF) {
            index = <usize>bsearch(c, specialsPtr, specialsLen);
          }
          if (~index) {
            // load next 3 code points from row with `index` offset for specialsUpper table
            let ab = load<u32>(specialsPtr + (index << 1), 2);
            let cc = load<u16>(specialsPtr + (index << 1), 6);
            store<u32>(changetype<usize>(codes) + (j << 1), ab, 0);
            store<u16>(changetype<usize>(codes) + (j << 1), cc, 4);
            j += 1 + usize(cc != 0);
          } else {
            let code = casemap(c, 1) & 0x1FFFFF;
            if (code < 0x10000) {
              store<u16>(changetype<usize>(codes) + (j << 1), code);
            } else {
              // store as surrogare pair
              code -= 0x10000;
              let lo = (code >>> 10) | 0xD800;
              let hi = (code & 0x03FF) | 0xDC00;
              store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));
              ++j;
            }
          }
        }
      }
    }
    return changetype<String>(__renew(changetype<usize>(codes), j << 1));
  }

  toString(): String {
    return this;
  }
}

// @ts-ignore: nolib
export type string = String;

export function parseInt(str: string, radix: i32 = 0): f64 {
  return strtol<f64>(str, radix);
}

export function parseFloat(str: string): f64 {
  return strtod(str);
}

// Encoding helpers
export namespace String {

  export namespace UTF8 {

    export const enum ErrorMode {
      WTF8,
      REPLACE,
      ERROR
    }

    export function byteLength(str: string, nullTerminated: bool = false): i32 {
      var strOff = changetype<usize>(str);
      var strEnd = strOff + <usize>changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;
      var bufLen = i32(nullTerminated);
      while (strOff < strEnd) {
        let c1 = <u32>load<u16>(strOff);
        if (c1 < 128) {
          // @ts-ignore: cast
          if (nullTerminated & !c1) break;
          bufLen += 1;
        } else if (c1 < 2048) {
          bufLen += 2;
        } else {
          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {
            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {
              bufLen += 4; strOff += 4;
              continue;
            }
          }
          bufLen += 3;
        }
        strOff += 2;
      }
      return bufLen;
    }

    export function encode(str: string, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): ArrayBuffer {
      var buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str, nullTerminated), idof<ArrayBuffer>()));
      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf), nullTerminated, errorMode);
      return buf;
    }

    // @ts-ignore: decorator
    @unsafe
    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): usize {
      var strEnd = str + (<usize>len << 1);
      var bufOff = buf;
      while (str < strEnd) {
        let c1 = <u32>load<u16>(str);
        if (c1 < 128) {
          store<u8>(bufOff, c1);
          bufOff++;
        } else if (c1 < 2048) {
          let b0 = c1 >> 6 | 192;
          let b1 = c1 & 63 | 128;
          store<u16>(bufOff, b1 << 8 | b0);
          bufOff += 2;
        } else {
          // D800: 11011 0 0000000000 Lead
          // DBFF: 11011 0 1111111111
          // DC00: 11011 1 0000000000 Trail
          // DFFF: 11011 1 1111111111
          // F800: 11111 0 0000000000 Mask
          // FC00: 11111 1 0000000000
          if ((c1 & 0xF800) == 0xD800) {
            if (c1 < 0xDC00 && str + 2 < strEnd) {
              let c2 = <u32>load<u16>(str, 2);
              if ((c2 & 0xFC00) == 0xDC00) {
                c1 = 0x10000 + ((c1 & 0x03FF) << 10) | (c2 & 0x03FF);
                let b0 = c1 >> 18 | 240;
                let b1 = c1 >> 12 & 63 | 128;
                let b2 = c1 >> 6  & 63 | 128;
                let b3 = c1       & 63 | 128;
                store<u32>(bufOff, b3 << 24 | b2 << 16 | b1 << 8 | b0);
                bufOff += 4; str += 4;
                continue;
              }
            }
            if (errorMode != ErrorMode.WTF8) { // unlikely
              if (errorMode == ErrorMode.ERROR) throw new Error(E_UNPAIRED_SURROGATE);
              c1 = 0xFFFD;
            }
          }
          let b0 = c1 >> 12 | 224;
          let b1 = c1 >> 6  & 63 | 128;
          let b2 = c1       & 63 | 128;
          store<u16>(bufOff, b1 << 8 | b0);
          store<u8>(bufOff, b2, 2);
          bufOff += 3;
        }
        str += 2;
      }
      if (nullTerminated) {
        store<u8>(bufOff++, 0);
      }
      return bufOff - buf;
    }

    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): String {
      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);
    }

    // @ts-ignore: decorator
    @unsafe
    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): String {
      var bufOff = buf;
      var bufEnd = buf + len;
      assert(bufEnd >= bufOff); // guard wraparound
      var str = changetype<String>(__new(len << 1, idof<String>())); // max is one u16 char per u8 byte
      var strOff = changetype<usize>(str);
      while (bufOff < bufEnd) {
        let u0 = <u32>load<u8>(bufOff); ++bufOff;
        if (!(u0 & 128)) {
          // @ts-ignore: cast
          if (nullTerminated & !u0) break;
          store<u16>(strOff, u0);
        } else {
          if (bufEnd == bufOff) break;
          let u1 = <u32>load<u8>(bufOff) & 63; ++bufOff;
          if ((u0 & 224) == 192) {
            store<u16>(strOff, (u0 & 31) << 6 | u1);
          } else {
            if (bufEnd == bufOff) break;
            let u2 = <u32>load<u8>(bufOff) & 63; ++bufOff;
            if ((u0 & 240) == 224) {
              u0 = (u0 & 15) << 12 | u1 << 6 | u2;
            } else {
              if (bufEnd == bufOff) break;
              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | <u32>load<u8>(bufOff) & 63;
              ++bufOff;
            }
            if (u0 < 0x10000) {
              store<u16>(strOff, u0);
            } else {
              u0 -= 0x10000;
              let lo = u0 >> 10 | 0xD800;
              let hi = (u0 & 0x03FF) | 0xDC00;
              store<u32>(strOff, lo | (hi << 16));
              strOff += 2;
            }
          }
        }
        strOff += 2;
      }
      return changetype<String>(__renew(changetype<usize>(str), strOff - changetype<usize>(str)));
    }
  }

  export namespace UTF16 {

    export function byteLength(str: string): i32 {
      return changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;
    }

    export function encode(str: string): ArrayBuffer {
      var buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str), idof<ArrayBuffer>()));
      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf));
      return buf;
    }

    // @ts-ignore: decorator
    @unsafe
    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize {
      var size = <usize>len << 1;
      memory.copy(buf, changetype<usize>(str), size);
      return size;
    }

    export function decode(buf: ArrayBuffer): String {
      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);
    }

    // @ts-ignore: decorator
    @unsafe
    export function decodeUnsafe(buf: usize, len: usize): String {
      var str = changetype<String>(__new(len &= ~1, idof<String>()));
      memory.copy(changetype<usize>(str), buf, len);
      return str;
    }
  }
}

export class TemplateStringsArray extends Array<string> {
  readonly raw: string[];
}

'''
'''--- std/assembly/symbol.ts ---
import { Map } from "./map";

// @ts-ignore: decorator
@lazy var stringToId: Map<string, usize>;

// @ts-ignore: decorator
@lazy var idToString: Map<usize, string>;

// @ts-ignore: decorator
@lazy var nextId: usize = 12; // Symbol.unscopables + 1

@unmanaged @final abstract class _Symbol {

  // TODO: all of the following default symbols are unused currently yet add to
  // binary size if #toString becomes compiled. Ultimately we'll most likely want
  // to remove the unsupported ones and only keep what's actually supported.

  // @ts-ignore: decorator
  @lazy
  static readonly hasInstance: symbol = changetype<symbol>(1);

  // @ts-ignore: decorator
  @lazy
  static readonly isConcatSpreadable: symbol = changetype<symbol>(2);

  // @ts-ignore: decorator
  @lazy
  static readonly isRegExp: symbol = changetype<symbol>(3);

  // @ts-ignore: decorator
  @lazy
  static readonly iterator: symbol = changetype<symbol>(3);

  // @ts-ignore: decorator
  @lazy
  static readonly match: symbol = changetype<symbol>(4);

  // @ts-ignore: decorator
  @lazy
  static readonly replace: symbol = changetype<symbol>(5);

  // @ts-ignore: decorator
  @lazy
  static readonly search: symbol = changetype<symbol>(6);

  // @ts-ignore: decorator
  @lazy
  static readonly species: symbol = changetype<symbol>(7);

  // @ts-ignore: decorator
  @lazy
  static readonly split: symbol = changetype<symbol>(8);

  // @ts-ignore: decorator
  @lazy
  static readonly toPrimitive: symbol = changetype<symbol>(9);

  // @ts-ignore: decorator
  @lazy
  static readonly toStringTag: symbol = changetype<symbol>(10);

  // @ts-ignore: decorator
  @lazy
  static readonly unscopables: symbol = changetype<symbol>(11);

  static for(key: string): symbol {
    if (!stringToId) { stringToId = new Map(); idToString = new Map(); }
    else if (stringToId.has(key)) return changetype<symbol>(stringToId.get(key));
    var id = nextId++;
    if (!id) unreachable(); // out of ids
    stringToId.set(key, id);
    idToString.set(id, key);
    return changetype<symbol>(id);
  }

  static keyFor(sym: symbol): string | null {
    return idToString !== null && idToString.has(changetype<usize>(sym))
      ? idToString.get(changetype<usize>(sym))
      : null;
  }

  toString(): string {
    var id = changetype<usize>(this);
    var str = "";
    switch (<u32>id) {
      case 1:  { str = "hasInstance"; break; }
      case 2:  { str = "isConcatSpreadable"; break; }
      case 3:  { str = "isRegExp"; break; }
      case 4:  { str = "match"; break; }
      case 5:  { str = "replace"; break; }
      case 6:  { str = "search"; break; }
      case 7:  { str = "species"; break; }
      case 8:  { str = "split"; break; }
      case 9:  { str = "toPrimitive"; break; }
      case 10: { str = "toStringTag"; break; }
      case 11: { str = "unscopables"; break; }
      default: {
        if (idToString !== null && idToString.has(id)) str = idToString.get(id);
        break;
      }
    }
    return "Symbol(" + str + ")";
  }
}

export function Symbol(description: string | null = null): symbol {
  var id = nextId++;
  if (!id) unreachable(); // out of ids
  return changetype<symbol>(id);
}

export type Symbol = _Symbol;

// @ts-ignore: nolib
export type symbol = _Symbol;

'''
'''--- std/assembly/table.ts ---
import { E_NOTIMPLEMENTED } from "./util/error";

export namespace table {

  export function copy(dst: u32, src: u32, n: u32): void {
    throw new Error(E_NOTIMPLEMENTED);
  }

  export function init(elementIndex: u32, srcOffset: u32, dstOffset: u32, n: u32): void {
    throw new Error(E_NOTIMPLEMENTED);
  }

  export function drop(elementIndex: u32): void {
    throw new Error(E_NOTIMPLEMENTED);
  }
}

'''
'''--- std/assembly/tsconfig.json ---
{
  "extends": "../assembly.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- std/assembly/typedarray.ts ---
import { COMPARATOR, SORT } from "./util/sort";
import { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_NOTIMPLEMENTED } from "./util/error";
import { joinIntegerArray, joinFloatArray } from "./util/string";
import { idof } from "./builtins";
import { ArrayBufferView } from "./arraybuffer";

export class Int8Array extends ArrayBufferView {
  [key: number]: i8;

  // @ts-ignore: decorator
  @lazy
  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i8>();

  constructor(length: i32) {
    super(length, alignof<i8>());
  }

  get length(): i32 {
    return this.byteLength;
  }

  @operator("[]")
  private __get(index: i32): i8 {
    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<i8>(this.dataStart + <usize>index);
  }

  @unsafe @operator("{}")
  private __uget(index: i32): i8 {
    return load<i8>(this.dataStart + <usize>index);
  }

  @operator("[]=")
  private __set(index: i32, value: native<i8>): void {
    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    store<i8>(this.dataStart + <usize>index, value);
  }

  @unsafe @operator("{}=")
  private __uset(index: i32, value: native<i8>): void {
    store<i8>(this.dataStart + <usize>index, value);
  }

  at(index: i32): i8 {
    var len = this.byteLength;
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<i8>(this.dataStart + <usize>index);
  }

  includes(searchElement: i8, fromIndex: i32 = 0): bool {
    return INCLUDES<Int8Array, i8>(this, searchElement, fromIndex);
  }

  indexOf(searchElement: i8, fromIndex: i32 = 0): i32 {
    return INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);
  }

  lastIndexOf(searchElement: i8, fromIndex: i32 = this.length): i32 {
    return LAST_INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);
  }

  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {
    return FILL<Int8Array, i8>(this, value, start, end);
  }

  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {
    SORT<i8>(this.dataStart, this.length, comparator);
    return this;
  }

  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {
    return SLICE<Int8Array, i8>(this, begin, end);
  }

  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {
    return SUBARRAY<Int8Array, i8>(this, begin, end);
  }

  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int8Array {
    return COPY_WITHIN<Int8Array, i8>(this, target, start, end);
  }

  reduce<T>(
    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,
    initialValue: T,
  ): T {
    return REDUCE<Int8Array, i8, T>(this, fn, initialValue);
  }

  reduceRight<T>(
    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,
    initialValue: T,
  ): T {
    return REDUCE_RIGHT<Int8Array, i8, T>(this, fn, initialValue);
  }

  map(fn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {
    return MAP<Int8Array, i8>(this, fn);
  }

  filter(fn: (value: i8, index: i32, self: Int8Array) => bool): Int8Array {
    return FILTER<Int8Array, i8>(this, fn);
  }

  findIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {
    return FIND_INDEX<Int8Array, i8>(this, fn);
  }

  findLastIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {
    return FIND_LAST_INDEX<Int8Array, i8>(this, fn);
  }

  some(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {
    return SOME<Int8Array, i8>(this, fn);
  }

  every(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {
    return EVERY<Int8Array, i8>(this, fn);
  }

  forEach(fn: (value: i8, index: i32, self: Int8Array) => void): void {
    FOREACH<Int8Array, i8>(this, fn);
  }

  reverse(): this {
    return REVERSE<this, i8>(this);
  }

  join(separator: string = ","): string {
    return joinIntegerArray<i8>(this.dataStart, this.length, separator);
  }

  toString(): string {
    return this.join();
  }

  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {
    SET<Int8Array, i8, U, valueof<U>>(this, source, offset);
  }

  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int8Array {
    return WRAP<Int8Array, i8>(buffer, byteOffset, length);
  }
}

export class Uint8Array extends ArrayBufferView {
  [key: number]: u8;

  // @ts-ignore: decorator
  @lazy
  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();

  constructor(length: i32) {
    super(length, alignof<u8>());
  }

  get length(): i32 {
    return this.byteLength;
  }

  @operator("[]")
  private __get(index: i32): u8 {
    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<u8>(this.dataStart + <usize>index);
  }

  @unsafe @operator("{}")
  private __uget(index: i32): u8 {
    return load<u8>(this.dataStart + <usize>index);
  }

  @operator("[]=")
  private __set(index: i32, value: native<u8>): void {
    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    store<u8>(this.dataStart + <usize>index, value);
  }

  @unsafe @operator("{}=")
  private __uset(index: i32, value: native<u8>): void {
    store<u8>(this.dataStart + <usize>index, value);
  }

  at(index: i32): u8 {
    var len = this.byteLength;
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<u8>(this.dataStart + <usize>index);
  }

  includes(searchElement: u8, fromIndex: i32 = 0): bool {
    return INCLUDES<Uint8Array, u8>(this, searchElement, fromIndex);
  }

  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {
    return INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);
  }

  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {
    return LAST_INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);
  }

  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {
    return FILL<Uint8Array, u8>(this, value, start, end);
  }

  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {
    SORT<u8>(this.dataStart, this.length, comparator);
    return this;
  }

  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {
    return SLICE<Uint8Array, u8>(this, begin, end);
  }

  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {
    return SUBARRAY<Uint8Array, u8>(this, begin, end);
  }

  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8Array {
    return COPY_WITHIN<Uint8Array, u8>(this, target, start, end);
  }

  reduce<T>(
    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,
    initialValue: T,
  ): T {
    return REDUCE<Uint8Array, u8, T>(this, fn, initialValue);
  }

  reduceRight<T>(
    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,
    initialValue: T,
  ): T {
    return REDUCE_RIGHT<Uint8Array, u8, T>(this, fn, initialValue);
  }

  map(fn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {
    return MAP<Uint8Array, u8>(this, fn);
  }

  filter(fn: (value: u8, index: i32, self: Uint8Array) => bool): Uint8Array {
    return FILTER<Uint8Array, u8>(this, fn);
  }

  findIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {
    return FIND_INDEX<Uint8Array, u8>(this, fn);
  }

  findLastIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {
    return FIND_LAST_INDEX<Uint8Array, u8>(this, fn);
  }

  some(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {
    return SOME<Uint8Array, u8>(this, fn);
  }

  every(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {
    return EVERY<Uint8Array, u8>(this, fn);
  }

  forEach(fn: (value: u8, index: i32, self: Uint8Array) => void): void {
    FOREACH<Uint8Array, u8>(this, fn);
  }

  reverse(): this {
    return REVERSE<this, u8>(this);
  }

  join(separator: string = ","): string {
    return joinIntegerArray<u8>(this.dataStart, this.length, separator);
  }

  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {
    SET<Uint8Array, u8, U, valueof<U>>(this, source, offset);
  }

  toString(): string {
    return this.join();
  }

  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8Array {
    return WRAP<Uint8Array, u8>(buffer, byteOffset, length);
  }
}

export class Uint8ClampedArray extends ArrayBufferView {
  [key: number]: u8;

  // @ts-ignore: decorator
  @lazy
  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();

  constructor(length: i32) {
    super(length, alignof<u8>());
  }

  get length(): i32 {
    return this.byteLength;
  }

  @operator("[]")
  private __get(index: i32): u8 {
    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<u8>(this.dataStart + <usize>index);
  }

  @unsafe @operator("{}")
  private __uget(index: i32): u8 {
    return load<u8>(this.dataStart + <usize>index);
  }

  @operator("[]=")
  private __set(index: i32, value: native<u8>): void {
    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);
    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));
  }

  @unsafe @operator("{}=")
  private __uset(index: i32, value: native<u8>): void {
    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));
  }

  at(index: i32): u8 {
    var len = this.byteLength;
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<u8>(this.dataStart + <usize>index);
  }

  includes(searchElement: u8, fromIndex: i32 = 0): bool {
    return INCLUDES<Uint8ClampedArray, u8>(this, searchElement, fromIndex);
  }

  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {
    return INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);
  }

  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {
    return LAST_INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);
  }

  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {
    return FILL<Uint8ClampedArray, u8>(this, value, start, end);
  }

  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {
    SORT<u8>(this.dataStart, this.length, comparator);
    return this;
  }

  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {
    return SLICE<Uint8ClampedArray, u8>(this, begin, end);
  }

  subarray(start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {
    return SUBARRAY<Uint8ClampedArray, u8>(this, start, end);
  }

  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {
    return COPY_WITHIN<Uint8ClampedArray, u8>(this, target, start, end);
  }

  reduce<T>(
    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,
    initialValue: T,
  ): T {
    return REDUCE<Uint8ClampedArray, u8, T>(this, fn, initialValue);
  }

  reduceRight<T>(
    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,
    initialValue: T,
  ): T {
    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, fn, initialValue);
  }

  map(fn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {
    return MAP<Uint8ClampedArray, u8>(this, fn);
  }

  filter(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): Uint8ClampedArray {
    return FILTER<Uint8ClampedArray, u8>(this, fn);
  }

  findIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {
    return FIND_INDEX<Uint8ClampedArray, u8>(this, fn);
  }

  findLastIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {
    return FIND_LAST_INDEX<Uint8ClampedArray, u8>(this, fn);
  }

  some(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {
    return SOME<Uint8ClampedArray, u8>(this, fn);
  }

  every(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {
    return EVERY<Uint8ClampedArray, u8>(this, fn);
  }

  forEach(fn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {
    FOREACH<Uint8ClampedArray, u8>(this, fn);
  }

  reverse(): this {
    return REVERSE<this, u8>(this);
  }

  join(separator: string = ","): string {
    return joinIntegerArray<u8>(this.dataStart, this.length, separator);
  }

  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {
    SET<Uint8ClampedArray, u8, U, valueof<U>>(this, source, offset);
  }

  toString(): string {
    return this.join();
  }

  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8ClampedArray {
    return WRAP<Uint8ClampedArray, u8>(buffer, byteOffset, length);
  }
}

export class Int16Array extends ArrayBufferView {
  [key: number]: i16;

  // @ts-ignore: decorator
  @lazy
  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i16>();

  constructor(length: i32) {
    super(length, alignof<i16>());
  }

  get length(): i32 {
    return this.byteLength >>> alignof<i16>();
  }

  @operator("[]")
  private __get(index: i32): i16 {
    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));
  }

  @unsafe @operator("{}")
  private __uget(index: i32): i16 {
    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));
  }

  @operator("[]=")
  private __set(index: i32, value: native<i16>): void {
    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);
    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);
  }

  @unsafe @operator("{}=")
  private __uset(index: i32, value: native<i16>): void {
    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);
  }

  at(index: i32): i16 {
    var len = this.byteLength >>> alignof<i16>();
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));
  }

  includes(searchElement: i16, fromIndex: i32 = 0): bool {
    return INCLUDES<Int16Array, i16>(this, searchElement, fromIndex);
  }

  indexOf(searchElement: i16, fromIndex: i32 = 0): i32 {
    return INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);
  }

  lastIndexOf(searchElement: i16, fromIndex: i32 = this.length): i32 {
    return LAST_INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);
  }

  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {
    return FILL<Int16Array, i16>(this, value, start, end);
  }

  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {
    SORT<i16>(this.dataStart, this.length, comparator);
    return this;
  }

  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {
    return SLICE<Int16Array, i16>(this, begin, end);
  }

  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {
    return SUBARRAY<Int16Array, i16>(this, begin, end);
  }

  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int16Array {
    return COPY_WITHIN<Int16Array, i16>(this, target, start, end);
  }

  reduce<T>(
    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,
    initialValue: T,
  ): T {
    return REDUCE<Int16Array, i16, T>(this, fn, initialValue);
  }

  reduceRight<T>(
    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,
    initialValue: T,
  ): T {
    return REDUCE_RIGHT<Int16Array, i16, T>(this, fn, initialValue);
  }

  map(fn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {
    return MAP<Int16Array, i16>(this, fn);
  }

  filter(fn: (value: i16, index: i32, self: Int16Array) => bool): Int16Array {
    return FILTER<Int16Array, i16>(this, fn);
  }

  findIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {
    return FIND_INDEX<Int16Array, i16>(this, fn);
  }

  findLastIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {
    return FIND_LAST_INDEX<Int16Array, i16>(this, fn);
  }

  some(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {
    return SOME<Int16Array, i16>(this, fn);
  }

  every(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {
    return EVERY<Int16Array, i16>(this, fn);
  }

  forEach(fn: (value: i16, index: i32, self: Int16Array) => void): void {
    FOREACH<Int16Array, i16>(this, fn);
  }

  reverse(): this {
    return REVERSE<this, i16>(this);
  }

  join(separator: string = ","): string {
    return joinIntegerArray<i16>(this.dataStart, this.length, separator);
  }

  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {
    SET<Int16Array, i16, U, valueof<U>>(this, source, offset);
  }

  toString(): string {
    return this.join();
  }

  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int16Array {
    return WRAP<Int16Array, i16>(buffer, byteOffset, length);
  }
}

export class Uint16Array extends ArrayBufferView {
  [key: number]: u16;

  // @ts-ignore: decorator
  @lazy
  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u16>();

  constructor(length: i32) {
    super(length, alignof<u16>());
  }

  get length(): i32 {
    return this.byteLength >>> alignof<u16>();
  }

  @operator("[]")
  private __get(index: i32): u16 {
    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));
  }

  @unsafe @operator("{}")
  private __uget(index: i32): u16 {
    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));
  }

  @operator("[]=")
  private __set(index: i32, value: native<u16>): void {
    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);
    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);
  }

  @unsafe @operator("{}=")
  private __uset(index: i32, value: native<u16>): void {
    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);
  }

  at(index: i32): u16 {
    var len = this.byteLength >>> alignof<u16>();
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));
  }

  includes(searchElement: u16, fromIndex: i32 = 0): bool {
    return INCLUDES<Uint16Array, u16>(this, searchElement, fromIndex);
  }

  indexOf(searchElement: u16, fromIndex: i32 = 0): i32 {
    return INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);
  }

  lastIndexOf(searchElement: u16, fromIndex: i32 = this.length): i32 {
    return LAST_INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);
  }

  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {
    return FILL<Uint16Array, u16>(this, value, start, end);
  }

  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {
    SORT<u16>(this.dataStart, this.length, comparator);
    return this;
  }

  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {
    return SLICE<Uint16Array, u16>(this, begin, end);
  }

  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {
    return SUBARRAY<Uint16Array, u16>(this, begin, end);
  }

  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint16Array {
    return COPY_WITHIN<Uint16Array, u16>(this, target, start, end);
  }

  reduce<T>(
    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,
    initialValue: T,
  ): T {
    return REDUCE<Uint16Array, u16, T>(this, fn, initialValue);
  }

  reduceRight<T>(
    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,
    initialValue: T,
  ): T {
    return REDUCE_RIGHT<Uint16Array, u16, T>(this, fn, initialValue);
  }

  map(fn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {
    return MAP<Uint16Array, u16>(this, fn);
  }

  filter(fn: (value: u16, index: i32, self: Uint16Array) => bool): Uint16Array {
    return FILTER<Uint16Array, u16>(this, fn);
  }

  findIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {
    return FIND_INDEX<Uint16Array, u16>(this, fn);
  }

  findLastIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {
    return FIND_LAST_INDEX<Uint16Array, u16>(this, fn);
  }

  some(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {
    return SOME<Uint16Array, u16>(this, fn);
  }

  every(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {
    return EVERY<Uint16Array, u16>(this, fn);
  }

  forEach(fn: (value: u16, index: i32, self: Uint16Array) => void): void {
    FOREACH<Uint16Array, u16>(this, fn);
  }

  reverse(): this {
    return REVERSE<this, u16>(this);
  }

  join(separator: string = ","): string {
    return joinIntegerArray<u16>(this.dataStart, this.length, separator);
  }

  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {
    SET<Uint16Array, u16, U, valueof<U>>(this, source, offset);
  }

  toString(): string {
    return this.join();
  }

  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint16Array {
    return WRAP<Uint16Array, u16>(buffer, byteOffset, length);
  }
}

export class Int32Array extends ArrayBufferView {
  [key: number]: i32;

  // @ts-ignore: decorator
  @lazy
  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i32>();

  constructor(length: i32) {
    super(length, alignof<i32>());
  }

  get length(): i32 {
    return this.byteLength >>> alignof<i32>();
  }

  @operator("[]")
  private __get(index: i32): i32 {
    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));
  }

  @unsafe @operator("{}")
  private __uget(index: i32): i32 {
    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));
  }

  @operator("[]=")
  private __set(index: i32, value: i32): void {
    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);
    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);
  }

  @unsafe @operator("{}=")
  private __uset(index: i32, value: i32): void {
    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);
  }

  at(index: i32): i32 {
    var len = this.byteLength >>> alignof<i32>();
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));
  }

  includes(searchElement: i32, fromIndex: i32 = 0): bool {
    return INCLUDES<Int32Array, i32>(this, searchElement, fromIndex);
  }

  indexOf(searchElement: i32, fromIndex: i32 = 0): i32 {
    return INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);
  }

  lastIndexOf(searchElement: i32, fromIndex: i32 = this.length): i32 {
    return LAST_INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);
  }

  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {
    return FILL<Int32Array, i32>(this, value, start, end);
  }

  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {
    SORT<i32>(this.dataStart, this.length, comparator);
    return this;
  }

  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {
    return SLICE<Int32Array, i32>(this, begin, end);
  }

  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {
    return SUBARRAY<Int32Array, i32>(this, begin, end);
  }

  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int32Array {
    return COPY_WITHIN<Int32Array, i32>(this, target, start, end);
  }

  reduce<T>(
    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,
    initialValue: T,
  ): T {
    return REDUCE<Int32Array, i32, T>(this, fn, initialValue);
  }

  reduceRight<T>(
    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,
    initialValue: T,
  ): T {
    return REDUCE_RIGHT<Int32Array, i32, T>(this, fn, initialValue);
  }

  map(fn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {
    return MAP<Int32Array, i32>(this, fn);
  }

  filter(fn: (value: i32, index: i32, self: Int32Array) => bool): Int32Array {
    return FILTER<Int32Array, i32>(this, fn);
  }

  findIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {
    return FIND_INDEX<Int32Array, i32>(this, fn);
  }

  findLastIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {
    return FIND_LAST_INDEX<Int32Array, i32>(this, fn);
  }

  some(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {
    return SOME<Int32Array, i32>(this, fn);
  }

  every(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {
    return EVERY<Int32Array, i32>(this, fn);
  }

  forEach(fn: (value: i32, index: i32, self: Int32Array) => void): void {
    FOREACH<Int32Array, i32>(this, fn);
  }

  reverse(): this {
    return REVERSE<this, i32>(this);
  }

  join(separator: string = ","): string {
    return joinIntegerArray<i32>(this.dataStart, this.length, separator);
  }

  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {
    SET<Int32Array, i32, U, valueof<U>>(this, source, offset);
  }

  toString(): string {
    return this.join();
  }

  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int32Array {
    return WRAP<Int32Array, i32>(buffer, byteOffset, length);
  }
}

export class Uint32Array extends ArrayBufferView {
  [key: number]: u32;

  // @ts-ignore: decorator
  @lazy
  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u32>();

  constructor(length: i32) {
    super(length, alignof<u32>());
  }

  get length(): i32 {
    return this.byteLength >>> alignof<u32>();
  }

  @operator("[]")
  private __get(index: i32): u32 {
    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));
  }

  @unsafe @operator("{}")
  private __uget(index: i32): u32 {
    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));
  }

  @operator("[]=")
  private __set(index: i32, value: u32): void {
    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);
    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);
  }

  @unsafe @operator("{}=")
  private __uset(index: i32, value: u32): void {
    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);
  }

  at(index: i32): u32 {
    var len = this.byteLength >>> alignof<u32>();
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));
  }

  includes(searchElement: u32, fromIndex: i32 = 0): bool {
    return INCLUDES<Uint32Array, u32>(this, searchElement, fromIndex);
  }

  indexOf(searchElement: u32, fromIndex: i32 = 0): i32 {
    return INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);
  }

  lastIndexOf(searchElement: u32, fromIndex: i32 = this.length): i32 {
    return LAST_INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);
  }

  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {
    return FILL<Uint32Array, u32>(this, value, start, end);
  }

  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {
    SORT<u32>(this.dataStart, this.length, comparator);
    return this;
  }

  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {
    return SLICE<Uint32Array, u32>(this, begin, end);
  }

  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {
    return SUBARRAY<Uint32Array, u32>(this, begin, end);
  }

  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint32Array {
    return COPY_WITHIN<Uint32Array, u32>(this, target, start, end);
  }

  reduce<T>(
    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,
    initialValue: T,
  ): T {
    return REDUCE<Uint32Array, u32, T>(this, fn, initialValue);
  }

  reduceRight<T>(
    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,
    initialValue: T,
  ): T {
    return REDUCE_RIGHT<Uint32Array, u32, T>(this, fn, initialValue);
  }

  map(fn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {
    return MAP<Uint32Array, u32>(this, fn);
  }

  filter(fn: (value: u32, index: i32, self: Uint32Array) => bool): Uint32Array {
    return FILTER<Uint32Array, u32>(this, fn);
  }

  findIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {
    return FIND_INDEX<Uint32Array, u32>(this, fn);
  }

  findLastIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {
    return FIND_LAST_INDEX<Uint32Array, u32>(this, fn);
  }

  some(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {
    return SOME<Uint32Array, u32>(this, fn);
  }

  every(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {
    return EVERY<Uint32Array, u32>(this, fn);
  }

  forEach(fn: (value: u32, index: i32, self: Uint32Array) => void): void {
    FOREACH<Uint32Array, u32>(this, fn);
  }

  reverse(): this {
    return REVERSE<this, u32>(this);
  }

  join(separator: string = ","): string {
    return joinIntegerArray<u32>(this.dataStart, this.length, separator);
  }

  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {
    SET<Uint32Array, u32, U, valueof<U>>(this, source, offset);
  }

  toString(): string {
    return this.join();
  }

  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint32Array {
    return WRAP<Uint32Array, u32>(buffer, byteOffset, length);
  }
}

export class Int64Array extends ArrayBufferView {
  [key: number]: i64;

  // @ts-ignore: decorator
  @lazy
  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i64>();

  constructor(length: i32) {
    super(length, alignof<i64>());
  }

  get length(): i32 {
    return this.byteLength >>> alignof<i64>();
  }

  @operator("[]")
  private __get(index: i32): i64 {
    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));
  }

  @unsafe @operator("{}")
  private __uget(index: i32): i64 {
    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));
  }

  @operator("[]=")
  private __set(index: i32, value: i64): void {
    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);
    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);
  }

  @unsafe @operator("{}=")
  private __uset(index: i32, value: i64): void {
    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);
  }

  at(index: i32): i64 {
    var len = this.byteLength >>> alignof<i64>();
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));
  }

  includes(searchElement: i64, fromIndex: i32 = 0): bool {
    return INCLUDES<Int64Array, i64>(this, searchElement, fromIndex);
  }

  indexOf(searchElement: i64, fromIndex: i32 = 0): i32 {
    return INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);
  }

  lastIndexOf(searchElement: i64, fromIndex: i32 = this.length): i32 {
    return LAST_INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);
  }

  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {
    return FILL<Int64Array, i64>(this, value, start, end);
  }

  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {
    SORT<i64>(this.dataStart, this.length, comparator);
    return this;
  }

  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {
    return SLICE<Int64Array, i64>(this, begin, end);
  }

  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {
    return SUBARRAY<Int64Array, i64>(this, begin, end);
  }

  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int64Array {
    return COPY_WITHIN<Int64Array, i64>(this, target, start, end);
  }

  reduce<T>(
    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,
    initialValue: T,
  ): T {
    return REDUCE<Int64Array, i64, T>(this, fn, initialValue);
  }

  reduceRight<T>(
    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,
    initialValue: T,
  ): T {
    return REDUCE_RIGHT<Int64Array, i64, T>(this, fn, initialValue);
  }

  map(fn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {
    return MAP<Int64Array, i64>(this, fn);
  }

  filter(fn: (value: i64, index: i32, self: Int64Array) => bool): Int64Array {
    return FILTER<Int64Array, i64>(this, fn);
  }

  findIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {
    return FIND_INDEX<Int64Array, i64>(this, fn);
  }

  findLastIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {
    return FIND_LAST_INDEX<Int64Array, i64>(this, fn);
  }

  some(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {
    return SOME<Int64Array, i64>(this, fn);
  }

  every(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {
    return EVERY<Int64Array, i64>(this, fn);
  }

  forEach(fn: (value: i64, index: i32, self: Int64Array) => void): void {
    FOREACH<Int64Array, i64>(this, fn);
  }

  reverse(): this {
    return REVERSE<this, i64>(this);
  }

  join(separator: string = ","): string {
    return joinIntegerArray<i64>(this.dataStart, this.length, separator);
  }

  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {
    SET<Int64Array, i64, U, valueof<U>>(this, source, offset);
  }

  toString(): string {
    return this.join();
  }

  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int64Array {
    return WRAP<Int64Array, i64>(buffer, byteOffset, length);
  }
}

export class Uint64Array extends ArrayBufferView {
  [key: number]: u64;

  // @ts-ignore: decorator
  @lazy
  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u64>();

  constructor(length: i32) {
    super(length, alignof<u64>());
  }

  get length(): i32 {
    return this.byteLength >>> alignof<u64>();
  }

  @operator("[]")
  private __get(index: i32): u64 {
    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));
  }

  @unsafe @operator("{}")
  private __uget(index: i32): u64 {
    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));
  }

  @operator("[]=")
  private __set(index: i32, value: u64): void {
    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);
    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);
  }

  @unsafe @operator("{}=")
  private __uset(index: i32, value: u64): void {
    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);
  }

  at(index: i32): u64 {
    var len = this.byteLength >>> alignof<u64>();
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));
  }

  includes(searchElement: u64, fromIndex: i32 = 0): bool {
    return INCLUDES<Uint64Array, u64>(this, searchElement, fromIndex);
  }

  indexOf(searchElement: u64, fromIndex: i32 = 0): i32 {
    return INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);
  }

  lastIndexOf(searchElement: u64, fromIndex: i32 = this.length): i32 {
    return LAST_INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);
  }

  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {
    return FILL<Uint64Array, u64>(this, value, start, end);
  }

  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {
    SORT<u64>(this.dataStart, this.length, comparator);
    return this;
  }

  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {
    return SLICE<Uint64Array, u64>(this, begin, end);
  }

  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {
    return SUBARRAY<Uint64Array, u64>(this, begin, end);
  }

  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint64Array {
    return COPY_WITHIN<Uint64Array, u64>(this, target, start, end);
  }

  reduce<T>(
    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,
    initialValue: T,
  ): T {
    return REDUCE<Uint64Array, u64, T>(this, fn, initialValue);
  }

  reduceRight<T>(
    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,
    initialValue: T,
  ): T {
    return REDUCE_RIGHT<Uint64Array, u64, T>(this, fn, initialValue);
  }

  map(fn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {
    return MAP<Uint64Array, u64>(this, fn);
  }

  filter(fn: (value: u64, index: i32, self: Uint64Array) => bool): Uint64Array {
    return FILTER<Uint64Array, u64>(this, fn);
  }

  findIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {
    return FIND_INDEX<Uint64Array, u64>(this, fn);
  }

  findLastIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {
    return FIND_LAST_INDEX<Uint64Array, u64>(this, fn);
  }

  some(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {
    return SOME<Uint64Array, u64>(this, fn);
  }

  every(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {
    return EVERY<Uint64Array, u64>(this, fn);
  }

  forEach(fn: (value: u64, index: i32, self: Uint64Array) => void): void {
    FOREACH<Uint64Array, u64>(this, fn);
  }

  reverse(): this {
    return REVERSE<this, u64>(this);
  }

  join(separator: string = ","): string {
    return joinIntegerArray<u64>(this.dataStart, this.length, separator);
  }

  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {
    SET<Uint64Array, u64, U, valueof<U>>(this, source, offset);
  }

  toString(): string {
    return this.join();
  }

  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint64Array {
    return WRAP<Uint64Array, u64>(buffer, byteOffset, length);
  }
}

export class Float32Array extends ArrayBufferView {
  [key: number]: f32;

  // @ts-ignore: decorator
  @lazy
  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f32>();

  constructor(length: i32) {
    super(length, alignof<f32>());
  }

  get length(): i32 {
    return this.byteLength >>> alignof<f32>();
  }

  @operator("[]")
  private __get(index: i32): f32 {
    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));
  }

  @unsafe @operator("{}")
  private __uget(index: i32): f32 {
    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));
  }

  @operator("[]=")
  private __set(index: i32, value: f32): void {
    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);
    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);
  }

  @unsafe @operator("{}=")
  private __uset(index: i32, value: f32): void {
    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);
  }

  at(index: i32): f32 {
    var len = this.byteLength >>> alignof<f32>();
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));
  }

  includes(searchElement: f32, fromIndex: i32 = 0): bool {
    return INCLUDES<Float32Array, f32>(this, searchElement, fromIndex);
  }

  indexOf(searchElement: f32, fromIndex: i32 = 0): i32 {
    return INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);
  }

  lastIndexOf(searchElement: f32, fromIndex: i32 = this.length): i32 {
    return LAST_INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);
  }

  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {
    return FILL<Float32Array, f32>(this, value, start, end);
  }

  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {
    SORT<f32>(this.dataStart, this.length, comparator);
    return this;
  }

  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {
    return SLICE<Float32Array, f32>(this, begin, end);
  }

  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {
    return SUBARRAY<Float32Array, f32>(this, begin, end);
  }

  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float32Array {
    return COPY_WITHIN<Float32Array, f32>(this, target, start, end);
  }

  reduce<T>(
    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,
    initialValue: T,
  ): T {
    return REDUCE<Float32Array, f32, T>(this, fn, initialValue);
  }

  reduceRight<T>(
    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,
    initialValue: T,
  ): T {
    return REDUCE_RIGHT<Float32Array, f32, T>(this, fn, initialValue);
  }

  map(fn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {
    return MAP<Float32Array, f32>(this, fn);
  }

  filter(fn: (value: f32, index: i32, self: Float32Array) => bool): Float32Array {
    return FILTER<Float32Array, f32>(this, fn);
  }

  findIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {
    return FIND_INDEX<Float32Array, f32>(this, fn);
  }

  findLastIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {
    return FIND_LAST_INDEX<Float32Array, f32>(this, fn);
  }

  some(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {
    return SOME<Float32Array, f32>(this, fn);
  }

  every(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {
    return EVERY<Float32Array, f32>(this, fn);
  }

  forEach(fn: (value: f32, index: i32, self: Float32Array) => void): void {
    FOREACH<Float32Array, f32>(this, fn);
  }

  reverse(): this {
    return REVERSE<this, f32>(this);
  }

  join(separator: string = ","): string {
    return joinFloatArray<f32>(this.dataStart, this.length, separator);
  }

  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {
    SET<Float32Array, f32, U, valueof<U>>(this, source, offset);
  }

  toString(): string {
    return this.join();
  }

  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float32Array {
    return WRAP<Float32Array, f32>(buffer, byteOffset, length);
  }
}

export class Float64Array extends ArrayBufferView {
  [key: number]: f64;

  // @ts-ignore: decorator
  @lazy
  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f64>();

  constructor(length: i32) {
    super(length, alignof<f64>());
  }

  get length(): i32 {
    return this.byteLength >>> alignof<f64>();
  }

  @operator("[]")
  private __get(index: i32): f64 {
    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));
  }

  @unsafe @operator("{}")
  private __uget(index: i32): f64 {
    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));
  }

  @operator("[]=")
  private __set(index: i32, value: f64): void {
    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);
    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);
  }

  @unsafe @operator("{}=")
  private __uset(index: i32, value: f64): void {
    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);
  }

  at(index: i32): f64 {
    var len = this.byteLength >>> alignof<f64>();
    index += select(0, len, index >= 0);
    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);
    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));
  }

  includes(searchElement: f64, fromIndex: i32 = 0): bool {
    return INCLUDES<Float64Array, f64>(this, searchElement, fromIndex);
  }

  indexOf(searchElement: f64, fromIndex: i32 = 0): i32 {
    return INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);
  }

  lastIndexOf(searchElement: f64, fromIndex: i32 = this.length): i32 {
    return LAST_INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);
  }

  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {
    return FILL<Float64Array, f64>(this, value, start, end);
  }

  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {
    SORT<f64>(this.dataStart, this.length, comparator);
    return this;
  }

  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {
    return SLICE<Float64Array, f64>(this, begin, end);
  }

  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {
    return SUBARRAY<Float64Array, f64>(this, begin, end);
  }

  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float64Array {
    return COPY_WITHIN<Float64Array, f64>(this, target, start, end);
  }

  reduce<T>(
    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,
    initialValue: T,
  ): T {
    return REDUCE<Float64Array, f64, T>(this, fn, initialValue);
  }

  reduceRight<T>(
    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,
    initialValue: T,
  ): T {
    return REDUCE_RIGHT<Float64Array, f64, T>(this, fn, initialValue);
  }

  map(fn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {
    return MAP<Float64Array, f64>(this, fn);
  }

  filter(fn: (value: f64, index: i32, self: Float64Array) => bool): Float64Array {
    return FILTER<Float64Array, f64>(this, fn);
  }

  findIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {
    return FIND_INDEX<Float64Array, f64>(this, fn);
  }

  findLastIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {
    return FIND_LAST_INDEX<Float64Array, f64>(this, fn);
  }

  some(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {
    return SOME<Float64Array, f64>(this, fn);
  }

  every(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {
    return EVERY<Float64Array, f64>(this, fn);
  }

  forEach(fn: (value: f64, index: i32, self: Float64Array) => void): void {
    FOREACH<Float64Array, f64>(this, fn);
  }

  reverse(): this {
    return REVERSE<this, f64>(this);
  }

  join(separator: string = ","): string {
    return joinFloatArray<f64>(this.dataStart, this.length, separator);
  }

  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {
    SET<Float64Array, f64, U, valueof<U>>(this, source, offset);
  }

  toString(): string {
    return this.join();
  }

  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float64Array {
    return WRAP<Float64Array, f64>(buffer, byteOffset, length);
  }
}

// @ts-ignore: decorator
@inline
function FILL<TArray extends ArrayBufferView, T extends number>(
  array: TArray,
  value: native<T>,
  start: i32,
  end: i32
): TArray {
  var ptr = array.dataStart;
  var len = array.length;
  start = start < 0 ? max(len + start, 0) : min(start, len);
  end   = end   < 0 ? max(len + end,   0) : min(end,   len);
  if (sizeof<T>() == 1) {
    if (start < end) memory.fill(ptr + <usize>start, <u8>value, <usize>(end - start));
  } else {
    for (; start < end; ++start) {
      store<T>(ptr + (<usize>start << alignof<T>()), value);
    }
  }
  return array;
}

// @ts-ignore: decorator
@inline
function SLICE<TArray extends ArrayBufferView, T>(
  array: TArray,
  start: i32,
  end: i32
): TArray {
  var len = array.length;
  start  = start < 0 ? max(start + len, 0) : min(start, len);
  end    = end   < 0 ? max(end   + len, 0) : min(end  , len);
  len = max(end - start, 0);
  var slice = instantiate<TArray>(len);
  memory.copy(
    slice.dataStart,
    array.dataStart + (<usize>start << alignof<T>()),
    <usize>len << alignof<T>()
  );
  return slice;
}

// @ts-ignore: decorator
@inline
function SUBARRAY<TArray extends ArrayBufferView, T>(
  array: TArray,
  begin: i32,
  end: i32
): TArray {
  var len = array.length;
  begin = begin < 0 ? max(len + begin, 0) : min(begin, len);
  end   = end   < 0 ? max(len + end,   0) : min(end,   len);
  end   = max(end, begin);

  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));
  var buf = changetype<usize>(array.buffer);
  store<usize>(changetype<usize>(out), buf, offsetof<TArray>("buffer"));
  __link(changetype<usize>(out), buf, false);
  store<usize>(changetype<usize>(out), array.dataStart + (<usize>begin << alignof<T>()), offsetof<TArray>("dataStart"));
  store<u32>(changetype<usize>(out), (end - begin) << alignof<T>(), offsetof<TArray>("byteLength"));
  return out;
}

// @ts-ignore: decorator
@inline
function COPY_WITHIN<TArray extends ArrayBufferView, T>(
  array: TArray,
  target: i32,
  start: i32,
  end: i32
): TArray {
  var len = array.length;
  var ptr = array.dataStart;

  end   = min<i32>(end, len);
  var to    = target < 0 ? max(len + target, 0) : min(target, len);
  var from  = start < 0 ? max(len + start, 0) : min(start, len);
  var last  = end < 0 ? max(len + end, 0) : min(end, len);
  var count = min(last - from, len - to);

  memory.copy(
    ptr + (<usize>to << alignof<T>()),
    ptr + (<usize>from << alignof<T>()),
    <usize>count << alignof<T>()
  );
  return array;
}

// @ts-ignore: decorator
@inline
function REDUCE<TArray extends ArrayBufferView, T, TRet>(
  array: TArray,
  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,
  initialValue: TRet
): TRet {
  var ptr = array.dataStart;
  for (let i = 0, k = array.length; i < k; i++) {
    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);
  }
  return initialValue;
}

// @ts-ignore: decorator
@inline
function REDUCE_RIGHT<TArray extends ArrayBufferView, T, TRet>(
  array: TArray,
  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,
  initialValue: TRet
): TRet {
  var ptr = array.dataStart;
  for (let i = array.length - 1; i >= 0; i--) {
    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);
  }
  return initialValue;
}

// @ts-ignore: decorator
@inline
function MAP<TArray extends ArrayBufferView, T>(
  array: TArray,
  fn: (value: T, index: i32, self: TArray) => T,
): TArray {
  var len = array.length;
  var ptr = array.dataStart;

  var byteLength = len << alignof<T>();
  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));
  var buf = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));
  for (let i = 0; i < len; i++) {
    store<T>(
      changetype<usize>(buf) + (<usize>i << alignof<T>()),
      fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)
    );
  }
  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>("buffer"));
  __link(changetype<usize>(out), changetype<usize>(buf), false);
  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>("dataStart"));
  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>("byteLength"));
  return out;
}

// @ts-ignore: decorator
@inline
function FILTER<TArray extends ArrayBufferView, T>(
  array: TArray,
  fn: (value: T, index: i32, self: TArray) => bool,
): TArray {
  var len = array.length;
  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));
  var buf = changetype<ArrayBuffer>(__new(len << alignof<T>(), idof<ArrayBuffer>()));
  var dataStart  = array.dataStart;
  var j: usize = 0;
  for (let i = 0; i < len; i++) {
    let value = load<T>(dataStart + (<usize>i << alignof<T>()));
    if (fn(value, i, array)) {
      store<T>(
        changetype<usize>(buf) + (j++ << alignof<T>()),
        value
      );
    }
  }
  // shrink output buffer
  var byteLength = j << alignof<T>();
  var data = __renew(changetype<usize>(buf), byteLength);
  store<usize>(changetype<usize>(out), data, offsetof<TArray>("buffer"));
  __link(changetype<usize>(out), data, false);
  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>("byteLength"));
  store<usize>(changetype<usize>(out), data, offsetof<TArray>("dataStart"));
  return out;
}

// @ts-ignore: decorator
@inline
function FIND_INDEX<TArray extends ArrayBufferView, T>(
  array: TArray,
  fn: (value: T, index: i32, array: TArray) => bool,
): i32 {
  var ptr = array.dataStart;
  for (let i = 0, k = array.length; i < k; i++) {
    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;
  }
  return -1;
}

// @ts-ignore: decorator
@inline
function FIND_LAST_INDEX<TArray extends ArrayBufferView, T>(
  array: TArray,
  fn: (value: T, index: i32, array: TArray) => bool,
): i32 {
  var ptr = array.dataStart;
  for (let i = array.length - 1; i >= 0; --i) {
    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;
  }
  return -1;
}

// @ts-ignore: decorator
@inline
function INCLUDES<TArray extends ArrayBufferView, T>(
  array: TArray,
  searchElement: T,
  fromIndex: i32,
): bool {
  if (isFloat<T>()) {
    let index: isize = fromIndex;
    let len: isize = array.length;
    if (len == 0 || index >= len) return false;
    if (index < 0) index = max(len + index, 0);
    let dataStart = array.dataStart;
    while (index < len) {
      let elem = load<T>(dataStart + (index << alignof<T>()));
      // @ts-ignore
      if (elem == searchElement || isNaN(elem) & isNaN(searchElement)) return true;
      ++index;
    }
    return false;
  } else {
    return INDEX_OF<TArray, T>(array, searchElement, fromIndex) >= 0;
  }
}

// @ts-ignore: decorator
@inline
function INDEX_OF<TArray extends ArrayBufferView, T>(
  array: TArray,
  searchElement: T,
  fromIndex: i32,
): i32 {
  var index: isize = fromIndex;
  var len: isize = array.length;
  if (len == 0 || index >= len) return -1;
  if (index < 0) index = max(len + index, 0);
  var dataStart = array.dataStart;
  while (index < len) {
    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;
    ++index;
  }
  return -1;
}

// @ts-ignore: decorator
@inline
function LAST_INDEX_OF<TArray extends ArrayBufferView, T>(
  array: TArray,
  searchElement: T,
  fromIndex: i32,
): i32 {
  var index: isize = fromIndex;
  var len: isize = array.length;
  if (len == 0) return -1;
  if (index < 0) index = len + index; // no need to clamp
  else if (index >= len) index = len - 1;
  var dataStart = array.dataStart;
  while (index >= 0) {
    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;
    --index;
  }
  return -1;
}

// @ts-ignore: decorator
@inline
function SOME<TArray extends ArrayBufferView, T>(
  array: TArray,
  fn: (value: T, index: i32, array: TArray) => bool,
): bool {
  var ptr = array.dataStart;
  for (let i = 0, k = array.length; i < k; i++) {
    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return true;
  }
  return false;
}

// @ts-ignore: decorator
@inline
function EVERY<TArray extends ArrayBufferView, T>(
  array: TArray,
  fn: (value: T, index: i32, array: TArray) => bool,
): bool {
  var ptr = array.dataStart;
  for (let i = 0, k = array.length; i < k; i++) {
    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) continue;
    return false;
  }
  return true;
}

// @ts-ignore: decorator
@inline
function FOREACH<TArray extends ArrayBufferView, T>(
  array: TArray,
  fn: (value: T, index: i32, array: TArray) => void,
): void {
  var ptr = array.dataStart;
  for (let i = 0, k = array.length; i < k; i++) {
    fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array);
  }
}

// @ts-ignore: decorator
@inline
function REVERSE<TArray extends ArrayBufferView, T>(array: TArray): TArray {
  var ptr = array.dataStart;
  for (let front: usize = 0, back: usize = array.length - 1; front < back; ++front, --back) {
    let frontPtr = ptr + (front << alignof<T>());
    let backPtr = ptr + (back << alignof<T>());
    let temp = load<T>(frontPtr);
    store<T>(frontPtr, load<T>(backPtr));
    store<T>(backPtr, temp);
  }
  return array;
}

// @ts-ignore: decorator
@inline
function WRAP<TArray extends ArrayBufferView, T>(
  buffer: ArrayBuffer,
  byteOffset: i32 = 0,
  len: i32 = -1
): TArray {
  var byteLength: i32;
  var bufferByteLength = buffer.byteLength;
  const mask: u32 = sizeof<T>() - 1;
  if (i32(<u32>byteOffset > <u32>bufferByteLength) | (byteOffset & mask)) {
    throw new RangeError(E_INDEXOUTOFRANGE);
  }
  if (len < 0) {
    if (len == -1) {
      if (bufferByteLength & mask) {
        throw new RangeError(E_INVALIDLENGTH);
      }
      byteLength = bufferByteLength - byteOffset;
    } else {
      throw new RangeError(E_INVALIDLENGTH);
    }
  } else {
    byteLength = len << alignof<T>();
    if (byteOffset + byteLength > bufferByteLength) {
      throw new RangeError(E_INVALIDLENGTH);
    }
  }
  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));
  store<usize>(changetype<usize>(out), changetype<usize>(buffer), offsetof<TArray>("buffer"));
  __link(changetype<usize>(out), changetype<usize>(buffer), false);
  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>("byteLength"));
  store<usize>(changetype<usize>(out), changetype<usize>(buffer) + <usize>byteOffset, offsetof<TArray>("dataStart"));
  return out;
}

// @ts-ignore: decorator
@inline
function SET<TArray extends ArrayBufferView, T, UArray extends ArrayBufferView, U>(
  target: TArray,
  source: UArray,
  offset: i32 = 0
): void {
  // need to assert at compile time that U is not a reference or a function
  if (isReference<U>()) {
    ERROR(E_NOTIMPLEMENTED);
  }

  // Uncaught RangeError: offset is out of bounds
  if (offset < 0) throw new RangeError(E_INDEXOUTOFRANGE);
  if (source.length + offset > target.length) throw new RangeError(E_INDEXOUTOFRANGE);

  // if the types align and match, use memory.copy() instead of manual loop
  if (isInteger<T>() == isInteger<U>() && alignof<T>() == alignof<U>() &&
    !(target instanceof Uint8ClampedArray && isSigned<U>())) {
    memory.copy(
      target.dataStart + (<usize>offset << alignof<T>()),
      source.dataStart,
      source.byteLength
    );
  } else {
    let targetDataStart = target.dataStart + (<usize>offset << alignof<T>());
    let sourceDataStart = source.dataStart;
    let count = source.length;
    for (let i = 0; i < count; i++) {
      // if TArray is Uint8ClampedArray, then values must be clamped
      if (target instanceof Uint8ClampedArray) {
        if (isFloat<U>()) {
          let value = load<U>(sourceDataStart + (<usize>i << alignof<U>()));
          store<T>(
            targetDataStart + (<usize>i << alignof<T>()),
            isFinite<U>(value) ? <T>max<U>(0, min<U>(255, value)) : <T>0
          );
        } else {
          let value = load<U>(sourceDataStart + (<usize>i << alignof<U>()));
          if (!isSigned<U>()) {
            store<T>(
              targetDataStart + (<usize>i << alignof<T>()),
              // @ts-ignore: cast to T is valid for numeric types here
              min<U>(255, value)
            );
          } else if (sizeof<T>() <= 4) {
            store<T>(
              targetDataStart + (<usize>i << alignof<T>()),
              // @ts-ignore: cast to T is valid for numeric types here
              ~(<i32>value >> 31) & (((255 - <i32>value) >> 31) | value)
            );
          } else {
            store<T>(
              targetDataStart + (<usize>i << alignof<T>()),
              // @ts-ignore: cast to T is valid for numeric types here
              ~(<i64>value >> 63) & (((255 - <i64>value) >> 63) | value)
            );
          }
        }
        // if U is a float, then casting float to int must include a finite check
      } else if (isFloat<U>() && !isFloat<T>()) {
        let value = load<U>(sourceDataStart + (<usize>i << alignof<U>()));
        // @ts-ignore: cast to T is valid for numeric types here
        store<T>(targetDataStart + (<usize>i << alignof<T>()), isFinite<U>(value) ? <T>value : 0);
      } else if (isFloat<T>() && !isFloat<U>()) {
        // @ts-ignore: In this case the <T> conversion is required
        store<T>(targetDataStart + (<usize>i << alignof<T>()), <T>load<U>(sourceDataStart + (<usize>i << alignof<U>())));
      } else {
        store<T>(targetDataStart + (<usize>i << alignof<T>()), load<U>(sourceDataStart + (<usize>i << alignof<U>())));
      }
    }
  }
}

'''
'''--- std/assembly/uri.ts ---
import { encode, decode, URI_UNSAFE, URL_UNSAFE } from "./util/uri";

export function encodeURI(str: string): string {
  return changetype<string>(encode(changetype<usize>(str), str.length, URI_UNSAFE));
}

export function decodeURI(str: string): string {
  return changetype<string>(decode(changetype<usize>(str), str.length, false));
}

export function encodeURIComponent(str: string): string {
  return changetype<string>(encode(changetype<usize>(str), str.length, URL_UNSAFE));
}

export function decodeURIComponent(str: string): string {
  return changetype<string>(decode(changetype<usize>(str), str.length, true));
}

'''
'''--- std/assembly/util/casemap.ts ---
// Total tables size: ~5 kb (usually compressed to ~4 kb)
// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/casemap.h

// @ts-ignore: decorator
@lazy @inline const TAB = memory.data<u8>([
  7, 8, 9, 10, 11, 12, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  13, 6, 6, 14, 6, 6, 6, 6, 6, 6, 6, 6, 15, 16, 17, 18,
  6, 19, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 20, 21, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 22, 23, 6, 6, 6, 24, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 25,
  6, 6, 6, 6, 26, 6, 6, 6, 6, 6, 6, 6, 27, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 28, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 29, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 30, 6, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36,
  43, 43, 43, 43, 43, 43, 43, 43, 1, 0, 84, 86, 86, 86, 86, 86,
  86, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 43, 43, 43, 43, 43, 43,
  43, 7, 43, 43, 91, 86, 86, 86, 86, 86, 86, 86, 74, 86, 86, 5,
  49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,
  36, 80, 121, 49, 80, 49, 80, 49, 56, 80, 49, 80, 49, 80, 49, 80,
  49, 80, 49, 80, 49, 80, 49, 80, 78, 49, 2, 78, 13, 13, 78, 3,
  78, 0, 36, 110, 0, 78, 49, 38, 110, 81, 78, 36, 80, 78, 57, 20,
  129, 27, 29, 29, 83, 49, 80, 49, 80, 13, 49, 80, 49, 80, 49, 80,
  27, 83, 36, 80, 49, 2, 92, 123, 92, 123, 92, 123, 92, 123, 92, 123,
  20, 121, 92, 123, 92, 123, 92, 45, 43, 73, 3, 72, 3, 120, 92, 123,
  20, 0, 150, 10, 1, 43, 40, 6, 6, 0, 42, 6, 42, 42, 43, 7,
  187, 181, 43, 30, 0, 43, 7, 43, 43, 43, 1, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 1, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
  43, 205, 70, 205, 43, 0, 37, 43, 7, 1, 6, 1, 85, 86, 86, 86,
  86, 86, 85, 86, 86, 2, 36, 129, 129, 129, 129, 129, 21, 129, 129, 129,
  0, 0, 43, 0, 178, 209, 178, 209, 178, 209, 178, 209, 0, 0, 205, 204,
  1, 0, 215, 215, 215, 215, 215, 131, 129, 129, 129, 129, 129, 129, 129, 129,
  129, 129, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 28, 0, 0, 0,
  0, 0, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 2, 0, 0,
  49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,
  49, 80, 78, 49, 80, 49, 80, 78, 49, 80, 49, 80, 49, 80, 49, 80,
  49, 80, 49, 80, 49, 80, 49, 2, 135, 166, 135, 166, 135, 166, 135, 166,
  135, 166, 135, 166, 135, 166, 135, 166, 42, 43, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 0, 0, 0, 84, 86, 86, 86, 86, 86, 86, 86,
  86, 86, 86, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 84, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
  12, 0, 12, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
  43, 7, 42, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 86, 86, 108, 129, 21, 0, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 7, 108, 3, 65, 43, 43, 86, 86, 86, 86, 86, 86,
  86, 86, 86, 86, 86, 86, 86, 86, 44, 86, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 1,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 12, 108, 0, 0, 0, 0, 0, 6,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,
  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,
  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,
  6, 37, 6, 37, 6, 37, 6, 37, 86, 122, 158, 38, 6, 37, 6, 37,
  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,
  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 1, 43, 43, 79, 86,
  86, 44, 43, 127, 86, 86, 57, 43, 43, 85, 86, 86, 43, 43, 79, 86,
  86, 44, 43, 127, 86, 86, 129, 55, 117, 91, 123, 92, 43, 43, 79, 86,
  86, 2, 172, 4, 0, 0, 57, 43, 43, 85, 86, 86, 43, 43, 79, 86,
  86, 44, 43, 43, 86, 86, 50, 19, 129, 87, 0, 111, 129, 126, 201, 215,
  126, 45, 129, 129, 14, 126, 57, 127, 111, 87, 0, 129, 129, 126, 21, 0,
  126, 3, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 7, 43,
  36, 43, 151, 43, 43, 43, 43, 43, 43, 43, 43, 43, 42, 43, 43, 43,
  43, 43, 86, 86, 86, 86, 86, 128, 129, 129, 129, 129, 57, 187, 42, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 1, 129, 129, 129, 129, 129, 129, 129, 129,
  129, 129, 129, 129, 129, 129, 129, 201, 172, 172, 172, 172, 172, 172, 172, 172,
  172, 172, 172, 172, 172, 172, 172, 208, 13, 0, 78, 49, 2, 180, 193, 193,
  215, 215, 36, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,
  49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,
  49, 80, 49, 80, 215, 215, 83, 193, 71, 212, 215, 215, 215, 5, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 7, 1, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 49, 80, 49, 80, 49, 80,
  49, 80, 49, 80, 49, 80, 49, 80, 13, 0, 0, 0, 0, 0, 36, 80,
  49, 80, 49, 80, 49, 80, 49, 80, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 121, 92, 123, 92, 123, 79, 123, 92, 123, 92, 123,
  92, 123, 92, 123, 92, 123, 92, 123, 92, 123, 92, 123, 92, 123, 92, 45,
  43, 43, 121, 20, 92, 123, 92, 45, 121, 42, 92, 39, 92, 123, 92, 123,
  92, 123, 164, 0, 10, 180, 92, 123, 92, 123, 79, 3, 120, 56, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 79, 45, 43, 43, 1,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 72, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 43, 43, 43, 43, 43, 43, 43, 43, 7, 0, 72, 86, 86, 86, 86,
  86, 86, 86, 86, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 43, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 85, 86, 86, 86, 86, 86, 86,
  86, 86, 86, 86, 86, 86, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 36, 43, 43, 43, 43, 43, 43, 43, 43, 43,
  43, 43, 7, 0, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 43, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 7, 0, 0,
  0, 0, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
  86, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 43, 43,
  43, 43, 43, 43, 43, 43, 43, 43, 86, 86, 86, 86, 86, 86, 86, 86,
  86, 86, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 86, 86,
  86, 86, 86, 86, 86, 86, 86, 86, 14, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 85,
  86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 14, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0
]);

// @ts-ignore: decorator
@lazy @inline const RULES = memory.data<i32>([
  0x0, 0x2001, -0x2000, 0x1dbf00, 0x2e700, 0x7900,
  0x2402, 0x101, -0x100, 0x0, 0x201, -0x200,
  -0xc6ff, -0xe800, -0x78ff, -0x12c00, 0xc300, 0xd201,
  0xce01, 0xcd01, 0x4f01, 0xca01, 0xcb01, 0xcf01,
  0x6100, 0xd301, 0xd101, 0xa300, 0xd501, 0x8200,
  0xd601, 0xda01, 0xd901, 0xdb01, 0x3800, 0x3,
  -0x4f00, -0x60ff, -0x37ff, 0x242802, 0x0, 0x101,
  -0x100, -0xcd00, -0xda00, -0x81ff, 0x2a2b01, -0xa2ff,
  0x2a2801, 0x2a3f00, -0xc2ff, 0x4501, 0x4701, 0x2a1f00,
  0x2a1c00, 0x2a1e00, -0xd200, -0xce00, -0xca00, -0xcb00,
  0xa54f00, 0xa54b00, -0xcf00, 0xa52800, 0xa54400, -0xd100,
  -0xd300, 0x29f700, 0xa54100, 0x29fd00, -0xd500, -0xd600,
  0x29e700, 0xa54300, 0xa52a00, -0x4500, -0xd900, -0x4700,
  -0xdb00, 0xa51500, 0xa51200, 0x4c2402, 0x0, 0x2001,
  -0x2000, 0x101, -0x100, 0x5400, 0x7401, 0x2601,
  0x2501, 0x4001, 0x3f01, -0x2600, -0x2500, -0x1f00,
  -0x4000, -0x3f00, 0x801, -0x3e00, -0x3900, -0x2f00,
  -0x3600, -0x800, -0x5600, -0x5000, 0x700, -0x7400,
  -0x3bff, -0x6000, -0x6ff, 0x701a02, 0x101, -0x100,
  0x2001, -0x2000, 0x5001, 0xf01, -0xf00, 0x0,
  0x3001, -0x3000, 0x101, -0x100, 0x0, 0xbc000,
  0x1c6001, 0x0, 0x97d001, 0x801, -0x800, 0x8a0502,
  0x0, -0xbbfff, -0x186200, 0x89c200, -0x182500, -0x186e00,
  -0x186d00, -0x186400, -0x186300, -0x185c00, 0x0, 0x8a3800,
  0x8a0400, 0xee600, 0x101, -0x100, 0x0, -0x3b00,
  -0x1dbeff, 0x8f1d02, 0x800, -0x7ff, 0x0, 0x5600,
  -0x55ff, 0x4a00, 0x6400, 0x8000, 0x7000, 0x7e00,
  0x900, -0x49ff, -0x8ff, -0x1c2500, -0x63ff, -0x6fff,
  -0x7fff, -0x7dff, 0xac0502, 0x0, 0x1001, -0x1000,
  0x1c01, 0x101, -0x1d5cff, -0x20beff, -0x2045ff, -0x1c00,
  0xb10b02, 0x101, -0x100, 0x3001, -0x3000, 0x0,
  -0x29f6ff, -0xee5ff, -0x29e6ff, -0x2a2b00, -0x2a2800, -0x2a1bff,
  -0x29fcff, -0x2a1eff, -0x2a1dff, -0x2a3eff, 0x0, -0x1c6000,
  0x0, 0x101, -0x100, 0xbc0c02, 0x0, 0x101,
  -0x100, -0xa543ff, 0x3a001, -0x8a03ff, -0xa527ff, 0x3000,
  -0xa54eff, -0xa54aff, -0xa540ff, -0xa511ff, -0xa529ff, -0xa514ff,
  -0x2fff, -0xa542ff, -0x8a37ff, 0x0, -0x97d000, -0x3a000,
  0x0, 0x2001, -0x2000, 0x0, 0x2801, -0x2800,
  0x0, 0x4001, -0x4000, 0x0, 0x2001, -0x2000,
  0x0, 0x2001, -0x2000, 0x0, 0x2201, -0x2200
]);

// @ts-ignore: decorator
@lazy @inline const RULE_BASES = memory.data<u8>([
  0, 6, 39, 81, 111, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  124, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 131, 142, 146, 151,
  0, 170, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 180, 196, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 198, 201, 0, 0, 0, 219, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 222,
  0, 0, 0, 0, 225, 0, 0, 0, 0, 0, 0, 0, 228, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 231, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 234, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 237, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
]);

// @ts-ignore: decorator
@lazy @inline const EXCEPTIONS = memory.data<u8>([
  48, 12,  49, 13,  120, 14,  127, 15,
  128, 16,  129, 17,  134, 18,  137, 19,
  138, 19,  142, 20,  143, 21,  144, 22,
  147, 19,  148, 23,  149, 24,  150, 25,
  151, 26,  154, 27,  156, 25,  157, 28,
  158, 29,  159, 30,  166, 31,  169, 31,
  174, 31,  177, 32,  178, 32,  183, 33,
  191, 34,  197, 35,  200, 35,  203, 35,
  221, 36,  242, 35,  246, 37,  247, 38,
  32, 45,  58, 46,  61, 47,  62, 48,
  63, 49,  64, 49,  67, 50,  68, 51,
  69, 52,  80, 53,  81, 54,  82, 55,
  83, 56,  84, 57,  89, 58,  91, 59,
  92, 60,  97, 61,  99, 62,  101, 63,
  102, 64,  104, 65,  105, 66,  106, 64,
  107, 67,  108, 68,  111, 66,  113, 69,
  114, 70,  117, 71,  125, 72,  130, 73,
  135, 74,  137, 75,  138, 76,  139, 76,
  140, 77,  146, 78,  157, 79,  158, 80,
  69, 87,  123, 29,  124, 29,  125, 29,
  127, 88,  134, 89,  136, 90,  137, 90,
  138, 90,  140, 91,  142, 92,  143, 92,
  172, 93,  173, 94,  174, 94,  175, 94,
  194, 95,  204, 96,  205, 97,  206, 97,
  207, 98,  208, 99,  209, 100,  213, 101,
  214, 102,  215, 103,  240, 104,  241, 105,
  242, 106,  243, 107,  244, 108,  245, 109,
  249, 110,  253, 45,  254, 45,  255, 45,
  80, 105,  81, 105,  82, 105,  83, 105,
  84, 105,  85, 105,  86, 105,  87, 105,
  88, 105,  89, 105,  90, 105,  91, 105,
  92, 105,  93, 105,  94, 105,  95, 105,
  130, 0,  131, 0,  132, 0,  133, 0,
  134, 0,  135, 0,  136, 0,  137, 0,
  192, 117,  207, 118,  128, 137,  129, 138,
  130, 139,  133, 140,  134, 141,  112, 157,
  113, 157,  118, 158,  119, 158,  120, 159,
  121, 159,  122, 160,  123, 160,  124, 161,
  125, 161,  179, 162,  186, 163,  187, 163,
  188, 164,  190, 165,  195, 162,  204, 164,
  218, 166,  219, 166,  229, 106,  234, 167,
  235, 167,  236, 110,  243, 162,  248, 168,
  249, 168,  250, 169,  251, 169,  252, 164,
  38, 176,  42, 177,  43, 178,  78,  179,
  132,  8,  98, 186,  99, 187,  100, 188,
  101, 189,  102, 190,  109, 191,  110, 192,
  111, 193,  112, 194,  126, 195,  127, 195,
  125, 207,  141, 208,  148, 209,  171, 210,
  172, 211,  173, 212,  176, 213,  177, 214,
  178, 215,  196, 216,  197, 217,  198, 218
]);

/* Special Case Mappings
 * See: https://unicode.org/Public/UNIDATA/SpecialCasing.txt
 */

/*
@lazy @inline
const SPECIALS_LOWER: StaticArray<u16> = [
  0x0130,  0x0069, 0x0307, 0x0000,
];
*/

// @ts-ignore: decorator
@lazy @inlne
export const SPECIALS_UPPER: StaticArray<u16> = [
  // String#toUpperCase needs .length
  0x00DF,  0x0053, 0x0053, 0x0000,
  0x0149,  0x02BC, 0x004E, 0x0000,
  0x01F0,  0x004A, 0x030C, 0x0000,
  0x0390,  0x0399, 0x0308, 0x0301,
  0x03B0,  0x03A5, 0x0308, 0x0301,
  0x0587,  0x0535, 0x0552, 0x0000,
  0x1E96,  0x0048, 0x0331, 0x0000,
  0x1E97,  0x0054, 0x0308, 0x0000,
  0x1E98,  0x0057, 0x030A, 0x0000,
  0x1E99,  0x0059, 0x030A, 0x0000,
  0x1E9A,  0x0041, 0x02BE, 0x0000,
  0x1F50,  0x03A5, 0x0313, 0x0000,
  0x1F52,  0x03A5, 0x0313, 0x0300,
  0x1F54,  0x03A5, 0x0313, 0x0301,
  0x1F56,  0x03A5, 0x0313, 0x0342,
  0x1F80,  0x1F08, 0x0399, 0x0000,
  0x1F81,  0x1F09, 0x0399, 0x0000,
  0x1F82,  0x1F0A, 0x0399, 0x0000,
  0x1F83,  0x1F0B, 0x0399, 0x0000,
  0x1F84,  0x1F0C, 0x0399, 0x0000,
  0x1F85,  0x1F0D, 0x0399, 0x0000,
  0x1F86,  0x1F0E, 0x0399, 0x0000,
  0x1F87,  0x1F0F, 0x0399, 0x0000,
  0x1F88,  0x1F08, 0x0399, 0x0000,
  0x1F89,  0x1F09, 0x0399, 0x0000,
  0x1F8A,  0x1F0A, 0x0399, 0x0000,
  0x1F8B,  0x1F0B, 0x0399, 0x0000,
  0x1F8C,  0x1F0C, 0x0399, 0x0000,
  0x1F8D,  0x1F0D, 0x0399, 0x0000,
  0x1F8E,  0x1F0E, 0x0399, 0x0000,
  0x1F8F,  0x1F0F, 0x0399, 0x0000,
  0x1F90,  0x1F28, 0x0399, 0x0000,
  0x1F91,  0x1F29, 0x0399, 0x0000,
  0x1F92,  0x1F2A, 0x0399, 0x0000,
  0x1F93,  0x1F2B, 0x0399, 0x0000,
  0x1F94,  0x1F2C, 0x0399, 0x0000,
  0x1F95,  0x1F2D, 0x0399, 0x0000,
  0x1F96,  0x1F2E, 0x0399, 0x0000,
  0x1F97,  0x1F2F, 0x0399, 0x0000,
  0x1F98,  0x1F28, 0x0399, 0x0000,
  0x1F99,  0x1F29, 0x0399, 0x0000,
  0x1F9A,  0x1F2A, 0x0399, 0x0000,
  0x1F9B,  0x1F2B, 0x0399, 0x0000,
  0x1F9C,  0x1F2C, 0x0399, 0x0000,
  0x1F9D,  0x1F2D, 0x0399, 0x0000,
  0x1F9E,  0x1F2E, 0x0399, 0x0000,
  0x1F9F,  0x1F2F, 0x0399, 0x0000,
  0x1FA0,  0x1F68, 0x0399, 0x0000,
  0x1FA1,  0x1F69, 0x0399, 0x0000,
  0x1FA2,  0x1F6A, 0x0399, 0x0000,
  0x1FA3,  0x1F6B, 0x0399, 0x0000,
  0x1FA4,  0x1F6C, 0x0399, 0x0000,
  0x1FA5,  0x1F6D, 0x0399, 0x0000,
  0x1FA6,  0x1F6E, 0x0399, 0x0000,
  0x1FA7,  0x1F6F, 0x0399, 0x0000,
  0x1FA8,  0x1F68, 0x0399, 0x0000,
  0x1FA9,  0x1F69, 0x0399, 0x0000,
  0x1FAA,  0x1F6A, 0x0399, 0x0000,
  0x1FAB,  0x1F6B, 0x0399, 0x0000,
  0x1FAC,  0x1F6C, 0x0399, 0x0000,
  0x1FAD,  0x1F6D, 0x0399, 0x0000,
  0x1FAE,  0x1F6E, 0x0399, 0x0000,
  0x1FAF,  0x1F6F, 0x0399, 0x0000,
  0x1FB2,  0x1FBA, 0x0399, 0x0000,
  0x1FB3,  0x0391, 0x0399, 0x0000,
  0x1FB4,  0x0386, 0x0399, 0x0000,
  0x1FB6,  0x0391, 0x0342, 0x0000,
  0x1FB7,  0x0391, 0x0342, 0x0399,
  0x1FBC,  0x0391, 0x0399, 0x0000,
  0x1FC2,  0x1FCA, 0x0399, 0x0000,
  0x1FC3,  0x0397, 0x0399, 0x0000,
  0x1FC4,  0x0389, 0x0399, 0x0000,
  0x1FC6,  0x0397, 0x0342, 0x0000,
  0x1FC7,  0x0397, 0x0342, 0x0399,
  0x1FCC,  0x0397, 0x0399, 0x0000,
  0x1FD2,  0x0399, 0x0308, 0x0300,
  0x1FD3,  0x0399, 0x0308, 0x0301,
  0x1FD6,  0x0399, 0x0342, 0x0000,
  0x1FD7,  0x0399, 0x0308, 0x0342,
  0x1FE2,  0x03A5, 0x0308, 0x0300,
  0x1FE3,  0x03A5, 0x0308, 0x0301,
  0x1FE4,  0x03A1, 0x0313, 0x0000,
  0x1FE6,  0x03A5, 0x0342, 0x0000,
  0x1FE7,  0x03A5, 0x0308, 0x0342,
  0x1FF2,  0x1FFA, 0x0399, 0x0000,
  0x1FF3,  0x03A9, 0x0399, 0x0000,
  0x1FF4,  0x038F, 0x0399, 0x0000,
  0x1FF6,  0x03A9, 0x0342, 0x0000,
  0x1FF7,  0x03A9, 0x0342, 0x0399,
  0x1FFC,  0x03A9, 0x0399, 0x0000,
  0xFB00,  0x0046, 0x0046, 0x0000,
  0xFB01,  0x0046, 0x0049, 0x0000,
  0xFB02,  0x0046, 0x004C, 0x0000,
  0xFB03,  0x0046, 0x0046, 0x0049,
  0xFB04,  0x0046, 0x0046, 0x004C,
  0xFB05,  0x0053, 0x0054, 0x0000,
  0xFB06,  0x0053, 0x0054, 0x0000,
  0xFB13,  0x0544, 0x0546, 0x0000,
  0xFB14,  0x0544, 0x0535, 0x0000,
  0xFB15,  0x0544, 0x053B, 0x0000,
  0xFB16,  0x054E, 0x0546, 0x0000,
  0xFB17,  0x0544, 0x053D, 0x0000
];

// @ts-ignore: decorator
@lazy @inline const MT = memory.data<i32>([
  2048, 342, 57
]);

// Special binary search routine for Special Casing Tables
// @ts-ignore: decorator
@inline
export function bsearch(key: u32, ptr: usize, max: i32): i32 {
  var min = 0;
  while (min <= max) {
    let mid = (min + max) >>> 3 << 2;
    let cmp = load<u16>(ptr + (mid << alignof<u16>())) - key;
    if (cmp == 0) return mid; // found
    else if (cmp >>> 31) min = mid + 4; // < 0
    else max = mid - 4; // > 0
  }
  return -1; // not found
}

// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/towctrans.c
export function casemap(c: u32, dir: i32): i32 {
  // if (c >= 0x20000) return c;
  var c0 = c as i32;
  var b = c >> 8;
  c &= 255;

  var x = c / 3;
  var y = c % 3;

  /* lookup entry in two-level base-6 table */
  // v = tab[(tab[b] as i32) * 86 + x] as u32;
  var v = <usize>load<u8>(TAB + <usize>load<u8>(TAB + b) * 86 + x);
  // v = (v * mt[y] >> 11) % 6;
  v = (v * load<i32>(MT + (y << alignof<i32>())) >> 11) % 6;
  /* use the bit vector out of the tables as an index into
   * a block-specific set of rules and decode the rule into
   * a type and a case-mapping delta. */
  // r = rules[(ruleBases[b] as u32) + v];
  var r = load<i32>(RULES + ((<usize>load<u8>(RULE_BASES + b) + v) << alignof<i32>()));
  var rt: u32 = r & 255;
  var rd: i32 = r >> 8;
  /* rules 0/1 are simple lower/upper case with a delta.
   * apply according to desired mapping direction. */
  if (rt < 2) return c0 + (rd & -(rt ^ dir));
  /* binary search. endpoints of the binary search for
   * this block are stored in the rule delta field. */
  var xn: u32 = rd & 0xff;
  var xb: u32 = rd >>> 8;
  while (xn) {
    let h = xn >> 1;
    // let t = exceptions[(xb + h) * 2 + 0] as u32;
    let t = <u32>load<u8>(EXCEPTIONS + (xb + h) * 2, 0);
    if (t == c) {
      // r = rules[exceptions[(xb + h) * 2 + 1]];
      r = load<i32>(RULES + <usize>(load<u8>(EXCEPTIONS + (xb + h) * 2, 1) << alignof<i32>()));
      rt = r & 255;
      rd = r >> 8;
      if (rt < 2) return c0 + (rd & -(rt ^ dir));
      /* Hard-coded for the four exceptional titlecase */
      return c0 + 1 - (dir << 1); // (dir ? -1 : 1);
    } else if (t > c) {
      xn = h;
    } else {
      xb += h;
      xn -= h;
    }
  }
  return c0;
}

'''
'''--- std/assembly/util/error.ts ---
// Common error messages for use across the standard library. Keeping error messages compact
// and reusing them where possible ensures minimal static data in binaries.

// @ts-ignore: decorator
@lazy @inline
export const E_INDEXOUTOFRANGE: string = "Index out of range";

// @ts-ignore: decorator
@lazy @inline
export const E_VALUEOUTOFRANGE: string = "Value out of range";

// @ts-ignore: decorator
@lazy @inline
export const E_INVALIDLENGTH: string = "Invalid length";

// @ts-ignore: decorator
@lazy @inline
export const E_ILLEGALGENTYPE: string = "Illegal generic type";

// @ts-ignore: decorator
@lazy @inline
export const E_EMPTYARRAY: string = "Array is empty";

// @ts-ignore: decorator
@lazy @inline
export const E_HOLEYARRAY: string = "Element type must be nullable if array is holey";

// @ts-ignore: decorator
@lazy @inline
export const E_NOTIMPLEMENTED: string = "Not implemented";

// @ts-ignore: decorator
@lazy @inline
export const E_KEYNOTFOUND: string = "Key does not exist";

// @ts-ignore: decorator
@lazy @inline
export const E_ALLOCATION_TOO_LARGE: string = "Allocation too large";

// @ts-ignore: decorator
@lazy @inline
export const E_ALREADY_PINNED: string = "Object already pinned";

// @ts-ignore: decorator
@lazy @inline
export const E_NOT_PINNED: string = "Object is not pinned";

// @ts-ignore: decorator
@lazy @inline
export const E_URI_MALFORMED: string = "URI malformed";

// @ts-ignore: decorator
@lazy @inline
export const E_INVALIDDATE: string = "Invalid Date";

// @ts-ignore: decorator
@lazy @inline
export const E_UNPAIRED_SURROGATE: string = "Unpaired surrogate";

'''
'''--- std/assembly/util/hash.ts ---
export function HASH<T>(key: T): u32 {
  if (isString<T>()) {
    return hashStr(changetype<string>(key));
  } else if (isReference<T>()) {
    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));
    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));
  } else if (isFloat<T>()) {
    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(f32(key)));
    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(f64(key)));
  } else {
    if (sizeof<T>() <= 4) return hash32(u32(key), sizeof<T>());
    if (sizeof<T>() == 8) return hash64(u64(key));
  }
  return unreachable();
}

// XXHash 32-bit as a starting point, see: https://cyan4973.github.io/xxHash

// primes
// @ts-ignore: decorator
@inline const XXH32_P1: u32 = 2654435761;
// @ts-ignore: decorator
@inline const XXH32_P2: u32 = 2246822519;
// @ts-ignore: decorator
@inline const XXH32_P3: u32 = 3266489917;
// @ts-ignore: decorator
@inline const XXH32_P4: u32 = 668265263;
// @ts-ignore: decorator
@inline const XXH32_P5: u32 = 374761393;
// @ts-ignore: decorator
@inline const XXH32_SEED: u32 = 0;

// @ts-ignore: decorator
@inline
function hash32(key: u32, len: u32 = 4): u32 {
  var h: u32 = XXH32_SEED + XXH32_P5 + len;
  h += key * XXH32_P3;
  h  = rotl(h, 17) * XXH32_P4;
  h ^= h >> 15;
  h *= XXH32_P2;
  h ^= h >> 13;
  h *= XXH32_P3;
  h ^= h >> 16;
  return h;
}

// @ts-ignore: decorator
@inline
function hash64(key: u64): u32 {
  var h: u32 = XXH32_SEED + XXH32_P5 + 8;
  h += <u32>key * XXH32_P3;
  h  = rotl(h, 17) * XXH32_P4;
  h += <u32>(key >> 32) * XXH32_P3;
  h  = rotl(h, 17) * XXH32_P4;
  h ^= h >> 15;
  h *= XXH32_P2;
  h ^= h >> 13;
  h *= XXH32_P3;
  h ^= h >> 16;
  return h;
}

// @ts-ignore: decorator
@inline
function mix(h: u32, key: u32): u32 {
  return rotl(h + key * XXH32_P2, 13) * XXH32_P1;
}

// @ts-ignore: decorator
@inline
function hashStr(key: string): u32 {
  if (key === null) return XXH32_SEED;

  var h: u32 = key.length << 1;
  var len: usize = h;
  var pos = changetype<usize>(key);

  if (len >= 16) {
    let s1 = XXH32_SEED + XXH32_P1 + XXH32_P2;
    let s2 = XXH32_SEED + XXH32_P2;
    let s3 = XXH32_SEED;
    let s4 = XXH32_SEED - XXH32_P1;

    let end = len + pos - 16;
    while (pos <= end) {
      s1 = mix(s1, load<u32>(pos    ));
      s2 = mix(s2, load<u32>(pos,  4));
      s3 = mix(s3, load<u32>(pos,  8));
      s4 = mix(s4, load<u32>(pos, 12));
      pos += 16;
    }
    h += rotl(s1, 1) + rotl(s2, 7) + rotl(s3, 12) + rotl(s4, 18);
  } else {
    h += XXH32_SEED + XXH32_P5;
  }

  var end = changetype<usize>(key) + len - 4;
  while (pos <= end) {
    h += load<u32>(pos) * XXH32_P3;
    h = rotl(h, 17) * XXH32_P4;
    pos += 4;
  }

  end = changetype<usize>(key) + len;
  while (pos < end) {
    h += <u32>load<u8>(pos) * XXH32_P5;
    h = rotl(h, 11) * XXH32_P1;
    pos++;
  }

  h ^= h >> 15;
  h *= XXH32_P2;
  h ^= h >> 13;
  h *= XXH32_P3;
  h ^= h >> 16;
  return h;
}

'''
'''--- std/assembly/util/math.ts ---
//
// Lookup data for exp2f
//

// @ts-ignore: decorator
@inline const EXP2F_TABLE_BITS = 5;

// @ts-ignore: decorator
@lazy @inline const EXP2F_DATA_TAB = memory.data<u64>([
  // exp2f_data_tab[i] = uint(2^(i/N)) - (i << 52-BITS)
  // used for computing 2^(k/N) for an int |k| < 150 N as
  // double(tab[k%N] + (k << 52-BITS))
  0x3FF0000000000000, 0x3FEFD9B0D3158574, 0x3FEFB5586CF9890F, 0x3FEF9301D0125B51,
  0x3FEF72B83C7D517B, 0x3FEF54873168B9AA, 0x3FEF387A6E756238, 0x3FEF1E9DF51FDEE1,
  0x3FEF06FE0A31B715, 0x3FEEF1A7373AA9CB, 0x3FEEDEA64C123422, 0x3FEECE086061892D,
  0x3FEEBFDAD5362A27, 0x3FEEB42B569D4F82, 0x3FEEAB07DD485429, 0x3FEEA47EB03A5585,
  0x3FEEA09E667F3BCD, 0x3FEE9F75E8EC5F74, 0x3FEEA11473EB0187, 0x3FEEA589994CCE13,
  0x3FEEACE5422AA0DB, 0x3FEEB737B0CDC5E5, 0x3FEEC49182A3F090, 0x3FEED503B23E255D,
  0x3FEEE89F995AD3AD, 0x3FEEFF76F2FB5E47, 0x3FEF199BDD85529C, 0x3FEF3720DCEF9069,
  0x3FEF5818DCFBA487, 0x3FEF7C97337B9B5F, 0x3FEFA4AFA2A490DA, 0x3FEFD0765B6E4540
]);

// ULP error: 0.502 (nearest rounding.)
// Relative error: 1.69 * 2^-34 in [-1/64, 1/64] (before rounding.)
// Wrong count: 168353 (all nearest rounding wrong results with fma.)
// @ts-ignore: decorator
@inline
export function exp2f_lut(x: f32): f32 {
  const
    N      = 1 << EXP2F_TABLE_BITS,
    N_MASK = N - 1,
    shift  = reinterpret<f64>(0x4338000000000000) / N, // 0x1.8p+52
    Ox127f = reinterpret<f32>(0x7F000000);

  const
    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5
    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3
    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1

  var xd = <f64>x;
  var ix = reinterpret<u32>(x);
  var ux = ix >> 20 & 0x7FF;
  if (ux >= 0x430) {
    // |x| >= 128 or x is nan.
    if (ix == 0xFF800000) return 0; // x == -Inf    -> 0
    if (ux >= 0x7F8) return x + x;  // x == Inf/NaN -> Inf/NaN
    if (x > 0) return x * Ox127f;   // x >     0    -> HugeVal (Owerflow)
    if (x <= -150) return 0;        // x <= -150    -> 0 (Underflow)
  }

  // x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.
  var kd = xd + shift;
  var ki = reinterpret<u64>(kd);
  var r  = xd - (kd - shift);
  var t: u64, y: f64, s: f64;

  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)
  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));
  t += ki << (52 - EXP2F_TABLE_BITS);
  s  = reinterpret<f64>(t);
  y  = C2 * r + 1;
  y += (C0 * r + C1) * (r  * r);
  y *= s;

  return <f32>y;
}

// ULP error: 0.502 (nearest rounding.)
// Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before rounding.)
// Wrong count: 170635 (all nearest rounding wrong results with fma.)
// @ts-ignore: decorator
@inline
export function expf_lut(x: f32): f32 {
  const
    N        = 1 << EXP2F_TABLE_BITS,
    N_MASK   = N - 1,
    shift    = reinterpret<f64>(0x4338000000000000),        // 0x1.8p+52
    InvLn2N  = reinterpret<f64>(0x3FF71547652B82FE) * N,    // 0x1.71547652b82fep+0
    Ox1p127f = reinterpret<f32>(0x7F000000);

  const
    C0 = reinterpret<f64>(0x3FAC6AF84B912394) / N / N / N, // 0x1.c6af84b912394p-5
    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3) / N / N,     // 0x1.ebfce50fac4f3p-3
    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6) / N;         // 0x1.62e42ff0c52d6p-1

  var xd = <f64>x;
  var ix = reinterpret<u32>(x);
  var ux = ix >> 20 & 0x7FF;
  if (ux >= 0x42B) {
    // |x| >= 88 or x is nan.
    if (ix == 0xFF800000) return 0;                            // x == -Inf    -> 0
    if (ux >= 0x7F8) return x + x;                             // x == Inf/NaN -> Inf/NaN
    if (x > reinterpret<f32>(0x42B17217)) return x * Ox1p127f; // x > log(0x1p128)  ~=  88.72 -> HugeVal (Owerflow)
    if (x < reinterpret<f32>(0xC2CFF1B4)) return 0;            // x < log(0x1p-150) ~= -103.97 -> 0 (Underflow)
  }

  // x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k.
  var z = InvLn2N * xd;

  // Round and convert z to int, the result is in [-150*N, 128*N] and
  // ideally ties-to-even rule is used, otherwise the magnitude of r
  // can be bigger which gives larger approximation error.
  var kd = <f64>(z + shift);
  var ki = reinterpret<u64>(kd);
  var r  = z - (kd - shift);
  var s: f64, y: f64, t: u64;

  // exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)
  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));
  t += ki << (52 - EXP2F_TABLE_BITS);
  s  = reinterpret<f64>(t);
  z  = C0 * r + C1;
  y  = C2 * r + 1;
  y += z * (r * r);
  y *= s;

  return <f32>y;
}

//
// Lookup data for log2f
//

// @ts-ignore: decorator
@inline const LOG2F_TABLE_BITS = 4;

// @ts-ignore: decorator
@lazy @inline const LOG2F_DATA_TAB = memory.data<f64>([
  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFDEFEC65B963019), // 0x1.661ec79f8f3bep+0, -0x1.efec65b963019p-2,
  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFDB0B6832D4FCA4), // 0x1.571ed4aaf883dp+0, -0x1.b0b6832d4fca4p-2,
  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD7418B0A1FB77B), // 0x1.49539f0f010bp+0 , -0x1.7418b0a1fb77bp-2,
  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFD39DE91A6DCF7B), // 0x1.3c995b0b80385p+0, -0x1.39de91a6dcf7bp-2,
  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFD01D9BF3F2B631), // 0x1.30d190c8864a5p+0, -0x1.01d9bf3f2b631p-2,
  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC97C1D1B3B7AF0), // 0x1.25e227b0b8eap+0 , -0x1.97c1d1b3b7afp-3 ,
  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFC2F9E393AF3C9F), // 0x1.1bb4a4a1a343fp+0, -0x1.2f9e393af3c9fp-3,
  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB960CBBF788D5C), // 0x1.12358f08ae5bap+0, -0x1.960cbbf788d5cp-4,
  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFAA6F9DB6475FCE), // 0x1.0953f419900a7p+0, -0x1.a6f9db6475fcep-5,
  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0x0,
  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FB338CA9F24F53D), // 0x1.e608cfd9a47acp-1,  0x1.338ca9f24f53dp-4,
  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FC476A9543891BA), // 0x1.ca4b31f026aap-1 ,  0x1.476a9543891bap-3,
  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FCE840B4AC4E4D2), // 0x1.b2036576afce6p-1,  0x1.e840b4ac4e4d2p-3,
  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FD40645F0C6651C), // 0x1.9c2d163a1aa2dp-1,  0x1.40645f0c6651cp-2,
  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD88E9C2C1B9FF8), // 0x1.886e6037841edp-1,  0x1.88e9c2c1b9ff8p-2,
  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FDCE0A44EB17BCC)  // 0x1.767dcf5534862p-1,  0x1.ce0a44eb17bccp-2
]);

// ULP error: 0.752 (nearest rounding.)
// Relative error: 1.9 * 2^-26 (before rounding.)
// @ts-ignore: decorator
@inline
export function log2f_lut(x: f32): f32 {
  const
    N_MASK  = (1 << LOG2F_TABLE_BITS) - 1,
    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f

  const
    A0 = reinterpret<f64>(0xBFD712B6F70A7E4D), // -0x1.712b6f70a7e4dp-2
    A1 = reinterpret<f64>(0x3FDECABF496832E0), //  0x1.ecabf496832ep-2
    A2 = reinterpret<f64>(0xBFE715479FFAE3DE), // -0x1.715479ffae3dep-1
    A3 = reinterpret<f64>(0x3FF715475F35C8B8); //  0x1.715475f35c8b8p0

  var ux = reinterpret<u32>(x);
  // Fix sign of zero with downward rounding when x==1.
  // if (WANT_ROUNDING && predict_false(ix == 0x3f800000)) return 0;
  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {
    // x < 0x1p-126 or inf or nan.
    if (ux * 2 == 0) return -Infinity;
    if (ux == 0x7F800000) return x; // log2(inf) == inf.
    if ((ux >> 31) || ux * 2 >= 0xFF000000) return (x - x) / (x - x);
    // x is subnormal, normalize it.
    ux = reinterpret<u32>(x * Ox1p23f);
    ux -= 23 << 23;
  }
  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.
  // The range is split into N subintervals.
  // The ith subinterval contains z and c is near its center.
  var tmp  = ux - 0x3F330000;
  var i    = (tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK;
  var top  = tmp & 0xFF800000;
  var iz   = ux - top;
  var k    = <i32>tmp >> 23;

  var invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());
  var logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());
  var z    = <f64>reinterpret<f32>(iz);

  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k
  var r  = z * invc - 1;
  var y0 = logc + <f64>k;

  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.
  var y  = A1 * r + A2;
  var p  = A3 * r + y0;
  var r2 = r * r;
  y += A0 * r2;
  y  = y * r2 + p;

  return <f32>y;
}

//
// Lookup data for logf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/logf.c
//

// @ts-ignore: decorator
@inline const LOGF_TABLE_BITS = 4;

// @ts-ignore: decorator
@lazy @inline const LOGF_DATA_TAB = memory.data<f64>([
  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFD57BF7808CAADE), // 0x1.661ec79f8f3bep+0, -0x1.57bf7808caadep-2,
  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFD2BEF0A7C06DDB), // 0x1.571ed4aaf883dp+0, -0x1.2bef0a7c06ddbp-2,
  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD01EAE7F513A67), // 0x1.49539f0f010bp+0 , -0x1.01eae7f513a67p-2,
  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFCB31D8A68224E9), // 0x1.3c995b0b80385p+0, -0x1.b31d8a68224e9p-3,
  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFC6574F0AC07758), // 0x1.30d190c8864a5p+0, -0x1.6574f0ac07758p-3,
  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC1AA2BC79C8100), // 0x1.25e227b0b8eap+0 , -0x1.1aa2bc79c81p-3  ,
  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFBA4E76CE8C0E5E), // 0x1.1bb4a4a1a343fp+0, -0x1.a4e76ce8c0e5ep-4,
  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB1973C5A611CCC), // 0x1.12358f08ae5bap+0, -0x1.1973c5a611cccp-4,
  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFA252F438E10C1E), // 0x1.0953f419900a7p+0, -0x1.252f438e10c1ep-5,
  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0,
  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FAAA5AA5DF25984), // 0x1.e608cfd9a47acp-1,  0x1.aa5aa5df25984p-5,
  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FBC5E53AA362EB4), // 0x1.ca4b31f026aap-1 ,  0x1.c5e53aa362eb4p-4,
  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FC526E57720DB08), // 0x1.b2036576afce6p-1,  0x1.526e57720db08p-3,
  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FCBC2860D224770), // 0x1.9c2d163a1aa2dp-1,  0x1.bc2860d22477p-3 ,
  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD1058BC8A07EE1), // 0x1.886e6037841edp-1,  0x1.1058bc8a07ee1p-2,
  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FD4043057B6EE09)  // 0x1.767dcf5534862p-1,  0x1.4043057b6ee09p-2
]);

// ULP error: 0.818 (nearest rounding.)
// Relative error: 1.957 * 2^-26 (before rounding.)
// @ts-ignore: decorator
@inline
export function logf_lut(x: f32): f32 {
  const
    N_MASK  = (1 << LOGF_TABLE_BITS) - 1,
    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f

  const
    Ln2 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1;
    A0  = reinterpret<f64>(0xBFD00EA348B88334), // -0x1.00ea348b88334p-2
    A1  = reinterpret<f64>(0x3FD5575B0BE00B6A), //  0x1.5575b0be00b6ap-2
    A2  = reinterpret<f64>(0xBFDFFFFEF20A4123); // -0x1.ffffef20a4123p-2

  var ux = reinterpret<u32>(x);
  // Fix sign of zero with downward rounding when x==1.
  // if (WANT_ROUNDING && ux == 0x3f800000) return 0;
  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {
    // x < 0x1p-126 or inf or nan.
    if ((ux << 1) == 0) return -Infinity;
    if (ux == 0x7F800000) return x; // log(inf) == inf.
    if ((ux >> 31) || (ux << 1) >= 0xFF000000) return (x - x) / (x - x);
    // x is subnormal, normalize it.
    ux = reinterpret<u32>(x * Ox1p23f);
    ux -= 23 << 23;
  }
  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.
  // The range is split into N subintervals.
  // The ith subinterval contains z and c is near its center.
  var tmp = ux - 0x3F330000;
  var i   = (tmp >> (23 - LOGF_TABLE_BITS)) & N_MASK;
  var k   = <i32>tmp >> 23;
  var iz  = ux - (tmp & 0x1FF << 23);

  var invc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());
  var logc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());

  var z = <f64>reinterpret<f32>(iz);

  // log(x) = log1p(z/c-1) + log(c) + k*Ln2
  var r = z * invc - 1;
  var y0 = logc + <f64>k * Ln2;

  // Pipelined polynomial evaluation to approximate log1p(r).
  var r2 = r * r;
  var y  = A1 * r + A2;
  y += A0 * r2;
  y = y * r2 + (y0 + r);

  return <f32>y;
}

//
// Lookup data for powf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/powf.c
//

// @ts-ignore: decorator
@inline
function zeroinfnanf(ux: u32): bool {
  return (ux << 1) - 1 >= (<u32>0x7f800000 << 1) - 1;
}

// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is
// the bit representation of a non-zero finite floating-point value.
// @ts-ignore: decorator
@inline
function checkintf(iy: u32): i32 {
  var e = iy >> 23 & 0xFF;
  if (e < 0x7F     ) return 0;
  if (e > 0x7F + 23) return 2;
  e = 1 << (0x7F + 23 - e);
  if (iy & (e - 1)) return 0;
  if (iy &  e     ) return 1;
  return 2;
}

// Subnormal input is normalized so ix has negative biased exponent.
// Output is multiplied by N (POWF_SCALE) if TOINT_INTRINICS is set.
// @ts-ignore: decorator
@inline
function log2f_inline(ux: u32): f64 {
  const N_MASK = (1 << LOG2F_TABLE_BITS) - 1;

  const
    A0 = reinterpret<f64>(0x3FD27616C9496E0B), //  0x1.27616c9496e0bp-2
    A1 = reinterpret<f64>(0xBFD71969A075C67A), // -0x1.71969a075c67ap-2
    A2 = reinterpret<f64>(0x3FDEC70A6CA7BADD), //  0x1.ec70a6ca7baddp-2
    A3 = reinterpret<f64>(0xBFE7154748BEF6C8), // -0x1.7154748bef6c8p-1
    A4 = reinterpret<f64>(0x3FF71547652AB82B); //  0x1.71547652ab82bp+0

  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.
  // The range is split into N subintervals.
  // The ith subinterval contains z and c is near its center.
  var tmp  = ux - 0x3F330000;
  var i    = <usize>((tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK);
  var top  = tmp & 0xFF800000;
  var uz   = ux - top;
  var k    = <i32>(<i32>top >> 23);

  var invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());
  var logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());
  var z    = <f64>reinterpret<f32>(uz);

  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k
  var r  = z * invc - 1;
  var y0 = logc + <f64>k;

  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.
  var y = A0 * r + A1;
  var p = A2 * r + A3;
  var q = A4 * r + y0;

  r *= r;
  q += p * r;
  y  = y * (r * r) + q;

  return y;
}

// The output of log2 and thus the input of exp2 is either scaled by N
// (in case of fast toint intrinsics) or not.  The unscaled xd must be
// in [-1021,1023], sign_bias sets the sign of the result.
// @ts-ignore: decorator
@inline
function exp2f_inline(xd: f64, signBias: u32): f32 {
  const
    N      = 1 << EXP2F_TABLE_BITS,
    N_MASK = N - 1,
    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p+52

  const
    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5
    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3
    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1

  // x = k/N + r with r in [-1/(2N), 1/(2N)]
  var kd = <f64>(xd + shift);
  var ki = reinterpret<u64>(kd);
  var r  = xd - (kd - shift);
  var t: u64, z: f64, y: f64, s: f64;

  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)
  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));
  t += (ki + signBias) << (52 - EXP2F_TABLE_BITS);
  s  = reinterpret<f64>(t);
  z  = C0 * r + C1;
  y  = C2 * r + 1;
  y += z * (r * r);
  y *= s;
  return <f32>y;
}

// @ts-ignore: decorator
@inline
function xflowf(sign: u32, y: f32): f32 {
  return select<f32>(-y, y, sign) * y;
}

// @ts-ignore: decorator
@inline
function oflowf(sign: u32): f32 {
  return xflowf(sign, reinterpret<f32>(0x70000000)); // 0x1p97f
}

// @ts-ignore: decorator
@inline
function uflowf(sign: u32): f32 {
  return xflowf(sign, reinterpret<f32>(0x10000000)); // 0x1p-95f
}

// @ts-ignore: decorator
@inline
export function powf_lut(x: f32, y: f32): f32 {
  const
    Ox1p23f     = reinterpret<f32>(0x4B000000), // 0x1p23f
    UPPER_LIMIT = reinterpret<f64>(0x405FFFFFFFD1D571), // 0x1.fffffffd1d571p+6
    LOWER_LIMIT = -150.0,
    SIGN_BIAS   = 1 << (EXP2F_TABLE_BITS + 11);

  var signBias: u32 = 0;
  var ix = reinterpret<u32>(x);
  var iy = reinterpret<u32>(y);
  var ny = 0;

  if (i32(ix - 0x00800000 >= 0x7f800000 - 0x00800000) | (ny = i32(zeroinfnanf(iy)))) {
    // Either (x < 0x1p-126 or inf or nan) or (y is 0 or inf or nan).
    if (ny) {
      if ((iy << 1) == 0) return 1.0;
      if (ix == 0x3F800000) return NaN; // original: 1.0
      if ((ix << 1) > (<u32>0x7F800000 << 1) || (iy << 1) > (<u32>0x7F800000 << 1)) return x + y;
      if ((ix << 1) == (0x3F800000 << 1)) return NaN; // original: 1.0
      if (((ix << 1) < (0x3F800000 << 1)) == !(iy >> 31)) return 0; // |x| < 1 && y==inf or |x| > 1 && y==-inf.
      return y * y;
    }
    if (zeroinfnanf(ix)) {
      let x2 = x * x;
      if ((ix >> 31) && checkintf(iy) == 1) x2 = -x2;
      return iy >> 31 ? 1 / x2 : x2;
    }
    // x and y are non-zero finite.
    if (ix >> 31) {
      // Finite x < 0.
      let yint = checkintf(iy);
      if (yint == 0) return (x - x) / (x - x);
      if (yint == 1) signBias = SIGN_BIAS;
      ix &= 0x7FFFFFFF;
    }
    if (ix < 0x00800000) {
      // Normalize subnormal x so exponent becomes negative.
      ix = reinterpret<u32>(x * Ox1p23f);
      ix &= 0x7FFFFFFF;
      ix -= 23 << 23;
    }
  }
  var logx = log2f_inline(ix);
  var ylogx = y * logx; // cannot overflow, y is single prec.
  if ((reinterpret<u64>(ylogx) >> 47 & 0xFFFF) >= 0x80BF) { // reinterpret<u64>(126.0) >> 47
    // |y * log(x)| >= 126
    if (ylogx  > UPPER_LIMIT) return oflowf(signBias); // overflow
    if (ylogx <= LOWER_LIMIT) return uflowf(signBias); // underflow
  }
  return exp2f_inline(ylogx, signBias);
}

//
// Lookup data for exp. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp.c
//

// @ts-ignore: decorator
@inline const EXP_TABLE_BITS = 7;

// @ts-ignore: decorator
@lazy @inline const EXP_DATA_TAB = memory.data<u64>([
  0x0000000000000000, 0x3FF0000000000000,
  0x3C9B3B4F1A88BF6E, 0x3FEFF63DA9FB3335,
  0xBC7160139CD8DC5D, 0x3FEFEC9A3E778061,
  0xBC905E7A108766D1, 0x3FEFE315E86E7F85,
  0x3C8CD2523567F613, 0x3FEFD9B0D3158574,
  0xBC8BCE8023F98EFA, 0x3FEFD06B29DDF6DE,
  0x3C60F74E61E6C861, 0x3FEFC74518759BC8,
  0x3C90A3E45B33D399, 0x3FEFBE3ECAC6F383,
  0x3C979AA65D837B6D, 0x3FEFB5586CF9890F,
  0x3C8EB51A92FDEFFC, 0x3FEFAC922B7247F7,
  0x3C3EBE3D702F9CD1, 0x3FEFA3EC32D3D1A2,
  0xBC6A033489906E0B, 0x3FEF9B66AFFED31B,
  0xBC9556522A2FBD0E, 0x3FEF9301D0125B51,
  0xBC5080EF8C4EEA55, 0x3FEF8ABDC06C31CC,
  0xBC91C923B9D5F416, 0x3FEF829AAEA92DE0,
  0x3C80D3E3E95C55AF, 0x3FEF7A98C8A58E51,
  0xBC801B15EAA59348, 0x3FEF72B83C7D517B,
  0xBC8F1FF055DE323D, 0x3FEF6AF9388C8DEA,
  0x3C8B898C3F1353BF, 0x3FEF635BEB6FCB75,
  0xBC96D99C7611EB26, 0x3FEF5BE084045CD4,
  0x3C9AECF73E3A2F60, 0x3FEF54873168B9AA,
  0xBC8FE782CB86389D, 0x3FEF4D5022FCD91D,
  0x3C8A6F4144A6C38D, 0x3FEF463B88628CD6,
  0x3C807A05B0E4047D, 0x3FEF3F49917DDC96,
  0x3C968EFDE3A8A894, 0x3FEF387A6E756238,
  0x3C875E18F274487D, 0x3FEF31CE4FB2A63F,
  0x3C80472B981FE7F2, 0x3FEF2B4565E27CDD,
  0xBC96B87B3F71085E, 0x3FEF24DFE1F56381,
  0x3C82F7E16D09AB31, 0x3FEF1E9DF51FDEE1,
  0xBC3D219B1A6FBFFA, 0x3FEF187FD0DAD990,
  0x3C8B3782720C0AB4, 0x3FEF1285A6E4030B,
  0x3C6E149289CECB8F, 0x3FEF0CAFA93E2F56,
  0x3C834D754DB0ABB6, 0x3FEF06FE0A31B715,
  0x3C864201E2AC744C, 0x3FEF0170FC4CD831,
  0x3C8FDD395DD3F84A, 0x3FEEFC08B26416FF,
  0xBC86A3803B8E5B04, 0x3FEEF6C55F929FF1,
  0xBC924AEDCC4B5068, 0x3FEEF1A7373AA9CB,
  0xBC9907F81B512D8E, 0x3FEEECAE6D05D866,
  0xBC71D1E83E9436D2, 0x3FEEE7DB34E59FF7,
  0xBC991919B3CE1B15, 0x3FEEE32DC313A8E5,
  0x3C859F48A72A4C6D, 0x3FEEDEA64C123422,
  0xBC9312607A28698A, 0x3FEEDA4504AC801C,
  0xBC58A78F4817895B, 0x3FEED60A21F72E2A,
  0xBC7C2C9B67499A1B, 0x3FEED1F5D950A897,
  0x3C4363ED60C2AC11, 0x3FEECE086061892D,
  0x3C9666093B0664EF, 0x3FEECA41ED1D0057,
  0x3C6ECCE1DAA10379, 0x3FEEC6A2B5C13CD0,
  0x3C93FF8E3F0F1230, 0x3FEEC32AF0D7D3DE,
  0x3C7690CEBB7AAFB0, 0x3FEEBFDAD5362A27,
  0x3C931DBDEB54E077, 0x3FEEBCB299FDDD0D,
  0xBC8F94340071A38E, 0x3FEEB9B2769D2CA7,
  0xBC87DECCDC93A349, 0x3FEEB6DAA2CF6642,
  0xBC78DEC6BD0F385F, 0x3FEEB42B569D4F82,
  0xBC861246EC7B5CF6, 0x3FEEB1A4CA5D920F,
  0x3C93350518FDD78E, 0x3FEEAF4736B527DA,
  0x3C7B98B72F8A9B05, 0x3FEEAD12D497C7FD,
  0x3C9063E1E21C5409, 0x3FEEAB07DD485429,
  0x3C34C7855019C6EA, 0x3FEEA9268A5946B7,
  0x3C9432E62B64C035, 0x3FEEA76F15AD2148,
  0xBC8CE44A6199769F, 0x3FEEA5E1B976DC09,
  0xBC8C33C53BEF4DA8, 0x3FEEA47EB03A5585,
  0xBC845378892BE9AE, 0x3FEEA34634CCC320,
  0xBC93CEDD78565858, 0x3FEEA23882552225,
  0x3C5710AA807E1964, 0x3FEEA155D44CA973,
  0xBC93B3EFBF5E2228, 0x3FEEA09E667F3BCD,
  0xBC6A12AD8734B982, 0x3FEEA012750BDABF,
  0xBC6367EFB86DA9EE, 0x3FEE9FB23C651A2F,
  0xBC80DC3D54E08851, 0x3FEE9F7DF9519484,
  0xBC781F647E5A3ECF, 0x3FEE9F75E8EC5F74,
  0xBC86EE4AC08B7DB0, 0x3FEE9F9A48A58174,
  0xBC8619321E55E68A, 0x3FEE9FEB564267C9,
  0x3C909CCB5E09D4D3, 0x3FEEA0694FDE5D3F,
  0xBC7B32DCB94DA51D, 0x3FEEA11473EB0187,
  0x3C94ECFD5467C06B, 0x3FEEA1ED0130C132,
  0x3C65EBE1ABD66C55, 0x3FEEA2F336CF4E62,
  0xBC88A1C52FB3CF42, 0x3FEEA427543E1A12,
  0xBC9369B6F13B3734, 0x3FEEA589994CCE13,
  0xBC805E843A19FF1E, 0x3FEEA71A4623C7AD,
  0xBC94D450D872576E, 0x3FEEA8D99B4492ED,
  0x3C90AD675B0E8A00, 0x3FEEAAC7D98A6699,
  0x3C8DB72FC1F0EAB4, 0x3FEEACE5422AA0DB,
  0xBC65B6609CC5E7FF, 0x3FEEAF3216B5448C,
  0x3C7BF68359F35F44, 0x3FEEB1AE99157736,
  0xBC93091FA71E3D83, 0x3FEEB45B0B91FFC6,
  0xBC5DA9B88B6C1E29, 0x3FEEB737B0CDC5E5,
  0xBC6C23F97C90B959, 0x3FEEBA44CBC8520F,
  0xBC92434322F4F9AA, 0x3FEEBD829FDE4E50,
  0xBC85CA6CD7668E4B, 0x3FEEC0F170CA07BA,
  0x3C71AFFC2B91CE27, 0x3FEEC49182A3F090,
  0x3C6DD235E10A73BB, 0x3FEEC86319E32323,
  0xBC87C50422622263, 0x3FEECC667B5DE565,
  0x3C8B1C86E3E231D5, 0x3FEED09BEC4A2D33,
  0xBC91BBD1D3BCBB15, 0x3FEED503B23E255D,
  0x3C90CC319CEE31D2, 0x3FEED99E1330B358,
  0x3C8469846E735AB3, 0x3FEEDE6B5579FDBF,
  0xBC82DFCD978E9DB4, 0x3FEEE36BBFD3F37A,
  0x3C8C1A7792CB3387, 0x3FEEE89F995AD3AD,
  0xBC907B8F4AD1D9FA, 0x3FEEEE07298DB666,
  0xBC55C3D956DCAEBA, 0x3FEEF3A2B84F15FB,
  0xBC90A40E3DA6F640, 0x3FEEF9728DE5593A,
  0xBC68D6F438AD9334, 0x3FEEFF76F2FB5E47,
  0xBC91EEE26B588A35, 0x3FEF05B030A1064A,
  0x3C74FFD70A5FDDCD, 0x3FEF0C1E904BC1D2,
  0xBC91BDFBFA9298AC, 0x3FEF12C25BD71E09,
  0x3C736EAE30AF0CB3, 0x3FEF199BDD85529C,
  0x3C8EE3325C9FFD94, 0x3FEF20AB5FFFD07A,
  0x3C84E08FD10959AC, 0x3FEF27F12E57D14B,
  0x3C63CDAF384E1A67, 0x3FEF2F6D9406E7B5,
  0x3C676B2C6C921968, 0x3FEF3720DCEF9069,
  0xBC808A1883CCB5D2, 0x3FEF3F0B555DC3FA,
  0xBC8FAD5D3FFFFA6F, 0x3FEF472D4A07897C,
  0xBC900DAE3875A949, 0x3FEF4F87080D89F2,
  0x3C74A385A63D07A7, 0x3FEF5818DCFBA487,
  0xBC82919E2040220F, 0x3FEF60E316C98398,
  0x3C8E5A50D5C192AC, 0x3FEF69E603DB3285,
  0x3C843A59AC016B4B, 0x3FEF7321F301B460,
  0xBC82D52107B43E1F, 0x3FEF7C97337B9B5F,
  0xBC892AB93B470DC9, 0x3FEF864614F5A129,
  0x3C74B604603A88D3, 0x3FEF902EE78B3FF6,
  0x3C83C5EC519D7271, 0x3FEF9A51FBC74C83,
  0xBC8FF7128FD391F0, 0x3FEFA4AFA2A490DA,
  0xBC8DAE98E223747D, 0x3FEFAF482D8E67F1,
  0x3C8EC3BC41AA2008, 0x3FEFBA1BEE615A27,
  0x3C842B94C3A9EB32, 0x3FEFC52B376BBA97,
  0x3C8A64A931D185EE, 0x3FEFD0765B6E4540,
  0xBC8E37BAE43BE3ED, 0x3FEFDBFDAD9CBE14,
  0x3C77893B4D91CD9D, 0x3FEFE7C1819E90D8,
  0x3C5305C14160CC89, 0x3FEFF3C22B8F71F1
]);

// Handle cases that may overflow or underflow when computing the result that
// is scale*(1+TMP) without intermediate rounding. The bit representation of
// scale is in SBITS, however it has a computed exponent that may have
// overflown into the sign bit so that needs to be adjusted before using it as
// a double.  (int32_t)KI is the k used in the argument reduction and exponent
// adjustment of scale, positive k here means the result may overflow and
// negative k means the result may underflow.
// @ts-ignore: decorator
@inline
function specialcase(tmp: f64, sbits: u64, ki: u64): f64 {
  const
    Ox1p_1022 = reinterpret<f64>(0x0010000000000000), // 0x1p-1022
    Ox1p1009  = reinterpret<f64>(0x7F00000000000000); // 0x1p1009

  var scale: f64;
  if (!(ki & 0x80000000)) {
    // k > 0, the exponent of scale might have overflowed by <= 460.
    sbits -= u64(1009) << 52;
    scale = reinterpret<f64>(sbits);
    return Ox1p1009 * (scale + scale * tmp); // 0x1p1009
  }
  // k < 0, need special care in the subnormal range.
  sbits += u64(1022) << 52;
  // Note: sbits is signed scale.
  scale = reinterpret<f64>(sbits);
  var y = scale + scale * tmp;
  if (abs(y) < 1.0) {
    // Round y to the right precision before scaling it into the subnormal
    // range to avoid double rounding that can cause 0.5+E/2 ulp error where
    // E is the worst-case ulp error outside the subnormal range.  So this
    // is only useful if the goal is better than 1 ulp worst-case error.
    let one = copysign(1.0, y);
    let lo = scale - y + scale * tmp;
    let hi = one + y;
    lo = one - hi + y + lo;
    y  = (hi + lo) - one;
    // Fix the sign of 0.
    if (y == 0.0) y = reinterpret<f64>(sbits & 0x8000000000000000);
  }
  return y * Ox1p_1022;
}

// @ts-ignore: decorator
@inline
export function exp_lut(x: f64): f64 {
  const
    N      = 1 << EXP_TABLE_BITS,
    N_MASK = N - 1;

  const
    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0
    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8
    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47
    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52;

  const
    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)
    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)
    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)
    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)

  var ux = reinterpret<u64>(x);
  var abstop = <u32>(ux >> 52 & 0x7FF);
  if (abstop - 0x3C9 >= 0x03F) {
    if (abstop - 0x3C9 >= 0x80000000) return 1;
    if (abstop >= 0x409) {
      if (ux == 0xFFF0000000000000) return 0;
      if (abstop >= 0x7FF) return 1.0 + x;
      return select<f64>(0, Infinity, ux >> 63);
    }
    // Large x is special cased below.
    abstop = 0;
  }

  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)]
  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N]
  var z = InvLn2N * x;
  // #if TOINT_INTRINSICS
  // 	kd = roundtoint(z);
  // 	ki = converttoint(z);
  // #elif EXP_USE_TOINT_NARROW
  // 	// z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.
  // var kd = z + shift;
  // var ki = reinterpret<u64>(kd) >> 16;
  // var kd = <f64><i32>ki;
  // #else
  // z - kd is in [-1, 1] in non-nearest rounding modes.
  var kd = z + shift;
  var ki = reinterpret<u64>(kd);
  kd -= shift;
  // #endif
  var r = x + kd * NegLn2hiN + kd * NegLn2loN;
  // 2^(k/N) ~= scale * (1 + tail).
  var idx = <usize>((ki & N_MASK) << 1);
  var top = ki << (52 - EXP_TABLE_BITS);

  var tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()))); // T[idx]
  // This is only a valid scale when -1023*N < k < 1024*N
  var sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]
  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).
  // Evaluation is optimized assuming superscalar pipelined execution.
  var r2 = r * r;
  // Without fma the worst case error is 0.25/N ulp larger.
  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.
  var tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);
  if (abstop == 0) return specialcase(tmp, sbits, ki);
  var scale = reinterpret<f64>(sbits);
  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there
  // is no spurious underflow here even without fma.
  return scale + scale * tmp;
}

//
// Lookup data for exp2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp2.c
//

// Handle cases that may overflow or underflow when computing the result that
// is scale*(1+TMP) without intermediate rounding.  The bit representation of
// scale is in SBITS, however it has a computed exponent that may have
// overflown into the sign bit so that needs to be adjusted before using it as
// a double.  (int32_t)KI is the k used in the argument reduction and exponent
// adjustment of scale, positive k here means the result may overflow and
// negative k means the result may underflow.
// @ts-ignore: decorator
@inline
function specialcase2(tmp: f64, sbits: u64, ki: u64): f64 {
  const Ox1p_1022 = reinterpret<f64>(0x10000000000000); // 0x1p-1022
  var scale: f64;
  if ((ki & 0x80000000) == 0) {
    // k > 0, the exponent of scale might have overflowed by 1
    sbits -= u64(1) << 52;
    scale = reinterpret<f64>(sbits);
    return 2 * (scale * tmp + scale);
  }
  // k < 0, need special care in the subnormal range
  sbits += u64(1022) << 52;
  scale = reinterpret<f64>(sbits);
  var y = scale * tmp + scale;
  if (y < 1.0) {
    // Round y to the right precision before scaling it into the subnormal
    // range to avoid double rounding that can cause 0.5+E/2 ulp error where
    // E is the worst-case ulp error outside the subnormal range. So this
    // is only useful if the goal is better than 1 ulp worst-case error.
    let hi: f64, lo: f64;
    lo = scale - y + scale * tmp;
    hi = 1.0 + y;
    lo = 1.0 - hi + y + lo;
    y = (hi + lo) - 1.0;
  }
  return y * Ox1p_1022;
}

// @ts-ignore: decorator
@inline
export function exp2_lut(x: f64): f64 {
  const
    N      = 1 << EXP_TABLE_BITS,
    N_MASK = N - 1,
    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p52

  const
    C1 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1
    C2 = reinterpret<f64>(0x3FCEBFBDFF82C424), // 0x1.ebfbdff82c424p-3
    C3 = reinterpret<f64>(0x3FAC6B08D70CF4B5), // 0x1.c6b08d70cf4b5p-5
    C4 = reinterpret<f64>(0x3F83B2ABD24650CC), // 0x1.3b2abd24650ccp-7
    C5 = reinterpret<f64>(0x3F55D7E09B4E3A84); // 0x1.5d7e09b4e3a84p-10

  var ux = reinterpret<u64>(x);
  var abstop = <u32>(ux >> 52 & 0x7ff);
  if (abstop - 0x3C9 >= 0x03F) {
    if (abstop - 0x3C9 >= 0x80000000) return 1.0;
    if (abstop >= 0x409) {
      if (ux == 0xFFF0000000000000) return 0;
      if (abstop >= 0x7FF) return 1.0 + x;
      if (!(ux >> 63)) return Infinity;
      else if (ux >= 0xC090CC0000000000) return 0;
    }
    if ((ux << 1) > 0x811A000000000000) abstop = 0; // Large x is special cased below.
  }

  // exp2(x) = 2^(k/N) * 2^r, with 2^r in [2^(-1/2N),2^(1/2N)].
  // x = k/N + r, with int k and r in [-1/2N, 1/2N]
  var kd = x + shift;
  var ki = reinterpret<u64>(kd);
  kd -= shift; // k/N for int k
  var r = x - kd;
  // 2^(k/N) ~= scale * (1 + tail)
  var idx = <usize>((ki & N_MASK) << 1);
  var top = ki << (52 - EXP_TABLE_BITS);

  var tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 0 << alignof<u64>())); // T[idx])
  // This is only a valid scale when -1023*N < k < 1024*N
  var sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]
  // exp2(x) = 2^(k/N) * 2^r ~= scale + scale * (tail + 2^r - 1).
  // Evaluation is optimized assuming superscalar pipelined execution
  var r2 = r * r;
  // Without fma the worst case error is 0.5/N ulp larger.
  // Worst case error is less than 0.5+0.86/N+(abs poly error * 2^53) ulp.
  var tmp = tail + r * C1 + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);
  if (abstop == 0) return specialcase2(tmp, sbits, ki);
  var scale = reinterpret<f64>(sbits);
  // Note: tmp == 0 or |tmp| > 2^-65 and scale > 2^-928, so there
  // is no spurious underflow here even without fma.
  return scale * tmp + scale;
}

//
// Lookup data for log2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log2.c
//

// @ts-ignore: decorator
@inline const LOG2_TABLE_BITS = 6;

/* Algorithm:

  x = 2^k z
  log2(x) = k + log2(c) + log2(z/c)
  log2(z/c) = poly(z/c - 1)

where z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls
into the ith one, then table entries are computed as

  tab[i].invc = 1/c
  tab[i].logc = (double)log2(c)
  tab2[i].chi = (double)c
  tab2[i].clo = (double)(c - (double)c)

where c is near the center of the subinterval and is chosen by trying +-2^29
floating point invc candidates around 1/center and selecting one for which

  1) the rounding error in 0x1.8p10 + logc is 0,
  2) the rounding error in z - chi - clo is < 0x1p-64 and
  3) the rounding error in (double)log2(c) is minimized (< 0x1p-68).

Note: 1) ensures that k + logc can be computed without rounding error, 2)
ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to a
single rounding error when there is no fast fma for z*invc - 1, 3) ensures
that logc + poly(z/c - 1) has small error, however near x == 1 when
|log2(x)| < 0x1p-4, this is not enough so that is special cased. */

// @ts-ignore: decorator
@lazy @inline const LOG2_DATA_TAB1 = memory.data<f64>([
  //            invc                  ,                logc
  reinterpret<f64>(0x3FF724286BB1ACF8), reinterpret<f64>(0xBFE1095FEECDB000),
  reinterpret<f64>(0x3FF6E1F766D2CCA1), reinterpret<f64>(0xBFE08494BD76D000),
  reinterpret<f64>(0x3FF6A13D0E30D48A), reinterpret<f64>(0xBFE00143AEE8F800),
  reinterpret<f64>(0x3FF661EC32D06C85), reinterpret<f64>(0xBFDEFEC5360B4000),
  reinterpret<f64>(0x3FF623FA951198F8), reinterpret<f64>(0xBFDDFDD91AB7E000),
  reinterpret<f64>(0x3FF5E75BA4CF026C), reinterpret<f64>(0xBFDCFFAE0CC79000),
  reinterpret<f64>(0x3FF5AC055A214FB8), reinterpret<f64>(0xBFDC043811FDA000),
  reinterpret<f64>(0x3FF571ED0F166E1E), reinterpret<f64>(0xBFDB0B67323AE000),
  reinterpret<f64>(0x3FF53909590BF835), reinterpret<f64>(0xBFDA152F5A2DB000),
  reinterpret<f64>(0x3FF5014FED61ADDD), reinterpret<f64>(0xBFD9217F5AF86000),
  reinterpret<f64>(0x3FF4CAB88E487BD0), reinterpret<f64>(0xBFD8304DB0719000),
  reinterpret<f64>(0x3FF49539B4334FEE), reinterpret<f64>(0xBFD74189F9A9E000),
  reinterpret<f64>(0x3FF460CBDFAFD569), reinterpret<f64>(0xBFD6552BB5199000),
  reinterpret<f64>(0x3FF42D664EE4B953), reinterpret<f64>(0xBFD56B23A29B1000),
  reinterpret<f64>(0x3FF3FB01111DD8A6), reinterpret<f64>(0xBFD483650F5FA000),
  reinterpret<f64>(0x3FF3C995B70C5836), reinterpret<f64>(0xBFD39DE937F6A000),
  reinterpret<f64>(0x3FF3991C4AB6FD4A), reinterpret<f64>(0xBFD2BAA1538D6000),
  reinterpret<f64>(0x3FF3698E0CE099B5), reinterpret<f64>(0xBFD1D98340CA4000),
  reinterpret<f64>(0x3FF33AE48213E7B2), reinterpret<f64>(0xBFD0FA853A40E000),
  reinterpret<f64>(0x3FF30D191985BDB1), reinterpret<f64>(0xBFD01D9C32E73000),
  reinterpret<f64>(0x3FF2E025CAB271D7), reinterpret<f64>(0xBFCE857DA2FA6000),
  reinterpret<f64>(0x3FF2B404CF13CD82), reinterpret<f64>(0xBFCCD3C8633D8000),
  reinterpret<f64>(0x3FF288B02C7CCB50), reinterpret<f64>(0xBFCB26034C14A000),
  reinterpret<f64>(0x3FF25E2263944DE5), reinterpret<f64>(0xBFC97C1C2F4FE000),
  reinterpret<f64>(0x3FF234563D8615B1), reinterpret<f64>(0xBFC7D6023F800000),
  reinterpret<f64>(0x3FF20B46E33EAF38), reinterpret<f64>(0xBFC633A71A05E000),
  reinterpret<f64>(0x3FF1E2EEFDCDA3DD), reinterpret<f64>(0xBFC494F5E9570000),
  reinterpret<f64>(0x3FF1BB4A580B3930), reinterpret<f64>(0xBFC2F9E424E0A000),
  reinterpret<f64>(0x3FF19453847F2200), reinterpret<f64>(0xBFC162595AFDC000),
  reinterpret<f64>(0x3FF16E06C0D5D73C), reinterpret<f64>(0xBFBF9C9A75BD8000),
  reinterpret<f64>(0x3FF1485F47B7E4C2), reinterpret<f64>(0xBFBC7B575BF9C000),
  reinterpret<f64>(0x3FF12358AD0085D1), reinterpret<f64>(0xBFB960C60FF48000),
  reinterpret<f64>(0x3FF0FEF00F532227), reinterpret<f64>(0xBFB64CE247B60000),
  reinterpret<f64>(0x3FF0DB2077D03A8F), reinterpret<f64>(0xBFB33F78B2014000),
  reinterpret<f64>(0x3FF0B7E6D65980D9), reinterpret<f64>(0xBFB0387D1A42C000),
  reinterpret<f64>(0x3FF0953EFE7B408D), reinterpret<f64>(0xBFAA6F9208B50000),
  reinterpret<f64>(0x3FF07325CAC53B83), reinterpret<f64>(0xBFA47A954F770000),
  reinterpret<f64>(0x3FF05197E40D1B5C), reinterpret<f64>(0xBF9D23A8C50C0000),
  reinterpret<f64>(0x3FF03091C1208EA2), reinterpret<f64>(0xBF916A2629780000),
  reinterpret<f64>(0x3FF0101025B37E21), reinterpret<f64>(0xBF7720F8D8E80000),
  reinterpret<f64>(0x3FEFC07EF9CAA76B), reinterpret<f64>(0x3F86FE53B1500000),
  reinterpret<f64>(0x3FEF4465D3F6F184), reinterpret<f64>(0x3FA11CCCE10F8000),
  reinterpret<f64>(0x3FEECC079F84107F), reinterpret<f64>(0x3FAC4DFC8C8B8000),
  reinterpret<f64>(0x3FEE573A99975AE8), reinterpret<f64>(0x3FB3AA321E574000),
  reinterpret<f64>(0x3FEDE5D6F0BD3DE6), reinterpret<f64>(0x3FB918A0D08B8000),
  reinterpret<f64>(0x3FED77B681FF38B3), reinterpret<f64>(0x3FBE72E9DA044000),
  reinterpret<f64>(0x3FED0CB5724DE943), reinterpret<f64>(0x3FC1DCD2507F6000),
  reinterpret<f64>(0x3FECA4B2DC0E7563), reinterpret<f64>(0x3FC476AB03DEA000),
  reinterpret<f64>(0x3FEC3F8EE8D6CB51), reinterpret<f64>(0x3FC7074377E22000),
  reinterpret<f64>(0x3FEBDD2B4F020C4C), reinterpret<f64>(0x3FC98EDE8BA94000),
  reinterpret<f64>(0x3FEB7D6C006015CA), reinterpret<f64>(0x3FCC0DB86AD2E000),
  reinterpret<f64>(0x3FEB20366E2E338F), reinterpret<f64>(0x3FCE840AAFCEE000),
  reinterpret<f64>(0x3FEAC57026295039), reinterpret<f64>(0x3FD0790AB4678000),
  reinterpret<f64>(0x3FEA6D01BC2731DD), reinterpret<f64>(0x3FD1AC056801C000),
  reinterpret<f64>(0x3FEA16D3BC3FF18B), reinterpret<f64>(0x3FD2DB11D4FEE000),
  reinterpret<f64>(0x3FE9C2D14967FEAD), reinterpret<f64>(0x3FD406464EC58000),
  reinterpret<f64>(0x3FE970E4F47C9902), reinterpret<f64>(0x3FD52DBE093AF000),
  reinterpret<f64>(0x3FE920FB3982BCF2), reinterpret<f64>(0x3FD651902050D000),
  reinterpret<f64>(0x3FE8D30187F759F1), reinterpret<f64>(0x3FD771D2CDEAF000),
  reinterpret<f64>(0x3FE886E5EBB9F66D), reinterpret<f64>(0x3FD88E9C857D9000),
  reinterpret<f64>(0x3FE83C97B658B994), reinterpret<f64>(0x3FD9A80155E16000),
  reinterpret<f64>(0x3FE7F405FFC61022), reinterpret<f64>(0x3FDABE186ED3D000),
  reinterpret<f64>(0x3FE7AD22181415CA), reinterpret<f64>(0x3FDBD0F2AEA0E000),
  reinterpret<f64>(0x3FE767DCF99EFF8C), reinterpret<f64>(0x3FDCE0A43DBF4000)
]);

// @ts-ignore: decorator
@lazy @inline const LOG2_DATA_TAB2 = memory.data<f64>([
  //              chi                 ,                 clo
  reinterpret<f64>(0x3FE6200012B90A8E), reinterpret<f64>(0x3C8904AB0644B605),
  reinterpret<f64>(0x3FE66000045734A6), reinterpret<f64>(0x3C61FF9BEA62F7A9),
  reinterpret<f64>(0x3FE69FFFC325F2C5), reinterpret<f64>(0x3C827ECFCB3C90BA),
  reinterpret<f64>(0x3FE6E00038B95A04), reinterpret<f64>(0x3C88FF8856739326),
  reinterpret<f64>(0x3FE71FFFE09994E3), reinterpret<f64>(0x3C8AFD40275F82B1),
  reinterpret<f64>(0x3FE7600015590E10), reinterpret<f64>(0xBC72FD75B4238341),
  reinterpret<f64>(0x3FE7A00012655BD5), reinterpret<f64>(0x3C7808E67C242B76),
  reinterpret<f64>(0x3FE7E0003259E9A6), reinterpret<f64>(0xBC6208E426F622B7),
  reinterpret<f64>(0x3FE81FFFEDB4B2D2), reinterpret<f64>(0xBC8402461EA5C92F),
  reinterpret<f64>(0x3FE860002DFAFCC3), reinterpret<f64>(0x3C6DF7F4A2F29A1F),
  reinterpret<f64>(0x3FE89FFFF78C6B50), reinterpret<f64>(0xBC8E0453094995FD),
  reinterpret<f64>(0x3FE8E00039671566), reinterpret<f64>(0xBC8A04F3BEC77B45),
  reinterpret<f64>(0x3FE91FFFE2BF1745), reinterpret<f64>(0xBC77FA34400E203C),
  reinterpret<f64>(0x3FE95FFFCC5C9FD1), reinterpret<f64>(0xBC76FF8005A0695D),
  reinterpret<f64>(0x3FE9A0003BBA4767), reinterpret<f64>(0x3C70F8C4C4EC7E03),
  reinterpret<f64>(0x3FE9DFFFE7B92DA5), reinterpret<f64>(0x3C8E7FD9478C4602),
  reinterpret<f64>(0x3FEA1FFFD72EFDAF), reinterpret<f64>(0xBC6A0C554DCDAE7E),
  reinterpret<f64>(0x3FEA5FFFDE04FF95), reinterpret<f64>(0x3C867DA98CE9B26B),
  reinterpret<f64>(0x3FEA9FFFCA5E8D2B), reinterpret<f64>(0xBC8284C9B54C13DE),
  reinterpret<f64>(0x3FEADFFFDDAD03EA), reinterpret<f64>(0x3C5812C8EA602E3C),
  reinterpret<f64>(0x3FEB1FFFF10D3D4D), reinterpret<f64>(0xBC8EFADDAD27789C),
  reinterpret<f64>(0x3FEB5FFFCE21165A), reinterpret<f64>(0x3C53CB1719C61237),
  reinterpret<f64>(0x3FEB9FFFD950E674), reinterpret<f64>(0x3C73F7D94194CE00),
  reinterpret<f64>(0x3FEBE000139CA8AF), reinterpret<f64>(0x3C750AC4215D9BC0),
  reinterpret<f64>(0x3FEC20005B46DF99), reinterpret<f64>(0x3C6BEEA653E9C1C9),
  reinterpret<f64>(0x3FEC600040B9F7AE), reinterpret<f64>(0xBC7C079F274A70D6),
  reinterpret<f64>(0x3FECA0006255FD8A), reinterpret<f64>(0xBC7A0B4076E84C1F),
  reinterpret<f64>(0x3FECDFFFD94C095D), reinterpret<f64>(0x3C88F933F99AB5D7),
  reinterpret<f64>(0x3FED1FFFF975D6CF), reinterpret<f64>(0xBC582C08665FE1BE),
  reinterpret<f64>(0x3FED5FFFA2561C93), reinterpret<f64>(0xBC7B04289BD295F3),
  reinterpret<f64>(0x3FED9FFF9D228B0C), reinterpret<f64>(0x3C870251340FA236),
  reinterpret<f64>(0x3FEDE00065BC7E16), reinterpret<f64>(0xBC75011E16A4D80C),
  reinterpret<f64>(0x3FEE200002F64791), reinterpret<f64>(0x3C89802F09EF62E0),
  reinterpret<f64>(0x3FEE600057D7A6D8), reinterpret<f64>(0xBC7E0B75580CF7FA),
  reinterpret<f64>(0x3FEEA00027EDC00C), reinterpret<f64>(0xBC8C848309459811),
  reinterpret<f64>(0x3FEEE0006CF5CB7C), reinterpret<f64>(0xBC8F8027951576F4),
  reinterpret<f64>(0x3FEF2000782B7DCC), reinterpret<f64>(0xBC8F81D97274538F),
  reinterpret<f64>(0x3FEF6000260C450A), reinterpret<f64>(0xBC4071002727FFDC),
  reinterpret<f64>(0x3FEF9FFFE88CD533), reinterpret<f64>(0xBC581BDCE1FDA8B0),
  reinterpret<f64>(0x3FEFDFFFD50F8689), reinterpret<f64>(0x3C87F91ACB918E6E),
  reinterpret<f64>(0x3FF0200004292367), reinterpret<f64>(0x3C9B7FF365324681),
  reinterpret<f64>(0x3FF05FFFE3E3D668), reinterpret<f64>(0x3C86FA08DDAE957B),
  reinterpret<f64>(0x3FF0A0000A85A757), reinterpret<f64>(0xBC57E2DE80D3FB91),
  reinterpret<f64>(0x3FF0E0001A5F3FCC), reinterpret<f64>(0xBC91823305C5F014),
  reinterpret<f64>(0x3FF11FFFF8AFBAF5), reinterpret<f64>(0xBC8BFABB6680BAC2),
  reinterpret<f64>(0x3FF15FFFE54D91AD), reinterpret<f64>(0xBC9D7F121737E7EF),
  reinterpret<f64>(0x3FF1A00011AC36E1), reinterpret<f64>(0x3C9C000A0516F5FF),
  reinterpret<f64>(0x3FF1E00019C84248), reinterpret<f64>(0xBC9082FBE4DA5DA0),
  reinterpret<f64>(0x3FF220000FFE5E6E), reinterpret<f64>(0xBC88FDD04C9CFB43),
  reinterpret<f64>(0x3FF26000269FD891), reinterpret<f64>(0x3C8CFE2A7994D182),
  reinterpret<f64>(0x3FF2A00029A6E6DA), reinterpret<f64>(0xBC700273715E8BC5),
  reinterpret<f64>(0x3FF2DFFFE0293E39), reinterpret<f64>(0x3C9B7C39DAB2A6F9),
  reinterpret<f64>(0x3FF31FFFF7DCF082), reinterpret<f64>(0x3C7DF1336EDC5254),
  reinterpret<f64>(0x3FF35FFFF05A8B60), reinterpret<f64>(0xBC9E03564CCD31EB),
  reinterpret<f64>(0x3FF3A0002E0EAECC), reinterpret<f64>(0x3C75F0E74BD3A477),
  reinterpret<f64>(0x3FF3E000043BB236), reinterpret<f64>(0x3C9C7DCB149D8833),
  reinterpret<f64>(0x3FF4200002D187FF), reinterpret<f64>(0x3C7E08AFCF2D3D28),
  reinterpret<f64>(0x3FF460000D387CB1), reinterpret<f64>(0x3C820837856599A6),
  reinterpret<f64>(0x3FF4A00004569F89), reinterpret<f64>(0xBC89FA5C904FBCD2),
  reinterpret<f64>(0x3FF4E000043543F3), reinterpret<f64>(0xBC781125ED175329),
  reinterpret<f64>(0x3FF51FFFCC027F0F), reinterpret<f64>(0x3C9883D8847754DC),
  reinterpret<f64>(0x3FF55FFFFD87B36F), reinterpret<f64>(0xBC8709E731D02807),
  reinterpret<f64>(0x3FF59FFFF21DF7BA), reinterpret<f64>(0x3C87F79F68727B02),
  reinterpret<f64>(0x3FF5DFFFEBFC3481), reinterpret<f64>(0xBC9180902E30E93E)
]);

// @ts-ignore: decorator
@inline
export function log2_lut(x: f64): f64 {
  const N_MASK = (1 << LOG2_TABLE_BITS) - 1;

  const
    LO: u64 = 0x3FEEA4AF00000000, // reinterpret<u64>(1.0 - 0x1.5b51p-5)
    HI: u64 = 0x3FF0B55900000000; // reinterpret<u64>(1.0 + 0x1.6ab2p-5)

  const
    InvLn2hi = reinterpret<f64>(0x3FF7154765200000), // 0x1.7154765200000p+0
    InvLn2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 0x1.705fc2eefa200p-33
    Ox1p52   = reinterpret<f64>(0x4330000000000000); // 0x1p52

  const
    B0 = reinterpret<f64>(0xBFE71547652B82FE), // -0x1.71547652b82fep-1
    B1 = reinterpret<f64>(0x3FDEC709DC3A03F7), //  0x1.ec709dc3a03f7p-2
    B2 = reinterpret<f64>(0xBFD71547652B7C3F), // -0x1.71547652b7c3fp-2
    B3 = reinterpret<f64>(0x3FD2776C50F05BE4), //  0x1.2776c50f05be4p-2
    B4 = reinterpret<f64>(0xBFCEC709DD768FE5), // -0x1.ec709dd768fe5p-3
    B5 = reinterpret<f64>(0x3FCA61761EC4E736), //  0x1.a61761ec4e736p-3
    B6 = reinterpret<f64>(0xBFC7153FBC64A79B), // -0x1.7153fbc64a79bp-3
    B7 = reinterpret<f64>(0x3FC484D154F01B4A), //  0x1.484d154f01b4ap-3
    B8 = reinterpret<f64>(0xBFC289E4A72C383C), // -0x1.289e4a72c383cp-3
    B9 = reinterpret<f64>(0x3FC0B32F285AEE66); //  0x1.0b32f285aee66p-3

  const
    A0 = reinterpret<f64>(0xBFE71547652B8339), // -0x1.71547652b8339p-1
    A1 = reinterpret<f64>(0x3FDEC709DC3A04BE), //  0x1.ec709dc3a04bep-2
    A2 = reinterpret<f64>(0xBFD7154764702FFB), // -0x1.7154764702ffbp-2
    A3 = reinterpret<f64>(0x3FD2776C50034C48), //  0x1.2776c50034c48p-2
    A4 = reinterpret<f64>(0xBFCEC7B328EA92BC), // -0x1.ec7b328ea92bcp-3
    A5 = reinterpret<f64>(0x3FCA6225E117F92E); //  0x1.a6225e117f92ep-3

  var ix = reinterpret<u64>(x);
  if (ix - LO < HI - LO) {
    let r = x - 1.0;
    // #if __FP_FAST_FMA
    //     hi = r * InvLn2hi;
    //     lo = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -hi);
    // #else
    let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);
    let rlo = r - rhi;
    let hi  = rhi * InvLn2hi;
    let lo  = rlo * InvLn2hi + r * InvLn2lo;
    // #endif
    let r2 = r * r; // rounding error: 0x1p-62
    let r4 = r2 * r2;
    // Worst-case error is less than 0.54 ULP (0.55 ULP without fma)
    let p = r2 * (B0 + r * B1);
    let y = hi + p;
    lo += hi - y + p;
    lo += r4 * (B2 + r * B3 + r2 * (B4 + r * B5) +
          r4 * (B6 + r * B7 + r2 * (B8 + r * B9)));
    return y + lo;
  }
  var top = <u32>(ix >> 48);
  if (top - 0x0010 >= 0x7ff0 - 0x0010) {
    // x < 0x1p-1022 or inf or nan.
    if ((ix << 1) == 0) return -1.0 / (x * x);
    if (ix == 0x7FF0000000000000) return x; // log(inf) == inf
    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);
    // x is subnormal, normalize it.
    ix = reinterpret<u64>(x * Ox1p52);
    ix -= u64(52) << 52;
  }

  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.
  // The range is split into N subintervals.
  // The ith subinterval contains z and c is near its center.
  var tmp  = ix - 0x3FE6000000000000;
  var i    = <usize>((tmp >> (52 - LOG2_TABLE_BITS)) & N_MASK);
  var k    = <i64>tmp >> 52;
  var iz   = ix - (tmp & 0xFFF0000000000000);

  var invc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;
  var logc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;
  var z    = reinterpret<f64>(iz);
  var kd   = <f64>k;

  // log2(x) = log2(z/c) + log2(c) + k.
  // r ~= z/c - 1, |r| < 1/(2*N).
  // #if __FP_FAST_FMA
  // 	// rounding error: 0x1p-55/N.
  // 	r = __builtin_fma(z, invc, -1.0);
  // 	t1 = r * InvLn2hi;
  // 	t2 = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -t1);
  // #else
  // rounding error: 0x1p-55/N + 0x1p-65.
  var chi = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].chi;
  var clo = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].clo;

  var r   = (z - chi - clo) * invc;
  var rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);
  var rlo = r - rhi;
  var t1  = rhi * InvLn2hi;
  var t2  = rlo * InvLn2hi + r * InvLn2lo;
  // #endif

  // hi + lo = r/ln2 + log2(c) + k
  var t3 = kd + logc;
  var hi = t3 + t1;
  var lo = t3 - hi + t1 + t2;

  // log2(r+1) = r/ln2 + r^2*poly(r)
  // Evaluation is optimized assuming superscalar pipelined execution
  var r2 = r * r; // rounding error: 0x1p-54/N^2
  // Worst-case error if |y| > 0x1p-4: 0.547 ULP (0.550 ULP without fma).
  // ~ 0.5 + 2/N/ln2 + abs-poly-error*0x1p56 ULP (+ 0.003 ULP without fma).
  var p = A0 + r * A1 + r2 * (A2 + r * A3) + (r2 * r2) * (A4 + r * A5);
  return lo + r2 * p + hi;
}

//
// Lookup data for log. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log.c
//

// @ts-ignore: decorator
@inline const LOG_TABLE_BITS = 7;

/* Algorithm:

  x = 2^k z
  log(x) = k ln2 + log(c) + log(z/c)
  log(z/c) = poly(z/c - 1)

where z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls
into the ith one, then table entries are computed as

  tab[i].invc = 1/c
  tab[i].logc = (double)log(c)
  tab2[i].chi = (double)c
  tab2[i].clo = (double)(c - (double)c)

where c is near the center of the subinterval and is chosen by trying +-2^29
floating point invc candidates around 1/center and selecting one for which

  1) the rounding error in 0x1.8p9 + logc is 0,
  2) the rounding error in z - chi - clo is < 0x1p-66 and
  3) the rounding error in (double)log(c) is minimized (< 0x1p-66).

Note: 1) ensures that k*ln2hi + logc can be computed without rounding error,
2) ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to
a single rounding error when there is no fast fma for z*invc - 1, 3) ensures
that logc + poly(z/c - 1) has small error, however near x == 1 when
|log(x)| < 0x1p-4, this is not enough so that is special cased.*/

// @ts-ignore: decorator
@lazy @inline const LOG_DATA_TAB1 = memory.data<f64>([
  //              invc                ,                 logc
  reinterpret<f64>(0x3FF734F0C3E0DE9F), reinterpret<f64>(0xBFD7CC7F79E69000),
  reinterpret<f64>(0x3FF713786A2CE91F), reinterpret<f64>(0xBFD76FEEC20D0000),
  reinterpret<f64>(0x3FF6F26008FAB5A0), reinterpret<f64>(0xBFD713E31351E000),
  reinterpret<f64>(0x3FF6D1A61F138C7D), reinterpret<f64>(0xBFD6B85B38287800),
  reinterpret<f64>(0x3FF6B1490BC5B4D1), reinterpret<f64>(0xBFD65D5590807800),
  reinterpret<f64>(0x3FF69147332F0CBA), reinterpret<f64>(0xBFD602D076180000),
  reinterpret<f64>(0x3FF6719F18224223), reinterpret<f64>(0xBFD5A8CA86909000),
  reinterpret<f64>(0x3FF6524F99A51ED9), reinterpret<f64>(0xBFD54F4356035000),
  reinterpret<f64>(0x3FF63356AA8F24C4), reinterpret<f64>(0xBFD4F637C36B4000),
  reinterpret<f64>(0x3FF614B36B9DDC14), reinterpret<f64>(0xBFD49DA7FDA85000),
  reinterpret<f64>(0x3FF5F66452C65C4C), reinterpret<f64>(0xBFD445923989A800),
  reinterpret<f64>(0x3FF5D867B5912C4F), reinterpret<f64>(0xBFD3EDF439B0B800),
  reinterpret<f64>(0x3FF5BABCCB5B90DE), reinterpret<f64>(0xBFD396CE448F7000),
  reinterpret<f64>(0x3FF59D61F2D91A78), reinterpret<f64>(0xBFD3401E17BDA000),
  reinterpret<f64>(0x3FF5805612465687), reinterpret<f64>(0xBFD2E9E2EF468000),
  reinterpret<f64>(0x3FF56397CEE76BD3), reinterpret<f64>(0xBFD2941B3830E000),
  reinterpret<f64>(0x3FF54725E2A77F93), reinterpret<f64>(0xBFD23EC58CDA8800),
  reinterpret<f64>(0x3FF52AFF42064583), reinterpret<f64>(0xBFD1E9E129279000),
  reinterpret<f64>(0x3FF50F22DBB2BDDF), reinterpret<f64>(0xBFD1956D2B48F800),
  reinterpret<f64>(0x3FF4F38F4734DED7), reinterpret<f64>(0xBFD141679AB9F800),
  reinterpret<f64>(0x3FF4D843CFDE2840), reinterpret<f64>(0xBFD0EDD094EF9800),
  reinterpret<f64>(0x3FF4BD3EC078A3C8), reinterpret<f64>(0xBFD09AA518DB1000),
  reinterpret<f64>(0x3FF4A27FC3E0258A), reinterpret<f64>(0xBFD047E65263B800),
  reinterpret<f64>(0x3FF4880524D48434), reinterpret<f64>(0xBFCFEB224586F000),
  reinterpret<f64>(0x3FF46DCE1B192D0B), reinterpret<f64>(0xBFCF474A7517B000),
  reinterpret<f64>(0x3FF453D9D3391854), reinterpret<f64>(0xBFCEA4443D103000),
  reinterpret<f64>(0x3FF43A2744B4845A), reinterpret<f64>(0xBFCE020D44E9B000),
  reinterpret<f64>(0x3FF420B54115F8FB), reinterpret<f64>(0xBFCD60A22977F000),
  reinterpret<f64>(0x3FF40782DA3EF4B1), reinterpret<f64>(0xBFCCC00104959000),
  reinterpret<f64>(0x3FF3EE8F5D57FE8F), reinterpret<f64>(0xBFCC202956891000),
  reinterpret<f64>(0x3FF3D5D9A00B4CE9), reinterpret<f64>(0xBFCB81178D811000),
  reinterpret<f64>(0x3FF3BD60C010C12B), reinterpret<f64>(0xBFCAE2C9CCD3D000),
  reinterpret<f64>(0x3FF3A5242B75DAB8), reinterpret<f64>(0xBFCA45402E129000),
  reinterpret<f64>(0x3FF38D22CD9FD002), reinterpret<f64>(0xBFC9A877681DF000),
  reinterpret<f64>(0x3FF3755BC5847A1C), reinterpret<f64>(0xBFC90C6D69483000),
  reinterpret<f64>(0x3FF35DCE49AD36E2), reinterpret<f64>(0xBFC87120A645C000),
  reinterpret<f64>(0x3FF34679984DD440), reinterpret<f64>(0xBFC7D68FB4143000),
  reinterpret<f64>(0x3FF32F5CCEFFCB24), reinterpret<f64>(0xBFC73CB83C627000),
  reinterpret<f64>(0x3FF3187775A10D49), reinterpret<f64>(0xBFC6A39A9B376000),
  reinterpret<f64>(0x3FF301C8373E3990), reinterpret<f64>(0xBFC60B3154B7A000),
  reinterpret<f64>(0x3FF2EB4EBB95F841), reinterpret<f64>(0xBFC5737D76243000),
  reinterpret<f64>(0x3FF2D50A0219A9D1), reinterpret<f64>(0xBFC4DC7B8FC23000),
  reinterpret<f64>(0x3FF2BEF9A8B7FD2A), reinterpret<f64>(0xBFC4462C51D20000),
  reinterpret<f64>(0x3FF2A91C7A0C1BAB), reinterpret<f64>(0xBFC3B08ABC830000),
  reinterpret<f64>(0x3FF293726014B530), reinterpret<f64>(0xBFC31B996B490000),
  reinterpret<f64>(0x3FF27DFA5757A1F5), reinterpret<f64>(0xBFC2875490A44000),
  reinterpret<f64>(0x3FF268B39B1D3BBF), reinterpret<f64>(0xBFC1F3B9F879A000),
  reinterpret<f64>(0x3FF2539D838FF5BD), reinterpret<f64>(0xBFC160C8252CA000),
  reinterpret<f64>(0x3FF23EB7AAC9083B), reinterpret<f64>(0xBFC0CE7F57F72000),
  reinterpret<f64>(0x3FF22A012BA940B6), reinterpret<f64>(0xBFC03CDC49FEA000),
  reinterpret<f64>(0x3FF2157996CC4132), reinterpret<f64>(0xBFBF57BDBC4B8000),
  reinterpret<f64>(0x3FF201201DD2FC9B), reinterpret<f64>(0xBFBE370896404000),
  reinterpret<f64>(0x3FF1ECF4494D480B), reinterpret<f64>(0xBFBD17983EF94000),
  reinterpret<f64>(0x3FF1D8F5528F6569), reinterpret<f64>(0xBFBBF9674ED8A000),
  reinterpret<f64>(0x3FF1C52311577E7C), reinterpret<f64>(0xBFBADC79202F6000),
  reinterpret<f64>(0x3FF1B17C74CB26E9), reinterpret<f64>(0xBFB9C0C3E7288000),
  reinterpret<f64>(0x3FF19E010C2C1AB6), reinterpret<f64>(0xBFB8A646B372C000),
  reinterpret<f64>(0x3FF18AB07BB670BD), reinterpret<f64>(0xBFB78D01B3AC0000),
  reinterpret<f64>(0x3FF1778A25EFBCB6), reinterpret<f64>(0xBFB674F145380000),
  reinterpret<f64>(0x3FF1648D354C31DA), reinterpret<f64>(0xBFB55E0E6D878000),
  reinterpret<f64>(0x3FF151B990275FDD), reinterpret<f64>(0xBFB4485CDEA1E000),
  reinterpret<f64>(0x3FF13F0EA432D24C), reinterpret<f64>(0xBFB333D94D6AA000),
  reinterpret<f64>(0x3FF12C8B7210F9DA), reinterpret<f64>(0xBFB22079F8C56000),
  reinterpret<f64>(0x3FF11A3028ECB531), reinterpret<f64>(0xBFB10E4698622000),
  reinterpret<f64>(0x3FF107FBDA8434AF), reinterpret<f64>(0xBFAFFA6C6AD20000),
  reinterpret<f64>(0x3FF0F5EE0F4E6BB3), reinterpret<f64>(0xBFADDA8D4A774000),
  reinterpret<f64>(0x3FF0E4065D2A9FCE), reinterpret<f64>(0xBFABBCECE4850000),
  reinterpret<f64>(0x3FF0D244632CA521), reinterpret<f64>(0xBFA9A1894012C000),
  reinterpret<f64>(0x3FF0C0A77CE2981A), reinterpret<f64>(0xBFA788583302C000),
  reinterpret<f64>(0x3FF0AF2F83C636D1), reinterpret<f64>(0xBFA5715E67D68000),
  reinterpret<f64>(0x3FF09DDB98A01339), reinterpret<f64>(0xBFA35C8A49658000),
  reinterpret<f64>(0x3FF08CABAF52E7DF), reinterpret<f64>(0xBFA149E364154000),
  reinterpret<f64>(0x3FF07B9F2F4E28FB), reinterpret<f64>(0xBF9E72C082EB8000),
  reinterpret<f64>(0x3FF06AB58C358F19), reinterpret<f64>(0xBF9A55F152528000),
  reinterpret<f64>(0x3FF059EEA5ECF92C), reinterpret<f64>(0xBF963D62CF818000),
  reinterpret<f64>(0x3FF04949CDD12C90), reinterpret<f64>(0xBF9228FB8CAA0000),
  reinterpret<f64>(0x3FF038C6C6F0ADA9), reinterpret<f64>(0xBF8C317B20F90000),
  reinterpret<f64>(0x3FF02865137932A9), reinterpret<f64>(0xBF8419355DAA0000),
  reinterpret<f64>(0x3FF0182427EA7348), reinterpret<f64>(0xBF781203C2EC0000),
  reinterpret<f64>(0x3FF008040614B195), reinterpret<f64>(0xBF60040979240000),
  reinterpret<f64>(0x3FEFE01FF726FA1A), reinterpret<f64>(0x3F6FEFF384900000),
  reinterpret<f64>(0x3FEFA11CC261EA74), reinterpret<f64>(0x3F87DC41353D0000),
  reinterpret<f64>(0x3FEF6310B081992E), reinterpret<f64>(0x3F93CEA3C4C28000),
  reinterpret<f64>(0x3FEF25F63CEEADCD), reinterpret<f64>(0x3F9B9FC114890000),
  reinterpret<f64>(0x3FEEE9C8039113E7), reinterpret<f64>(0x3FA1B0D8CE110000),
  reinterpret<f64>(0x3FEEAE8078CBB1AB), reinterpret<f64>(0x3FA58A5BD001C000),
  reinterpret<f64>(0x3FEE741AA29D0C9B), reinterpret<f64>(0x3FA95C8340D88000),
  reinterpret<f64>(0x3FEE3A91830A99B5), reinterpret<f64>(0x3FAD276AEF578000),
  reinterpret<f64>(0x3FEE01E009609A56), reinterpret<f64>(0x3FB07598E598C000),
  reinterpret<f64>(0x3FEDCA01E577BB98), reinterpret<f64>(0x3FB253F5E30D2000),
  reinterpret<f64>(0x3FED92F20B7C9103), reinterpret<f64>(0x3FB42EDD8B380000),
  reinterpret<f64>(0x3FED5CAC66FB5CCE), reinterpret<f64>(0x3FB606598757C000),
  reinterpret<f64>(0x3FED272CAA5EDE9D), reinterpret<f64>(0x3FB7DA76356A0000),
  reinterpret<f64>(0x3FECF26E3E6B2CCD), reinterpret<f64>(0x3FB9AB434E1C6000),
  reinterpret<f64>(0x3FECBE6DA2A77902), reinterpret<f64>(0x3FBB78C7BB0D6000),
  reinterpret<f64>(0x3FEC8B266D37086D), reinterpret<f64>(0x3FBD431332E72000),
  reinterpret<f64>(0x3FEC5894BD5D5804), reinterpret<f64>(0x3FBF0A3171DE6000),
  reinterpret<f64>(0x3FEC26B533BB9F8C), reinterpret<f64>(0x3FC067152B914000),
  reinterpret<f64>(0x3FEBF583EEECE73F), reinterpret<f64>(0x3FC147858292B000),
  reinterpret<f64>(0x3FEBC4FD75DB96C1), reinterpret<f64>(0x3FC2266ECDCA3000),
  reinterpret<f64>(0x3FEB951E0C864A28), reinterpret<f64>(0x3FC303D7A6C55000),
  reinterpret<f64>(0x3FEB65E2C5EF3E2C), reinterpret<f64>(0x3FC3DFC33C331000),
  reinterpret<f64>(0x3FEB374867C9888B), reinterpret<f64>(0x3FC4BA366B7A8000),
  reinterpret<f64>(0x3FEB094B211D304A), reinterpret<f64>(0x3FC5933928D1F000),
  reinterpret<f64>(0x3FEADBE885F2EF7E), reinterpret<f64>(0x3FC66ACD2418F000),
  reinterpret<f64>(0x3FEAAF1D31603DA2), reinterpret<f64>(0x3FC740F8EC669000),
  reinterpret<f64>(0x3FEA82E63FD358A7), reinterpret<f64>(0x3FC815C0F51AF000),
  reinterpret<f64>(0x3FEA5740EF09738B), reinterpret<f64>(0x3FC8E92954F68000),
  reinterpret<f64>(0x3FEA2C2A90AB4B27), reinterpret<f64>(0x3FC9BB3602F84000),
  reinterpret<f64>(0x3FEA01A01393F2D1), reinterpret<f64>(0x3FCA8BED1C2C0000),
  reinterpret<f64>(0x3FE9D79F24DB3C1B), reinterpret<f64>(0x3FCB5B515C01D000),
  reinterpret<f64>(0x3FE9AE2505C7B190), reinterpret<f64>(0x3FCC2967CCBCC000),
  reinterpret<f64>(0x3FE9852EF297CE2F), reinterpret<f64>(0x3FCCF635D5486000),
  reinterpret<f64>(0x3FE95CBAEEA44B75), reinterpret<f64>(0x3FCDC1BD3446C000),
  reinterpret<f64>(0x3FE934C69DE74838), reinterpret<f64>(0x3FCE8C01B8CFE000),
  reinterpret<f64>(0x3FE90D4F2F6752E6), reinterpret<f64>(0x3FCF5509C0179000),
  reinterpret<f64>(0x3FE8E6528EFFD79D), reinterpret<f64>(0x3FD00E6C121FB800),
  reinterpret<f64>(0x3FE8BFCE9FCC007C), reinterpret<f64>(0x3FD071B80E93D000),
  reinterpret<f64>(0x3FE899C0DABEC30E), reinterpret<f64>(0x3FD0D46B9E867000),
  reinterpret<f64>(0x3FE87427AA2317FB), reinterpret<f64>(0x3FD13687334BD000),
  reinterpret<f64>(0x3FE84F00ACB39A08), reinterpret<f64>(0x3FD1980D67234800),
  reinterpret<f64>(0x3FE82A49E8653E55), reinterpret<f64>(0x3FD1F8FFE0CC8000),
  reinterpret<f64>(0x3FE8060195F40260), reinterpret<f64>(0x3FD2595FD7636800),
  reinterpret<f64>(0x3FE7E22563E0A329), reinterpret<f64>(0x3FD2B9300914A800),
  reinterpret<f64>(0x3FE7BEB377DCB5AD), reinterpret<f64>(0x3FD3187210436000),
  reinterpret<f64>(0x3FE79BAA679725C2), reinterpret<f64>(0x3FD377266DEC1800),
  reinterpret<f64>(0x3FE77907F2170657), reinterpret<f64>(0x3FD3D54FFBAF3000),
  reinterpret<f64>(0x3FE756CADBD6130C), reinterpret<f64>(0x3FD432EEE32FE000)
]);

// @ts-ignore: decorator
@lazy @inline const LOG_DATA_TAB2 = memory.data<f64>([
  //               chi                ,                  clo
  reinterpret<f64>(0x3FE61000014FB66B), reinterpret<f64>(0x3C7E026C91425B3C),
  reinterpret<f64>(0x3FE63000034DB495), reinterpret<f64>(0x3C8DBFEA48005D41),
  reinterpret<f64>(0x3FE650000D94D478), reinterpret<f64>(0x3C8E7FA786D6A5B7),
  reinterpret<f64>(0x3FE67000074E6FAD), reinterpret<f64>(0x3C61FCEA6B54254C),
  reinterpret<f64>(0x3FE68FFFFEDF0FAE), reinterpret<f64>(0xBC7C7E274C590EFD),
  reinterpret<f64>(0x3FE6B0000763C5BC), reinterpret<f64>(0xBC8AC16848DCDA01),
  reinterpret<f64>(0x3FE6D0001E5CC1F6), reinterpret<f64>(0x3C833F1C9D499311),
  reinterpret<f64>(0x3FE6EFFFEB05F63E), reinterpret<f64>(0xBC7E80041AE22D53),
  reinterpret<f64>(0x3FE710000E869780), reinterpret<f64>(0x3C7BFF6671097952),
  reinterpret<f64>(0x3FE72FFFFC67E912), reinterpret<f64>(0x3C8C00E226BD8724),
  reinterpret<f64>(0x3FE74FFFDF81116A), reinterpret<f64>(0xBC6E02916EF101D2),
  reinterpret<f64>(0x3FE770000F679C90), reinterpret<f64>(0xBC67FC71CD549C74),
  reinterpret<f64>(0x3FE78FFFFA7EC835), reinterpret<f64>(0x3C81BEC19EF50483),
  reinterpret<f64>(0x3FE7AFFFFE20C2E6), reinterpret<f64>(0xBC707E1729CC6465),
  reinterpret<f64>(0x3FE7CFFFED3FC900), reinterpret<f64>(0xBC808072087B8B1C),
  reinterpret<f64>(0x3FE7EFFFE9261A76), reinterpret<f64>(0x3C8DC0286D9DF9AE),
  reinterpret<f64>(0x3FE81000049CA3E8), reinterpret<f64>(0x3C897FD251E54C33),
  reinterpret<f64>(0x3FE8300017932C8F), reinterpret<f64>(0xBC8AFEE9B630F381),
  reinterpret<f64>(0x3FE850000633739C), reinterpret<f64>(0x3C89BFBF6B6535BC),
  reinterpret<f64>(0x3FE87000204289C6), reinterpret<f64>(0xBC8BBF65F3117B75),
  reinterpret<f64>(0x3FE88FFFEBF57904), reinterpret<f64>(0xBC89006EA23DCB57),
  reinterpret<f64>(0x3FE8B00022BC04DF), reinterpret<f64>(0xBC7D00DF38E04B0A),
  reinterpret<f64>(0x3FE8CFFFE50C1B8A), reinterpret<f64>(0xBC88007146FF9F05),
  reinterpret<f64>(0x3FE8EFFFFC918E43), reinterpret<f64>(0x3C83817BD07A7038),
  reinterpret<f64>(0x3FE910001EFA5FC7), reinterpret<f64>(0x3C893E9176DFB403),
  reinterpret<f64>(0x3FE9300013467BB9), reinterpret<f64>(0x3C7F804E4B980276),
  reinterpret<f64>(0x3FE94FFFE6EE076F), reinterpret<f64>(0xBC8F7EF0D9FF622E),
  reinterpret<f64>(0x3FE96FFFDE3C12D1), reinterpret<f64>(0xBC7082AA962638BA),
  reinterpret<f64>(0x3FE98FFFF4458A0D), reinterpret<f64>(0xBC87801B9164A8EF),
  reinterpret<f64>(0x3FE9AFFFDD982E3E), reinterpret<f64>(0xBC8740E08A5A9337),
  reinterpret<f64>(0x3FE9CFFFED49FB66), reinterpret<f64>(0x3C3FCE08C19BE000),
  reinterpret<f64>(0x3FE9F00020F19C51), reinterpret<f64>(0xBC8A3FAA27885B0A),
  reinterpret<f64>(0x3FEA10001145B006), reinterpret<f64>(0x3C74FF489958DA56),
  reinterpret<f64>(0x3FEA300007BBF6FA), reinterpret<f64>(0x3C8CBEAB8A2B6D18),
  reinterpret<f64>(0x3FEA500010971D79), reinterpret<f64>(0x3C88FECADD787930),
  reinterpret<f64>(0x3FEA70001DF52E48), reinterpret<f64>(0xBC8F41763DD8ABDB),
  reinterpret<f64>(0x3FEA90001C593352), reinterpret<f64>(0xBC8EBF0284C27612),
  reinterpret<f64>(0x3FEAB0002A4F3E4B), reinterpret<f64>(0xBC69FD043CFF3F5F),
  reinterpret<f64>(0x3FEACFFFD7AE1ED1), reinterpret<f64>(0xBC823EE7129070B4),
  reinterpret<f64>(0x3FEAEFFFEE510478), reinterpret<f64>(0x3C6A063EE00EDEA3),
  reinterpret<f64>(0x3FEB0FFFDB650D5B), reinterpret<f64>(0x3C5A06C8381F0AB9),
  reinterpret<f64>(0x3FEB2FFFFEAACA57), reinterpret<f64>(0xBC79011E74233C1D),
  reinterpret<f64>(0x3FEB4FFFD995BADC), reinterpret<f64>(0xBC79FF1068862A9F),
  reinterpret<f64>(0x3FEB7000249E659C), reinterpret<f64>(0x3C8AFF45D0864F3E),
  reinterpret<f64>(0x3FEB8FFFF9871640), reinterpret<f64>(0x3C7CFE7796C2C3F9),
  reinterpret<f64>(0x3FEBAFFFD204CB4F), reinterpret<f64>(0xBC63FF27EEF22BC4),
  reinterpret<f64>(0x3FEBCFFFD2415C45), reinterpret<f64>(0xBC6CFFB7EE3BEA21),
  reinterpret<f64>(0x3FEBEFFFF86309DF), reinterpret<f64>(0xBC814103972E0B5C),
  reinterpret<f64>(0x3FEC0FFFE1B57653), reinterpret<f64>(0x3C8BC16494B76A19),
  reinterpret<f64>(0x3FEC2FFFF1FA57E3), reinterpret<f64>(0xBC64FEEF8D30C6ED),
  reinterpret<f64>(0x3FEC4FFFDCBFE424), reinterpret<f64>(0xBC843F68BCEC4775),
  reinterpret<f64>(0x3FEC6FFFED54B9F7), reinterpret<f64>(0x3C847EA3F053E0EC),
  reinterpret<f64>(0x3FEC8FFFEB998FD5), reinterpret<f64>(0x3C7383068DF992F1),
  reinterpret<f64>(0x3FECB0002125219A), reinterpret<f64>(0xBC68FD8E64180E04),
  reinterpret<f64>(0x3FECCFFFDD94469C), reinterpret<f64>(0x3C8E7EBE1CC7EA72),
  reinterpret<f64>(0x3FECEFFFEAFDC476), reinterpret<f64>(0x3C8EBE39AD9F88FE),
  reinterpret<f64>(0x3FED1000169AF82B), reinterpret<f64>(0x3C757D91A8B95A71),
  reinterpret<f64>(0x3FED30000D0FF71D), reinterpret<f64>(0x3C89C1906970C7DA),
  reinterpret<f64>(0x3FED4FFFEA790FC4), reinterpret<f64>(0xBC580E37C558FE0C),
  reinterpret<f64>(0x3FED70002EDC87E5), reinterpret<f64>(0xBC7F80D64DC10F44),
  reinterpret<f64>(0x3FED900021DC82AA), reinterpret<f64>(0xBC747C8F94FD5C5C),
  reinterpret<f64>(0x3FEDAFFFD86B0283), reinterpret<f64>(0x3C8C7F1DC521617E),
  reinterpret<f64>(0x3FEDD000296C4739), reinterpret<f64>(0x3C88019EB2FFB153),
  reinterpret<f64>(0x3FEDEFFFE54490F5), reinterpret<f64>(0x3C6E00D2C652CC89),
  reinterpret<f64>(0x3FEE0FFFCDABF694), reinterpret<f64>(0xBC7F8340202D69D2),
  reinterpret<f64>(0x3FEE2FFFDB52C8DD), reinterpret<f64>(0x3C7B00C1CA1B0864),
  reinterpret<f64>(0x3FEE4FFFF24216EF), reinterpret<f64>(0x3C72FFA8B094AB51),
  reinterpret<f64>(0x3FEE6FFFE88A5E11), reinterpret<f64>(0xBC57F673B1EFBE59),
  reinterpret<f64>(0x3FEE9000119EFF0D), reinterpret<f64>(0xBC84808D5E0BC801),
  reinterpret<f64>(0x3FEEAFFFDFA51744), reinterpret<f64>(0x3C780006D54320B5),
  reinterpret<f64>(0x3FEED0001A127FA1), reinterpret<f64>(0xBC5002F860565C92),
  reinterpret<f64>(0x3FEEF00007BABCC4), reinterpret<f64>(0xBC8540445D35E611),
  reinterpret<f64>(0x3FEF0FFFF57A8D02), reinterpret<f64>(0xBC4FFB3139EF9105),
  reinterpret<f64>(0x3FEF30001EE58AC7), reinterpret<f64>(0x3C8A81ACF2731155),
  reinterpret<f64>(0x3FEF4FFFF5823494), reinterpret<f64>(0x3C8A3F41D4D7C743),
  reinterpret<f64>(0x3FEF6FFFFCA94C6B), reinterpret<f64>(0xBC6202F41C987875),
  reinterpret<f64>(0x3FEF8FFFE1F9C441), reinterpret<f64>(0x3C777DD1F477E74B),
  reinterpret<f64>(0x3FEFAFFFD2E0E37E), reinterpret<f64>(0xBC6F01199A7CA331),
  reinterpret<f64>(0x3FEFD0001C77E49E), reinterpret<f64>(0x3C7181EE4BCEACB1),
  reinterpret<f64>(0x3FEFEFFFF7E0C331), reinterpret<f64>(0xBC6E05370170875A),
  reinterpret<f64>(0x3FF00FFFF465606E), reinterpret<f64>(0xBC8A7EAD491C0ADA),
  reinterpret<f64>(0x3FF02FFFF3867A58), reinterpret<f64>(0xBC977F69C3FCB2E0),
  reinterpret<f64>(0x3FF04FFFFDFC0D17), reinterpret<f64>(0x3C97BFFE34CB945B),
  reinterpret<f64>(0x3FF0700003CD4D82), reinterpret<f64>(0x3C820083C0E456CB),
  reinterpret<f64>(0x3FF08FFFF9F2CBE8), reinterpret<f64>(0xBC6DFFDFBE37751A),
  reinterpret<f64>(0x3FF0B000010CDA65), reinterpret<f64>(0xBC913F7FAEE626EB),
  reinterpret<f64>(0x3FF0D00001A4D338), reinterpret<f64>(0x3C807DFA79489FF7),
  reinterpret<f64>(0x3FF0EFFFFADAFDFD), reinterpret<f64>(0xBC77040570D66BC0),
  reinterpret<f64>(0x3FF110000BBAFD96), reinterpret<f64>(0x3C8E80D4846D0B62),
  reinterpret<f64>(0x3FF12FFFFAE5F45D), reinterpret<f64>(0x3C9DBFFA64FD36EF),
  reinterpret<f64>(0x3FF150000DD59AD9), reinterpret<f64>(0x3C9A0077701250AE),
  reinterpret<f64>(0x3FF170000F21559A), reinterpret<f64>(0x3C8DFDF9E2E3DEEE),
  reinterpret<f64>(0x3FF18FFFFC275426), reinterpret<f64>(0x3C910030DC3B7273),
  reinterpret<f64>(0x3FF1B000123D3C59), reinterpret<f64>(0x3C997F7980030188),
  reinterpret<f64>(0x3FF1CFFFF8299EB7), reinterpret<f64>(0xBC65F932AB9F8C67),
  reinterpret<f64>(0x3FF1EFFFF48AD400), reinterpret<f64>(0x3C937FBF9DA75BEB),
  reinterpret<f64>(0x3FF210000C8B86A4), reinterpret<f64>(0x3C9F806B91FD5B22),
  reinterpret<f64>(0x3FF2300003854303), reinterpret<f64>(0x3C93FFC2EB9FBF33),
  reinterpret<f64>(0x3FF24FFFFFBCF684), reinterpret<f64>(0x3C7601E77E2E2E72),
  reinterpret<f64>(0x3FF26FFFF52921D9), reinterpret<f64>(0x3C7FFCBB767F0C61),
  reinterpret<f64>(0x3FF2900014933A3C), reinterpret<f64>(0xBC7202CA3C02412B),
  reinterpret<f64>(0x3FF2B00014556313), reinterpret<f64>(0xBC92808233F21F02),
  reinterpret<f64>(0x3FF2CFFFEBFE523B), reinterpret<f64>(0xBC88FF7E384FDCF2),
  reinterpret<f64>(0x3FF2F0000BB8AD96), reinterpret<f64>(0xBC85FF51503041C5),
  reinterpret<f64>(0x3FF30FFFFB7AE2AF), reinterpret<f64>(0xBC810071885E289D),
  reinterpret<f64>(0x3FF32FFFFEAC5F7F), reinterpret<f64>(0xBC91FF5D3FB7B715),
  reinterpret<f64>(0x3FF350000CA66756), reinterpret<f64>(0x3C957F82228B82BD),
  reinterpret<f64>(0x3FF3700011FBF721), reinterpret<f64>(0x3C8000BAC40DD5CC),
  reinterpret<f64>(0x3FF38FFFF9592FB9), reinterpret<f64>(0xBC943F9D2DB2A751),
  reinterpret<f64>(0x3FF3B00004DDD242), reinterpret<f64>(0x3C857F6B707638E1),
  reinterpret<f64>(0x3FF3CFFFF5B2C957), reinterpret<f64>(0x3C7A023A10BF1231),
  reinterpret<f64>(0x3FF3EFFFEAB0B418), reinterpret<f64>(0x3C987F6D66B152B0),
  reinterpret<f64>(0x3FF410001532AFF4), reinterpret<f64>(0x3C67F8375F198524),
  reinterpret<f64>(0x3FF4300017478B29), reinterpret<f64>(0x3C8301E672DC5143),
  reinterpret<f64>(0x3FF44FFFE795B463), reinterpret<f64>(0x3C89FF69B8B2895A),
  reinterpret<f64>(0x3FF46FFFE80475E0), reinterpret<f64>(0xBC95C0B19BC2F254),
  reinterpret<f64>(0x3FF48FFFEF6FC1E7), reinterpret<f64>(0x3C9B4009F23A2A72),
  reinterpret<f64>(0x3FF4AFFFE5BEA704), reinterpret<f64>(0xBC94FFB7BF0D7D45),
  reinterpret<f64>(0x3FF4D000171027DE), reinterpret<f64>(0xBC99C06471DC6A3D),
  reinterpret<f64>(0x3FF4F0000FF03EE2), reinterpret<f64>(0x3C977F890B85531C),
  reinterpret<f64>(0x3FF5100012DC4BD1), reinterpret<f64>(0x3C6004657166A436),
  reinterpret<f64>(0x3FF530001605277A), reinterpret<f64>(0xBC96BFCECE233209),
  reinterpret<f64>(0x3FF54FFFECDB704C), reinterpret<f64>(0xBC8902720505A1D7),
  reinterpret<f64>(0x3FF56FFFEF5F54A9), reinterpret<f64>(0x3C9BBFE60EC96412),
  reinterpret<f64>(0x3FF5900017E61012), reinterpret<f64>(0x3C887EC581AFEF90),
  reinterpret<f64>(0x3FF5B00003C93E92), reinterpret<f64>(0xBC9F41080ABF0CC0),
  reinterpret<f64>(0x3FF5D0001D4919BC), reinterpret<f64>(0xBC98812AFB254729),
  reinterpret<f64>(0x3FF5EFFFE7B87A89), reinterpret<f64>(0xBC947EB780ED6904)
]);

// @ts-ignore: decorator
@inline
export function log_lut(x: f64): f64 {
  const N_MASK = (1 << LOG_TABLE_BITS) - 1;

  const
    B0  = reinterpret<f64>(0xBFE0000000000000), // -0x1p-1
    B1  = reinterpret<f64>(0x3FD5555555555577), //  0x1.5555555555577p-2
    B2  = reinterpret<f64>(0xBFCFFFFFFFFFFDCB), // -0x1.ffffffffffdcbp-3
    B3  = reinterpret<f64>(0x3FC999999995DD0C), //  0x1.999999995dd0cp-3
    B4  = reinterpret<f64>(0xBFC55555556745A7), // -0x1.55555556745a7p-3
    B5  = reinterpret<f64>(0x3FC24924A344DE30), //  0x1.24924a344de3p-3
    B6  = reinterpret<f64>(0xBFBFFFFFA4423D65), // -0x1.fffffa4423d65p-4
    B7  = reinterpret<f64>(0x3FBC7184282AD6CA), //  0x1.c7184282ad6cap-4
    B8  = reinterpret<f64>(0xBFB999EB43B068FF), // -0x1.999eb43b068ffp-4
    B9  = reinterpret<f64>(0x3FB78182F7AFD085), //  0x1.78182f7afd085p-4
    B10 = reinterpret<f64>(0xBFB5521375D145CD); // -0x1.5521375d145cdp-4

  const
    A0 = reinterpret<f64>(0xBFE0000000000001),  // -0x1.0000000000001p-1
    A1 = reinterpret<f64>(0x3FD555555551305B),  //  0x1.555555551305bp-2
    A2 = reinterpret<f64>(0xBFCFFFFFFFEB4590),  // -0x1.fffffffeb459p-3
    A3 = reinterpret<f64>(0x3FC999B324F10111),  //  0x1.999b324f10111p-3
    A4 = reinterpret<f64>(0xBFC55575E506C89F);  // -0x1.55575e506c89fp-3

  const
    LO: u64 = 0x3FEE000000000000,
    HI: u64 = 0x3FF1090000000000;

  const
    Ln2hi  = reinterpret<f64>(0x3FE62E42FEFA3800), // 0x1.62e42fefa3800p-1
    Ln2lo  = reinterpret<f64>(0x3D2EF35793C76730), // 0x1.ef35793c76730p-45
    Ox1p27 = reinterpret<f64>(0x41A0000000000000), // 0x1p27
    Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52

  var ix = reinterpret<u64>(x);
  if (ix - LO < HI - LO) {
    let r  = x - 1.0;
    let r2 = r * r;
    let r3 = r2 * r;
    let y =
      r3 * (B1 + r * B2 + r2 * B3 +
      r3 * (B4 + r * B5 + r2 * B6 +
      r3 * (B7 + r * B8 + r2 * B9 + r3 * B10)));
    // Worst-case error is around 0.507 ULP
    let w   = r * Ox1p27;
    let rhi = r + w - w;
    let rlo = r - rhi;
    w = rhi * rhi * B0; // B[0] == -0.5
    let hi = r + w;
    let lo = r - hi + w;
    lo += B0 * rlo * (rhi + r);
    return y + lo + hi;
  }
  var top = u32(ix >> 48);
  if (top - 0x0010 >= 0x7FF0 - 0x0010) {
    // x < 0x1p-1022 or inf or nan
    if ((ix << 1) == 0) return -1.0 / (x * x);
    if (ix == reinterpret<u64>(Infinity)) return x; // log(inf) == inf
    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);
    // x is subnormal, normalize it
    ix = reinterpret<u64>(x * Ox1p52);
    ix -= u64(52) << 52;
  }

  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.
  // The range is split into N subintervals.
  // The ith subinterval contains z and c is near its center.
  var tmp  = ix - 0x3FE6000000000000;
  var i    = <usize>((tmp >> (52 - LOG_TABLE_BITS)) & N_MASK);
  var k    = <i64>tmp >> 52;
  var iz   = ix - (tmp & (u64(0xFFF) << 52));

  var invc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;
  var logc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;
  var z    = reinterpret<f64>(iz);

  // log(x) = log1p(z/c-1) + log(c) + k*Ln2.
  // r ~= z/c - 1, |r| < 1/(2*N)
  // #if __FP_FAST_FMA
  // 	// rounding error: 0x1p-55/N
  // 	r = __builtin_fma(z, invc, -1.0);
  // #else
  // rounding error: 0x1p-55/N + 0x1p-66
  const chi = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T2[i].chi
  const clo = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T2[i].clo
  var r = (z - chi - clo) * invc;
  // #endif
  var kd = <f64>k;

  // hi + lo = r + log(c) + k*Ln2
  var w  = kd * Ln2hi + logc;
  var hi = w + r;
  var lo = w - hi + r + kd * Ln2lo;

  // log(x) = lo + (log1p(r) - r) + hi
  var r2 = r * r; // rounding error: 0x1p-54/N^2
  // Worst case error if |y| > 0x1p-5:
  // 0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)
  // Worst case error if |y| > 0x1p-4:
  // 0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).
  return lo + r2 * A0 + r * r2 * (A1 + r * A2 + r2 * (A3 + r * A4)) + hi;
}

//
// Lookup data for pow. See: https://git.musl-libc.org/cgit/musl/tree/src/math/pow.c
//

// @ts-ignore: decorator
@inline const POW_LOG_TABLE_BITS = 7;

/* Algorithm:

  x = 2^k z
  log(x) = k ln2 + log(c) + log(z/c)
  log(z/c) = poly(z/c - 1)

where z is in [0x1.69555p-1; 0x1.69555p0] which is split into N subintervals
and z falls into the ith one, then table entries are computed as

  tab[i].invc = 1/c
  tab[i].logc = round(0x1p43*log(c))/0x1p43
  tab[i].logctail = (double)(log(c) - logc)

where c is chosen near the center of the subinterval such that 1/c has only a
few precision bits so z/c - 1 is exactly representible as double:

  1/c = center < 1 ? round(N/center)/N : round(2*N/center)/N/2

Note: |z/c - 1| < 1/N for the chosen c, |log(c) - logc - logctail| < 0x1p-97,
the last few bits of logc are rounded away so k*ln2hi + logc has no rounding
error and the interval for z is selected such that near x == 1, where log(x)
is tiny, large cancellation error is avoided in logc + poly(z/c - 1). */

// @ts-ignore: decorator
@lazy @inline const POW_LOG_DATA_TAB = memory.data<f64>([
  //             invc                 ,pad,               logc                 ,               logctail
  reinterpret<f64>(0x3FF6A00000000000), 0, reinterpret<f64>(0xBFD62C82F2B9C800), reinterpret<f64>(0x3CFAB42428375680),
  reinterpret<f64>(0x3FF6800000000000), 0, reinterpret<f64>(0xBFD5D1BDBF580800), reinterpret<f64>(0xBD1CA508D8E0F720),
  reinterpret<f64>(0x3FF6600000000000), 0, reinterpret<f64>(0xBFD5767717455800), reinterpret<f64>(0xBD2362A4D5B6506D),
  reinterpret<f64>(0x3FF6400000000000), 0, reinterpret<f64>(0xBFD51AAD872DF800), reinterpret<f64>(0xBCE684E49EB067D5),
  reinterpret<f64>(0x3FF6200000000000), 0, reinterpret<f64>(0xBFD4BE5F95777800), reinterpret<f64>(0xBD041B6993293EE0),
  reinterpret<f64>(0x3FF6000000000000), 0, reinterpret<f64>(0xBFD4618BC21C6000), reinterpret<f64>(0x3D13D82F484C84CC),
  reinterpret<f64>(0x3FF5E00000000000), 0, reinterpret<f64>(0xBFD404308686A800), reinterpret<f64>(0x3CDC42F3ED820B3A),
  reinterpret<f64>(0x3FF5C00000000000), 0, reinterpret<f64>(0xBFD3A64C55694800), reinterpret<f64>(0x3D20B1C686519460),
  reinterpret<f64>(0x3FF5A00000000000), 0, reinterpret<f64>(0xBFD347DD9A988000), reinterpret<f64>(0x3D25594DD4C58092),
  reinterpret<f64>(0x3FF5800000000000), 0, reinterpret<f64>(0xBFD2E8E2BAE12000), reinterpret<f64>(0x3D267B1E99B72BD8),
  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),
  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),
  reinterpret<f64>(0x3FF5400000000000), 0, reinterpret<f64>(0xBFD22941FBCF7800), reinterpret<f64>(0xBD165A242853DA76),
  reinterpret<f64>(0x3FF5200000000000), 0, reinterpret<f64>(0xBFD1C898C1699800), reinterpret<f64>(0xBD1FAFBC68E75404),
  reinterpret<f64>(0x3FF5000000000000), 0, reinterpret<f64>(0xBFD1675CABABA800), reinterpret<f64>(0x3D1F1FC63382A8F0),
  reinterpret<f64>(0x3FF4E00000000000), 0, reinterpret<f64>(0xBFD1058BF9AE4800), reinterpret<f64>(0xBD26A8C4FD055A66),
  reinterpret<f64>(0x3FF4C00000000000), 0, reinterpret<f64>(0xBFD0A324E2739000), reinterpret<f64>(0xBD0C6BEE7EF4030E),
  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),
  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),
  reinterpret<f64>(0x3FF4800000000000), 0, reinterpret<f64>(0xBFCFB9186D5E4000), reinterpret<f64>(0x3D0D572AAB993C87),
  reinterpret<f64>(0x3FF4600000000000), 0, reinterpret<f64>(0xBFCEF0ADCBDC6000), reinterpret<f64>(0x3D2B26B79C86AF24),
  reinterpret<f64>(0x3FF4400000000000), 0, reinterpret<f64>(0xBFCE27076E2AF000), reinterpret<f64>(0xBD172F4F543FFF10),
  reinterpret<f64>(0x3FF4200000000000), 0, reinterpret<f64>(0xBFCD5C216B4FC000), reinterpret<f64>(0x3D21BA91BBCA681B),
  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),
  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),
  reinterpret<f64>(0x3FF3E00000000000), 0, reinterpret<f64>(0xBFCBC286742D9000), reinterpret<f64>(0x3D194EB0318BB78F),
  reinterpret<f64>(0x3FF3C00000000000), 0, reinterpret<f64>(0xBFCAF3C94E80C000), reinterpret<f64>(0x3CBA4E633FCD9066),
  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),
  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),
  reinterpret<f64>(0x3FF3800000000000), 0, reinterpret<f64>(0xBFC9525A9CF45000), reinterpret<f64>(0xBD2AD1D904C1D4E3),
  reinterpret<f64>(0x3FF3600000000000), 0, reinterpret<f64>(0xBFC87FA06520D000), reinterpret<f64>(0x3D2BBDBF7FDBFA09),
  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),
  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),
  reinterpret<f64>(0x3FF3200000000000), 0, reinterpret<f64>(0xBFC6D60FE719D000), reinterpret<f64>(0xBD10E46AA3B2E266),
  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),
  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),
  reinterpret<f64>(0x3FF2E00000000000), 0, reinterpret<f64>(0xBFC526E5E3A1B000), reinterpret<f64>(0xBD20DE8B90075B8F),
  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),
  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),
  reinterpret<f64>(0x3FF2A00000000000), 0, reinterpret<f64>(0xBFC371FC201E9000), reinterpret<f64>(0x3CF178864D27543A),
  reinterpret<f64>(0x3FF2800000000000), 0, reinterpret<f64>(0xBFC29552F81FF000), reinterpret<f64>(0xBD248D301771C408),
  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),
  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),
  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),
  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),
  reinterpret<f64>(0x3FF2200000000000), 0, reinterpret<f64>(0xBFBFEC9131DBE000), reinterpret<f64>(0xBD2575545CA333F2),
  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),
  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),
  reinterpret<f64>(0x3FF1E00000000000), 0, reinterpret<f64>(0xBFBC5E548F5BC000), reinterpret<f64>(0xBD1D0C57585FBE06),
  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),
  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),
  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),
  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),
  reinterpret<f64>(0x3FF1800000000000), 0, reinterpret<f64>(0xBFB6F0D28AE56000), reinterpret<f64>(0xBD269737C93373DA),
  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),
  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),
  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),
  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),
  reinterpret<f64>(0x3FF1200000000000), 0, reinterpret<f64>(0xBFB16536EEA38000), reinterpret<f64>(0x3D147C5E768FA309),
  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),
  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),
  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),
  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),
  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),
  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),
  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),
  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),
  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),
  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),
  reinterpret<f64>(0x3FF0600000000000), 0, reinterpret<f64>(0xBF97B91B07D58000), reinterpret<f64>(0xBD288D5493FAA639),
  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),
  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),
  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),
  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),
  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,
  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,
  reinterpret<f64>(0x3FEFC00000000000), 0, reinterpret<f64>(0x3F80101575890000), reinterpret<f64>(0xBD10C76B999D2BE8),
  reinterpret<f64>(0x3FEF800000000000), 0, reinterpret<f64>(0x3F90205658938000), reinterpret<f64>(0xBD23DC5B06E2F7D2),
  reinterpret<f64>(0x3FEF400000000000), 0, reinterpret<f64>(0x3F98492528C90000), reinterpret<f64>(0xBD2AA0BA325A0C34),
  reinterpret<f64>(0x3FEF000000000000), 0, reinterpret<f64>(0x3FA0415D89E74000), reinterpret<f64>(0x3D0111C05CF1D753),
  reinterpret<f64>(0x3FEEC00000000000), 0, reinterpret<f64>(0x3FA466AED42E0000), reinterpret<f64>(0xBD2C167375BDFD28),
  reinterpret<f64>(0x3FEE800000000000), 0, reinterpret<f64>(0x3FA894AA149FC000), reinterpret<f64>(0xBD197995D05A267D),
  reinterpret<f64>(0x3FEE400000000000), 0, reinterpret<f64>(0x3FACCB73CDDDC000), reinterpret<f64>(0xBD1A68F247D82807),
  reinterpret<f64>(0x3FEE200000000000), 0, reinterpret<f64>(0x3FAEEA31C006C000), reinterpret<f64>(0xBD0E113E4FC93B7B),
  reinterpret<f64>(0x3FEDE00000000000), 0, reinterpret<f64>(0x3FB1973BD1466000), reinterpret<f64>(0xBD25325D560D9E9B),
  reinterpret<f64>(0x3FEDA00000000000), 0, reinterpret<f64>(0x3FB3BDF5A7D1E000), reinterpret<f64>(0x3D2CC85EA5DB4ED7),
  reinterpret<f64>(0x3FED600000000000), 0, reinterpret<f64>(0x3FB5E95A4D97A000), reinterpret<f64>(0xBD2C69063C5D1D1E),
  reinterpret<f64>(0x3FED400000000000), 0, reinterpret<f64>(0x3FB700D30AEAC000), reinterpret<f64>(0x3CEC1E8DA99DED32),
  reinterpret<f64>(0x3FED000000000000), 0, reinterpret<f64>(0x3FB9335E5D594000), reinterpret<f64>(0x3D23115C3ABD47DA),
  reinterpret<f64>(0x3FECC00000000000), 0, reinterpret<f64>(0x3FBB6AC88DAD6000), reinterpret<f64>(0xBD1390802BF768E5),
  reinterpret<f64>(0x3FECA00000000000), 0, reinterpret<f64>(0x3FBC885801BC4000), reinterpret<f64>(0x3D2646D1C65AACD3),
  reinterpret<f64>(0x3FEC600000000000), 0, reinterpret<f64>(0x3FBEC739830A2000), reinterpret<f64>(0xBD2DC068AFE645E0),
  reinterpret<f64>(0x3FEC400000000000), 0, reinterpret<f64>(0x3FBFE89139DBE000), reinterpret<f64>(0xBD2534D64FA10AFD),
  reinterpret<f64>(0x3FEC000000000000), 0, reinterpret<f64>(0x3FC1178E8227E000), reinterpret<f64>(0x3D21EF78CE2D07F2),
  reinterpret<f64>(0x3FEBE00000000000), 0, reinterpret<f64>(0x3FC1AA2B7E23F000), reinterpret<f64>(0x3D2CA78E44389934),
  reinterpret<f64>(0x3FEBA00000000000), 0, reinterpret<f64>(0x3FC2D1610C868000), reinterpret<f64>(0x3D039D6CCB81B4A1),
  reinterpret<f64>(0x3FEB800000000000), 0, reinterpret<f64>(0x3FC365FCB0159000), reinterpret<f64>(0x3CC62FA8234B7289),
  reinterpret<f64>(0x3FEB400000000000), 0, reinterpret<f64>(0x3FC4913D8333B000), reinterpret<f64>(0x3D25837954FDB678),
  reinterpret<f64>(0x3FEB200000000000), 0, reinterpret<f64>(0x3FC527E5E4A1B000), reinterpret<f64>(0x3D2633E8E5697DC7),
  reinterpret<f64>(0x3FEAE00000000000), 0, reinterpret<f64>(0x3FC6574EBE8C1000), reinterpret<f64>(0x3D19CF8B2C3C2E78),
  reinterpret<f64>(0x3FEAC00000000000), 0, reinterpret<f64>(0x3FC6F0128B757000), reinterpret<f64>(0xBD25118DE59C21E1),
  reinterpret<f64>(0x3FEAA00000000000), 0, reinterpret<f64>(0x3FC7898D85445000), reinterpret<f64>(0xBD1C661070914305),
  reinterpret<f64>(0x3FEA600000000000), 0, reinterpret<f64>(0x3FC8BEAFEB390000), reinterpret<f64>(0xBD073D54AAE92CD1),
  reinterpret<f64>(0x3FEA400000000000), 0, reinterpret<f64>(0x3FC95A5ADCF70000), reinterpret<f64>(0x3D07F22858A0FF6F),
  reinterpret<f64>(0x3FEA000000000000), 0, reinterpret<f64>(0x3FCA93ED3C8AE000), reinterpret<f64>(0xBD28724350562169),
  reinterpret<f64>(0x3FE9E00000000000), 0, reinterpret<f64>(0x3FCB31D8575BD000), reinterpret<f64>(0xBD0C358D4EACE1AA),
  reinterpret<f64>(0x3FE9C00000000000), 0, reinterpret<f64>(0x3FCBD087383BE000), reinterpret<f64>(0xBD2D4BC4595412B6),
  reinterpret<f64>(0x3FE9A00000000000), 0, reinterpret<f64>(0x3FCC6FFBC6F01000), reinterpret<f64>(0xBCF1EC72C5962BD2),
  reinterpret<f64>(0x3FE9600000000000), 0, reinterpret<f64>(0x3FCDB13DB0D49000), reinterpret<f64>(0xBD2AFF2AF715B035),
  reinterpret<f64>(0x3FE9400000000000), 0, reinterpret<f64>(0x3FCE530EFFE71000), reinterpret<f64>(0x3CC212276041F430),
  reinterpret<f64>(0x3FE9200000000000), 0, reinterpret<f64>(0x3FCEF5ADE4DD0000), reinterpret<f64>(0xBCCA211565BB8E11),
  reinterpret<f64>(0x3FE9000000000000), 0, reinterpret<f64>(0x3FCF991C6CB3B000), reinterpret<f64>(0x3D1BCBECCA0CDF30),
  reinterpret<f64>(0x3FE8C00000000000), 0, reinterpret<f64>(0x3FD07138604D5800), reinterpret<f64>(0x3CF89CDB16ED4E91),
  reinterpret<f64>(0x3FE8A00000000000), 0, reinterpret<f64>(0x3FD0C42D67616000), reinterpret<f64>(0x3D27188B163CEAE9),
  reinterpret<f64>(0x3FE8800000000000), 0, reinterpret<f64>(0x3FD1178E8227E800), reinterpret<f64>(0xBD2C210E63A5F01C),
  reinterpret<f64>(0x3FE8600000000000), 0, reinterpret<f64>(0x3FD16B5CCBACF800), reinterpret<f64>(0x3D2B9ACDF7A51681),
  reinterpret<f64>(0x3FE8400000000000), 0, reinterpret<f64>(0x3FD1BF99635A6800), reinterpret<f64>(0x3D2CA6ED5147BDB7),
  reinterpret<f64>(0x3FE8200000000000), 0, reinterpret<f64>(0x3FD214456D0EB800), reinterpret<f64>(0x3D0A87DEBA46BAEA),
  reinterpret<f64>(0x3FE7E00000000000), 0, reinterpret<f64>(0x3FD2BEF07CDC9000), reinterpret<f64>(0x3D2A9CFA4A5004F4),
  reinterpret<f64>(0x3FE7C00000000000), 0, reinterpret<f64>(0x3FD314F1E1D36000), reinterpret<f64>(0xBD28E27AD3213CB8),
  reinterpret<f64>(0x3FE7A00000000000), 0, reinterpret<f64>(0x3FD36B6776BE1000), reinterpret<f64>(0x3D116ECDB0F177C8),
  reinterpret<f64>(0x3FE7800000000000), 0, reinterpret<f64>(0x3FD3C25277333000), reinterpret<f64>(0x3D183B54B606BD5C),
  reinterpret<f64>(0x3FE7600000000000), 0, reinterpret<f64>(0x3FD419B423D5E800), reinterpret<f64>(0x3D08E436EC90E09D),
  reinterpret<f64>(0x3FE7400000000000), 0, reinterpret<f64>(0x3FD4718DC271C800), reinterpret<f64>(0xBD2F27CE0967D675),
  reinterpret<f64>(0x3FE7200000000000), 0, reinterpret<f64>(0x3FD4C9E09E173000), reinterpret<f64>(0xBD2E20891B0AD8A4),
  reinterpret<f64>(0x3FE7000000000000), 0, reinterpret<f64>(0x3FD522AE0738A000), reinterpret<f64>(0x3D2EBE708164C759),
  reinterpret<f64>(0x3FE6E00000000000), 0, reinterpret<f64>(0x3FD57BF753C8D000), reinterpret<f64>(0x3D1FADEDEE5D40EF),
  reinterpret<f64>(0x3FE6C00000000000), 0, reinterpret<f64>(0x3FD5D5BDDF596000), reinterpret<f64>(0xBD0A0B2A08A465DC)
]);

// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is
// the bit representation of a non-zero finite floating-point value.
// @ts-ignore: decorator
@inline
function checkint(iy: u64): i32 {
  var e = iy >> 52 & 0x7FF;
  if (e < 0x3FF     ) return 0;
  if (e > 0x3FF + 52) return 2;
  e = u64(1) << (0x3FF + 52 - e);
  if (iy & (e - 1)) return 0;
  if (iy &  e     ) return 1;
  return 2;
}

// @ts-ignore: decorator
@inline
function xflow(sign: u32, y: f64): f64 {
  return select(-y, y, sign) * y;
}

// @ts-ignore: decorator
@inline
function uflow(sign: u32): f64 {
  return xflow(sign, reinterpret<f64>(0x1000000000000000)); // 0x1p-767
}

// @ts-ignore: decorator
@inline
function oflow(sign: u32): f64 {
  return xflow(sign, reinterpret<f64>(0x7000000000000000)); // 0x1p769
}

// Returns 1 if input is the bit representation of 0, infinity or nan.
// @ts-ignore: decorator
@inline
function zeroinfnan(u: u64): bool {
  return (u << 1) - 1 >= 0xFFE0000000000000 - 1;
}

// @ts-ignore: decorator
@lazy var log_tail: f64 = 0;

// Compute y+TAIL = log(x) where the rounded result is y and TAIL has about
// additional 15 bits precision. IX is the bit representation of x, but
// normalized in the subnormal range using the sign bit for the exponent.
// @ts-ignore: decorator
@inline
function log_inline(ix: u64): f64 {
  const N = 1 << POW_LOG_TABLE_BITS;
  const N_MASK = N - 1;

  const
    Ln2hi = reinterpret<f64>(0x3FE62E42FEFA3800),
    Ln2lo = reinterpret<f64>(0x3D2EF35793C76730);

  const
    A0 = reinterpret<f64>(0xBFE0000000000000),
    A1 = reinterpret<f64>(0xBFE5555555555560),
    A2 = reinterpret<f64>(0x3FE0000000000006),
    A3 = reinterpret<f64>(0x3FE999999959554E),
    A4 = reinterpret<f64>(0xBFE555555529A47A),
    A5 = reinterpret<f64>(0xBFF2495B9B4845E9),
    A6 = reinterpret<f64>(0x3FF0002B8B263FC3);

  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.
  // The range is split into N subintervals.
  // The ith subinterval contains z and c is near its center.
  var tmp = ix - 0x3fE6955500000000;
  var i   = <usize>((tmp >> (52 - POW_LOG_TABLE_BITS)) & N_MASK);
  var k   = <i64>tmp >> 52;
  var iz  = ix - (tmp & u64(0xFFF) << 52);
  var z   = reinterpret<f64>(iz);
  var kd  = <f64>k;

  // log(x) = k*Ln2 + log(c) + log1p(z/c-1).
  var invc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 0 << alignof<f64>()); // tab[i].invc
  var logc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 2 << alignof<f64>()); // tab[i].logc
  var logctail = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 3 << alignof<f64>()); // tab[i].logctail

  // Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and
  // |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.
  // Split z such that rhi, rlo and rhi*rhi are exact and |rlo| <= |r|.
  var zhi = reinterpret<f64>((iz + u64(0x80000000)) & 0xFFFFFFFF00000000);
  var zlo = z - zhi;
  var rhi = zhi * invc - 1.0;
  var rlo = zlo * invc;
  var r   = rhi + rlo;

  // k * Ln2 + log(c) + r.
  var t1  = kd * Ln2hi + logc;
  var t2  = t1 + r;
  var lo1 = kd * Ln2lo + logctail;
  var lo2 = t1 - t2 + r;

  // Evaluation is optimized assuming superscalar pipelined execution.
  var ar  = A0 * r; // A[0] = -0.5
  var ar2 = r * ar;
  var ar3 = r * ar2;
  // k * Ln2 + log(c) + r + A[0] * r * r.
  var arhi  = A0  * rhi;
  var arhi2 = rhi * arhi;
  var hi    = t2  + arhi2;
  var lo3   = rlo * (ar + arhi);
  var lo4   = t2 - hi + arhi2;

  // p = log1p(r) - r - A[0] * r * r.
  var p  = ar3 * (A1 + r * A2 + ar2 * (A3 + r * A4 + ar2 * (A5 + r * A6)));
  var lo = lo1 + lo2 + lo3 + lo4 + p;
  var y  = hi + lo;
  log_tail = hi - y + lo;

  return y;
}

// @ts-ignore: decorator
@inline const SIGN_BIAS = 0x800 << EXP_TABLE_BITS;

// Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.
// The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.
// @ts-ignore: decorator
@inline
function exp_inline(x: f64, xtail: f64, sign_bias: u32): f64 {
  const N      = 1 << EXP_TABLE_BITS;
  const N_MASK = N - 1;

  const
    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0
    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8
    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47
    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52

  const
    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)
    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)
    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)
    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)

  var abstop: u32;
  var ki: u64, top: u64, sbits: u64;
  var idx: usize;
  // double_t for better performance on targets with FLT_EVAL_METHOD==2.
  var kd: f64, z: f64, r: f64, r2: f64, scale: f64, tail: f64, tmp: f64;

  var ux = reinterpret<u64>(x);
  abstop = <u32>(ux >> 52) & 0x7FF;
  if (abstop - 0x3C9 >= 0x03F) {
    if (abstop - 0x3C9 >= 0x80000000) {
      // Avoid spurious underflow for tiny x.
      // Note: 0 is common input.
      return select(-1.0, 1.0, sign_bias);
    }
    if (abstop >= 0x409) { // top12(1024.0)
      // Note: inf and nan are already handled.
      return ux >> 63 ? uflow(sign_bias) : oflow(sign_bias);
    }
    // Large x is special cased below.
    abstop = 0;
  }

  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].
  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].
  z = InvLn2N * x;

  // #if TOINT_INTRINSICS
  //   kd = roundtoint(z);
  //   ki = converttoint(z);
  // #elif EXP_USE_TOINT_NARROW
  //   // z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.
  //   kd = eval_as_double(z + shift);
  //   ki = asuint64(kd) >> 16;
  //   kd = (double_t)(int32_t)ki;
  // #else
  // z - kd is in [-1, 1] in non-nearest rounding modes
  kd  = z + shift;
  ki  = reinterpret<u64>(kd);
  kd -= shift;
  // #endif
  r = x + kd * NegLn2hiN + kd * NegLn2loN;
  // The code assumes 2^-200 < |xtail| < 2^-8/N
  r += xtail;
  // 2^(k/N) ~= scale * (1 + tail)
  idx = <usize>((ki & N_MASK) << 1);
  top = (ki + sign_bias) << (52 - EXP_TABLE_BITS);

  tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>())));
  // This is only a valid scale when -1023*N < k < 1024*N
  sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top;
  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).
  // Evaluation is optimized assuming superscalar pipelined execution.
  r2 = r * r;
  // Without fma the worst case error is 0.25/N ulp larger.
  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp
  tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);
  if (abstop == 0) return specialcase(tmp, sbits, ki);
  scale = reinterpret<f64>(sbits);
  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there
  // is no spurious underflow here even without fma.
  return scale + scale * tmp;
}

// @ts-ignore: decorator
@inline
export function pow_lut(x: f64, y: f64): f64 {
  const Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52

  var sign_bias: u32 = 0;
  var ix = reinterpret<u64>(x);
  var iy = reinterpret<u64>(y);
  var topx = ix >> 52;
  var topy = iy >> 52;

  if (topx - 0x001 >= 0x7FF - 0x001 || (topy & 0x7FF) - 0x3BE >= 0x43e - 0x3BE) {
    // Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0
    // and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.
    // Special cases: (x < 0x1p-126 or inf or nan) or
    // (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).
    if (zeroinfnan(iy)) {
      if ((iy << 1) == 0) return 1.0;
      if (ix == 0x3FF0000000000000) return NaN; // original: 1.0
      if ((ix << 1) > 0xFFE0000000000000 || (iy << 1) > 0xFFE0000000000000) return x + y;
      if ((ix << 1) == 0x7FE0000000000000) return NaN; // original: 1.0
      if (((ix << 1) < 0x7FE0000000000000) == !(iy >> 63)) return 0; // |x|<1 && y==inf or |x|>1 && y==-inf.
      return y * y;
    }
    if (zeroinfnan(ix)) {
      let x2 = x * x;
      if (i32(ix >> 63) && checkint(iy) == 1) x2 = -x2;
      return iy >> 63 ? 1 / x2 : x2;
    }
    // Here x and y are non-zero finite
    if (ix >> 63) {
      // Finite x < 0
      let yint = checkint(iy);
      if (yint == 0) return (x - x) / (x - x);
      if (yint == 1) sign_bias = SIGN_BIAS;
      ix   &= 0x7FFFFFFFFFFFFFFF;
      topx &= 0x7FF;
    }
    if ((topy & 0x7FF) - 0x3BE >= 0x43E - 0x3BE) {
      // Note: sign_bias == 0 here because y is not odd.
      if (ix == 0x3FF0000000000000) return 1;
      if ((topy & 0x7FF) < 0x3BE)   return 1; // |y| < 2^-65, x^y ~= 1 + y*log(x).
      return (ix > 0x3FF0000000000000) == (topy < 0x800) ? Infinity : 0;
    }
    if (topx == 0) {
      // Normalize subnormal x so exponent becomes negative.
      ix = reinterpret<u64>(x * Ox1p52);
      ix &= 0x7FFFFFFFFFFFFFFF;
      ix -= u64(52) << 52;
    }
  }

  var hi = log_inline(ix);
  var lo = log_tail;
  var ehi: f64, elo: f64;
  // #if __FP_FAST_FMA
  //   ehi = y * hi;
  //   elo = y * lo + __builtin_fma(y, hi, -ehi);
  // #else
  var yhi = reinterpret<f64>(iy & 0xFFFFFFFFF8000000);
  var ylo = y - yhi;
  var lhi = reinterpret<f64>(reinterpret<u64>(hi) & 0xFFFFFFFFF8000000);
  var llo = hi - lhi + lo;
  ehi = yhi * lhi;
  elo = ylo * lhi + y * llo; // |elo| < |ehi| * 2^-25.
  // #endif
  return exp_inline(ehi, elo, sign_bias);
}

'''
'''--- std/assembly/util/memory.ts ---
export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c
  var w: u32, x: u32;

  // copy 1 byte each until src is aligned to 4 bytes
  while (n && (src & 3)) {
    store<u8>(dest++, load<u8>(src++));
    n--;
  }

  // if dst is aligned to 4 bytes as well, copy 4 bytes each
  if ((dest & 3) == 0) {
    while (n >= 16) {
      store<u32>(dest     , load<u32>(src     ));
      store<u32>(dest +  4, load<u32>(src +  4));
      store<u32>(dest +  8, load<u32>(src +  8));
      store<u32>(dest + 12, load<u32>(src + 12));
      src += 16; dest += 16; n -= 16;
    }
    if (n & 8) {
      store<u32>(dest    , load<u32>(src    ));
      store<u32>(dest + 4, load<u32>(src + 4));
      dest += 8; src += 8;
    }
    if (n & 4) {
      store<u32>(dest, load<u32>(src));
      dest += 4; src += 4;
    }
    if (n & 2) { // drop to 2 bytes each
      store<u16>(dest, load<u16>(src));
      dest += 2; src += 2;
    }
    if (n & 1) { // drop to 1 byte
      store<u8>(dest++, load<u8>(src++));
    }
    return;
  }

  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each
  // doing shifts if faster when copying enough bytes (here: 32 or more)
  if (n >= 32) {
    switch (<u32>dest & 3) {
      // known to be != 0
      case 1: {
        w = load<u32>(src);
        store<u8>(dest++, load<u8>(src++));
        store<u8>(dest++, load<u8>(src++));
        store<u8>(dest++, load<u8>(src++));
        n -= 3;
        while (n >= 17) {
          x = load<u32>(src + 1);
          store<u32>(dest, w >> 24 | x << 8);
          w = load<u32>(src + 5);
          store<u32>(dest + 4, x >> 24 | w << 8);
          x = load<u32>(src + 9);
          store<u32>(dest + 8, w >> 24 | x << 8);
          w = load<u32>(src + 13);
          store<u32>(dest + 12, x >> 24 | w << 8);
          src += 16; dest += 16; n -= 16;
        }
        break;
      }
      case 2: {
        w = load<u32>(src);
        store<u8>(dest++, load<u8>(src++));
        store<u8>(dest++, load<u8>(src++));
        n -= 2;
        while (n >= 18) {
          x = load<u32>(src + 2);
          store<u32>(dest, w >> 16 | x << 16);
          w = load<u32>(src + 6);
          store<u32>(dest + 4, x >> 16 | w << 16);
          x = load<u32>(src + 10);
          store<u32>(dest + 8, w >> 16 | x << 16);
          w = load<u32>(src + 14);
          store<u32>(dest + 12, x >> 16 | w << 16);
          src += 16; dest += 16; n -= 16;
        }
        break;
      }
      case 3: {
        w = load<u32>(src);
        store<u8>(dest++, load<u8>(src++));
        n -= 1;
        while (n >= 19) {
          x = load<u32>(src + 3);
          store<u32>(dest, w >> 8 | x << 24);
          w = load<u32>(src + 7);
          store<u32>(dest + 4, x >> 8 | w << 24);
          x = load<u32>(src + 11);
          store<u32>(dest + 8, w >> 8 | x << 24);
          w = load<u32>(src + 15);
          store<u32>(dest + 12, x >> 8 | w << 24);
          src += 16; dest += 16; n -= 16;
        }
        break;
      }
    }
  }

  // copy remaining bytes one by one
  if (n & 16) {
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
  }
  if (n & 8) {
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
  }
  if (n & 4) {
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
  }
  if (n & 2) {
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
  }
  if (n & 1) {
    store<u8>(dest++, load<u8>(src++));
  }
}

// @ts-ignore: decorator
@inline
export function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c
  if (dest === src) return;
  if (ASC_SHRINK_LEVEL < 1) {
    if (src - dest - n <= -(n << 1)) {
      memcpy(dest, src, n);
      return;
    }
  }
  if (dest < src) {
    if (ASC_SHRINK_LEVEL < 2) {
      if ((src & 7) == (dest & 7)) {
        while (dest & 7) {
          if (!n) return;
          --n;
          store<u8>(dest++, load<u8>(src++));
        }
        while (n >= 8) {
          store<u64>(dest, load<u64>(src));
          n    -= 8;
          dest += 8;
          src  += 8;
        }
      }
    }
    while (n) {
      store<u8>(dest++, load<u8>(src++));
      --n;
    }
  } else {
    if (ASC_SHRINK_LEVEL < 2) {
      if ((src & 7) == (dest & 7)) {
        while ((dest + n) & 7) {
          if (!n) return;
          store<u8>(dest + --n, load<u8>(src + n));
        }
        while (n >= 8) {
          n -= 8;
          store<u64>(dest + n, load<u64>(src + n));
        }
      }
    }
    while (n) {
      store<u8>(dest + --n, load<u8>(src + n));
    }
  }
}

// @ts-ignore: decorator
@inline
export function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset
  if (ASC_SHRINK_LEVEL > 1) {
    while (n) {
      store<u8>(dest++, c);
      --n;
    }
  } else {
    // fill head and tail with minimal branching
    if (!n) return;
    let dend = dest + n;
    store<u8>(dest, c);
    store<u8>(dend - 1, c);
    if (n <= 2) return;
    store<u8>(dest, c, 1);
    store<u8>(dest, c, 2);
    store<u8>(dend - 2, c);
    store<u8>(dend - 3, c);
    if (n <= 6) return;
    store<u8>(dest, c, 3);
    store<u8>(dend - 4, c);
    if (n <= 8) return;

    // advance pointer to align it at 4-byte boundary
    let k: usize = -dest & 3;
    dest += k;
    n -= k;
    n &= -4;

    let c32: u32 = <u32>-1 / 255 * c;

    // fill head/tail up to 28 bytes each in preparation
    dend = dest + n;
    store<u32>(dest, c32);
    store<u32>(dend - 4, c32);
    if (n <= 8) return;
    store<u32>(dest, c32, 4);
    store<u32>(dest, c32, 8);
    store<u32>(dend - 12, c32);
    store<u32>(dend - 8, c32);
    if (n <= 24) return;
    store<u32>(dest, c32, 12);
    store<u32>(dest, c32, 16);
    store<u32>(dest, c32, 20);
    store<u32>(dest, c32, 24);
    store<u32>(dend - 28, c32);
    store<u32>(dend - 24, c32);
    store<u32>(dend - 20, c32);
    store<u32>(dend - 16, c32);

    // align to a multiple of 8
    k = 24 + (dest & 4);
    dest += k;
    n -= k;

    // copy 32 bytes each
    let c64: u64 = <u64>c32 | (<u64>c32 << 32);
    while (n >= 32) {
      store<u64>(dest, c64);
      store<u64>(dest, c64, 8);
      store<u64>(dest, c64, 16);
      store<u64>(dest, c64, 24);
      n -= 32;
      dest += 32;
    }
  }
}

// @ts-ignore: decorator
@inline
export function memcmp(vl: usize, vr: usize, n: usize): i32 {
  if (vl == vr) return 0;
  if (ASC_SHRINK_LEVEL < 2) {
    if ((vl & 7) == (vr & 7)) {
      while (vl & 7) {
        if (!n) return 0;
        let a = <i32>load<u8>(vl);
        let b = <i32>load<u8>(vr);
        if (a != b) return a - b;
        n--; vl++; vr++;
      }
      while (n >= 8) {
        if (load<u64>(vl) != load<u64>(vr)) break;
        vl += 8;
        vr += 8;
        n  -= 8;
      }
    }
  }
  while (n--) {
    let a = <i32>load<u8>(vl);
    let b = <i32>load<u8>(vr);
    if (a != b) return a - b;
    vl++; vr++;
  }
  return 0;
}

'''
'''--- std/assembly/util/number.ts ---
/// <reference path="../rt/index.d.ts" />

import { idof } from "../builtins";
import { CharCode } from "./string";

// @ts-ignore: decorator
@inline
export const MAX_DOUBLE_LENGTH = 28;

// @ts-ignore: decorator
@lazy @inline const POWERS10 = memory.data<u32>([
  1,
  10,
  100,
  1000,
  10000,
  100000,
  1000000,
  10000000,
  100000000,
  1000000000
]);

/*
  Lookup table for pairwise char codes in range [0-99]

  "00", "01", "02", "03", "04", "05", "06", "07", "08", "09",
  "10", "11", "12", "13", "14", "15", "16", "17", "18", "19",
  "20", "21", "22", "23", "24", "25", "26", "27", "28", "29",
  "30", "31", "32", "33", "34", "35", "36", "37", "38", "39",
  "40", "41", "42", "43", "44", "45", "46", "47", "48", "49",
  "50", "51", "52", "53", "54", "55", "56", "57", "58", "59",
  "60", "61", "62", "63", "64", "65", "66", "67", "68", "69",
  "70", "71", "72", "73", "74", "75", "76", "77", "78", "79",
  "80", "81", "82", "83", "84", "85", "86", "87", "88", "89",
  "90", "91", "92", "93", "94", "95", "96", "97", "98", "99"
*/
// @ts-ignore: decorator
@lazy @inline const DIGITS = memory.data<u32>([
  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,
  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,
  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,
  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,
  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,
  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,
  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,
  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,
  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,
  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,
  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,
  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,
  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,
  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,
  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,
  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,
  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,
  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,
  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,
  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039
]);

// Lookup table for pairwise char codes in range [0x00-0xFF]
// @ts-ignore: decorator
@lazy @inline const HEX_DIGITS =
"000102030405060708090a0b0c0d0e0f\
101112131415161718191a1b1c1d1e1f\
202122232425262728292a2b2c2d2e2f\
303132333435363738393a3b3c3d3e3f\
404142434445464748494a4b4c4d4e4f\
505152535455565758595a5b5c5d5e5f\
606162636465666768696a6b6c6d6e6f\
707172737475767778797a7b7c7d7e7f\
808182838485868788898a8b8c8d8e8f\
909192939495969798999a9b9c9d9e9f\
a0a1a2a3a4a5a6a7a8a9aaabacadaeaf\
b0b1b2b3b4b5b6b7b8b9babbbcbdbebf\
c0c1c2c3c4c5c6c7c8c9cacbcccdcecf\
d0d1d2d3d4d5d6d7d8d9dadbdcdddedf\
e0e1e2e3e4e5e6e7e8e9eaebecedeeef\
f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff";

// @ts-ignore: decorator
@lazy @inline const ANY_DIGITS = "0123456789abcdefghijklmnopqrstuvwxyz";

// @ts-ignore: decorator
@lazy @inline const EXP_POWERS = memory.data<i16>([/* eslint-disable indent */
  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,
   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,
   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,
   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,
   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,
    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,
    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,
    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,
    907,   933,   960,   986,  1013,  1039,  1066
/* eslint-enable indent */]);

// 1e-348, 1e-340, ..., 1e340
// @ts-ignore: decorator
@lazy @inline const FRC_POWERS = memory.data<u64>([
  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,
  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,
  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,
  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,
  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,
  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,
  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,
  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,
  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,
  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,
  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,
  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,
  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,
  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,
  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,
  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,
  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,
  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,
  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,
  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,
  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,
  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B
]);

// @ts-ignore: decorator
@inline
export function isPowerOf2<T extends number>(value: T): bool {
  return popcnt<T>(value) == 1;
}

// Count number of decimals for u32 values
// In our case input value always non-zero so we can simplify some parts
export function decimalCount32(value: u32): u32 {
  if (value < 100000) {
    if (value < 100) {
      return 1 + u32(value >= 10);
    } else {
      return 3 + u32(value >= 10000) + u32(value >= 1000);
    }
  } else {
    if (value < 10000000) {
      return 6 + u32(value >= 1000000);
    } else {
      return 8 + u32(value >= 1000000000) + u32(value >= 100000000);
    }
  }
}

// Count number of decimals for u64 values
// In our case input value always greater than 2^32-1 so we can skip some parts
export function decimalCount64High(value: u64): u32 {
  if (value < 1000000000000000) {
    if (value < 1000000000000) {
      return 10 + u32(value >= 100000000000) + u32(value >= 10000000000);
    } else {
      return 13 + u32(value >= 100000000000000) + u32(value >= 10000000000000);
    }
  } else {
    if (value < 100000000000000000) {
      return 16 + u32(value >= 10000000000000000);
    } else {
      return 18 + u32(value >= 10000000000000000000) + u32(value >= 1000000000000000000);
    }
  }
}

function ulog_base(num: u64, base: i32): u32 {
  if (isPowerOf2(base)) {
    return (63 - <u32>clz(num)) / (31 - <u32>clz(base)) + 1;
  }
  var b64 = u64(base), b = b64, e: u32 = 1;
  while (num >= b) {
    num /= b;
    b *= b;
    e <<= 1;
  }
  while (num >= 1) {
    num /= b64;
    e++;
  }
  return e - 1;
}

function utoa32_dec_lut(buffer: usize, num: u32, offset: usize): void {
  while (num >= 10000) {
    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate
    let t = num / 10000;
    let r = num % 10000;
    num = t;

    let d1 = r / 100;
    let d2 = r % 100;

    let digits1 = <u64>load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));
    let digits2 = <u64>load<u32>(DIGITS + (<usize>d2 << alignof<u32>()));

    offset -= 4;
    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));
  }

  if (num >= 100) {
    let t  = num / 100;
    let d1 = num % 100;
    num = t;
    offset -= 2;
    let digits = load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));
    store<u32>(buffer + (offset << 1), digits);
  }

  if (num >= 10) {
    offset -= 2;
    let digits = load<u32>(DIGITS + (<usize>num << alignof<u32>()));
    store<u32>(buffer + (offset << 1), digits);
  } else {
    offset -= 1;
    let digit = CharCode._0 + num;
    store<u16>(buffer + (offset << 1), digit);
  }
}

function utoa64_dec_lut(buffer: usize, num: u64, offset: usize): void {
  while (num >= 100000000) {
    let t = num / 100000000;
    let r = <usize>(num - t * 100000000);
    num = t;

    let b = r / 10000;
    let c = r % 10000;

    let b1 = b / 100;
    let b2 = b % 100;
    let c1 = c / 100;
    let c2 = c % 100;

    let digits1 = <u64>load<u32>(DIGITS + (<usize>c1 << alignof<u32>()));
    let digits2 = <u64>load<u32>(DIGITS + (<usize>c2 << alignof<u32>()));

    offset -= 4;
    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));

    digits1 = <u64>load<u32>(DIGITS + (<usize>b1 << alignof<u32>()));
    digits2 = <u64>load<u32>(DIGITS + (<usize>b2 << alignof<u32>()));

    offset -= 4;
    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));
  }

  utoa32_dec_lut(buffer, <u32>num, offset);
}

function utoa_hex_lut(buffer: usize, num: u64, offset: usize): void {
  const lut = changetype<usize>(HEX_DIGITS);
  while (offset >= 2) {
    offset -= 2;
    store<u32>(
      buffer + (offset << 1),
      load<u32>(lut + ((<usize>num & 0xFF) << alignof<u32>()))
    );
    num >>= 8;
  }
  if (offset & 1) {
    store<u16>(buffer, load<u16>(lut + (<usize>num << 6)));
  }
}

function utoa_dec_simple<T extends number>(buffer: usize, num: T, offset: usize): void {
  do {
    let t = num / 10;
    let r = <u32>(num % 10);
    num = changetype<T>(t);
    offset--;
    store<u16>(buffer + (offset << 1), CharCode._0 + r);
  } while (num);
}

function utoa_hex_simple<T extends number>(buffer: usize, num: T, offset: usize): void {
  do {
    let d = num & 0x0F | CharCode._0;
    d += select<T>(<T>0x27, <T>0, d > <T>CharCode._9);
    offset--;
    store<u16>(buffer + (offset << 1), d);
    // @ts-ignore: type
    num >>= 4;
  } while (num);
}

// @ts-ignore: decorator
@inline
export function utoa32_dec_core(buffer: usize, num: u32, offset: usize): void {
  if (ASC_SHRINK_LEVEL >= 1) {
    utoa_dec_simple<u32>(buffer, num, offset);
  } else {
    utoa32_dec_lut(buffer, num, offset);
  }
}

// @ts-ignore: decorator
@inline
function utoa32_hex_core(buffer: usize, num: u32, offset: usize): void {
  if (ASC_SHRINK_LEVEL >= 1) {
    utoa_hex_simple<u32>(buffer, num, offset);
  } else {
    utoa_hex_lut(buffer, num, offset);
  }
}

// @ts-ignore: decorator
@inline
function utoa64_dec_core(buffer: usize, num: u64, offset: usize): void {
  if (ASC_SHRINK_LEVEL >= 1) {
    utoa_dec_simple<u64>(buffer, num, offset);
  } else {
    utoa64_dec_lut(buffer, num, offset);
  }
}

// @ts-ignore: decorator
@inline
function utoa64_hex_core(buffer: usize, num: u64, offset: usize): void {
  if (ASC_SHRINK_LEVEL >= 1) {
    utoa_hex_simple<u64>(buffer, num, offset);
  } else {
    utoa_hex_lut(buffer, num, offset);
  }
}

function utoa64_any_core(buffer: usize, num: u64, offset: usize, radix: i32): void {
  const lut = changetype<usize>(ANY_DIGITS);
  var base = u64(radix);
  if ((radix & (radix - 1)) == 0) { // for radix which pow of two
    let shift = u64(ctz(radix) & 7);
    let mask = base - 1;
    do {
      offset--;
      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num & mask) << 1)));
      num >>= shift;
    } while (num);
  } else {
    do {
      offset--;
      let q = num / base;
      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num - q * base) << 1)));
      num = q;
    } while (num);
  }
}

export function utoa32(value: u32, radix: i32): String {
  if (radix < 2 || radix > 36) {
    throw new RangeError("toString() radix argument must be between 2 and 36");
  }
  if (!value) return "0";
  var out: String;

  if (radix == 10) {
    let decimals = decimalCount32(value);
    out = changetype<String>(__new(decimals << 1, idof<String>()));
    utoa32_dec_core(changetype<usize>(out), value, decimals);
  } else if (radix == 16) {
    let decimals = (31 - clz(value) >> 2) + 1;
    out = changetype<String>(__new(decimals << 1, idof<String>()));
    utoa32_hex_core(changetype<usize>(out), value, decimals);
  } else {
    let decimals = ulog_base(value, radix);
    out = changetype<String>(__new(decimals << 1, idof<String>()));
    utoa64_any_core(changetype<usize>(out), value, decimals, radix);
  }
  return out;
}

export function itoa32(value: i32, radix: i32): String {
  if (radix < 2 || radix > 36) {
    throw new RangeError("toString() radix argument must be between 2 and 36");
  }
  if (!value) return "0";

  var sign = value >>> 31;
  if (sign) value = -value;
  var out: String;

  if (radix == 10) {
    let decimals = decimalCount32(value) + sign;
    out = changetype<String>(__new(decimals << 1, idof<String>()));
    utoa32_dec_core(changetype<usize>(out), value, decimals);
  } else if (radix == 16) {
    let decimals = (31 - clz(value) >> 2) + 1 + sign;
    out = changetype<String>(__new(decimals << 1, idof<String>()));
    utoa32_hex_core(changetype<usize>(out), value, decimals);
  } else {
    let val32 = u32(value);
    let decimals = ulog_base(val32, radix) + sign;
    out = changetype<String>(__new(decimals << 1, idof<String>()));
    utoa64_any_core(changetype<usize>(out), val32, decimals, radix);
  }
  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);
  return out;
}

export function utoa64(value: u64, radix: i32): String {
  if (radix < 2 || radix > 36) {
    throw new RangeError("toString() radix argument must be between 2 and 36");
  }
  if (!value) return "0";
  var out: String;

  if (radix == 10) {
    if (value <= u32.MAX_VALUE) {
      let val32    = <u32>value;
      let decimals = decimalCount32(val32);
      out = changetype<String>(__new(decimals << 1, idof<String>()));
      utoa32_dec_core(changetype<usize>(out), val32, decimals);
    } else {
      let decimals = decimalCount64High(value);
      out = changetype<String>(__new(decimals << 1, idof<String>()));
      utoa64_dec_core(changetype<usize>(out), value, decimals);
    }
  } else if (radix == 16) {
    let decimals = (63 - u32(clz(value)) >> 2) + 1;
    out = changetype<String>(__new(decimals << 1, idof<String>()));
    utoa64_hex_core(changetype<usize>(out), value, decimals);
  } else {
    let decimals = ulog_base(value, radix);
    out = changetype<String>(__new(decimals << 1, idof<String>()));
    utoa64_any_core(changetype<usize>(out), value, decimals, radix);
  }
  return out;
}

export function itoa64(value: i64, radix: i32): String {
  if (radix < 2 || radix > 36) {
    throw new RangeError("toString() radix argument must be between 2 and 36");
  }
  if (!value) return "0";

  var sign = u32(value >>> 63);
  if (sign) value = -value;
  var out: String;

  if (radix == 10) {
    if (<u64>value <= <u64>u32.MAX_VALUE) {
      let val32    = <u32>value;
      let decimals = decimalCount32(val32) + sign;
      out = changetype<String>(__new(decimals << 1, idof<String>()));
      utoa32_dec_core(changetype<usize>(out), val32, decimals);
    } else {
      let decimals = decimalCount64High(value) + sign;
      out = changetype<String>(__new(decimals << 1, idof<String>()));
      utoa64_dec_core(changetype<usize>(out), value, decimals);
    }
  } else if (radix == 16) {
    let decimals = (63 - u32(clz(value)) >> 2) + 1 + sign;
    out = changetype<String>(__new(decimals << 1, idof<String>()));
    utoa64_hex_core(changetype<usize>(out), value, decimals);
  } else {
    let decimals = ulog_base(value, radix) + sign;
    out = changetype<String>(__new(decimals << 1, idof<String>()));
    utoa64_any_core(changetype<usize>(out), value, decimals, radix);
  }
  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);
  return out;
}

// @ts-ignore: decorator
@lazy var _K: i32 = 0;

// // @ts-ignore: decorator
// @lazy
// var _frc: u64 = 0;

// @ts-ignore: decorator
@lazy var _exp: i32 = 0;

// @ts-ignore: decorator
@lazy var _frc_minus: u64 = 0;

// @ts-ignore: decorator
@lazy var _frc_plus:  u64 = 0;

// @ts-ignore: decorator
@lazy var _frc_pow: u64 = 0;

// @ts-ignore: decorator
@lazy var _exp_pow: i32 = 0;

// @ts-ignore: decorator
@inline
function umul64f(u: u64, v: u64): u64 {
  var u0 = u & 0xFFFFFFFF;
  var v0 = v & 0xFFFFFFFF;

  var u1 = u >> 32;
  var v1 = v >> 32;

  var l = u0 * v0;
  var t = u1 * v0 + (l >> 32);
  var w = u0 * v1 + (t & 0xFFFFFFFF);

  w += 0x7FFFFFFF; // rounding

  t >>= 32;
  w >>= 32;

  return u1 * v1 + t + w;
}

// @ts-ignore: decorator
@inline
function umul64e(e1: i32, e2: i32): i32 {
  return e1 + e2 + 64; // where 64 is significand size
}

// @ts-ignore: decorator
@inline
function normalizedBoundaries(f: u64, e: i32): void {
  var frc = (f << 1) + 1;
  var exp = e - 1;
  var off = <i32>clz<u64>(frc);
  frc <<= off;
  exp  -= off;

  var m = 1 + i32(f == 0x0010000000000000);

  _frc_plus  = frc;
  _frc_minus = ((f << m) - 1) << e - m - exp;
  _exp = exp;
}

// @ts-ignore: decorator
@inline
function grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {
  var lastp = buffer + ((len - 1) << 1);
  var digit = load<u16>(lastp);
  while (
    rest < wp_w &&
    delta - rest >= ten_kappa && (
      rest + ten_kappa < wp_w ||
      wp_w - rest > rest + ten_kappa - wp_w
    )
  ) {
    --digit;
    rest += ten_kappa;
  }
  store<u16>(lastp, digit);
}

// @ts-ignore: decorator
@inline
function getCachedPower(minExp: i32): void {
  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114
  var dk = (-61 - minExp) * c + 347;	            // dk must be positive, so can do ceiling in positive
  var k = <i32>dk;
  k += i32(k != dk); // conversion with ceil

  var index = (k >> 3) + 1;
  _K = 348 - (index << 3);	// decimal exponent no need lookup table
  _frc_pow = load<u64>(FRC_POWERS + (<usize>index << alignof<u64>()));
  _exp_pow = load<i16>(EXP_POWERS + (<usize>index << alignof<i16>()));
}

// @ts-ignore: decorator
@inline
function grisu2(value: f64, buffer: usize, sign: i32): i32 {

  // frexp routine
  var uv  = reinterpret<u64>(value);
  var exp = i32((uv & 0x7FF0000000000000) >>> 52);
  var sid = uv & 0x000FFFFFFFFFFFFF;
  var frc = (u64(exp != 0) << 52) + sid;
  exp = select<i32>(exp, 1, exp) - (0x3FF + 52);

  normalizedBoundaries(frc, exp);
  getCachedPower(_exp);

  // normalize
  var off = <i32>clz<u64>(frc);
  frc <<= off;
  exp  -= off;

  var frc_pow = _frc_pow;
  var exp_pow = _exp_pow;

  var w_frc = umul64f(frc, frc_pow);
  var w_exp = umul64e(exp, exp_pow);

  var wp_frc = umul64f(_frc_plus, frc_pow) - 1;
  var wp_exp = umul64e(_exp, exp_pow);

  var wm_frc = umul64f(_frc_minus, frc_pow) + 1;
  var delta  = wp_frc - wm_frc;

  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);
}

function genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {
  var one_exp = -mp_exp;
  var one_frc = (<u64>1) << one_exp;
  var mask    = one_frc - 1;

  var wp_w_frc = mp_frc - w_frc;

  var p1 = u32(mp_frc >> one_exp);
  var p2 = mp_frc & mask;

  var kappa = <i32>decimalCount32(p1);
  var len = sign;

  while (kappa > 0) {
    let d: u32;
    switch (kappa) {
      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }
      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }
      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }
      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }
      case  6: { d = p1 /     100000; p1 %=     100000; break; }
      case  5: { d = p1 /      10000; p1 %=      10000; break; }
      case  4: { d = p1 /       1000; p1 %=       1000; break; }
      case  3: { d = p1 /        100; p1 %=        100; break; }
      case  2: { d = p1 /         10; p1 %=         10; break; }
      case  1: { d = p1;              p1 =           0; break; }
      default: { d = 0; break; }
    }

    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);

    --kappa;
    let tmp = ((<u64>p1) << one_exp) + p2;
    if (tmp <= delta) {
      _K += kappa;
      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(POWERS10 + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);
      return len;
    }
  }

  while (true) {
    p2    *= 10;
    delta *= 10;

    let d = p2 >> one_exp;
    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);

    p2 &= mask;
    --kappa;
    if (p2 < delta) {
      _K += kappa;
      wp_w_frc *= <u64>load<u32>(POWERS10 + (<usize>-kappa << alignof<u32>()));
      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);
      return len;
    }
  }
}

// @ts-ignore: decorator
@inline
function genExponent(buffer: usize, k: i32): i32 {
  var sign = k < 0;
  if (sign) k = -k;
  var decimals = decimalCount32(k) + 1;
  utoa32_dec_core(buffer, k, decimals);
  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));
  return decimals;
}

function prettify(buffer: usize, length: i32, k: i32): i32 {
  if (!k) {
    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));
    return length + 2;
  }

  var kk = length + k;
  if (length <= kk && kk <= 21) {
    // 1234e7 -> 12340000000
    for (let i = length; i < kk; ++i) {
      store<u16>(buffer + (i << 1), CharCode._0);
    }
    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));
    return kk + 2;
  } else if (kk > 0 && kk <= 21) {
    // 1234e-2 -> 12.34
    let ptr = buffer + (kk << 1);
    memory.copy(
      ptr + 2,
      ptr,
      -k << 1
    );
    store<u16>(buffer + (kk << 1), CharCode.DOT);
    return length + 1;
  } else if (-6 < kk && kk <= 0) {
    // 1234e-6 -> 0.001234
    let offset = 2 - kk;
    memory.copy(
      buffer + (offset << 1),
      buffer,
      length << 1
    );
    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));
    for (let i = 2; i < offset; ++i) {
      store<u16>(buffer + (i << 1), CharCode._0);
    }
    return length + offset;
  } else if (length == 1) {
    // 1e30
    store<u16>(buffer, CharCode.e, 2);
    length = genExponent(buffer + 4, kk - 1);
    return length + 2;
  } else {
    let len = length << 1;
    memory.copy(
      buffer + 4,
      buffer + 2,
      len - 2
    );
    store<u16>(buffer,       CharCode.DOT, 2);
    store<u16>(buffer + len, CharCode.e,   2);
    length += genExponent(buffer + len + 4, kk - 1);
    return length + 2;
  }
}

function dtoa_core(buffer: usize, value: f64): i32 {
  var sign = i32(value < 0);
  if (sign) {
    value = -value;
    store<u16>(buffer, CharCode.MINUS);
  }
  // assert(value > 0 && value <= 1.7976931348623157e308);
  var len = grisu2(value, buffer, sign);
  len = prettify(buffer + (sign << 1), len - sign, _K);
  return len + sign;
}

// @ts-ignore: decorator
@lazy @inline const dtoa_buf = memory.data(MAX_DOUBLE_LENGTH << 1);

export function dtoa(value: f64): String {
  if (value == 0) return "0.0";
  if (!isFinite(value)) {
    if (isNaN(value)) return "NaN";
    return select<String>("-Infinity", "Infinity", value < 0);
  }
  var size = dtoa_core(dtoa_buf, value) << 1;
  var result = changetype<String>(__new(size, idof<String>()));
  memory.copy(changetype<usize>(result), dtoa_buf, size);
  return result;
}

export function itoa_buffered<T extends number>(buffer: usize, value: T): u32 {
  var sign: u32 = 0;
  if (isSigned<T>()) {
    sign = u32(value < 0);
    if (sign) {
      value = changetype<T>(-value);
      store<u16>(buffer, CharCode.MINUS);
    }
  }
  if (ASC_SHRINK_LEVEL <= 1) {
    if (isSigned<T>()) {
      if (sizeof<T>() <= 4) {
        if (<u32>value < 10) {
          store<u16>(buffer + (sign << 1), value | CharCode._0);
          return 1 + sign;
        }
      } else {
        if (<u64>value < 10) {
          store<u16>(buffer + (sign << 1), value | CharCode._0);
          return 1 + sign;
        }
      }
    } else {
      if (value < 10) {
        store<u16>(buffer, value | CharCode._0);
        return 1;
      }
    }
  }
  var decimals = sign;
  if (sizeof<T>() <= 4) {
    decimals += decimalCount32(value);
    utoa32_dec_core(buffer, value, decimals);
  } else {
    if (<u64>value <= <u64>u32.MAX_VALUE) {
      let val32 = <u32>value;
      decimals += decimalCount32(val32);
      utoa32_dec_core(buffer, val32, decimals);
    } else {
      decimals += decimalCount64High(value);
      utoa64_dec_core(buffer, value, decimals);
    }
  }
  return decimals;
}

export function dtoa_buffered(buffer: usize, value: f64): u32 {
  if (value == 0) {
    store<u16>(buffer, CharCode._0);
    store<u16>(buffer, CharCode.DOT, 2);
    store<u16>(buffer, CharCode._0,  4);
    return 3;
  }
  if (!isFinite(value)) {
    if (isNaN(value)) {
      store<u16>(buffer, CharCode.N);
      store<u16>(buffer, CharCode.a, 2);
      store<u16>(buffer, CharCode.N, 4);
      return 3;
    } else {
      let sign = value < 0;
      if (sign) {
        store<u16>(buffer, CharCode.MINUS); // -
        buffer += 2;
      }
      store<u64>(buffer, 0x690066006E0049, 0); // ifnI
      store<u64>(buffer, 0x7900740069006E, 8); // ytin
      return 8 + u32(sign);
    }
  }
  return dtoa_core(buffer, value);
}

'''
'''--- std/assembly/util/sort.ts ---
import { compareImpl } from "./string";

type Comparator<T> = (a: T, b: T) => i32;

// @ts-ignore: decorator
@lazy @inline const EMPTY = u32.MAX_VALUE;
// @ts-ignore: decorator
@inline const INSERTION_SORT_THRESHOLD = 48;
// @ts-ignore: decorator
@inline const MIN_RUN_LENGTH = 32;

// @ts-ignore: decorator
@inline
function log2u(n: u32): u32 {
  return 31 - clz(n);
}

// @ts-ignore: decorator
@inline
export function COMPARATOR<T>(): Comparator<T> {
  if (isInteger<T>()) {
    if (isSigned<T>() && sizeof<T>() <= 4) {
      return (a, b) => i32(a) - i32(b);
    } else {
      return (a, b) => i32(a > b) - i32(a < b);
    }
  } else if (isFloat<T>()) {
    if (sizeof<T>() == 4) {
      return (a, b) => {
        var ia = reinterpret<i32>(f32(a));
        var ib = reinterpret<i32>(f32(b));
        ia ^= ia >> 31 >>> 1;
        ib ^= ib >> 31 >>> 1;
        return i32(ia > ib) - i32(ia < ib);
      };
    } else {
      return (a, b) => {
        var ia = reinterpret<i64>(f64(a));
        var ib = reinterpret<i64>(f64(b));
        ia ^= ia >> 63 >>> 1;
        ib ^= ib >> 63 >>> 1;
        return i32(ia > ib) - i32(ia < ib);
      };
    }
  } else if (isString<T>()) {
    return (a, b) => {
      if (a === b || a === null || b === null) return 0;
      var alen = changetype<string>(a).length;
      var blen = changetype<string>(b).length;
      if (!(alen | blen)) return 0;
      if (!alen) return -1;
      if (!blen) return  1;
      let res = compareImpl(
        changetype<string>(a), 0,
        changetype<string>(b), 0,
        <usize>min(alen, blen)
      );
      return res ? res : alen - blen;
    };
  } else {
    return (a, b) => i32(a > b) - i32(a < b);
  }
}

// Power Sort implementation (stable) from paper "Nearly-Optimal Mergesorts"
// https://arxiv.org/pdf/1805.04154.pdf
// This method usually outperform TimSort.
// TODO: refactor c >>> 31 to c < 0 when binaryen will support this opt
export function SORT<T>(
  ptr: usize,
  len: i32,
  comparator: Comparator<T>
): void {
  if (len <= INSERTION_SORT_THRESHOLD) {
    if (len <= 1) return;
    if (ASC_SHRINK_LEVEL < 1) {
      switch (len) {
        case 3: {
          let a = load<T>(ptr, 0);
          let b = load<T>(ptr, 1 << alignof<T>());
          let c = comparator(a, b) > 0;
          store<T>(ptr, select<T>(b, a, c), 0);
          a = select<T>(a, b, c);
          b = load<T>(ptr, 2 << alignof<T>());
          c = comparator(a, b) > 0;
          store<T>(ptr, select<T>(b, a, c), 1 << alignof<T>());
          store<T>(ptr, select<T>(a, b, c), 2 << alignof<T>());
        }
        case 2: {
          let a = load<T>(ptr, 0);
          let b = load<T>(ptr, 1 << alignof<T>());
          let c = comparator(a, b) > 0;
          store<T>(ptr, select<T>(b, a, c), 0);
          store<T>(ptr, select<T>(a, b, c), 1 << alignof<T>());
          return;
        }
      }
    }
    insertionSort<T>(ptr, 0, len - 1, 0, comparator);
    return;
  }

  var lgPlus2         = log2u(len) + 2;
  var lgPlus2Size     = lgPlus2 << alignof<u32>();
  var leftRunStartBuf = __alloc(lgPlus2Size << 1);
  var leftRunEndBuf   = leftRunStartBuf + lgPlus2Size;

  for (let i: u32 = 0; i < lgPlus2; ++i) {
    store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);
  }

  var buffer = __alloc(len << alignof<T>());

  var hi   = len - 1;
  var endA = extendRunRight<T>(ptr, 0, hi, comparator);
  var lenA = endA + 1;

  if (lenA < MIN_RUN_LENGTH) {
    endA = min(hi, MIN_RUN_LENGTH - 1);
    insertionSort<T>(ptr, 0, endA, lenA, comparator);
  }

  var top: u32 = 0, startA = 0;
  while (endA < hi) {
    let startB = endA + 1;
    let endB = extendRunRight<T>(ptr, startB, hi, comparator);
    let lenB = endB - startB + 1;

    if (lenB < MIN_RUN_LENGTH) {
      endB = min(hi, startB + MIN_RUN_LENGTH - 1);
      insertionSort<T>(ptr, startB, endB, lenB, comparator);
    }

    let k = nodePower(0, hi, startA, startB, endB);

    for (let i = top; i > k; --i) {
      let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));
      if (start != EMPTY) {
        mergeRuns<T>(
          ptr,
          start,
          load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,
          endA,
          buffer,
          comparator
        );
        startA = start;
        store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);
      }
    }

    store<u32>(leftRunStartBuf + (<usize>k << alignof<u32>()), startA);
    store<u32>(leftRunEndBuf   + (<usize>k << alignof<u32>()), endA);
    startA = startB;
    endA = endB;
    top = k;
  }

  for (let i = top; i != 0; --i) {
    let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));
    if (start != EMPTY) {
      mergeRuns<T>(
        ptr,
        start,
        load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,
        hi,
        buffer,
        comparator
      );
    }
  }
  // dealloc aux buffers
  __free(buffer);
  __free(leftRunStartBuf);
}

function insertionSort<T>(
  ptr: usize,
  left: i32,
  right: i32,
  presorted: i32,
  comparator: Comparator<T>
): void {
  if (ASC_SHRINK_LEVEL >= 1) {
    // slightly improved original insertion sort
    for (let i = left + presorted; i <= right; ++i) {
      let j = i - 1;
      let a = load<T>(ptr + (<usize>i << alignof<T>()));
      while (j >= left) {
        let b = load<T>(ptr + (<usize>j << alignof<T>()));
        if (comparator(a, b) < 0) {
          store<T>(ptr + (<usize>j << alignof<T>()), b, 1 << alignof<T>()); --j;
        } else break;
      }
      store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>());
    }
  } else {
    // even-odd two-way insertion sort which allow increase minRunLen
    let range = right - left + 1;
    let i = left + select(range & 1, presorted - ((range - presorted) & 1), presorted == 0);
    for (; i <= right; i += 2) {
      let a = load<T>(ptr + (<usize>i << alignof<T>()), 0);
      let b = load<T>(ptr + (<usize>i << alignof<T>()), 1 << alignof<T>());
      let min = b, max = a;
      if (comparator(a, b) <= 0) {
        min = a, max = b;
      }
      let j = i - 1;
      while (j >= left) {
        a = load<T>(ptr + (<usize>j << alignof<T>()));
        if (comparator(a, max) > 0) {
          store<T>(ptr + (<usize>j << alignof<T>()), a, 2 << alignof<T>()); --j;
        } else break;
      }
      store<T>(ptr + (<usize>j << alignof<T>()), max, 2 << alignof<T>());
      while (j >= left) {
        a = load<T>(ptr + (<usize>j << alignof<T>()));
        if (comparator(a, min) > 0) {
          store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>()); --j;
        } else break;
      }
      store<T>(ptr + (<usize>j << alignof<T>()), min, 1 << alignof<T>());
    }
  }
}

function nodePower(left: u32, right: u32, startA: u32, startB: u32, endB: u32): u32 {
  var n: u64 = right - left + 1;
  var s = startB - (left << 1);
  var l = startA + s;
  var r = endB   + s + 1;
  var a = (<u64>l << 30) / n;
  var b = (<u64>r << 30) / n;
  return clz(<u32>(a ^ b));
}

function extendRunRight<T>(
  ptr: usize,
  i: i32,
  right: i32,
  comparator: Comparator<T>
): i32 {
  if (i == right) return i;
  var j = i;
  if (comparator(
    load<T>(ptr + (<usize>  j << alignof<T>())),
    load<T>(ptr + (<usize>++j << alignof<T>()))
  ) > 0) {
    while (
      j < right &&
      (comparator(
        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),
        load<T>(ptr + (<usize>j << alignof<T>()))
      ) >>> 31) // < 0
    ) ++j;
    // reverse
    let k = j;
    while (i < k) {
      let tmp = load<T>(ptr + (<usize>i << alignof<T>()));
      store<T>(ptr + (<usize>i << alignof<T>()), load<T>(ptr + (<usize>k << alignof<T>()))); ++i;
      store<T>(ptr + (<usize>k << alignof<T>()), tmp); --k;
    }
  } else {
    while (
      j < right &&
      comparator(
        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),
        load<T>(ptr + (<usize>j << alignof<T>()))
      ) >= 0
    ) ++j;
  }
  return j;
}

// Merges arr[l..m - 1] and arr[m..r]
function mergeRuns<T>(
  ptr: usize,
  l: i32,
  m: i32,
  r: i32,
  buffer: usize,
  comparator: Comparator<T>
): void {
  --m;
  var i: i32, j: i32, t = r + m;
  for (i = m + 1; i > l; --i) {
    store<T>(
      buffer + (<usize>(i - 1) << alignof<T>()),
      load<T>(ptr + (<usize>(i - 1) << alignof<T>()))
    );
  }
  for (j = m; j < r; ++j) {
    store<T>(
      buffer + (<usize>(t - j) << alignof<T>()),
      load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>())
    );
  }
  for (let k = l; k <= r; ++k) {
    let a = load<T>(buffer + (<usize>j << alignof<T>()));
    let b = load<T>(buffer + (<usize>i << alignof<T>()));
    if (comparator(a, b) < 0) {
      store<T>(ptr + (<usize>k << alignof<T>()), a);
      --j;
    } else {
      store<T>(ptr + (<usize>k << alignof<T>()), b);
      ++i;
    }
  }
}

'''
'''--- std/assembly/util/string.ts ---
import { itoa32, utoa32, itoa64, utoa64, dtoa, itoa_buffered, dtoa_buffered, MAX_DOUBLE_LENGTH } from "./number";
import { ipow32 } from "../math";

// All tables are stored as two staged lookup tables (static tries)
// because the full range of Unicode symbols can't be efficiently
// represented as-is in memory (see Unicode spec ch 5, p.196):
// https://www.unicode.org/versions/Unicode12.0.0/ch05.pdf
// Tables have been generated using these forked musl tools:
// https://github.com/MaxGraey/musl-chartable-tools/tree/case-ignorable

// Lookup table to check if a character is alphanumeric or not
// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/alpha.h
// size: 3904 bytes
// @ts-ignore
@inline @lazy const ALPHA_TABLE = memory.data<u8>([
  18,17,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,17,34,35,36,17,37,38,39,40,
  41,42,43,44,17,45,46,47,16,16,48,16,16,16,16,16,16,16,49,50,51,16,52,53,16,16,
  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,54,
  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
  17,17,17,55,17,17,17,17,56,17,57,58,59,60,61,62,17,17,17,17,17,17,17,17,17,17,
  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
  17,17,17,17,17,17,17,63,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,64,65,17,66,67,
  68,69,70,71,72,73,74,17,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,
  93,94,16,95,96,97,98,17,17,17,99,100,101,16,16,16,16,16,16,16,16,16,16,17,17,
  17,17,102,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,103,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,17,17,104,105,16,16,106,107,17,17,17,17,17,17,17,17,17,17,17,17,17,
  17,17,17,17,17,17,17,17,17,17,108,17,17,17,17,109,110,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  17,111,112,16,16,16,16,16,16,16,16,16,113,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,114,115,116,117,16,16,16,16,16,16,16,16,118,
  119,120,16,16,16,16,16,121,122,16,16,16,16,123,16,16,124,16,16,16,16,16,16,16,
  16,16,125,16,16,16,
  16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,254,255,255,7,254,
  255,255,7,0,0,0,0,0,4,32,4,255,255,127,255,255,255,127,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,195,255,3,0,31,80,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,223,188,64,215,255,255,
  251,255,255,255,255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,3,252,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,254,255,255,255,127,2,255,255,255,
  255,255,1,0,0,0,0,255,191,182,0,255,255,255,135,7,0,0,0,255,7,255,255,255,255,
  255,255,255,254,255,195,255,255,255,255,255,255,255,255,255,255,255,255,239,
  31,254,225,255,
  159,0,0,255,255,255,255,255,255,0,224,255,255,255,255,255,255,255,255,255,255,
  255,255,3,0,255,255,255,255,255,7,48,4,255,255,255,252,255,31,0,0,255,255,255,
  1,255,7,0,0,0,0,0,0,255,255,223,255,255,0,240,255,248,3,255,255,255,255,255,
  255,255,255,255,239,255,223,225,255,207,255,254,255,239,159,249,255,255,253,
  197,227,159,89,128,176,207,255,3,16,238,135,249,255,255,253,109,195,135,25,2,
  94,192,255,63,0,238,191,251,255,255,253,237,227,191,27,1,0,207,255,0,30,238,
  159,249,255,255,253,237,227,159,25,192,176,207,255,2,0,236,199,61,214,24,199,
  255,195,199,29,129,0,192,255,0,0,239,223,253,255,255,253,255,227,223,29,96,7,
  207,255,0,0,239,223,253,255,255,253,239,227,223,29,96,64,207,255,6,0,255,223,
  253,255,255,255,255,231,223,93,240,128,207,255,0,252,238,255,127,252,255,255,
  251,47,127,128,95,255,192,255,12,0,254,255,255,255,255,127,255,7,63,32,255,3,
  0,0,0,0,214,247,255,255,175,255,255,59,95,32,255,243,0,0,0,
  0,1,0,0,0,255,3,0,0,255,254,255,255,255,31,254,255,3,255,255,254,255,255,255,
  31,0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,249,255,3,255,255,255,255,255,
  255,255,255,255,63,255,255,255,255,191,32,255,255,255,255,255,247,255,255,255,
  255,255,255,255,255,255,61,127,61,255,255,255,255,255,61,255,255,255,255,61,
  127,61,255,127,255,255,255,255,255,255,255,61,255,255,255,255,255,255,255,255,
  7,0,0,0,0,255,255,0,0,255,255,255,255,255,255,255,255,255,255,63,63,254,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,159,255,255,254,255,255,7,255,255,255,255,255,255,255,255,
  255,199,255,1,255,223,15,0,255,255,15,0,255,255,15,0,255,223,13,0,255,255,255,
  255,255,255,207,255,255,1,128,16,255,3,0,0,0,0,255,3,255,255,255,255,255,255,
  255,255,255,255,255,1,255,255,255,255,255,7,255,255,255,255,255,255,255,255,
  63,
  0,255,255,255,127,255,15,255,1,192,255,255,255,255,63,31,0,255,255,255,255,
  255,15,255,255,255,3,255,3,0,0,0,0,255,255,255,15,255,255,255,255,255,255,255,
  127,254,255,31,0,255,3,255,3,128,0,0,128,1,0,0,0,0,0,0,0,255,255,255,255,255,
  255,239,255,239,15,255,3,0,0,0,0,255,255,255,255,255,243,255,255,255,255,255,
  255,191,255,3,0,255,255,255,255,255,255,127,0,255,227,255,255,255,255,255,63,
  255,1,255,255,255,255,255,231,0,0,0,0,0,222,111,4,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,
  128,255,31,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,255,
  255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,132,252,47,62,80,189,255,243,
  224,67,0,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,
  0,255,255,255,255,255,127,255,255,255,255,255,127,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,31,120,12,0,255,255,255,255,191,32,255,
  255,255,255,255,255,255,128,0,0,255,255,127,0,127,127,127,127,127,127,127,127,
  255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,224,0,0,0,254,3,62,31,254,255,255,255,255,255,255,255,255,255,127,224,254,
  255,255,255,255,255,255,255,255,255,255,247,224,255,255,255,255,255,254,255,
  255,255,255,255,255,255,255,255,255,127,0,0,255,255,255,255,0,0,0,0,0,0,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,
  31,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,
  0,0,0,0,0,0,255,255,255,255,255,63,255,31,255,255,255,15,0,0,255,255,255,255,
  255,127,240,143,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,
  0,128,255,252,255,255,255,255,255,255,255,255,255,255,255,255,249,255,255,255,
  255,255,255,252,7,0,0,0,0,224,255,191,255,255,255,255,0,0,0,255,255,255,255,
  255,255,15,0,255,255,255,255,255,255,255,255,47,0,255,3,0,0,252,232,255,255,
  255,255,255,7,255,255,255,255,7,0,255,255,255,31,255,255,255,255,255,255,247,
  255,0,128,255,3,255,255,255,127,255,255,255,255,255,255,127,0,255,63,255,3,
  255,255,127,252,255,255,255,255,255,255,255,127,5,0,0,56,255,255,60,0,126,126,
  126,0,127,127,255,255,255,255,255,247,255,3,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,7,255,3,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,15,0,255,255,127,248,255,255,255,255,
  255,
  15,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,255,255,
  255,255,255,255,255,255,255,255,3,0,0,0,0,127,0,248,224,255,253,127,95,219,
  255,255,255,255,255,255,255,255,255,255,255,255,255,3,0,0,0,248,255,255,255,
  255,255,255,255,255,255,255,255,255,63,0,0,255,255,255,255,255,255,255,255,
  252,255,255,255,255,255,255,0,0,0,0,0,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,223,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,255,3,
  254,255,255,7,254,255,255,7,192,255,255,255,255,255,255,255,255,255,255,127,
  252,252,252,28,0,0,0,0,255,239,255,255,127,255,255,183,255,63,255,63,0,0,0,0,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,
  255,255,255,255,255,255,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,255,255,255,31,255,255,255,255,255,255,1,0,0,0,0,
  0,255,255,255,255,0,224,255,255,255,7,255,255,255,255,255,7,255,255,255,63,
  255,255,255,255,15,255,62,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,63,255,3,255,255,255,255,15,255,255,255,
  255,15,255,255,255,255,255,0,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,0,255,255,63,0,255,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,63,253,255,255,255,255,191,145,255,255,63,0,255,255,
  127,0,255,255,255,127,0,0,0,0,0,0,0,0,255,255,55,0,255,255,63,0,255,255,255,3,
  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,192,0,0,0,0,0,0,0,0,111,240,239,
  254,255,255,63,0,0,0,0,0,255,255,255,31,255,255,255,31,0,0,0,0,255,254,255,
  255,31,0,0,0,255,255,255,255,255,255,63,0,255,255,63,0,255,255,7,0,255,255,3,
  0,0,0,0,0,0,0,0,0,0,0,0,
  0,255,255,255,255,255,255,255,255,255,1,0,0,0,0,0,0,255,255,255,255,255,255,7,
  0,255,255,255,255,255,255,7,0,255,255,255,255,255,0,255,3,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,
  255,27,3,0,0,0,0,0,0,0,0,0,255,255,255,31,128,0,255,255,63,0,0,0,0,0,0,0,0,0,
  0,0,0,0,255,255,31,0,0,0,255,255,127,0,255,255,255,255,255,255,255,255,63,0,0,
  0,192,255,0,0,252,255,255,255,255,255,255,1,0,0,255,255,255,1,255,3,255,255,
  255,255,255,255,199,255,240,0,255,255,255,255,71,0,255,255,255,255,255,255,
  255,255,30,192,255,23,0,0,0,0,255,255,251,255,255,255,159,64,0,0,0,0,0,0,0,0,
  127,189,255,191,255,1,255,255,255,255,255,255,255,1,255,3,239,159,249,255,255,
  253,237,227,159,25,129,224,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,255,255,255,255,255,255,255,255,187,7,255,131,3,0,0,0,255,255,255,255,255,
  255,255,255,179,0,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,
  255,255,255,63,127,0,0,0,63,0,0,0,0,255,255,255,255,255,255,255,127,17,0,255,
  3,0,0,0,0,255,255,255,255,255,255,63,1,255,3,0,0,0,0,0,0,255,255,255,231,255,
  7,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,
  255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,3,0,128,
  127,242,111,255,255,255,191,153,7,0,255,3,0,0,0,0,0,0,0,0,255,252,255,255,255,
  255,255,252,26,0,0,0,255,255,255,255,255,255,231,127,0,0,255,255,255,255,255,
  255,255,255,255,32,0,0,0,0,255,255,255,255,255,255,255,1,255,253,255,255,255,
  255,127,127,1,0,255,3,0,0,252,255,255,255,252,255,255,254,127,0,0,0,0,0,0,0,0,
  0,127,251,255,255,255,255,127,180,203,0,255,3,191,253,255,255,255,127,123,1,
  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
  0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,3,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,
  255,127,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,255,255,255,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,
  0,255,255,255,255,255,255,255,1,255,255,255,127,255,3,0,0,0,0,0,0,0,0,0,0,0,0,
  255,255,255,63,0,0,255,255,255,255,255,255,0,0,15,0,255,3,248,255,255,224,255,
  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,
  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,135,
  255,255,255,255,255,255,255,128,255,255,0,0,0,0,0,0,0,0,11,0,3,0,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,0,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,0,0,0,0,0,
  255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,
  127,0,0,0,0,0,0,7,0,240,0,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,15,255,255,255,255,255,
  255,255,255,255,255,255,255,255,7,255,31,255,1,255,67,0,0,0,0,0,0,0,0,0,0,0,0,
  255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,255,255,255,
  223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,
  255,123,95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,63,255,255,255,253,255,255,247,255,255,255,
  247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,255,253,
  255,255,255,253,255,255,247,207,255,255,255,255,255,255,127,255,255,249,219,7,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,31,
  128,63,255,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,15,255,
  3,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,31,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,143,8,
  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,239,255,255,255,150,254,247,10,
  132,234,150,170,150,247,247,94,255,251,255,15,238,251,255,15,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,3
]);

// size: 1568 bytes (compressed to ~1380 bytes after binaryen)
// @ts-ignore: decorator
@lazy @inline const CASED = memory.data<u8>([
  18,19,20,21,22,23,16,16,16,16,16,16,16,16,16,16,
  24,16,16,25,16,16,16,16,16,16,16,16,26,27,17,28,
  29,30,16,16,31,16,16,16,16,16,16,16,32,33,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,34,35,16,16,16,36,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,37,16,16,16,38,
  16,16,16,16,39,16,16,16,16,16,16,16,40,16,16,16,
  16,16,16,16,16,16,16,16,41,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,42,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,43,44,45,46,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,47,16,16,16,16,16,16,
  16,48,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  0,0,0,0,0,0,0,0,254,255,255,7,254,255,255,7,0,0,0,0,0,4,32,4,
  255,255,127,255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,247,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,239,255,255,255,255,1,3,0,0,0,31,0,0,0,
  0,0,0,0,0,0,0,0,32,0,0,0,0,0,207,188,64,215,255,255,251,255,255,255,
  255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  3,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,255,
  255,255,127,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,
  191,32,255,255,255,255,255,231,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,255,255,255,255,255,255,255,255,255,255,63,63,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,255,1,255,255,255,255,255,231,0,0,0,0,0,0,0,0,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  0,0,0,0,0,0,0,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,
  255,255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,
  132,252,47,62,80,189,31,242,224,67,0,0,255,255,255,255,24,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,0,255,255,255,255,255,127,255,255,
  255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,120,12,0,
  255,255,255,255,191,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,63,0,0,
  255,255,255,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,255,255,
  255,255,255,255,255,255,255,255,255,120,255,255,255,255,255,255,252,7,0,0,0,0,96,7,
  0,0,0,0,0,0,255,255,255,255,255,247,255,1,255,255,255,255,255,255,255,255,255,255,
  0,0,0,0,0,0,0,0,127,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,255,255,7,
  254,255,255,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,255,
  255,255,15,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  255,255,255,255,255,255,7,0,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,
  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,
  255,255,255,223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,255,123,
  95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,
  253,255,255,247,255,255,255,247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,
  255,253,255,255,255,253,255,255,247,15,0,0,0,0,0,0,255,255,255,255,255,255,255,255,
  15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0
]);

// size: 2976 bytes (compressed to ~2050 bytes after binaryen)
// @ts-ignore: decorator
@lazy @inline const CASE_IGNORABLES = memory.data<u8>([
  18,16,19,20,21,22,23,24,25,26,27,28,29,30,31,32,
  33,16,16,34,16,16,16,35,36,37,38,39,40,41,16,42,
  43,16,16,16,16,16,16,16,16,16,16,16,44,45,46,16,
  47,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  48,16,16,16,49,16,50,51,52,53,54,55,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,56,16,16,57,58,
  16,59,60,61,16,16,16,16,16,16,62,16,16,63,64,65,
  66,67,68,69,70,71,72,73,74,75,76,16,77,78,79,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,80,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,81,82,16,16,16,83,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,84,16,16,16,
  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
  16,85,86,16,16,16,16,16,16,16,87,16,16,16,16,16,
  88,89,90,16,16,16,16,16,91,92,16,16,16,16,16,16,
  16,16,16,93,16,16,16,16,16,16,16,16,16,16,16,16,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  0,0,0,0,128,64,0,4,0,0,0,64,1,0,0,0,0,0,0,0,0,161,144,1,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
  255,255,255,255,255,255,48,4,176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,3,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0,0,0,
  0,0,254,255,255,255,255,191,182,0,0,0,0,0,16,0,63,0,255,23,0,0,0,0,
  1,248,255,255,0,0,1,0,0,0,0,0,0,0,0,0,0,0,192,191,255,61,0,0,
  0,128,2,0,0,0,255,255,255,7,0,0,0,0,0,0,0,0,0,0,192,255,1,0,
  0,0,0,0,0,248,63,36,0,0,192,255,255,63,0,0,0,0,0,14,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,248,255,255,255,255,255,7,0,0,0,0,0,0,20,
  254,33,254,0,12,0,2,0,2,0,0,0,0,0,0,16,30,32,0,0,12,0,0,64,
  6,0,0,0,0,0,0,16,134,57,2,0,0,0,35,0,6,0,0,0,0,0,0,16,
  190,33,0,0,12,0,0,252,2,0,0,0,0,0,0,144,30,32,96,0,12,0,0,0,
  4,0,0,0,0,0,0,0,1,32,0,0,0,0,0,0,17,0,0,0,0,0,0,192,
  193,61,96,0,12,0,0,0,2,0,0,0,0,0,0,144,64,48,0,0,12,0,0,0,
  3,0,0,0,0,0,0,24,30,32,0,0,12,0,0,0,2,0,0,0,0,0,0,0,
  0,4,92,0,0,0,0,0,0,0,0,0,0,0,242,7,192,127,0,0,0,0,0,0,
  0,0,0,0,0,0,242,31,64,63,0,0,0,0,0,0,0,0,0,3,0,0,160,2,
  0,0,0,0,0,0,254,127,223,224,255,254,255,255,255,31,64,0,0,0,0,0,0,0,
  0,0,0,0,0,224,253,102,0,0,0,195,1,0,30,0,100,32,0,32,0,0,0,0,
  0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,224,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,28,0,
  0,0,12,0,0,0,12,0,0,0,0,0,0,0,176,63,64,254,143,32,0,0,0,0,
  0,120,0,0,0,0,0,0,8,0,0,0,0,0,0,0,96,0,0,0,0,2,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,135,1,4,14,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,9,0,0,0,0,
  0,0,64,127,229,31,248,159,0,0,0,0,128,0,255,255,1,0,0,0,0,0,0,0,
  15,0,0,0,0,0,208,23,4,0,0,0,0,248,15,0,3,0,0,0,60,59,0,0,
  0,0,0,0,64,163,3,0,0,0,0,0,0,240,207,0,0,0,0,0,0,0,0,63,
  0,0,0,0,0,0,0,0,0,0,247,255,253,33,16,3,0,0,0,0,0,240,255,255,
  255,255,255,255,255,7,0,1,0,0,0,248,255,255,255,255,255,255,255,255,255,255,255,251,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,
  3,224,0,224,0,224,0,96,0,248,0,3,144,124,0,0,0,0,0,0,223,255,2,128,
  0,0,255,31,0,0,0,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,
  0,0,0,0,255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,60,62,8,
  0,0,0,0,0,0,0,0,0,0,0,126,0,0,0,0,0,0,0,0,0,0,0,112,
  0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,0,16,0,0,0,0,0,0,
  0,0,0,0,0,128,247,191,0,0,0,240,0,0,0,0,0,0,0,0,0,0,3,0,
  255,255,255,255,3,0,0,0,0,0,0,0,0,0,1,0,0,7,0,0,0,0,0,0,
  0,0,0,0,0,0,0,3,68,8,0,0,96,16,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,48,0,0,0,255,255,3,128,0,0,0,0,192,63,0,0,
  128,255,3,0,0,0,0,0,7,0,0,0,0,0,200,51,0,128,0,0,96,0,0,0,
  0,0,0,0,0,126,102,0,8,16,0,0,0,0,1,16,0,0,0,0,0,0,157,193,
  2,0,0,32,0,48,88,0,0,0,0,0,0,0,0,0,0,0,0,248,0,14,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,32,33,0,0,0,0,0,64,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,3,0,0,0,0,0,0,0,
  255,255,8,0,255,255,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,128,128,64,0,4,0,0,0,64,1,0,0,0,0,0,1,0,
  0,0,0,192,0,0,0,0,0,0,0,0,8,0,0,14,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,7,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,240,0,0,0,0,0,135,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,
  0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  192,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  2,0,0,0,0,0,0,255,127,0,0,0,0,0,0,128,3,0,0,0,0,0,120,38,
  0,32,0,0,0,0,0,0,7,0,0,0,128,239,31,0,0,0,0,0,0,0,8,0,
  3,0,0,0,0,0,192,127,0,158,0,0,0,0,0,0,0,0,0,0,0,128,211,64,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,248,7,0,0,
  3,0,0,0,0,0,0,24,1,0,0,0,192,31,31,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,92,0,0,64,0,0,0,0,
  0,0,0,0,0,0,248,133,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,176,1,0,0,48,0,0,0,0,
  0,0,0,0,0,0,248,167,1,0,0,0,0,0,0,0,0,0,0,0,0,40,191,0,
  0,0,0,0,0,0,0,0,0,0,0,224,188,15,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,255,6,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,88,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,240,12,1,0,0,0,254,7,0,0,0,0,248,121,128,0,126,14,0,0,0,0,
  0,252,127,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,191,
  0,0,0,0,0,0,0,0,0,0,252,255,255,252,109,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,126,180,191,0,0,0,0,0,0,0,0,0,163,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,255,1,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,31,0,0,0,0,0,0,0,127,0,15,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,128,0,0,0,0,0,0,0,128,255,255,0,0,0,0,0,0,0,0,27,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,15,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,248,255,
  231,15,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  255,255,255,255,255,255,127,248,255,255,255,255,255,31,32,0,16,0,0,248,254,255,0,0,
  0,0,0,0,0,0,0,0,127,255,255,249,219,7,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,63,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,
  240,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,248
]);

// @ts-ignore: decorator
@lazy @inline const LOWER127 = memory.data<u8>([
  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,
  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,
  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
  64,
  97,98,99,100,101,102,103,104,105,106,107,108,109,
  110,111,112,113,114,115,116,117,118,119,120,121,122,
  91,92,93,94,95,96,
  97,98,99,100,101,102,103,104,105,106,107,108,109,
  110,111,112,113,114,115,116,117,118,119,120,121,122,
  123,124,125,126,127
]);

// @ts-ignore: decorator
@lazy @inline const UPPER127 = memory.data<u8>([
  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,
  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,
  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
  64,
  65,66,67,68,69,70,71,72,73,74,75,76,77,
  78,79,80,81,82,83,84,85,86,87,88,89,90,
  91,92,93,94,95,96,
  65,66,67,68,69,70,71,72,73,74,75,76,77,
  78,79,80,81,82,83,84,85,86,87,88,89,90,
  123,124,125,126,127
]);

// 23 * 8 = 184 bytes
// @ts-ignore: decorator
@lazy @inline const POWERS10 = memory.data<f64>([
  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,
  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,
  1e20, 1e21, 1e22
]);

// @ts-ignore: decorator
@inline
export const enum CharCode {
  PERCENT = 0x25,
  PLUS = 0x2B,
  MINUS = 0x2D,
  DOT = 0x2E,
  _0 = 0x30,
  _1 = 0x31,
  _2 = 0x32,
  _3 = 0x33,
  _4 = 0x34,
  _5 = 0x35,
  _6 = 0x36,
  _7 = 0x37,
  _8 = 0x38,
  _9 = 0x39,
  A = 0x41,
  B = 0x42,
  E = 0x45,
  I = 0x49,
  N = 0x4E,
  O = 0x4F,
  X = 0x58,
  Z = 0x5A,
  a = 0x61,
  b = 0x62,
  e = 0x65,
  n = 0x6E,
  o = 0x6F,
  u = 0x75,
  x = 0x78,
  z = 0x7A
}

// @ts-ignore: decorator
@inline
export function isAscii(c: u32): bool {
  return !(c >> 7);
}

// @ts-ignore: decorator
@inline
export function isLower8(c: u32): bool {
  return c - CharCode.a < 26;
}

// @ts-ignore: decorator
@inline
export function isUpper8(c: u32): bool {
  return c - CharCode.A < 26;
}

export function isSpace(c: u32): bool {
  if (c < 0x1680) { // < <LS> (1)
    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>
    // (c == 0x20 || c == 0xA0) was optimized to (c | 0x80) == 0xA0
    // @ts-ignore: cast
    return ((c | 0x80) == 0xA0) | (c - 0x09 <= 0x0D - 0x09);
  }
  if (c - 0x2000 <= 0x200A - 0x2000) return true;
  switch (c) {
    case 0x1680: // <LS> (1)
    case 0x2028: // <LS> (2)
    case 0x2029: // <PS>
    case 0x202F: // <NNS>
    case 0x205F: // <MMSP>
    case 0x3000: // <IS>
    case 0xFEFF: return true; // <ZWNBSP>
  }
  return false;
}

export function isAlpha(c: u32): bool {
  if (isAscii(c)) return (c | 32) - CharCode.a < 26;
  if (c < 0x20000) {
    // @ts-ignore: cast
    return stagedBinaryLookup(ALPHA_TABLE, c);
  }
  return c < 0x2FFFE;
}

// @ts-ignore: decorator
@inline
export function isCased(c: u32): bool {
  // @ts-ignore: cast
  return c < 0x1F18A && stagedBinaryLookup(CASED, c);
}

// @ts-ignore: decorator
@inline
export function isCaseIgnorable(c: u32): bool {
  // @ts-ignore: cast
  return c < 0xE01F0 && stagedBinaryLookup(CASE_IGNORABLES, c);
}

// @ts-ignore: decorator
@inline
export function isFinalSigma(buffer: usize, index: isize, len: isize): bool {
  const lookaheadLimit = 30; // max lookahead limit
  var found = false;
  var pos = index;
  var minPos = max(0, pos - lookaheadLimit);
  while (pos > minPos) {
    let c = codePointBefore(buffer, pos);
    if (!isCaseIgnorable(c)) {
      if (isCased(c)) {
        found = true;
      } else {
        return false;
      }
    }
    pos -= isize(c >= 0x10000) + 1;
  }
  if (!found) return false;
  pos = index + 1;
  var maxPos = min(pos + lookaheadLimit, len);
  while (pos < maxPos) {
    let c = <u32>load<u16>(buffer + (pos << 1));
    if (u32((c & 0xFC00) == 0xD800) & u32(pos + 1 != len)) {
      let c1 = <u32>load<u16>(buffer + (pos << 1), 2);
      if ((c1 & 0xFC00) == 0xDC00) {
        c = (c - 0xD800 << 10) + (c1 - 0xDC00) + 0x10000;
      }
    }
    if (!isCaseIgnorable(c)) {
      return !isCased(c);
    }
    pos += isize(c >= 0x10000) + 1;
  }
  return true;
}

// @ts-ignore: decorator
@inline
function codePointBefore(buffer: usize, index: isize): i32 {
  if (index <= 0) return -1;
  var c = <u32>load<u16>(buffer + (index - 1 << 1));
  if (u32((c & 0xFC00) == 0xDC00) & u32(index - 2 >= 0)) {
    let c1 = <u32>load<u16>(buffer + (index - 2 << 1));
    if ((c1 & 0xFC00) == 0xD800) {
      return ((c1 & 0x3FF) << 10) + (c & 0x3FF) + 0x10000;
    }
  }
  return (c & 0xF800) == 0xD800 ? 0xFFFD : c;
}

// Search routine for two-staged lookup tables
function stagedBinaryLookup(table: usize, c: u32): bool {
  return <bool>((load<u8>(table + (<u32>load<u8>(table + (c >>> 8)) << 5) + ((c & 255) >> 3)) >>> (c & 7)) & 1);
}

export function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {
  var ptr1 = changetype<usize>(str1) + (index1 << 1);
  var ptr2 = changetype<usize>(str2) + (index2 << 1);
  if (ASC_SHRINK_LEVEL < 2) {
    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {
      do {
        if (load<u64>(ptr1) != load<u64>(ptr2)) break;
        ptr1 += 8;
        ptr2 += 8;
        len  -= 4;
      } while (len >= 4);
    }
  }
  while (len--) {
    let a = <i32>load<u16>(ptr1);
    let b = <i32>load<u16>(ptr2);
    if (a != b) return a - b;
    ptr1 += 2;
    ptr2 += 2;
  }
  return 0;
}

// @ts-ignore: decorator
@inline
export function toLower8(c: u32): u32 {
  if (ASC_SHRINK_LEVEL > 0) {
    return c | u32(isUpper8(c)) << 5;
  } else {
    return <u32>load<u8>(LOWER127 + c);
  }
}

// @ts-ignore: decorator
@inline
export function toUpper8(c: u32): u32 {
  if (ASC_SHRINK_LEVEL > 0) {
    return c & ~(u32(isLower8(c)) << 5);
  } else {
    return <u32>load<u8>(UPPER127 + c);
  }
}

/** Parses a string to an integer (usually), using the specified radix. */
export function strtol<T>(str: string, radix: i32 = 0): T {
  var len = str.length;
  if (!len) {
    if (isFloat<T>()) {
      // @ts-ignore: cast
      return <T>NaN;
    } else {
      // @ts-ignore: cast
      return <T>0;
    }
  }

  var ptr = changetype<usize>(str) /* + HEAD -> offset */;
  var code = <u32>load<u16>(ptr);

  // trim white spaces
  while (isSpace(code)) {
    code = <u32>load<u16>(ptr += 2);
    --len;
  }
  // determine sign
  // @ts-ignore
  var sign: T = 1;
  if (code == CharCode.MINUS || code == CharCode.PLUS) {
    if (!--len) {
      if (isFloat<T>()) {
        // @ts-ignore: cast
        return <T>NaN;
      } else {
        // @ts-ignore: cast
        return <T>0;
      }
    }
    if (code == CharCode.MINUS) {
      // @ts-ignore: type
      sign = -1;
    }
    code = <u32>load<u16>(ptr += 2);
  }

  // See https://tc39.es/ecma262/#sec-parseint-string-radix
  if (radix) {
    if (radix < 2 || radix > 36) {
      if (isFloat<T>()) {
        // @ts-ignore: cast
        return <T>NaN;
      } else {
        // @ts-ignore: cast
        return <T>0;
      }
    }
    // handle case as parseInt("0xFF", 16) by spec
    if (radix == 16) {
      if (
        len > 2 &&
        code == CharCode._0 &&
        (<u32>load<u16>(ptr, 2) | 32) == CharCode.x
      ) {
        ptr += 4; len -= 2;
      }
    }
  } else {
    // determine radix by literal prefix
    if (code == CharCode._0 && len > 2) {
      switch (<u32>load<u16>(ptr, 2) | 32) {
        case CharCode.b: {
          ptr += 4; len -= 2;
          radix = 2;
          break;
        }
        case CharCode.o: {
          ptr += 4; len -= 2;
          radix = 8;
          break;
        }
        case CharCode.x: {
          ptr += 4; len -= 2;
          radix = 16;
          break;
        }
      }
    }
    if (!radix) radix = 10;
  }

  // calculate value
  // @ts-ignore: type
  var num: T = 0;
  while (len--) {
    code = <u32>load<u16>(ptr);
    if (code - CharCode._0 < 10) {
      code -= CharCode._0;
    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {
      code -= CharCode.A - 10;
    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {
      code -= CharCode.a - 10;
    }
    if (code >= <u32>radix) {
      if (!num) {
        if (isFloat<T>()) {
          // @ts-ignore: cast
          return <T>NaN;
        } else {
          // @ts-ignore: cast
          return <T>0;
        }
      }
      break;
    }
    // @ts-ignore: type
    num = num * radix + code;
    ptr += 2;
  }
  // @ts-ignore: type
  return sign * num;
}

export function strtod(str: string): f64 {
  var len = str.length;
  if (!len) return NaN;

  var ptr  = changetype<usize>(str);
  var code = <u32>load<u16>(ptr);

  var sign = 1.0;
  // skip white spaces
  while (len && isSpace(code)) {
    code = <u32>load<u16>(ptr += 2);
    --len;
  }
  if (!len) return NaN;

  // try parse '-' or '+'
  if (code == CharCode.MINUS) {
    if (!--len) return NaN;
    code = <u32>load<u16>(ptr += 2);
    sign = -1;
  } else if (code == CharCode.PLUS) {
    if (!--len) return NaN;
    code = <u32>load<u16>(ptr += 2);
  }

  // try parse Infinity
  if (len >= 8 && code == CharCode.I) {
    if (
      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI
      load<u64>(ptr, 8) == 0x7900740069006E    // ytin
    ) {
      return Infinity * sign;
    }
    return NaN;
  }
  // validate next symbol
  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {
    return NaN;
  }
  var savedPtr = ptr;
  // skip zeros
  while (code == CharCode._0) {
    code = <u32>load<u16>(ptr += 2);
    --len;
  }
  if (len <= 0) return 0;
  const capacity = 19; // int(64 * 0.3010)
  var pointed = false;
  var consumed = 0;
  var position = 0;
  var x: u64 = 0;
  if (code == CharCode.DOT) {
    let noDigits = !(savedPtr - ptr);
    ptr += 2; --len;
    if (!len && noDigits) return NaN;
    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;
    if (len <= 0) return 0;
    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;
  }
  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {
    if (digit < 10) {
      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);
      ++consumed;
    } else {
      position = consumed;
      pointed = true;
    }
    if (!--len) break;
    code = <u32>load<u16>(ptr += 2);
  }

  if (!pointed) position = consumed;
  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);
}

export function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {
  var lastIndex = length - 1;
  if (lastIndex < 0) return "";
  if (!lastIndex) return select("true", "false", load<bool>(dataStart));

  var sepLen = separator.length;
  var valueLen = 5; // max possible length of element len("false")
  var estLen = (valueLen + sepLen) * lastIndex + valueLen;
  var result = changetype<string>(__new(estLen << 1, idof<string>()));
  var offset = 0;
  var value: bool;
  for (let i = 0; i < lastIndex; ++i) {
    value = load<bool>(dataStart + i);
    valueLen = 4 + i32(!value);
    memory.copy(
      changetype<usize>(result) + (<usize>offset << 1),
      changetype<usize>(select("true", "false", value)),
      <usize>valueLen << 1
    );
    offset += valueLen;
    if (sepLen) {
      memory.copy(
        changetype<usize>(result) + (<usize>offset << 1),
        changetype<usize>(separator),
        <usize>sepLen << 1
      );
      offset += sepLen;
    }
  }
  value = load<bool>(dataStart + <usize>lastIndex);
  valueLen = 4 + i32(!value);
  memory.copy(
    changetype<usize>(result) + (<usize>offset << 1),
    changetype<usize>(select("true", "false", value)),
    valueLen << 1
  );
  offset += valueLen;

  if (estLen > offset) return result.substring(0, offset);
  return result;
}

export function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {
  var lastIndex = length - 1;
  if (lastIndex < 0) return "";
  if (!lastIndex) {
    let value = load<T>(dataStart);
    if (isSigned<T>()) {
      if (sizeof<T>() <= 4) {
        // @ts-ignore: type
        return changetype<string>(itoa32(<i32>value, 10));
      } else {
        // @ts-ignore: type
        return changetype<string>(itoa64(<i32>value, 10));
      }
    } else {
      if (sizeof<T>() <= 4) {
        // @ts-ignore: type
        return changetype<string>(utoa32(<u32>value, 10));
      } else {
        // @ts-ignore: type
        return changetype<string>(utoa64(<u64>value, 10));
      }
    }
  }

  var sepLen = separator.length;
  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());
  var estLen = (valueLen + sepLen) * lastIndex + valueLen;
  var result = changetype<string>(__new(estLen << 1, idof<string>()));
  var offset = 0;
  var value: T;
  for (let i = 0; i < lastIndex; ++i) {
    value = load<T>(dataStart + (<usize>i << alignof<T>()));
    // @ts-ignore: type
    offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);
    if (sepLen) {
      memory.copy(
        changetype<usize>(result) + (<usize>offset << 1),
        changetype<usize>(separator),
        <usize>sepLen << 1
      );
      offset += sepLen;
    }
  }
  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));
  // @ts-ignore: type
  offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);
  if (estLen > offset) return result.substring(0, offset);
  return result;
}

export function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {
  var lastIndex = length - 1;
  if (lastIndex < 0) return "";
  if (!lastIndex) {
    return changetype<string>(dtoa(
      // @ts-ignore: type
      load<T>(dataStart))
    );
  }

  const valueLen = MAX_DOUBLE_LENGTH;
  var sepLen = separator.length;
  var estLen = (valueLen + sepLen) * lastIndex + valueLen;
  var result = changetype<string>(__new(estLen << 1, idof<string>()));
  var offset = 0;
  var value: T;
  for (let i = 0; i < lastIndex; ++i) {
    value = load<T>(dataStart + (<usize>i << alignof<T>()));
    // @ts-ignore: type
    offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);
    if (sepLen) {
      memory.copy(
        changetype<usize>(result) + (<usize>offset << 1),
        changetype<usize>(separator),
        <usize>sepLen << 1
      );
      offset += sepLen;
    }
  }
  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));
  // @ts-ignore: type
  offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);
  if (estLen > offset) return result.substring(0, offset);
  return result;
}

export function joinStringArray(dataStart: usize, length: i32, separator: string): string {
  var lastIndex = length - 1;
  if (lastIndex < 0) return "";
  if (!lastIndex) {
    // @ts-ignore: type
    return load<string>(dataStart) || "";
  }
  var estLen = 0;
  var value: string;
  for (let i = 0; i < length; ++i) {
    value = load<string>(dataStart + (<usize>i << alignof<string>()));
    // @ts-ignore: type
    if (value !== null) estLen += value.length;
  }
  var offset = 0;
  var sepLen = separator.length;
  var result = changetype<string>(__new((estLen + sepLen * lastIndex) << 1, idof<string>()));
  for (let i = 0; i < lastIndex; ++i) {
    value = load<string>(dataStart + (<usize>i << alignof<string>()));
    if (value !== null) {
      let valueLen = value.length;
      memory.copy(
        changetype<usize>(result) + (<usize>offset << 1),
        changetype<usize>(value),
        <usize>valueLen << 1
      );
      offset += valueLen;
    }
    if (sepLen) {
      memory.copy(
        changetype<usize>(result) + (<usize>offset << 1),
        changetype<usize>(separator),
        <usize>sepLen << 1
      );
      offset += sepLen;
    }
  }
  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));
  if (value !== null) {
    memory.copy(
      changetype<usize>(result) + (<usize>offset << 1),
      changetype<usize>(value),
      <usize>value.length << 1
    );
  }
  return result;
}

export function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {
  var lastIndex = length - 1;
  if (lastIndex < 0) return "";
  var value: T;
  if (!lastIndex) {
    value = load<T>(dataStart);
    // @ts-ignore: type
    return value !== null ? value.toString() : "";
  }
  var result = "";
  var sepLen = separator.length;
  for (let i = 0; i < lastIndex; ++i) {
    value = load<T>(dataStart + (<usize>i << alignof<T>()));
    // @ts-ignore: type
    if (value !== null) result += value.toString();
    if (sepLen) result += separator;
  }
  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));
  // @ts-ignore: type
  if (value !== null) result += value.toString();
  return result;
}

// @ts-ignore: decorator
@inline
function scientific(significand: u64, exp: i32): f64 {
  if (!significand || exp < -342) return 0;
  if (exp > 308) return Infinity;
  // Try use fast path
  // Use fast path for string-to-double conversion if possible
  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion
  // Simple integer
  var significandf = <f64>significand;
  if (!exp) return significandf;
  if (exp > 22 && exp <= 22 + 15) {
    significandf *= pow10(exp - 22);
    exp = 22;
  }
  if (significand <= 9007199254740991 && abs(exp) <= 22) {
    if (exp > 0) return significandf * pow10(exp);
    return significandf / pow10(-exp);
  } else if (exp < 0) {
    return scaledown(significand, exp);
  } else {
    return scaleup(significand, exp);
  }
}

// Adopted from metallic lib:
// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h
// @ts-ignore: decorator
@inline
function scaledown(significand: u64, exp: i32): f64 {
  const denom: u64 = 6103515625; // 1e14 * 0x1p-14
  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32

  var shift = clz(significand);
  significand <<= shift;
  shift = exp - shift;

  for (; exp <= -14; exp += 14) {
    let q = significand / denom;
    let r = significand % denom;
    let s = clz(q);
    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));
    shift -= s;
  }
  var b = <u64>ipow32(5, -exp);
  var q = significand / b;
  var r = significand % b;
  var s = clz(q);
  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);
  shift -= s;

  return NativeMath.scalbn(<f64>significand, <i32>shift);
}

// Adopted from metallic lib:
// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h
// @ts-ignore: decorator
@inline
function scaleup(significand: u64, exp: i32): f64 {
  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;
  var shift = ctz(significand);
  significand >>= shift;
  shift += exp;

  __fixmulShift = shift;
  for (; exp >= 13; exp -= 13) {
    significand = fixmul(significand, coeff);
  }
  significand = fixmul(significand, <u32>ipow32(5, exp));
  shift = __fixmulShift;
  return NativeMath.scalbn(<f64>significand, <i32>shift);
}

// Adopted from metallic lib:
// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h
// @ts-ignore: decorator
@inline
function parseExp(ptr: usize, len: i32): i32 {
  var sign = 1, magnitude = 0;
  var code = <u32>load<u16>(ptr);
  // check code is 'e' or 'E'
  if ((code | 32) != CharCode.e) return 0;

  if (!--len) return 0;
  code = <u32>load<u16>(ptr += 2);
  if (code == CharCode.MINUS) {
    if (!--len) return 0;
    code = <u32>load<u16>(ptr += 2);
    sign = -1;
  } else if (code == CharCode.PLUS) {
    if (!--len) return 0;
    code = <u32>load<u16>(ptr += 2);
  }
  // skip zeros
  while (code == CharCode._0) {
    if (!--len) return 0;
    code = <u32>load<u16>(ptr += 2);
  }
  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {
    if (magnitude >= 3200) return sign * 3200;
    magnitude = 10 * magnitude + digit;
    code = <u32>load<u16>(ptr += 2);
    --len;
  }
  return sign * magnitude;
}

// @ts-ignore: decorator
@lazy var __fixmulShift: u64 = 0;

// Adopted from metallic lib:
// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h
// @ts-ignore: decorator
@inline
function fixmul(a: u64, b: u32): u64 {
  var low  = (a & 0xFFFFFFFF) * b;
  var high = (a >> 32) * b + (low >> 32);
  var overflow = <u32>(high >> 32);
  var space = clz(overflow);
  var revspace: u64 = 32 - space;
  __fixmulShift += revspace;
  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);
}

// @ts-ignore: decorator
@inline
function pow10(n: i32): f64 {
  // argument `n` should bounds in [0, 22] range
  return load<f64>(POWERS10 + (n << alignof<f64>()));
}

'''
'''--- std/assembly/util/uri.ts ---
import { E_URI_MALFORMED } from "./error";
import { CharCode } from "./string";

// Truncated lookup boolean table that helps us quickly determine
// if a char needs to be escaped for URIs (RFC 2396).
// @ts-ignore: decorator
@lazy export const URI_UNSAFE = memory.data<u8>([
/* skip 32 + 1 always set to '1' head slots
  */ 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, /*
  skip 128 + 1 always set to '1' tail slots */
]);

// Truncated lookup boolean table that helps us quickly determine
// if a char needs to be escaped for URLs (RFC 3986).
// @ts-ignore: decorator
@lazy export const URL_UNSAFE = memory.data<u8>([
/* skip 32 + 1 always set to '1' head slots
  */ 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, /*
  skip 128 + 1 always set to '1' tail slots */
]);

// Truncated lookup boolean table for determine reserved chars: ;/?:@&=+$,#
// @ts-ignore: decorator
@lazy export const URI_RESERVED = memory.data<u8>([
  /*  skip 32 + 3 always set to '0' head slots
        */ 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1,
  1, /* skip 191 always set to '0' tail slots */
]);

export function encode(src: usize, len: usize, table: usize): usize {
  if (!len) return src;

  var i: usize = 0, offset: usize = 0, outSize = len << 1;
  var dst = __new(outSize, idof<String>());

  while (i < len) {
    let org = i;
    let c: u32, c1: u32;
    // fast scan a check chars until it valid ASCII
    // and safe for copying withoud escaping.
    do {
      c = <u32>load<u16>(src + (i << 1));
      // is it valid ASII and safe?
      if (c - 33 < 94) { // 127 - 33
        if (load<u8>(table + (c - 33))) break;
      } else break;
    } while (++i < len);

    // if we have some safe range of sequence just copy it without encoding
    if (i > org) {
      let size = i - org << 1;
      if (offset + size > outSize) {
        outSize = offset + size;
        dst = __renew(dst, outSize);
      }
      // TODO: should we optimize for short cases like 2 byte size?
      memory.copy(
        dst + offset,
        src + (org << 1),
        size
      );
      offset += size;
      // return if we reach end on input string
      if (i >= len) break;
    }

    // decode UTF16 with checking for unpaired surrogates
    if (c >= 0xD800) {
      if (c >= 0xDC00 && c <= 0xDFFF) {
        throw new URIError(E_URI_MALFORMED);
      }
      if (c <= 0xDBFF) {
        if (i >= len) {
          throw new URIError(E_URI_MALFORMED);
        }
        c1 = <u32>load<u16>(src + (++i << 1));
        if (c1 < 0xDC00 || c1 > 0xDFFF) {
          throw new URIError(E_URI_MALFORMED);
        }
        c = (((c & 0x3FF) << 10) | (c1 & 0x3FF)) + 0x10000;
      }
    }

    let estSize = offset + (c < 0x80 ? 1 * 6 : 4 * 6);
    if (estSize > outSize) {
      // doubling estimated size but only for greater than one
      // input lenght due to we already estemated it for worst case
      outSize = len > 1 ? estSize << 1 : estSize;
      dst = __renew(dst, outSize);
    }

    if (c < 0x80) {
      // encode ASCII unsafe code point
      storeHex(dst, offset, c);
      offset += 6;
    } else {
      // encode UTF-8 unsafe code point
      if (c < 0x800) {
        storeHex(dst, offset, (c >> 6) | 0xC0);
        offset += 6;
      } else {
        if (c < 0x10000) {
          storeHex(dst, offset, (c >> 12) | 0xE0);
          offset += 6;
        } else {
          storeHex(dst, offset, (c >> 18) | 0xF0);
          offset += 6;
          storeHex(dst, offset, (c >> 12 & 0x3F) | 0x80);
          offset += 6;
        }
        storeHex(dst, offset, (c >> 6 & 0x3F) | 0x80);
        offset += 6;
      }
      storeHex(dst, offset, (c & 0x3F) | 0x80);
      offset += 6;
    }
    ++i;
  }
  // shink output string buffer if necessary
  if (outSize > offset) {
    dst = __renew(dst, offset);
  }
  return dst;
}

export function decode(src: usize, len: usize, component: bool): usize {
  if (!len) return src;

  var i: usize = 0, offset: usize = 0, ch: u32 = 0;
  var dst = __new(len << 1, idof<String>());

  while (i < len) {
    let org = i;
    while (i < len && (ch = load<u16>(src + (i << 1))) != CharCode.PERCENT) i++;

    if (i > org) {
      let size = i - org << 1;
      // TODO: should we optimize for short cases like 2 byte size?
      memory.copy(
        dst + offset,
        src + (org << 1),
        size
      );
      offset += size;
      if (i >= len) break;
    }

    // decode hex
    if (
      i + 2 >= len ||
      ch != CharCode.PERCENT ||
      (ch = loadHex(src, i + 1 << 1)) == -1
    ) throw new URIError(E_URI_MALFORMED);

    i += 3;
    if (ch < 0x80) {
      if (!component && isReserved(ch)) {
        ch = CharCode.PERCENT;
        i -= 2;
      }
    } else {
      // decode UTF-8 sequence
      let nb = utf8LenFromUpperByte(ch);
      // minimal surrogate: 2 => 0x80, 3 => 0x800, 4 => 0x10000, _ => -1
      let lo: u32 = 1 << (17 * nb >> 2) - 1;
      // mask: 2 => 31, 3 => 15, 4 => 7, _ =>  0
      ch &= nb ? (0x80 >> nb) - 1 : 0;

      while (--nb != 0) {
        let c1: u32;
        // decode hex
        if (
          i + 2 >= len ||
          load<u16>(src + (i << 1)) != CharCode.PERCENT ||
          (c1 = loadHex(src, i + 1 << 1)) == -1
        ) throw new URIError(E_URI_MALFORMED);

        i += 3;
        if ((c1 & 0xC0) != 0x80) {
          ch = 0;
          break;
        }
        ch = (ch << 6) | (c1 & 0x3F);
      }

      // check if UTF8 code point properly fit into invalid UTF16 encoding
      if (ch < lo || lo == -1 || ch > 0x10FFFF || (ch >= 0xD800 && ch < 0xE000)) {
        throw new URIError(E_URI_MALFORMED);
      }

      // encode UTF16
      if (ch >= 0x10000) {
        ch -= 0x10000;
        let lo = ch >> 10 | 0xD800;
        let hi = (ch & 0x03FF) | 0xDC00;
        store<u32>(dst + offset, lo | (hi << 16));
        offset += 4;
        continue;
      }
    }
    store<u16>(dst + offset, ch);
    offset += 2;
  }

  assert(offset <= (len << 1));
  // shink output string buffer if necessary
  if ((len << 1) > offset) {
    dst = __renew(dst, offset);
  }
  return dst;
}

function storeHex(dst: usize, offset: usize, ch: u32): void {
  // @ts-ignore: decorator
  const HEX_CHARS = memory.data<u8>([
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46
  ]);

  store<u16>(dst + offset, CharCode.PERCENT, 0); // %
  store<u32>(
    dst + offset,
    <u32>load<u8>(HEX_CHARS + (ch >> 4 & 0x0F)) |
    <u32>load<u8>(HEX_CHARS + (ch      & 0x0F)) << 16,
    2
  ); // XX
}

function loadHex(src: usize, offset: usize): u32 {
  let c0 = <u32>load<u16>(src + offset, 0);
  let c1 = <u32>load<u16>(src + offset, 2);
  return isHex(c0) && isHex(c1)
    ? fromHex(c0) << 4 | fromHex(c1)
    : -1;
}

// @ts-ignore: decorator
@inline function fromHex(ch: u32): u32 {
  return (ch | 32) % 39 - 9;
}

// @ts-ignore: decorator
@inline function utf8LenFromUpperByte(c0: u32): u32 {
  // same as
  // if (c0 - 0xC0 <= 0xDF - 0xC0) return 2;
  // if (c0 - 0xE0 <= 0xEF - 0xE0) return 3;
  // if (c0 - 0xF0 <= 0xF7 - 0xF0) return 4;
  // return 0;
  return c0 - 0xC0 < 56
    ? clz(~(c0 << 24))
    : 0;
}

// @ts-ignore: decorator
@inline function isReserved(ch: u32): bool {
  return ch - 35 < 30
    ? <bool>load<u8>(URI_RESERVED + (ch - 35))
    : false;
}

// @ts-ignore: decorator
@inline function isHex(ch: u32): bool {
  // @ts-ignore
  return (ch - CharCode._0 < 10) | ((ch | 32) - CharCode.a < 6);
}

'''
'''--- std/assembly/vector.ts ---
/** Vector abstraction. */
@final @unmanaged
export abstract class V128 {
}

'''
'''--- std/assembly/wasi/index.ts ---
import {
  proc_exit,
  fd_write,
  iovec,
  random_get
} from "bindings/wasi";

import {
  MAX_DOUBLE_LENGTH,
  decimalCount32,
  dtoa_buffered
} from "util/number";

// @ts-ignore: decorator
@global @inline const ASC_WASI = true; // eslint-disable-line @typescript-eslint/no-unused-vars

function abort( // eslint-disable-line @typescript-eslint/no-unused-vars
  message: string | null = null,
  fileName: string | null = null,
  lineNumber: u32 = 0,
  columnNumber: u32 = 0
): void {
  // 0: iov.buf
  // 4: iov.buf_len
  // 8: len
  // 12: buf...
  const iovPtr: usize = 0;
  const lenPtr: usize = iovPtr + offsetof<iovec>();
  const bufPtr: usize = lenPtr + sizeof<usize>();
  changetype<iovec>(iovPtr).buf = bufPtr;
  var ptr = bufPtr;
  store<u64>(ptr, 0x203A74726F6261); ptr += 7; // 'abort: '
  if (message !== null) {
    ptr += String.UTF8.encodeUnsafe(changetype<usize>(message), message.length, ptr);
  }
  store<u32>(ptr, 0x206E6920); ptr += 4; // ' in '
  if (fileName !== null) {
    ptr += String.UTF8.encodeUnsafe(changetype<usize>(fileName), fileName.length, ptr);
  }
  store<u8>(ptr++, 0x28); // (
  var len = decimalCount32(lineNumber); ptr += len;
  do {
    let t = lineNumber / 10;
    store<u8>(--ptr, 0x30 + lineNumber % 10);
    lineNumber = t;
  } while (lineNumber); ptr += len;
  store<u8>(ptr++, 0x3A); // :
  len = decimalCount32(columnNumber); ptr += len;
  do {
    let t = columnNumber / 10;
    store<u8>(--ptr, 0x30 + columnNumber % 10);
    columnNumber = t;
  } while (columnNumber); ptr += len;
  store<u16>(ptr, 0x0A29); ptr += 2; // )\n
  changetype<iovec>(iovPtr).buf_len = ptr - bufPtr;
  fd_write(2, iovPtr, 1, lenPtr);
  proc_exit(255);
}

function trace( // eslint-disable-line @typescript-eslint/no-unused-vars
  message: string,
  n: i32 = 0,
  a0: f64 = 0,
  a1: f64 = 0,
  a2: f64 = 0,
  a3: f64 = 0,
  a4: f64 = 0
): void {
  // 0: iov.buf
  // 4: iov.buf_len
  // 8: len
  // 12: buf...
  var iovPtr = __alloc(offsetof<iovec>() + sizeof<usize>() + 1 + <usize>(max(String.UTF8.byteLength(message), MAX_DOUBLE_LENGTH << 1)));
  var lenPtr = iovPtr + offsetof<iovec>();
  var bufPtr = lenPtr + sizeof<usize>();
  changetype<iovec>(iovPtr).buf = bufPtr;
  store<u64>(bufPtr, 0x203A6563617274); // 'trace: '
  changetype<iovec>(iovPtr).buf_len = 7;
  fd_write(2, iovPtr, 1, lenPtr);
  changetype<iovec>(iovPtr).buf_len = String.UTF8.encodeUnsafe(changetype<usize>(message), message.length, bufPtr);
  fd_write(2, iovPtr, 1, lenPtr);
  if (n) {
    store<u8>(bufPtr++, 0x20); // space
    changetype<iovec>(iovPtr).buf_len = 1 + String.UTF8.encodeUnsafe(bufPtr, dtoa_buffered(bufPtr, a0), bufPtr);
    fd_write(2, iovPtr, 1, lenPtr);
    if (n > 1) {
      changetype<iovec>(iovPtr).buf_len = 1 + String.UTF8.encodeUnsafe(bufPtr, dtoa_buffered(bufPtr, a1), bufPtr);
      fd_write(2, iovPtr, 1, lenPtr);
      if (n > 2) {
        changetype<iovec>(iovPtr).buf_len = 1 + String.UTF8.encodeUnsafe(bufPtr, dtoa_buffered(bufPtr, a2), bufPtr);
        fd_write(2, iovPtr, 1, lenPtr);
        if (n > 3) {
          changetype<iovec>(iovPtr).buf_len = 1 + String.UTF8.encodeUnsafe(bufPtr, dtoa_buffered(bufPtr, a3), bufPtr);
          fd_write(2, iovPtr, 1, lenPtr);
          if (n > 4) {
            changetype<iovec>(iovPtr).buf_len = 1 + String.UTF8.encodeUnsafe(bufPtr, dtoa_buffered(bufPtr, a4), bufPtr);
            fd_write(2, iovPtr, 1, lenPtr);
          }
        }
      }
    }
    --bufPtr;
  }
  store<u8>(bufPtr, 0x0A); // \n
  changetype<iovec>(iovPtr).buf_len = 1;
  fd_write(2, iovPtr, 1, lenPtr);
  __free(iovPtr);
}

function seed(): f64 { // eslint-disable-line @typescript-eslint/no-unused-vars
  var temp = load<u64>(0);
  var rand: u64;
  do {
    random_get(0, 8); // to be sure
    rand = load<u64>(0);
  } while (!rand);
  store<u64>(0, temp);
  return reinterpret<f64>(rand);
}

export * from "bindings/wasi";

'''
'''--- std/portable.json ---
{
  "extends": "../tsconfig-base.json",
  "compilerOptions": {
    "target": "esnext",
    "module": "commonjs",
    "allowJs": true,
    "downlevelIteration": true,
    "preserveConstEnums": true,
    "typeRoots": [ "types" ],
    "types": [ "portable" ],
    "lib": ["esnext", "esnext.string"]
  }
}

'''
'''--- std/portable/index.d.ts ---
/**
 * Environment definitions for compiling AssemblyScript to JavaScript using tsc.
 *
 * Note that semantic differences require additional explicit conversions for full compatibility.
 * For example, when casting an i32 to an u8, doing `<u8>(someI32 & 0xff)` will yield the same
 * result when compiling to WebAssembly or JS while `<u8>someI32` alone does nothing in JS.
 *
 * Note that i64's are not portable (JS numbers are IEEE754 doubles with a maximum safe integer
 * value of 2^53-1) and instead require a compatibility layer to work in JS as well, as for example
 * {@link glue/js/i64} respectively {@link glue/wasm/i64}.
 *
 * @module std/portable
 *//***/

// Types

declare type bool = boolean;
declare type i8 = number;
declare type i16 = number;
declare type i32 = number;
declare type isize = number;
declare type u8 = number;
declare type u16 = number;
declare type u32 = number;
declare type usize = number;
declare type f32 = number;
declare type f64 = number;

/** Special type evaluating the indexed access index type. */
declare type indexof<T extends unknown[]> = keyof T;
/** Special type evaluating the indexed access value type. */
declare type valueof<T extends unknown[]> = T[0];

// Compiler hints

/** Compiler target. 0 = JS, 1 = WASM32, 2 = WASM64. */
declare const ASC_TARGET: i32;
/** Provided noAssert option. */
declare const ASC_NO_ASSERT: bool;
/** Provided memoryBase option. */
declare const ASC_MEMORY_BASE: i32;
/** Provided optimizeLevel option. */
declare const ASC_OPTIMIZE_LEVEL: i32;
/** Provided shrinkLevel option. */
declare const ASC_SHRINK_LEVEL: i32;
/** Whether the mutable global feature is enabled. */
declare const ASC_FEATURE_MUTABLE_GLOBAL: bool;
/** Whether the sign extension feature is enabled. */
declare const ASC_FEATURE_SIGN_EXTENSION: bool;

// Builtins

/** Performs the sign-agnostic count leading zero bits operation on a 32-bit integer. All zero bits are considered leading if the value is zero. */
declare function clz<T = i32>(value: T): T;
/** Performs the sign-agnostic count tailing zero bits operation on a 32-bit integer. All zero bits are considered trailing if the value is zero. */
declare function ctz<T = i32>(value: T): T;
/** Performs the sign-agnostic count number of one bits operation on a 32-bit integer. */
declare function popcnt<T = i32>(value: T): T;
/** Performs the sign-agnostic rotate left operation on a 32-bit integer. */
declare function rotl<T = i32>(value: T, shift: T): T;
/** Performs the sign-agnostic rotate right operation on a 32-bit integer. */
declare function rotr<T = i32>(value: T, shift: T): T;
/** Computes the absolute value of an integer or float. */
declare function abs<T = i32 | f32 | f64>(value: T): T;
/** Determines the maximum of two integers or floats. If either operand is `NaN`, returns `NaN`. */
declare function max<T = i32 | f32 | f64>(left: T, right: T): T;
/** Determines the minimum of two integers or floats. If either operand is `NaN`, returns `NaN`. */
declare function min<T = i32 | f32 | f64>(left: T, right: T): T;
/** Composes a 32-bit or 64-bit float from the magnitude of `x` and the sign of `y`. */
declare function copysign<T = f32 | f64>(x: T, y: T): T;
/** Performs the ceiling operation on a 32-bit or 64-bit float. */
declare function ceil<T = f32 | f64>(value: T): T;
/** Performs the floor operation on a 32-bit or 64-bit float. */
declare function floor<T = f32 | f64>(value: T): T;
/** Rounds to the nearest integer tied to even of a 32-bit or 64-bit float. */
declare function nearest<T = f32 | f64>(value: T): T;
/** Selects one of two pre-evaluated values depending on the condition. */
declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;
/** Calculates the square root of a 32-bit or 64-bit float. */
declare function sqrt<T = f32 | f64>(value: T): T;
/** Rounds to the nearest integer towards zero of a 32-bit or 64-bit float. */
declare function trunc<T = f32 | f64>(value: T): T;
/** Emits an unreachable operation that results in a runtime error when executed. */
declare function unreachable(): any; // sic

/** Changes the type of any value of `usize` kind to another one of `usize` kind. Useful for casting class instances to their pointer values and vice-versa. Beware that this is unsafe.*/
declare function changetype<T>(value: any): T;
/** Explicitly requests no bounds checks on the provided expression. Useful for array accesses. */
declare function unchecked<T>(value: T): T;
/** Tests if the specified value is a valid integer. Can't distinguish an integer from an integral float. */
declare function isInteger(value: any): value is number;
/** Tests if the specified value is a valid float. Can't distinguish a float from an integer. */
declare function isFloat(value: any): value is number;
/** Tests if the specified value is of a nullable reference type. */
declare function isNullable(value: any): bool;
/** Tests if the specified value is of a reference type. */
declare function isReference(value: any): value is object | string;
/** Tests if the specified value is of a function type */
declare function isFunction(value: any): value is Function;
/** Tests if the specified value can be used as a string. */
declare function isString(value: any): value is string | String;
/** Tests if the specified value can be used as an array. */
declare function isArray(value: any): value is Array<any>;
/** Tests if the specified type *or* expression can be used as an array like object. */
declare function isArrayLike(value: any): value is ArrayLike<any>;
/** Tests if the specified expression resolves to a defined element. */
declare function isDefined(expression: any): bool;
/** Tests if the specified expression evaluates to a constant value. */
declare function isConstant(expression: any): bool;
/** Traps if the specified value is not true-ish, otherwise returns the value. */
declare function assert<T>(isTrueish: T, message?: string): T & (object | string | number); // any better way to model `: T != null`?
/** Parses an integer string to a 64-bit float. */
declare function parseInt(str: string, radix?: i32): f64;
/** Parses a floating point string to a 64-bit float. */
declare function parseFloat(str: string): f64;
/** Returns the 64-bit floating-point remainder of `x/y`. */
declare function fmod(x: f64, y: f64): f64;
/** Returns the 32-bit floating-point remainder of `x/y`. */
declare function fmodf(x: f32, y: f32): f32;

/** Converts any other numeric value to an 8-bit signed integer. */
declare function i8(value: any): i8;
declare namespace i8 {
  /** Smallest representable value. */
  export const MIN_VALUE: i8;
  /** Largest representable value. */
  export const MAX_VALUE: i8;
  /** Converts a string to a floating-point number and cast to target integer after. */
  export function parseFloat(string: string): i8;
  /** Converts A string to an integer. */
  export function parseInt(string: string, radix?: i32): i8;
}
/** Converts any other numeric value to a 16-bit signed integer. */
declare function i16(value: any): i16;
declare namespace i16 {
  /** Smallest representable value. */
  export const MIN_VALUE: i16;
  /** Largest representable value. */
  export const MAX_VALUE: i16;
  /** Converts a string to a floating-point number and cast to target integer after. */
  export function parseFloat(string: string): i16;
  /** Converts A string to an integer. */
  export function parseInt(string: string, radix?: i32): i16;
}
/** Converts any other numeric value to a 32-bit signed integer. */
declare function i32(value: any): i32;
declare namespace i32 {
  /** Smallest representable value. */
  export const MIN_VALUE: i32;
  /** Largest representable value. */
  export const MAX_VALUE: i32;
  /** Converts a string to a floating-point number and cast to target integer after. */
  export function parseFloat(string: string): i32;
  /** Converts A string to an integer. */
  export function parseInt(string: string, radix?: i32): i32;
}
/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) signed integer. */
declare function isize(value: any): isize;
declare namespace isize {
  /** Smallest representable value. */
  export const MIN_VALUE: isize;
  /** Largest representable value. */
  export const MAX_VALUE: isize;
  /** Converts a string to a floating-point number and cast to target integer after. */
  export function parseFloat(string: string): isize;
  /** Converts A string to an integer. */
  export function parseInt(string: string, radix?: i32): isize;
}
/** Converts any other numeric value to an 8-bit unsigned integer. */
declare function u8(value: any): u8;
declare namespace u8 {
  /** Smallest representable value. */
  export const MIN_VALUE: u8;
  /** Largest representable value. */
  export const MAX_VALUE: u8;
  /** Converts a string to a floating-point number and cast to target integer after. */
  export function parseFloat(string: string): u8;
  /** Converts A string to an integer. */
  export function parseInt(string: string, radix?: i32): u8;
}
/** Converts any other numeric value to a 16-bit unsigned integer. */
declare function u16(value: any): u16;
declare namespace u16 {
  /** Smallest representable value. */
  export const MIN_VALUE: u16;
  /** Largest representable value. */
  export const MAX_VALUE: u16;
  /** Converts a string to a floating-point number and cast to target integer after. */
  export function parseFloat(string: string): u16;
  /** Converts A string to an integer. */
  export function parseInt(string: string, radix?: i32): u16;
}
/** Converts any other numeric value to a 32-bit unsigned integer. */
declare function u32(value: any): u32;
declare namespace u32 {
  /** Smallest representable value. */
  export const MIN_VALUE: u32;
  /** Largest representable value. */
  export const MAX_VALUE: u32;
  /** Converts a string to a floating-point number and cast to target integer after. */
  export function parseFloat(string: string): u32;
  /** Converts A string to an integer. */
  export function parseInt(string: string, radix?: i32): u32;
}
/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) unsigned integer. */
declare function usize(value: any): isize;
declare namespace usize {
  /** Smallest representable value. */
  export const MIN_VALUE: usize;
  /** Largest representable value. */
  export const MAX_VALUE: usize;
  /** Converts a string to a floating-point number and cast to target integer after. */
  export function parseFloat(string: string): usize;
  /** Converts A string to an integer. */
  export function parseInt(string: string, radix?: i32): usize;
}
/** Converts any other numeric value to a 1-bit unsigned integer. */
declare function bool(value: any): bool;
declare namespace bool {
  /** Smallest representable value. */
  export const MIN_VALUE: bool;
  /** Largest representable value. */
  export const MAX_VALUE: bool;
}
/** Converts any other numeric value to a 32-bit float. */
declare function f32(value: any): f32;
declare namespace f32 {
  /** Smallest representable value. */
  export const MIN_VALUE: f32;
  /** Largest representable value. */
  export const MAX_VALUE: f32;
  /** Smallest normalized positive value. */
  export const MIN_NORMAL_VALUE: f32;
  /** Smallest safely representable integer value. */
  export const MIN_SAFE_INTEGER: f32;
  /** Largest safely representable integer value. */
  export const MAX_SAFE_INTEGER: f32;
  /** Positive infinity value. */
  export const POSITIVE_INFINITY: f32;
  /** Negative infinity value. */
  export const NEGATIVE_INFINITY: f32;
  /** Not a number value. */
  /* eslint no-shadow-restricted-names: "off" */
  export const NaN: f32;
  /** Difference between 1 and the smallest representable value greater than 1. */
  export const EPSILON: f32;
  /** Returns a boolean value that indicates whether a value is the reserved value NaN (not a number). */
  export function isNaN(value: f32): bool;
  /** Returns true if passed value is finite. */
  export function isFinite(value: f32): bool;
  /** Returns true if the value passed is a safe integer. */
  export function isSafeInteger(value: f32): bool;
  /** Returns true if the value passed is an integer, false otherwise. */
  export function isInteger(value: f32): bool;
  /** Converts a string to a floating-point number. */
  export function parseFloat(string: string): f32;
  /** Converts A string to an integer. */
  export function parseInt(string: string, radix?: i32): f32;
}
/** Converts any other numeric value to a 64-bit float. */
declare function f64(value: any): f64;
declare namespace f64 {
  /** Smallest representable value. */
  export const MIN_VALUE: f64;
  /** Largest representable value. */
  export const MAX_VALUE: f64;
  /** Smallest normalized positive value. */
  export const MIN_NORMAL_VALUE: f64;
  /** Smallest safely representable integer value. */
  export const MIN_SAFE_INTEGER: f64;
  /** Largest safely representable integer value. */
  export const MAX_SAFE_INTEGER: f64;
  /** Positive infinity value. */
  export const POSITIVE_INFINITY: f64;
  /** Negative infinity value. */
  export const NEGATIVE_INFINITY: f64;
  /** Not a number value. */
  /* eslint no-shadow-restricted-names: "off" */
  export const NaN: f64;
  /** Difference between 1 and the smallest representable value greater than 1. */
  export const EPSILON: f64;
  /** Returns a boolean value that indicates whether a value is the reserved value NaN (not a number). */
  export function isNaN(value: f32): bool;
  /** Returns true if passed value is finite. */
  export function isFinite(value: f32): bool;
  /** Returns true if the value passed is a safe integer. */
  export function isSafeInteger(value: f64): bool;
  /** Returns true if the value passed is an integer, false otherwise. */
  export function isInteger(value: f64): bool;
  /** Converts a string to a floating-point number. */
  export function parseFloat(string: string): f64;
  /** Converts A string to an integer. */
  export function parseInt(string: string, radix?: i32): f64;
}

// Polyfills

/** [Polyfill] Performs the sign-agnostic reverse bytes **/
declare function bswap<T = i32 | u32 | isize | usize>(value: T): T;
/** [Polyfill] Performs the sign-agnostic reverse bytes only for last 16-bit **/
declare function bswap16<T = i16 | u16 | i32 | u32>(value: T): T;

// Standard library

declare const Mathf: typeof Math;
declare const JSMath: typeof Math;

declare interface StringConstructor {
  /** Equivalent to calling `String.fromCharCode` with multiple arguments. */
  fromCharCodes(arr: u16[]): string;
  /** Equivalent to calling `String.fromCodePoint` with multiple arguments. */
  fromCodePoints(arr: i32[]): string;
}

declare interface String {
  /** Returns value using relative indexing. Index may be negative */
  at(index: i32): string;
}

/** Annotates a class as being unmanaged with limited capabilities. */
declare function unmanaged(constructor: Function): void;

/** Environmental tracing function. */
declare function trace(msg: string, n?: i32, a0?: f64, a1?: f64, a2?: f64, a3?: f64, a4?: f64): void;

declare interface Array<T> {
  /** Returns value using relative indexing. Index may be negative */
  at(index: i32): T;
  /** Returns an index start searching from the end in the array */
  findLastIndex(callbackfn: (value: T, index: i32, self: Array<T>) => bool): i32;
}

declare interface Int8ArrayConstructor {
  /** Equivalent to calling `new Int8Array` with multiple arguments. */
  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int8Array;
}

declare interface Int8Array {
  /** Returns value using relative indexing. Index may be negative */
  at(index: i32): i8;
  /** Returns an index start searching from the end in the typedarray */
  findLastIndex(callbackfn: (value: i8, index: i32, self: Int8Array) => bool): i32;
}

declare interface Uint8ArrayConstructor {
  /** Equivalent to calling `new Uint8Array` with multiple arguments. */
  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint8Array;
}

declare interface Uint8Array {
  /** Returns value using relative indexing. Index may be negative */
  at(index: i32): u8;
  /** Returns an index start searching from the end in the typedarray */
  findLastIndex(callbackfn: (value: u8, index: i32, self: Uint8Array) => bool): i32;
}

declare interface Uint8ClampedArrayConstructor {
  /** Equivalent to calling `new Uint8ClampedArray` with multiple arguments. */
  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint8ClampedArray;
}

declare interface Uint8ClampedArray {
  /** Returns value using relative indexing. Index may be negative */
  at(index: i32): u8;
  /** Returns an index start searching from the end in the typedarray */
  findLastIndex(callbackfn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32;
}

declare interface Int16ArrayConstructor {
  /** Equivalent to calling `new Int16Array` with multiple arguments. */
  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int16Array;
}

declare interface Int16Array {
  /** Returns value using relative indexing. Index may be negative */
  at(index: i32): i16;
  /** Returns an index start searching from the end in the typedarray */
  findLastIndex(callbackfn: (value: i16, index: i32, self: Int16Array) => bool): i32;
}

declare interface Uint16ArrayConstructor {
  /** Equivalent to calling `new Uint16Array` with multiple arguments. */
  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint16Array;
}

declare interface Uint16Array {
  /** Returns value using relative indexing. Index may be negative */
  at(index: i32): u16;
  /** Returns an index start searching from the end in the typedarray */
  findLastIndex(callbackfn: (value: u16, index: i32, self: Uint16Array) => bool): i32;
}

declare interface Int32ArrayConstructor {
  /** Equivalent to calling `new Int32Array` with multiple arguments. */
  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Int32Array;
}

declare interface Int32Array {
  /** Returns value using relative indexing. Index may be negative */
  at(index: i32): i32;
  /** Returns an index start searching from the end in the typedarray */
  findLastIndex(callbackfn: (value: i32, index: i32, self: Int32Array) => bool): i32;
}

declare interface Uint32ArrayConstructor {
  /** Equivalent to calling `new Uint32Array` with multiple arguments. */
  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Uint32Array;
}

declare interface Uint32Array {
  /** Returns value using relative indexing. Index may be negative */
  at(index: i32): u32;
  /** Returns an index start searching from the end in the typedarray */
  findLastIndex(callbackfn: (value: u32, index: i32, self: Uint32Array) => bool): i32;
}

declare interface Float32ArrayConstructor {
  /** Equivalent to calling `new Float32Array` with multiple arguments. */
  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Float32Array;
}

declare interface Float32Array {
  /** Returns value using relative indexing. Index may be negative */
  at(index: i32): f32;
  /** Returns an index start searching from the end in the typedarray */
  findLastIndex(callbackfn: (value: f32, index: i32, self: Float32Array) => bool): i32;
}

declare interface Float64ArrayConstructor {
  /** Equivalent to calling `new Float64Array` with multiple arguments. */
  wrap(buffer: ArrayBuffer, byteOffset?: i32, length?: i32): Float64Array;
}

declare interface Float64Array {
  /** Returns value using relative indexing. Index may be negative */
  at(index: i32): f64;
  /** Returns an index start searching from the end in the typedarray */
  findLastIndex(callbackfn: (value: f64, index: i32, self: Float64Array) => bool): i32;
}

// FIXME: remove
declare function offsetof<T>(fieldName?: string): usize;
declare function idof<T>(): u32;

'''
'''--- std/portable/index.js ---
/** @module std/portable *//***/

var globalScope = typeof window !== "undefined" && window || typeof global !== "undefined" && global || self;

globalScope.ASC_TARGET = 0; // Target.JS
globalScope.ASC_NO_ASSERT = false;
globalScope.ASC_MEMORY_BASE = 0;
globalScope.ASC_OPTIMIZE_LEVEL = 3;
globalScope.ASC_SHRINK_LEVEL = 0;
globalScope.ASC_FEATURE_MUTABLE_GLOBAL = false;
globalScope.ASC_FEATURE_SIGN_EXTENSION = false;
globalScope.ASC_FEATURE_BULK_MEMORY = false;
globalScope.ASC_FEATURE_SIMD = false;
globalScope.ASC_FEATURE_THREADS = false;

var F64 = new Float64Array(1);
var U64 = new Uint32Array(F64.buffer);

Object.defineProperties(
  globalScope["i8"] = function i8(value) { return value << 24 >> 24; },
  {
    "MIN_VALUE": { value: -128, writable: false },
    "MAX_VALUE": { value:  127, writable: false }
  }
);

Object.defineProperties(
  globalScope["i16"] = function i16(value) { return value << 16 >> 16; },
  {
    "MIN_VALUE": { value: -32768, writable: false },
    "MAX_VALUE": { value:  32767, writable: false }
  }
);

Object.defineProperties(
  globalScope["i32"] = globalScope["isize"] = function i32(value) { return value | 0; },
  {
    "MIN_VALUE": { value: -2147483648, writable: false },
    "MAX_VALUE": { value:  2147483647, writable: false }
  }
);

Object.defineProperties(
  globalScope["u8"] = function u8(value) { return value & 0xff; },
  {
    "MIN_VALUE": { value:   0, writable: false },
    "MAX_VALUE": { value: 255, writable: false }
  }
);

Object.defineProperties(
  globalScope["u16"] = function u16(value) { return value & 0xffff; },
  {
    "MIN_VALUE": { value:     0, writable: false },
    "MAX_VALUE": { value: 65535, writable: false }
  }
);

Object.defineProperties(
  globalScope["u32"] = globalScope["usize"] = function u32(value) { return value >>> 0; },
  {
    "MIN_VALUE": { value:          0, writable: false },
    "MAX_VALUE": { value: 4294967295, writable: false }
  }
);

Object.defineProperties(
  globalScope["bool"] = function bool(value) { return !!value; },
  {
    "MIN_VALUE": { value: false, writable: false },
    "MAX_VALUE": { value: true,  writable: false }
  }
);

Object.defineProperties(
  globalScope["f32"] = function f32(value) { return Math.fround(value); },
  {
    "EPSILON":   { value: 1.1920928955078125e-07, writable: false },
    "MIN_VALUE": { value: 1.4012984643248170e-45, writable: false },
    "MAX_VALUE": { value: 3.4028234663852886e+38, writable: false },
    "MIN_NORMAL_VALUE":  { value:  1.1754943508222875e-38, writable: false },
    "MIN_SAFE_INTEGER":  { value: -16777215, writable: false },
    "MAX_SAFE_INTEGER":  { value:  16777215, writable: false },
    "POSITIVE_INFINITY": { value:  Infinity, writable: false },
    "NEGATIVE_INFINITY": { value: -Infinity, writable: false },
    "NaN": { value: NaN, writable: false }
  }
);

Object.defineProperties(
  globalScope["f64"] = function f64(value) { return +value; },
  {
    "EPSILON":   { value: 2.2204460492503131e-016, writable: false },
    "MIN_VALUE": { value:                  5e-324, writable: false },
    "MAX_VALUE": { value: 1.7976931348623157e+308, writable: false },
    "MIN_NORMAL_VALUE":  { value:  2.2250738585072014e-308, writable: false },
    "MIN_SAFE_INTEGER":  { value: -9007199254740991, writable: false },
    "MAX_SAFE_INTEGER":  { value:  9007199254740991, writable: false },
    "POSITIVE_INFINITY": { value:  Infinity, writable: false },
    "NEGATIVE_INFINITY": { value: -Infinity, writable: false },
    "NaN": { value: NaN, writable: false }
  }
);

globalScope["clz"] = Math.clz32;

globalScope["ctz"] = function ctz(value) {
  var c = Math.clz32(value & -value);
  return value ? 31 - c : c;
};

globalScope["popcnt"] = function popcnt(value) {
  value -= value >>> 1 & 0x55555555;
  value = (value & 0x33333333) + (value >>> 2 & 0x33333333);
  return (((value + (value >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;
};

globalScope["rotl"] = function rotl(value, shift) {
  shift &= 31;
  return (value << shift) | (value >>> (32 - shift));
};

globalScope["rotr"] = function rotr(value, shift) {
  shift &= 31;
  return (value >>> shift) | (value << (32 - shift));
};

globalScope["abs"] = Math.abs;

globalScope["max"] = Math.max;

globalScope["min"] = Math.min;

globalScope["ceil"] = Math.ceil;

globalScope["floor"] = Math.floor;

// Adopt code from https://github.com/rfk/wasm-polyfill
globalScope["nearest"] = function nearest(value) {
  if (Math.abs(value - Math.trunc(value)) === 0.5) {
    return 2.0 * Math.round(value * 0.5);
  }
  return Math.round(value);
};

globalScope["select"] = function select(ifTrue, ifFalse, condition) {
  return condition ? ifTrue : ifFalse;
};

globalScope["sqrt"] = Math.sqrt;

globalScope["trunc"] = Math.trunc;

globalScope["copysign"] = function copysign(x, y) {
  return Math.abs(x) * Math.sign(y);
};

globalScope["bswap"] = function bswap(value) {
  var a = value >> 8 & 0x00FF00FF;
  var b = (value & 0x00FF00FF) << 8;
  value = a | b;
  a = value >> 16 & 0x0000FFFF;
  b = (value & 0x0000FFFF) << 16;
  return a | b;
};

globalScope["bswap16"] = function bswap16(value) {
  return ((value << 8) & 0xFF00) | ((value >> 8) & 0x00FF) | (value & 0xFFFF0000);
};

function UnreachableError() {
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, UnreachableError);
  } else {
    this.stack = this.name + ": " + this.message + "\n" + new Error().stack;
  }
}
UnreachableError.prototype = Object.create(Error.prototype);
UnreachableError.prototype.name = "UnreachableError";
UnreachableError.prototype.message = "unreachable";

globalScope["unreachable"] = function unreachable() {
  throw new UnreachableError();
};

function AssertionError(message) {
  this.message = message || "assertion failed";
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, AssertionError);
  } else {
    this.stack = this.name + ": " + this.message + "\n" + new Error().stack;
  }
}
AssertionError.prototype = Object.create(Error.prototype);
AssertionError.prototype.name = "AssertionError";

globalScope["assert"] = function assert(isTrueish, message) {
  if (isTrueish) return isTrueish;
  throw new AssertionError(message);
};

globalScope["changetype"] = function changetype(value) {
  return value;
};

String["fromCharCodes"] = function fromCharCodes(arr) {
  const CHUNKSIZE = 1 << 13;
  const len = arr.length;
  if (len <= CHUNKSIZE) {
    return String.fromCharCode.apply(String, arr);
  }
  let index = 0;
  let parts = '';
  while (index < len) {
    parts += String.fromCharCode.apply(
      String,
      arr.slice(index, Math.min(index + CHUNKSIZE, len))
    );
    index += CHUNKSIZE;
  }
  return parts;
};

String["fromCodePoints"] = function fromCodePoints(arr) {
  const CHUNKSIZE = 1 << 13;
  const len = arr.length;
  if (len <= CHUNKSIZE) {
    return String.fromCodePoint.apply(String, arr);
  }
  let index = 0;
  let parts = '';
  while (index < len) {
    parts += String.fromCodePoint.apply(
      String,
      arr.slice(index, Math.min(index + CHUNKSIZE, len))
    );
    index += CHUNKSIZE;
  }
  return parts;
};

if (!String.prototype.at) {
  Object.defineProperty(String.prototype, "at", {
    value: function at(index) {
      return this.charAt(index >= 0 ? index : index + this.length);
    },
    configurable: true
  });
}

if (!String.prototype.replaceAll) {
  Object.defineProperty(String.prototype, "replaceAll", {
    value: function replaceAll(search, replacment) {
      var res = this.split(search).join(replacment);
      if (!search.length) res = replacment + res + replacment;
      return res;
    },
    configurable: true
  });
}

function defaultComparator(a, b) {
  if (a === b) {
    if (a !== 0) return 0;
    a = 1 / a, b = 1 / b;
  } else {
    var nanA = a != a, nanB = b != b;
    if (nanA | nanB) return nanA - nanB;
    if (a == null) a = String(a);
    if (b == null) b = String(b);
  }
  return a > b ? 1 : -1;
}

const arraySort = Array.prototype.sort;
Array.prototype.sort = function sort(comparator) {
  return arraySort.call(this, comparator || defaultComparator);
};

[ Array,
  Uint8ClampedArray,
  Uint8Array, Int8Array,
  Uint16Array, Int16Array,
  Uint32Array, Int32Array,
  Float32Array, Float64Array
].forEach(Ctr => {
  if (!Ctr.prototype.at) {
    Object.defineProperty(Ctr.prototype, "at", {
      value: function at(index) {
        return this[index >= 0 ? index : index + this.length];
      },
      configurable: true
    });
  }

  if (!Ctr.prototype.findLastIndex) {
    Object.defineProperty(Ctr.prototype, "findLastIndex", {
      value: function findLastIndex(fn) {
        for (let i = this.length - 1; i >= 0; --i) {
          if (fn(this[i], i, this)) return i;
        }
        return -1;
      },
      configurable: true
    });
  }
});

globalScope["isInteger"] = Number.isInteger;

globalScope["isFloat"] = function isFloat(arg) {
  return typeof arg === "number";
};

globalScope["isNullable"] = function isNullable(arg) {
  return true;
};

globalScope["isReference"] = function isReference(arg) {
  return typeof arg === "object" || typeof arg === "string";
};

globalScope["isFunction"] = function isFunction(arg) {
  return typeof arg === "function";
};

globalScope["isString"] = function isString(arg) {
  return typeof arg === "string" || arg instanceof String;
};

globalScope["isArray"] = Array.isArray;
globalScope["isArrayLike"] = function isArrayLike(expr) {
  return expr
    && typeof expr === 'object'
    && typeof expr.length === 'number'
    && expr.length >= 0
    && Math.trunc(expr.length) === expr.length;
};

globalScope["isDefined"] = function isDefined(expr) {
  return typeof expr !== "undefined";
};

globalScope["isConstant"] = function isConstant(expr) {
  return false;
};

globalScope["unchecked"] = function unchecked(expr) {
  return expr;
};

globalScope["fmod"] = function fmod(x, y) {
  return x % y;
};

globalScope["fmodf"] = function fmodf(x, y) {
  return Math.fround(x % y);
};

globalScope["JSMath"] = Math;

Object.defineProperties(globalScope["JSMath"], {
  sincos_sin: { value: 0.0, writable: true },
  sincos_cos: { value: 0.0, writable: true },
  signbit: {
    value: function signbit(x) {
      F64[0] = x; return Boolean(U64[1] >>> 31);
    }
  },
  sincos: {
    value: function sincos(x) {
      this.sincos_sin = Math.sin(x);
      this.sincos_cos = Math.cos(x);
    }
  },
  exp2: {
    value: function exp2(x) {
      return Math.pow(2, x);
    }
  }
});

globalScope["unmanaged"] = function() { /* nop */ };

globalScope["trace"] = function(message, n) {
  if (n) message += Array.prototype.slice.call(arguments, 2, 2 + n);
  console.error("trace: " + message);
};

Object.defineProperty(Int8Array, "wrap", {
  value: function wrap(buffer, byteOffset, length) {
    return new Int8Array(buffer, byteOffset, length);
  }
});

Object.defineProperty(Uint8Array, "wrap", {
  value: function wrap(buffer, byteOffset, length) {
    return new Uint8Array(buffer, byteOffset, length);
  }
});

Object.defineProperty(Uint8ClampedArray, "wrap", {
  value: function wrap(buffer, byteOffset, length) {
    return new Uint8ClampedArray(buffer, byteOffset, length);
  }
});

Object.defineProperty(Int16Array, "wrap", {
  value: function wrap(buffer, byteOffset, length) {
    return new Int16Array(buffer, byteOffset, length);
  }
});

Object.defineProperty(Uint16Array, "wrap", {
  value: function wrap(buffer, byteOffset, length) {
    return new Uint16Array(buffer, byteOffset, length);
  }
});

Object.defineProperty(Int32Array, "wrap", {
  value: function wrap(buffer, byteOffset, length) {
    return new Int32Array(buffer, byteOffset, length);
  }
});

Object.defineProperty(Uint32Array, "wrap", {
  value: function wrap(buffer, byteOffset, length) {
    return new Uint32Array(buffer, byteOffset, length);
  }
});

Object.defineProperty(Float32Array, "wrap", {
  value: function wrap(buffer, byteOffset, length) {
    return new Float32Array(buffer, byteOffset, length);
  }
});

Object.defineProperty(Float64Array, "wrap", {
  value: function wrap(buffer, byteOffset, length) {
    return new Float64Array(buffer, byteOffset, length);
  }
});

'''
'''--- std/types/assembly/index.d.ts ---
import "../../assembly/index";

'''
'''--- std/types/assembly/package.json ---
{
  "types": "index.d.ts"
}
'''
'''--- std/types/portable/index.d.ts ---
import "../../portable/index";

'''
'''--- std/types/portable/package.json ---
{
  "types": "index.d.ts"
}
'''
'''--- tests/README.md ---
Tests
=====

This directory contains the test cases for AssemblyScript's parser and compiler. A test case
consists of:

* A test file that is parsed or compiled (.ts)
* One or multiple automatically generated fixtures generated from the source file

### Creating a test:

* Run `npm run clean` to make sure that the sources are tested instead of the distribution
* Create a new test file (.ts) within the respective directory (see below) that contains your test code
* Follow the instructions below to generate the first fixture(s)
* Make sure the fixture(s) contain exactly what you'd expect

### Updating a test:

* Run `npm run clean` to make sure that the sources are tested instead of the distribution
* Make changes to the respective test file (.ts)
* Follow the instructions below to update the fixture(s)
* Make sure the fixture(s) contain exactly what you'd expect

See also: [Contribution guidelines](../CONTRIBUTING.md)

Parser
------

Directory: [tests/parser](./parser)

The test file is parsed while warnings and errors are recorded and re-serialized to a new source
afterwards. The new source with warnings and errors appended as comments is compared to the fixture.

Running all tests:

```
$> npm run test:parser
```

Running a specific test only:

```
$> npm run test:parser -- testNameWithoutTs
```

To (re-)create all fixtures:

```
$>npm run test:parser -- --create
```

To (re-)create a specific fixture only:

```
$> npm run test:parser -- testNameWithoutTs --create
```

Compiler
--------

General directory: [tests/compiler](./compiler)<br />
Standard library directory: [tests/compiler/std](./compiler/std)

The source file is parsed and compiled to a module, validated and the resulting module converted to
WebAsssembly text format.

The text format output is compared to its fixture and the module interpreted in a WebAssembly VM. To
assert for runtime conditions, the `assert` builtin can be used. Note that tree-shaking is enabled
and it might be necessary to export entry points.

Additional fixtures for the optimized module etc. are generated as well but are used for visual
confirmation only.

If present, error checks are performed by expecting the exact sequence of substrings provided within
the respective `.json` file. Using the `stderr` config option will skip instantiating and running
the module.

Optionally, a `.js` file of the same name as the test file can be added containing code to run pre
and post instantiation of the module, with the following export signatures:

* **preInstantiate**(imports: `object`, exports: `object`): `void`<br />
  Can be used to populate imports with functionality required by the test. Note that `exports` is an
  empty object that will be populated with the actual exports after instantiation. Useful if an import
  needs to call an export (usually in combination with the `--explicitStart` flag).

* **postInstantiate**(instance: `WebAssembly.Instance`): `void`<br />
  Can be used to execute custom test logic once the module is ready. Throwing an error will fail the
  instantiation test.

Running all tests:

```
$> npm run test:compiler
```

Running a specific test only:

```
$> npm run test:compiler -- testNameWithoutTs
```

To (re-)create all fixtures:

```
$> npm run test:compiler -- --create
```

To (re-)create a specific fixture only:

```
$> npm run test:compiler -- testNameWithoutTs --create
```

Features
--------

Tests for experimental features (usually enabled via the `--enable` CLI flag) are disabled by default. To enable a feature, set the `ASC_FEATURES` environment variable to a comma-separated list of feature names (see [`features.json`](./features.json)). You can also set `ASC_FEATURES="*"` to enable all features.

Other
-----

Tests in other directories are not run automatically and do not need to be updated.

* [tests/allocators](./allocators) contains the memory allocator test suite
* [tests/binaryen](./binaryen) contains various triggers for earlier Binaryen issues
* [tests/tokenizer](./tokenizer.js) is a visual test for the tokenizer tokenizing itself
* [tests/util-path](./util-path.js) is a sanity test for the path utility

'''
'''--- tests/allocators/default/assembly/index.ts ---
export { heap };

'''
'''--- tests/allocators/default/assembly/tsconfig.json ---
{
  "extends": "../../../../std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- tests/allocators/default/package.json ---
{
  "private": true,
  "scripts": {
    "build": "npm run build:untouched && npm run build:optimized",
    "build:untouched": "node ../../../bin/asc assembly/index.ts -t untouched.wat -b untouched.wasm --sourceMap --measure --debug",
    "build:optimized": "node ../../../bin/asc assembly/index.ts -t optimized.wat -b optimized.wasm --sourceMap --measure --noAssert --optimize"
  }
}

'''
'''--- tests/allocators/forever.js ---
var child_process = require("child_process");

// restarts the test forever, that is, until an issue is detected

if (process.argv.length < 2) {
  console.error("Usage: npm run test:forever <allocator>");
  process.exit(1);
}

var count = 0;
while (true) {
  console.log("[ #" + ++count + " ]\n");
  var res = child_process.spawnSync("node", [ "./index", process.argv[2] ], { stdio: "inherit" });
  if (res.status !== 0)
    throw Error("exited with " + res.status);
  if (res.error)
    throw res.error;
}

'''
'''--- tests/allocators/index.js ---
const fs = require("fs");
const COMMON_MAX = 1 << 30;

function test(file) {
  console.log("Testing '" + file + "' ...\n");

  const exports = new WebAssembly.Instance(new WebAssembly.Module(fs.readFileSync(__dirname + "/" + file)), {
    env: {
      abort(msg, file, line, column) {
        throw Error("Assertion failed: " + (msg ? "'" + getString(msg) + "' " : "") + "at " + getString(file) + ":" + line + ":" + column);
      },
      log(ptr) { console.log(getString(ptr)); },
      logi(i) { console.log(i); },
      trace(...args) { console.log("trace", args); }
    }
  }).exports;

  function getString(ptr) {
    if (!ptr) return "null";
    var U32 = new Uint32Array(exports.memory.buffer);
    var U16 = new Uint16Array(exports.memory.buffer);
    var length = U32[(ptr - 4) >>> 2] >>> 1;
    var offset = ptr >>> 1;
    return String.fromCharCode.apply(String, U16.subarray(offset, offset + length));
  }

  require("./runner")(exports, 20, 20000);

  console.log("mem final: " + exports.memory.buffer.byteLength);
  console.log();

  const alloc = exports["__alloc"];
  var overflow = false;
  try {
    alloc(COMMON_MAX + 1, 0); // unreachable
    overflow = true;
  } catch (e) { /* nop */ }
  if (overflow) throw Error("allocation can overflow COMMON_MAX + 1");
  try {
    alloc(0xffffffff, 0); // unreachable
    overflow = true;
  } catch (e) { /* nop */ }
  if (overflow) throw Error("allocation can overflow 0xffffffff");
}

if (process.argv.length > 2) {
  test(process.argv[2] + "/untouched.wasm");
  test(process.argv[2] + "/optimized.wasm");
} else {
  console.error("Usage: npm test <allocator>");
  process.exit(1);
}

'''
'''--- tests/allocators/package.json ---
{
  "private": true,
  "scripts": {
    "test": "node ./index",
    "test:forever": "node ./forever",
    "test:all": "npm run test default && npm run test stub"
  }
}

'''
'''--- tests/allocators/runner.js ---
function runner(exports, runs, allocs) {
  const alloc = exports["heap.alloc"];
  const free  = exports["heap.free"];
  const reset = exports["heap.reset"];
  const fill  = exports["memory.fill"];

  const ptrs = [];

  function randomAlloc(maxSize) {
    if (!maxSize) maxSize = 8192;
    var size = ((Math.random() * maxSize) >>> 0) + 1;
    size = (size + 3) & ~3;
    var ptr = alloc(size, 0);
    if (!ptr) throw Error();
    if ((ptr & 15) != 0) throw Error("invalid alignment: " + (ptr & 15) + " on " + ptr);
    if (ptrs.indexOf(ptr) >= 0) throw Error("duplicate pointer");
    if (fill) fill(ptr, ptr % 16, size);
    ptrs.push(ptr);
    return ptr;
  }

  function preciseFree(ptr) {
    var idx = ptrs.indexOf(ptr);
    if (idx < 0) throw Error("unknown pointer");
    ptr = ptrs[idx];
    ptrs.splice(idx, 1);
    if (typeof ptr !== "number") throw Error();
    free(ptr);
  }

  function randomFree() {
    var idx = (Math.random() * ptrs.length) >>> 0;
    var ptr = ptrs[idx];
    if (typeof ptr !== "number") throw Error();
    ptrs.splice(idx, 1);
    free(ptr);
  }

  // remember the smallest possible memory address
  var base = alloc(64, 0);
  console.log("base: " + base);
  try {
    reset();
  } catch (e) {
    free(base);
  }
  var currentMem = exports.memory.buffer.byteLength;
  console.log("mem initial: " + currentMem);

  function testMemChanged() {
    var actualMem = exports.memory.buffer.byteLength;
    if (actualMem > currentMem) {
      console.log("mem changed: " + currentMem + " -> " + actualMem);
      currentMem = actualMem;
    }
  }

  try {
    for (var j = 0; j < runs; ++j) {
      console.log("run " + (j + 1) + " (" + allocs + " allocations) ...");
      for (var i = 0; i < allocs; ++i) {
        var ptr = randomAlloc();
        testMemChanged();

        // immediately free every 4th
        if (!(i % 4)) preciseFree(ptr);

        // occasionally free random blocks
        else if (ptrs.length && Math.random() < 0.33) randomFree();

        // ^ sums up to clearing about half the blocks half-way
      }
      // free the rest, randomly
      while (ptrs.length) randomFree();

      try {
        reset();
        let ptr = alloc(64, 0);
        if (ptr !== base) throw Error("expected " + base + " but got " + ptr);
        reset();
      } catch (e) {
        // should now be possible to reuse the entire memory
        // just try a large portion of the memory here, for example because of
        // SL+1 for allocations in TLSF
        let size = ((exports.memory.buffer.byteLength - base) * 9 / 10) >>> 0;
        let ptr = alloc(size, 0);
        // if (fill) fill(ptr, 0xac, size);
        if (ptr !== base) throw Error("expected " + base + " but got " + ptr);
        free(ptr);
      }
      testMemChanged();
    }
  } finally {
    // mem(exports.memory, 0, 0x800);
  }
}

/* function mem(memory, offset, count) {
  if (!offset) offset = 0;
  if (!count) count = 1024;
  var mem = new Uint8Array(memory.buffer, offset);
  // var stackTop = new Uint32Array(memory.buffer, 4, 1)[0];
  var hex = [];
  for (var i = 0; i < count; ++i) {
    var o = (offset + i).toString(16);
    while (o.length < 4) o = "0" + o;
    if ((i & 15) === 0) {
      hex.push("\n" + o + ":");
    }
    var h = mem[i].toString(16);
    if (h.length < 2) h = "0" + h;
    hex.push(h);
  }
  console.log(hex.join(" ") + " ...");
} */

if (typeof module === "object" && typeof exports === "object") module.exports = runner;

'''
'''--- tests/allocators/stub/assembly/index.ts ---
export { heap };

'''
'''--- tests/allocators/stub/assembly/tsconfig.json ---
{
  "extends": "../../../../std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- tests/allocators/stub/package.json ---
{
  "private": true,
  "scripts": {
    "build": "npm run build:untouched && npm run build:optimized",
    "build:untouched": "node ../../../bin/asc assembly/index.ts -t untouched.wat -b untouched.wasm --runtime stub --sourceMap --measure",
    "build:optimized": "node ../../../bin/asc assembly/index.ts -t optimized.wat -b optimized.wasm --runtime stub --sourceMap --measure --noAssert --optimize"
  }
}

'''
'''--- tests/asconfig/complicated/asconfig.json ---
{
  "targets": {
    "release": {
      "optimize": true,
      "exportRuntime": true,
      "initialMemory": 30,
      "explicitStart": true,
      "measure": true,
      "pedantic": true,
      "sourceMap": true
    }
  },
  "options": {
    "initialMemory": 100,
    "enable": ["simd"]
  }
}

'''
'''--- tests/asconfig/complicated/assembly/index.ts ---
assert(ASC_OPTIMIZE_LEVEL == 3, "expected optimize level == 3");
assert(ASC_SHRINK_LEVEL == 0, "expected shrink level == 0");
assert(ASC_FEATURE_SIMD, "expected SIMD enabled");
let size = memory.size();
trace("size", 1, size);
assert(size == 30, "expected 30 got " + size.toString());

'''
'''--- tests/asconfig/complicated/package.json ---
{
  "private": true,
  "scripts": {
    "test": "node ../index.js"
  }
}

'''
'''--- tests/asconfig/cyclical/asconfig.json ---
{
  "extends": "./extends.json"
}

'''
'''--- tests/asconfig/cyclical/assembly/index.ts ---
assert(true);

'''
'''--- tests/asconfig/cyclical/extends.json ---
{
  "extends": "./asconfig.json"
}

'''
'''--- tests/asconfig/cyclical/package.json ---
{
  "private": true,
  "scripts": {
    "test": "node ../index.js"
  }
}

'''
'''--- tests/asconfig/entry-points/asconfig.json ---
{
  "entries": ["assembly/globals.ts"]
}

'''
'''--- tests/asconfig/entry-points/assembly/data.ts ---
export let forty_one = 41;

'''
'''--- tests/asconfig/entry-points/assembly/globalTwo.ts ---
// @ts-ignore
@global
  const ONE = 1;

assert(ONE);

'''
'''--- tests/asconfig/entry-points/assembly/globals.ts ---
import { forty_one } from "./data";
import "./globalTwo";

// @ts-ignore: decorator
@global function answerToLife(): i32 { return forty_one + ONE; }

assert(answerToLife());

'''
'''--- tests/asconfig/entry-points/assembly/index.ts ---
assert(answerToLife() == 42);

'''
'''--- tests/asconfig/entry-points/nested/asconfig.json ---
{
  "extends": "../asconfig.json"
}

'''
'''--- tests/asconfig/entry-points/nested/assembly/index.ts ---
assert(answerToLife() == 42);

'''
'''--- tests/asconfig/entry-points/nested/package.json ---
{
  "private": true,
  "scripts": {
    "test": "node ../../index.js"
  }
}

'''
'''--- tests/asconfig/entry-points/node-resolution/asconfig.json ---
{
  "extends": "entry-points/asconfig.json"
}

'''
'''--- tests/asconfig/entry-points/node-resolution/assembly/index.ts ---
assert(answerToLife() == 42);

'''
'''--- tests/asconfig/entry-points/node-resolution/node_modules/entry-points/asconfig.json ---
{
  "extends": "../../../asconfig.json"
}

'''
'''--- tests/asconfig/entry-points/node-resolution/package.json ---
{
  "private": true,
  "scripts": {
    "test": "node ../../index.js"
  }
}

'''
'''--- tests/asconfig/entry-points/package.json ---
{
  "private": true,
  "scripts": {
    "test": "node ../index.js && npm run test:nested && npm run test:node",
    "test:nested": "cd nested && npm run test",
    "test:node": "cd node-resolution && npm run test"
  }
}

'''
'''--- tests/asconfig/extends/asconfig.json ---
{
  "targets": {
    "release": {
      "shrinkLevel": 2
    }
  },
  "options": {
    "enable": ["simd"],
    "exportRuntime": true,
    "noEmit": false
  },
  "extends": "./extends.json"
}

'''
'''--- tests/asconfig/extends/assembly/index.ts ---
assert(ASC_OPTIMIZE_LEVEL == 1);
assert(ASC_SHRINK_LEVEL == 2);
assert(ASC_FEATURE_SIMD);

'''
'''--- tests/asconfig/extends/expected.json ---
{
  "options": {
    "exportRuntime": true,
    "noEmit": false,
    "noAssert": true,
    "enable": ["simd"]
  }
}

'''
'''--- tests/asconfig/extends/extends.json ---
{
  "targets": {
    "release": {
      "shrinkLevel": 1,
      "optimizeLevel": 1
    }
  },
  "options": {
    "disable": ["simd"],
    "noEmit": true,
    "noAssert": true
  }
}

'''
'''--- tests/asconfig/extends/package.json ---
{
  "private": true,
  "scripts": {
    "test": "node ../index.js --showConfig && node ../index.js"
  }
}

'''
'''--- tests/asconfig/index.js ---
const asc = require("../../cli/asc");
const loader = require("../../lib/loader/umd");
const args = process.argv.slice(2);
const path = require('path');
const fs = require("fs");

/** @type {string} */
let stderr;
/** @type {Uint8Array} */
let binary;
asc.main(["assembly/index.ts", "--outFile", "output.wasm", "--explicitStart", ...args], {
  writeFile(name, contents) {
    if (name === "output.wasm") {
      binary = contents;
    } else if (name !== "output.wasm.map") {
      throw Error("Unexpected output file: " + name);
    }
  },
  stderr: {
    write(s) {
      stderr = s;
    }
  }

}, (err) => {
  if (err) {
    console.error(err);
    console.error(stderr);
    process.exit(1);
  }

  const jsonPath = path.join(process.cwd(), "expected.json");
  if (fs.existsSync(jsonPath) && stderr) {
    const actualRes = JSON.parse(stderr);
    const actual = actualRes.options;
    const expected = require(jsonPath).options;
    let errored = false;
    for (let name of Object.getOwnPropertyNames(expected)) {
      if (actual[name] !== expected[name]) {
        // If object check just first level
        if (typeof actual[name] === 'object' && typeof expected[name] === 'object') {
          let error = false;
          for (let field of Object.getOwnPropertyNames(actual[name])) {
            if (actual[name][field] !== expected[name][field]) {
              error = true;
              break;
            }
          }
          if (!error) {
            continue;
          }
        }
        console.error(name + ": " + actual[name] + " expected " + expected[name]);
        errored = true;
      }
    }
    if (errored) {
      process.exit(1);
    }
    process.exit(0);
  }

  
  if (!binary) {
    console.error("No binary was generated for the asconfig test in " + process.cwd());
    process.exit(1);
  }

  const theModule = loader.instantiateSync(binary);

  try {
    theModule.exports._start();
  } catch (err) {
    console.error("The wasm module _start() function failed in " + process.cwd());
    console.error(err);
    process.exit(1);
  }
  return 0;
});

'''
'''--- tests/asconfig/package.json ---
{
  "private": true,
  "scripts": {
    "test": "npm run test:use-consts && npm run test:target && npm run test:entry-points && npm run test:complicated && npm run test:extends",
    "test:use-consts": "cd use-consts && npm run test",
    "test:entry-points": "cd entry-points && npm run test",
    "test:respect-inheritence": "cd respect-inheritence && npm run test",
    "test:target": "cd target && npm run test",
    "test:cyclical": "cd cyclical && npm run test",
    "test:complicated": "cd complicated && npm run test",
    "test:extends": "cd extends && npm run test"
  }
}

'''
'''--- tests/asconfig/respect-inheritence/asconfig.json ---
{
  "targets": {
    "release": {
      "optimizeLevel": 2,
      "enable": ["simd"]
    }
  },
  "options": {
    "optimizeLevel": 1,
    "disable": ["simd"]
  }
}

'''
'''--- tests/asconfig/respect-inheritence/assembly/index.ts ---
// --optimizeLevel 3
assert(ASC_OPTIMIZE_LEVEL == 3);
// enabled in target release which is default
assert(ASC_FEATURE_SIMD);
// disable: ["simd"] is set in asconfig under general options, it should be ignored

'''
'''--- tests/asconfig/respect-inheritence/package.json ---
{
  "private": true,
  "scripts": {
    "test": "node ../index.js --optimizeLevel 3"
  }
}

'''
'''--- tests/asconfig/target/asconfig.json ---
{
  "targets": {
    "release": {
      "noAssert": true,
      "exportRuntime": false
    },
    "debug": {
      "optimizeLevel": 3,
      "shrinkLevel": 1,
      "enable": ["simd"],      
      "debug": true
    }
  },
  "options": {
    "exportRuntime": true
  }
}

'''
'''--- tests/asconfig/target/assembly/index.ts ---
assert(ASC_OPTIMIZE_LEVEL == 3, "expected optimize level == 3");
assert(ASC_SHRINK_LEVEL == 1, "expected shrink level == 1");
assert(ASC_FEATURE_SIMD, "expected SIMD enabled");

'''
'''--- tests/asconfig/target/expected.json ---
{
  "options": {
    "exportRuntime": false,
    "noAssert": true
  }
}

'''
'''--- tests/asconfig/target/package.json ---
{
  "private": true,
  "scripts": {
    "test": "node ../index.js --target debug && node ../index.js --showConfig"
  }
}

'''
'''--- tests/asconfig/use-consts/asconfig.json ---
{
  "options": {
    "use": [
      "A=1",
      "B=2",
      "C=3"
    ]
  }
}

'''
'''--- tests/asconfig/use-consts/assembly/index.ts ---
assert(A == 1);
assert(B == 2);
assert(C == 3);

'''
'''--- tests/asconfig/use-consts/package.json ---
{
  "private": true,
  "scripts": {
    "test": "node ../index.js"
  }
}

'''
'''--- tests/binaryen/asmjs-math-builtins.js ---
var binaryen = require("binaryen");

var mod = new binaryen.Module();
var funcType = mod.addFunctionType("F", binaryen.f64, [ binaryen.f64 ]);

mod.addFunction("floor", funcType, [],
  mod.f64.floor(
    mod.get_local(0, binaryen.f64)
  )
);
mod.addExport("floor", "floor");

mod.addFunction("ceil", funcType, [],
  mod.f64.ceil(
    mod.get_local(0, binaryen.f64)
  )
);
mod.addExport("ceil", "ceil");

mod.addFunction("sqrt", funcType, [],
  mod.f64.sqrt(
    mod.get_local(0, binaryen.f64)
  )
);
mod.addExport("sqrt", "sqrt");

mod.addFunction("trunc", funcType, [],
  mod.f64.trunc(
    mod.get_local(0, binaryen.f64)
  )
);
mod.addExport("trunc", "trunc");

mod.addFunction("nearest", funcType, [],
  mod.f64.nearest(
    mod.get_local(0, binaryen.f64)
  )
);
mod.addExport("nearest", "nearest");

console.log(mod.emitText());
if (!mod.validate())
  console.log("-> does not validate");

console.log(mod.emitAsmjs());

'''
'''--- tests/binaryen/block-pre.js ---
var binaryen = require("binaryen");
var mod = binaryen.parseText(`
(module
  (global $ref (mut i32) (i32.const 1))
  (func $test
    (call $release
      (block (result i32)
        (global.get $ref)
        (global.set $ref
          (call $retain
            (i32.const 2) (; some-expression-that-might-conflict-with-a-temp ;)
          )
        )
      )
    )
  )
  (func $retain (param i32) (result i32)
    (local.get 0)
  )
  (func $release (param i32)
    (nop)
  )
)
`);
if (!mod.validate()) console.log(":-(");
else console.log(mod.emitText());

'''
'''--- tests/binaryen/block-stack.js ---
var binaryen = require("binaryen");

// "non-final block elements returning a value must be drop()ed"
// "0 == 0: block with value must not have last element that is none, on"

var mod = new binaryen.Module();

var funcType = mod.addFunctionType("i", binaryen.i32, []);
var func = mod.addFunction("test", funcType, [ binaryen.i32 ],
  mod.block("", [
    mod.teeLocal(0, mod.i32.const(1)),
    mod.nop()
  ], binaryen.i32)
);
mod.addExport("test", func);

console.log(mod.emitText());
if (!mod.validate())
  console.log("-> does not validate");

'''
'''--- tests/binaryen/break-value.js ---
var binaryen = require("binaryen");

var mod = new binaryen.Module();
var ftype = mod.addFunctionType("ii", binaryen.i32, [ binaryen.i32 ]);
mod.addFunction("test", ftype, [],
  mod.block("label", [
    mod.drop( // "br_if returns the value too"
      mod.break("label",
        // condition: $0 == 1
        mod.i32.eq(
          mod.getLocal(0, binaryen.i32),
          mod.i32.const(1)
        ),
        // value: 1
        mod.i32.const(1)
      )
    ),
    // push: 0
    mod.i32.const(0)
  ], binaryen.i32)
);
console.log(mod.emitText());

mod.validate();

'''
'''--- tests/binaryen/const-expr.js ---
var binaryen = require("binaryen");

var mod = new binaryen.Module();

var addType = mod.addFunctionType("iii", binaryen.i32, [ binaryen.i32, binaryen.i32 ]);
mod.addFunction("add", addType, [],
  mod.i32.add(
    mod.get_local(0, binaryen.i32),
    mod.get_local(1, binaryen.i32)
  )
);
mod.addFunctionExport("add", "add");

var testType = mod.addFunctionType("i", binaryen.i32, []);
mod.addFunction("test", testType, [],
  mod.call("add", [
    mod.i32.const(1),
    mod.i32.const(2)
  ], binaryen.i32)
);
mod.addFunctionExport("test", "test");

binaryen.setOptimizeLevel(4);
binaryen.setShrinkLevel(0);
binaryen.setDebugInfo(false);
mod.runPasses(["precompute"]);
if (!mod.validate())
  console.log("-> does not validate");
console.log(mod.emitText());

'''
'''--- tests/binaryen/const-global.js ---
var binaryen = require("binaryen");

var mod = new binaryen.Module();

mod.addGlobal("testGlobal", binaryen.i32, false, mod.i32.const(2));
var funcType = mod.addFunctionType("i", binaryen.i32, []);
mod.addFunction("test", funcType, [],
  mod.get_global("testGlobal", binaryen.i32)
);
mod.addFunctionExport("test", "test");

binaryen.setOptimizeLevel(4);
binaryen.setShrinkLevel(0);
binaryen.setDebugInfo(false);
mod.optimize();
if (!mod.validate())
  console.log("-> does not validate");
console.log(mod.emitText());

'''
'''--- tests/binaryen/const-local.js ---
var binaryen = require("binaryen");

var mod = new binaryen.Module();

var funcType = mod.addFunctionType("i", binaryen.i32, [ binaryen.i32 ]);
mod.addFunction("test", funcType, [], mod.block("", [
  mod.setLocal(0, mod.i32.const(2)),
  mod.getLocal(0, binaryen.i32)
], binaryen.i32));
mod.addFunctionExport("test", "test");

binaryen.setOptimizeLevel(4);
binaryen.setShrinkLevel(0);
binaryen.setDebugInfo(false);
mod.optimize();
if (!mod.validate())
  console.log("-> does not validate");
console.log(mod.emitText());

'''
'''--- tests/binaryen/constant-indirect-arg.js ---
var binaryen = require("binaryen");

var mod = new binaryen.Module();

var ftype_v = mod.addFunctionType("v", binaryen.none, []);
var ftype_vi = mod.addFunctionType("vi", binaryen.none, [ binaryen.i32 ]);

mod.addFunction("callee-2", ftype_v, [], mod.block(null, [
]));
mod.addFunction("callee-1", ftype_vi, [], mod.block(null, [
  mod.call_indirect(mod.getLocal(0, binaryen.i32), [], "v"),
]));
mod.setFunctionTable(2, 2, [ "callee-1", "callee-2" ]);

mod.addFunction("caller", ftype_vi, [ binaryen.i32 ], mod.block(null, [
  mod.call_indirect(mod.getLocal(0, binaryen.i32), [ mod.i32.const(1) ], "vi"),
]));
mod.addFunctionExport("caller", "main");

binaryen.setOptimizeLevel(4);
binaryen.setShrinkLevel(0);
binaryen.setDebugInfo(false);
mod.optimize();
if (!mod.validate())
  console.log("-> does not validate");
console.log(mod.emitText());

'''
'''--- tests/binaryen/constant-indirect.js ---
var binaryen = require("binaryen");

var mod = new binaryen.Module();

var ftype = mod.addFunctionType("v", binaryen.none, []);

mod.addFunction("callee", ftype, [], mod.block(null, [
]));
mod.setFunctionTable(1, 1, [ "callee" ]);

mod.addFunction("caller", ftype, [], mod.block(null, [
  mod.call_indirect(mod.i32.const(0), [], "v"),
]));
mod.addFunctionExport("caller", "main");

binaryen.setOptimizeLevel(4);
binaryen.setShrinkLevel(0);
binaryen.setDebugInfo(false);
mod.optimize();
if (!mod.validate())
  console.log("-> does not validate");
console.log(mod.emitText());

'''
'''--- tests/binaryen/get_global-missing.js ---
var binaryen = require("binaryen");

var mod = new binaryen.Module();
var funcType = mod.addFunctionType("v", binaryen.void, []);
var func = mod.addFunction("test", funcType, [],
  mod.block("", [
    mod.drop(
      mod.getGlobal("missing", binaryen.i32)
    )
  ])
);
mod.addFunctionExport("test", "test", func);

console.log(mod.emitText());
if (mod.validate())
  console.log("-> validates");
mod.emitBinary(); // -> Assertion failed: mappedGlobals.count(name), at: binaryen/src/wasm/wasm-binary.cpp,355,getGlobalIndex at Error

'''
'''--- tests/binaryen/get_local-missing.js ---
var binaryen = require("binaryen");

var mod = new binaryen.Module();
var funcType = mod.addFunctionType("v", binaryen.void, []);
var func = mod.addFunction("test", funcType, [],
  mod.block("", [
    mod.drop(
      mod.getLocal(0, binaryen.i32)
    )
  ])
);
mod.addFunctionExport("test", "test", func);

console.log(mod.emitText());
if (mod.validate()) {
  console.log("-> validates");
  var binary = mod.emitBinary();
  new WebAssembly.Module(binary); // CompileError: WebAssembly.Module(): Compiling wasm function #0:test failed: invalid local index: 0 @+34
}

'''
'''--- tests/binaryen/i64-binary-result.js ---
var binaryen = require("binaryen");

// "non-final block elements returning a value must be drop()ed"
// "0 == 0: block with value must not have last element that is none, on"

var mod = new binaryen.Module();

var funcType = mod.addFunctionType("I", binaryen.void, [ binaryen.i64 ]);
var func = mod.addFunction("test", funcType, [ binaryen.i32 ],
  mod.block("", [
    mod.setLocal(1, mod.i64.eq(mod.i64.const(0, 0), mod.getLocal(0, binaryen.i64)))
  ])
);
mod.addExport("test", func);

console.log(mod.emitText());
if (mod.validate())
  console.log("-> ok: i64.eq returns i32");

'''
'''--- tests/binaryen/inline-export.js ---
var binaryen = require("binaryen");

var mod = new binaryen.Module();
var funcType = mod.addFunctionType("iii", binaryen.i32, [ binaryen.i32, binaryen.i32 ]);

mod.addFunction("exported_add", funcType, [],
  mod.i32.add(
    mod.get_local(0, binaryen.i32),
    mod.get_local(1, binaryen.i32)
  )
);
mod.addFunctionExport("exported_add", "add");

mod.addFunction("internal_sub", funcType, [],
  mod.i32.sub(
    mod.get_local(0, binaryen.i32),
    mod.get_local(1, binaryen.i32)
  )
);

mod.addFunction("test", funcType, [],
  mod.i32.add(
    mod.call("exported_add", [ // should become inlined but doesn't
      mod.get_local(0, binaryen.i32),
      mod.get_local(1, binaryen.i32)
    ], binaryen.i32),
    mod.call("internal_sub", [ // just like this one becomes inlined
      mod.get_local(0, binaryen.i32),
      mod.get_local(1, binaryen.i32)
    ], binaryen.i32)
  )
);
mod.addFunctionExport("test", "test");

// binaryen.setOptimizeLevel(3);
// binaryen.setShrinkLevel(0);
mod.optimize();
if (!mod.validate()) throw Error();
console.log(mod.emitText());

'''
'''--- tests/binaryen/libm.html ---
<script src="https://cdn.jsdelivr.net/gh/AssemblyScript/binaryen.js/index.js"></script>
<script>
var libm;
// fetch("../compiler/std/libm.optimized.wat") // doesn't work: too large?
// .then(str => Binaryen.parseText(str))
// .then(module => module.emitBinary())
fetch("libm.wasm")
.then(res => res.arrayBuffer())
.then(buf => WebAssembly.instantiate(buf, {}))
.then(module => {
  libm = module.instance.exports;
  Object.keys(libm).forEach(key => {
    var val = libm[key];
    if (typeof val === "function") {
      console.log("libm." + key + "(...)");
    } else {
      console.log("libm." + key + " = " + val);
    }
  });
})
.catch(err => { throw err; });
</script>

'''
'''--- tests/binaryen/multi-value.js ---
var binaryen = require("binaryen");

var mod = new binaryen.Module();
var ii = binaryen.createType([ binaryen.i32, binaryen.i32 ]);
mod.addFunction("test", ii, ii, [],
  mod.unreachable()
);
mod.addExport("test", "test");

console.log(mod.emitText());
if (!mod.validate())
  console.log("-> does not validate");

mod.optimize();
console.log(mod.emitText());

'''
'''--- tests/binaryen/optimize-if-eqz.js ---
var binaryen = require("binaryen");

var mod = new binaryen.Module();
var funcType = mod.addFunctionType("i", binaryen.i32, [ binaryen.i32 ]);
mod.addFunction("test", funcType, [],
  mod.if(
    mod.i32.eqz(mod.getLocal(0, binaryen.i32)),
    mod.i32.const(0),
    mod.getLocal(0, binaryen.i32)
  )
);
mod.addExport("test", "test");

console.log(mod.emitText());
if (!mod.validate())
  console.log("-> does not validate");

mod.optimize();
console.log(mod.emitText());

'''
'''--- tests/binaryen/reloop.js ---
var binaryen = require("binaryen");
binaryen.setOptimizeLevel(3);
binaryen.setShrinkLevel(0);

function usingBranches() {
  var module = new binaryen.Module();
  var rl = new binaryen.Relooper(module);
  var entry = rl.addBlock(module.nop());

  for (let i = 0; i < 10; ++i) {
    rl.addBranch(entry,
      rl.addBlock(
        module.return(
          module.call("other", [ module.i32.const(i) ], binaryen.none, binaryen.i32)
        )
      ),
      module.i32.eq(
        module.local.get(0, binaryen.i32),
        module.i32.const(i)
      )
    );
  }
  rl.addBranch(entry,
    rl.addBlock(
      module.unreachable()
    )
  );

  module.addFunction("test", binaryen.i32, binaryen.i32, [ binaryen.i32 ], rl.renderAndDispose(entry, 1));
  module.addFunctionImport("other", "env", "other", binaryen.i32, binaryen.i32);
  module.addFunctionExport("test", "test");

  console.log("=== unoptimized ===");
  console.log(module.emitText());
  module.optimize();
  console.log("=== optimized ===");
  console.log(module.emitText());
}
usingBranches();

/* function usingSwitch() {
  var module = new binaryen.Module();
  var rl = new binaryen.Relooper(module);
  var entry = rl.addBlockWithSwitch(module.nop(), module.local.get(0, binaryen.i32));
  
  for (let i = 0; i < 10; ++i) {
    rl.addBranchForSwitch(entry,
      rl.addBlock(
        module.return(
          module.call("other", [ module.i32.const(i) ], binaryen.none, binaryen.i32)
        )
      ),
      [ i ]
    );
  }
  rl.addBranchForSwitch(entry,
    rl.addBlock(
      module.unreachable()
    ),
    []
  );
  
  module.addFunction("test", binaryen.i32, binaryen.i32, [ binaryen.i32 ], rl.renderAndDispose(entry, 1));
  module.addFunctionImport("other", "env", "other", binaryen.none, binaryen.i32);
  module.addFunctionExport("test", "test");
  
  console.log(module.emitText());
  module.optimize();
  console.log(module.emitText());
}
usingSwitch(); */

'''
'''--- tests/binaryen/return-flatten.js ---
var binaryen = require("binaryen");

var module = new binaryen.Module();
module.addFunction("nothing", binaryen.none, binaryen.none, [], module.nop());
module.addFunction("test", binaryen.none, binaryen.none, [],
  module.return(
    module.call("nothing", [], binaryen.none)
  )
);
module.addExport("test", "test");

console.log(module.emitText());
if (!module.validate())
  console.log("-> does not validate");

binaryen.setOptimizeLevel(4);
module.runPasses(["flatten"]);
module.optimize(); // Fatal: IR must be flat: run --flatten beforehand
console.log(module.emitText());

'''
'''--- tests/binaryen/set_global-immutable.js ---
var binaryen = require("binaryen");

// "It is a validation error for a set_global to index an immutable global variable."

var mod = new binaryen.Module();
mod.addGlobal("a", binaryen.i32, false, mod.i32.const(0));

var funcType = mod.addFunctionType("v", binaryen.none, []);
var func = mod.addFunction("start", funcType, [], mod.block("", [
  mod.setGlobal("a", mod.i32.const(1))
]));
mod.setStart(func);

console.log(mod.emitText());
if (mod.validate())
  console.log("-> validates");

'''
'''--- tests/binaryen/unreachable-loop.js ---
var binaryen = require("binaryen");

var mod = new binaryen.Module();
var funcType = mod.addFunctionType("v", binaryen.none, []);
mod.addFunction("0", funcType, [],
  mod.drop(
    mod.block("label$1", [
      mod.loop("label$2",
        mod.unreachable()
      )
    ], binaryen.i32)
  )
);
mod.addExport("0", "0");

console.log(mod.emitText());
if (!mod.validate())
  console.log("-> does not validate");

var bin = mod.emitBinary();
require("fs").writeFileSync(__dirname + "/unreachable-loop.wasm", bin);
var mod2 = binaryen.readBinary(bin);
console.log(mod2.emitText());

'''
'''--- tests/binaryen/unreachable-spam.js ---
var binaryen = require("binaryen");

var mod = new binaryen.Module();
var funcType = mod.addFunctionType("ii", binaryen.i32, [ binaryen.i32 ]);
mod.addFunction("0", funcType, [],
  mod.block(null, [
    mod.loop("continue",
      mod.block(null, [
        mod.if(
          mod.local.get(0, binaryen.i32),
          mod.return(mod.i32.const(1)),
          mod.return(mod.i32.const(2))
        ),
        mod.unreachable()
      ])
    ),
    mod.unreachable()
  ], binaryen.i32)
);
mod.addExport("0", "0");

if (!mod.validate())
  console.log("-> does not validate");
console.log(mod.emitText());
console.log(mod.emitStackIR(/* true */)); // optimize-stack-ir fixes this

'''
'''--- tests/browser-asc.js ---
const asc = require("../dist/asc.js");

if (typeof asc.definitionFiles.assembly !== "string") throw Error("missing bundled assembly.d.ts");
if (typeof asc.definitionFiles.portable !== "string") throw Error("missing bundled portable.d.ts");

const stdout = asc.createMemoryStream();
const stderr = asc.createMemoryStream();
const files = { "module.ts": `export function test(): void {}` };

console.log("# asc --version");

asc.main([
  "--version"
], {
  stdout: stdout,
  stderr: stderr
}, err => {
  console.log(">>> STDOUT >>>");
  process.stdout.write(stdout.toString());
  stdout.reset();
  console.log(">>> STDERR >>>");
  process.stdout.write(stderr.toString());
  stderr.reset();
});

console.log("\n# asc --help");

asc.main([
  "--help"
], {
  stdout: stdout,
  stderr: stderr
}, err => {
  console.log(">>> STDOUT >>>");
  process.stdout.write(stdout.toString());
  stdout.reset();
  console.log(">>> STDERR >>>");
  process.stdout.write(stderr.toString());
  stderr.reset();
});

console.log("\n# asc module.ts --textFile");

asc.main([
  "module.ts",
  "--textFile"
], {
  stdout: stdout,
  stderr: stderr,
  readFile: (name, baseDir) => {
    console.log("readFile: " + name + ", baseDir=" + baseDir);
    if (Object.prototype.hasOwnProperty.call(files, name)) return files[name];
    return null;
  },
  writeFile: (name, data, baseDir) => {
    console.log("writeFile: " + name + ", baseDir=" + baseDir);
  },
  listFiles: (dirname, baseDir) => {
    console.log("listFiles: " + dirname + ", baseDir=" + baseDir);
    return [];
  }
}, err => {
  if (err) {
    console.log(">>> THROWN >>>");
    console.log(err);
  }
});

console.log(">>> STDOUT >>>");
process.stdout.write(stdout.toString());
console.log(">>> STDERR >>>");
process.stdout.write(stderr.toString());

console.log("\n# asc.compileString");

const output = asc.compileString(`export function test(): void {}`, { optimizeLevel: 3, exportTable: true, measure: true });
console.log(">>> .stdout >>>");
process.stdout.write(output.stdout.toString());
console.log(">>> .stderr >>>");
process.stdout.write(output.stderr.toString());
console.log(">>> .text >>>");
process.stdout.write(output.text);
console.log(">>> .binary >>> " + output.binary.length + " bytes");

'''
'''--- tests/cli/options.js ---
const assert = require("assert");
const optionsUtil = require("../../cli/util/options");

const config = {
  "enable": {
    "type": "S",
    "mutuallyExclusive": "disable"
  },
  "disable": {
    "type": "S",
    "mutuallyExclusive": "enable"
  },
  "other": {
    "type": "S",
    "default": ["x"]
  }
};

// Present in both should concat
var merged = optionsUtil.merge(config, { enable: ["a"] }, { enable: ["b"] });
assert.deepStrictEqual(merged.enable, ["a", "b"]);

merged = optionsUtil.merge(config, { enable: ["a"] }, { enable: ["a", "b"] });
assert.deepStrictEqual(merged.enable, ["a", "b"]);

// Mutually exclusive should exclude
merged = optionsUtil.merge(config, { enable: ["a", "b"] }, { disable: ["a", "c"] });
assert.deepStrictEqual(merged.enable, ["a", "b"]);
assert.deepStrictEqual(merged.disable, ["c"]);

merged = optionsUtil.merge(config, { disable: ["a", "b"] }, { enable: ["a", "c"] });
assert.deepStrictEqual(merged.enable, ["c"]);
assert.deepStrictEqual(merged.disable, ["a", "b"]);

// Populating defaults should work after the fact
merged = optionsUtil.addDefaults(config, {});
assert.deepStrictEqual(merged.other, ["x"]);

merged = optionsUtil.addDefaults(config, { other: ["y"] });
assert.deepStrictEqual(merged.other, ["y"]);

// Complete usage test
var result = optionsUtil.parse(["--enable", "a", "--disable", "b"], config, false);
merged = optionsUtil.merge(config, result.options, { enable: ["b", "c"] });
merged = optionsUtil.merge(config, merged, { disable: ["a", "d"] });
optionsUtil.addDefaults(config, merged);
assert.deepStrictEqual(merged.enable, ["a", "c"]);
assert.deepStrictEqual(merged.disable, ["b", "d"]);
assert.deepStrictEqual(merged.other, ["x"]);

'''
'''--- tests/compiler.js ---
const startTime = Date.now();
const fs  = require("fs");
const path = require("path");
const os = require("os");
const v8 = require("v8");
const WASI = require("wasi").WASI;
const glob = require("glob");
const colorsUtil = require("../cli/util/colors");
const optionsUtil = require("../cli/util/options");
const diff = require("./util/diff");
const asc = require("../cli/asc.js");
const { Rtrace } = require("../lib/rtrace/umd");
const cluster = require("cluster");
const coreCount = require("physical-cpu-count");

const config = {
  "create": {
    "description": [
      "Recreates the fixture for the specified test(s)",
      "or all the fixtures if no specific test is given."
    ],
    "type": "b"
  },
  "createBinary": {
    "description": [
      "Also creates the respective .wasm binaries."
    ],
    "type": "b"
  },
  "noDiff": {
    "description": [
      "Disables output of detailed fixture differences."
    ],
    "type": "b"
  },
  "rtraceVerbose": {
    "description": [
      "Enables verbose rtrace output."
    ]
  },
  "parallel": {
    "description": [
      "Runs tests in parallel."
    ]
  },
  "help": {
    "description": "Prints this message and exits.",
    "type": "b",
    "alias": "h"
  }
};
const opts = optionsUtil.parse(process.argv.slice(2), config);
const args = opts.options;
const argv = opts.arguments;

if (args.help) {
  console.log([
    colorsUtil.white("SYNTAX"),
    "  " + colorsUtil.cyan("npm run test:compiler --") + " [test1, test2 ...] [options]",
    "",
    colorsUtil.white("OPTIONS"),
    optionsUtil.help(config)
  ].join(os.EOL) + os.EOL);
  process.exit(0);
}

const features = process.env.ASC_FEATURES ? process.env.ASC_FEATURES.split(",") : [];
const featuresConfig = require("./features.json");

var failedTests = new Set();
var failedMessages = new Map();
var skippedTests = new Set();
var skippedMessages = new Map();

const basedir = path.join(__dirname, "compiler");

// Gets a list of all relevant tests
function getTests() {
  var tests =  glob.sync("**/!(_*).ts", { cwd: basedir }).map(name => name.replace(/\.ts$/, ""));
  if (argv.length) { // run matching tests only
    tests = tests.filter(filename => argv.indexOf(filename.replace(/\.ts$/, "")) >= 0);
    if (!tests.length) {
      console.log(colorsUtil.red("FAILURE: ") + colorsUtil.white("No matching tests: " + argv.join(" ") + "\n"));
      process.exit(1);
    }
  }
  return tests;
}

// Starts a new section within a test
function section(title) {
  var start = process.hrtime();
  console.log("- " + title);
  return {
    title,
    end: function(code) {
      const times = process.hrtime(start);
      const time = asc.formatTime(times[0] * 1e9 + times[1]);
      switch (code) {
        case SUCCESS: console.log("  " + colorsUtil.green ("SUCCESS") + " (" + time + ")\n"); break;
        default: console.log("  " + colorsUtil.red("FAILURE") + " (" + time + ")\n"); break;
        case SKIPPED: console.log("  " + colorsUtil.yellow("SKIPPED") + " (" + time + ")\n"); break;
      }
    }
  };
}
const SUCCESS = 0;
const FAILURE = 1;
const SKIPPED = 2;

// Runs a single test
function runTest(basename) {
  console.log(colorsUtil.white("# compiler/" + basename) + "\n");

  const configPath = path.join(basedir, basename + ".json");
  const config = fs.existsSync(configPath)
    ? require(configPath)
    : {};

  const stdout = asc.createMemoryStream();
  const stderr = asc.createMemoryStream(chunk => process.stderr.write(chunk.toString().replace(/^(?!$)/mg, "  ")));
  stderr.isTTY = true;

  var asc_flags = [];
  var asc_rtrace = !!config.asc_rtrace;
  var v8_flags = "";
  var v8_no_flags = "";
  var missing_features = [];
  if (config.features) {
    config.features.forEach(feature => {
      if (!features.includes(feature) && !features.includes("*")) {
        missing_features.push(feature);
        return;
      }
      var featureConfig = featuresConfig[feature];
      if (featureConfig.asc_flags) {
        featureConfig.asc_flags.forEach(flag => {
          Array.prototype.push.apply(asc_flags, flag.split(" "));
        });
      }
      if (featureConfig.v8_flags) {
        featureConfig.v8_flags.forEach(flag => {
          if (v8_flags) v8_flags += " ";
          v8_flags += flag;
          if (v8_no_flags) v8_no_flags += " ";
          v8_no_flags += "--no-" + flag.substring(2);
        });
        v8.setFlagsFromString(v8_flags);
      }
    });
    if (missing_features.length) {
      console.log("- " + colorsUtil.yellow("feature SKIPPED") + " (" + missing_features.join(", ") + ")\n");
      skippedTests.add(basename);
      skippedMessages.set(basename, "feature not enabled");
      if (cluster.isWorker) process.send({ cmd: "skipped", message: skippedMessages.get(basename) });
      return;
    }
  }
  if (config.asc_flags) {
    config.asc_flags.forEach(flag => {
      Array.prototype.push.apply(asc_flags, flag.split(" "));
    });
  }

  var failed = false;

  // Build untouched
  var cmd = [
    basename + ".ts",
    "--baseDir", basedir,
    "--debug",
    "--textFile" // -> stdout
  ];
  if (asc_flags)
    Array.prototype.push.apply(cmd, asc_flags);
  cmd.push("--binaryFile", basename + ".untouched.wasm");
  const compileUntouched = section("compile untouched");
  asc.main(cmd, {
    stdout: stdout,
    stderr: stderr
  }, err => {
    let expectStderr = config.stderr;
    if (err) {
      stderr.write("---\n");
      stderr.write(err.stack);
      stderr.write("\n---\n");
      if (expectStderr) {
        compileUntouched.end(SKIPPED);
      } else {
        compileUntouched.end(FAILURE);
      }
    } else {
      compileUntouched.end(SUCCESS);
    }

    // check expected stderr patterns in order
    if (expectStderr) {
      const compareStderr = section("compare stderr");
      const stderrString = stderr.toString();
      if (typeof expectStderr === "string") expectStderr = [ expectStderr ];
      let lastIndex = 0;
      expectStderr.forEach((substr, i) => {
        var index = stderrString.indexOf(substr, lastIndex);
        if (index < 0) {
          console.log("  missing pattern #" + (i + 1) + " '" + substr + "' in stderr at " + lastIndex + "+.");
          failed = true;
        } else {
          lastIndex = index + substr.length;
        }
      });
      if (failed) {
        failedTests.add(basename);
        failedMessages.set(basename, "stderr mismatch");
        compareStderr.end(FAILURE);
      } else {
        compareStderr.end(SUCCESS);
      }
      return 1;
    }

    const compareFixture = section("compare fixture");
    var actual = stdout.toString().replace(/\r\n/g, "\n");
    if (args.create) {
      fs.writeFileSync(path.join(basedir, basename + ".untouched.wat"), actual, { encoding: "utf8" });
      console.log("  " + colorsUtil.yellow("Created fixture"));
      compareFixture.end(SKIPPED);
    } else {
      let expected = fs.readFileSync(path.join(basedir, basename + ".untouched.wat"), { encoding: "utf8" }).replace(/\r\n/g, "\n");
      if (args.noDiff) {
        if (expected != actual) {
          failed = true;
          failedTests.add(basename);
          compareFixture.end(FAILURE);
        } else {
          compareFixture.end(SUCCESS);
        }
      } else {
        let diffs = diff(basename + ".untouched.wat", expected, actual);
        if (diffs !== null) {
          console.log(diffs);
          failed = true;
          failedTests.add(basename);
          compareFixture.end(FAILURE);
        } else {
          compareFixture.end(SUCCESS);
        }
      }
    }

    stdout.length = 0;
    stderr.length = 0;

    // Build optimized
    var cmd = [
      basename + ".ts",
      "--baseDir", basedir,
      "--binaryFile", // -> stdout
      "-O"
    ];
    if (asc_flags)
      Array.prototype.push.apply(cmd, asc_flags);
    if (args.create)
      cmd.push("--textFile", basename + ".optimized.wat");
    const compileOptimized = section("compile optimized");
    asc.main(cmd, {
      stdout: stdout,
      stderr: stderr
    }, err => {
      if (err) {
        stderr.write("---\n");
        stderr.write(err.stack);
        stderr.write("\n---\n");
        failed = true;
        failedMessages.set(basename, err.message);
        failedTests.add(basename);
        compileOptimized.end(FAILURE);
        return 1;
      } else {
        compileOptimized.end(SUCCESS);
      }
      let untouchedBuffer = fs.readFileSync(path.join(basedir, basename + ".untouched.wasm"));
      let optimizedBuffer = stdout.toBuffer();
      const gluePath = path.join(basedir, basename + ".js");
      var glue = {};
      if (fs.existsSync(gluePath)) glue = require(gluePath);

      const instantiateUntouched = section("instantiate untouched");
      if (!config.skipInstantiate) {
        if (!testInstantiate(basename, untouchedBuffer, glue, stderr, config.asc_wasi)) {
          failed = true;
          failedTests.add(basename);
          instantiateUntouched.end(FAILURE);
        } else {
          instantiateUntouched.end(SUCCESS);
          const instantiateOptimized = section("instantiate optimized");
          if (!testInstantiate(basename, optimizedBuffer, glue, stderr, config.asc_wasi)) {
            failed = true;
            failedTests.add(basename);
            instantiateOptimized.end(FAILURE);
          } else {
            instantiateOptimized.end(SUCCESS);
          }
        }
      } else {
        instantiateUntouched.end(SKIPPED);
      }

      if (!asc_rtrace) return;

      stdout.length = 0;
      stderr.length = 0;

      // Build rtraced
      var cmd = [
        basename + ".ts",
        "--baseDir", basedir,
        "--binaryFile", // -> stdout
        "--debug",
        "--use", "ASC_RTRACE=1",
        "--explicitStart",
        // "--runPasses", "instrument-memory"
      ];
      if (asc_flags) {
        Array.prototype.push.apply(cmd, asc_flags);
      }
      const compileRtraced = section("compile rtraced");
      asc.main(cmd, {
        stdout: stdout,
        stderr: stderr
      }, err => {
        if (err) {
          stderr.write("---\n");
          stderr.write(err.stack);
          stderr.write("\n---\n");
          failed = true;
          failedMessages.set(basename, err.message);
          failedTests.add(basename);
          compileRtraced.end(FAILURE);
          return 1;
        } else {
          compileRtraced.end(SUCCESS);
        }
        let rtracedBuffer = stdout.toBuffer();
        const instantiateRtrace = section("instantiate rtrace");
        v8.setFlagsFromString("--experimental-wasm-bigint");
        if (!testInstantiate(basename, rtracedBuffer, glue, stderr, config.asc_wasi)) {
          failed = true;
          failedTests.add(basename);
          instantiateRtrace.end(FAILURE);
        } else {
          instantiateRtrace.end(SUCCESS);
        }
        v8.setFlagsFromString("--no-experimental-wasm-bigint");
      });
    });
    if (failed) return 1;
  });
  if (v8_no_flags) v8.setFlagsFromString(v8_no_flags);
  if (!args.createBinary) fs.unlink(path.join(basedir, basename + ".untouched.wasm"), err => { /* nop */ });
  if (cluster.isWorker) process.send({ cmd: "done", failed: failed, message: failedMessages.get(basename) });
}

// Tests if instantiation of a module succeeds
function testInstantiate(basename, binaryBuffer, glue, stderr, wasiOptions) {
  var failed = false;
  try {
    let memory = new WebAssembly.Memory({ initial: 10 });
    let exports = {};

    function getString(ptr) {
      const RUNTIME_HEADER_SIZE = 16;
      if (!ptr) return "null";
      var U32 = new Uint32Array(exports.memory ? exports.memory.buffer : memory.buffer);
      var U16 = new Uint16Array(exports.memory ? exports.memory.buffer : memory.buffer);
      var len16 = U32[(ptr - RUNTIME_HEADER_SIZE + 12) >>> 2] >>> 1;
      var ptr16 = ptr >>> 1;
      return String.fromCharCode.apply(String, U16.subarray(ptr16, ptr16 + len16));
    }

    let rtrace = new Rtrace({
      onerror(err, info) {
        console.log("  ERROR: " + err.stack);
        failed = true;
        failedMessages.set(basename, err.message);
      },
      oninfo(msg, info) {
        if (!args.rtraceVerbose) return;
        console.log("  " + msg);
      },
      getMemory() {
        return instance.exports.memory;
      }
    });

    var imports = rtrace.install({
      env: {
        memory,
        abort: function(msg, file, line, column) {
          console.log(colorsUtil.red("  abort: " + getString(msg) + " in " + getString(file) + "(" + line + ":" + column + ")"));
        },
        trace: function(msg, n) {
          console.log("  trace: " + getString(msg) + (n ? " " : "") + Array.prototype.slice.call(arguments, 2, 2 + n).join(", "));
        },
        seed: function() {
          return 0xA5534817; // make tests deterministic
        },
        visit: function() {
          // override in tests
        }
      },
      Math,
      Date,
      Reflect
    });
    if (glue.preInstantiate) {
      console.log("  [call preInstantiate]");
      glue.preInstantiate(imports, exports);
    }
    var wasi = null;
    if (wasiOptions) {
      wasi = new WASI(wasiOptions);
      imports.wasi_snapshot_preview1 = wasi.wasiImport;
    }
    var instance = new WebAssembly.Instance(new WebAssembly.Module(binaryBuffer), imports);
    Object.setPrototypeOf(exports, instance.exports);
    if (glue.postInstantiate) {
      console.log("  [call postInstantiate]");
      glue.postInstantiate(instance);
    }
    if (wasi) {
      console.log("  [wasi start]");
      let code = wasi.start(instance);
      console.log("  [wasi exit] code=" + code);
    } else if (exports._start) {
      console.log("  [call start]");
      exports._start();
    }
    if (glue.postStart) {
      console.log("  [call postStart]");
      glue.postStart(instance);
    }
    let leakCount = rtrace.check();
    if (leakCount) {
      let msg = "memory leak detected: " + leakCount + " leaking";
      failed = true;
      failedMessages.set(basename, msg);
      console.log("  " + msg);
    }
    if (!failed) {
      if (rtrace.active) {
        console.log("  " +
          rtrace.allocCount + " allocs, " +
          rtrace.freeCount + " frees, " +
          rtrace.resizeCount + " resizes, " +
          rtrace.moveCount + " moves"
        );
      }
      return true;
    }
  } catch (e) {
    stderr.write("---\n");
    stderr.write(e.stack);
    stderr.write("\n---\n");
    failed = true;
    failedMessages.set(basename, e.message);
  }
  return false;
}

// Evaluates the overall test result
function evaluateResult() {
  if (skippedTests.size) {
    console.log(colorsUtil.yellow("WARNING: ") + colorsUtil.white(skippedTests.size + " compiler tests have been skipped:\n"));
    skippedTests.forEach(name => {
      var message = skippedMessages.has(name) ? colorsUtil.gray("[" + skippedMessages.get(name) + "]") : "";
      console.log("  " + name + " " + message);
    });
    console.log();
  }
  if (failedTests.size) {
    process.exitCode = 1;
    console.log(colorsUtil.red("FAILURE: ") + colorsUtil.white(failedTests.size + " compiler tests had failures:\n"));
    failedTests.forEach(name => {
      var message = failedMessages.has(name) ? colorsUtil.gray("[" + failedMessages.get(name) + "]") : "";
      console.log("  " + name + " " + message);
    });
    console.log();
  }
  console.log("Time: " + (Date.now() - startTime) + " ms\n");
  if (!process.exitCode) {
    console.log("[ " + colorsUtil.white("SUCCESS") + " ]");
  }
}

asc.ready.then(() => {

  // Run tests in parallel if requested
  if (args.parallel && coreCount > 1) {
    if (cluster.isWorker) {
      colorsUtil.supported = true;
      process.on("message", msg => {
        if (msg.cmd != "run") throw Error("invalid command: " + msg.cmd);
        try {
          runTest(msg.test);
        } catch (e) {
          process.send({ cmd: "done", failed: true, message: e.message });
        }
      });
      process.send({ cmd: "ready" });
    } else {
      const tests = getTests();
      // const sizes = new Map();
      // tests.forEach(name => sizes.set(name, fs.statSync(path.join(basedir, name + ".ts")).size));
      // tests.sort((a, b) => sizes.get(b) - sizes.get(a));
      const workers = [];
      const current = [];
      const outputs = [];
      let numWorkers = Math.min(coreCount - 1, tests.length);
      console.log("Spawning " + numWorkers + " workers ...");
      cluster.settings.silent = true;
      let index = 0;
      for (let i = 0; i < numWorkers; ++i) {
        let worker = cluster.fork();
        workers[i] = worker;
        current[i] = null;
        outputs[i] = [];
        worker.process.stdout.on("data", buf => outputs[i].push(buf));
        worker.process.stderr.on("data", buf => outputs[i].push(buf));
        worker.on("message", msg => {
          if (msg.cmd == "done") {
            process.stdout.write(Buffer.concat(outputs[i]).toString());
            if (msg.failed) failedTests.add(current[i]);
            if (msg.message) failedMessages.set(current[i], msg.message);
          } else if (msg.cmd == "skipped") {
            process.stdout.write(Buffer.concat(outputs[i]).toString());
            skippedTests.add(current[i]);
            if (msg.message) skippedMessages.set(current[i], msg.message);
          } else if (msg.cmd != "ready") {
            throw Error("invalid command: " + msg.cmd);
          }
          if (index >= tests.length) {
            workers[i] = null;
            worker.kill();
            return;
          }
          current[i] = tests[index++];
          outputs[i] = [];
          worker.send({ cmd: "run", test: current[i] });
        });
        worker.on("disconnect", () => {
          if (workers[i]) throw Error("worker#" + i + " died unexpectedly");
          if (!--numWorkers) evaluateResult();
        });
      }
    }

  // Otherwise run tests sequentially
  } else {
    getTests().forEach(runTest);
    evaluateResult();
  }
});

'''
'''--- tests/compiler/NonNullable.ts ---
type nullableString = string | null;

assert(nameof<NonNullable<u32>>() == nameof<u32>());
assert(nameof<NonNullable<nullableString>>() == nameof<string>());
assert(nameof<NonNullable<string[] | null>>() == nameof<string[]>());

function assertNonNull<T>(t: T): void {
  assert(!isNullable<T>(), "T cannot be null");
  assert(t != null);
}

function safetyCheck<A>(t: A): void {
  if (t != null) {
    assertNonNull(<NonNullable<A>>t);
  }
}

let z: nullableString = "z";

assertNonNull<nonnull<nullableString>>(z!);
safetyCheck(z);

'''
'''--- tests/compiler/ReturnType.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/ReturnType.ts ---
assert(isInteger<ReturnType<() => i8>>());
assert(isSigned<ReturnType<() => i8>>());
assert(sizeof<ReturnType<() => i8>>() == 1); // i32

assert(isFloat<ReturnType<() => f64>>());
assert(sizeof<ReturnType<() => f64>>() == 8);

class SomeExample {
  a: f64;
  b: f64;
}

assert(isManaged<ReturnType<() => SomeExample>>());
assert(offsetof<ReturnType<() => SomeExample>>() == 16);

'''
'''--- tests/compiler/abi.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/abi.ts ---
// NOTE: this test mostly relies on comparing to the fixture because the ABI affects emitted
// instructions, not semantics.

// exported functions should wrap their returns
export function exported(): i8 {
  return <i8>128;
}

// internal functions should not wrap their returns
function internal(): i8 {
  return <i8>128;
}

// calling a function that already wraps its return should not wrap again
export function exportedExported(): i8 {
  return exported();
}

// calling a function that does not wrap its return should wrap it
export function exportedInternal(): i8 {
  return internal();
}

internal(); // keep alive

var condition = !0;

// locals not marked as wrapped should be wrapped when necessaray
{
  let x: i8;
  x = <i8>256; // overflows to 0
  assert(!x); // should wrap
}

// locals not marked as wrapped in all branches should be wrapped when necessary
{
  let x: i8;
  x = <i8>256; // overflows to 0

  if (condition) {
    x = x / 2; // should sign-extend x on input
  } else {
    x = x / 2; // ^
  }
  assert(!x); // should wrap x
}

// locals marked as wrapped in all branches should not be wrapped again
{
  let x: i8; // local
  x = <i8>256; // overflows to 0

  if (condition) {
    x = x >> 24; // should mark result as wrapped
  } else {
    x = x & 127; // ^
  }
  assert(!x); // should not wrap
}

// unlike locals, globals are wrapped on assignment
var y: i8;
{
  y = <i8>256; // should wrap
  assert(!y); // should not wrap
}

// certain operations do not overflow, depending on target type
{
  let b: bool;
  b = <bool>ctz(2);
  assert(b); // should wrap
  b = <bool>clz(1);
  assert(b); // should wrap
  let x: i8;
  x = <i8>ctz(2);
  assert(x);  // should not wrap
  x = <i8>clz(1);
  assert(x);  // should not wrap
  // TODO: test more?
}

'''
'''--- tests/compiler/asc-constants.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/asc-constants.ts ---
ASC_TARGET;
ASC_NO_ASSERT;
ASC_MEMORY_BASE;
ASC_OPTIMIZE_LEVEL;
ASC_SHRINK_LEVEL;

ASC_FEATURE_SIGN_EXTENSION;
ASC_FEATURE_MUTABLE_GLOBALS;
ASC_FEATURE_NONTRAPPING_F2I;
ASC_FEATURE_BULK_MEMORY;
ASC_FEATURE_SIMD;
ASC_FEATURE_THREADS;
ASC_FEATURE_EXCEPTION_HANDLING;
ASC_FEATURE_TAIL_CALLS;
ASC_FEATURE_REFERENCE_TYPES;
ASC_FEATURE_MULTI_VALUE;
ASC_FEATURE_GC;
ASC_FEATURE_MEMORY64;

// versions vary between builds
isDefined(ASC_VERSION_MAJOR);
isDefined(ASC_VERSION_MINOR);
isDefined(ASC_VERSION_PATCH);

'''
'''--- tests/compiler/assert-nonnull.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/assert-nonnull.ts ---
export function testVar(n: Error | null): Error {
  return n!;
}

class Foo {
  bar: Foo | null;
  baz: (() => Foo | null) | null;
}

export function testObj(foo: Foo | null): Foo | null {
  return foo!.bar;
}

export function testProp(foo: Foo): Foo {
  return foo.bar!;
}

export function testArr(foo: Array<Foo> | null): Foo {
  return foo![0];
}

export function testElem(foo: Array<Foo | null>): Foo {
  return foo[0]!;
}

export function testAll(foo: Array<Foo | null> | null): Foo {
  return foo![0]!.bar!;
}

export function testAll2(foo: Array<Foo | null> | null): Foo {
  return foo!![0]!!.bar!!; // 3x AS225: Expression is never 'null'
}

export function testFn(fn: (() => Foo | null) | null): Foo | null {
  return fn!();
}

export function testFn2(fn: (() => Foo | null) | null): Foo | null {
  var fn2 = fn!;
  return fn2();
}

export function testRet(fn: (() => Foo | null) | null): Foo {
  return fn!()!;
}

export function testObjFn(foo: Foo): Foo | null {
  return foo.baz!();
}

export function testObjRet(foo: Foo): Foo {
  return foo.baz!()!;
}

'''
'''--- tests/compiler/assert.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/assert.ts ---
assert(true);
assert(1);
assert(1 > 0);
assert(0.5);
assert(0.5 > 0.4);
assert(0x100000000);
assert(0x100000000 > 1);

// can be used as an expression
if (!assert(true, "must be true")) unreachable();

'''
'''--- tests/compiler/basic-nullable.json ---
{
  "asc_flags": [
  ],
  "stderr": [
    "AS204: Type 'i32' cannot be nullable.",
    "EOF"
  ]
}

'''
'''--- tests/compiler/basic-nullable.ts ---
var a: i32 | null;

ERROR("EOF"); // mark end and ensure fail

'''
'''--- tests/compiler/binary.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/binary.ts ---
var b = false;

var i: i32 = 0;

i < 1;
i > 1;
i <= 1;
i >= 1;
i == 1;
i === 1;
i + 1;
i - 1;
i * 1;
i / 1;
i % 1;
i ** 1;
i << 1;
i >> 1;
i >>> 1;
i & 1;
i | 1;
i ^ 1;

b = i < 1;
b = i > 1;
b = i <= 1;
b = i >= 1;
b = i == 1;
b = i === 1;
i = i + 1;
i = i - 1;
i = i * 1;
i = i / 1;
i = i % 1;
i = <i32>(i ** 1);
i = i << 1;
i = i >> 1;
i = i >>> 1;
i = i & 1;
i = i | 1;
i = i ^ 1;

i += 1;
i -= 1;
i *= 1;
i %= 1;
// i **= 1;
i <<= 1;
i >>= 1;
i >>>= 1;
i &= 1;
i |= 1;
i ^= 1;

var I: i64 = 0;

I < 1;
I > 1;
I <= 1;
I >= 1;
I == 1;
I === 1;
I + 1;
I - 1;
I * 1;
I / 1;
I % 1;
(<f64>I) ** 1;
I << 1;
I >> 1;
I >>> 1;
I & 1;
I | 1;
I ^ 1;

b = I < 1;
b = I > 1;
b = I <= 1;
b = I >= 1;
b = I == 1;
b = I === 1;
I = I + 1;
I = I - 1;
I = I * 1;
I = I / 1;
I = I % 1;
I = <i64>((<f64>I) ** 1);
I = I << 1;
I = I >> 1;
I = I >>> 1;
I = I & 1;
I = I | 1;
I = I ^ 1;

I += 1;
I -= 1;
I *= 1;
I %= 1;
// I **= 1;
I <<= 1;
I >>= 1;
I >>>= 1;
I &= 1;
I |= 1;
I ^= 1;

var f: f32 = 0;

f < 1;
f > 1;
f <= 1;
f >= 1;
f == 1;
f === 1;
f + 1;
f - 1;
f * 1;
f / 1;
f % 1;
f ** 1;

b = f < 1;
b = f > 1;
b = f <= 1;
b = f >= 1;
b = f == 1;
b = f === 1;
f = f + 1;
f = f - 1;
f = f * 1;
f = f / 1;
f = f % 1;
f = f ** 1;

f += 1;
f -= 1;
f *= 1;
f %= 1;
f **= 1;

var F: f64 = 0;

F < 1;
F > 1;
F <= 1;
F >= 1;
F == 1;
F === 1;
F + 1;
F - 1;
F * 1;
F / 1;
F % 1;
F ** 1;

b = F < 1;
b = F > 1;
b = F <= 1;
b = F >= 1;
b = F == 1;
b = F === 1;
F = F + 1;
F = F - 1;
F = F * 1;
F = F / 1;
F = F % 1;
F = F ** 1;

F += 1;
F -= 1;
F *= 1;
F %= 1;
F **= 1;

'''
'''--- tests/compiler/bool.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/bool.ts ---
var i = <i32>2;
assert(<bool>i == true);
var I = <i64>2;
assert(<bool>I == true);
var u = <u32>2;
assert(<bool>u == true);
var U = <u64>2;
assert(<bool>U == true);

var f = <f32>2;
assert(<bool>f == true);
var f0 = <f32>+0.0;
assert(<bool>f0 == false);
var f1 = <f32>-0.0;
assert(<bool>f1 == false);
var f2 = <f32>+NaN;
assert(<bool>f2 == false);
var f3 = <f32>-NaN;
assert(<bool>f3 == false);
var f4 = +f32.MAX_VALUE;
assert(<bool>f4 == true);
var f5 = -f32.MAX_VALUE;
assert(<bool>f5 == true);
var f6 = <f32>+Infinity;
assert(<bool>f6 == true);
var f7 = <f32>-Infinity;
assert(<bool>f7 == true);
var f8 = +f32.MIN_VALUE;
assert(<bool>f8 == true);
var f9 = -f32.MIN_VALUE;
assert(<bool>f9 == true);
var f10 = reinterpret<f32>(1);
assert(<bool>f10 == true);
var f11 = reinterpret<f32>(0x7F800000 - 1);
assert(<bool>f11 == true);
var f12 = reinterpret<f32>(0x7F800000 + 1);
assert(<bool>f12 == false);
var f13 = reinterpret<f32>(0xFF800000 + 1);
assert(<bool>f13 == false);

var F = <f64>2;
assert(<bool>F == true);
var F0 = <f64>+0.0;
assert(<bool>F0 == false);
var F1 = <f64>-0.0;
assert(<bool>F1 == false);
var F2 = <f64>+NaN;
assert(<bool>F2 == false);
var F3 = <f64>-NaN;
assert(<bool>F3 == false);
var F4 = +f64.MAX_VALUE;
assert(<bool>F4 == true);
var F5 = -f64.MAX_VALUE;
assert(<bool>F5 == true);
var F6 = +Infinity;
assert(<bool>F6 == true);
var F7 = -Infinity;
assert(<bool>F7 == true);
var F8 = +f64.MIN_VALUE;
assert(<bool>F8 == true);
var F9 = -f64.MIN_VALUE;
assert(<bool>F9 == true);
var F10 = reinterpret<f64>(1);
assert(<bool>F10 == true);
var F11 = reinterpret<f64>(0x7FF0000000000000 - 1);
assert(<bool>F11 == true);
var F12 = reinterpret<f64>(0x7FF0000000000000 + 1);
assert(<bool>F12 == false);
var F13 = reinterpret<f64>(0xFFF0000000000000 + 1);
assert(<bool>F13 == false);

var uu = <u8>2;
assert(<bool>uu == true);

'''
'''--- tests/compiler/builtins.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/builtins.ts ---
var b: bool;
class C {}

// type checks

assert(isInteger<i32>());
assert(!isInteger<f32>());
assert(isFloat<f32>());
assert(!isFloat<i32>());
assert(isReference<string>());
assert(!isReference<usize>());
assert(isArray<i32[]>());
assert(!isArray<usize>());
assert(isArrayLike<i32[]>());
assert(isArrayLike<string>());
assert(isArrayLike<Uint8Array>());
assert(!isArrayLike<i32>());
assert(isFunction<() => void>());
assert(!isFunction<u32>());
assert(isNullable<C | null>());
assert(!isNullable<C>());

assert(isInteger(<i32>1));
assert(!isInteger(<f32>1));
assert(isFloat(<f32>1));
assert(!isFloat(<i32>1));
assert(isReference(changetype<string>(0)));
assert(!isReference(changetype<usize>(0)));
assert(isString(""));
assert(isString("abc"));
assert(!isString(1));
assert(isArray(changetype<i32[]>(0)));
assert(isArrayLike(changetype<i32[]>(0)));
assert(isArrayLike(changetype<string>(0)));
assert(isArrayLike(changetype<Uint8Array>(0)));
assert(!isArray(changetype<usize>(0)));
assert(isFunction(changetype<() => void>(0)));
assert(!isFunction(changetype<u32>(0)));
assert(isNullable(changetype<C | null>(0)));
assert(!isNullable(changetype<C>(0)));

// evaluation

assert(isDefined(b));
assert(!isDefined(c));
assert(isConstant(1));
assert(!isConstant(b));

// small integers
var l: i8;
l = add<i8>(1, 2); assert(l == 3);
l = sub<i8>(2, 1); assert(l == 1);
l = mul<i8>(1, 2); assert(l == 2);
l = div<i8>(6, 2); assert(l == 3);

var v: u8;
v = rotl<u8>(<u8>0b10001111, 3); assert(v == 0b01111100);
v = rotr<u8>(<u8>0b10101010, 1); assert(v == 0b01010101);

// integers

var i: i32;

clz<i32>(1);
ctz<i32>(1);
popcnt<i32>(1);
rotl<i32>(1, 1);
rotr<i32>(1, 1);
abs<i32>(-42);
max<i32>(1, 2);
min<i32>(1, 2);
add<i32>(1, 2);
sub<i32>(2, 1);
mul<i32>(1, 2);
div<i32>(6, 2);

i = clz<i32>(1);
i = ctz<i32>(1);
i = popcnt<i32>(1);
i = rotl<i32>(1, 1);
i = rotr<i32>(1, 1);
i = abs<i32>(-42); assert(i == 42);
i = max<i32>(1, 2); assert(i == 2);
i = min<i32>(1, 2); assert(i == 1);
i = add<i32>(1, 2); assert(i == 3);
i = sub<i32>(2, 1); assert(i == 1);
i = mul<i32>(2, 3); assert(i == 6);
i = div<i32>(6, 2); assert(i == 3);
var I: i64;

clz<i64>(1);
ctz<i64>(1);
popcnt<i64>(1);
rotl<i64>(1, 1);
rotr<i64>(1, 1);
abs<i64>(-42);

I = clz<i64>(1);
I = ctz<i64>(1);
I = popcnt<i64>(1);
I = rotl<i64>(1, 1);
I = rotr<i64>(1, 1);
I = abs<i64>(-42); assert(I == 42);
I = max<i64>(1, 2); assert(I == 2);
I = min<i64>(1, 2); assert(I == 1);
I = add<i64>(1, 2); assert(I == 3);
I = sub<i64>(2, 1); assert(I == 1);
I = mul<i64>(2, 3); assert(I == 6);
I = div<i64>(6, 2); assert(I == 3);

// floats

var f: f32;

<f32>NaN;
<f32>Infinity;
abs<f32>(1.25);
ceil<f32>(1.25);
copysign<f32>(1.25, 2.5);
floor<f32>(1.25);
max<f32>(1.25, 2.5);
min<f32>(1.25, 2.5);
nearest<f32>(1.25);
sqrt<f32>(1.25);
trunc<f32>(1.25);
assert(isNaN<f32>(1.25) == false);
assert(isNaN<f32>(NaN) == true);
assert(isFinite<f32>(1.25) == true);
assert(isFinite<f32>(Infinity) == false);
assert(isFinite<f32>(-Infinity) == false);
assert(isFinite<f32>(NaN) == false);

f = NaN;
f = Infinity;
f = abs<f32>(1.25);
f = ceil<f32>(1.25);
f = copysign<f32>(1.25, 2.5);
f = floor<f32>(1.25);
f = add<f32>(1.5, 2.5); assert(f == 4.0);
f = sub<f32>(2.5, 1.5); assert(f == 1.0);
f = mul<f32>(1.5, 2.0); assert(f == 3.0);
f = div<f32>(1.5, 0.5); assert(f == 3.0);
f = max<f32>(1.25, 2.5); assert(f == 2.5);
f = min<f32>(1.25, 2.5);
f = nearest<f32>(1.25);
f = sqrt<f32>(1.25);
f = trunc<f32>(1.25);
b = isNaN<f32>(1.25);
b = isFinite<f32>(1.25);

var F: f64;

<f64>NaN;
<f64>Infinity;
NaN;
Infinity;
abs<f64>(1.25);
ceil<f64>(1.25);
copysign<f64>(1.25, 2.5);
floor<f64>(1.25);
add<f64>(1.5, 2.5);
sub<f64>(2.5, 1.5);
mul<f64>(1.5, 2.0);
div<f64>(1.5, 0.5);
max<f64>(1.25, 2.5);
min<f64>(1.25, 2.5);
nearest<f64>(1.25);
sqrt<f64>(1.25);
trunc<f64>(1.25);
assert(isNaN<f64>(1.25) == false);
assert(isNaN<f64>(NaN) == true);
assert(isFinite<f64>(1.25) == true);
assert(isFinite<f64>(Infinity) == false);
assert(isFinite<f64>(-Infinity) == false);
assert(isFinite<f64>(NaN) == false);

F = NaN;
F = Infinity;
F = abs<f64>(1.25);
F = ceil<f64>(1.25);
F = copysign<f64>(1.25, 2.5);
F = floor<f64>(1.25);
F = add<f64>(1.5, 2.5); assert(F == 4.0);
F = sub<f64>(2.5, 1.5); assert(F == 1.0);
F = mul<f64>(1.5, 2.0); assert(F == 3.0);
F = div<f64>(1.5, 0.5); assert(F == 3.0);
F = max<f64>(1.25, 2.5);
F = min<f64>(1.25, 2.5);
F = nearest<f64>(1.25);
F = sqrt<f64>(1.25);
F = trunc<f64>(1.25);
b = isNaN<f64>(1.25);
b = isFinite<f64>(1.25);

// prefer right type if left is a numeric literal

F = min(0, 1.0);
f = max(0, f);
F = add(0, 1.5);
f = add(0, f);
F = sub(2, 1.0);
f = sub(2, f);
F = mul(2, 1.0);
f = mul(2, f);
F = div(2, 1.0);
f = div(2, f);

// load and store

i = load<i32>(8); store<i32>(8, i);
store<i32>(8, load<i32>(8));
I = load<i64>(8); store<i64>(8, I);
store<i64>(8, load<i64>(8));
f = load<f32>(8); store<f32>(8, f);
store<f32>(8, load<f32>(8));
F = load<f64>(8); store<f64>(8, F);
store<f64>(8, load<f64>(8));

const constantOffset: usize = 8;
i = load<i32>(0, constantOffset); store<i32>(0, i, constantOffset);
store<i32>(0, load<i32>(0, constantOffset), constantOffset);
I = load<i64>(0, constantOffset); store<i64>(0, I, constantOffset);
store<i64>(0, load<i64>(0, constantOffset), constantOffset);
f = load<f32>(0, constantOffset); store<f32>(0, f, constantOffset);
store<f32>(0, load<f32>(0, constantOffset), constantOffset);
F = load<f64>(0, constantOffset); store<f64>(0, F, constantOffset);
store<f64>(0, load<f64>(0, constantOffset), constantOffset);

// load and store smaller types

i = load<i8>(8);
i = load<i16>(8);
i = load<i32>(8);

i = load<u8>(8);
i = load<u16>(8);
i = load<u32>(8);

var u: u32;
u = load<u8>(8);
u = load<u16>(8);
u = load<u32>(8);

u = load<i8>(8);
u = load<i16>(8);
u = load<i32>(8);

I = load<i8>(8);
I = load<i16>(8);
I = load<i32>(8);
I = load<i64>(8);

var U: u64;
U = load<u8>(8);
U = load<u16>(8);
U = load<u32>(8);
U = load<u64>(8);

store<i8>(8, <i32>1);
store<i16>(8, <i32>1);
store<i32>(8, <i32>1);

store<i8>(8, <i64>1);
store<i16>(8, <i64>1);
store<i32>(8, <i64>1);
store<i64>(8, <i64>1);

store<i64>(8, <i32>1); // must extend

// reinterpretation

reinterpret<i32>(1.25);
reinterpret<f32>(25);
reinterpret<i64>(1.25);
reinterpret<f64>(25);

i = reinterpret<i32>(1.25);
f = reinterpret<f32>(25);
I = reinterpret<i64>(1.25);
F = reinterpret<f64>(25);

// host

var s: usize;

memory.size();
memory.grow(1); // also necessary for load/store tests below

s = memory.size();
s = memory.grow(1);

// other

select<i32>(10, 20, true);
select<i64>(100, 200, false);
select<f32>(1.25, 2.5, true);
select<f64>(12.5, 25.0, false);

i = select<i32>(10, 20, true);
I = select<i64>(100, 200, false);
f = select<f32>(1.25, 2.5, true);
F = select<f64>(12.5, 25.0, false);

if (!i) unreachable();

var fn = function(a: i32, b: i32): i32 { return a + b; };
assert(fn(1,2) == 3);
assert(5 == call_indirect(fn.index, 2, 3)); // ctxType i32
assert(fn.name == "");
assert(fn.length == 2);
assert(changetype<(a: i32, b: i32) => i32>(fn).length == 2);
assert(fn.toString() == "function() { [native code] }");

// AS specific

assert(sizeof<u8>() == 1);
assert(sizeof<u16>() == 2);
assert(sizeof<u32>() == 4);
assert(sizeof<u64>() == 8);
sizeof<usize>();
assert(sizeof<bool>() == 1);
assert(sizeof<i8>() == 1);
assert(sizeof<i16>() == 2);
assert(sizeof<i32>() == 4);
assert(sizeof<i64>() == 8);
sizeof<isize>();
assert(sizeof<f32>() == 4);
assert(sizeof<f64>() == 8);

assert(alignof<u8>() == 0);
assert(alignof<u16>() == 1);
assert(alignof<u32>() == 2);
assert(alignof<u64>() == 3);
assert(alignof<bool>() == 0);

class Foo<T> { a: T; b: T; }
assert(offsetof<Foo<i32>>("a") == 0);
assert(offsetof<Foo<i32>>("b") == 4);
assert(offsetof<Foo<i16>>("a") == 0);
assert(offsetof<Foo<i16>>("b") == 2);
class Bar extends Foo<i64> {}
assert(offsetof<Bar>("a") == 0);
assert(offsetof<Bar>("b") == 8);

assert(NaN != NaN);
assert(isNaN<f32>(NaN));
assert(isNaN<f64>(NaN));
assert(!isFinite<f32>(NaN));
assert(!isFinite<f32>(Infinity));
assert(!isFinite<f64>(NaN));
assert(!isFinite<f64>(Infinity));
assert(isFinite<f32>(0));
assert(isFinite<f64>(0));

// imported

export function test(): void {
  // cannot be interpreted
  // parseInt("01");
  // parseInt("1", 10);
  // parseFloat("1.0");
}

// limits

assert(i8.MIN_VALUE == <i8>0x80);
assert(i8.MAX_VALUE == 0x7f);
assert(i16.MIN_VALUE == <i16>0x8000);
assert(i16.MAX_VALUE == 0x7fff);
assert(i32.MIN_VALUE == <i32>0x80000000);
assert(i32.MAX_VALUE == 0x7fffffff);
assert(i64.MIN_VALUE == <i64>0x8000000000000000);
assert(i64.MAX_VALUE == 0x7fffffffffffffff);

assert(u8.MIN_VALUE == 0);
assert(u8.MAX_VALUE == 0xff);
assert(u16.MIN_VALUE == 0);
assert(u16.MAX_VALUE == 0xffff);
assert(u32.MIN_VALUE == 0);
assert(u32.MAX_VALUE == 0xffffffff);
assert(u64.MIN_VALUE == 0);
assert(u64.MAX_VALUE == 0xffffffffffffffff);
assert(bool.MIN_VALUE == 0); assert(bool.MIN_VALUE == false);
assert(bool.MAX_VALUE == 1); assert(bool.MAX_VALUE == true);

assert(f32.MIN_NORMAL_VALUE == 1.1754943508222875e-38);
assert(f32.MIN_VALUE == 1.401298464324817e-45);
assert(f32.MAX_VALUE == 3.40282347e+38);
assert(f32.MIN_SAFE_INTEGER == -16777215);
assert(f32.MAX_SAFE_INTEGER == 16777215);
assert(f32.EPSILON == 1.19209290e-07);

assert(f64.MIN_NORMAL_VALUE == 2.2250738585072014e-308);
assert(f64.MIN_VALUE == 5e-324);
assert(f64.MAX_VALUE == 1.7976931348623157e+308);
assert(f64.MIN_SAFE_INTEGER == -9007199254740991);
assert(f64.MAX_SAFE_INTEGER == 9007199254740991);
assert(f64.EPSILON == 2.2204460492503131e-16);

// inline-assembler

f32.abs(1.0);
f64.abs(1.0);

f32.ceil(1.0);
f64.ceil(1.0);

i32.clz(1);
i64.clz(1);

f32.copysign(1.0, 2.0);
f64.copysign(1.0, 2.0);

i32.ctz(1);
i64.ctz(1);

f32.floor(1.0);
f64.floor(1.0);

f32.nearest(1.0);
f64.nearest(1.0);

i32.popcnt(1);
i64.popcnt(1);

i32.add(1, 2);
i64.add(1, 2);
i32.sub(2, 1);
i64.sub(2, 1);
i32.mul(3, 1);
i64.mul(3, 1);
i32.div_s(4, 1);
i32.div_u(4, 1);
i64.div_s(5, 1);
i64.div_u(5, 1);

i32.load8_s(8);
i32.load8_u(8);
i32.load16_s(8);
i32.load16_u(8);
i32.load(8);
i64.load8_s(8);
i64.load8_u(8);
i64.load16_s(8);
i64.load16_u(8);
i64.load32_s(8);
i64.load32_u(8);
i64.load(8);
f32.load(8);
f64.load(8);

f32.add(1.0, 2.0);
f64.add(1.0, 2.0);
f32.sub(2.0, 1.0);
f64.sub(2.0, 1.0);
f32.mul(1.0, 2.0);
f64.mul(1.0, 2.0);
f32.div(1.5, 0.5);
f64.div(1.5, 0.5);

f32.max(1.0, 2.0);
f64.max(1.0, 2.0);

f32.min(1.0, 2.0);
f64.min(1.0, 2.0);

i32.reinterpret_f32(1.0);
i64.reinterpret_f64(1.0);
f32.reinterpret_i32(1);
f64.reinterpret_i64(1);

i32.rotl(1, 2);
i64.rotl(1, 2);

i32.rotr(1, 2);
i64.rotr(1, 2);

f32.sqrt(1.0);
f64.sqrt(1.0);

i32.store8(8, 1);
i32.store16(8, 1);
i32.store(8, 1);
i64.store8(8, 1);
i64.store16(8, 1);
i64.store32(8, 1);
i64.store(8, 1);
f32.store(8, 1.0);
f64.store(8, 1.0);

f32.trunc(1.0);
f64.trunc(1.0);

assert(Atomics.isLockFree(0) == false);
assert(Atomics.isLockFree(1) == true);
assert(Atomics.isLockFree(2) == true);
assert(Atomics.isLockFree(3) == false);
assert(Atomics.isLockFree(4) == true);
assert(Atomics.isLockFree(5) == false);
assert(Atomics.isLockFree(8) == false);

{
  let a = idof<() => void>();
  let b = idof<() => void>();
  let c = idof<(a: u32) => void>();
  let d = idof<(val: C) => C>();
  let e = idof<(val2: C) => C>();
  trace("signatures", 5, a, b, c, d, e);

  assert(a == b, "testing");
  assert(a != c);
  assert(c == idof<(b: u32) => void>());
  assert(d == e);
}

{
  assert(nameof<() => void>() == "Function");
  assert(nameof<(a: C) => i32>() == "Function");
  assert(nameof<C>() == "C");
  assert(nameof<string>() == "String");
  assert(nameof<bool>() == "bool");
  assert(nameof<i8>() == "i8");
  assert(nameof<u8>() == "u8");
  assert(nameof<i16>() == "i16");
  assert(nameof<u16>() == "u16");
  assert(nameof<i32>() == "i32");
  assert(nameof<u32>() == "u32");
  assert(nameof<f32>() == "f32");
  assert(nameof<i64>() == "i64");
  assert(nameof<u64>() == "u64");
  assert(nameof<f64>() == "f64");
  assert(nameof<isize>() == "isize");
  assert(nameof<usize>() == "usize");
  assert(nameof<void>() == "void");
  assert(nameof("some value") == "String");
  assert(nameof((): void => {}) == "Function");
}

assert(isVoid<void>());
assert(!isVoid<i8>());
assert(!isVoid<u8>());
assert(!isVoid<i16>());
assert(!isVoid<u16>());
assert(!isVoid<i32>());
assert(!isVoid<u32>());
assert(!isVoid<f32>());
assert(!isVoid<i64>());
assert(!isVoid<u64>());
assert(!isVoid<f64>());
assert(!isVoid<C>());
assert(!isVoid<string>());
// assert(!isVoid<v128>());

assert(lengthof<() => void>() == 0);
assert(lengthof<(a: i32) => void>() == 1);
assert(lengthof<(a: i32, b: C) => void>() == 2);
assert(lengthof<(a: i32, b: C, c: string) => void>() == 3);
assert(lengthof((a: i32, b: i32, c: i32, d: i32): void => {}) == 4);

assert(isInteger<ReturnType<() => i32>>());
assert(isInteger<returnof<() => i32>>());
assert(isManaged<returnof<() => C>>());
assert(isManaged<ReturnType<() => C>>());

// Issue #1537: Make sure temp. locals are not confused

function max3(a: i32, b: i32, c: i32): i32 {
  return max(a, max(b, c));
}
assert(max3(3, 2, 1) == 3);

function min3(a: i32, b: i32, c: i32): i32 {
  return min(a, min(b, c));
}
assert(min3(1, 2, 3) == 1);

function rotl3(a: i8, b: i8, c: i8): i32 {
  return rotl(a, rotl(b, c));
}
assert(rotl3(3, 2, 1) == 48);

function rotr3(a: i8, b: i8, c: i8): i32 {
  return rotr(a, rotr(b, c));
}
assert(rotr3(48, 8, 1) == 3);

'''
'''--- tests/compiler/call-inferred.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/call-inferred.ts ---
function foo<T>(a: T): T {
  return a;
}

assert(foo(42) == 42);
assert(foo(42.0) == 42);
assert(foo(<f32>42.0) == 42);

function bar<T>(a: T = <f32>42.0): T {
  return a;
}

assert(bar() == 42);

// TODO: this'd require return type inference, i.e., omitted return type
// function baz<T>(a: i32): T {
//   return a;
// }
// baz(42);

// TODO: this'd ideally be inferred by matching contextualType, avoiding conversions
// function baz<T>(): T {
//   return 1;
// }
// baz(42);

'''
'''--- tests/compiler/call-optional.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/call-optional.ts ---
function opt(a: i32, b: i32 = -1, c: i32 = -2): i32 {
  return a + b + c;
}
assert(opt(3) == 0); // calls the trampoline with 0of2
assert(opt(3, 4) == 5); // calls the trampoline with 1of2
assert(opt(3, 4, 5) == 12); // calls the function directly

var optIndirect = opt;
assert(optIndirect(3) == 0); // calls the trampoline indirectly with 0of2
assert(optIndirect(3, 4) == 5); // calls the trampoline indirectly with 1of2
assert(optIndirect(3, 4, 5) == 12); // calls the trampoline indirectly with 2of2

'''
'''--- tests/compiler/call-super.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/call-super.ts ---
// both constructors present

class A {
  a: i32 = 1;
  constructor() {
    assert(this.a == 1);
  }
}

class B extends A {
  // a: i32 = 3; // FIXME: currently duplicate identifier
  b: i32 = 2;
  constructor() {
    super();
    assert(this.a == 1);
    assert(this.b == 2);
  }
}

function test1(): void {
  var b = new B();
  assert(b.a == 1);
  assert(b.b == 2);
}

test1();

// this constructor present

class C {
  a: i32 = 1;
}

class D extends C {
  b: i32 = 2;
  constructor() {
    super();
    assert(this.a == 1);
    assert(this.b == 2);
  }
}

function test2(): void {
  var d = new D();
  assert(d.a == 1);
  assert(d.b == 2);
}

test2();

// super constructor present

class E {
  a: i32 = 1;
  constructor() {
    assert(this.a == 1);
  }
}

class F extends E {
  b: i32 = 2;
}

function test3(): void {
  var f = new F();
  assert(f.a == 1);
  assert(f.b == 2);
}

test3();

// no constructor present

class G {
  a: i32 = 1;
}

class H extends G {
  b: i32 = 2;
}

function test4(): void {
  var h = new H();
  assert(h.a == 1);
  assert(h.b == 2);
}

test4();

// this constructor present with fallback allocation (`this` is not accessed)

class I {
  a: i32 = 1;
  constructor() {
  }
}

class J extends I {
  b: i32 = 2;
}

function test5(): void {
  var h = new J();
  assert(h.a == 1);
  assert(h.b == 2);
}

test5();

'''
'''--- tests/compiler/cast.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/cast.ts ---
function test<T,U>(x: T): U {
  // @ts-ignore
  var y = x as U;
  // @ts-ignore
  return y;
}

test<i8,i8>(0);
test<i8,u8>(0);
test<i8,i16>(0);
test<i8,u16>(0);
test<i8,i32>(0);
test<i8,u32>(0);
test<i8,i64>(0);
test<i8,u64>(0);
test<i8,bool>(0);

test<u8,i8>(0);
test<u8,u8>(0);
test<u8,i16>(0);
test<u8,u16>(0);
test<u8,i32>(0);
test<u8,u32>(0);
test<u8,i64>(0);
test<u8,u64>(0);
test<u8,bool>(0);

test<i16,i8>(0);
test<i16,u8>(0);
test<i16,i16>(0);
test<i16,u16>(0);
test<i16,i32>(0);
test<i16,u32>(0);
test<i16,i64>(0);
test<i16,u64>(0);
test<i16,bool>(0);

test<u16,i8>(0);
test<u16,u8>(0);
test<u16,i16>(0);
test<u16,u16>(0);
test<u16,i32>(0);
test<u16,u32>(0);
test<u16,i64>(0);
test<u16,u64>(0);
test<u16,bool>(0);

test<i32,i8>(0);
test<i32,u8>(0);
test<i32,i16>(0);
test<i32,u16>(0);
test<i32,i32>(0);
test<i32,u32>(0);
test<i32,i64>(0);
test<i32,u64>(0);
test<i32,bool>(0);

test<u32,i8>(0);
test<u32,u8>(0);
test<u32,i16>(0);
test<u32,u16>(0);
test<u32,i32>(0);
test<u32,u32>(0);
test<u32,i64>(0);
test<u32,u64>(0);
test<u32,bool>(0);

test<i64,i8>(0);
test<i64,u8>(0);
test<i64,i16>(0);
test<i64,u16>(0);
test<i64,i32>(0);
test<i64,u32>(0);
test<i64,i64>(0);
test<i64,u64>(0);
test<i64,bool>(0);

test<u64,i8>(0);
test<u64,u8>(0);
test<u64,i16>(0);
test<u64,u16>(0);
test<u64,i32>(0);
test<u64,u32>(0);
test<u64,i64>(0);
test<u64,u64>(0);
test<u64,bool>(0);

test<bool,i8>(0);
test<bool,u8>(0);
test<bool,i16>(0);
test<bool,u16>(0);
test<bool,i32>(0);
test<bool,u32>(0);
test<bool,i64>(0);
test<bool,u64>(0);
test<bool,bool>(0);

'''
'''--- tests/compiler/class-abstract-errors.json ---
{
  "asc_flags": [
  ],
  "stderr": [
    "TS2511: Cannot create an instance of an abstract class.",
    "TS2515: Non-abstract class 'class-abstract-errors/Baz' does not implement inherited abstract member 'bar'",
    "TS2515: Non-abstract class 'class-abstract-errors/Baz' does not implement inherited abstract member 'a'",
    "EOF"
  ]
}

'''
'''--- tests/compiler/class-abstract-errors.ts ---
abstract class Foo {
  abstract bar(): void;
  abstract get a(): i32;
  abstract set a(a: i32);
}

new Foo(); // TS2511: Cannot create an instance of an abstract class.

class Baz extends Foo {
  // TS2515: Non-abstract class 'Baz' does not implement inherited abstract member 'bar' from 'Foo'
  // TS2515: Non-abstract class 'Baz' does not implement inherited abstract member 'a' from 'Foo'
}

new Baz();

class Qux extends Foo {
  bar(): i32 {
    return 1;
  }
  get a(): i32 { return 0; }
  set a(a: i32) {}
}

// TODO: This does not check .bar overload
var qux = new Qux();
// But this does: var qux: Foo = new Qux();
qux.bar();

ERROR("EOF");

'''
'''--- tests/compiler/class-extends.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/class-extends.ts ---
class A {
  a: i32 = 0;
}

class B extends A {
  b: i16 = 1;
}

export function test(b: B): void {
  b.a;
  b.b;
  b.a = 2;
  b.b = 3;
}

'''
'''--- tests/compiler/class-implements.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/class-implements.ts ---
interface I {
  foo(): i32;
}

export class A implements I {
  foo(): i32 { return 1; }
}

var a = new A();
assert(a.foo() === 1);

class B {
}

export class C extends B implements I {
  foo(): i32 { return 2; }
}

var c = new C();
assert(c.foo() === 2);

'''
'''--- tests/compiler/class-overloading-cast.json ---
{
  "asc_flags": [
    "--explicitStart"
  ]
}

'''
'''--- tests/compiler/class-overloading-cast.ts ---
class A<T> {
  foo(a: T): string {
    return "A";
  }
}
class B<T, V> extends A<T> {
  foo(a: T): string {
    return "B";
  }
}

class C extends A<string>{}

let v = new B<i32, f64>();
let v2 = new B<i32, string>();
let v3 = new B<f64, string>();
assert((<A<i32>>v).foo(1) == "B");
assert(v2.foo(1) == "B");
assert((<A<f64>>v3).foo(1.1) == "B");

let c = new C();

assert(c.foo("a") == "A");
assert((<A<string>>c).foo("a") == "A");

'''
'''--- tests/compiler/class-overloading.json ---
{
  "asc_flags": [
    "--explicitStart"
  ]
}

'''
'''--- tests/compiler/class-overloading.ts ---
var which: string = "";

class A {
  a<T>(a: T): void { // virtual
    which = "A";
  }
  b(b: i32): void { // virtual
    which = "A";
  }
  get c(): i32 { // virtual
    which = "A";
    return 0;
  }
  set c(c: i32) { // virtual
    which = "A";
  }
}

class B extends A {
  a<T>(a: T): void { // virtual + overload
    which = "B";
  }
  b(b: i32): void { // virtual + overload
    which = "B";
  }
  get c(): i32 { // virtual + overload
    which = "B";
    return 0;
  }
  set c(c: i32) { // virtual + overload
    which = "B";
  }
}

// Should call the overload
var a: A = new B();
a.a<i32>(1);
assert(which == "B");
which = "";
a.b(1);
assert(which == "B");
which = "";
a.c;
assert(which == "B");
which = "";
a.c = 1;
assert(which == "B");

class C extends B {
  a<T>(a: T): void { // overload
    super.a(a);
    assert(which == "B");
    which = "C";
  }
  b(b: i32): void { // overload
    which = "C";
  }
  get c(): i32 { // overload
    which = "C";
    return 0;
  }
  set c(c: i32) { // overload
    which = "C";
  }
}

// Should call non-virtual super
var c = new C();
which = "";
c.a<i32>(1);
assert(which == "C");
which = "";
c.b(1);
assert(which == "C");
which = "";
c.c;
assert(which == "C");
c.c = 1;
assert(which == "C");

class D extends B {
  // inherits B's
}

// Should call inherited overload
a = new D();
which = "";
a.a<i32>(1);
assert(which == "B");
which = "";
a.b(1);
assert(which == "B");
which = "";
a.c;
assert(which == "B");
a.c = 1;
assert(which == "B");

class E extends D {
  // inherits B's
}

// Should still call inherited overload
a = new E();
which = "";
a.a<i32>(1);
assert(which == "B");
which = "";
a.b(1);
assert(which == "B");
which = "";
a.c;
assert(which == "B");
a.c = 1;
assert(which == "B");

class F extends E {
  a<T>(a: T): void { // overload
    which = "F";
  }
  b(b: i32): void { // overload
    which = "F";
  }
  get c(): i32 { // overload
    which = "F";
    return 0;
  }
  set c(c: i32) { // overload
    which = "F";
  }
}

// Should no longer call inherited overload
a = new F();
which = "";
a.a<i32>(1);
assert(which == "F");
which = "";
a.b(1);
assert(which == "F");
which = "";
a.c;
assert(which == "F");
which = "";
a.c = 1;
assert(which == "F");

// Should work with interfaces
interface IA {
  foo(): void;
}

class CA implements IA {
  foo(): void {
    which = "IB";
  }
}

var ia: IA = new CA();
which = "";
ia.foo();
assert(which == "IB");

// Should work with extended interfaces
interface IC extends IA {
}

class CC implements IC {
  foo(): void {
    which = "IC";
  }
}

var ic: IC = new CC();
which = "";
ic.foo();
assert(which == "IC");

// Should make stubs for functions discovered when compiling other virtual stubs
class A1 {
  public bar(): i32 {
    return this.baz();
    // 4) discovers A1#baz
  }
  public baz(): i32 {
    throw new Error("not implemented");
    // 5) discovers B1#baz (overload)
  }
}
class B1 extends A1 {
  public baz(): i32 {
    return 3;
    // 6) complete
  }
}
class A2 {
  foo(): i32 {
    throw new Error("not implemented");
    // 2) discovers B2#foo (overload)
  }
}
class B2 extends A2 {
  foo(): i32 {
    return new B1().bar();
    // 3) discovers B1#bar (alias of A1#bar)
  }
}
var b2: A2 = new B2();
assert(b2.foo() == 3); // 1) discovers A2#foo

'''
'''--- tests/compiler/class-static-function.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/class-static-function.ts ---
class Example {
  public static staticFunc(): i32 {
    return 42;
  }
}

function call(func: () => i32): i32 {
  return func();
}

assert(call(Example.staticFunc) == 42);

'''
'''--- tests/compiler/class.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/class.ts ---
class Animal<T> {
  static ONE: i32 = 1;
  static add(a: i32, b: i32): i32 { return a + b + Animal.ONE; }
  static sub<T>(a: T, b: T): T { return a - b + <T>Animal.ONE; } // tsc does not allow this

  one: i32 = 1; // 4
  two: i16 = 2; // 6
  three: i8 = 3; // 7
  instanceAdd(a: i32, b: i32): i32 { return a + b + Animal.ONE; }
  instanceSub<T>(a: T, b: T): T { return a - b + <T>Animal.ONE; } // tsc does not allow this
}

assert(sizeof<Animal<f64>>() == sizeof<usize>());

Animal.ONE;
Animal.add(1,2);
Animal.sub<f32>(1, 2);

export function test(animal: Animal<f64>): Animal<f64> {
  animal.instanceAdd(1, 2);
  animal.instanceSub<f32>(1, 2);

  animal.one;
  animal.two;
  animal.three;

  animal.one = 0 + 1;
  animal.two = 1 + 1; // checks overflow
  animal.three = 1 + 1 + 1; // checks overflow (once)

  var ptr = changetype<usize>(animal);
  var cls = changetype<Animal<f64>>(ptr);
  return cls;
}

class GenericInitializer<T> {
  foo: Array<T> = new Array<T>(); // issue 1119
}

export function testGenericInitializer(): void {
  new GenericInitializer<i32>();
}

'''
'''--- tests/compiler/closure.json ---
{
  "asc_flags": [
  ],
  "stderr": [
    "AS100: Not implemented: Closures",
    "$local1; // closure 1",
    "AS100: Not implemented: Closures",
    "$local0; // closure 2",
    "AS100: Not implemented: Closures",
    "$local0; // closure 3",
    "EOF"
  ]
}

'''
'''--- tests/compiler/closure.ts ---
function testParam($local0: i32, $local1: i32): (value: i32) => i32 {
  return function inner(value: i32) {
    return $local1; // closure 1
  };
}
testParam(1, 2);

function testVar(): (value: i32) => i32 {
  var $local0 = 0;
  return function inner(value: i32) {
    return $local0; // closure 2
  };
}
testVar();

function testLet(): (value: i32) => i32 {
  let $local0 = 0;
  return function inner(value: i32) {
    return $local0; // closure 3
  };
}
testLet();

ERROR("EOF");

'''
'''--- tests/compiler/comma.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/comma.ts ---
var a = 0, b = 0;

b = a++, a; // lower precedence (like separate expressions)
assert(a == 1);
assert(b == 0);

a++, b = a;
assert(a == 2);
assert(b == 2);

a = b = 0;

b = (a++, a); // higher precedence
assert(a == 1);
assert(b == 1);

a = (a++, b = a);
assert(a == 2);
assert(b == 2);

for (var c = 0; c < a; a--, c++);
assert(c == 1);

1, 2, 3; // tsc doesn't allow this

'''
'''--- tests/compiler/const-folding.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/const-folding.ts ---
export function test(value: u64): u64 {
  var mod1: u64 = -1;
  var mod2: u64 = -1;

  var rlo = value << 1;
  var rhi = rlo & ~mod2;

  rhi |= rhi << 1;
  rhi |= (value >> 63) & mod1;
  return rlo + rhi;
}

'''
'''--- tests/compiler/constant-assign.json ---
{
  "asc_flags": [
  ],
  "stderr": [
    "TS2540: Cannot assign to", "b = 3;",
    "TS2540: Cannot assign to", "a = 2;",
    "TS2540: Cannot assign to", "b = [ 2 ];",
    "TS2540: Cannot assign to", "a = [ 2 ];",
    "TS2540: Cannot assign to", "a = 2;",
    "EOF"
  ]
}

'''
'''--- tests/compiler/constant-assign.ts ---
function localConst(a: i32): void {
  const b = a + 1;
  b = 3;
}
localConst(1);

function localConstInline(): void {
  const a = 1;
  a = 2;
}
localConstInline();

function localConstArray(a: i32): void {
  const b: i32[] = [ a ];
  b = [ 2 ];
}
localConstArray(1);

function localConstArrayInline(): void {
  const a: i32[] = [ 1 ];
  a = [ 2 ];
}
localConstArrayInline();

// globalConst
const a = 1;
a = 2;

ERROR("EOF"); // mark end and ensure fail

'''
'''--- tests/compiler/constructor-errors.json ---
{
  "asc_flags": [
  ],
  "stderr": [
    "TS2333: 'this' cannot be referenced in constructor arguments.",
    "b: i32 = this.a, // TS2333",
    "TS2333: 'this' cannot be referenced in constructor arguments.",
    "c: i32 = this.foo() // TS2333",
    "TS2333: 'this' cannot be referenced in constructor arguments.",
    "e: i32 = this.d, // TS2333",
    "TS2333: 'this' cannot be referenced in constructor arguments.",
    "f: i32 = this.bar() // TS2333",
    "TS2336: 'super' cannot be referenced in constructor arguments.",
    "h: i32 = super.g, // TS2336",
    "TS2336: 'super' cannot be referenced in constructor arguments.",
    "i: i32 = super.baz() // TS2336",
    "TS2336: 'super' cannot be referenced in constructor arguments.",
    "j: i32 = super.g, // TS2336",
    "TS2336: 'super' cannot be referenced in constructor arguments.",
    "k: i32 = super.baz() // TS2336",
    "EOF"
  ]
}

'''
'''--- tests/compiler/constructor-errors.ts ---
class CtorAccessThis {
  a: i32 = 0;
  constructor(
    public b: i32 = this.a, // TS2333
    public c: i32 = this.foo() // TS2333
  ) {}
  foo(): i32 { return 0; }
}

new CtorAccessThis();

class CtorAccessThisInline {
  d: i32 = 0;
  @inline
  constructor(
    public e: i32 = this.d, // TS2333
    public f: i32 = this.bar() // TS2333
  ) {}
  bar(): i32 { return 0; }
}

new CtorAccessThisInline();

class CtorSuper {
  g: i32 = 0;
  baz(): i32 { return 0; }
}

class CtorAccessSuper extends CtorSuper {
  constructor(
    public h: i32 = super.g, // TS2336
    public i: i32 = super.baz() // TS2336
  ) {
    super();
  }
}

new CtorAccessSuper();

class CtorAccessSuperInline extends CtorSuper {
  @inline
  constructor(
    public j: i32 = super.g, // TS2336
    public k: i32 = super.baz() // TS2336
  ) {
    super();
  }
}

new CtorAccessSuperInline();

ERROR("EOF");

'''
'''--- tests/compiler/constructor.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/constructor.ts ---
// fall-through allocate
class EmptyCtor {
  constructor() {}
}

var emptyCtor = new EmptyCtor();

// fall-through allocate with field initializer
class EmptyCtorWithFieldInit {
  a: i32 = 1;
  constructor() {}
}

var emptyCtorWithFieldInit = new EmptyCtorWithFieldInit();

// fall-through allocate with field initialized to zero
class EmptyCtorWithFieldNoInit {
  a: i32;
  constructor() {}
}

var emptyCtorWithFieldNoInit = new EmptyCtorWithFieldNoInit();

// fall-through allocate with field access
class EmptyCtorWithFieldAccess {
  a: i32;
  constructor() {
    this.a = 1;
  }
}

var emptyCtorWithFieldAccess = new EmptyCtorWithFieldAccess();

// direct allocate
class None {
}

var none = new None();

// direct allocate with field initializer
class JustFieldInit {
  a: i32 = 1;
}

var justFieldInit = new JustFieldInit();

// direct allocate with field initialized to zero
class JustFieldNoInit {
  a: i32;
}

var justFieldNoInit = new JustFieldNoInit();

// explicit return with no extra checks
@final
class CtorReturns {
  constructor() {
    return changetype<CtorReturns>(0);
  }
}

var ctorReturns = new CtorReturns();

var b: bool = true;

// conditional explicit return, otherwise fall-through
@final
class CtorConditionallyReturns {
  constructor() {
    // AS905 due to fall-through needing to prepend a 'this' allocation
    if (b) {
      return changetype<CtorConditionallyReturns>(0);
    }
  }
}

var ctorConditionallyReturns = new CtorConditionallyReturns();

// conditional explicit return 'this', otherwise fall-through
class CtorConditionallyReturnsThis {
  constructor() {
    if (b) {
      return this;
    }
  }
}

var ctorConditionallyReturnsThis = new CtorConditionallyReturnsThis();

class CtorFieldInitOrder {
  c: i32 = this.a + this.b;
  constructor(public a: i32, public b: i32 = 2) {
    assert(a == 1);
    assert(this.a == 1);
    assert(b == 2);
    assert(this.b == 2);
    assert(this.c == 3);
  }
}

var ctorFieldInitOrder = new CtorFieldInitOrder(1);
assert(ctorFieldInitOrder.a == 1);
assert(ctorFieldInitOrder.b == 2);
assert(ctorFieldInitOrder.c == 3);

'''
'''--- tests/compiler/continue.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/continue.ts ---
// see https://github.com/AssemblyScript/assemblyscript/issues/813
export function testInherit(b: bool): void {
  for (let i = 0; i < 10; i++) {
    if (b) {
      if (i == 5) {
        continue;
      }
      // inheritConditional
    }
    // yielding a continue block
  }
}

'''
'''--- tests/compiler/converge.json ---
{
  "asc_flags": [
    "--converge"
  ]
}

'''
'''--- tests/compiler/converge.ts ---
export function test(): void {}

'''
'''--- tests/compiler/declare.js ---
exports.preInstantiate = function(imports, exports) {
  imports.declare = {
    externalFunction: function() { /* nop */ },
    externalConstant: 1,
    "my.externalFunction": function() { /* nop */ },
    "my.externalConstant": 2
  };
};

'''
'''--- tests/compiler/declare.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/declare.ts ---
declare function externalFunction(): void;
declare const externalConstant: i32;

externalFunction();
assert(externalConstant == 1);

declare namespace my {
  function externalFunction(): void;
  const externalConstant: i32;
}

my.externalFunction();
assert(my.externalConstant == 2);

'''
'''--- tests/compiler/do.json ---
{
  "asc_rtrace": true
}

'''
'''--- tests/compiler/do.ts ---
var ran: bool;

function testSimple(): void {
  var n = 10;
  var m = 0;
  do {
    n--;
    m++;
  } while (n);
  assert(n == 0);
  assert(m == 10);
  ran = true;
}
ran = false;
testSimple();
assert(ran);

function testEmpty(): void {
  var n = 10;
  do; while(n--);
  assert(n == -1);
  ran = true;
}
ran = false;
testEmpty();
assert(ran);

function testNested(): void {
  var n = 10;
  var m = 0;
  var o = 0;
  do {
    n--;
    m++;
    do {
      n--;
      o++;
    } while (n);
    assert(n == 0);
    assert(o == 9);
  } while (n);
  assert(n == 0);
  assert(m == 1);
  assert(o == 9);
  ran = true;
}
ran = false;
testNested();
assert(ran);

function testAlwaysTrue(): void {
  var i = 0;
  do {
    if (++i == 10) break;
  } while (true);
  assert(i == 10);
  ran = true;
}
ran = false;
testAlwaysTrue();
assert(ran);

function testAlwaysTrueNeverBreaks(): i32 {
  var i = 0;
  do {
    if (++i == 10) return i;
  } while (true);
  // no return required
}
assert(testAlwaysTrueNeverBreaks() == 10);

function testAlwaysFalse(): void {
  var i = 0;
  do {
    ++i;
  } while (false);
  assert(i == 1);
  ran = true;
}
ran = false;
testAlwaysFalse();
assert(ran);

function testAlwaysBreaks(): void {
  var i = 0;
  do {
    ++i;
    break;
  } while (i);
  assert(i == 1);
  ran = true;
}
ran = false;
testAlwaysBreaks();
assert(ran);

function testAlwaysReturns(): void {
  var i = 0;
  do {
    ++i;
    ran = true;
    return;
  } while (i);
  assert(false);
}
ran = false;
testAlwaysReturns();
assert(ran);

function testContinue(): void {
  var i = 0;
  do {
    if (++i == 10) break;
    continue;
  } while (i);
  assert(i == 10);
  ran = true;
}
ran = false;
testContinue();
assert(ran);

function testNestedContinue(): void {
  var i = 0;
  var j = 0;
  do {
    if (++i == 10) break;
    do {
      if ((++j % 10) == 0) break;
      continue;
    } while (j);
    continue;
  } while (i);
  assert(i == 10);
  assert(j == 90);
  ran = true;
}
ran = false;
testNestedContinue();
assert(ran);

class Ref {}
function testRef(): void {
  var i = 0;
  var ref: Ref | null = new Ref();
  do {
    if (++i == 10) ref = null;
    else ref = new Ref();
  } while (ref);
  assert(i == 10);
  assert(!ref);
  ran = true;
}
ran = false;
testRef();
assert(ran);

function getRef(): Ref {
  return new Ref();
}
function testRefAutorelease(): void {
  var i = 0;
  var ref: Ref | null = new Ref();
  do {
    if (++i == 10) {
      ref = null;
      break;
    }
  } while (getRef()); // must not leak
  assert(i == 10);
  assert(!ref);
  ran = true;
}
ran = false;
testRefAutorelease();
assert(ran);

__collect();

'''
'''--- tests/compiler/duplicate-identifier.json ---
{
  "asc_flags": [
  ],
  "stderr": [
    "TS2300: Duplicate identifier 'a'", "var a: f32", "var a: i32",
    "TS2300: Duplicate identifier 'b'", "b: f32", "b: i32",
    "TS2300: Duplicate identifier 'c'", "static c: f32", " static c: i32",
    "TS2300: Duplicate identifier 'd'", "const d: f32", "const d: i32",
    "TS2300: Duplicate identifier 'e'", "var e: f32", "var e: i32",
    "TS2300: Duplicate identifier 'f'", "let f: f32",
    "EOF"
  ]
}

'''
'''--- tests/compiler/duplicate-identifier.ts ---
var a: i32;
var a: f32;

class Foo {
  b: i32;
  b: f32;
  static c: i32;
  static c: f32;
}

namespace Bar {
  const d: i32 = 0;
  const d: f32 = 1;
}

function baz(): void {
  var e: i32;
  var e: f32;
  {
    let f: i32;
    let f: f32;
  }
}

baz();

ERROR("EOF"); // mark end and ensure fail

'''
'''--- tests/compiler/empty-exportruntime.json ---
{
  "asc_flags": [
    "--exportRuntime"
  ]
}

'''
'''--- tests/compiler/empty-exportruntime.ts ---

'''
'''--- tests/compiler/empty-new.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/empty-new.ts ---
__new(0, 0);

'''
'''--- tests/compiler/empty-use.json ---
{
  "asc_flags": [
    "--use Date="
  ],
  "stderr": [
    "TS2304: Cannot find name 'Date'.",
    "EOF"
  ]
}

'''
'''--- tests/compiler/empty-use.ts ---
Date.now();

ERROR("EOF");

'''
'''--- tests/compiler/empty.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/empty.ts ---

'''
'''--- tests/compiler/enum.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/enum.ts ---
export enum Implicit {
  ZERO,
  ONE,
  TWO,
  THREE
}

export const enum ImplicitConst {
  ZERO,
  ONE,
  TWO,
  THREE
}

const enum ImplicitConstNoExport {
  ZERO,
  ONE,
  TWO,
  THREE
}

export enum Explicit {
  ZERO = 0,
  ONE = 0 + 1,
  TWO = 1 + 1,
  THREE = 3
}

export const enum ExplicitConst {
  ZERO = 0,
  ONE = 0 + 1,
  TWO = 1 + 1,
  THREE = 3
}

export enum Mixed {
  ZERO,
  ONE,
  THREE = 3,
  FOUR
}

export const enum MixedConst {
  ZERO,
  ONE,
  THREE = 3,
  FOUR
}

function getZero(): i32 {
  return 0;
}

enum NonConstant {
  ZERO = getZero(),
  ONE = getZero() + 1
}

NonConstant.ZERO;
NonConstant.ONE;

export enum SelfReference {
  ZERO,
  ONE = ZERO + 1
}

export const enum SelfReferenceConst {
  ZERO,
  ONE = ZERO + 1
}

var enumType: SelfReferenceConst;

'''
'''--- tests/compiler/export-default.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/export-default.ts ---
export default function theDefault(): void {}

'''
'''--- tests/compiler/export-generic.json ---
{
  "asc_flags": [
    "--pedantic"
  ],
  "stderr": [
    "AS907: Exported generic function or class has no concrete instances.",
    "export function testFunction<T>",
    "AS907: Exported generic function or class has no concrete instances.",
    "export class TestClass<T>",
    "AS907: Exported generic function or class has no concrete instances.",
    "public testMethod<T>()",
    "AS907: Exported generic function or class has no concrete instances.",
    "export function testNamespacedFunction<T>",
    "AS907: Exported generic function or class has no concrete instances.",
    "export class TestNamespacedClass<T>"
  ]
}

'''
'''--- tests/compiler/export-generic.ts ---
export function testFunction<T>(): void {}

export class TestClass<T> {}

export class Foo {
  public testMethod<T>(): void {}
}

export namespace test {
  export function testNamespacedFunction<T>(): void {}
  export class TestNamespacedClass<T> {}
}

ERROR("EOF");

'''
'''--- tests/compiler/export.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/export.ts ---
export function add(a: i32, b: i32): i32 {
  return a + b;
}

function sub(a: i32, b: i32): i32 {
  return a - b;
}

export { sub };

function mul(a: i32, b: i32): i32 { // not exported as "mul"
  return a * b;
}

export { mul as renamed_mul };

export const a: i32 = 1;

const b: i32 = 2;

export { b };

const c: i32 = 3; // not exported as "c"

export { c as renamed_c };

export namespace ns {
  function one(): void {}
  export function two(): void {}
}

export default ns;

'''
'''--- tests/compiler/exportimport-table.js ---
exports.preInstantiate = function(imports, exports) {
  imports.env = {
    table: new WebAssembly.Table({ element: "anyfunc", initial: 2 })
  };
};

'''
'''--- tests/compiler/exportimport-table.json ---
{
  "asc_flags": [
    "--importTable",
    "--exportTable"
  ]
}

'''
'''--- tests/compiler/exportimport-table.ts ---
var f = (): void => {};
f;

'''
'''--- tests/compiler/exports-lazy.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/exports-lazy.ts ---
@lazy export const lazyGlobalUnused: i32[] = [1,2,3];

@lazy export const lazyGlobalUsed: i32[] = [1,2,3];
lazyGlobalUsed;

@lazy export function lazyFuncUnused(): void {}

@lazy export function lazyFuncUsed(): void {}
lazyFuncUsed();

'''
'''--- tests/compiler/exports.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/exports.ts ---
// top-level function
export function add(a: i32, b: i32): i32 {
  return a + b;
}

export function subOpt(a: i32, b: i32 = 0): i32 {
  return a - b;
}

// namespaced function
export namespace math {
  export function sub(a: i32, b: i32): i32 {
    return a - b;
  }
}

// top-level enum
export const enum Animal {
  CAT,
  DOG
}

// namespaced enum
export namespace animals {
  export const enum Animal {
    CAT,
    DOG
  }
}

// top-level class
export class Car {
  static readonly TIRES: i32 = 4;
  static getNumTires(): i32 { return this.TIRES; }
  constructor(public doors: i32 = 2) { this.doors = doors; }
  get numDoors(): i32 { return this.doors; }
  set numDoors(doors: i32) { this.doors = doors; }
  openDoors(): void {}
}

// namespaced class
export namespace vehicles {
  export class Car {
    static readonly TIRES: i32 = 4;
    static getNumTires(): i32 { return this.TIRES; }
    constructor(public doors: i32 = 2) { this.doors = doors; }
    get numDoors(): i32 { return this.doors; }
    set numDoors(doors: i32) { this.doors = doors; }
    openDoors(): void {}
  }
}

// namespaced namespace
export namespace outer {
  export namespace inner {
    export const a = 42;
  }
}

export {renamed_mul} from "./export"; 

// interfaces (should not error)
export interface Iface {}
export namespace outer {
  export interface Iface {}
}

'''
'''--- tests/compiler/exportstar-rereexport.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/exportstar-rereexport.ts ---
export * from './rereexport';

'''
'''--- tests/compiler/exportstar.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/exportstar.ts ---
export * from "./export";

'''
'''--- tests/compiler/extends-baseaggregate.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/extends-baseaggregate.ts ---
class A1 {
  private padding0: f64;
  private padding1: f64;
  private c1: C1 | null;
}

class A2 extends A1 { }

class B1 {
  private a1: A1;
}

class C1 {
  private a2: A2;
}

const poolB: B1[] = [];
const poolA: A2[] = [];
poolA.push(new A2());

'''
'''--- tests/compiler/extends-recursive.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/extends-recursive.ts ---
class Parent {
  child: Child | null = null;
}
export class Child extends Parent { }

'''
'''--- tests/compiler/extends-self.json ---
{
  "asc_flags": [
  ],
  "stderr": [
    "TS2506",
    "EOF"
  ]
}

'''
'''--- tests/compiler/extends-self.ts ---
class Parent extends Child { }
class Child extends Parent { }
new Child();
ERROR("EOF");

'''
'''--- tests/compiler/external.js ---
exports.preInstantiate = function(imports, exports) {
  imports.external = {
    foo: function() { /* nop */ },
    "foo.bar": function() { /* nop */ },
    bar: function() { /* nop */ }
  };
  imports.foo = {
    baz: function() { /* nop */ },
    "var": 3
  };
};

'''
'''--- tests/compiler/external.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/external.ts ---
export declare function foo(): void; // external , foo
export declare namespace foo {
  export function bar(): void; // external , foo.bar
}

@external("bar")
export declare function two(): void; // external , bar

@external("foo", "baz")
export declare function three(): void; // foo , baz

@external("foo", "var") // foo , var
export declare const var_: i32;

'''
'''--- tests/compiler/features/README.md ---
Test cases for post-MVP WebAssembly features.
'''
'''--- tests/compiler/features/gc.json ---
{
  "features": [
    "gc"
  ],
  "asc_flags": [
    "--explicitStart",
    "--noValidate"
  ],
  "skipInstantiate": true
}

'''
'''--- tests/compiler/features/gc.ts ---
function test_i31(): void {
  var ref = i31.new(123);
  assert(ref);
  var val = i31.get(ref);
  var uval = <u32>i31.get(ref);
}

test_i31();

'''
'''--- tests/compiler/features/js-bigint-integration.js ---
exports.preInstantiate = function(imports, exports) {
  const externalValue = 9007199254740991n;
  imports["js-bigint-integration"] = {
    externalValue,
    getExternalValue: function() {
      return externalValue;
    },
  };
};
exports.postInstantiate = function(instance) {
  const exports = instance.exports;
  const internalValue = exports.internalValue;
  if (internalValue != 9007199254740991n) throw Error("unexpected value");
  if (exports.getInternalValue() != internalValue) throw Error("unexpected value");
};

'''
'''--- tests/compiler/features/js-bigint-integration.json ---
{
  "features": [
    "bigint-integration"
  ],
  "asc_flags": [
    "--explicitStart"
  ]
}

'''
'''--- tests/compiler/features/js-bigint-integration.ts ---
declare const externalValue: i64;
declare function getExternalValue(): i64;

assert(externalValue == 9007199254740991);
assert(getExternalValue() == externalValue);

export const internalValue: i64 = 9007199254740991;

export function getInternalValue(): i64 {
  return internalValue;
}

'''
'''--- tests/compiler/features/mutable-globals.js ---
exports.preInstantiate = function(imports, exports) {
  imports["mutable-globals"] = {
    external: new WebAssembly.Global({ value: "i32", mutable: true }, 123)
  };
};
exports.postStart = function(instance) {
  // adds 10 to both
  const exports = instance.exports;
  if (exports.external.valueOf() != 133) throw Error("unexpected value");
  if (exports.internal.valueOf() != 134) throw Error("unexpected value");
};

'''
'''--- tests/compiler/features/mutable-globals.json ---
{
  "features": [
    "mutable-globals"
  ],
  "asc_flags": [
    "--explicitStart"
  ]
}

'''
'''--- tests/compiler/features/mutable-globals.ts ---
export declare var external: i32;

export var internal: i32 = 124;

assert(external == 123);
assert(internal == 124);

external += 10;
internal += 10;

assert(external == 133);
assert(internal == 134);

'''
'''--- tests/compiler/features/nontrapping-f2i.json ---
{
  "features": [
    "nontrapping-f2i"
  ],
  "asc_flags": [
    "--explicitStart"
  ]
}

'''
'''--- tests/compiler/features/nontrapping-f2i.ts ---
// f32->i32
assert(<i32>f32.MAX_VALUE == i32.MAX_VALUE);
assert(<i32>-f32.MAX_VALUE == i32.MIN_VALUE);
assert(<i32>f32.NaN == 0);

// f32->i64
assert(<i64>f32.MAX_VALUE == i64.MAX_VALUE);
assert(<i64>-f32.MAX_VALUE == i64.MIN_VALUE);
assert(<i64>f32.NaN == 0);

// f32->u32
assert(<u32>f32.MAX_VALUE == u32.MAX_VALUE);
assert(<u32>-f32.MAX_VALUE == u32.MIN_VALUE);
assert(<u32>f32.NaN == 0);

// f32->u64
assert(<u64>f32.MAX_VALUE == u64.MAX_VALUE);
assert(<u64>-f32.MAX_VALUE == u64.MIN_VALUE);
assert(<u64>f32.NaN == 0);

// f64->i32
assert(<i32>f64.MAX_VALUE == i32.MAX_VALUE);
assert(<i32>-f64.MAX_VALUE == i32.MIN_VALUE);
assert(<i32>f64.NaN == 0);

// f64->i64
assert(<i64>f64.MAX_VALUE == i64.MAX_VALUE);
assert(<i64>-f64.MAX_VALUE == i64.MIN_VALUE);
assert(<i64>f64.NaN == 0);

// f64->u32
assert(<u32>f64.MAX_VALUE == u32.MAX_VALUE);
assert(<u32>-f64.MAX_VALUE == u32.MIN_VALUE);
assert(<u32>f64.NaN == 0);

// f64->u64
assert(<u64>f64.MAX_VALUE == u64.MAX_VALUE);
assert(<u64>-f64.MAX_VALUE == u64.MIN_VALUE);
assert(<u64>f64.NaN == 0);

'''
'''--- tests/compiler/features/not-supported.json ---
{
  "asc_flags": [
  ],
  "stderr": [
    "AS103: Feature 'simd' is not enabled.",
    "var a: v128;",
    "AS103: Feature 'simd' is not enabled.",
    "var b = v128.",
    "AS103: Feature 'simd' is not enabled.",
    "var c: Array<v128>;",
    "AS103: Feature 'simd' is not enabled.",
    "var a: v128;",
    "AS103: Feature 'simd' is not enabled.",
    "var b = v128.",
    "AS103: Feature 'simd' is not enabled.",
    "let a: v128;",
    "AS103: Feature 'simd' is not enabled.",
    "let b = v128.",
    "AS103: Feature 'simd' is not enabled.",
    "a: v128",
    "AS103: Feature 'simd' is not enabled.",
    "): v128",
    "AS103: Feature 'simd' is not enabled.",
    "a: v128;",
    "AS103: Feature 'simd' is not enabled.",
    "b: Array<v128>;",
    "AS103: Feature 'simd' is not enabled.",
    "get c(): v128",
    "EOF"
  ]
}

'''
'''--- tests/compiler/features/not-supported.ts ---
var a: v128; // type not enabled
var b = v128.splat<i32>(1); // instruction not enabled
var c: Array<v128>; // type not enabled

function test1(): void {
  var a: v128; // type not enabled
  var b = v128.splat<i32>(1); // instruction not enabled
}
test1();

function test2(): void {
  {
    let a: v128; // type not enabled
    let b = v128.splat<i32>(1); // instruction not enabled
  }
}
test2();

function test3(
  a: v128 // type not enabled
): v128 { // type not enabled
  return unreachable();
}
test3(v128.splat<i32>(1)); // instruction not enabled

class Foo {
  a: v128; // type not enabled
  b: Array<v128>; // type not enabled
  get c(): v128 { // type not enabled
    return this.a;
  }
}
(new Foo()).c;

ERROR("EOF");

'''
'''--- tests/compiler/features/reference-types.js ---
exports.preInstantiate = function(imports, exports) {
  imports.Reflect = Reflect;
  imports.console = {
    log: function(ref) {
      console.log("  log: " + ref);
    }
  };
  imports["reference-types"] = {
    external: function(a) {
      return a;
    },
    somethingReal() {
      return {};
    },
    somethingNull() {
      return null;
    },
    someObject: {
      theKey: "Hello world!"
    },
    someKey: "theKey"
  };
};

'''
'''--- tests/compiler/features/reference-types.json ---
{
  "features": [
    "reference-types",
    "exception-handling",
    "gc"
  ],
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/features/reference-types.ts ---
// can use externref as a parameter or return type

export declare function external(a: externref): externref;
export declare function somethingReal(): externref;
export declare function somethingNull(): externref;

export function internal(a: externref): externref {
  const b = external(a);
  let c = external(b);
  var d = external(c);
  return d;
}

// can use reflection to work with externref values

import * as Reflect from "bindings/Reflect";

declare const someObject: externref;
declare const someKey: externref;

assert(Reflect.has(someObject, someKey));

// can call JS bindings with externref values

import * as console from "bindings/console";

console.log(someObject);
console.log(someKey);
console.log(Reflect.get(someObject, someKey));

// Truthiness conversion
if(!somethingReal()) {
  assert(false);
}
if(!somethingNull()) {
  // nop
} else {
  assert(false);
}
if(somethingReal()) {
  // nop
} else {
  assert(false);
}
if(somethingNull()) {
  assert(false);
}

// Explicit null checks (donâ€™t work yet)
/*
if(somethingReal() !== null) {
  // nop
} else {
  assert(false);
}
if(somethingReal() === null) {
  assert(false);
}
if(somethingNull() === null) {
  // nop
} else {
  assert(false);
}
if(somethingNull() !== null) {
  assert(false);
}
*/

// can represent and recognize 'null'

var funcGlobal: funcref;
assert(!funcGlobal);
funcGlobal = null;
assert(!funcGlobal);
var funcGlobalInit: funcref = null;
assert(!funcGlobalInit);

var externGlobal: externref;
assert(!externGlobal);
externGlobal = null;
assert(!externGlobal);
var externGlobalInit: externref = null;
assert(!externGlobalInit);

var anyGlobal: anyref;
assert(!anyGlobal);
anyGlobal = null;
assert(!anyGlobal);
var anyGlobalInit: anyref = null;
assert(!anyGlobalInit);

function testLocal<T>(): void {
  let local: T;
  assert(!local);
  local = null;
  assert(!local);
  let localInit: T = null;
  assert(!localInit);
}
testLocal<funcref>();
testLocal<externref>();
testLocal<anyref>();

// funcref can represent function references

function someFunc(): void {}
funcGlobal = someFunc;
assert(funcGlobalInit);
var otherFuncGlobal: funcref = someFunc;
assert(otherFuncGlobal);
{
  let funcLocal: funcref = someFunc;
  assert(funcLocal);
}

// can assign any reference type to anyref

anyGlobal = funcGlobal;

'''
'''--- tests/compiler/features/simd.json ---
{
  "features": [
    "simd"
  ],
  "asc_flags": [
  ],
  "skipInstantiate": true
}

'''
'''--- tests/compiler/features/simd.ts ---
// hint: asc tests/compiler/simd --enable simd

function test_v128(): void {
  // equality and inequality
  assert(
    v128(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)
    == // i8x16.all_true(i8x16.eq(lhs, rhs))
    v128(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)
  );
  assert(
    v128(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)
    != // i8x16.any_true(i8x16.ne(lhs, rhs))
    v128(2, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)
  );
  // bitwise
  assert(
    v128.and(
      v128(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16),
      v128(1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1 , 1 , 1 , 1 , 1 , 1)
    ) ==
      v128(1, 0, 1, 0, 1, 0, 1, 0, 1, 0 , 1 , 0 , 1 , 0 , 1 , 0)
  );
  assert(
    v128.or(
      v128(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16),
      v128(1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1 , 1 , 1 , 1 , 1 , 1)
    ) ==
      v128(1, 3, 3, 5, 5, 7, 7, 9, 9, 11, 11, 13, 13, 15, 15, 17)
  );
  assert(
    v128.xor(
      v128(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16),
      v128(1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1 , 1 , 1 , 1 , 1 , 1)
    ) ==
      v128(0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 17)
  );
  assert(
    v128.not(
      v128(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)
    ) ==
      v128(-2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17)
  );
  assert(
    v128.bitselect(
      v128(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16),
      v128(16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1),
      v128(0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1),
    ) ==
      v128(16, 2, 14, 4, 12, 6, 10, 8, 8, 10, 6, 12, 4, 14, 2, 16),
  );
  {
    let ptr = __alloc(64);
    v128.store(ptr, v128.load(ptr, 16), 32);
    __free(ptr);
  }
  {
    let ptr = __alloc(16);
    store<u8>(ptr, 42);
    assert(
      v128.load8_splat(ptr)
      ==
      v128(42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42)
    );
    __free(ptr);
  }
  {
    let ptr = __alloc(16);
    store<u16>(ptr, 42);
    assert(
      v128.load16_splat(ptr)
      ==
      v128(42, 0, 42, 0, 42, 0, 42, 0, 42, 0, 42, 0, 42, 0, 42, 0)
    );
    __free(ptr);
  }
  {
    let ptr = __alloc(16);
    store<u32>(ptr, 42);
    assert(
      v128.load32_splat(ptr)
      ==
      v128(42, 0, 0, 0, 42, 0, 0, 0, 42, 0, 0, 0, 42, 0, 0, 0)
    );
    __free(ptr);
  }
  {
    let ptr = __alloc(16);
    store<u64>(ptr, 42);
    assert(
      v128.load64_splat(ptr)
      ==
      v128(42, 0, 0, 0, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0)
    );
    __free(ptr);
  }
  {
    let ptr = __alloc(16);
    store<u32>(ptr, 42);
    assert(
      v128.load32_zero(ptr)
      ==
      v128(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 0, 0, 0)
    );
    __free(ptr);
  }
  {
    let ptr = __alloc(16);
    store<u64>(ptr, 42);
    assert(
      v128.load64_zero(ptr)
      ==
      v128(0, 0, 0, 0, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0)
    );
    __free(ptr);
  }
  // TODO: missing C-API in Binaryen (see also passes/pass.ts)
  // v128.load8_lane
  // v128.load16_lane
  // v128.load32_lane
  // v128.load64_lane
  // v128.store8_lane
  // v128.store16_lane
  // v128.store32_lane
  // v128.store64_lane

  // generic operations are tested by the aliases below already
}

function test_i8x16(): void {
  var a = i8x16(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 127);
  assert(a == v128(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 127));
  var b = i8x16.splat(1);
  assert(b == v128(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1));
  var c = i8x16.add(a, b);
  assert(c == i8x16(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, -128));
  assert(i8x16.sub(c, b) == a);
  assert(
    i8x16.min_s(
      i8x16(0, 127, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
      i8x16(-128, 0, -128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    )
    ==
    i8x16(-128, 0, -128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  );
  assert(
    i8x16.min_u(
      i8x16(0, 127, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
      i8x16(-128, 0, -128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    )
    ==
    i8x16(0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  );
  assert(
    i8x16.max_s(
      i8x16(0, 127, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
      i8x16(-128, 0, -128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    )
    ==
    i8x16(0, 127, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  );
  assert(
    i8x16.max_u(
      i8x16(0, 127, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
      i8x16(-128, 0, -128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    )
    ==
    i8x16(-128, 127, -128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  );
  assert(
    i8x16.avgr_u(
      i8x16(1, 2, 4, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, <u8>0x80, <u8>0xFF),
      i8x16(1, 4, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, <u8>0x80, <u8>0xFF)
    )
    ==
    i8x16(1, 3, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, <u8>0x80, <u8>0xFF)
  );
  assert(
    i8x16.neg(a)
    ==
    i8x16(-1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -127)
  );
  assert(i8x16.extract_lane_s(c, 0) == 2);
  assert(i8x16.extract_lane_s(c, 15) == -128);
  assert(i8x16.extract_lane_u(c, 15) == 128);
  assert(
    i8x16.replace_lane(c, 15, 17)
    ==
    i8x16(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17)
  );
  assert(
    v128.shuffle<i8>(a, b, 0, 1, 2, 3, 4, 5, 6, 7, 24, 25, 26, 27, 28, 29, 30, 31)
    ==
    i8x16(1, 2, 3, 4, 5, 6, 7, 8, 1, 1, 1, 1, 1, 1, 1, 1)
  );
  assert(
    i8x16.add_sat_s(
      i8x16(126, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127),
      i8x16.splat(2)
    ) == i8x16.splat(127)
  );
  assert(
    i8x16.add_sat_u(
      i8x16(-2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1),
      i8x16.splat(2)
    ) == i8x16.splat(-1)
  );
  assert(
    i8x16.sub_sat_s(
      i8x16(-127, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128),
      i8x16.splat(2)
    ) == i8x16.splat(-128)
  );
  assert(
    i8x16.sub_sat_u(
      i8x16(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
      i8x16.splat(2)
    ) == i8x16.splat(0)
  );
  assert(i8x16.shl(i8x16.splat(1), 1) == i8x16.splat(2));
  assert(i8x16.shr_s(i8x16.splat(-2), 1) == i8x16.splat(-1));
  assert(i8x16.shr_u(i8x16.splat(-1), 1) == i8x16.splat(127));
  assert(v128.any_true(i8x16(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)) == true);
  assert(i8x16.all_true(i8x16.splat(1)) == true);
  var one = i8x16.replace_lane(i8x16.splat(0), 0, 1);
  var negOne = i8x16.replace_lane(i8x16.splat(0), 0, -1);
  var only1st = negOne;
  var excl1st = v128.not(negOne);
  assert(i8x16.eq(negOne, one) == excl1st);
  assert(i8x16.ne(negOne, one) == only1st);
  assert(i8x16.lt_s(negOne, one) == only1st);
  assert(i8x16.lt_u(one, negOne) == only1st);
  assert(i8x16.le_s(one, negOne) == excl1st);
  assert(i8x16.le_u(negOne, one) == excl1st);
  assert(i8x16.gt_s(one, negOne) == only1st);
  assert(i8x16.gt_u(negOne, one) == only1st);
  assert(i8x16.ge_s(negOne, one) == excl1st);
  assert(i8x16.ge_u(one, negOne) == excl1st);
  assert(i8x16.narrow_i16x8_s(i16x8.splat(i16.MAX_VALUE), i16x8.splat(i16.MAX_VALUE)) == i8x16.splat(i8.MAX_VALUE));
  assert(i8x16.narrow_i16x8_u(i16x8.splat(i16.MAX_VALUE), i16x8.splat(i16.MAX_VALUE)) == i8x16.splat(u8.MAX_VALUE));
  {
    let a = v128( 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15);
    let b = v128(16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31);
    assert(
      i8x16.shuffle(a, b, 0, 17, 2, 19, 4, 21, 6, 23, 8, 25, 10, 27, 12, 29, 14, 31)
      ==
      v128(0, 17, 2, 19, 4, 21, 6, 23, 8, 25, 10, 27, 12, 29, 14, 31)
    );
    let c = v128(16, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0);
    assert(
      i8x16.swizzle(a, c)
      ==
      v128(0, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
    );
  }
  assert(i8x16.popcnt(a) == v128(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4));
}

function test_i16x8(): void {
  var a = i16x8(1, 2, 3, 4, 5, 6, 7, 32767);
  assert(a == v128(1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0, -1, 127));
  var b = i16x8.splat(1);
  assert(b == v128(1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0));
  var c = i16x8.add(a, b);
  assert(c == i16x8(2, 3, 4, 5, 6, 7, 8, -32768));
  assert(i16x8.sub(c, b) == a);
  assert(i16x8.mul(c, b) == c);
  assert(
    i16x8.min_s(
      i16x8(0, 32767, 32767, 0, 0, 0, 0, 0),
      i16x8(-32768, 0, -32768, 0, 0, 0, 0, 0)
    )
    ==
    i16x8(-32768, 0, -32768, 0, 0, 0, 0, 0)
  );
  assert(
    i16x8.min_u(
      i16x8(0, 32767, 32767, 0, 0, 0, 0, 0),
      i16x8(-32768, 0, -32768, 0, 0, 0, 0, 0)
    )
    ==
    i16x8(0, 0, 32767, 0, 0, 0, 0, 0)
  );
  assert(
    i16x8.max_s(
      i16x8(0, 32767, 32767, 0, 0, 0, 0, 0),
      i16x8(-32768, 0, -32768, 0, 0, 0, 0, 0)
    )
    ==
    i16x8(0, 32767, 32767, 0, 0, 0, 0, 0)
  );
  assert(
    i16x8.max_u(
      i16x8(0, 32767, 32767, 0, 0, 0, 0, 0),
      i16x8(-32768, 0, -32768, 0, 0, 0, 0, 0)
    )
    ==
    i16x8(-32768, 32767, -32768, 0, 0, 0, 0, 0)
  );
  assert(
    i16x8.avgr_u(
      i16x8(1, 2, 4, 4, 5, 6, <u16>0x8000, <u16>0xFFFF),
      i16x8(1, 4, 2, 4, 5, 6, <u16>0x8000, <u16>0xFFFF)
    )
    ==
    i16x8(1, 3, 3, 4, 5, 6, <u16>0x8000, <u16>0xFFFF)
  );
  assert(
    i16x8.neg(a)
    ==
    i16x8(-1, -2, -3, -4, -5, -6, -7, -32767)
  );
  assert(i16x8.extract_lane_s(c, 0) == 2);
  assert(i16x8.extract_lane_s(c, 7) == -32768);
  assert(i16x8.extract_lane_u(c, 7) == 32768);
  assert(
    i16x8.replace_lane(c, 7, 9)
    ==
    i16x8(2, 3, 4, 5, 6, 7, 8, 9)
  );
  assert(
    v128.shuffle<i16>(a, b, 0, 1, 2, 3, 12, 13, 14, 15)
    ==
    i16x8(1, 2, 3, 4, 1, 1, 1, 1)
  );
  assert(
    i16x8.add_sat_s(
      i16x8(32766, 32767, 32767, 32767, 32767, 32767, 32767, 32767),
      i16x8.splat(2)
    ) == i16x8.splat(32767)
  );
  assert(
    i16x8.add_sat_u(
      i16x8(-2, -1, -1, -1, -1, -1, -1, -1),
      i16x8.splat(2)
    ) == i16x8.splat(-1)
  );
  assert(
    i16x8.sub_sat_s(
      i16x8(-32767, -32768, -32768, -32768, -32768, -32768, -32768, -32768),
      i16x8.splat(2)
    ) == i16x8.splat(-32768)
  );
  assert(
    i16x8.sub_sat_u(
      i16x8(1, 0, 0, 0, 0, 0, 0, 0),
      i16x8.splat(2)
    ) == i16x8.splat(0)
  );
  assert(i16x8.shl(i16x8.splat(1), 1) == i16x8.splat(2));
  assert(i16x8.shr_s(i16x8.splat(-2), 1) == i16x8.splat(-1));
  assert(i16x8.shr_u(i16x8.splat(-1), 1) == i16x8.splat(32767));
  assert(v128.any_true(i16x8(1, 0, 0, 0, 0, 0, 0, 0)) == true);
  assert(i16x8.all_true(i16x8.splat(1)) == true);
  var one = i16x8.replace_lane(i16x8.splat(0), 0, 1);
  var negOne = i16x8.replace_lane(i16x8.splat(0), 0, -1);
  var only1st = negOne;
  var excl1st = v128.not(negOne);
  assert(i16x8.eq(negOne, one) == excl1st);
  assert(i16x8.ne(negOne, one) == only1st);
  assert(i16x8.lt_s(negOne, one) == only1st);
  assert(i16x8.lt_u(one, negOne) == only1st);
  assert(i16x8.le_s(one, negOne) == excl1st);
  assert(i16x8.le_u(negOne, one) == excl1st);
  assert(i16x8.gt_s(one, negOne) == only1st);
  assert(i16x8.gt_u(negOne, one) == only1st);
  assert(i16x8.ge_s(negOne, one) == excl1st);
  assert(i16x8.ge_u(one, negOne) == excl1st);
  assert(i16x8.narrow_i32x4_s(i32x4.splat(i32.MAX_VALUE), i32x4.splat(i32.MAX_VALUE)) == i16x8.splat(i16.MAX_VALUE));
  assert(i16x8.narrow_i32x4_u(i32x4.splat(i32.MAX_VALUE), i32x4.splat(i32.MAX_VALUE)) == i16x8.splat(u16.MAX_VALUE));
  assert(i16x8.extend_low_i8x16_s(i8x16.replace_lane(i8x16.splat(-1), 8, 0)) == i16x8.splat(-1));
  assert(i16x8.extend_low_i8x16_u(i8x16.replace_lane(i8x16.splat(-1), 8, 0)) == i16x8.splat(255));
  assert(i16x8.extend_high_i8x16_s(i8x16.replace_lane(i8x16.splat(-1), 0, 0)) == i16x8.splat(-1));
  assert(i16x8.extend_high_i8x16_u(i8x16.replace_lane(i8x16.splat(-1), 0, 0)) == i16x8.splat(255));
  {
    let ptr = __alloc(16);
    store<i8>(ptr, 1);
    store<i8>(ptr, 2, 1);
    store<i8>(ptr, 3, 2);
    store<i8>(ptr, 4, 3);
    store<i8>(ptr, 5, 4);
    store<i8>(ptr, 6, 5);
    store<i8>(ptr, 7, 6);
    store<i8>(ptr, -1, 7);
    assert(
      v128.load8x8_s(ptr)
      ==
      v128(1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0, -1, -1)
    );
    assert(
      v128.load8x8_u(ptr)
      ==
      v128(1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0, -1, 0)
    );
    __free(ptr);
  }
  assert(i16x8.q15mulr_sat_s(
    i16x8(-1, -16383, 32765, <i16>65535, -32768, <i16>65535, -16385, -32768),
    i16x8(-1, -16384,     1,     -32768, -32768,          1, -16384,    -10)
  ) == i16x8(0, 8192, 1, 1, 32767, 0, 8193, 1));

  // TODO: unimp in Binaryen's interpreter
  i16x8.extadd_pairwise_i8x16_s(a);
  i16x8.extadd_pairwise_i8x16_u(a);
  i16x8.extmul_low_i8x16_s(a, a);
  i16x8.extmul_low_i8x16_u(a, a);
  i16x8.extmul_high_i8x16_s(a, a);
  i16x8.extmul_high_i8x16_u(a, a);
}

function test_i32x4(): void {
  var a = i32x4(1, 2, 3, 2147483647);
  assert(a == v128(1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, -1, -1, -1, 127));
  var b = i32x4.splat(1);
  assert(b == v128(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0));
  var c = i32x4.add(a, b);
  assert(c == i32x4(2, 3, 4, -2147483648));
  assert(i32x4.sub(c, b) == a);
  assert(i32x4.mul(c, b) == c);
  assert(
    i32x4.min_s(
      i32x4(0, 2147483647, 2147483647, 0),
      i32x4(-2147483648, 0, -2147483648, 0)
    )
    ==
    i32x4(-2147483648, 0, -2147483648, 0)
  );
  assert(
    i32x4.min_u(
      i32x4(0, 2147483647, 2147483647, 0),
      i32x4(-2147483648, 0, -2147483648, 0)
    )
    ==
    i32x4(0, 0, 2147483647, 0)
  );
  assert(
    i32x4.max_s(
      i32x4(0, 2147483647, 2147483647, 0),
      i32x4(-2147483648, 0, -2147483648, 0)
    )
    ==
    i32x4(0, 2147483647, 2147483647, 0)
  );
  assert(
    i32x4.max_u(
      i32x4(0, 2147483647, 2147483647, 0),
      i32x4(-2147483648, 0, -2147483648, 0)
    )
    ==
    i32x4(-2147483648, 2147483647, -2147483648, 0)
  );
  assert(
    i32x4.dot_i16x8_s(
      i16x8(1, 2, 3, 4, -1, 3, 0, 0),
      i16x8(5, 6, 7, 8, 2, -1, 0, 0),
    )
    ==
    i32x4(17, 53, -5, 0)
  );
  assert(
    i32x4.neg(a)
    ==
    i32x4(-1, -2, -3, -2147483647)
  );
  assert(i32x4.extract_lane(c, 0) == 2);
  assert(i32x4.extract_lane(c, 3) == -2147483648);
  assert(
    i32x4.replace_lane(c, 3, 5)
    ==
    i32x4(2, 3, 4, 5)
  );
  assert(
    v128.shuffle<i32>(a, b, 0, 1, 6, 7)
    ==
    i32x4(1, 2, 1, 1)
  );
  assert(i32x4.shl(i32x4.splat(1), 1) == i32x4.splat(2));
  assert(i32x4.shr_s(i32x4.splat(-2), 1) == i32x4.splat(-1));
  assert(i32x4.shr_u(i32x4.splat(-1), 1) == i32x4.splat(2147483647));
  assert(v128.any_true(i32x4(1, 0, 0, 0)) == true);
  assert(i32x4.all_true(i32x4.splat(1)) == true);
  var one = i32x4.replace_lane(i32x4.splat(0), 0, 1);
  var negOne = i32x4.replace_lane(i32x4.splat(0), 0, -1);
  var only1st = negOne;
  var excl1st = v128.not(negOne);
  assert(i32x4.eq(negOne, one) == excl1st);
  assert(i32x4.ne(negOne, one) == only1st);
  assert(i32x4.lt_s(negOne, one) == only1st);
  assert(i32x4.lt_u(one, negOne) == only1st);
  assert(i32x4.le_s(one, negOne) == excl1st);
  assert(i32x4.le_u(negOne, one) == excl1st);
  assert(i32x4.gt_s(one, negOne) == only1st);
  assert(i32x4.gt_u(negOne, one) == only1st);
  assert(i32x4.ge_s(negOne, one) == excl1st);
  assert(i32x4.ge_u(one, negOne) == excl1st);
  assert(
    i32x4.trunc_sat_f32x4_s(f32x4.splat(-1.5))
    ==
    i32x4.splat(-1)
  );
  assert(
    i32x4.trunc_sat_f32x4_u(f32x4.splat(-1.5))
    ==
    i32x4.splat(0)
  );
  assert(i32x4.extend_low_i16x8_s(i16x8.replace_lane(i16x8.splat(-1), 4, 0)) == i32x4.splat(-1));
  assert(i32x4.extend_low_i16x8_u(i16x8.replace_lane(i16x8.splat(-1), 4, 0)) == i32x4.splat(65535));
  assert(i32x4.extend_high_i16x8_s(i16x8.replace_lane(i16x8.splat(-1), 0, 0)) == i32x4.splat(-1));
  assert(i32x4.extend_high_i16x8_u(i16x8.replace_lane(i16x8.splat(-1), 0, 0)) == i32x4.splat(65535));
  {
    let ptr = __alloc(16);
    store<i16>(ptr, 1);
    store<i16>(ptr, 2, 2);
    store<i16>(ptr, 3, 4);
    store<i16>(ptr, -1, 6);
    assert(
      v128.load16x4_s(ptr)
      ==
      v128(1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, -1, -1, -1, -1)
    );
    assert(
      v128.load16x4_u(ptr)
      ==
      v128(1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, -1, -1, 0, 0)
    );
    __free(ptr);
  }

  // TODO: unimp in Binaryen's interpreter
  i32x4.extadd_pairwise_i16x8_s(a);
  i32x4.extadd_pairwise_i16x8_u(a);
  i32x4.trunc_sat_f64x2_s_zero(a);
  i32x4.trunc_sat_f64x2_u_zero(a);
  i32x4.extmul_low_i16x8_s(a, a);
  i32x4.extmul_low_i16x8_u(a, a);
  i32x4.extmul_high_i16x8_s(a, a);
  i32x4.extmul_high_i16x8_u(a, a);
}

function test_i64x2(): void {
  var a = i64x2(1, 9223372036854775807);
  assert(a == v128(1, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, 127));
  var b = i64x2.splat(1);
  assert(b == v128(1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0));
  var c = i64x2.add(a, b);
  assert(c == i64x2(2, -9223372036854775808));
  assert(i64x2.sub(c, b) == a);
  assert(i64x2.mul(c, b) == c);
  assert(
    i64x2.neg(a)
    ==
    i64x2(-1, -9223372036854775807)
  );
  assert(i64x2.extract_lane(c, 0) == 2);
  assert(i64x2.extract_lane(c, 1) == -9223372036854775808);
  assert(
    i64x2.replace_lane(c, 1, 3)
    ==
    i64x2(2, 3)
  );
  assert(
    v128.shuffle<i64>(a, b, 0, 3)
    ==
    i64x2(1, 1)
  );
  assert(i64x2.shl(i64x2.splat(1), 1) == i64x2.splat(2));
  assert(i64x2.shr_s(i64x2.splat(-2), 1) == i64x2.splat(-1));
  assert(i64x2.shr_u(i64x2.splat(-1), 1) == i64x2.splat(9223372036854775807));
  assert(v128.any_true(i64x2(1, 0)) == true);
  assert(i64x2.all_true(i64x2.splat(1)) == true);
  {
    let ptr = __alloc(16);
    store<i32>(ptr, 1);
    store<i32>(ptr, -1, 4);
    assert(
      v128.load32x2_s(ptr)
      ==
      v128(1, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1)
    );
    assert(
      v128.load32x2_u(ptr)
      ==
      v128(1, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1, 0, 0, 0, 0)
    );
    __free(ptr);
  }
  // TODO: unimp in Binaryen's interpreter
  i64x2.extmul_low_i32x4_s(a, a);
  i64x2.extmul_low_i32x4_u(a, a);
  i64x2.extmul_high_i32x4_s(a, a);
  i64x2.extmul_high_i32x4_u(a, a);
}

function test_f32x4(): void {
  var a = f32x4(1.5, 2.5, 3.5, 4.5);
  assert(a == v128(0, 0, -64, 63, 0, 0, 32, 64, 0, 0, 96, 64, 0, 0, -112, 64));
  var b = f32x4.splat(1.0);
  assert(b == v128(0, 0, -128, 63, 0, 0, -128, 63, 0, 0, -128, 63, 0, 0, -128, 63));
  var c = f32x4.add(a, b);
  assert(c == f32x4(2.5, 3.5, 4.5, 5.5));
  assert(f32x4.sub(c, b) == a);
  assert(f32x4.mul(c, b) == c);
  var d = f32x4.mul(a, a);
  assert(f32x4.div(d, a) == a);
  assert(f32x4.mul(d, a) != a);
  assert(f32x4.neg(a) == f32x4(-1.5, -2.5, -3.5, -4.5));
  assert(f32x4.extract_lane(c, 0) == 2.5);
  assert(f32x4.extract_lane(c, 3) == 5.5);
  assert(
    f32x4.replace_lane(c, 3, 6.5)
    ==
    f32x4(2.5, 3.5, 4.5, 6.5)
  );
  assert(
    v128.shuffle<f32>(a, b, 0, 1, 6, 7)
    ==
    f32x4(1.5, 2.5, 1.0, 1.0)
  );
  var one = f32x4.replace_lane(f32x4.splat(0), 0, 1);
  var negOne = f32x4.replace_lane(f32x4.splat(0), 0, -1);
  var only1st = i32x4(-1, 0, 0, 0);
  var excl1st = i32x4(0, -1, -1, -1);
  assert(f32x4.eq(negOne, one) == excl1st);
  assert(f32x4.ne(negOne, one) == only1st);
  assert(f32x4.lt(negOne, one) == only1st);
  assert(f32x4.le(one, negOne) == excl1st);
  assert(f32x4.gt(one, negOne) == only1st);
  assert(f32x4.ge(negOne, one) == excl1st);
  assert(f32x4.min(negOne, one) == negOne);
  assert(f32x4.max(negOne, one) == one);
  assert(f32x4.abs(negOne) == one);
  assert(f32x4.sqrt(f32x4(4.0, 9.0, 16.0, 25.0)) == f32x4(2.0, 3.0, 4.0, 5.0));
  assert(
    f32x4.convert_i32x4_s(i32x4.splat(-1))
    ==
    f32x4.splat(-1.0)
  );
  assert(
    f32x4.convert_i32x4_u(i32x4.splat(-1))
    ==
    f32x4.splat(4294967296.0)
  );

  // TODO: unimp in Binaryen's interpreter
  f32x4.demote_f64x2_zero(a);
}

function test_f64x2(): void {
  var a = f64x2(1.5, 2.5);
  assert(a == v128(0, 0, 0, 0, 0, 0, -8, 63, 0, 0, 0, 0, 0, 0, 4, 64));
  var b = f64x2.splat(1.0);
  assert(b == v128(0, 0, 0, 0, 0, 0, -16, 63, 0, 0, 0, 0, 0, 0, -16, 63));
  var c = f64x2.add(a, b);
  assert(c == f64x2(2.5, 3.5));
  assert(f64x2.sub(c, b) == a);
  assert(f64x2.mul(c, b) == c);
  var d = f64x2.mul(a, a);
  assert(f64x2.div(d, a) == a);
  assert(f64x2.mul(d, a) != a);
  assert(f64x2.neg(a) == f64x2(-1.5, -2.5));
  assert(f64x2.extract_lane(c, 0) == 2.5);
  assert(f64x2.extract_lane(c, 1) == 3.5);
  assert(
    f64x2.replace_lane(c, 1, 4.5)
    ==
    f64x2(2.5, 4.5)
  );
  assert(
    v128.shuffle<f64>(a, b, 0, 3)
    ==
    f64x2(1.5, 1.0)
  );
  var one = f64x2.replace_lane(f64x2.splat(0), 0, 1);
  var negOne = f64x2.replace_lane(f64x2.splat(0), 0, -1);
  var only1st = i64x2(-1, 0);
  var excl1st = i64x2(0, -1);
  assert(f64x2.eq(negOne, one) == excl1st);
  assert(f64x2.ne(negOne, one) == only1st);
  assert(f64x2.lt(negOne, one) == only1st);
  assert(f64x2.le(one, negOne) == excl1st);
  assert(f64x2.gt(one, negOne) == only1st);
  assert(f64x2.ge(negOne, one) == excl1st);
  assert(f64x2.min(negOne, one) == negOne);
  assert(f64x2.max(negOne, one) == one);
  assert(f64x2.abs(negOne) == one);
  assert(f64x2.sqrt(f64x2(4.0, 9.0)) == f64x2(2.0, 3.0));

  // TODO: unimp in Binaryen's interpreter
  f64x2.convert_low_i32x4_s(a);
  f64x2.convert_low_i32x4_u(a);
  f64x2.promote_low_f32x4(a);
}

function test_const(): v128 {
  const one = i32x4.splat(1); // should precompute
  return one;                 // should not inline
}

if (ASC_FEATURE_SIMD) {
  test_v128();
  test_i8x16();
  test_i16x8();
  test_i32x4();
  test_i64x2();
  test_f32x4();
  test_f64x2();
  test_const();
}

'''
'''--- tests/compiler/features/threads.json ---
{
  "features": [
    "threads"
  ],
  "asc_flags": [
    "--memoryBase 8",
    "--maximumMemory 10",
    "--sharedMemory"
  ]
}

'''
'''--- tests/compiler/features/threads.ts ---
function testAtomic(): void {
  atomic.load<u8>(0);                     // i32.atomic.load8_u
  atomic.load<u16>(0);                    // i32.atomic.load16_u
  atomic.load<u32>(0);                    // i32.atomic.load
  <u64>atomic.load<u8>(0);                // i64.atomic.load8_u
  <u64>atomic.load<u16>(0);               // i64.atomic.load16_u
  <u64>atomic.load<u32>(0);               // i64.atomic.load32_u
  atomic.load<u64>(0);                    // i64.atomic.load
  atomic.load<u64>(0, 8);                 // with offset

  atomic.store<u8>(0, 1);                 // i32.atomic.store8
  atomic.store<u16>(0, 1);                // i32.atomic.store16
  atomic.store<u32>(0, 1);                // i32.atomic.store
  atomic.store<u8>(0, <u64>1);            // i64.atomic.store8
  atomic.store<u16>(0, <u64>1);           // i64.atomic.store16
  atomic.store<u32>(0, <u64>1);           // i64.atomic.store32
  atomic.store<u64>(0, 1);                // i64.atomic.store
  atomic.store<u64>(0, 1, 8);             // with offset

  atomic.add<u8>(0, 1);                   // i32.atomic.rmw8.add_u
  atomic.add<u16>(0, 1);                  // i32.atomic.rmw16.add_u
  atomic.add<u32>(0, 1);                  // i32.atomic.rmw.add
  atomic.add<u8>(0, <u64>1);              // i64.atomic.rmw8.add_u
  atomic.add<u16>(0, <u64>1);             // i64.atomic.rmw16.add_u
  atomic.add<u32>(0, <u64>1);             // i64.atomic.rmw32.add_u
  atomic.add<u64>(0, 1);                  // i64.atomic.rmw.add
  atomic.add<u64>(0, 1, 8);               // with offset

  atomic.sub<u8>(0, 1);                   // i32.atomic.rmw8.sub_u
  atomic.sub<u16>(0, 1);                  // i32.atomic.rmw16.sub_u
  atomic.sub<u32>(0, 1);                  // i32.atomic.rmw.sub
  atomic.sub<u8>(0, <u64>1);              // i64.atomic.rmw8.sub_u
  atomic.sub<u16>(0, <u64>1);             // i64.atomic.rmw16.sub_u
  atomic.sub<u32>(0, <u64>1);             // i64.atomic.rmw32.sub_u
  atomic.sub<u64>(0, 1);                  // i64.atomic.rmw.sub
  atomic.sub<u64>(0, 1, 8);               // with offset

  atomic.and<u8>(0, 1);                   // i32.atomic.rmw8.and_u
  atomic.and<u16>(0, 1);                  // i32.atomic.rmw16.and_u
  atomic.and<u32>(0, 1);                  // i32.atomic.rmw.and
  atomic.and<u8>(0, <u64>1);              // i64.atomic.rmw8.and_u
  atomic.and<u16>(0, <u64>1);             // i64.atomic.rmw16.and_u
  atomic.and<u32>(0, <u64>1);             // i64.atomic.rmw32.and_u
  atomic.and<u64>(0, 1);                  // i64.atomic.rmw.and
  atomic.and<u64>(0, 1, 8);               // with offset

  atomic.or<u8>(0, 1);                    // i32.atomic.rmw8.or_u
  atomic.or<u16>(0, 1);                   // i32.atomic.rmw16.or_u
  atomic.or<u32>(0, 1);                   // i32.atomic.rmw.or
  atomic.or<u8>(0, <u64>1);               // i64.atomic.rmw8.or_u
  atomic.or<u16>(0, <u64>1);              // i64.atomic.rmw16.or_u
  atomic.or<u32>(0, <u64>1);              // i64.atomic.rmw32.or_u
  atomic.or<u64>(0, 1);                   // i64.atomic.rmw.or
  atomic.or<u64>(0, 1, 8);                // with offset

  atomic.xor<u8>(0, 1);                   // i32.atomic.rmw8.xor_u
  atomic.xor<u16>(0, 1);                  // i32.atomic.rmw16.xor_u
  atomic.xor<u32>(0, 1);                  // i32.atomic.rmw.xor
  atomic.xor<u8>(0, <u64>1);              // i64.atomic.rmw8.xor_u
  atomic.xor<u16>(0, <u64>1);             // i64.atomic.rmw16.xor_u
  atomic.xor<u32>(0, <u64>1);             // i64.atomic.rmw32.xor_u
  atomic.xor<u64>(0, 1);                  // i64.atomic.rmw.xor
  atomic.xor<u64>(0, 1, 8);               // with offset

  atomic.xchg<u8>(0, 1);                  // i32.atomic.rmw8.xchg_u
  atomic.xchg<u16>(0, 1);                 // i32.atomic.rmw16.xchg_u
  atomic.xchg<u32>(0, 1);                 // i32.atomic.rmw.xchg
  atomic.xchg<u8>(0, <u64>1);             // i64.atomic.rmw8.xchg_u
  atomic.xchg<u16>(0, <u64>1);            // i64.atomic.rmw16.xchg_u
  atomic.xchg<u32>(0, <u64>1);            // i64.atomic.rmw32.xchg_u
  atomic.xchg<u64>(0, 1);                 // i64.atomic.rmw.xchg
  atomic.xchg<u64>(0, 1, 8);              // with offset

  atomic.cmpxchg<u8>(0, 1, 2);            // i32.atomic.rmw8.xchg_u
  atomic.cmpxchg<u16>(0, 1, 2);           // i32.atomic.rmw16.xchg_u
  atomic.cmpxchg<u32>(0, 1, 2);           // i32.atomic.rmw.xchg
  atomic.cmpxchg<u8>(0, <u64>1, 2);       // i64.atomic.rmw8.xchg_u
  atomic.cmpxchg<u16>(0, <u64>1, 2);      // i64.atomic.rmw16.xchg_u
  atomic.cmpxchg<u32>(0, <u64>1, 2);      // i64.atomic.rmw32.xchg_u
  atomic.cmpxchg<u64>(0, 1, 2);           // i64.atomic.rmw.xchg
  atomic.cmpxchg<u64>(0, 1, 2, 8);        // with offset

  // atomic.wait<i32>(0, 0, -1);          // i32.atomic.wait
  // atomic.wait<i64>(0, 0, -1);          // i64.atomic.wait
  // atomic.notify(0, 1);                 // atomic.notify

  // atomic.fence();                      // atomic.fence
}

function testAtomicAsm(): void {

  i32.atomic.load8_u(0);
  i32.atomic.load16_u(0);
  i32.atomic.load(0);
  i64.atomic.load8_u(0);
  i64.atomic.load16_u(0);
  i64.atomic.load32_u(0);
  i64.atomic.load(0);

  i32.atomic.store8(0, 1);
  i32.atomic.store16(0, 1);
  i32.atomic.store(0, 1);
  i64.atomic.store8(0, 1);
  i64.atomic.store16(0, 1);
  i64.atomic.store32(0, 1);
  i64.atomic.store(0, 1);

  i32.atomic.rmw8.add_u(0, 1);
  i32.atomic.rmw16.add_u(0, 1);
  i32.atomic.rmw.add(0, 1);
  i64.atomic.rmw8.add_u(0, 1);
  i64.atomic.rmw16.add_u(0, 1);
  i64.atomic.rmw32.add_u(0, 1);
  i64.atomic.rmw.add(0, 1);

  i32.atomic.rmw8.sub_u(0, 1);
  i32.atomic.rmw16.sub_u(0, 1);
  i32.atomic.rmw.sub(0, 1);
  i64.atomic.rmw8.sub_u(0, 1);
  i64.atomic.rmw16.sub_u(0, 1);
  i64.atomic.rmw32.sub_u(0, 1);
  i64.atomic.rmw.sub(0, 1);

  i32.atomic.rmw8.and_u(0, 1);
  i32.atomic.rmw16.and_u(0, 1);
  i32.atomic.rmw.and(0, 1);
  i64.atomic.rmw8.and_u(0, 1);
  i64.atomic.rmw16.and_u(0, 1);
  i64.atomic.rmw32.and_u(0, 1);
  i64.atomic.rmw.and(0, 1);

  i32.atomic.rmw8.or_u(0, 1);
  i32.atomic.rmw16.or_u(0, 1);
  i32.atomic.rmw.or(0, 1);
  i64.atomic.rmw8.or_u(0, 1);
  i64.atomic.rmw16.or_u(0, 1);
  i64.atomic.rmw32.or_u(0, 1);
  i64.atomic.rmw.or(0, 1);

  i32.atomic.rmw8.xor_u(0, 1);
  i32.atomic.rmw16.xor_u(0, 1);
  i32.atomic.rmw.xor(0, 1);
  i64.atomic.rmw8.xor_u(0, 1);
  i64.atomic.rmw16.xor_u(0, 1);
  i64.atomic.rmw32.xor_u(0, 1);
  i64.atomic.rmw.xor(0, 1);

  i32.atomic.rmw8.xchg_u(0, 1);
  i32.atomic.rmw16.xchg_u(0, 1);
  i32.atomic.rmw.xchg(0, 1);
  i64.atomic.rmw8.xchg_u(0, 1);
  i64.atomic.rmw16.xchg_u(0, 1);
  i64.atomic.rmw32.xchg_u(0, 1);
  i64.atomic.rmw.xchg(0, 1);

  i32.atomic.rmw8.cmpxchg_u(0, 1, 2);
  i32.atomic.rmw16.cmpxchg_u(0, 1, 2);
  i32.atomic.rmw.cmpxchg(0, 1, 2);
  i64.atomic.rmw8.cmpxchg_u(0, 1, 2);
  i64.atomic.rmw16.cmpxchg_u(0, 1, 2);
  i64.atomic.rmw32.cmpxchg_u(0, 1, 2);
  i64.atomic.rmw.cmpxchg(0, 1, 2);

  // i32.atomic.wait(0, 0, -1);
  // i64.atomic.wait(0, 0, -1);
}

if (ASC_FEATURE_THREADS) {
  testAtomic();
  testAtomicAsm();
}

'''
'''--- tests/compiler/field-initialization-errors.json ---
{
  "asc_flags": [
  ],
  "stderr": [
    "TS2564: Property 'field-initialization-errors/Ref.a' has no initializer",
    "TS2564: Property 'field-initialization-errors/Ref_Ctor.a' has no initializer",
    "TS2564: Property 'field-initialization-errors/Ref_InlineCtor.a' has no initializer",
    "TS2564: Property 'field-initialization-errors/Ref_Ctor_Branch.a' has no initializer",
    "TS2565: Property 'field-initialization-errors/Ref_Ctor_Use_Init.a' is used before being assigned.",
    "TS2564: Property 'field-initialization-errors/Ref_Ctor_Call_Init.a' has no initializer",
    "TS2564: Property 'field-initialization-errors/Ref_Ctor_Prop_Init.a' has no initializer",
    "TS2564: Property 'field-initialization-errors/Ref_Ctor_Callwith_Init.a' has no initializer",
    "TS2564: Property 'field-initialization-errors/Ref_Ctor_Alias_Init.a' has no initializer",
    "TS2564: Property 'field-initialization-errors/Ref_Ctor_Assign_Init.a' has no initializer",
    "TS2564: Property 'field-initialization-errors/Ref_Ctor_Icallwith_Init.a' has no initializer",
    "TS2564: Property 'field-initialization-errors/Inherit_Base.a' has no initializer",
    "EOF"
  ]
}

'''
'''--- tests/compiler/field-initialization-errors.ts ---
// Uninitialized without ctor
class Ref {
  a: ArrayBuffer; // TS2564
}
{
  new Ref();
}

// Uninitialized with ctor
class Ref_Ctor {
  a: ArrayBuffer; // TS2564
  constructor() {
  }
}
{
  new Ref_Ctor();
}

// Uninitialized with inline ctor
class Ref_InlineCtor {
  a: ArrayBuffer; // TS2564
  @inline constructor() {
  }
}
{
  new Ref_InlineCtor();
}

// Uninitialized in any branch
class Ref_Ctor_Branch {
  a: ArrayBuffer; // TS2564
  constructor(cond: bool) {
    if (cond) {
      this.a = new ArrayBuffer(0);
    } else {
      // uninitialized
    }
  }
}
{
  new Ref_Ctor_Branch(true);
}

// Access before initialize
class Ref_Ctor_Use_Init {
  a: ArrayBuffer;
  constructor() {
    this.a; // TS2565
    this.a = new ArrayBuffer(0);
  }
}
{
  new Ref_Ctor_Use_Init();
}

// Call before initialize
class Ref_Ctor_Call_Init {
  a: ArrayBuffer;
  constructor() {
    this.foo();
    this.a = new ArrayBuffer(0);
  }
  foo(): void {}
}
{
  new Ref_Ctor_Call_Init();
}

// Property (call) before initialize
class Ref_Ctor_Prop_Init {
  a: ArrayBuffer;
  constructor() {
    this.foo;
    this.a = new ArrayBuffer(0);
  }
  get foo(): i32 { return 1; }
}
{
  new Ref_Ctor_Prop_Init();
}

// Called with before initialize
class Ref_Ctor_Callwith_Init {
  a: ArrayBuffer;
  constructor() {
    Ref_Ctor_Callwith_Init.foo(this);
    this.a = new ArrayBuffer(0);
  }
  static foo(o: Ref_Ctor_Callwith_Init): void {}
}
{
  new Ref_Ctor_Callwith_Init();
}

// Aliase before initialize
class Ref_Ctor_Alias_Init {
  a: ArrayBuffer;
  constructor() {
    var b = this;
    this.a = new ArrayBuffer(0);
  }
}
{
  new Ref_Ctor_Alias_Init();
}

// Assignment before initialize
class Ref_Ctor_Assign_Init {
  a: ArrayBuffer;
  constructor() {
    var b: this;
    b = this;
    this.a = new ArrayBuffer(0);
  }
}
{
  new Ref_Ctor_Assign_Init();
}

// Indirectly called with before initialize
class Ref_Ctor_Icallwith_Init {
  a: ArrayBuffer;
  constructor() {
    Ref_Ctor_Icallwith_Init_fn(this);
    this.a = new ArrayBuffer(0);
  }
}
var Ref_Ctor_Icallwith_Init_fn = (o: Ref_Ctor_Icallwith_Init): void => {};
{
  new Ref_Ctor_Icallwith_Init();
}

// Uninitialized inherited
class Inherit_Base {
  a: ArrayBuffer; // TS2564
}
class Inherit extends Inherit_Base {
}
{
  new Inherit();
}

ERROR("EOF");

'''
'''--- tests/compiler/field-initialization-warnings.json ---
{
  "asc_flags": [
  ],
  "stderr": [
    "AS906: Unnecessary definite assignment.",
    "AS233: Property 'field-initialization-warnings/Ref_Ctor_Init.a' is always assigned",
    "EOF"
  ]
}

'''
'''--- tests/compiler/field-initialization-warnings.ts ---
// non-reference is unnecessary
class Nonref {
  a!: i32;
}
{
  new Nonref();
}

// always assigned
class Ref_Ctor_Init {
  a!: string;
  constructor() {
    this.a = "a";
  }
}
{
  var o = new Ref_Ctor_Init();
  assert(o.a == "a");
}

ERROR("EOF");

'''
'''--- tests/compiler/field-initialization.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/field-initialization.ts ---
// without constructor

class Value_Init {
  a: i32 = 1; // OK
}
{
  let o = new Value_Init();
  assert(o.a == 1);
}

class Value {
  a: i32; // OK (zeroed)
}
{
  let o = new Value();
  assert(o.a == 0);
}

class Ref_Init {
  a: ArrayBuffer = new ArrayBuffer(0); // OK
}
{
  let o = new Ref_Init();
  assert(o.a != null);
}

class Nullable_Init {
  a: ArrayBuffer | null = new ArrayBuffer(0); // OK
}
{
  let o = new Nullable_Init();
  assert(o.a != null);
}

class Nullable {
  a: ArrayBuffer | null; // OK (zeroed)
}
{
  let o = new Nullable();
  assert(o.a == null);
}

// with constructor

class Value_Ctor {
  a: i32; // OK (zeroed)
  constructor() {
  }
}
{
  let o = new Value_Ctor();
  assert(o.a == 0);
}

class Value_Init_Ctor {
  a: i32 = 1; // OK
  constructor() {
  }
}
{
  let o = new Value_Init_Ctor();
  assert(o.a == 1);
}

class Value_Ctor_Init {
  a: i32; // OK (zeroed)
  constructor() {
    this.a = 1;
  }
}
{
  let o = new Value_Ctor_Init();
  assert(o.a == 1);
}

class Ref_Init_Ctor {
  a: ArrayBuffer = new ArrayBuffer(0); // OK
  constructor() {
  }
}
{
  let o = new Ref_Init_Ctor();
  assert(o.a != null);
}

class Ref_Ctor_Init {
  a: ArrayBuffer; // OK (in ctor)
  constructor() {
    this.a = new ArrayBuffer(0);
  }
}
{
  let o = new Ref_Ctor_Init();
  assert(o.a != null);
}

class Ref_Ctor_Param {
  constructor(public a: ArrayBuffer) { // OK
  }
}
{
  let a = new ArrayBuffer(0);
  let o = new Ref_Ctor_Param(a);
  assert(o.a == a);
}

class Nullable_Ctor {
  a: ArrayBuffer | null; // OK (zeroed)
  constructor() {
  }
}
{
  let o = new Nullable_Ctor();
  assert(o.a == null);
}

class Nullable_Init_Ctor {
  a: ArrayBuffer | null = new ArrayBuffer(0); // OK
  constructor() {
  }
}
{
  let o = new Nullable_Init_Ctor();
  assert(o.a != null);
}

class Nullable_Ctor_Init {
  a: ArrayBuffer | null; // OK (zeroed)
  constructor() {
    this.a = new ArrayBuffer(0);
  }
}
{
  let o = new Nullable_Ctor_Init();
  assert(o.a != null);
}

// inheritance

class Inherit_Base {
  a: ArrayBuffer = new ArrayBuffer(0);
}
class Inherit extends Inherit_Base {
}
{
  let o = new Inherit();
  assert(o.a != null);
}
class Inherit_Ctor extends Inherit_Base {
}
{
  let o = new Inherit_Ctor();
  assert(o.a != null);
}

// related object literal cases

class SomeObject {
  a: i32;
  b: string | null;
}
{
  let a: SomeObject = {}; // OK
  assert(a.a == 0);
  assert(a.b == null);
  let b: SomeObject = { a: 1 }; // OK
  assert(b.a == 1);
  assert(b.b == null);
  let c: SomeObject = { b: "b" }; // OK
  assert(c.a == 0);
  assert(c.b == "b");
  let d: SomeObject = { a: 2, b: "bb" }; // OK
  assert(d.a == 2);
  assert(d.b == "bb");
}

class SomeOtherObject extends SomeObject {
  c: string;
}
{
  let a: SomeOtherObject = { c: "c" }; // OK
  assert(a.a == 0);
  assert(a.b == null);
  assert(a.c == "c");
  let b: SomeOtherObject = { a: 3, b: "bbb", c: "cc" };
  assert(b.a == 3);
  assert(b.b == "bbb");
  assert(b.c == "cc");
}

// related flow cases

class Flow_Balanced {
  a: ArrayBuffer; // OK (any branch)
  constructor(cond: bool) {
    if (cond) {
      this.a = new ArrayBuffer(0);
    } else {
      this.a = new ArrayBuffer(0);
    }
  }
}
{
  let o = new Flow_Balanced(true);
  assert(o.a != null);
}

// inlined ctors

class Ref_Init_InlineCtor {
  a: ArrayBuffer = new ArrayBuffer(0); // OK
  @inline
  constructor() {
  }
}
{
  let o = new Ref_Init_InlineCtor();
  assert(o.a != null);
}

class Ref_InlineCtor_Init {
  a: ArrayBuffer; // OK (in ctor)
  @inline
  constructor() {
    this.a = new ArrayBuffer(0);
  }
}
{
  let o = new Ref_InlineCtor_Init();
  assert(o.a != null);
}

'''
'''--- tests/compiler/for.json ---
{
  "asc_flags": [
  ],
  "asc_rtrace": true
}

'''
'''--- tests/compiler/for.ts ---
var ran: bool;

function testInitExpression(): void {
  var i: i32;
  for (i = 0; i < 10; ++i) {
    ;
  }
  assert(i == 10);
  ran = true;
}
ran = false;
testInitExpression();
assert(ran);

function testInitStatement(): void {
  for (var j = 0; j < 10; ++j) {
    ;
  }
  assert(j == 10);
  ran = true;
}
ran = false;
testInitStatement();
assert(ran);

function testEmpty(): void {
  var i = 10;
  for (; i > 0; --i);
  assert(i == 0);
  ran = true;
}
ran = false;
testEmpty();
assert(ran);

function testConditionOmitted(): void {
  var i = 0;
  for (;; ++i) if (i == 10) break;
  assert(i == 10);
  ran = true;
}
ran = false;
testConditionOmitted();
assert(ran);

function testAllOmitted(): void {
  var i = 10;
  for (;;) if (--i == 0) break;
  assert(i == 0);
  ran = true;
}
ran = false;
testAllOmitted();
assert(ran);

function testAlwaysTrue(): void {
  var i = 0;
  for (;true;) {
    if (++i == 10) break;
  }
  assert(i == 10);
  ran = true;
}
ran = false;
testAlwaysTrue();
assert(ran);

function testAlwaysFalse(): void {
  for (;false;) {
    assert(false);
  }
  ran = true;
}
ran = false;
testAlwaysFalse();
assert(ran);

function testAlwaysContinues(): void {
  for (var k = 0; k < 10; ++k) continue;
  assert(k == 10);
  ran = true;
}
ran = false;
testAlwaysContinues();
assert(ran);

function testAlwaysBreaks(): void {
  for (var k = 0; k < 10; ++k) break;
  assert(k == 0);
  ran = true;
}
ran = false;
testAlwaysBreaks();
assert(ran);

function testAlwaysReturns(): void {
  for (let k = 0; k < 10; ++k) {
    ran = true;
    return;
  }
  assert(false);
}
ran = false;
testAlwaysReturns();
assert(ran);

function testNestedContinue(): void {
  var i = 0;
  var j = 0;
  var k = 0;
  for (; i < 10; i++) {
    if (i < 2) continue;
    for (j = 0; j < 10; j++) {
      if (i < j) {
        ++k;
        continue;
      }
    }
  }
  assert(i == 10);
  assert(j == 10);
  assert(k == 28);
  ran = true;
}
ran = false;
testNestedContinue();
assert(ran);

class Ref {}
function testRef(): void {
  var i = 0;
  var ref: Ref | null = new Ref();
  for (; ref;) {
    if (++i == 10) ref = null;
    else ref = new Ref();
  }
  assert(i == 10);
  assert(!ref);
  ran = true;
}
ran = false;
testRef();
assert(ran);

function getRef(): Ref {
  return new Ref();
}
function testRefAutorelease(): void {
  var i = 0;
  var ref: Ref | null = new Ref();
  for (ref = getRef(); getRef(); ref = getRef()) { // must not leak
    if (++i == 10) {
      ref = null;
      break;
    }
  }
  assert(i == 10);
  assert(!ref);
  ran = true;
}
ran = false;
testRefAutorelease();
assert(ran);

__collect();

'''
'''--- tests/compiler/function-call.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/function-call.ts ---
var fnVoid = function(): void {};
fnVoid.call(null);

var faVoid = (): void => {};
faVoid.call(null);

var fnRet = function(a: i32, b: i32): i32 {
  return a + b;
};
assert(fnRet.call(null, 1, 2) == 3);

var faRet = (a: i32, b: i32): i32 => {
  return a + b;
};
assert(faRet.call(null, 2, 3) == 5);

var fnThis = function fn2(this: i32): i32 {
  return this;
};
assert(fnThis.call(1) == 1);

class Foo {
  fnVoid(): void {}
  fnThis(this: i32): i32 {
    return this;
  }
  fnRet(a: i32, b: i32): i32 {
    return a + b;
  }
}
var foo = new Foo();
foo.fnVoid.call(foo);
assert(foo.fnThis.call(1) == 1);
assert(foo.fnRet.call(foo, 1, 2) == 3);

'''
'''--- tests/compiler/function-expression.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/function-expression.ts ---
var f1 = function(a: i32): i32 {
  return a;
};
assert(f1(1) == 1);

var f2 = (a: i32): i32 => {
  return a;
};
assert(f2(2) == 2);

var f3 = function someName(): void {
};
f3();

var f4 = (): i32 => 1;
assert(f4() == 1);

function testOmitted(fn: (a: i32, b: i32) => i32): i32 {
  return fn(1, 2);
}
assert(testOmitted((a, b) => a + b) == 3);
assert(testOmitted(a => a) == 1);
assert(testOmitted(() => 42) == 42);

function testOmittedReturn1(): (a: i32, b: i32) => i32 {
  return (a, b) => a + b;
}
function testOmittedReturn2(): (a: i32, b: i32) => i32 {
  return a => a;
}
function testOmittedReturn3(): (a: i32, b: i32) => i32 {
  return () => 42;
}
assert(testOmittedReturn1()(1, 2) == 3);
assert(testOmittedReturn2()(1, 2) == 1);
assert(testOmittedReturn3()(1, 2) == 42);

function testNullable(b: boolean): (() => i32) | null {
  if (b) {
    return (): i32 => 1;
  } else {
    return null;
  }
}
assert(testNullable(false) == null);

// see: https://github.com/AssemblyScript/assemblyscript/issues/1289

var globalFunc: () => (x: i32) => i32;
function testGlobal(): void {
  globalFunc = (): (x:i32) => i32 => {
    let myFunc = (x: i32): i32 => {
      return 24 + x;
    };
    return myFunc;
  };
  assert(globalFunc()(1) == 25);
}
testGlobal();

function testLocal(): void {
  let localFunc = (): (x:i32) => i32 => {
    let myFunc = (x: i32): i32 => {
      return 24 + x;
    };
    return myFunc;
  };
  assert(localFunc()(1) == 25);
}
testLocal();

class FieldClass {
  constructor(public fieldFunc: () => (x: i32) => i32) {}
}
function testField(): void {
  let fieldInst = new FieldClass((): (x:i32) => i32 => {
    let myFunc = (x: i32): i32 => {
      return 24 + x;
    };
    return myFunc;
  });
  assert(fieldInst.fieldFunc()(1) == 25);
}
testField();

export function semanticallyAnonymous(): void {
  function fnDecl(val: i32): i32 {
    return val;
  }
  const exprDecl = function fnDecl(val: i64): i64 { // must not shadow
    return val;
  };
  assert(fnDecl != exprDecl);
}
semanticallyAnonymous();

'''
'''--- tests/compiler/function-types.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/function-types.ts ---
type Adder<T> = (a: T, b: T) => T;

function makeAdder<T>(): Adder<T> {
  return (a: T, b: T): T => {
    return a + b;
  };
}

var i32Adder = makeAdder<i32>();

assert(i32Adder(1, 2) == 3);

var i64Adder = makeAdder<i64>();

assert(i64Adder(10, 20) == 30);

assert(makeAdder<f64>()(1.5, 2.5) == 4.0);

function doAddWithFn<T>(a: T, b: T, fn: (a: T, b: T) => T): T {
  return fn(a, b);
}

assert(doAddWithFn<i32>(2, 3, i32Adder) == 5);

function doAdd<T>(a: T, b: T): T {
  return makeAdder<T>()(a, b);
}

assert(doAdd<i32>(3, 4) == 7);

function addI32(a: i32, b: i32): i32 {
  return a + b;
}

assert(doAddWithFn<i32>(4, 5, addI32) == 9);

function makeAndAdd<T>(a: T, b: T, adder: Adder<T> = makeAdder<T>()): T {
  return adder(a, b);
}

assert(makeAndAdd<i32>(1, 2) == 3);
assert(makeAndAdd<i32>(1, 2, makeAdder<i32>()) == 3);

'''
'''--- tests/compiler/function.json ---
{
  "asc_flags": [
  ],
  "stderr": [
    "TS2300: Duplicate identifier 'a'"
  ]
}

'''
'''--- tests/compiler/function.ts ---
function _(): void {}
function v(): void { return; }
function i(): i32 { return 0; }
function j(): i64 { return 0; }
function f(): f32 { return 0; }
function d(): f64 { return 0; }

_();
v();
i();
j();
f();
d();

function i_(a: i32): void {}
function iv(a: i32): void { return; }
function ii(a: i32): i32 { return a; }
function jj(a: i64): i64 { return a; }
function ff(a: f32): f32 { return a; }
function dd(a: f64): f64 { return a; }

i_(0);
iv(0);
ii(0);
jj(0);
ff(0);
dd(0);

function ii_(a: i32, b: i32): void {}
function iiv(a: i32, b: i32): void { return; }
function iii(a: i32, b: i32): i32 { return a + b; }
function jjj(a: i64, b: i32): i64 { return a + b; }
function fff(a: f32, b: f32): f32 { return a + b; }
function ddd(a: f64, b: f64): f64 { return a + b; }

ii_(1, 2);
iiv(1, 2);
iii(1, 2);
jjj(1, 2);
fff(1, 2);
ddd(1, 2);

function duplicateParams(a: i32, a: i32): void {}
// TS2300: Duplicate identifier 'a'
duplicateParams(1, 2);

'''
'''--- tests/compiler/getter-call.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/getter-call.ts ---
class C {
  get x(): () => i32 {
    return (): i32 => 42;
  }
}

export function test(): i32 {
  // TODO: GH#251 return new C().x();
  let c = new C();
  return c.x();
}

'''
'''--- tests/compiler/getter-setter.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/getter-setter.ts ---
class Foo {
  static _bar: i32 = 0;

  static get bar(): i32 {
    return Foo._bar;
  }

  static set bar(bar: i32) {
    Foo._bar = bar;
  }
}

assert(Foo.bar == 0);
Foo.bar = 1;
assert(Foo.bar == 1);
assert((Foo.bar = 2) == 2);

'''
'''--- tests/compiler/heap.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/heap.ts ---
export { heap };

var ptr = heap.alloc(16);
ptr = heap.realloc(ptr, 32);
heap.free(ptr);

'''
'''--- tests/compiler/if.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/if.ts ---
export function ifThenElse(n: i32): bool {
  if (n)
    return true;
  else
    return false;
}

assert(ifThenElse(0) == false);
assert(ifThenElse(1) == true);

export function ifThen(n: i32): bool {
  if (n)
    return true;
  return false;
}

assert(ifThen(0) == false);
assert(ifThen(1) == true);

export function ifThenElseBlock(n: i32): bool {
  if (n) {
    ; // nop
    return true;
  } else {
    ; // nop
    return false;
  }
}

assert(ifThenElseBlock(0) == false);
assert(ifThenElseBlock(1) == true);

export function ifAlwaysReturns(n: i32): bool {
  if (n)
    return true;
  else
    throw new Error("error");
}

'''
'''--- tests/compiler/implicit-getter-setter.js ---
exports.postInstantiate = function(instance) {
  const exports = instance.exports;
  
  // using an integer value
  var basic = exports["Basic#constructor"](0, 123);
  (() => {
    var val = exports["Basic#get:val"](basic);
    if (val != 123) throw Error("invalid value");
    exports["Basic#set:val"](basic, 42);
    val = exports["Basic#get:val"](basic);
    if (val != 42) throw Error("invalid value");
  })();

  // using a managed value
  var managed = exports["Managed#constructor"](0, basic);
  (() => {
    var foo = exports["Managed#get:foo"](managed);
    if (foo != basic) throw Error("invalid value");
  })();
  (() => {
    var foo = exports["Basic#constructor"](0, 321);
    exports["Managed#set:foo"](managed, foo);
    var expectedFoo = foo;
    foo = exports["Managed#get:foo"](managed);
    if (foo != expectedFoo) throw Error("invalid value");
  })();

  // combining both
  (() => {
    var foo = exports["Managed#get:foo"](managed);
    var val = exports["Basic#get:val"](foo);
    if (val != 321) throw Error("invalid value");
  })();
};

'''
'''--- tests/compiler/implicit-getter-setter.json ---
{
}

'''
'''--- tests/compiler/implicit-getter-setter.ts ---
export class Basic {
  constructor(public val: i32) {}
}

export class Managed {
  constructor(public foo: Basic) {}
}

'''
'''--- tests/compiler/import.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/import.ts ---
import {
  add,
  sub as sub,
  renamed_mul as mul,
  a,
  b as b,
  renamed_c as c,
  ns as renamed_ns
} from "./export";

add(a, b) + sub(b, c) + mul(c, a);

renamed_ns.two();

import * as other from "./export";

other.add(other.a, other.b) +
other.sub(other.b, other.renamed_c) +
other.renamed_mul(other.renamed_c, other.a);

other.ns.two();

import theDefault from "./export";

theDefault.two();

import theOtherDefault from "./export-default";

theOtherDefault();

'''
'''--- tests/compiler/indexof-valueof.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/indexof-valueof.ts ---
// simple indexes
assert(isInteger<indexof<i8[]>>());
assert(isSigned<indexof<i8[]>>());
assert(sizeof<indexof<i8[]>>() == 4); // i32

// simple values
assert(isInteger<valueof<i8[]>>());
assert(isSigned<valueof<i8[]>>());
assert(sizeof<valueof<i8[]>>() == 1);

// using an alias
type u32Array = u32[];
assert(isInteger<valueof<u32Array>>());
assert(!isSigned<valueof<u32Array>>());
assert(sizeof<valueof<u32Array>>() == 4);

// float values
assert(isFloat<valueof<f32[]>>());
assert(sizeof<valueof<f32[]>>() == 4);

// string values
assert(isString<valueof<string[]>>());
assert(isManaged<valueof<string[]>>());

// array indexes
assert(isInteger<indexof<string[][]>>());
assert(isSigned<indexof<string[][]>>());
assert(sizeof<indexof<string[][]>>() == 4); // i32

// array values
assert(isArray<valueof<string[][]>>());

// typed array indexes
assert(isInteger<indexof<Float32Array>>());
assert(isSigned<indexof<Float32Array>>());
assert(sizeof<indexof<Float32Array>>() == 4); // i32

// typed array values
assert(isInteger<valueof<Uint8ClampedArray>>());
assert(!isSigned<valueof<Uint8ClampedArray>>());
assert(sizeof<valueof<Uint8ClampedArray>>() == 1);

// map indexes
assert(isInteger<indexof<Map<i32,i32>>>());
assert(isFloat<indexof<Map<f32,i32>>>());
assert(isString<indexof<Map<string,i32>>>());

// map values
assert(isInteger<valueof<Map<i32,i8>>>());
assert(isFloat<valueof<Map<i32,f32>>>());
assert(isString<valueof<Map<i32,string>>>());

// set indexes
assert(isInteger<indexof<Set<i32>>>());
assert(isFloat<indexof<Set<f32>>>());
assert(isString<indexof<Set<string>>>());

// set values (always bool)
assert(isBoolean<valueof<Set<i32>>>());
assert(isBoolean<valueof<Set<f32>>>());
assert(isBoolean<valueof<Set<string>>>());

'''
'''--- tests/compiler/infer-array.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/infer-array.ts ---
{ // default to i32 for integer literals
  let arr = [1, 2, 3];
  assert(isInteger(arr[0]));
  assert(isSigned(arr[0]));
}
{ // default to f64 for float literals
  let arr = [1.0, 2, 3];
  assert(isFloat(arr[0]));
}
{ // retain signedness
  let arr = [<u32>1, -1];
  assert(isInteger(arr[0]));
  assert(!isSigned(arr[0]));
  assert(arr[1] == 4294967295);
}
{ // use common denominator
  let arr = [1, 2, 3.0];
  assert(isFloat(arr[0]));
}
{ // pass contextual type upwards
  let arr = [<f32>1.0, 2.0, 3];
  assert(isFloat(arr[0]));
  let f: f32 = arr[1]; // would error if f64
}
class Ref {}
{ // use common nullable state
  let a: Ref = new Ref();
  let b: Ref | null = new Ref();
  let arr = [a, b];
  assert(isNullable(arr[0]));
}
{ // allow lesser nullable state
  let a: Ref | null = new Ref();
  let b: Ref = new Ref();
  let arr = [a, b];
  assert(isNullable(arr[1]));
}
{ // also works with null literal
  let a: Ref = new Ref();
  let arr = [a, null];
  assert(isNullable(arr[0]));
}
{ // leading null literals are deferred
  let arr = [null, "a"];
  assert(isNullable(arr[0]));
}
{ // only nulls infers as usize[]
  let arr1 = [null];
  assert(isInteger(arr1[0]));
  assert(!isNullable(arr1[0]));
  let arr2 = [null, null];
  assert(isInteger(arr2[0]));
  assert(!isNullable(arr2[0]));
}
{ // null in integer contexts infers as usize
  let arr1 = [1, null];
  assert(isInteger(arr1[0]));
  assert(!isNullable(arr1[0]));
  let arr2 = [null, 1];
  assert(isInteger(arr2[0]));
  assert(!isNullable(arr2[0]));
}
{ // nesting works as well
  let arr = [[1], [2]];
  assert(isArray(arr[0]));
  assert(!isNullable(arr));
}

'''
'''--- tests/compiler/infer-generic.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/infer-generic.ts ---
// T should infer T

function inferPlain<T>(arr: T): T {
  return arr;
}

export function test1(arr: f32): f32 {
  return inferPlain(arr);
}

// Array<T> should infer T

function inferEncapsulatedClass<T>(arr: T[]): T[] {
  return arr;
}

export function test2(arr: f32[]): f32[] {
  return inferEncapsulatedClass(arr);
}

// (a: T) => R should infer T,R

function inferEncapsulatedFunction<T,R>(fn: (a: T) => R): (a: T) => R {
  return fn;
}

export function test3(fn: (a: f32) => f64): (a: f32) => f64 {
  return inferEncapsulatedFunction(fn);
}

// (a: T, b: i32) => R should not bail out on non-inferred i32

function inferEncapsulatedFunctionMixed<T,R>(fn: (a: T, b: i32) => R): (a: T, b: i32) => R {
  return fn;
}

export function test4(fn: (a: f32, b: i32) => f64): (a: f32, b: i32) => f64 {
  return inferEncapsulatedFunctionMixed(fn);
}

// <i32|f64> should pick common compatible type f64

function inferCompatible<T>(a: T, b: T): bool {
  return a == b;
}
assert(inferCompatible(1, 1.0));

// should work with function expressions with omitted types
// if all types can be inferred from other arguments

const arr: f32[] = [1.0, 2.0, 3.0];
arr.reduce(((acc, cur) => acc && cur != 0), false);

// should fall back to default type

class Ref { x: i32; }
function inferDefault<T = Ref>(a: T): T {
  return a;
}
assert(inferDefault(1) == 1);
assert(inferDefault({ x: 2 }) instanceof Ref);

'''
'''--- tests/compiler/infer-type.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/infer-type.ts ---
const i = 10; // infers i32 because it fits into i32 as the default
i;

const I = 0x100000000; // infers i64 because the value doesn't fit into 32 bits
I;

const F = 1.5; // infers f64 because of float notation
F;

function locals(): void {
  var li = 10;
  var lI = 0x100000000;
  var lF = 1.5;
  var ai = i;
  var aI = I;
  var aF = F;
}
locals();

function reti(): i32 {
  return 0;
}
var ri = reti();
ri;

function retI(): i64 {
  return 0;
}
var rI = retI();
rI;

function retf(): f32 {
  return 0;
}
var rf = retf();
rf;

function refF(): f64 {
  return 0;
}
var rF = refF();
rF;

for (var a = 0, b = 10; a < b; ++a) {
  ;
}

var inferi = 0x80000000; // infers u32
assert(!isSigned(inferi));

var inferu = 0x7fffffff; // infers i32
assert(isSigned(inferu));

'''
'''--- tests/compiler/inlining-blocklocals.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/inlining-blocklocals.ts ---
var b: i32 = 2;

var theCall_a: i32;
var theCall_b: i32;
var theCall_c: i32;

@inline function theCall(a: i32, b: i32, c: i32): void {
  theCall_a = a;
  theCall_b = b;
  theCall_c = c;
}

function test(): void {
  var a = 1;
  // see comment in Compiler#makeCallInlinePrechecked
  // theCall($3, $2=[except $3], $1=[except $3,$2])
  theCall(a++, b++, ++a);
  assert(theCall_a == 1);
  assert(theCall_b == 2);
  assert(theCall_c == 3);
  assert(a == 3);
}
test();

'''
'''--- tests/compiler/inlining-recursive.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/inlining-recursive.ts ---
// direct

@inline
export function foo(): void {
  foo();
}

// indirect

@inline
export function bar(): void {
  baz();
}

@inline
export function baz(): void {
  bar();
}

'''
'''--- tests/compiler/inlining.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/inlining.ts ---
// Constant inlining

const constantGlobal = 1;

export function test(): i32 {
  const constantLocal = 2;
  return constantGlobal + constantLocal;
}

assert(test() == 3);

// Function inlining

@inline
function func_ii(a: i32): i32 {
  if (a == 42) return 1;
  return a < 42 ? 2 : 3;
}

@inline
function func_ii_opt(a: i32 = 0): i32 {
  return a;
}

@inline
function func_ii_loc(a: i32): i32 {
  var b = a;
  var e: i32;
  if (true) {
    let c = b;
    let d = c;
    e = d + 1;
  }
  return e;
}

@inline
function func_iv(a: i32): void {
}

@inline
function func_fe(): (a: i32) => i32 {
  return (a: i32): i32 => a;
}

class Foo {
  @inline
  static method_static(a: i32, b: i32 = 2): i32 {
    return a + b;
  }
  @inline
  method_this(a: i32, b: i32 = 3): Foo {
    return this;
  }
}

function test_funcs(): void {
  var a: f32 = -1, b: f64 = -2;
  assert(func_ii(42) == 1);
  assert(func_ii(41) == 2);
  assert(func_ii(43) == 3);
  assert(func_ii_opt() == 0);
  assert(func_ii_opt(1) == 1);
  assert(func_ii_loc(2) == 3);
  assert(func_ii_loc(3) == 4);
  func_iv(0);
  assert(func_fe()(2) == 2);
  assert(Foo.method_static(42) == 44);
  var foo = changetype<Foo>(123);
  assert(changetype<usize>(foo.method_this(43)) == 123);
}

test_funcs();

class Baz {
  a: i32 = 1;
  b: i32;
  @inline constructor(c: i32) {
    this.b = c;
  }
}

class Bar extends Baz {
  d: i32 = 3;
  e: i32;
  @inline constructor(f: i32) {
    super(2);
    this.e = f;
  }
}

function test_ctor(): void {
  var bar = new Bar(4);
  assert(bar.a == 1);
  assert(bar.b == 2);
  assert(bar.d == 3);
  assert(bar.e == 4);
}

test_ctor();

'''
'''--- tests/compiler/instanceof-class.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/instanceof-class.ts ---
class Parent<T> {
}

class Child<T> extends Parent<T> {
}

class SomethingElse<T> {
}

var a: Child<i32> = new Child<i32>();
assert(a instanceof Child);            // static true
assert(a instanceof Parent);           // static true
assert(!(a instanceof SomethingElse)); // static false

var b: Parent<f32> = new Child<f32>();
assert(b instanceof Parent);           // static true
assert(b instanceof Child);            // dynamic true (checks Child<i32>, Child<f32>)
assert(!(b instanceof SomethingElse)); // static false

'''
'''--- tests/compiler/instanceof.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/instanceof.ts ---
class A {}
class B extends A {}

var a: A;
var b: B;
var i: i32;
var I: i64;
var f: f32;
var F: f64;

assert(  a instanceof A );
assert(  b instanceof A );
assert(!(i instanceof A));
assert(!(I instanceof A));
assert(!(f instanceof A));
assert(!(F instanceof A));

// assert(!(a instanceof B)); // dynamic upcast, checked in rt/instanceof
assert(  b instanceof B );
assert(!(i instanceof B));
assert(!(I instanceof B));
assert(!(f instanceof B));
assert(!(F instanceof B));

assert(!(a instanceof i32));
assert(!(b instanceof i32));
assert(  i instanceof i32 );
assert(!(I instanceof i32));
assert(!(f instanceof i32));
assert(!(F instanceof i32));

assert(!(a instanceof i64));
assert(!(b instanceof i64));
assert(!(i instanceof i64));
assert(  I instanceof i64 );
assert(!(f instanceof i64));
assert(!(F instanceof i64));

assert(!(a instanceof f32));
assert(!(b instanceof f32));
assert(!(i instanceof f32));
assert(!(I instanceof f32));
assert(  f instanceof f32 );
assert(!(F instanceof f32));

assert(!(a instanceof f64));
assert(!(b instanceof f64));
assert(!(i instanceof f64));
assert(!(I instanceof f64));
assert(!(f instanceof f64));
assert(  F instanceof f64 );

function isI32<T>(v: T): bool {
  // should eliminate non-applicable branches (see fixture)
  if (v instanceof i32) {
    return true;
  } else {
    return false;
  }
}

assert( isI32(0));
assert(!isI32(0.0));
assert(!isI32(<u32>0)); // signedness is relevant
assert(!isI32(<u16>0)); // byte size is relevant

var an: A | null = null;
assert(!(an instanceof A));       // TS: ==null is not an instance of A
assert(  an instanceof A | null); // AS: ==null is     an instance of A | null
an = changetype<A | null>(1);
assert(  an instanceof A);        // TS: !=null is an instance of A
assert(  an instanceof A | null); // AS: !=null is an instance of A | null

// TODO: keep track of nullability during flows, so this becomes precomputable:
// assert(an !== null && an instanceof A);

'''
'''--- tests/compiler/issues/1095.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/issues/1095.ts ---
class Foo {
  bar: string | null = "test";
}

function test(foo: Foo): void {
  // Make sure that the temp obtained for `foo` (`.bar` is loaded AND stored)
  // does not conflict with temps obtained and freed in the RHS expression.
  foo.bar = foo.bar!;
}

test(new Foo());

'''
'''--- tests/compiler/issues/1225.json ---
{
  "asc_flags": [
  ],
  "asc_rtrace": true
}

'''
'''--- tests/compiler/issues/1225.ts ---
class X {
  normal: i32;
  viaThis: i32;
  constructor(private x: i32) {
    this.viaThis = this.x;
    this.normal = x;
  }
}

var x = new X(4);
export function normal(): u32 {
  return x.normal;
}
export function viaThis(): u32 {
  return x.viaThis;
}

assert(normal() === 4);
assert(viaThis() === 4);

x = changetype<X>(0); // unleak

__collect();

'''
'''--- tests/compiler/issues/1699.ts ---
class MultiAssignmentTest {
    test: i32 = 2;
}

function test(): void {
  const testinstances = new Array<MultiAssignmentTest>(3);
  testinstances[0] = testinstances[1] = new MultiAssignmentTest();

  for (let n = 0; n < testinstances.length; n++) {
    const testinstance = new MultiAssignmentTest();
    if (n > 1) {
      testinstances[n] = testinstance;
    }
  }
  assert(testinstances[0] === testinstances[1]);
  assert(testinstances[2] !== testinstances[1]);
}

test();

'''
'''--- tests/compiler/issues/1714.ts ---
function a_i64_i32<T,U>(): bool { // T'=U=i64, U'=T=i32
  return sizeof<T>() == sizeof<U>();
}

function foo<T,U>(): bool { // T=i32, U=i64
  return a_i64_i32<U,T>() == true;
}

assert(foo<i32, i64>() == false);

function bar<T1,T2>(): string { // T1=f64, T2=i32
  if (isInteger<T2>()) {
    return bar<T2,T1>(); // T2'=T1=f64, T2'=T1=i32
  }
  return nameof<T1>(); // iff T1 == i32
}

assert(bar<f64, i32>() === "i32");

'''
'''--- tests/compiler/issues/1751.ts ---
import { Foo } from './1751/_reexport';

'''
'''--- tests/compiler/issues/1751/_common.ts ---
export { Foo } from "./_foo";

'''
'''--- tests/compiler/issues/1751/_foo.ts ---
export class Foo {}

'''
'''--- tests/compiler/issues/1751/_reexport.ts ---
export * from './_common'; // should propagate

'''
'''--- tests/compiler/limits.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/limits.ts ---
i8.MIN_VALUE;
i8.MAX_VALUE;
i16.MIN_VALUE;
i16.MAX_VALUE;
i32.MIN_VALUE;
i32.MAX_VALUE;
i64.MIN_VALUE;
i64.MAX_VALUE;
isize.MIN_VALUE;
isize.MAX_VALUE;
u8.MIN_VALUE;
u8.MAX_VALUE;
u16.MIN_VALUE;
u16.MAX_VALUE;
u32.MIN_VALUE;
u32.MAX_VALUE;
u64.MIN_VALUE;
u64.MAX_VALUE;
usize.MIN_VALUE;
usize.MAX_VALUE;
bool.MIN_VALUE;
bool.MAX_VALUE;
f32.MIN_SAFE_INTEGER;
f32.MAX_SAFE_INTEGER;
f64.MIN_SAFE_INTEGER;
f64.MAX_SAFE_INTEGER;

'''
'''--- tests/compiler/literals.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/literals.ts ---
0;
1;
2;
3;
4;
5;
6;
7;
8;
9;
0x0;
0x1;
0x2;
0x3;
0x4;
0x5;
0x6;
0x7;
0x8;
0x9;
0xA;
0xB;
0xC;
0xD;
0xE;
0xF;
0xa;
0xb;
0xc;
0xd;
0xe;
0xf;
0o0;
0o1;
0o2;
0o3;
0o4;
0o5;
0o6;
0o7;
0b0;
0b1;
true;
false;

'''
'''--- tests/compiler/logical.json ---
{
  "asc_flags": [
  ],
  "asc_rtrace": true
}

'''
'''--- tests/compiler/logical.ts ---
0 && unreachable();
0.0 && unreachable();
1 || unreachable();
1.0 || unreachable();

1 && 2 || unreachable();
1.0 && 2.0 || unreachable();

var i: i32;

i = 1 && 2;
assert(i == 2);

i = 0 || 1;
assert(i == 1);

var I: i64;

I = 1 && 2;
assert(I == 2);

I = 0 || 1;
assert(I == 1);

var f: f32;

f = 1.0 && 2.0;
assert(f == 2.0);

f = 0.0 || 1.0;
assert(f == 1.0);

var F: f64;

F = 1.0 && 2.0;
assert(F == 2.0);

F = 0.0 || 1.0;
assert(F == 1.0);

// NaN is considered falseish

f = NaN as f32 || 1.0 as f32;
assert(f == 1.0);

f = 1.0 as f32 || NaN as f32;
assert(f == 1.0);

F = NaN || 1.0;
assert(F == 1.0);

F = 1.0 || NaN;
assert(F == 1.0);

f = 1.0 as f32 && NaN as f32;
assert(isNaN(f));

f = NaN as f32 && 1.0 as f32;
assert(isNaN(f));

F = 1.0 && NaN;
assert(isNaN(F));

F = NaN && 1.0;
assert(isNaN(F));

// Test shortcutting to bool on contextual bool
// see: https://github.com/AssemblyScript/assemblyscript/pull/993

function testShortcutAnd(a: i64, b: i32): bool {
  return a && b;
}
function testShortcutOr(a: i64, b: i32): bool {
  return a || b;
}
assert(testShortcutAnd(1, 1));
assert(testShortcutOr(0, 1));

// Test non-bools on contextual bool
// see: https://github.com/AssemblyScript/assemblyscript/issues/1136

class Obj {}

function testContextualBoolAnd(someObj: Obj, someInt: i32): bool {
  return someObj && someInt;
}
assert(testContextualBoolAnd(new Obj(), 1));

function testContextualBoolOr(someObj: Obj, someInt: i32): bool {
  return someObj || someInt;
}
assert(testContextualBoolOr(new Obj(), 0));

__stack_pointer = __heap_base;
__collect();

'''
'''--- tests/compiler/loop-flow.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/loop-flow.ts ---
export function whileReturn(): i32 {
  while (true) {
    return 1;
  }
}

assert(whileReturn() == 1);

export function whileThrow(): i32 {
  while (true) {
    throw new Error("term");
  }
}

export function whileContinue(): i32 {
  while (true) {
    continue;
  }
}

export function whileAny(a: i32): i32 {
  while (true) {
    if (a == 1) return 1;
    else if (a == 2) throw new Error("term");
    else continue;
  }
}

assert(whileAny(1) == 1);

export function forReturn(): i32 {
  for (;;) {
    return 1;
  }
}

assert(forReturn() == 1);

export function forThrow(): i32 {
  for (;;) {
    throw new Error("term");
  }
}

export function forContinue(): i32 {
  for (;;) {
    continue;
  }
}

export function forAny(a: i32): i32 {
  for (;;) {
    if (a == 1) return 1;
    else if (a == 2) throw new Error("term");
    else continue;
  }
}

assert(forAny(1) == 1);

export function doReturn(): i32 {
  do {
    return 1;
  } while (true);
}

assert(doReturn() == 1);

export function doThrow(): i32 {
  do {
    throw new Error("term");
  } while (true);
}

export function doAny(a: i32): i32 {
  do {
    if (a == 1) return 1;
    else if (a == 2) throw new Error("term");
    else continue;
  } while (true);
}

assert(doAny(1) == 1);

'''
'''--- tests/compiler/loop-wrap.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/loop-wrap.ts ---
export function testAlwaysWrapped(): void {
  var i: u8 = 0; // <--
  do {
    if (i == 10) break; // no need to wrap
  } while (i = (i + 1) & 0xff); // <--
}

export function testFirstWrapped(): void {
  var i: u8 = 0;
  do {
    if (i == 10) break; // must wrap
  } while (++i); // <--
}

export function testSubsequentWrapped(a: i32): void {
  var i = <u8>a; // <--
  do {
    if (i == 10) break; // must wrap
  } while (i = (i + 1) & 0xff);
}

'''
'''--- tests/compiler/managed-cast.json ---
{
  "asc_flags": [
  ],
  "asc_rtrace": true
}

'''
'''--- tests/compiler/managed-cast.ts ---
class Animal {
  tame(): void {}
}
class Cat extends Animal {
  meow(): void {}
}

function testDowncast(cat: Cat): void {
  (<Animal>cat).tame();
}
testDowncast(new Cat());

function testDowncastFromNullable(cat: Cat | null): void {
  (<Animal>cat).tame();
}
testDowncastFromNullable(new Cat());

function testDowncastToNullable(cat: Cat): void {
  var maybeAnimal = <Animal | null>cat;
  if (maybeAnimal) maybeAnimal.tame();
}
testDowncastToNullable(new Cat());

function testDowncastFromToNullable(cat: Cat | null): void {
  var maybeAnimal = <Animal | null>cat;
  if (maybeAnimal) maybeAnimal.tame();
}
testDowncastFromToNullable(new Cat());

function testUpcast(animal: Animal): void {
  (<Cat>animal).meow();
}
testUpcast(new Cat());

function testUpcastFromNullable(animal: Animal | null): void {
  (<Cat>animal).meow();
}
testUpcastFromNullable(new Cat());

function testUpcastToNullable(animal: Animal): void {
  var maybeCat = <Cat | null>animal;
  if (maybeCat) maybeCat.meow();
}
testUpcastToNullable(new Cat());

function testUpcastFromToNullable(animal: Animal | null): void {
  var maybeCat = <Cat | null>animal;
  if (maybeCat) maybeCat.meow();
}
testUpcastFromToNullable(new Cat());

__stack_pointer = __heap_base;
__collect();

'''
'''--- tests/compiler/many-locals.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/many-locals.ts ---
export function testI32(a: i32): i32 { // does not have to remember wrap states
  var a00 = a;
  var a01 = a00;
  var a02 = a01;
  var a03 = a02;
  var a04 = a03;
  var a05 = a04;
  var a06 = a05;
  var a07 = a06;
  var a08 = a07;
  var a09 = a08;
  var a0A = a09;
  var a0B = a0A;
  var a0C = a0B;
  var a0D = a0C;
  var a0E = a0D;
  var a0F = a0E;
  var a10 = a0F;
  var a11 = a10;
  var a12 = a11;
  var a13 = a12;
  var a14 = a13;
  var a15 = a14;
  var a16 = a15;
  var a17 = a16;
  var a18 = a17;
  var a19 = a18;
  var a1A = a19;
  var a1B = a1A;
  var a1C = a1B;
  var a1D = a1C;
  var a1E = a1D;
  var a1F = a1E;
  var a20 = a1F;
  var a21 = a20;
  var a22 = a21;
  var a23 = a22;
  var a24 = a23;
  var a25 = a24;
  var a26 = a25;
  var a27 = a26;
  var a28 = a27;
  var a29 = a28;
  var a2A = a29;
  var a2B = a2A;
  var a2C = a2B;
  var a2D = a2C;
  var a2E = a2D;
  var a2F = a2E;
  var a30 = a2F;
  var a31 = a30;
  var a32 = a31;
  var a33 = a32;
  var a34 = a33;
  var a35 = a34;
  var a36 = a35;
  var a37 = a36;
  var a38 = a37;
  var a39 = a38;
  var a3A = a39;
  var a3B = a3A;
  var a3C = a3B;
  var a3D = a3C;
  var a3E = a3D;
  var a3F = a3E;
  var a40 = a3F;
  var a41 = a40;
  var a42 = a41;
  var a43 = a42;
  var a44 = a43;
  var a45 = a44;
  var a46 = a45;
  var a47 = a46;
  var a48 = a47;
  var a49 = a48;
  var a4A = a49;
  var a4B = a4A;
  var a4C = a4B;
  var a4D = a4C;
  var a4E = a4D;
  var a4F = a4E;
  var a50 = a4F;
  var a51 = a50;
  var a52 = a51;
  var a53 = a52;
  var a54 = a53;
  var a55 = a54;
  var a56 = a55;
  var a57 = a56;
  var a58 = a57;
  var a59 = a58;
  var a5A = a59;
  var a5B = a5A;
  var a5C = a5B;
  var a5D = a5C;
  var a5E = a5D;
  var a5F = a5E;
  var a60 = a5F;
  var a61 = a60;
  var a62 = a61;
  var a63 = a62;
  var a64 = a63;
  var a65 = a64;
  var a66 = a65;
  var a67 = a66;
  var a68 = a67;
  var a69 = a68;
  var a6A = a69;
  var a6B = a6A;
  var a6C = a6B;
  var a6D = a6C;
  var a6E = a6D;
  var a6F = a6E;
  var a70 = a6F;
  var a71 = a70;
  var a72 = a71;
  var a73 = a72;
  var a74 = a73;
  var a75 = a74;
  var a76 = a75;
  var a77 = a76;
  var a78 = a77;
  var a79 = a78;
  var a7A = a79;
  var a7B = a7A;
  var a7C = a7B;
  var a7D = a7C;
  var a7E = a7D;
  var a7F = a7E;
  return a7F;
}

assert(testI32(42) == 42);

export function testI8(a: i8): i8 { // has to remember wrap states
  var a00 = a;
  var a01 = a00;
  var a02 = a01;
  var a03 = a02;
  var a04 = a03;
  var a05 = a04;
  var a06 = a05;
  var a07 = a06;
  var a08 = a07;
  var a09 = a08;
  var a0A = a09;
  var a0B = a0A;
  var a0C = a0B;
  var a0D = a0C;
  var a0E = a0D;
  var a0F = a0E;
  var a10 = a0F;
  var a11 = a10;
  var a12 = a11;
  var a13 = a12;
  var a14 = a13;
  var a15 = a14;
  var a16 = a15;
  var a17 = a16;
  var a18 = a17;
  var a19 = a18;
  var a1A = a19;
  var a1B = a1A;
  var a1C = a1B;
  var a1D = a1C;
  var a1E = a1D;
  var a1F = a1E;
  var a20 = a1F;
  var a21 = a20;
  var a22 = a21;
  var a23 = a22;
  var a24 = a23;
  var a25 = a24;
  var a26 = a25;
  var a27 = a26;
  var a28 = a27;
  var a29 = a28;
  var a2A = a29;
  var a2B = a2A;
  var a2C = a2B;
  var a2D = a2C;
  var a2E = a2D;
  var a2F = a2E;
  var a30 = a2F;
  var a31 = a30;
  var a32 = a31;
  var a33 = a32;
  var a34 = a33;
  var a35 = a34;
  var a36 = a35;
  var a37 = a36;
  var a38 = a37;
  var a39 = a38;
  var a3A = a39;
  var a3B = a3A;
  var a3C = a3B;
  var a3D = a3C;
  var a3E = a3D;
  var a3F = a3E;
  var a40 = a3F;
  var a41 = a40;
  var a42 = a41;
  var a43 = a42;
  var a44 = a43;
  var a45 = a44;
  var a46 = a45;
  var a47 = a46;
  var a48 = a47;
  var a49 = a48;
  var a4A = a49;
  var a4B = a4A;
  var a4C = a4B;
  var a4D = a4C;
  var a4E = a4D;
  var a4F = a4E;
  var a50 = a4F;
  var a51 = a50;
  var a52 = a51;
  var a53 = a52;
  var a54 = a53;
  var a55 = a54;
  var a56 = a55;
  var a57 = a56;
  var a58 = a57;
  var a59 = a58;
  var a5A = a59;
  var a5B = a5A;
  var a5C = a5B;
  var a5D = a5C;
  var a5E = a5D;
  var a5F = a5E;
  var a60 = a5F;
  var a61 = a60;
  var a62 = a61;
  var a63 = a62;
  var a64 = a63;
  var a65 = a64;
  var a66 = a65;
  var a67 = a66;
  var a68 = a67;
  var a69 = a68;
  var a6A = a69;
  var a6B = a6A;
  var a6C = a6B;
  var a6D = a6C;
  var a6E = a6D;
  var a6F = a6E;
  var a70 = a6F;
  var a71 = a70;
  var a72 = a71;
  var a73 = a72;
  var a74 = a73;
  var a75 = a74;
  var a76 = a75;
  var a77 = a76;
  var a78 = a77;
  var a79 = a78;
  var a7A = a79;
  var a7B = a7A;
  var a7C = a7B;
  var a7D = a7C;
  var a7E = a7D;
  var a7F = a7E;
  return a7F;
}

assert(testI8(42) == 42);

'''
'''--- tests/compiler/memcpy.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/memcpy.ts ---
export function memcpy(dest: usize, src: usize, n: usize): usize {
  var ret = dest;
  var w: u32, x: u32;

  // copy 1 byte each until src is aligned to 4 bytes
  while (n && src % 4) {
    store<u8>(dest++, load<u8>(src++));
    n--;
  }

  // if dst is aligned to 4 bytes as well, copy 4 bytes each
  if (dest % 4 == 0) {
    while (n >= 16) {
      store<u32>(dest     , load<u32>(src     ));
      store<u32>(dest +  4, load<u32>(src +  4));
      store<u32>(dest +  8, load<u32>(src +  8));
      store<u32>(dest + 12, load<u32>(src + 12));
      src += 16; dest += 16; n -= 16;
    }
    if (n & 8) {
      store<u32>(dest    , load<u32>(src    ));
      store<u32>(dest + 4, load<u32>(src + 4));
      dest += 8; src += 8;
    }
    if (n & 4) {
      store<u32>(dest, load<u32>(src));
      dest += 4; src += 4;
    }
    if (n & 2) { // drop to 2 bytes each
      store<u16>(dest, load<u16>(src));
      dest += 2; src += 2;
    }
    if (n & 1) { // drop to 1 byte
      store<u8>(dest++, load<u8>(src++));
    }
    return ret;
  }

  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each
  // doing shifts if faster when copying enough bytes (here: 32 or more)
  if (n >= 32) {
    switch (<u32>dest % 4) {
      // known to be != 0
      case 1:
        w = load<u32>(src);
        store<u8>(dest++, load<u8>(src++));
        store<u8>(dest++, load<u8>(src++));
        store<u8>(dest++, load<u8>(src++));
        n -= 3;
        while (n >= 17) {
          x = load<u32>(src + 1);
          store<u32>(dest, w >> 24 | x << 8);
          w = load<u32>(src + 5);
          store<u32>(dest + 4, x >> 24 | w << 8);
          x = load<u32>(src + 9);
          store<u32>(dest + 8, w >> 24 | x << 8);
          w = load<u32>(src + 13);
          store<u32>(dest + 12, x >> 24 | w << 8);
          src += 16; dest += 16; n -= 16;
        }
        break;
      case 2:
        w = load<u32>(src);
        store<u8>(dest++, load<u8>(src++));
        store<u8>(dest++, load<u8>(src++));
        n -= 2;
        while (n >= 18) {
          x = load<u32>(src + 2);
          store<u32>(dest, w >> 16 | x << 16);
          w = load<u32>(src + 6);
          store<u32>(dest + 4, x >> 16 | w << 16);
          x = load<u32>(src + 10);
          store<u32>(dest + 8, w >> 16 | x << 16);
          w = load<u32>(src + 14);
          store<u32>(dest + 12, x >> 16 | w << 16);
          src += 16; dest += 16; n -= 16;
        }
        break;
      case 3:
        w = load<u32>(src);
        store<u8>(dest++, load<u8>(src++));
        n -= 1;
        while (n >= 19) {
          x = load<u32>(src + 3);
          store<u32>(dest, w >> 8 | x << 24);
          w = load<u32>(src + 7);
          store<u32>(dest + 4, x >> 8 | w << 24);
          x = load<u32>(src + 11);
          store<u32>(dest + 8, w >> 8 | x << 24);
          w = load<u32>(src + 15);
          store<u32>(dest + 12, x >> 8 | w << 24);
          src += 16; dest += 16; n -= 16;
        }
        break;
    }
  }

  // copy remaining bytes one by one
  if (n & 16) {
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
  }
  if (n & 8) {
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
  }
  if (n & 4) {
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
  }
  if (n & 2) {
    store<u8>(dest++, load<u8>(src++));
    store<u8>(dest++, load<u8>(src++));
  }
  if (n & 1) {
    store<u8>(dest++, load<u8>(src++));
  }
  return ret;
}

const base: usize = 8;
store<u64>(base     , 0x1111111111111111);
store<u64>(base + 8 , 0x2222222222222222);
store<u64>(base + 16, 0x3333333333333333);
store<u64>(base + 24, 0x4444444444444444);

var dest: usize;
dest = memcpy(base + 1, base + 16, 4);
assert(dest == base + 1);
assert(load<u64>(base) == 0x1111113333333311);

dest = memcpy(base, base, 32);
assert(dest == base);
assert(load<u64>(base) == 0x1111113333333311);
assert(load<u64>(base + 8) == 0x2222222222222222);
assert(load<u64>(base + 16) == 0x3333333333333333);
assert(load<u64>(base + 24) == 0x4444444444444444);

dest = memcpy(base + 5, base + 28, 3);
assert(load<u64>(base) == 0x4444443333333311);

dest = memcpy(base + 8, base + 16, 15);
assert(load<u64>(base) == 0x4444443333333311);
assert(load<u64>(base + 8) == 0x3333333333333333);
assert(load<u64>(base + 16) == 0x3344444444444444);
assert(load<u64>(base + 24) == 0x4444444444444444);

'''
'''--- tests/compiler/memmove.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/memmove.ts ---
function memmove(dest: usize, src: usize, n: usize): usize {
  var ret = dest;
  if (dest == src)
    return ret;
  // if (src + n <= dest || dest + n <= src) {
  //   memcpy(dest, src, n);
  //   return ret;
  // }
  if (dest < src) {
    if (src % 8 == dest % 8) {
      while (dest % 8) {
        if (!n)
          return ret;
        --n;
        store<u8>(dest++, load<u8>(src++));
      }
      while (n >= 8) {
        store<u64>(dest, load<u64>(src));
        n -= 8;
        dest += 8;
        src += 8;
      }
    }
    while (n) {
      store<u8>(dest++, load<u8>(src++));
      --n;
    }
  } else {
    if (src % 8 == dest % 8) {
      while ((dest + n) % 8) {
        if (!n)
          return ret;
        store<u8>(dest + --n, load<u8>(src + n));
      }
      while (n >= 8) {
        n -= 8;
        store<u64>(dest + n, load<u64>(src + n));
      }
    }
    while (n) {
      store<u8>(dest + --n, load<u8>(src + n));
    }
  }
  return ret;
}

const base: usize = 8;
store<u64>(base     , 0x1111111111111111);
store<u64>(base + 8 , 0x2222222222222222);
store<u64>(base + 16, 0x3333333333333333);
store<u64>(base + 24, 0x4444444444444444);

var dest: usize;
dest = memmove(base + 1, base + 16, 4);
assert(dest == base + 1);
assert(load<u64>(base) == 0x1111113333333311);

dest = memmove(base, base, 32);
assert(dest == base);
assert(load<u64>(base) == 0x1111113333333311);
assert(load<u64>(base + 8) == 0x2222222222222222);
assert(load<u64>(base + 16) == 0x3333333333333333);
assert(load<u64>(base + 24) == 0x4444444444444444);

dest = memmove(base + 5, base + 28, 3);
assert(load<u64>(base) == 0x4444443333333311);

dest = memmove(base + 8, base + 16, 15);
assert(load<u64>(base) == 0x4444443333333311);
assert(load<u64>(base + 8) == 0x3333333333333333);
assert(load<u64>(base + 16) == 0x3344444444444444);
assert(load<u64>(base + 24) == 0x4444444444444444);

'''
'''--- tests/compiler/memory-config-errors.json ---
{
  "asc_flags": [
    "--initialMemory 2",
    "--maximumMemory 1"
  ],
  "stderr": [
    "AS105: Module requires at least '3' pages of initial memory.",
    "AS106: Module requires at least '3' pages of maximum memory."
  ]
}

'''
'''--- tests/compiler/memory-config-errors.ts ---
memory.data((2 << 16) + 1);

'''
'''--- tests/compiler/memory-config-shared-errors.json ---
{
  "asc_flags": [
    "--sharedMemory"
  ],
  "stderr": [
    "AS107: Shared memory requires maximum memory to be defined.",
    "AS108: Shared memory requires feature 'threads' to be enabled."
  ]
}

'''
'''--- tests/compiler/memory-config-shared-errors.ts ---

'''
'''--- tests/compiler/memory.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/memory.ts ---
// === memory.data ===

// Should be static

function test(): i32 {
  const ptr = memory.data(4);
  var value = load<i32>(ptr);
  store<i32>(ptr, value + 1);
  return value;
}

assert(test() == 0);
assert(test() == 1);
assert(test() == 2);

// Should be properly aligned

var ptr = memory.data(1);
assert(ptr + 16 == (ptr = memory.data(1, 16)));
assert(ptr + 8 == (ptr = memory.data(1, 8)));
assert(ptr + 4 == (ptr = memory.data(1, 4)));
assert(ptr + 2 == (ptr = memory.data(1, 2)));
assert(ptr + 1 == (ptr = memory.data(1, 1)));
assert(ptr + 1 == memory.data(1, 16));

// Should be static and properly aligned per generic instance

function testGeneric<T>(): usize {
  const ptr = memory.data(1, 1 << alignof<T>());
  return ptr;
}

ptr = memory.data(1);
assert(ptr + 16 == (ptr = testGeneric<v128>()));
assert(ptr + 8 == (ptr = testGeneric<i64>()));
assert(ptr + 4 == (ptr = testGeneric<i32>()));
assert(ptr + 2 == (ptr = testGeneric<i16>()));
assert(ptr + 1 == (ptr = testGeneric<i8>()));
assert(ptr + 1 == memory.data(1, 16));

// Should work with arrays of values

ptr = memory.data<u8>([1, 2, 3]);
assert(load<u8>(ptr) == 1);
assert(load<u8>(ptr, 1) == 2);
assert(load<u8>(ptr, 2) == 3);

ptr = memory.data<f32>([1.5, 2.5, 3.5]);
assert(load<f32>(ptr) == 1.5);
assert(load<f32>(ptr, 4) == 2.5);
assert(load<f32>(ptr, 8) == 3.5);

// Should be properly aligned when using arrays of values

ptr = memory.data(1);
assert(ptr + 16 == (ptr = memory.data<u8>([1], 16)));
assert(ptr + 8 == (ptr = memory.data<u8>([1], 8)));
assert(ptr + 4 == (ptr = memory.data<u8>([1], 4)));
assert(ptr + 2 == (ptr = memory.data<u8>([1], 2)));
assert(ptr + 1 == (ptr = memory.data<u8>([1], 1)));
assert(ptr + 1 == memory.data<u8>([1], 16));

'''
'''--- tests/compiler/memorybase.json ---
{
  "asc_flags": [
    "--memoryBase 1024"
  ]
}

'''
'''--- tests/compiler/memorybase.ts ---
const staticData = memory.data(1);

assert(ASC_MEMORY_BASE == 1024);
assert(changetype<usize>(staticData) == ASC_MEMORY_BASE);

'''
'''--- tests/compiler/memset.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/memset.ts ---
function memset(dest: usize, c: u8, n: usize): usize {
  var ret = dest;

  // fill head and tail wwith minimal branching
  if (!n)
    return ret;
  store<u8>(dest, c);
  store<u8>(dest + n - 1, c);
  if (n <= 2)
    return ret;

  store<u8>(dest + 1, c);
  store<u8>(dest + 2, c);
  store<u8>(dest + n - 2, c);
  store<u8>(dest + n - 3, c);
  if (n <= 6)
    return ret;
  store<u8>(dest + 3, c);
  store<u8>(dest + n - 4, c);
  if (n <= 8)
    return ret;

  // advance pointer to align it at 4-byte boundary
  var k: usize = -dest & 3;
  dest += k;
  n -= k;
  n &= -4;

  var c32: u32 = <u32>-1 / 255 * c;

  // fill head/tail up to 28 bytes each in preparation
  store<u32>(dest, c32);
  store<u32>(dest + n - 4, c32);
  if (n <= 8)
    return ret;
  store<u32>(dest + 4, c32);
  store<u32>(dest + 8, c32);
  store<u32>(dest + n - 12, c32);
  store<u32>(dest + n - 8, c32);
  if (n <= 24)
    return ret;
  store<u32>(dest + 12, c32);
  store<u32>(dest + 16, c32);
  store<u32>(dest + 20, c32);
  store<u32>(dest + 24, c32);
  store<u32>(dest + n - 28, c32);
  store<u32>(dest + n - 24, c32);
  store<u32>(dest + n - 20, c32);
  store<u32>(dest + n - 16, c32);

  // align to a multiple of 8
  k = 24 + (dest & 4);
  dest += k;
  n -= k;

  // copy 32 bytes each
  var c64: u64 = <u64>c32 | (<u64>c32 << 32);
  while (n >= 32) {
    store<u64>(dest, c64);
    store<u64>(dest + 8, c64);
    store<u64>(dest + 16, c64);
    store<u64>(dest + 24, c64);
    n -= 32;
    dest += 32;
  }
  return ret;
}

var dest = __heap_base;
memset(dest, 1, 16);

assert(load<u8>(dest) == 1);
assert(load<u8>(dest + 15) == 1);

memset(dest + 1, 2, 14);

assert(load<u8>(dest) == 1);
assert(load<u8>(dest + 1) == 2);
assert(load<u8>(dest + 14) == 2);
assert(load<u8>(dest + 15) == 1);

'''
'''--- tests/compiler/merge.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/merge.ts ---
// variable can be shadowed by a type
const globalType: i32 = 2;
type globalType = bool;
globalType;
var globalType_test: globalType;

type typeGlobal = bool;
const typeGlobal: i32 = 3;
var typeGlobal_test: typeGlobal;
typeGlobal;

// namespace can be shadowed by a type
namespace namespaceType { export function test(): void {} }
type namespaceType = i32;
namespaceType.test();
var namespaceType_test: namespaceType;

type typeNamespace = i32;
namespace typeNamespace { export function test(): void {} }
var typeNamespace_test: typeNamespace;
typeNamespace.test();

// function can be shadowed by a type
function functionType(): void {}
type functionType = i32;
functionType();
var functionType_test: functionType;

type typeFunction = i32;
function typeFunction(): void {}
var typeFunction_test: typeFunction;
typeFunction();

// class can join with namespace
class classNamespace { static test1(): void {} }
namespace classNamespace { export function test2(): void {} }
classNamespace.test1();
classNamespace.test2();

namespace namespaceClass { export function test1(): void {} } // TS2434, but possible in AS
class namespaceClass { static test2(): void {} }
namespaceClass.test1();
namespaceClass.test2();

// function can join with namespace
function functionNamespace(): void {}
namespace functionNamespace { export function test(): void {} }
functionNamespace();
functionNamespace.test();

namespace namespaceFunction { export function test(): void {} } // TS2434, but possible in AS
function namespaceFunction(): void {}
namespaceFunction.test();
namespaceFunction();

// enum can join with namespace
enum enumNamespace { val = 1 }
namespace enumNamespace { export function test(): void {} }
enumNamespace.val;
enumNamespace.test();

namespace namespaceEnum { export function test(): void {} }
enum namespaceEnum { val = 2 }
namespaceEnum.test();
namespaceEnum.val;

// namespace can join with namespace
namespace namespaceNamespace { export function test1(): void {} }
namespace namespaceNamespace { export function test2(): void {} }
namespaceNamespace.test1();
namespaceNamespace.test2();

'''
'''--- tests/compiler/named-export-default.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/named-export-default.ts ---
function get3(): i32 {
  return 3;
}

export {get3 as default};

'''
'''--- tests/compiler/named-import-default.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/named-import-default.ts ---
import {
  default as get3
} from "./named-export-default";

export function getValue(): i32 {
  return get3();
}

'''
'''--- tests/compiler/namespace.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/namespace.ts ---
namespace Outer {
  export var outerVar: i32 = 1;
  export namespace Inner {
    export var aVar: i32 = 0;
    export var anotherVar: i32 = aVar;
    export var evenAnotherVar: i32 = outerVar;
    export function aFunc(): i32 { return aVar; }
    export enum anEnum { ONE = 1, TWO = 2 }
    export const enum aConstEnum { ONE = 1, TWO = 2 }
  }
}

Outer.Inner.aVar;
Outer.Inner.aFunc();
Outer.Inner.anEnum.ONE;
Outer.Inner.aConstEnum.TWO;

const enum Joined { // FIXME: tsc doesn't accept this when 'const'?
  THREE = 3
}
namespace Joined {
  export function anotherFunc(): i32 { return Joined.THREE; }
}

Joined.anotherFunc();

'''
'''--- tests/compiler/new.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/new.ts ---
class Ref {
  get ref(): Ref { return this; }
}

var ref: Ref;
ref = new Ref();
ref = new Ref;
ref = new Ref().ref;

class Gen<T> {
  get gen(): Gen<T> { return this; }
}

var gen: Gen<i32>;
gen = new Gen();
gen = new Gen<i32>();
gen = new Gen<i32>().gen;

namespace ns {
  export class Ref {
    get ref(): Ref { return this; }
  }
}

var ref2: ns.Ref;
ref2 = new ns.Ref();
ref2 = new ns.Ref;
ref2 = new ns.Ref().ref;

class GenExt extends Gen<i32> {
}

var genext = new GenExt();
var genext2: GenExt = new GenExt();
var genext3: Gen<i32> = new GenExt();

'''
'''--- tests/compiler/nonnullable.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/nullable.json ---
{
  "asc_flags": [
  ],
  "stderr": [
    "TS2322: Type 'nullable/Example | null' is not assignable to type 'nullable/Example'.",
    "EOF"
  ]
}

'''
'''--- tests/compiler/nullable.ts ---
class Example {}

function notNullable(a: Example): void {}

notNullable(null);

ERROR("EOF");

'''
'''--- tests/compiler/number.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/number.ts ---
// basic class bindings

// variable
var a = 1;
assert(a.toString() == "1");
// literal
assert(2..toString() == "2.0");
assert((3).toString() == "3");
// unary prefix
assert((-5).toString() == "-5");
assert((+4).toString() == "4");
assert((++a).toString() == "2");
assert((--a).toString() == "1");
assert((!0).toString() == "true");
assert((!1).toString() == "false");
// assert((~a).toString() == "-2");
// unary postfix
assert((a++).toString() == "1");
assert((a--).toString() == "2");

// float

assert(isNaN<f32>(F32.NaN));

assert(F32.isSafeInteger(f32.MIN_SAFE_INTEGER - 1) == false);
assert(F32.isSafeInteger(f32.MIN_SAFE_INTEGER) == true);
assert(F32.isSafeInteger(+0.0) == true);
assert(F32.isSafeInteger(-0.0) == true);
assert(F32.isSafeInteger(NaN) == false);
assert(F32.isSafeInteger(Infinity) == false);
assert(F32.isSafeInteger(f32.MAX_SAFE_INTEGER) == true);
assert(F32.isSafeInteger(f32.MAX_SAFE_INTEGER + 1) == false);
assert(F32.isSafeInteger(0.5) == false);
assert(F32.isInteger(+0.0) == true);
assert(F32.isInteger(-0.0) == true);
assert(F32.isInteger(NaN) == false);
assert(F32.isInteger(Infinity) == false);
assert(F32.isInteger(f32.EPSILON) == false);
assert(F32.isInteger(+1.0) == true);
assert(F32.isInteger(-1.0) == true);
assert(F32.isInteger(f32.MIN_SAFE_INTEGER) == true);
assert(F32.isInteger(f32.MAX_SAFE_INTEGER) == true);
assert(F32.isInteger(+0.5) == false);
assert(F32.isInteger(-1.5) == false);

assert(isNaN<f64>(F64.NaN));

assert(F64.isSafeInteger(f64.MIN_SAFE_INTEGER - 1) == false);
assert(F64.isSafeInteger(f64.MIN_SAFE_INTEGER) == true);
assert(F64.isSafeInteger(+0.0) == true);
assert(F64.isSafeInteger(-0.0) == true);
assert(F64.isSafeInteger(NaN) == false);
assert(F64.isSafeInteger(Infinity) == false);
assert(F64.isSafeInteger(f64.MAX_SAFE_INTEGER) == true);
assert(F64.isSafeInteger(f64.MAX_SAFE_INTEGER + 1) == false);
assert(F64.isSafeInteger(0.5) == false);
assert(F64.isInteger(+0.0) == true);
assert(F64.isInteger(-0.0) == true);
assert(F64.isInteger(NaN) == false);
assert(F64.isInteger(Infinity) == false);
assert(F64.isInteger(f64.EPSILON) == false);
assert(F64.isInteger(+1.0) == true);
assert(F64.isInteger(-1.0) == true);
assert(F64.isInteger(f64.MIN_SAFE_INTEGER) == true);
assert(F64.isInteger(f64.MAX_SAFE_INTEGER) == true);
assert(F64.isInteger(+0.5) == false);
assert(F64.isInteger(-1.5) == false);

'''
'''--- tests/compiler/object-literal.json ---
{
  "asc_flags": [
  ],
  "asc_rtrace": true
}

'''
'''--- tests/compiler/object-literal.ts ---
// Should work with managed classes

class Managed {
  bar: i32;
  baz: string;
}

function testManaged(managed: Managed): void {
  assert(managed.bar == 123);
  assert(managed.baz == "hello world");
}

testManaged({
  bar: 123,
  baz: "hello world"
});

// Should work with unmanaged classes

@unmanaged
class Unmanaged {
  bar: i32;
  baz: string;
}

function testUnmanaged(unmanaged: Unmanaged): void {
  assert(unmanaged.bar == 123);
  assert(unmanaged.baz == "hello");
  __free(changetype<usize>(unmanaged));
}

testUnmanaged({
  bar: 123,
  baz: "hello world".substring(0, 5)
});

// Should work with omitted fields

class OmittedTypes {
  int32: i32;
  uint32: u32;
  int64: i64;
  uint64: u64;
  float32: f32;
  float64: f64;
  int8: i8;
  uint8: u8;
  int16: i16;
  uint16: u16;
  intsize: isize;
  uintsize: usize;
  alias: number;
  isTrue: boolean;
}

function testOmittedTypes(omitted: OmittedTypes): void {
  assert(omitted.int32 == 0);
  assert(omitted.uint32 == 0);
  assert(omitted.int64 == 0);
  assert(omitted.uint64 == 0);
  assert(omitted.float32 == 0);
  assert(omitted.float64 == 0);
  assert(omitted.int8 == 0);
  assert(omitted.uint8 == 0);
  assert(omitted.int16 == 0);
  assert(omitted.uint16 == 0);
  assert(omitted.intsize == 0);
  assert(omitted.uintsize == 0);
  assert(omitted.alias == 0);
  assert(omitted.isTrue == false);
}

testOmittedTypes({});

class MixedOmitted {
  simpleType: i32;
  complexType: string;
  anotherSimpleType: f64;
}

function testMixedOmitted(omitted: MixedOmitted): void {
  assert(omitted.simpleType == 0);
  assert(omitted.complexType == "test");
  assert(omitted.anotherSimpleType == 0);
}

testMixedOmitted({
  simpleType: 0,
  complexType: "test"
});

// Test omitted fields
class OmittedFoo {
  bar: string = "bar";
  baz: string | null = "baz";
  quux: string | null;
  quuz: string | null;
  corge: string | null;
  grault: string | null;
  garply: string | null;
  waldo: string | null;
  fred: i32;
  qux: i32 = -1;
}

function testOmittedFoo(foo: OmittedFoo): void {
  assert(foo.bar == "bar");
  assert(foo.baz == "baz");
  assert(foo.quux == null);
  assert(foo.quuz == null);
  assert(foo.corge == null);
  assert(foo.grault == null);
  assert(foo.garply == null);
  assert(foo.waldo == null);
  assert(foo.fred == 0);
  assert(foo.qux == -1);
}

testOmittedFoo({});

__stack_pointer = __heap_base;
__collect();

'''
'''--- tests/compiler/optional-typeparameters.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/optional-typeparameters.ts ---
function testConcrete<T,U = i32>(a: T): U {
  return a;
}

function testDerived<T,U = T>(a: T): U {
  return a;
}

testConcrete<i32>(1);
testDerived<i32>(2);

class TestConcrete<T,U = i32> {
  test<V = i32>(a: T, b: U): V {
    return a + b;
  }
}

class TestDerived<T,U = T> {
  test<V = U>(a: T, b: U): V {
    return a + b;
  }
}

var tConcrete = new TestConcrete<i32>();
tConcrete.test<i32>(1, 2);
var tDerived = new TestDerived<f64>();
tDerived.test<f64>(1, 2);

'''
'''--- tests/compiler/overflow.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/overflow.ts ---
// becomes simplified: val++
// uses a temp. local: ctx = val++

// i8
{
  let val: i8 = 127;
  let ctx: i8;

  val++;
  assert(val == -128);

  val--;
  assert(val == 127);

  ctx = val++;
  assert(val == -128);

  ctx = val--;
  assert(val == 127);

  ++val;
  assert(val == -128);

  --val;
  assert(val == 127);

  ctx = ++val;
  assert(val == -128);

  ctx = --val;
  assert(val == 127);

  assert(val + 1 == -128);
}

// i16
{
  let val: i16 = 32767;
  let ctx: i16;

  val++;
  assert(val == -32768);

  val--;
  assert(val == 32767);

  ctx = val++;
  assert(val == -32768);

  ctx = val--;
  assert(val == 32767);

  ++val;
  assert(val == -32768);

  --val;
  assert(val == 32767);

  ctx = ++val;
  assert(val == -32768);

  ctx = --val;
  assert(val == 32767);

  assert(val + 1 == -32768);
}

// u8
{
  let val: u8 = 0;
  let ctx: u8;

  val--;
  assert(val == 0xff);

  val++;
  assert(val == 0);

  ctx = val--;
  assert(val == 0xff);

  ctx = val++;
  assert(val == 0);

  --val;
  assert(val == 0xff);

  ++val;
  assert(val == 0);

  ctx = --val;
  assert(val == 0xff);

  ctx = ++val;
  assert(val == 0);

  assert(val - 1 == 0xff);
}

// u16
{
  let val: u16 = 0;
  let ctx: u16;

  val--;
  assert(val == 0xffff);

  val++;
  assert(val == 0);

  ctx = val--;
  assert(val == 0xffff);

  ctx = val++;
  assert(val == 0);

  --val;
  assert(val == 0xffff);

  ++val;
  assert(val == 0);

  ctx = --val;
  assert(val == 0xffff);

  ctx = ++val;
  assert(val == 0);

  assert(val - 1 == 0xffff);
}

'''
'''--- tests/compiler/portable-conversions.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/portable-conversions.ts ---
var i: i32 = 1;
var I: i64 = 1;
var f: f32 = 1;
var F: f64 = 1;

assert(i8(i));
assert(i8(I));
assert(i8(f));
assert(i8(F));

assert(i16(i));
assert(i16(I));
assert(i16(f));
assert(i16(F));

assert(i32(i));
assert(i32(I));
assert(i32(f));
assert(i32(F));

assert(i64(i));
assert(i64(I));
assert(i64(f));
assert(i64(F));

assert(isize(i));
assert(isize(I));
assert(isize(f));
assert(isize(F));

assert(u8(i));
assert(u8(I));
assert(u8(f));
assert(u8(F));

assert(u16(i));
assert(u16(I));
assert(u16(f));
assert(u16(F));

assert(u32(i));
assert(u32(I));
assert(u32(f));
assert(u32(F));

assert(u64(i));
assert(u64(I));
assert(u64(f));
assert(u64(F));

assert(usize(i));
assert(usize(I));
assert(usize(f));
assert(usize(F));

assert(bool(i));
assert(bool(I));
assert(bool(f));
assert(bool(F));

assert(f32(i));
assert(f32(I));
assert(f32(f));
assert(f32(F));

assert(f64(i));
assert(f64(I));
assert(f64(f));
assert(f64(F));

'''
'''--- tests/compiler/possibly-null.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/possibly-null.ts ---
class Ref {}

// the following makes use of the fact that branches that can be eliminated statically
// won't become compiled, hence the ERROR statement is never executed.

export function testTrue(a: Ref | null): void {
  if (a) {
    if (isNullable(a)) ERROR("should be non-nullable");
  }
}

export function testFalseElse(a: Ref | null): void {
  if (!a) return;
  else {
    if (isNullable(a)) ERROR("should be non-nullable");
  }
}

export function testFalseContinuation(a: Ref | null): void {
  if (!a) return;
  if (isNullable(a)) ERROR("should be non-nullable");
}

export function testNeNull(a: Ref | null): void {
  if (a != null) {
    if (isNullable(a)) ERROR("should be non-nullable");
  }
}

export function testEqNullElse(a: Ref | null): void {
  if (a == null) return;
  else {
    if (isNullable(a)) ERROR("should be non-nullable");
  }
}

export function testEqNullContinuation(a: Ref | null): void {
  if (a == null) return;
  if (isNullable(a)) ERROR("should be non-nullable");
}

export function testNotEqNull(a: Ref | null): void {
  if (!(a == null)) {
    if (isNullable(a)) ERROR("should be non-nullable");
  }
}

export function testNotNeNullElse(a: Ref | null): void {
  if (!(a != null)) return;
  else {
    if (isNullable(a)) ERROR("should be non-nullable");
  }
}

export function testNotNeNullContinuation(a: Ref | null): void {
  if (!(a != null)) return;
  if (isNullable(a)) ERROR("should be non-nullable");
}

export function testWhile(a: Ref | null): void {
  while (a) {
    if (isNullable(a)) ERROR("should be non-nullable");
    a = null;
    if (!isNullable(a)) ERROR("should be nullable again");
  }
}

export function testWhile2(a: Ref | null, b: Ref | null): void {
  while (a) {
    if (isNullable(a)) ERROR("should be non-nullable");
    a = b;
    if (!isNullable(a)) ERROR("should be nullable again");
  }
}

export function testWhile3(a: Ref | null, b: Ref | null): void {
  while (a) {
    if (isNullable(a)) ERROR("should be non-nullable");
    if (b) {
      a = b;
      if (isNullable(a)) ERROR("should be non-nullable still");
    }
  }
}

function requireNonNull(a: Ref): Ref {
  return a;
}

export function testLogicalAnd(a: Ref | null): void {
  a && requireNonNull(a);
}

export function testLogicalOr(a: Ref | null): void {
  !a || requireNonNull(a) != null;
}

export function testLogicalAndMulti(a: Ref | null, b: Ref | null): void {
  if (a && b) {
    if (isNullable(a)) ERROR("should be non-nullable");
    if (isNullable(b)) ERROR("should be non-nullable");
  } else {
    if (!isNullable(a)) ERROR("should be nullable");
    if (!isNullable(b)) ERROR("should be nullable");
  }
}

export function testLogicalOrMulti(a: Ref | null, b: Ref | null): void {
  if (!a || !b) {
    if (!isNullable(a)) ERROR("should be nullable");
    if (!isNullable(b)) ERROR("should be nullable");
  } else {
    if (isNullable(a)) ERROR("should be non-nullable");
    if (isNullable(b)) ERROR("should be non-nullable");
  }
}

export function testAssign(a: Ref | null, b: Ref): void {
  a = b;
  if (isNullable(a)) ERROR("should be non-nullable");
}

export function testNeverNull(a: Ref | null): void {
  if (a) {
    a!; // INFO AS225: Expression is never 'null'.
  }
}

'''
'''--- tests/compiler/recursive.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/recursive.ts ---
export function fib(n: i32): i32 {
  if (n <= 1) return 1;
  return fib(n - 1) + fib(n - 2);
}

'''
'''--- tests/compiler/reexport.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/reexport.ts ---
export {
  add,
  sub as renamed_sub,
  renamed_mul,
  renamed_mul as rerenamed_mul,

  a,
  b as renamed_b,
  renamed_c,
  renamed_c as rerenamed_c
} from "./export";

export {
  Car
} from "./exports";

import {
  add as imported_add,
  renamed_mul as imported_sub,
  ns as imported_ns
} from "./export";

export {
  imported_add as renamed_add,
  imported_sub as rerenamed_sub
};

imported_add(1, 2) + imported_sub(3, 4);

export { ns as renamed_ns } from "./export";

import * as exportstar from "./exportstar";
export { exportstar };

import * as ExportsNamespace from "./exports";
export { ExportsNamespace };
assert(ExportsNamespace.add(2, 2) == 4);
assert(ExportsNamespace.renamed_mul(2, 2) == 4);
let car: ExportsNamespace.Car = new ExportsNamespace.Car();
assert(car.numDoors == 2);

export { default } from "./export-default";
export { default as renamed_default } from "./export-default";

'''
'''--- tests/compiler/rereexport.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/rereexport.ts ---
export {
  a,
  a as renamed_a,
  renamed_b,
  renamed_b as renamed_renamed_b,
  default,
  default as renamed_default
} from "./reexport";

import { exportstar } from "./reexport";
export { exportstar };

import * as ReexportsNamespace from "./reexport";
// Test our import * as namespace works with different types.
assert(ReexportsNamespace.add(2, 2) == 4);
assert(ReexportsNamespace.rerenamed_mul(2, 2) == 4);
let car: ReexportsNamespace.Car = new ReexportsNamespace.Car();
assert(car.numDoors == 2);

// Test our imported namespace with the exported import * as namespace.
assert(ReexportsNamespace.ExportsNamespace.add(2, 2) == 4);
assert(ReexportsNamespace.ExportsNamespace.renamed_mul(2, 2) == 4);
let exportsNamespaceCar: ReexportsNamespace.Car = new ReexportsNamespace.ExportsNamespace.Car();
assert(exportsNamespaceCar.numDoors == 2);

'''
'''--- tests/compiler/resolve-access.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/resolve-access.ts ---
export function arrayAccess(): string {
  let arr: u64[] = [1];
  return arr[0].toString();
}

class Container {
  foo: u64;

  toU32(): u32 {
    return this.foo as u32;
  }
}

export function fieldAccess(): string {
  let container = new Container();
  container.foo = 1;
  return container.foo.toString();
}

export function propertyAccess(): string {
  let container = new Container();
  container.foo = 1;
  return container.toU32().toString();
}

'''
'''--- tests/compiler/resolve-binary.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/resolve-binary.ts ---
// comparison
assert(
  (1 < 2).toString()
  ==
  "true"
);
assert(
  (1 > 2).toString()
  ==
  "false"
);
assert(
  (1 <= 2).toString()
  ==
  "true"
);
assert(
  (1 >= 2).toString()
  ==
  "false"
);
assert(
  (1 == 2).toString()
  ==
  "false"
);
assert(
  (1 != 2).toString()
  ==
  "true"
);

// identity
assert(
  ("a" === "a").toString()
  ==
  "true"
);
assert(
  ("a" !== "a").toString()
  ==
  "false"
);

// assignment
var a: i32;
var f: f64;
assert(
  (a = 1).toString()
  ==
  "1"
);
assert(
  (a += 1).toString()
  ==
  "2"
);
assert(
  (a -= 1).toString()
  ==
  "1"
);
assert(
  (a *= 2).toString()
  ==
  "2"
);
f = 2;
assert(
  (f **= 2).toString()
  ==
  "4.0"
);
a = 4;
assert(
  (a /= 2).toString()
  ==
  "2"
);
assert(
  (a %= 3).toString()
  ==
  "2"
);
assert(
  (a <<= 1).toString()
  ==
  "4"
);
assert(
  (a >>= 1).toString()
  ==
  "2"
);
assert(
  (a >>>= 1).toString()
  ==
  "1"
);
assert(
  (a &= 3).toString()
  ==
  "1"
);
assert(
  (a |= 3).toString()
  ==
  "3"
);
assert(
  (a ^= 2).toString()
  ==
  "1"
);

// arithmetics
assert(
  (1 + 2).toString()
  ==
  "3"
);
assert(
  (1 - 2).toString()
  ==
  "-1"
);
assert(
  (1 * 2).toString()
  ==
  "2"
);
assert(
  (4 / 2).toString()
  ==
  "2"
);
assert(
  (3 % 2).toString()
  ==
  "1"
);

// pow i32 only
assert(
  (2 ** 2).toString()
  ==
  "4"
);

// pow mixed i32 and f64
assert(
  (2 ** 2.0).toString()
  ==
  "4.0"
);

// pow mixed f64 and i32
assert(
  (2.0 ** 2).toString()
  ==
  "4.0"
);

// shift
assert(
  (2 << 1).toString()
  ==
  "4"
);
assert(
  (2 >> 1).toString()
  ==
  "1"
);
assert(
  (-1 >>> 30).toString()
  ==
  "3"
);

// bitwise
assert(
  (3 & 1).toString()
  ==
  "1"
);
assert(
  (1 | 2).toString()
  ==
  "3"
);
assert(
  (1 ^ 3).toString()
  ==
  "2"
);

// logical
assert(
  (1 && 2).toString()
  ==
  "2"
);
assert(
  (0 && 2).toString()
  ==
  "0"
);
assert(
  (1 || 2).toString()
  ==
  "1"
);
assert(
  (0 || 2).toString()
  ==
  "2"
);

// overloads
class Foo {
  @operator("<")
  lt(other: Foo): string {
    return "lt";
  }
  @operator(">")
  gt(other: Foo): string {
    return "gt";
  }
  @operator("<=")
  le(other: Foo): string {
    return "le";
  }
  @operator(">=")
  ge(other: Foo): string {
    return "ge";
  }
  @operator("==")
  eq(other: Foo): string {
    return "eq";
  }
  @operator("!=")
  ne(other: Foo): string {
    return "ne";
  }
  @operator("+")
  add(other: Foo): string {
    return "add";
  }
  @operator("-")
  static sub(a: Foo, b: Foo): string { // same for static
    return "sub";
  }
  @operator("*")
  mul(other: Foo): string {
    return "mul";
  }
  @operator("/")
  div(other: Foo): string {
    return "div";
  }
  @operator("%")
  rem(other: Foo): string {
    return "rem";
  }
  @operator("**")
  pow(other: Foo): string {
    return "pow";
  }
  self(): Foo {
    return this;
  }
}
var foo = new Foo();
assert(
  (foo < foo).toString()
  ==
  "lt"
);
assert(
  (foo > foo).toString()
  ==
  "gt"
);
assert(
  (foo <= foo).toString()
  ==
  "le"
);
assert(
  (foo >= foo).toString()
  ==
  "ge"
);
assert(
  (foo == foo).toString()
  ==
  "eq"
);
assert(
  (foo != foo).toString()
  ==
  "ne"
);
assert(
  (foo + foo).toString()
  ==
  "add"
);
assert(
  (foo - foo).toString()
  ==
  "sub"
);
assert(
  (foo * foo).toString()
  ==
  "mul"
);
assert(
  (foo / foo).toString()
  ==
  "div"
);
assert(
  (foo % foo).toString()
  ==
  "rem"
);
assert(
  (foo ** foo).toString()
  ==
  "pow"
);

// overload with compatible compound assignment
class Bar {
  @operator("+")
  add(other: Bar): Bar {
    return other;
  }
  self(): Bar {
    return this;
  }
}
var bar = new Bar();
var bar2 = new Bar();
assert(
  (bar += bar2).self()
  ==
  bar2
);
assert(bar === bar2);

'''
'''--- tests/compiler/resolve-elementaccess.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/resolve-elementaccess.ts ---
// Direct
var arr = new Float32Array(2);
arr[0] = 1;
arr[1] = 2;
assert(
  arr[0].toString()
  ==
  "1.0"
);
assert(
  (arr[1]).toString()
  ==
  "2.0"
);
assert(
  (arr[0] += 10).toString()
  ==
  "11.0"
);
arr[0] += 10; // void context
assert(arr[0] == 21.0);

// Inherited
class Buffer extends Uint8Array {}
var buf = new Buffer(2);
buf[0] = 1;
buf[1] = 2;
assert(
  buf[0].toString()
  ==
  "1"
);
assert(
  (buf[1]).toString()
  ==
  "2"
);
assert(
  (buf[0] += 10).toString()
  ==
  "11"
);
buf[0] += 10; // void context
assert(buf[0] == 21);

'''
'''--- tests/compiler/resolve-function-expression.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/resolve-function-expression.ts ---
assert(
  ((a: i32): i32 => a + 40)(2)
  ==
  42
);
assert(
  (function(a: i32): i32 { return a + 41; })(1)
  ==
  42
);
assert(
  ((a: i32): i32 => a + 42)(0).toString()
  ==
  "42"
);

'''
'''--- tests/compiler/resolve-nested.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/resolve-nested.ts ---
class OuterClass {}
export namespace Outer {
  export class InnerClass {}
  export namespace Inner {
    export class EvenInnerClass {}
    var a: OuterClass;
    var b: InnerClass;
    var c: EvenInnerClass;
    var d: Outer.InnerClass;
    var e: Outer.Inner.EvenInnerClass;
    var f: Inner.EvenInnerClass;
    export function evenInner(
      a: OuterClass,
      b: InnerClass,
      c: EvenInnerClass,
      d: Outer.InnerClass,
      e: Outer.Inner.EvenInnerClass,
      f: Inner.EvenInnerClass
    ): void {}
  }
  var a: OuterClass;
  var b: InnerClass;
  var c: Inner.EvenInnerClass;
  var d: Outer.InnerClass;
  var e: Outer.Inner.EvenInnerClass;
  export function inner(
    a: OuterClass,
    b: InnerClass,
    c: Inner.EvenInnerClass,
    d: Outer.InnerClass,
    e: Outer.Inner.EvenInnerClass
  ): void {}
}
var a: OuterClass;
var b: Outer.InnerClass;
var c: Outer.Inner.EvenInnerClass;
export function outer(
  a: OuterClass,
  b: Outer.InnerClass,
  c: Outer.Inner.EvenInnerClass
): void {}

'''
'''--- tests/compiler/resolve-new.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/resolve-new.ts ---
class Foo {
  bar(): void {}
}
var foo = new Foo();
(new Foo()).bar();

'''
'''--- tests/compiler/resolve-propertyaccess.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/resolve-propertyaccess.ts ---
namespace Namespace {
  export const member = 1;
  @lazy export const lazyMember = 11;
}

assert(
  (Namespace.member).toString()
  ==
  "1"
);

assert(
  (Namespace.lazyMember).toString()
  ==
  "11"
);

function MergedNamespace(): i32 { return 0; }
namespace MergedNamespace {
  export const member = 2;
  @lazy export const lazyMember = 22;
}

assert(
  (MergedNamespace.member).toString()
  ==
  "2"
);

assert(
  (MergedNamespace.lazyMember).toString()
  ==
  "22"
);

namespace TypedNamespace {
  export const member = 3;
  @lazy export const lazyMember = 33;
}
type TypedNamespace = string;

assert(
  (TypedNamespace.member).toString()
  ==
  "3"
);

assert(
  (TypedNamespace.lazyMember).toString()
  ==
  "33"
);

enum Enum {
  VALUE = 4
}

assert(
  (Enum.VALUE).toString()
  ==
  "4"
);

class Class {
  static staticField: i32 = 5;
  @lazy static lazyStaticField: i32 = 55;
  instanceField: i32 = 6;
  static get staticProperty(): i32 { return 7; }
  get instanceProperty(): i32 { return 8; }
}

assert(
  (Class.staticField).toString()
  ==
  "5"
);

assert(
  (Class.lazyStaticField).toString()
  ==
  "55"
);

assert(
  (Class.staticProperty).toString()
  ==
  "7"
);

{
  let instance = new Class();
  assert(
    (instance.instanceField).toString()
    ==
    "6"
  );
  assert(
    (instance.instanceProperty).toString()
    ==
    "8"
  );
}

'''
'''--- tests/compiler/resolve-ternary.ts ---
var b = true;

// literal

assert(
  (b ? 1 : 2).toString()
  ==
  "1"
);

// literal mismatch (convert lhs to f64)

assert(
  (b ? 1 : 2.0).toString()
  ==
  "1.0"
);

// function type

const f1 = (x: i32): i32 => x + 1;
const f2 = (x: i32): i32 => x + 2;

assert(
  (b ? f1 : f2)(1)
  ==
  2
);

// function type from identifier

function g1(x: i32): i32 { return x + 3; }
function g2(x: i32): i32 { return x + 4; }

assert(
  (b ? g1 : g2)(1)
  ==
  4
);

// function type mixed

assert(
  (b ? f2 : g2)(1)
  ==
  3
);

'''
'''--- tests/compiler/resolve-unary.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/resolve-unary.ts ---
// prefix
assert(
  (-1).toString()
  ==
  "-1"
);
assert(
  (+1).toString()
  ==
  "1"
);
var a = 1;
assert(
  (++a).toString()
  ==
  "2"
);
assert(
  (--a).toString()
  ==
  "1"
);
assert(
  (!a).toString()
  ==
  "false"
);
assert(
  (!!a).toString()
  ==
  "true"
);
assert(
  (~a).toString()
  ==
  "-2"
);

// postfix
var b = 1;
assert(
  (b++).toString()
  ==
  "1"
);
assert(
  (b--).toString()
  ==
  "2"
);

// overloads
class Foo {
  @operator.prefix("+")
  plus(): string {
    return "+";
  }
  @operator.prefix("-")
  minus(): string {
    return "-";
  }
  @operator.prefix("++")
  prefix_inc(): Foo {
    return this;
  }
  @operator.prefix("--")
  prefix_dec(): Foo {
    return this;
  }
  @operator.prefix("!")
  not(): string {
    return "!";
  }
  @operator.prefix("~")
  bitwise_not(): string {
    return "~";
  }
  @operator.postfix("++")
  postfix_inc(): Foo  {
    return this;
  }
  @operator.postfix("--")
  postfix_dec(): Foo  {
    return this;
  }
  self(): Foo {
    return this;
  }
}
var foo = new Foo();
assert(
  (+foo).toString()
  ==
  "+"
);
assert(
  (-foo).toString()
  ==
  "-"
);
assert(
  (++foo).self()
  ==
  foo
);
assert(
  (--foo).self()
  ==
  foo
);
assert(
  (!foo).toString()
  ==
  "!"
);
assert(
  (~foo).toString()
  ==
  "~"
);
assert(
  (foo++).self()
  ==
  foo
);
assert(
  (foo--).self()
  ==
  foo
);
class Bar {
  // static inc/dec don't reassign and can have different return type
  @operator.prefix("++")
  static prefix_inc(a: Foo): string {
    return "++i";
  }
  @operator.prefix("--")
  static prefix_dec(a: Foo): string {
    return "--i";
  }
  @operator.postfix("++")
  static postfix_inc(a: Foo): string {
    return "i++";
  }
  @operator.postfix("--")
  static postfix_dec(a: Foo): string {
    return "i--";
  }
}
var bar = new Bar();
assert(
  (++bar).toString()
  ==
  "++i"
);
assert(
  (--bar).toString()
  ==
  "--i"
);
assert(
  (bar++).toString()
  ==
  "i++"
);
assert(
  (bar--).toString()
  ==
  "i--"
);

'''
'''--- tests/compiler/retain-i32.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/retain-i32.ts ---
function test(a: u32, b: u32): void {

  // signed
  assert(<i8>(a + b) == <i8>(<i8>a + <i8>b));
  assert(<i8>(a - b) == <i8>(<i8>a - <i8>b));
  assert(<i8>(a * b) == <i8>(<i8>a * <i8>b));
  assert(<i8>(a & b) == <i8>(<i8>a & <i8>b));
  assert(<i8>(a | b) == <i8>(<i8>a | <i8>b));
  assert(<i8>(a ^ b) == <i8>(<i8>a ^ <i8>b));
  assert(<i8>(a << (b & 7)) == <i8>(<i8>a << <i8>b));

  // unsigned
  assert(<u8>(a + b) == <u8>(<u8>a + <u8>b));
  assert(<u8>(a - b) == <u8>(<u8>a - <u8>b));
  assert(<u8>(a * b) == <u8>(<u8>a * <u8>b));
  assert(<u8>(a & b) == <u8>(<u8>a & <u8>b));
  assert(<u8>(a | b) == <u8>(<u8>a | <u8>b));
  assert(<u8>(a ^ b) == <u8>(<u8>a ^ <u8>b));
  assert(<u8>(a << (b & 7)) == <u8>(<u8>a << <u8>b));
}

// signed
test(0, i8.MAX_VALUE);
test(i8.MAX_VALUE, 0);

test(1, i8.MAX_VALUE);
test(i8.MAX_VALUE, 1);

test(-1, i8.MAX_VALUE);
test(i8.MAX_VALUE, -1);

test(0, i8.MIN_VALUE);
test(i8.MIN_VALUE, 0);

test(1, i8.MIN_VALUE);
test(i8.MIN_VALUE, 1);

test(-1, i8.MIN_VALUE);
test(i8.MIN_VALUE, -1);

test(i8.MAX_VALUE, i8.MAX_VALUE);
test(i8.MIN_VALUE, i8.MIN_VALUE);
test(i8.MAX_VALUE, i8.MIN_VALUE);
test(i8.MIN_VALUE, i8.MAX_VALUE);

// unsigned
test(0, u8.MAX_VALUE);
test(u8.MAX_VALUE, 0);

test(1, u8.MAX_VALUE);
test(u8.MAX_VALUE, 1);

test(-1, u8.MAX_VALUE);
test(u8.MAX_VALUE, -1);

test(u8.MAX_VALUE, u8.MAX_VALUE);

// various
for (var i: i32 = i8.MIN_VALUE; i <= <i32>u8.MAX_VALUE; ++i) {
  test(0, i);
  test(1, i);
  test(-1, i);
  test(i8.MIN_VALUE, i);
  test(i8.MAX_VALUE, i);
  test(u8.MAX_VALUE, i);
  test(i16.MIN_VALUE, i);
  test(i16.MAX_VALUE, i);
  test(u16.MAX_VALUE, i);
  test(i32.MAX_VALUE, i);
  test(i32.MIN_VALUE, i);
  test(u32.MAX_VALUE, i);
}

// visually
var si: i8;

si = 127 + 127 + 1;   // sign-extends exactly once
assert(si == -1);

si = 127 - 1 - 127;   // sign-extends exactly once
assert(si == -1);

si = 127 * 2;         // sign-extends exactly once
assert(si == -2);

si = -(-128);         // -MIN_VALUE == MIN_VALUE
assert(si == -128);

si = -128 * -1;       // -MIN_VALUE == MIN_VALUE
assert(si == -128);

si = 127 / -1;
assert(si == -127);

si = -128 / -1;       // -MIN_VALUE == MIN_VALUE
assert(si == -128);

si = 127 % 2;
assert(si == 1);

si = 1 % 127;
assert(si == 1);

si = -128 % 2;
assert(si == 0);

si = 1 % -128;
assert(si == 1);

var ui: u8;

ui = 255 + 255 + 1;
assert(ui == 255);

ui = 255 - 1 - 255;
assert(ui == 255);

ui = 255 * 2;
assert(ui == 254);

ui = 255 * 255;
assert(ui == 1);

ui = 255 / 255;
assert(ui == 1);

ui = 255 % 2;
assert(ui == 1);

ui = 255 % 255;
assert(ui == 0);

// inferring global type from load should still retain T
var ri = load<i8>(0);
assert(ri instanceof i8);

// inferring local type from load should still retain T
function testLocalRetain(): void {
  var ri = load<i8>(0);
  assert(ri instanceof i8);
}
testLocalRetain();

'''
'''--- tests/compiler/rt/finalize.json ---
{
  "asc_flags": [
    "--explicitStart"
  ]
}

'''
'''--- tests/compiler/rt/finalize.ts ---
var expect: usize = 0;
var ran = false;

// @ts-ignore
@global function __finalize(ptr: usize): void {
  assert(ptr == expect);
  ran = true;
}

class Ref {}
expect = changetype<usize>(new Ref());
__collect();
assert(ran);

'''
'''--- tests/compiler/rt/flags.json ---
{
  "features": [
    "simd"
  ],
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/rt/flags.ts ---
/// <reference path="../../../std/assembly/rt/index.d.ts" />

import { TypeinfoFlags } from "shared/typeinfo";

function test<T>(flags: TypeinfoFlags): void {
  assert(
    __typeinfo(idof<T>())
    ==
    flags
  );
}

// structure flags

test<Int8Array>(TypeinfoFlags.ARRAYBUFFERVIEW | TypeinfoFlags.VALUE_ALIGN_0 | TypeinfoFlags.VALUE_SIGNED);
test<Uint8Array>(TypeinfoFlags.ARRAYBUFFERVIEW | TypeinfoFlags.VALUE_ALIGN_0);
test<Uint8ClampedArray>(TypeinfoFlags.ARRAYBUFFERVIEW | TypeinfoFlags.VALUE_ALIGN_0);
test<Int16Array>(TypeinfoFlags.ARRAYBUFFERVIEW | TypeinfoFlags.VALUE_ALIGN_1 | TypeinfoFlags.VALUE_SIGNED);
test<Uint16Array>(TypeinfoFlags.ARRAYBUFFERVIEW | TypeinfoFlags.VALUE_ALIGN_1);
test<Int32Array>(TypeinfoFlags.ARRAYBUFFERVIEW | TypeinfoFlags.VALUE_ALIGN_2 | TypeinfoFlags.VALUE_SIGNED);
test<Uint32Array>(TypeinfoFlags.ARRAYBUFFERVIEW | TypeinfoFlags.VALUE_ALIGN_2);
test<Int64Array>(TypeinfoFlags.ARRAYBUFFERVIEW | TypeinfoFlags.VALUE_ALIGN_3 | TypeinfoFlags.VALUE_SIGNED);
test<Uint64Array>(TypeinfoFlags.ARRAYBUFFERVIEW | TypeinfoFlags.VALUE_ALIGN_3);
test<Float32Array>(TypeinfoFlags.ARRAYBUFFERVIEW | TypeinfoFlags.VALUE_ALIGN_2 | TypeinfoFlags.VALUE_SIGNED | TypeinfoFlags.VALUE_FLOAT);
test<Float64Array>(TypeinfoFlags.ARRAYBUFFERVIEW | TypeinfoFlags.VALUE_ALIGN_3 | TypeinfoFlags.VALUE_SIGNED | TypeinfoFlags.VALUE_FLOAT);

class Ref {}

const VALUE_ALIGN_REF = sizeof<usize>() == 4 ? TypeinfoFlags.VALUE_ALIGN_2 : TypeinfoFlags.VALUE_ALIGN_3;
const KEY_ALIGN_REF = sizeof<usize>() == 4 ? TypeinfoFlags.KEY_ALIGN_2 : TypeinfoFlags.KEY_ALIGN_3;

test<Array<i8>>(TypeinfoFlags.ARRAY | TypeinfoFlags.VALUE_ALIGN_0 | TypeinfoFlags.VALUE_SIGNED);
test<Array<u8>>(TypeinfoFlags.ARRAY | TypeinfoFlags.VALUE_ALIGN_0);
test<Array<i16>>(TypeinfoFlags.ARRAY | TypeinfoFlags.VALUE_ALIGN_1 | TypeinfoFlags.VALUE_SIGNED);
test<Array<u16>>(TypeinfoFlags.ARRAY | TypeinfoFlags.VALUE_ALIGN_1);
test<Array<i32>>(TypeinfoFlags.ARRAY | TypeinfoFlags.VALUE_ALIGN_2 | TypeinfoFlags.VALUE_SIGNED);
test<Array<u32>>(TypeinfoFlags.ARRAY | TypeinfoFlags.VALUE_ALIGN_2);
test<Array<i64>>(TypeinfoFlags.ARRAY | TypeinfoFlags.VALUE_ALIGN_3 | TypeinfoFlags.VALUE_SIGNED);
test<Array<u64>>(TypeinfoFlags.ARRAY | TypeinfoFlags.VALUE_ALIGN_3);
test<Array<f32>>(TypeinfoFlags.ARRAY | TypeinfoFlags.VALUE_ALIGN_2 | TypeinfoFlags.VALUE_SIGNED | TypeinfoFlags.VALUE_FLOAT);
test<Array<f64>>(TypeinfoFlags.ARRAY | TypeinfoFlags.VALUE_ALIGN_3 | TypeinfoFlags.VALUE_SIGNED | TypeinfoFlags.VALUE_FLOAT);
test<Array<v128>>(TypeinfoFlags.ARRAY | TypeinfoFlags.VALUE_ALIGN_4);
test<Array<Ref>>(TypeinfoFlags.ARRAY | VALUE_ALIGN_REF | TypeinfoFlags.VALUE_MANAGED);
test<Array<Ref | null>>(TypeinfoFlags.ARRAY | VALUE_ALIGN_REF | TypeinfoFlags.VALUE_NULLABLE | TypeinfoFlags.VALUE_MANAGED);

test<Set<i8>>(TypeinfoFlags.SET | TypeinfoFlags.VALUE_ALIGN_0 | TypeinfoFlags.VALUE_SIGNED);
test<Set<u8>>(TypeinfoFlags.SET | TypeinfoFlags.VALUE_ALIGN_0);
test<Set<i16>>(TypeinfoFlags.SET | TypeinfoFlags.VALUE_ALIGN_1 | TypeinfoFlags.VALUE_SIGNED);
test<Set<u16>>(TypeinfoFlags.SET | TypeinfoFlags.VALUE_ALIGN_1);
test<Set<i32>>(TypeinfoFlags.SET | TypeinfoFlags.VALUE_ALIGN_2 | TypeinfoFlags.VALUE_SIGNED);
test<Set<u32>>(TypeinfoFlags.SET | TypeinfoFlags.VALUE_ALIGN_2);
test<Set<i64>>(TypeinfoFlags.SET | TypeinfoFlags.VALUE_ALIGN_3 | TypeinfoFlags.VALUE_SIGNED);
test<Set<u64>>(TypeinfoFlags.SET | TypeinfoFlags.VALUE_ALIGN_3);
test<Set<f32>>(TypeinfoFlags.SET | TypeinfoFlags.VALUE_ALIGN_2 | TypeinfoFlags.VALUE_SIGNED | TypeinfoFlags.VALUE_FLOAT);
test<Set<f64>>(TypeinfoFlags.SET | TypeinfoFlags.VALUE_ALIGN_3 | TypeinfoFlags.VALUE_SIGNED | TypeinfoFlags.VALUE_FLOAT);
test<Set<v128>>(TypeinfoFlags.SET | TypeinfoFlags.VALUE_ALIGN_4);
test<Set<Ref>>(TypeinfoFlags.SET | VALUE_ALIGN_REF | TypeinfoFlags.VALUE_MANAGED);
test<Set<Ref | null>>(TypeinfoFlags.SET | VALUE_ALIGN_REF | TypeinfoFlags.VALUE_NULLABLE | TypeinfoFlags.VALUE_MANAGED);

test<Map<v128,i8>>(TypeinfoFlags.MAP | TypeinfoFlags.KEY_ALIGN_4 | TypeinfoFlags.VALUE_ALIGN_0 | TypeinfoFlags.VALUE_SIGNED);
test<Map<i64,i16>>(TypeinfoFlags.MAP | TypeinfoFlags.KEY_ALIGN_3 | TypeinfoFlags.KEY_SIGNED | TypeinfoFlags.VALUE_ALIGN_1 | TypeinfoFlags.VALUE_SIGNED);
test<Map<i32,i32>>(TypeinfoFlags.MAP | TypeinfoFlags.KEY_ALIGN_2 | TypeinfoFlags.KEY_SIGNED | TypeinfoFlags.VALUE_ALIGN_2 | TypeinfoFlags.VALUE_SIGNED);
test<Map<i16,i64>>(TypeinfoFlags.MAP | TypeinfoFlags.KEY_ALIGN_1 | TypeinfoFlags.KEY_SIGNED | TypeinfoFlags.VALUE_ALIGN_3 | TypeinfoFlags.VALUE_SIGNED);
test<Map<i8,v128>>(TypeinfoFlags.MAP | TypeinfoFlags.KEY_ALIGN_0 | TypeinfoFlags.KEY_SIGNED | TypeinfoFlags.VALUE_ALIGN_4);
test<Map<Ref,i8>>(TypeinfoFlags.MAP | KEY_ALIGN_REF | TypeinfoFlags.KEY_MANAGED | TypeinfoFlags.VALUE_ALIGN_0 | TypeinfoFlags.VALUE_SIGNED);
test<Map<Ref | null,i8>>(TypeinfoFlags.MAP | KEY_ALIGN_REF | TypeinfoFlags.KEY_NULLABLE | TypeinfoFlags.KEY_MANAGED | TypeinfoFlags.VALUE_ALIGN_0 | TypeinfoFlags.VALUE_SIGNED);
test<Map<i8,Ref>>(TypeinfoFlags.MAP | TypeinfoFlags.KEY_ALIGN_0 | TypeinfoFlags.KEY_SIGNED | TypeinfoFlags.VALUE_MANAGED | VALUE_ALIGN_REF);
test<Map<i8,Ref | null>>(TypeinfoFlags.MAP | TypeinfoFlags.KEY_ALIGN_0 | TypeinfoFlags.KEY_SIGNED | TypeinfoFlags.VALUE_NULLABLE | TypeinfoFlags.VALUE_MANAGED | VALUE_ALIGN_REF);
test<Map<Ref | null,Ref | null>>(TypeinfoFlags.MAP | TypeinfoFlags.KEY_NULLABLE | TypeinfoFlags.KEY_MANAGED | KEY_ALIGN_REF | TypeinfoFlags.VALUE_NULLABLE | TypeinfoFlags.VALUE_MANAGED | VALUE_ALIGN_REF);
test<Map<f32,i32>>(TypeinfoFlags.MAP | TypeinfoFlags.KEY_ALIGN_2 | TypeinfoFlags.KEY_SIGNED | TypeinfoFlags.KEY_FLOAT | TypeinfoFlags.VALUE_ALIGN_2 | TypeinfoFlags.VALUE_SIGNED);

'''
'''--- tests/compiler/rt/ids.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/rt/ids.ts ---
import { ArrayBufferView } from "arraybuffer";

assert(idof<ArrayBuffer>() == 0);
assert(idof<String>() == 1);
assert(idof<ArrayBufferView>() == 2);

'''
'''--- tests/compiler/rt/instanceof.json ---
{
  "asc_flags": [
    "--explicitStart"
  ]
}

'''
'''--- tests/compiler/rt/instanceof.ts ---
class Animal {}
class Cat extends Animal {}
class BlackCat extends Cat {}

var animal: Animal = new Animal();
var cat: Animal = new Cat();
var blackcat: Animal = new BlackCat();

assert(animal instanceof Animal); // static true
assert(!(animal instanceof Cat)); // dynamic false
assert(!(animal instanceof BlackCat)); // dynamic false

assert(cat instanceof Animal); // static true
assert(cat instanceof Cat); // dynamic true
assert(!(cat instanceof BlackCat)); // dynamic false

assert(blackcat instanceof Animal); // static true
assert(blackcat instanceof Cat); // dynamic true
assert(blackcat instanceof BlackCat); // dynamic true

var nullableAnimal: Animal | null = new Animal();
var nullableCat: Animal | null = new Cat();
var nullableBlackcat: Animal | null = new BlackCat();

assert(nullableAnimal instanceof Animal); // static true
assert(!(nullableAnimal instanceof Cat)); // dynamic false
assert(!(nullableAnimal instanceof BlackCat)); // dynamic false

assert(nullableCat instanceof Animal); // static true
assert(nullableCat instanceof Cat); // dynamic true
assert(!(nullableCat instanceof BlackCat)); // dynamic false

assert(nullableBlackcat instanceof Animal); // static true
assert(nullableBlackcat instanceof Cat); // dynamic true
assert(nullableBlackcat instanceof BlackCat); // dynamic true

var nullAnimal: Animal | null = null;
var nullCat: Animal | null = null;
var nullBlackcat: Animal | null = null;

assert(!(nullAnimal instanceof Animal)); // static false
assert(!(nullAnimal instanceof Cat)); // dynamic false
assert(!(nullAnimal instanceof BlackCat)); // dynamic false

assert(!(nullCat instanceof Animal)); // static false
assert(!(nullCat instanceof Cat)); // dynamic false
assert(!(nullCat instanceof BlackCat)); // dynamic false

assert(!(nullBlackcat instanceof Animal)); // static false
assert(!(nullBlackcat instanceof Cat)); // dynamic false
assert(!(nullBlackcat instanceof BlackCat)); // dynamic false

'''
'''--- tests/compiler/rt/runtime-incremental-export.json ---
{
  "asc_flags": [
    "--runtime", "incremental",
    "--exportRuntime"
  ]
}

'''
'''--- tests/compiler/rt/runtime-incremental-export.ts ---

'''
'''--- tests/compiler/rt/runtime-incremental.json ---
{
  "asc_flags": [
    "--runtime", "incremental"
  ]
}

'''
'''--- tests/compiler/rt/runtime-incremental.ts ---

'''
'''--- tests/compiler/rt/runtime-minimal-export.json ---
{
  "asc_flags": [
    "--runtime", "minimal",
    "--exportRuntime"
  ]
}

'''
'''--- tests/compiler/rt/runtime-minimal-export.ts ---

'''
'''--- tests/compiler/rt/runtime-minimal.json ---
{
  "asc_flags": [
    "--runtime", "minimal"
  ]
}

'''
'''--- tests/compiler/rt/runtime-minimal.ts ---

'''
'''--- tests/compiler/rt/runtime-stub-export.json ---
{
  "asc_flags": [
    "--runtime", "stub",
    "--exportRuntime"
  ]
}

'''
'''--- tests/compiler/rt/runtime-stub-export.ts ---

'''
'''--- tests/compiler/rt/runtime-stub.json ---
{
  "asc_flags": [
    "--runtime", "stub"
  ]
}

'''
'''--- tests/compiler/rt/runtime-stub.ts ---

'''
'''--- tests/compiler/scoped.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/scoped.ts ---
var aGlobal: i32 = 1;
const aConstant: i32 = 3;

let aStartFunctionLocal: i32 = 2;
for (var anotherStartFunctionLocal: i32 = 0; anotherStartFunctionLocal < 1; ++anotherStartFunctionLocal);
for (let aGlobal /* that shadows */: i32 = 0; aGlobal < 1; ++aGlobal)
  aGlobal;

{
  let /* actually not */ aConstant: i64 = 5;
  {
    let /* still not */ aConstant: f32 = 10;
  }
}

// regression test: reused local should be updated with new requested type
function fn(c: i32): void {
  {
    let a: bool = 0;
  }
  {
    let b: i32;
    b = c; // should not issue a conversion warning mentioning 'bool'
  }
}
fn(42);

'''
'''--- tests/compiler/static-this.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/static-this.ts ---
class Foo {
  static bar: i32 = 42;
  static getBar(): i32 {
    return this.bar;
  }
}

assert(Foo.getBar() == 42);

'''
'''--- tests/compiler/std-wasi/console.json ---
{
  "asc_flags": [
    "--explicitStart"
  ],
  "asc_wasi": {
    "args": [],
    "env": {},
    "returnOnExit": true
  },
  "features": [
    "bigint-integration"
  ]
}

'''
'''--- tests/compiler/std-wasi/console.ts ---
import "wasi";

// asserts
console.assert(false, "whoops");
console.assert(true, "phew");

// prefixes
console.log("hello log");
console.debug("hello debug");
console.info("hello info");
console.warn("hello warn");
console.error("hello error");

// timers
console.time("someLabel");
console.timeLog("someLabel");
console.timeEnd("someLabel");
console.timeLog("wrongLabel");
console.timeEnd("wrongLabel");
console.time("duplicateLabel");
console.time("duplicateLabel");

// fast writes
console.log("1");
console.log("12");
console.log("123");
console.log("1234");

'''
'''--- tests/compiler/std-wasi/crypto.json ---
{
  "asc_flags": [
    "--explicitStart"
  ],
  "asc_wasi": {
    "args": [],
    "env": {},
    "returnOnExit": true
  },
  "features": [
    "bigint-integration"
  ]
}

'''
'''--- tests/compiler/std-wasi/crypto.ts ---
import "wasi";

var ab = new ArrayBuffer(8);

var buf = Uint8Array.wrap(ab, 0, 4);
crypto.getRandomValues(buf);
console.log("crypto.getRandomValues: " + buf.toString());
var b1 = buf.slice();

buf = Uint8Array.wrap(ab, 4, 4);
crypto.getRandomValues(buf);
console.log("crypto.getRandomValues: " + buf.toString());
var b2 = buf.slice();

buf = Uint8Array.wrap(ab);
for (let i = 0; i < 4; ++i) {
  assert(buf[i] == b1[i]);
}
for (let i= 0; i < 4; ++i) {
  assert(buf[4 + i] == b2[i]);
}

'''
'''--- tests/compiler/std-wasi/process.json ---
{
  "asc_flags": [
    "--explicitStart"
  ],
  "asc_wasi": {
    "args": [
      "firstArg",
      "secondArg",
      "thirdArg"
    ],
    "env": {
      "FIRSTENV": "firstEnv",
      "SECONDENV": "secondEnv",
      "THIRDENV": "thirdEnv"
    },
    "returnOnExit": true
  },
  "features": [
    "bigint-integration"
  ]
}

'''
'''--- tests/compiler/std-wasi/process.ts ---
import "wasi";

console.log("== arch ==");
console.log(process.arch);

console.log("== platform ==");
console.log(process.platform);

var argv = process.argv;
console.log("== argv ==");
for (let i = 0, k = argv.length; i < k; ++i) {
  console.log(argv[i]);
}

var env = process.env;
var envKeys = env.keys();
console.log("== env ==");
for (let i = 0, k = envKeys.length; i < k; ++i) {
  let key = envKeys[i];
  process.stdout.write("key: ");
  console.log(key);
  process.stdout.write("val: ");
  console.log(env.get(key));
}

console.log("== time ==");
console.log(process.time().toString());

console.log("== hrtime ==");
console.log(process.hrtime().toString());

console.log("== exit ==");
process.exit(42);

process.stdin.read(new ArrayBuffer(0));

'''
'''--- tests/compiler/std/array-access.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/std/array-access.ts ---
export function i32ArrayArrayElementAccess(a: i32[][]): i32 {
  return a[0][1];
}

export function stringArrayPropertyAccess(a: string[]): i32 {
  return a[0].length;
}

export function stringArrayMethodCall(a: string[]): i32 {
  return a[0].startsWith("");
}

export function stringArrayArrayPropertyAccess(a: string[][]): i32 {
  return a[0][1].length;
}

export function stringArrayArrayMethodCall(a: string[][]): i32 {
  return a[0][1].startsWith("");
}

'''
'''--- tests/compiler/std/array-literal.json ---
{
  "asc_flags": [
  ],
  "asc_rtrace": true
}

'''
'''--- tests/compiler/std/array-literal.ts ---
const staticArrayI8: i8[] = [0, 1, 2];
assert(staticArrayI8.length == 3);
assert(staticArrayI8[0] == 0);
assert(staticArrayI8[1] == 1);
assert(staticArrayI8[2] == 2);

const staticArrayI32: i32[] = [0, 1, 2];
assert(staticArrayI32.length == 3);
assert(staticArrayI32[0] == 0);
assert(staticArrayI32[1] == 1);
assert(staticArrayI32[2] == 2);

var emptyArrayI32: i32[] = []; // static
assert(emptyArrayI32.length == 0);

var i = 0;

var dynamicArrayI8: i8[] = [<i8>i, <i8>++i, <i8>++i];
assert(dynamicArrayI8.length == 3);
assert(dynamicArrayI8[0] == 0);
assert(dynamicArrayI8[1] == 1);
assert(dynamicArrayI8[2] == 2);

i = 0;

var dynamicArrayI32: i32[] = [i, ++i, ++i];
assert(dynamicArrayI32.length == 3);
assert(dynamicArrayI32[0] == 0);
assert(dynamicArrayI32[1] == 1);
assert(dynamicArrayI32[2] == 2);

class Ref {}
var dynamicArrayRef: Ref[] = [new Ref(), new Ref(), new Ref()];
assert(dynamicArrayRef.length == 3);

class RefWithCtor { constructor() {} }
var dynamicArrayRefWithCtor: RefWithCtor[] = [new RefWithCtor(), new RefWithCtor(), new RefWithCtor()];
assert(dynamicArrayRefWithCtor.length == 3);

// Unleak globals
emptyArrayI32 = changetype<i32[]>(0);
dynamicArrayI8 = changetype<i8[]>(0);
dynamicArrayI32 = changetype<i32[]>(0);
dynamicArrayRef = changetype<Ref[]>(0);
dynamicArrayRefWithCtor = changetype<RefWithCtor[]>(0);

// Make sure unassigned literals don't leak
function doesntLeak(refs: Ref[]): void {}
{
  doesntLeak([ new Ref() ]);
}

__stack_pointer = __heap_base;
__collect();

'''
'''--- tests/compiler/std/array.json ---
{
  "asc_flags": [
    "--explicitStart"
  ],
  "asc_rtrace": true
}

'''
'''--- tests/compiler/std/array.ts ---
import { Array } from "array";
import { ArrayBufferView } from "arraybuffer";
import { COMPARATOR } from "util/sort";

// Array<T> has the same layout as ArrayBufferView
assert(offsetof<ArrayBufferView>("buffer") == offsetof<i32[]>("buffer"));
assert(offsetof<ArrayBufferView>("dataStart") == offsetof<i32[]>("dataStart"));
assert(offsetof<ArrayBufferView>("byteLength") == offsetof<i32[]>("byteLength"));

// Obtains the internal capacity of an array from its backing buffer.
function internalCapacity<T>(array: Array<T>): i32 {
  // the memory region used by the backing buffer might still be larger in that the ArrayBuffer
  // pre-allocates a power of 2 sized buffer itself and reuses it as long as it isn't exceeded.
  var buffer: ArrayBuffer = array.buffer;
  return buffer.byteLength >> alignof<T>();
}

// Checks if two arrays are equal
function isArraysEqual<T>(a: Array<T>, b: Array<T>, len: i32 = 0): bool {
  if (!len) {
    len = a.length;
    if (len != b.length) return false;
    if (a === b) return true;
  }
  for (let i = 0; i < len; i++) {
    if (isFloat<T>()) {
      if (isNaN(a[i]) && isNaN(b[i])) continue;
    }
    if (a[i] != b[i]) return false;
  }
  return true;
}

var arr = new Array<i32>();

// Array.isArray ///////////////////////////////////////////////////////////////////////////////////

class Ref {
  constructor(public v: i32 = 0) {}
  toString(): string {
    return "[object Object]";
  }
}

{
  assert(!Array.isArray(<i32[] | null>null));
  assert(!Array.isArray(new Ref()));
  assert(!Array.isArray(new Uint8Array(1)));
  assert(!Array.isArray(<i32>1));
  assert(!Array.isArray("abc"));

  assert(Array.isArray(arr));
}

// Array#fill //////////////////////////////////////////////////////////////////////////////////////
{
  let arr8: u8[] = [1, 2, 3, 4, 5];

  arr8.fill(1, 1, 3);
  assert(isArraysEqual<u8>(arr8, [1, 1, 1, 4, 5]));

  arr8.fill(0);
  assert(isArraysEqual<u8>(arr8, [0, 0, 0, 0, 0]));

  arr8.fill(1, 0, -3);
  assert(isArraysEqual<u8>(arr8, [1, 1, 0, 0, 0]));

  arr8.fill(2, -2);
  assert(isArraysEqual<u8>(arr8, [1, 1, 0, 2, 2]));

  arr8.fill(0, 1, 0);
  assert(isArraysEqual<u8>(arr8, [1, 1, 0, 2, 2]));
}

{
  let arr32: u32[] = [1, 2, 3, 4, 5];

  arr32.fill(1, 1, 3);
  assert(isArraysEqual<u32>(arr32, [1, 1, 1, 4, 5]));

  arr32.fill(0);
  assert(isArraysEqual<u32>(arr32, [0, 0, 0, 0, 0]));

  arr32.fill(1, 0, -3);
  assert(isArraysEqual<u32>(arr32, [1, 1, 0, 0, 0]));

  arr32.fill(2, -2);
  assert(isArraysEqual<u32>(arr32, [1, 1, 0, 2, 2]));

  arr32.fill(0, 1, 0);
  assert(isArraysEqual<u32>(arr32, [1, 1, 0, 2, 2]));
}

// Array#push/pop //////////////////////////////////////////////////////////////////////////////////

{
  assert(arr.length == 0);
  assert(internalCapacity<i32>(arr) == 8);

  arr.push(42);

  assert(arr[0] == 42);
  assert(arr.length == 1);
  assert(internalCapacity<i32>(arr) == 8);

  let i = arr.pop();

  assert(i == 42);
  assert(arr.length == 0);
  assert(internalCapacity<i32>(arr) == 8);

  arr.push(43);

  assert(arr.length == 1);
  assert(internalCapacity<i32>(arr) == 8);
  assert(arr[0] == 43);

  arr.push(44);

  assert(arr.length == 2);
  assert(internalCapacity<i32>(arr) == 8);
  assert(arr[0] == 43);
  assert(arr[1] == 44);

  arr.push(45);

  assert(arr.length == 3);
  assert(internalCapacity<i32>(arr) == 8);
  assert(arr[0] == 43);
  assert(arr[1] == 44);
  assert(arr[2] == 45);
}

// Array#set:length ///////////////////////////////////////////////////////////////////////////////

{
  let arr: Ref[] = [new Ref(), new Ref()];
  arr.length = 0; // releases unused refs
  assert(arr.length == 0);
}

// Array#at ///////////////////////////////////////////////////////////////////////////////////////

{
  let arr: i32[] = [1, 2, 3, 4];

  assert(arr.at(0) == 1);
  assert(arr.at(3) == 4);
  assert(arr.at(-1) == 4);
  assert(arr.at(-4) == 1);
}

// Array#concat ///////////////////////////////////////////////////////////////////////////////////

{
  let other = new Array<i32>();

  let out = arr.concat(other);
  assert(internalCapacity<i32>(arr) == 8);
  assert(arr.length == 3);
  assert(out.length == 3);

  out.concat([]);
  assert(internalCapacity<i32>(arr) == 8);

  assert(out[0] == 43);
  assert(out[1] == 44);
  assert(out[2] == 45);

  other.push(46);
  other.push(47);

  out = arr.concat(other);

  assert(internalCapacity<i32>(arr) == 8);
  assert(other.length == 2);
  assert(out.length == 5);
  assert(out[0] == 43);
  assert(out[1] == 44);
  assert(out[2] == 45);
  assert(out[3] == 46);
  assert(out[4] == 47);

  out.pop();
  assert(out.length == 4);

  // TODO: wait for variable function parameters
  // out = arr.concat(null);
  // assert(out.length == 3);
  // assert(out[2] == 45);

  let source: i32[] = [];
  assert(source.length == 0);
  out = source.concat(arr);
  assert(out.length == 3);
  assert(source.length == 0);
}

// Array#copyWithin ////////////////////////////////////////////////////////////////////////////////

{
  let cwArr: i32[] = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(cwArr.copyWithin(0, 3), [4, 5, 3, 4, 5]));
  cwArr = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(cwArr.copyWithin(1, 3), [1, 4, 5, 4, 5]));
  cwArr = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(cwArr.copyWithin(1, 2), [1, 3, 4, 5, 5]));
  cwArr = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(cwArr.copyWithin(2, 2), [1, 2, 3, 4, 5]));
  cwArr = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(cwArr.copyWithin(0, 3, 4), [4, 2, 3, 4, 5]));
  cwArr = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(cwArr.copyWithin(1, 3, 4), [1, 4, 3, 4, 5]));
  cwArr = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(cwArr.copyWithin(1, 2, 4), [1, 3, 4, 4, 5]));
  cwArr = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(cwArr.copyWithin(0, -2), [4, 5, 3, 4, 5]));
  cwArr = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(cwArr.copyWithin(0, -2, -1), [4, 2, 3, 4, 5]));
  cwArr = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(cwArr.copyWithin(-4, -3, -2), [1, 3, 3, 4, 5]));
  cwArr = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(cwArr.copyWithin(-4, -3, -1), [1, 3, 4, 4, 5]));
  cwArr = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(cwArr.copyWithin(-4, -3), [1, 3, 4, 5, 5]));
}

// Array#unshift ///////////////////////////////////////////////////////////////////////////////////

{
  arr.unshift(42);

  assert(arr.length == 4);
  assert(internalCapacity<i32>(arr) == 8);
  assert(arr[0] == 42);
  assert(arr[1] == 43);
  assert(arr[2] == 44);
  assert(arr[3] == 45);

  arr.unshift(41);

  assert(arr.length == 5);
  assert(internalCapacity<i32>(arr) == 8);
  assert(arr[0] == 41);
  assert(arr[1] == 42);
  assert(arr[2] == 43);
  assert(arr[3] == 44);
  assert(arr[4] == 45);
}

// Array#shift /////////////////////////////////////////////////////////////////////////////////////

var i: i32;
{
  i = arr.shift();

  assert(i == 41);
  assert(arr.length == 4);
  assert(internalCapacity<i32>(arr) == 8);
  assert(arr[0] == 42);
  assert(arr[1] == 43);
  assert(arr[2] == 44);
  assert(arr[3] == 45);

  i = arr.pop();

  assert(i == 45);
  assert(arr.length == 3);
  assert(internalCapacity<i32>(arr) == 8);
  assert(arr[0] == 42);
  assert(arr[1] == 43);
  assert(arr[2] == 44);
}

// Array#slice

{
  let result: i32[];
  const elements: i32[] = [3, 5, 7, 9, 11];

  result = elements.slice(2);
  assert(isArraysEqual(result, [7, 9, 11]));

  result = elements.slice(2, 4);
  assert(isArraysEqual(result, [7, 9]));

  result = elements.slice(1, 5);
  assert(isArraysEqual(result, [5, 7, 9, 11]));

  result = elements.slice();
  assert(isArraysEqual(result, elements));

  result = elements.slice(-2);
  assert(isArraysEqual(result, [9, 11]));

  result = elements.slice(2, -1);
  assert(isArraysEqual(result, [7, 9]));

  result = elements.slice(-3, -1);
  assert(isArraysEqual(result, [7, 9]));

  assert(elements.slice(-1, -3).length == 0);
  assert(elements.slice(10).length == 0);
}

// Array#reverse ///////////////////////////////////////////////////////////////////////////////////

{
  arr.reverse();

  assert(arr.length == 3);
  assert(internalCapacity<i32>(arr) == 8);
  assert(arr[0] == 44);
  assert(arr[1] == 43);
  assert(arr[2] == 42);

  arr.push(43);
  arr.push(44);
}

// Array#indexOf ///////////////////////////////////////////////////////////////////////////////////

{
  i = arr.indexOf(44);
  assert(i == 0);

  i = arr.indexOf(42);
  assert(i == 2);

  i = arr.indexOf(45);
  assert(i == - 1);

  i = arr.indexOf(43, 100);
  assert(i == - 1);

  i = arr.indexOf(43, -100);
  assert(i == 1);

  i = arr.indexOf(43, -2);
  assert(i == 3);

  i = arr.indexOf(43, -4);
  assert(i == 1);

  i = arr.indexOf(43, 0);
  assert(i == 1);

  i = arr.indexOf(43, 1);
  assert(i == 1);

  i = arr.indexOf(43, 2);
  assert(i == 3);

  assert(([NaN] as f32[]).indexOf(NaN) == -1);
  assert(([NaN] as f64[]).indexOf(NaN) == -1);
}

// Array#lastIndexOf

{
  const numbers: i32[] = [2, 5, 9, 2];
  assert(numbers.lastIndexOf(2) == 3);
  assert(numbers.lastIndexOf(7) == -1);
  assert(numbers.lastIndexOf(2, 3) == 3);
  assert(numbers.lastIndexOf(2, 2) == 0);
  assert(numbers.lastIndexOf(2, -2) == 0);
  assert(numbers.lastIndexOf(2, -1) == 3);

}

// Array#includes //////////////////////////////////////////////////////////////////////////////////

{
  let includes = arr.includes(44);
  assert(includes == true);

  includes = arr.includes(42);
  assert(includes == true);

  includes = arr.includes(45);
  assert(includes == false);

  includes = arr.includes(43, 100);
  assert(includes == false);

  includes = arr.includes(43, -100);
  assert(includes == true);

  includes = arr.includes(43, -2);
  assert(includes == true);

  includes = arr.includes(43, -4);
  assert(includes == true);

  includes = arr.includes(43, 0);
  assert(includes == true);

  includes = arr.includes(43, 1);
  assert(includes == true);

  includes = arr.includes(43, 2);
  assert(includes == true);

  assert(([NaN] as f32[]).includes(NaN));
  assert(([NaN] as f64[]).includes(NaN));

  arr.splice(1, 1);

  assert(arr.length == 4);
  assert(internalCapacity<i32>(arr) == 8);
  assert(arr[0] == 44);
  assert(arr[1] == 42);
}

// Array#splice ////////////////////////////////////////////////////////////////////////////////////

{
  let sarr: i32[] = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(sarr.splice(0), [1, 2, 3, 4, 5]));
  assert(isArraysEqual<i32>(sarr, []));

  sarr = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(sarr.splice(0, 0), []));
  assert(isArraysEqual<i32>(sarr, [1, 2, 3, 4, 5]));

  sarr = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(sarr.splice(2), [3, 4, 5]));
  assert(isArraysEqual<i32>(sarr, [1, 2]));

  sarr = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(sarr.splice(2, 2), [3, 4]));
  assert(isArraysEqual<i32>(sarr, [1, 2, 5]));

  sarr = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(sarr.splice(0, 1), [1]));
  assert(isArraysEqual<i32>(sarr, [2, 3, 4, 5]));

  sarr = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(sarr.splice(-1), [5]));
  assert(isArraysEqual<i32>(sarr, [1, 2, 3, 4]));

  sarr = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(sarr.splice(-2), [4, 5]));
  assert(isArraysEqual<i32>(sarr, [1, 2, 3]));

  sarr = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(sarr.splice(-2, 1), [4]));
  assert(isArraysEqual<i32>(sarr, [1, 2, 3, 5]));

  sarr = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(sarr.splice(-7, 1), [1]));
  assert(isArraysEqual<i32>(sarr, [2, 3, 4, 5]));

  sarr = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(sarr.splice(-2, -1), []));
  assert(isArraysEqual<i32>(sarr, [1, 2, 3, 4, 5]));

  sarr = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(sarr.splice(1, -2), []));
  assert(isArraysEqual<i32>(sarr, [1, 2, 3, 4, 5]));

  sarr = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(sarr.splice(4, 0), []));
  assert(isArraysEqual<i32>(sarr, [1, 2, 3, 4, 5]));

  sarr = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(sarr.splice(7, 0), []));
  assert(isArraysEqual<i32>(sarr, [1, 2, 3, 4, 5]));

  sarr = [1, 2, 3, 4, 5];
  assert(isArraysEqual<i32>(sarr.splice(7, 5), []));
  assert(isArraysEqual<i32>(sarr, [1, 2, 3, 4, 5]));

  let refArr: Ref[] = [];
  let spliced = refArr.splice(1, 2);
  assert(spliced.length == 0);
  assert(refArr.length == 0);

  refArr = [new Ref(1), new Ref(2), new Ref(3), new Ref(4), new Ref(5)];
  spliced = refArr.splice(2, 2);

  assert(spliced.length == 2);
  assert(spliced[0].v == 3);
  assert(spliced[1].v == 4);

  assert(refArr.length == 3);
  assert(refArr[0].v == 1);
  assert(refArr[1].v == 2);
  assert(refArr[2].v == 5);

  let refArr2: (Ref | null)[] = [new Ref(1), null, new Ref(2)];
  let spliced2 = refArr2.splice(0, 1);

  assert(spliced2.length == 1);
  assert(spliced2[0]!.v == 1);

  assert(refArr2.length == 2);
  assert(refArr2[0] === null);
  assert(refArr2[1]!.v == 2);
}

// Array#findIndex /////////////////////////////////////////////////////////////////////////////////

{
  arr[0] = 0;
  arr[1] = 1;
  arr[2] = 2;
  arr[3] = 3;

  i = arr.findIndex((value: i32) => value == 0);

  assert(i == 0);

  i = arr.findIndex((value: i32) => value == 1);
  assert(i == 1);

  i = arr.findIndex((value: i32) => value == 100);
  assert(i == -1);

  // Test side effect push
  i = arr.findIndex((value: i32, _: i32, array: Array<i32>) => {
    array.push(100); // push side effect should not affect this method by spec
    return value == 100;
  });
  // array should be changed, but this method result should be calculated for old array length
  assert(i == -1);
  assert(arr.length == 8);
  i = arr.findIndex((value: i32) => value == 100);
  assert(i != -1);

  arr.pop();
  arr.pop();
  arr.pop();
  arr.pop();

  // Test side effect pop
  i = arr.findIndex((value: i32, _: i32, array: Array<i32>) => {
    array.pop(); // popped items shouldn't be looked up, and we shouldn't go out of bounds
    return value == 100;
  });
  // only 2 first items was looked up, since last 2 was removed by .pop()
  assert(i == -1);
  assert(arr.length == 2);

  arr.push(2);
  arr.push(3);
}

// Array#findLastIndex /////////////////////////////////////////////////////////////////////////////

{
  let intArr = [0, 1, 2, 3];

  i = intArr.findLastIndex(value => value == 0);

  assert(i == 0);

  i = intArr.findLastIndex(value => value == 1);
  assert(i == 1);

  i = intArr.findLastIndex(value => value == 100);
  assert(i == -1);

  // Test side effect pop
  i = intArr.findLastIndex((value, _, array) => {
    // @ts-ignore
    array.pop(); // popped items shouldn't be looked up, and we shouldn't go out of bounds
    return value == 100;
  });

  assert(i == -1);
}

// Array#every /////////////////////////////////////////////////////////////////////////////////////

{
  let every = arr.every((value: i32) => value >= 0);
  assert(every == true);

  every = arr.every((value: i32) => value <= 0);
  assert(every == false);

  // Test side effect push
  every = arr.every((value: i32, _: i32, array: Array<i32>) => {
    array.push(100); // push side effect should not affect this method by spec
    return value < 10;
  });
  // array should be changed, but this method result should be calculated for old array length
  assert(every == true);
  assert(arr.length == 8);
  every = arr.every((value: i32) => value < 10);
  assert(every == false);

  arr.pop();
  arr.pop();
  arr.pop();
  arr.pop();

  // Test side effect pop
  every = arr.every((value: i32, _: i32, array: Array<i32>) => {
    array.pop(); // popped items shouldn't be looked up, and we shouldn't go out of bounds
    return value < 3;
  });
  // only 2 first items was looked up, since last 2 was removed by .pop()
  assert(every == true);
  assert(arr.length == 2);

  arr.push(2);
  arr.push(3);
}

// Array#some //////////////////////////////////////////////////////////////////////////////////////

{
  let some = arr.some((value: i32) => value >= 3);
  assert(some == true);

  some = arr.some((value: i32) => value <= -1);
  assert(some == false);

  // Test side effect push
  some = arr.some((value: i32, _: i32, array: Array<i32>) => {
    array.push(100); // push side effect should not affect this method by spec
    return value > 10;
  });
  // array should be changed, but this method result should be calculated for old array length
  assert(some == false);
  assert(arr.length == 8);
  some = arr.some((value: i32) => value > 10);
  assert(some == true);

  arr.pop();
  arr.pop();
  arr.pop();
  arr.pop();

  // Test side effect pop
  some = arr.some((value: i32, _: i32, array: Array<i32>) => {
    array.pop(); // popped items shouldn't be looked up, and we shouldn't go out of bounds
    return value > 3;
  });
  // only 2 first items was looked up, since last 2 was removed by .pop()
  assert(some == false);
  assert(arr.length == 2);

  arr.push(2);
  arr.push(3);
}

// Array#forEach ///////////////////////////////////////////////////////////////////////////////////

{
  i = 0;
  arr.forEach((value: i32) => { i += value; });
  assert(i == 6);

  // Test side effect push
  i = 0;
  arr.forEach((value: i32, _: i32, array: Array<i32>) => {
    array.push(100); // push side effect should not affect this method by spec
    i += value;
  });
  // array should be changed, but this method result should be calculated for old array length
  assert(i == 6);
  assert(arr.length == 8);
  i = 0;
  arr.forEach((value: i32) => { i += value; });
  assert(i == 406);

  arr.pop();
  arr.pop();
  arr.pop();
  arr.pop();

  // Test side effect pop
  i = 0;
  arr.forEach((value: i32, _: i32, array: Array<i32>) => {
    array.pop(); // popped items shouldn't be looked up, and we shouldn't go out of bounds
    i += value;
  });
  // only 2 first items was looked up, since last 2 was removed by .pop()
  assert(i == 1);
  assert(arr.length == 2);

  arr.push(2);
  arr.push(3);

  // Test rehash action effec
  arr.forEach((value: i32, index: i32, array: Array<i32>) => {
    if (index == 0) {
      for (let i = 0; i < 4; i++) {
        array.pop();
      }
      for (let i = 0; i < 100; i++) {
        array.push(100 + i);
      }
      for (let i = 0; i < 100; i++) {
        array.pop();
      }
      for (let i = 0; i < 100; i++) {
        array.push(i + 200);
      }
    }
    if (index == 2) {
      assert(value == 202);
    }
  });
  assert(arr.length == 100);
  for (let i = 0; i < 100; i++) {
    arr.pop();
  }
  arr.push(0);
  arr.push(1);
  arr.push(2);
  arr.push(3);
}

// Array#map ///////////////////////////////////////////////////////////////////////////////////////

{
  let newArr = arr.map<f32>((value: i32) => <f32>value);
  assert(newArr.length == 4);
  assert(newArr[0] == <f32>arr[0]);

  // Test side effect push
  i = 0;
  arr.map<i32>((value: i32, _: i32, array: Array<i32>) => {
    array.push(100); // push side effect should not affect this method by spec
    i += value;
    return value;
  });
  assert(i == 6);
  assert(arr.length == 8);

  i = 0;
  arr.map<i32>((value: i32) => {
    i += value;
    return value;
  });
  assert(i == 406);

  arr.pop();
  arr.pop();
  arr.pop();
  arr.pop();

  // Test side effect pop
  i = 0;
  arr.map<i32>((value: i32, _: i32, array: Array<i32>) => {
    array.pop(); // popped items shouldn't be looked up, and we shouldn't go out of bounds
    i += value;
    return value;
  });
  // only 2 first items was looked up, since last 2 was removed by .pop()
  assert(i == 1);
  assert(arr.length == 2);

  arr.push(2);
  arr.push(3);
}

// Array#filter ////////////////////////////////////////////////////////////////////////////////////

{
  let filteredArr: i32[] = arr.filter((value: i32) => value >= 2);
  assert(filteredArr.length == 2);

  // Test side effect push
  i = 0;
  arr.filter((value: i32, _: i32, array: Array<i32>) => {
    array.push(100); // push side effect should not affect this method by spec
    i += value;
    return value >= 2;
  });
  assert(i == 6);
  assert(arr.length == 8);

  i = 0;
  arr.filter((value: i32) => {
    i += value;
    return value >= 2;
  });
  assert(i == 406);

  arr.pop();
  arr.pop();
  arr.pop();
  arr.pop();

  // Test side effect pop
  i = 0;
  arr.filter((value: i32, _: i32, array: Array<i32>) => {
    array.pop(); // popped items shouldn't be looked up, and we shouldn't go out of bounds
    i += value;
    return value >= 2;
  });
  // only 2 first items was looked up, since last 2 was removed by .pop()
  assert(i == 1);
  assert(arr.length == 2);

  arr.push(2);
  arr.push(3);
}

// Array#reduce ////////////////////////////////////////////////////////////////////////////////////

{
  i = arr.reduce<i32>(((prev: i32, current: i32): i32 => prev + current), 0);
  assert(i == 6);

  // init value
  i = arr.reduce(((prev: i32, current: i32): i32 => prev + current), 4);
  assert(i == 10);

  let boolVal = arr.reduce(((prev: bool, current: i32): bool => prev || current > 2), false);
  assert(boolVal == true);

  boolVal = arr.reduce<bool>(((prev: bool, current: i32): bool => prev || current > 100), false);
  assert(boolVal == false);

  // Test side effect push
  i = arr.reduce<i32>(((prev: i32, current: i32, _: i32, array: Array<i32>): i32 => {
    array.push(1); // push side effect should not affect this method by spec
    return prev + current;
  }), 0);
  // array should be changed, but this method result should be calculated for old array length
  assert(i == 6);
  assert(arr.length == 8);
  i = arr.reduce(((prev: i32, current: i32): i32 => prev + current), 0);
  assert(i == 10);

  arr.pop();
  arr.pop();
  arr.pop();
  arr.pop();

  // Test side effect pop
  i = arr.reduce(((prev: i32, current: i32, _: i32, array: Array<i32>): i32 => {
    array.pop(); // popped items shouldn't be reduced, and we shouldn't go out of bounds
    return prev + current;
  }), 0);
  // only 2 first items was reduced, since last 2 was removed by .pop()
  assert(i == 1);
  assert(arr.length == 2);

  arr.push(2);
  arr.push(3);
}

// Array#reduceRight ///////////////////////////////////////////////////////////////////////////////

{
  i = arr.reduceRight<i32>(((prev: i32, current: i32): i32 => prev + current), 0);
  assert(i == 6);

  // init value
  i = arr.reduceRight(((prev: i32, current: i32): i32 => prev + current), 4);
  assert(i == 10);

  let boolVal = arr.reduceRight<bool>(((prev: bool, current: i32): bool => prev || current > 2), false);
  assert(boolVal == true);

  boolVal = arr.reduceRight(((prev: bool, current: i32): bool => prev || current > 100), false);
  assert(boolVal == false);

  // Test side effect push
  i = arr.reduceRight<i32>(((prev: i32, current: i32, _: i32, array: Array<i32>): i32 => {
    array.push(1); // push side effect should not affect this method by spec
    return prev + current;
  }), 0);
  // array should be changed, but this method result should be calculated for old array length
  assert(i == 6);
  assert(arr.length == 8);
  i = arr.reduceRight(((prev: i32, current: i32): i32 => prev + current), 0);
  assert(i == 10);

  arr.pop();
  arr.pop();
  arr.pop();
  arr.pop();

  // Test side effect pop
  i = arr.reduceRight(((prev: i32, current: i32, _: i32, array: Array<i32>): i32 => {
    array.pop(); // popped items should be reduced
    return prev + current;
  }), 0);

  assert(i == 6);
  assert(arr.length == 0);

  arr.push(0);
  arr.push(1);
  arr.push(2);
  arr.push(3);
}

// Array#sort //////////////////////////////////////////////////////////////////////////////////////

// Checks if an array is properly sorted
function isSorted<T>(data: Array<T>, comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): bool {
  for (let i = 1, len = data.length; i < len; i++) {
    if (comparator(data[i - 1], data[i]) > 0) return false;
  }
  return true;
}

function createReverseOrderedArray(size: i32): Array<i32> {
  var arr = new Array<i32>(size);
  for (let i = 0; i < size; i++) {
    arr[i] = size - 1 - i;
  }
  return arr;
}

NativeMath.seedRandom(reinterpret<u64>(JSMath.random()));

function createRandomOrderedArray(size: i32): Array<i32> {
  var arr = new Array<i32>(size);
  for (let i = 0; i < size; i++) {
    arr[i] = <i32>(NativeMath.random() * size);
  }
  return arr;
}

function createReverseOrderedNestedArray(size: i32): Array<Array<i32>> {
  var arr = new Array<Array<i32>>(size);
  for (let i = 0; i < size; i++) {
    let inner = new Array<i32>(1);
    inner[0] = size - 1 - i;
    arr[i] = inner;
  }
  return arr;
}

class Proxy<T> {
  constructor(public x: T) {}
}

class Dim {
  height: i32;
  width: i32;
}

function createReverseOrderedElementsArray(size: i32): Array<Proxy<i32>> {
  var arr = new Array<Proxy<i32>>(size);
  for (let i = 0; i < size; i++) {
    arr[i] = new Proxy<i32>(size - 1 - i);
  }
  return arr;
}

const charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-,.+/\\[]{}()<>*&$%^@#!?";

let inputStabArr: Array<Dim> = [
  { height: 100, width: 80  },
  { height: 90,  width: 90  },
  { height: 70,  width: 95  },
  { height: 100, width: 100 },
  { height: 80,  width: 110 },
  { height: 110, width: 115 },
  { height: 100, width: 120 },
  { height: 70,  width: 125 },
  { height: 70,  width: 130 },
  { height: 100, width: 135 },
  { height: 75,  width: 140 },
  { height: 70,  width: 140 }
];

let outputStabArr: Array<Dim> = [
  { height: 70,  width: 95  },
  { height: 70,  width: 125 },
  { height: 70,  width: 130 },
  { height: 70,  width: 140 },
  { height: 75,  width: 140 },
  { height: 80,  width: 110 },
  { height: 90,  width: 90  },
  { height: 100, width: 80  },
  { height: 100, width: 100 },
  { height: 100, width: 120 },
  { height: 100, width: 135 },
  { height: 110, width: 115 }
];

function createRandomString(len: i32): string {
  var result = "";

  for (let i = 0; i < len; i++) {
    result += charset.charAt(<i32>(NativeMath.floor(NativeMath.random() * charset.length)));
  }
  return result;
}

function createRandomStringArray(size: i32): Array<string> {
  var arr = new Array<string>(size);
  for (let i = 0; i < size; i++) {
    arr[i] = createRandomString(<i32>(NativeMath.random() * 32));
  }
  return arr;
}

function assertStableSortedForComplexObjects(): void {
  let sorted = inputStabArr.slice(0).sort((a, b) => a.height - b.height);
  let check = true;
  for (let i = 0, len = inputStabArr.length; i < len; i++) {
    let input = sorted[i];
    let target = outputStabArr[i];
    if (input.height != target.height || input.width != target.width) {
      check = false;
      break;
    }
  }
  assert(check);
}

function assertSorted<T>(arr: Array<T>, comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): void {
  assert(isSorted<T>(arr.sort(comparator), comparator));
}

function assertSortedDefault<T>(arr: Array<T>): void {
  assertSorted<T>(arr, COMPARATOR<T>());
}

// Tests for default comparator
{
  let f32ArrayTypedSmall: f32[] = [2.0, -1.0, 0.0];
  f32ArrayTypedSmall.sort();
  assert(isArraysEqual<f32>(f32ArrayTypedSmall, [-1.0, 0.0, 2.0]));

  let f32ArrayTyped: f32[] = [1.0, NaN, -Infinity, 1.00000001, 0.0, -1.0, -2.0, +Infinity];
  f32ArrayTyped.sort();
  assert(isArraysEqual<f32>(f32ArrayTyped, [-Infinity, -2.0, -1.0, 0.0, 1.0, 1.00000001, Infinity, NaN]));

  let f64ArrayTyped: f64[] = [1.0, NaN, -Infinity, 1.000000000000001, 0.0, -1.0, -2.0, +Infinity];
  f64ArrayTyped.sort();
  assert(isArraysEqual<f64>(f64ArrayTyped, [-Infinity, -2.0, -1.0, 0.0, 1.0, 1.000000000000001, Infinity, NaN]));

  let i32ArrayTyped: i32[] = [1, -2, -1, 0, 2];
  i32ArrayTyped.sort();
  assert(isArraysEqual<i32>(i32ArrayTyped, [-2, -1, 0, 1, 2]));

  let u32ArrayTyped: u32[] = [1, 4294967295, 4294967294, 0, 2];
  u32ArrayTyped.sort();
  assert(isArraysEqual<u32>(u32ArrayTyped, [0, 1, 2, 4294967294, 4294967295]));

  let reversed0: i32[] = [];
  let reversed1: i32[] = [1];
  let reversed2: i32[] = [2, 1];
  let reversed4: i32[] = [3, 2, 1, 0];
  let expected4: i32[] = [0, 1, 2, 3];

  let reversed64    = createReverseOrderedArray(64);
  let reversed128   = createReverseOrderedArray(128);
  let reversed1024  = createReverseOrderedArray(1024);
  let reversed10000 = createReverseOrderedArray(10000);

  let randomized512 = createRandomOrderedArray(512);

  // Test sorting with with default comparator

  assertSortedDefault<i32>(reversed0);

  assertSortedDefault<i32>(reversed1);
  assert(isArraysEqual<i32>(reversed1, [1]));

  assertSortedDefault<i32>(reversed2);
  assert(isArraysEqual<i32>(reversed2, [1, 2]));

  assertSortedDefault<i32>(reversed4);
  assert(isArraysEqual<i32>(reversed4, expected4));

  assertSortedDefault<i32>(reversed64);
  assert(isArraysEqual<i32>(reversed64, expected4, 4));

  assertSortedDefault<i32>(reversed128);
  assert(isArraysEqual<i32>(reversed128, expected4, 4));

  assertSortedDefault<i32>(reversed1024);
  assert(isArraysEqual<i32>(reversed1024, expected4, 4));

  assertSortedDefault<i32>(reversed10000);
  assert(isArraysEqual<i32>(reversed10000, expected4, 4));

  assertSortedDefault<i32>(randomized512);

  assertStableSortedForComplexObjects();
}

// Test sorting with custom comparator

{
  let randomized64  = createRandomOrderedArray(64);
  let randomized257 = createRandomOrderedArray(257);

  assertSorted<i32>(randomized64, (a: i32, b: i32) => a - b);
  assertSorted<i32>(randomized64, (a: i32, b: i32) => b - a);

  assertSorted<i32>(randomized257, (a: i32, b: i32) => a - b);
  assertSorted<i32>(randomized257, (a: i32, b: i32) => b - a);
}

// Test sorting complex objects
{
  let reversedNested512 = createReverseOrderedNestedArray(2);
  assertSorted<i32[]>(reversedNested512, (a: i32[], b: i32[]) => a[0] - b[0]);
}

// Test sorting reference elements
{
  let reversedElements512 = createReverseOrderedElementsArray(512);
  assertSorted<Proxy<i32>>(reversedElements512, (a: Proxy<i32>, b: Proxy<i32>) => a.x - b.x);
}

// Test sorting strings

{
  let randomStringsActual:   (string | null)[] = ["a", "b", "a", "ab", "ba", "", null];
  let randomStringsExpected: (string | null)[] = ["", "a", "a", "ab", "b", "ba", null];

  assertSorted<string | null>(randomStringsActual);
  assert(isArraysEqual<string | null>(randomStringsActual, randomStringsExpected));

  let randomStrings400 = createRandomStringArray(400);
  assertSorted<string>(randomStrings400);
}

// Array#join //////////////////////////////////////////////////////////////////////////////////////

{
  assert((<bool[]>[true, false]).join() == "true,false");
  assert((<i32[]>[1,-2,-3]).join("") == "1-2-3");
  assert((<u32[]>[1, 2, 3]).join("-") == "1-2-3");
  assert((<i32[]>[i32.MIN_VALUE, i32.MIN_VALUE]).join("__") == "-2147483648__-2147483648");
  assert((<f64[]>[0.0, 1.0, -2.0, NaN, -Infinity, Infinity]).join(", ") == "0.0, 1.0, -2.0, NaN, -Infinity, Infinity");
  assert((<Array<string | null>>["", "1", null]).join("") == "1");
  let refArr: (Ref | null)[] = [new Ref(), null, new Ref()];
  assert(refArr.join() == "[object Object],,[object Object]");

  let refArr2: Ref[] = [new Ref(), new Ref()];
  assert(refArr2.join() == "[object Object],[object Object]");
}

// Array#toString //////////////////////////////////////////////////////////////////////////////////
{
  let arr0: i32[] = [];
  let arr1: i32[] = [1];
  let arr2: i32[] = [1,2];
  let arr3: i32[] = [0,1,2,3];

  assert(arr0.toString() == "");
  assert(arr1.toString() == "1");
  assert(arr2.toString() == "1,2");
  assert(arr3.toString() == "0,1,2,3");

  assert((<i8[]>[1, -1, 0]).toString() == "1,-1,0");
  assert((<u16[]>[1, 0xFFFF, 0]).toString() == "1,65535,0");
  assert((<u64[]>[1, 0xFFFFFFFFFFFFFFFF, 0]).toString() == "1,18446744073709551615,0");
  assert((<i64[]>[-1, -1234567890123456, 0, i64.MAX_VALUE]).toString() == "-1,-1234567890123456,0,9223372036854775807");

  let arrStr: (string | null)[] = ["", "a", "a", "ab", "b", "ba", null];

  assert(arrStr.toString() == ",a,a,ab,b,ba,");
  assert((<Array<string | null>>["1", "2", null, "4"]).toString() == "1,2,,4");

  let subarr32: i32[][] = [[1,2], [3,4]];
  assert(subarr32.toString() == "1,2,3,4");

  let subarr8: u8[][] = [[1,2], [3,4]];
  assert(subarr8.toString() == "1,2,3,4");

  let subarrU32: u32[][][] = [[[1]]];
  assert(subarrU32.toString() == "1");
}

// Array#flat //////////////////////////////////////////////////////////////////////////////////
{
  let flatTarget: i32[][] = [[0], [1, 2, 3], [4, 5, 6], [7, 8, 9]];
  let result = flatTarget.flat();
  assert(result.length == 10);
  for (let i = 0; i < 10; i++) {
    assert(result[i] == i);
  }

  let flatStringTarget: Array<Array<string | null>> = [["one"], ["two", null, "three"], ["four", "five", "six"], ["seven"]];
  let stringResult = flatStringTarget.flat();
  let expected = ["one", "two", null, "three", "four", "five", "six", "seven"];
  assert(stringResult.length == 8);
  for (let i = 0; i < expected.length; i++) {
    assert(stringResult[i] == expected[i]);
  }

  let testArray: i32[][] = [[], []];
  assert(testArray.flat().length == 0);
}

// export extended arrays

export class ArrayU32 extends Array<u32> {}
export class ArrayU8 extends Array<u8> {}
export class ArrayStr extends Array<string> {}
// FIXME: Fails on 'sort' due to operators '>', '<'
// export class ArrayArrayI32 extends Array<Array<i32>> {}

// Unleak globals
arr = changetype<Array<i32>>(0);
inputStabArr = changetype<Array<Dim>>(0);
outputStabArr = changetype<Array<Dim>>(0);

__stack_pointer = __heap_base;
__collect();

'''
'''--- tests/compiler/std/arraybuffer.json ---
{
  "asc_flags": [
  ],
  "asc_rtrace": true
}

'''
'''--- tests/compiler/std/arraybuffer.ts ---
{
  let buffer = new ArrayBuffer(8);

  assert(buffer.byteLength == 8);

  let sliced = buffer.slice();

  assert(sliced.byteLength == 8);
  assert(sliced !== buffer);

  sliced = buffer.slice(1);

  assert(sliced.byteLength == 7);

  sliced = buffer.slice(-1);

  assert(sliced.byteLength == 1);

  sliced = buffer.slice(1, 3);

  assert(sliced.byteLength == 2);

  sliced = buffer.slice(1, -1);

  assert(sliced.byteLength == 6);

  sliced = buffer.slice(-3, -1);

  assert(sliced.byteLength == 2);

  sliced = buffer.slice(-4, 42);

  assert(sliced.byteLength == 4);

  sliced = buffer.slice(42);

  assert(sliced.byteLength == 0);
  assert(sliced != null);

  assert(!ArrayBuffer.isView<i32[] | null>(null));
  assert(!ArrayBuffer.isView<usize>(0));
  assert(!ArrayBuffer.isView<usize>(1));
  assert(!ArrayBuffer.isView<Uint8Array | null>(null));
  assert(!ArrayBuffer.isView<Int32Array | null>(null));
  assert(!ArrayBuffer.isView<DataView | null>(null));

  let arr8 = new Uint8Array(1);
  assert(!ArrayBuffer.isView(<i32[]>[1, 2]));
  assert(ArrayBuffer.isView(arr8));
  assert(ArrayBuffer.isView(new Int32Array(1)));
  assert(ArrayBuffer.isView(new DataView(arr8.buffer)));
}

__stack_pointer = __heap_base;
__collect();

'''
'''--- tests/compiler/std/dataview.json ---
{
  "asc_flags": [
  ],
  "asc_rtrace": true
}

'''
'''--- tests/compiler/std/dataview.ts ---
{
  let array = new Uint8Array(8);

  array[0] = 246;
  array[1] = 224;
  array[2] = 88;
  array[3] = 159;
  array[4] = 130;
  array[5] = 101;
  array[6] = 67;
  array[7] = 95;

  let view = new DataView(array.buffer, array.byteOffset, array.byteLength);

  assert(view.getFloat32(0, true) === -4.592586247781397e-20);
  assert(view.getFloat32(1, true) === -2.3413961970849473e-37);
  assert(view.getFloat32(2, true) === 7.710587701863113e+22);
  assert(view.getFloat32(3, true) === 229.51023864746094);
  assert(view.getFloat32(4, true) === 14079802746555335000.0);

  assert(view.getFloat32(0, false) === -2.2751405188178955e+33);
  assert(view.getFloat32(1, false) === -62437351080004160000.0);
  assert(view.getFloat32(2, false) === 1403059112509440.0);
  assert(view.getFloat32(3, false) === -5.522466503261712e-20);
  assert(view.getFloat32(4, false) === -1.6843597451835358e-37);

  assert(view.getFloat64(0, true) === 7.936550095674706e+150);
  assert(view.getFloat64(0, false) === -4.1177747581885255e+264);

  assert(view.getInt8(0) === -10);
  assert(view.getInt8(1) === -32);
  assert(view.getInt8(2) === 88);
  assert(view.getInt8(3) === -97);
  assert(view.getInt8(4) === -126);
  assert(view.getInt8(5) === 101);
  assert(view.getInt8(6) === 67);
  assert(view.getInt8(7) === 95);

  assert(view.getInt16(0, true) === -7946);
  assert(view.getInt16(1, true) === 22752);
  assert(view.getInt16(2, true) === -24744);
  assert(view.getInt16(3, true) === -32097);
  assert(view.getInt16(4, true) === 25986);
  assert(view.getInt16(5, true) === 17253);
  assert(view.getInt16(6, true) === 24387);

  assert(view.getInt16(0, false) === -2336);
  assert(view.getInt16(1, false) === -8104);
  assert(view.getInt16(2, false) === 22687);
  assert(view.getInt16(3, false) === -24702);
  assert(view.getInt16(4, false) === -32155);
  assert(view.getInt16(5, false) === 25923);
  assert(view.getInt16(6, false) === 17247);

  assert(view.getInt32(0, true) === -1621565194);
  assert(view.getInt32(1, true) === -2103486240);
  assert(view.getInt32(2, true) === 1703059288);
  assert(view.getInt32(3, true) === 1130726047);
  assert(view.getInt32(4, true) === 1598252418);

  assert(view.getInt32(0, false) === -153069409);
  assert(view.getInt32(1, false) === -531062910);
  assert(view.getInt32(2, false) === 1486848613);
  assert(view.getInt32(3, false) === -1618844349);
  assert(view.getInt32(4, false) === -2107292833);

  assert(view.getInt64(0, true) === 6864441868736323830);
  assert(view.getInt64(0, false) === -657428103485373601);

  assert(view.getUint8(0) === 246);
  assert(view.getUint8(1) === 224);
  assert(view.getUint8(2) === 88);
  assert(view.getUint8(3) === 159);
  assert(view.getUint8(4) === 130);
  assert(view.getUint8(5) === 101);
  assert(view.getUint8(6) === 67);
  assert(view.getUint8(7) === 95);

  assert(view.getUint16(0, true) === 57590);
  assert(view.getUint16(1, true) === 22752);
  assert(view.getUint16(2, true) === 40792);
  assert(view.getUint16(3, true) === 33439);
  assert(view.getUint16(4, true) === 25986);
  assert(view.getUint16(5, true) === 17253);
  assert(view.getUint16(6, true) === 24387);

  assert(view.getUint16(0, false) === 63200);
  assert(view.getUint16(1, false) === 57432);
  assert(view.getUint16(2, false) === 22687);
  assert(view.getUint16(3, false) === 40834);
  assert(view.getUint16(4, false) === 33381);
  assert(view.getUint16(5, false) === 25923);
  assert(view.getUint16(6, false) === 17247);

  assert(view.getUint32(0, true) === 2673402102);
  assert(view.getUint32(1, true) === 2191481056);
  assert(view.getUint32(2, true) === 1703059288);
  assert(view.getUint32(3, true) === 1130726047);
  assert(view.getUint32(4, true) === 1598252418);

  assert(view.getUint32(0, false) === 4141897887);
  assert(view.getUint32(1, false) === 3763904386);
  assert(view.getUint32(2, false) === 1486848613);
  assert(view.getUint32(3, false) === 2676122947);
  assert(view.getUint32(4, false) === 2187674463);

  assert(view.getUint64(0, true) === 6864441868736323830);
  assert(view.getUint64(0, false) === 17789315970224178015);

  view.setFloat32(0, 1.5976661625240943e-18, true);
  assert(view.getFloat32(0, true) === 1.5976661625240943e-18);

  view.setFloat32(0, 1.9762819733816963e+21, false);
  assert(view.getFloat32(0, false) === 1.9762819733816963e+21);

  view.setFloat64(0, -1.094252199637739e+148, true);
  assert(view.getFloat64(0, true) === -1.094252199637739e+148);

  view.setFloat64(0, 6.022586634778589e-103, false);
  assert(view.getFloat64(0, false) === 6.022586634778589e-103);

  view.setInt8(0, 108);
  assert(view.getInt8(0) === 108);

  view.setInt16(0, -13360, true);
  assert(view.getInt16(0, true) === -13360);

  view.setInt16(0, 14689, false);
  assert(view.getInt16(0, false) === 14689);

  view.setInt32(0, 1204680201, true);
  assert(view.getInt32(0, true) === 1204680201);

  view.setInt32(0, 660673230, false);
  assert(view.getInt32(0, false) === 660673230);

  view.setInt64(0, -3290739641816099749, true);
  assert(view.getInt64(0, true) === -3290739641816099749);

  view.setInt64(0, 8178932412950708047, false);
  assert(view.getInt64(0, false) === 8178932412950708047);

  view.setUint8(0, 238);
  assert(view.getUint8(0) === 238);

  view.setUint16(0, 58856, true);
  assert(view.getUint16(0, true) === 58856);

  view.setUint16(0, 60400, false);
  assert(view.getUint16(0, false) === 60400);

  view.setUint32(0, 3448161552, true);
  assert(view.getUint32(0, true) === 3448161552);

  view.setUint32(0, 2784175665, false);
  assert(view.getUint32(0, false) === 2784175665);

  view.setUint64(0, 2334704782995986958, true);
  assert(view.getUint64(0, true) === 2334704782995986958);

  view.setUint64(0, 11323557176419695287, false);
  assert(view.getUint64(0, false) === 11323557176419695287);

  view = new DataView(array.buffer);
  assert(view.byteOffset == 0);
  assert(view.byteLength == 8);
}

__stack_pointer = __heap_base;
__collect();

'''
'''--- tests/compiler/std/date.json ---
{
  "asc_flags": [
    "--explicitStart"
  ]
}

'''
'''--- tests/compiler/std/date.ts ---
// Date UTC ///////////////////////////////////////////////////////////////////////////////////////
{
  assert(Date.UTC(1970, 0, 1) == 0);
  assert(Date.UTC(1970, 0, 1, 0, 0, 0, 0) == 0);
  assert(Date.UTC(70) == 0);
  assert(Date.UTC(90) == 631152000000);
  assert(Date.UTC(-90) == -65007360000000);
  assert(Date.UTC(2018, 10, 10, 11, 0, 0, 1) == 1541847600001);
  assert(Date.UTC(275760, 8, 13, 0, 0, 0, 0) == 8640000000000000);
  // Date.UTC(275760, 8, 13, 0, 0, 0, 1); // Invalid Date
}

// Date get / set Time ////////////////////////////////////////////////////////////////////////////

{
  let creationTime = 1541847600001;
  let date = new Date(creationTime);
  assert(date.getTime() == creationTime);
  date.setTime(creationTime + 1);
  assert(date.getTime() == creationTime + 1);
}

// Date getters ///////////////////////////////////////////////////////////////////////////////////

{
  // from +189512-12-14T22:09:43.706Z"
  let date = new Date(5918283958183706);
  assert(date.getUTCFullYear() == 189512);
  assert(date.getUTCMonth() == 11);
  assert(date.getUTCDate() == 14);
  assert(date.getUTCHours() == 22);
  assert(date.getUTCMinutes() == 9);
  assert(date.getUTCSeconds() == 43);
  assert(date.getUTCMilliseconds() == 706);
}

{
  // from 1973-12-04T01:03:11.274Z"
  let date = new Date(123814991274);
  assert(date.getUTCFullYear() == 1973);
  assert(date.getUTCMonth() == 11);
  assert(date.getUTCDate() == 4);
  assert(date.getUTCHours() == 1);
  assert(date.getUTCMinutes() == 3);
  assert(date.getUTCSeconds() == 11);
  assert(date.getUTCMilliseconds() == 274);
}

// Date#setUTCMilliseconds /////////////////////////////////////////////////////////////////////////
{
  let date = new Date(399464523963984);
  assert(date.getUTCMilliseconds() == 984);
  date.setUTCMilliseconds(12);
  assert(date.getUTCMilliseconds() == 12);
  date.setUTCMilliseconds(568);
  assert(date.getUTCMilliseconds() == 568);
  // test in boundaries
  date.setUTCMilliseconds(0);
  assert(date.getTime() == 399464523963000);
  date.setUTCMilliseconds(999);
  assert(date.getTime() == 399464523963999);
  // test out of boundaries
  date.setUTCMilliseconds(2000);
  assert(date.getUTCMilliseconds() == 0);
  assert(date.getTime() == 399464523965000);
  date.setUTCMilliseconds(-2000);
  assert(date.getUTCMilliseconds() == 0);
  assert(date.getTime() == 399464523963000);
}

// Date#setUTCSeconds //////////////////////////////////////////////////////////////////////////////
{
  let date = new Date(372027318331986);
  assert(date.getUTCSeconds() == 31);
  date.setUTCSeconds(12);
  assert(date.getUTCSeconds() == 12);
  date.setUTCSeconds(50);
  assert(date.getUTCSeconds() == 50);
  // test boundaries
  date.setUTCSeconds(0);
  assert(date.getTime() == 372027318300986);
  date.setUTCSeconds(59);
  assert(date.getTime() == 372027318359986);
}

// Date#setUTCMinutes //////////////////////////////////////////////////////////////////////////////
{
  let date = new Date(372027318331986);
  assert(date.getUTCMinutes() == 45);
  date.setUTCMinutes(12);
  assert(date.getUTCMinutes() == 12);
  date.setUTCMinutes(50);
  assert(date.getUTCMinutes() == 50);
  // test boundaries
  date.setUTCMinutes(0);
  assert(date.getTime() == 372027315631986);
  date.setUTCMinutes(59);
  assert(date.getTime() == 372027319171986);
}

// Date#setUTCHours ////////////////////////////////////////////////////////////////////////////////
{
  let date = new Date(372027318331986);
  assert(date.getUTCHours() == 17);
  date.setUTCHours(12);
  assert(date.getUTCHours() == 12);
  date.setUTCHours(2);
  assert(date.getUTCHours() == 2);
  // test boundaries
  date.setUTCHours(0);
  assert(date.getTime() == 372027257131986);
  date.setUTCHours(23);
  assert(date.getTime() == 372027339931986);
}

// Date#setUTCDate /////////////////////////////////////////////////////////////////////////////////
{
  let date = new Date(123814991274);
  assert(date.getUTCFullYear() == 1973);
  assert(date.getUTCMonth() == 11);

  // test a few values
  date.setUTCDate(12);
  assert(date.getUTCDate() == 12);
  date.setUTCDate(2);
  assert(date.getUTCDate() == 2);

  // test boundaries
  // nov has 30 days
  date.setUTCDate(1);
  date.setUTCDate(30);

  // jan has 31 days
  date.setUTCMonth(1);
  date.setUTCDate(1);
  date.setUTCDate(31);

  // feb on leap year
  date.setUTCFullYear(2024);
  date.setUTCMonth(2);
  date.setUTCDate(1);
  date.setUTCDate(29);

  assert(date.getTime() == 1711674191274);
  assert(date.getUTCDate() == 29);
  assert(date.getUTCMinutes() == 3);
  assert(date.getUTCSeconds() == 11);
  assert(date.getUTCMilliseconds() == 274);

  date = new Date(1362106799999);
  date.setUTCDate(20);
  assert(date.getTime() == 1363748399999);
  date.setUTCDate(1);
  assert(date.getTime() == 1362106799999);

  date.setUTCMilliseconds(1000);
  assert(date.getTime() == 1362106800000);

  date.setUTCMilliseconds(60 * 60 * 1000);
  assert(date.getTime() == 1362110400000);

  date.setUTCMilliseconds(60 * 60 * 1000 + 1);
  assert(date.getTime() == 1362114000001);

  date.setUTCMilliseconds(60 * 60 * 1000 + 1);
  assert(date.getTime() == 1362117600001);

  date = new Date(123814991274);
  date.setUTCDate(-2208);
  assert(date.getTime() == -67301808726);

  date = new Date(123814991274);
  date.setUTCDate(2208);
  assert(date.getTime() == 314240591274);
}

// Date#setUTCDay //////////////////////////////////////////////////////////////////////////////////
{
  // tests from test262
  const july6: i64 = 1467763200000;
  const july9: i64 = 1468022400000;
  const dayMs: i64 = 24 * 60 * 60 * 1000;

  assert(new Date(july6    ).getUTCDay() == 3);
  assert(new Date(july6 - 1).getUTCDay() == 2);
  assert(new Date(july6 + dayMs - 1).getUTCDay() == 3);
  assert(new Date(july6 + dayMs    ).getUTCDay() == 4);

  assert(new Date(july9    ).getUTCDay() == 6);
  assert(new Date(july9 - 1).getUTCDay() == 5);
  assert(new Date(july9 + dayMs - 1).getUTCDay() == 6);
  assert(new Date(july9 + dayMs    ).getUTCDay() == 0);
}

// Date#setUTCMonth ////////////////////////////////////////////////////////////////////////////////
{
  let date = new Date(7899943856218720);
  assert(date.getUTCMonth() == 3);
  date.setUTCMonth(10);
  assert(date.getUTCMonth() == 10);
  date.setUTCMonth(2);
  assert(date.getUTCMonth() == 2);
  assert(date.getTime() == 7899941177818720);
  // test boundaries
  date.setUTCMonth(1);
  date.setUTCMonth(12);
  assert(date.getTime() == 7899967616218720);

  // test out of boundaries
  date.setUTCMonth(0);
  assert(date.getTime() == 7899967616218720);
  date.setUTCMonth(13);
  assert(date.getTime() == 7900001830618720);
}

// Date#setUTCFullYear /////////////////////////////////////////////////////////////////////////////
{
  let date = new Date(7941202527925698);
  assert(date.getUTCFullYear() == 253616);
  date.setUTCFullYear(1976);
  assert(date.getUTCFullYear() == 1976);
  date.setUTCFullYear(20212);
  assert(date.getUTCFullYear() == 20212);
  date.setUTCFullYear(71);
  assert(date.getUTCFullYear() == 71);
}

// Date#toISOString ////////////////////////////////////////////////////////////////////////////////
{
  let date = new Date(-62167219200000);
  assert(date.toISOString() == "0000-01-01T00:00:00.000Z");
  date = new Date(-62167219200000 - 1);
  assert(date.toISOString() == "-000001-12-31T23:59:59.999Z");
  date = new Date(-62127219200000);
  assert(date.toISOString() == "0001-04-07T23:06:40.000Z");
  date = new Date(1231231231020);
  assert(date.toISOString() == "2009-01-06T08:40:31.020Z");
  date = new Date(1231231231456);
  assert(date.toISOString() == "2009-01-06T08:40:31.456Z");
  date = new Date(322331231231020);
  assert(date.toISOString() == "+012184-04-08T13:07:11.020Z");
  date = new Date(253402300799999);
  assert(date.toISOString() == "9999-12-31T23:59:59.999Z");
  date = new Date(253402300800000);
  assert(date.toISOString() == "+010000-01-01T00:00:00.000Z");
  date = new Date(-62847038769226);
  assert(date.toISOString() == "-000022-06-16T17:13:50.774Z");
}

// Date#toDateString ///////////////////////////////////////////////////////////////////////////////
{
  let date = new Date(-61536067200000);
  assert(date.toDateString() == "Wed Jan 01 0020");
  date = new Date(1580601600000);
  assert(date.toDateString() == "Sun Feb 02 2020");
  // negative year
  date = new Date(-62183116800000); // '-000001-07-01T00:00Z'
  assert(date.toDateString() == "Thu Jul 01 -0001");
}

// Date#toTimeString ///////////////////////////////////////////////////////////////////////////////
{
  let date = new Date(-61536067200000);
  assert(date.toTimeString() == "00:00:00"); // use UTC time instead local

  date = new Date(253402300799999);
  assert(date.toTimeString() == "23:59:59"); // use UTC time instead local
}

// Date#toUTCString ///////////////////////////////////////////////////////////////////////////////
{
  let date = new Date(-61536067200000);
  assert(date.toUTCString() == "Wed, 01 Jan 0020 00:00:00 GMT");
  date = new Date(1580741613467);
  assert(date.toUTCString() == "Mon, 03 Feb 2020 14:53:33 GMT");
  // negative year
  date = new Date(-62183116800000); // '-000001-07-01T00:00Z'
  assert(date.toUTCString() == "Thu, 01 Jul -0001 00:00:00 GMT");
}

// Date#fromString /////////////////////////////////////////////////////////////////////////////////
{
  // supports year / month / day
  let date = Date.fromString("1976-02-02");
  assert(date.getTime() == 192067200000);
  date = Date.fromString("1976-2-2");
  assert(date.getTime() == 192067200000);
  date = Date.fromString("2345-11-04");
  assert(date.getTime() == 11860387200000);

  // supports year / month / day / hour / minute / second
  date = Date.fromString("1976-02-02T12:34:56"); // still use Z suffix
  assert(date.getTime() == 192112496000);

  // supports milliseconds
  date = Date.fromString("1976-02-02T12:34:56.456"); // still use Z suffix
  assert(date.getTime() == 192112496456);

  // supports 'Z' suffix
  date = Date.fromString("1976-02-02T12:34:56.456Z");
  assert(date.getTime() == 192112496456);

  date = Date.fromString("0000");
  assert(date.getTime() == -62167219200000);

  date = Date.fromString("0001");
  assert(date.getTime() == -62135596800000);

  date = Date.fromString("1976");
  assert(date.getTime() == 189302400000);

  date = Date.fromString("1976-02");
  assert(date.getTime() == 191980800000);

  date = Date.fromString("1976-02-02");
  assert(date.getTime() == 192067200000);

  date = Date.fromString("1976-02-02T12:34"); // still use Z suffix
  assert(date.getTime() == 192112440000);

  date = Date.fromString("1976-02-02T12:34:56"); // still use Z suffix
  assert(date.getTime() == 192112496000);

  // date = Date.fromString('0Z');
  // assert(date.getTime() == 946684800000); // FIXME: fail

  // date = Date.fromString('000Z');
  // assert(date.getTime() == 946684800000); // FIXME: fail

  // Date.fromString("");              // Invalid Date
  // Date.fromString("1000000");       // Invalid Date
  // Date.fromString("1976-02-02T12"); // Invalid Date
}

// Minimum / Maximum dates ////////////////////////////////////////////////////////////////////////
{
  let minDate = new Date(-8640000000000000);
  let maxDate = new Date( 8640000000000000);

  assert(minDate.getTime() == -8640000000000000);
  assert(maxDate.getTime() ==  8640000000000000);

  assert(minDate.getUTCFullYear() == -271821);
  assert(maxDate.getUTCFullYear() ==  275760);

  assert(minDate.getUTCMonth() == 3);
  assert(maxDate.getUTCMonth() == 8);

  assert(minDate.getUTCDate() == 20);
  assert(maxDate.getUTCDate() == 13);

  assert(minDate.toISOString() == "-271821-04-20T00:00:00.000Z");
  assert(maxDate.toISOString() == "+275760-09-13T00:00:00.000Z");

  let maxDateDec = new Date( 8640000000000000 - 1);
  let minDateInc = new Date(-8640000000000000 + 1);

  assert(minDateInc.getUTCFullYear() == -271821);
  assert(minDateInc.getUTCMonth() == 3);
  assert(minDateInc.getUTCDate() == 20);
  assert(minDateInc.getUTCHours() == 0);
  assert(minDateInc.getUTCMinutes() == 0);
  assert(minDateInc.getUTCSeconds() == 0);
  assert(minDateInc.getUTCMilliseconds() == 1);

  assert(maxDateDec.toISOString() == "+275760-09-12T23:59:59.999Z");
  assert(minDateInc.toISOString() == "-271821-04-20T00:00:00.001Z");

  // new Date(maxDate.getTime() + 1); // Invalid Date
  // new Date(minDate.getTime() - 1); // Invalid Date
}

'''
'''--- tests/compiler/std/hash.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/std/hash.ts ---
import { HASH } from "util/hash";

function check(hash: u32): bool {
  return true;
}

check(HASH<string | null>(null));
check(HASH<string>(""));
check(HASH<string>("a"));
check(HASH<string>("ab"));
check(HASH<string>("abc"));
check(HASH<string>("abcd"));
check(HASH<string>("abcde"));
check(HASH<string>("abcdef"));
check(HASH<string>("abcdefg"));
check(HASH<string>("abcdefgh"));
check(HASH<string>("abcdefghi"));

check(HASH<f32>(0.0));
check(HASH<f32>(1.0));
check(HASH<f32>(1.1));
check(HASH<f32>(-0));
check(HASH<f32>(Infinity));
check(HASH<f32>(NaN));

check(HASH<f64>(0.0));
check(HASH<f64>(1.0));
check(HASH<f64>(1.1));
check(HASH<f64>(-0));
check(HASH<f64>(Infinity));
check(HASH<f64>(NaN));

'''
'''--- tests/compiler/std/map.json ---
{
  "asc_flags": [
  ],
  "asc_rtrace": true
}

'''
'''--- tests/compiler/std/map.ts ---
function testNumeric<K extends number,V extends number>(): void {
  var map = new Map<K,V>();

  // insert new
  for (let k: K = 0; k < 100; ++k) {
    assert(!map.has(k));
    map.set(k, 10 + <V>k);
    assert(map.has(k));
    assert(map.get(k) == 10 + <V>k);
  }
  assert(map.size == 100);

  // insert duplicate
  for (let k: K = 0; k < 100; ++k) {
    assert(map.has(k));
    assert(map.get(k) == 10 + <V>k);
    map.set(k, 20 + <V>k);
    assert(map.has(k));
    assert(map.get(k) == 20 + <V>k);
  }
  assert(map.size == 100);

  // keys and values
  let keys = map.keys();
  let vals = map.values();
  let keyMap = new Map<K, K>();
  let valMap = new Map<V, V>();
  for (let index = 0; index < keys.length; ++index) {
    let key = keys[index];
    let value = vals[index];
    assert(map.has(key));
    assert(map.has(<K>(value - 20)));
    keyMap.set(key, key);
    valMap.set(<V>(value - 20), <V>(value - 20));
  }
  assert(keyMap.size == 100);
  assert(valMap.size == 100);

  // delete
  for (let k: K = 0; k < 50; ++k) {
    assert(map.has(k));
    assert(map.get(k) == 20 + <V>k);
    map.delete(k);
    assert(!map.has(k));
  }
  assert(map.size == 50);

  // insert + delete
  for (let k: K = 0; k < 50; ++k) {
    assert(!map.has(k));
    map.set(k, 10 + <V>k);
    assert(map.has(k));
    map.delete(k);
    assert(!map.has(k));
  }
  assert(map.size == 50);

  // clear
  map.clear();
  assert(map.size == 0);
}

testNumeric<i8,i32>();
testNumeric<u8,i32>();
testNumeric<i16,i32>();
testNumeric<u16,i32>();
testNumeric<i32,i32>();
testNumeric<u32,i32>();
testNumeric<i64,i32>();
testNumeric<u64,i32>();
testNumeric<f32,i32>();
testNumeric<f64,i32>();

__collect();

'''
'''--- tests/compiler/std/math.js ---
exports.preInstantiate = function(imports, exports) {
  imports.Math = Math;
  imports.math = {
    mod: function(a, b) { return a % b; }
  };
};

'''
'''--- tests/compiler/std/math.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/std/math.ts ---
// Largely based on test cases from libc-test: http://nsz.repo.hu/git/?p=libc-test
/*
  libc-test is licensed under the following standard MIT license:

  Copyright Â© 2005-2013 libc-test AUTHORS

  Permission is hereby granted, free of charge, to any person obtaining
  a copy of this software and associated documentation files (the
  "Software"), to deal in the Software without restriction, including
  without limitation the rights to use, copy, modify, merge, publish,
  distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to
  the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

  Portions of this software is derived from software authored by
  third parties:

  math tests use numbers under BSD and GPL licenses see src/math/ucb/*
  and src/math/crlibm/* for details
*/

const js = true; // also test, and thus compare to, JS math?

// these flags are unused, but kept in case these might just so happen to become useful
const INEXACT   = 1 << 0;
const INVALID   = 1 << 1;
const DIVBYZERO = 1 << 2;
const UNDERFLOW = 1 << 3;
const OVERFLOW  = 1 << 4;

const kPI     = reinterpret<f64>(0x400921FB54442D18);
const kTwo120 = 1.329227995784916e+36;

function eulp(x: f64): i32 {
  var u = reinterpret<u64>(x);
  var e = <i32>(u >> 52 & 0x7ff);
  if (!e) e++;
  return e - 0x3ff - 52;
}

function ulperr(got: f64, want: f64, dwant: f64): f64 {
  const Ox1p1023  = reinterpret<f64>(0x7FE0000000000000);
  if (isNaN(got) && isNaN(want)) return 0;
  if (got == want) {
    if (NativeMath.signbit(got) == NativeMath.signbit(want)) return dwant;
    return Infinity;
  }
  if (!isFinite(got)) {
    got = copysign<f64>(Ox1p1023, got);
    want *= 0.5;
  }
  return NativeMath.scalbn(got - want, -eulp(want)) + dwant;
}

function eulpf(x: f32): i32 {
  var u = reinterpret<u32>(x);
  var e = <i32>(u >> 23 & 0xff);
  if (!e) e++;
  return e - 0x7f - 23;
}

function ulperrf(got: f32, want: f32, dwant: f32): f32 {
  const Ox1p127f = reinterpret<f32>(0x7F000000);
  if (isNaN(got) && isNaN(want)) return 0;
  if (got == want) {
    if (NativeMathf.signbit(got) == NativeMathf.signbit(want)) return dwant;
    return Infinity;
  }
  if (!isFinite(got)) {
    got = copysign<f32>(Ox1p127f, got);
    want *= 0.5;
  }
  return NativeMathf.scalbn(got - want, -eulpf(want)) + dwant;
}

function check<T>(actual: T, expected: T, dy: T, flags: i32): bool {
  if (actual == expected) return true;
  if (isNaN(expected)) return isNaN(actual);
  var d: T;
  if (sizeof<T>() == 8) d = ulperr(actual, expected, dy);
  else if (sizeof<T>() == 4) d = ulperrf(actual, expected, dy);
  else return false;
  if (abs<T>(d) >= 1.5) {
    return false;
  }
  return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Global aliases
////////////////////////////////////////////////////////////////////////////////////////////////////

assert(Math.E == NativeMath.E);
assert(Mathf.E == NativeMathf.E);

////////////////////////////////////////////////////////////////////////////////////////////////////
// Constants
////////////////////////////////////////////////////////////////////////////////////////////////////

assert(check<f64>(NativeMath.E, JSMath.E, 0.0, 0));
assert(check<f64>(NativeMath.LN2, JSMath.LN2, 0.0, 0));
assert(check<f64>(NativeMath.LN10, JSMath.LN10, 0.0, 0));
assert(check<f64>(NativeMath.LOG2E, JSMath.LOG2E, 0.0, 0));
assert(check<f64>(NativeMath.PI, JSMath.PI, 0.0, 0));
assert(check<f64>(NativeMath.SQRT1_2, JSMath.SQRT1_2, 0.0, 0));
assert(check<f64>(NativeMath.SQRT2, JSMath.SQRT2, 0.0, 0));

assert(check<f32>(NativeMathf.E, <f32>JSMath.E, 0.0, 0));
assert(check<f32>(NativeMathf.LN2, <f32>JSMath.LN2, 0.0, 0));
assert(check<f32>(NativeMathf.LN10, <f32>JSMath.LN10, 0.0, 0));
assert(check<f32>(NativeMathf.LOG2E, <f32>JSMath.LOG2E, 0.0, 0));
assert(check<f32>(NativeMathf.PI, <f32>JSMath.PI, 0.0, 0));
assert(check<f32>(NativeMathf.SQRT1_2, <f32>JSMath.SQRT1_2, 0.0, 0));
assert(check<f32>(NativeMathf.SQRT2, <f32>JSMath.SQRT2, 0.0, 0));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Internal scalbn
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_scalbn(value: f64, n: i32, expected: f64, error: f64, flags: i32): bool {
  return check<f64>(NativeMath.scalbn(value, n), expected, error, flags);
}

// sanity
assert(test_scalbn(-8.06684839057968084, -2, -2.01671209764492021, 0.0, 0));
assert(test_scalbn(4.34523984933830487, -1, 2.17261992466915244, 0.0, 0));
assert(test_scalbn(-8.38143342755524934, 0, -8.38143342755524934, 0.0, 0));
assert(test_scalbn(-6.53167358191348413, 1, -13.0633471638269683, 0.0, 0));
assert(test_scalbn(9.26705696697258574, 2, 37.068227867890343, 0.0, 0));
assert(test_scalbn(0.661985898099504477, 3, 5.29588718479603582, 0.0, 0));
assert(test_scalbn(-0.40660392238535531, 4, -6.50566275816568496, 0.0, 0));
assert(test_scalbn(0.56175974622072411, 5, 17.9763118790631715, 0.0, 0));
assert(test_scalbn(0.77415229659130369, 6, 49.5457469818434362, 0.0, 0));
assert(test_scalbn(-0.678763702639402444, 7, -86.8817539378435129, 0.0, 0));

// special
assert(test_scalbn(0.0, 2147483647, 0.0, 0.0, 0));
assert(test_scalbn(0.0, -2147483647, 0.0, 0.0, 0));
assert(test_scalbn(-0.0, 2147483647, -0.0, 0.0, 0));
assert(test_scalbn(NaN, 0, NaN, 0.0, 0));
assert(test_scalbn(Infinity, 0, Infinity, 0.0, 0));
assert(test_scalbn(-Infinity, 0, -Infinity, 0.0, 0));
assert(test_scalbn(1.0, 0, 1.0, 0.0, 0));
assert(test_scalbn(1.0, 1, 2.0, 0.0, 0));
assert(test_scalbn(1.0, -1, 0.5, 0.0, 0));
assert(test_scalbn(1.0, 2147483647, Infinity, 0.0, INEXACT | OVERFLOW));
assert(test_scalbn(NaN, 1, NaN, 0.0, 0));
assert(test_scalbn(Infinity, 2147483647, Infinity, 0.0, 0));
assert(test_scalbn(Infinity, -2147483647, Infinity, 0.0, 0));
assert(test_scalbn(-Infinity, 2147483647, -Infinity, 0.0, 0));
assert(test_scalbn(8.98846567431157954e+307, -2097, 4.94065645841246544e-324, 0.0, 0));
assert(test_scalbn(4.94065645841246544e-324, 2097, 8.98846567431157954e+307, 0.0, 0));
assert(test_scalbn(1.000244140625, -1074, 4.94065645841246544e-324, 0.0, INEXACT | UNDERFLOW));
assert(test_scalbn(0.749999999999999889, -1073, 4.94065645841246544e-324, 0.0, INEXACT | UNDERFLOW));
assert(test_scalbn(0.500000000000001221, -1024, 2.78134232313400667e-309, 0.0, INEXACT | UNDERFLOW));

// Internal scalbnf ////////////////////////////////////////////////////////////////////////////////

function test_scalbnf(value: f32, n: i32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.scalbn(value, n), expected, error, flags);
}

// sanity
assert(test_scalbnf(-8.066848755, -2, -2.016712189, 0.0, 0));
assert(test_scalbnf(4.345239639, -1, 2.17261982, 0.0, 0));
assert(test_scalbnf(-8.381433487, 0, -8.381433487, 0.0, 0));
assert(test_scalbnf(-6.531673431, 1, -13.06334686, 0.0, 0));
assert(test_scalbnf(9.267057419, 2, 37.06822968, 0.0, 0));
assert(test_scalbnf(0.6619858742, 3, 5.295886993, 0.0, 0));
assert(test_scalbnf(-0.4066039324, 4, -6.505662918, 0.0, 0));
assert(test_scalbnf(0.5617597699, 5, 17.97631264, 0.0, 0));
assert(test_scalbnf(0.7741522789, 6, 49.54574585, 0.0, 0));
assert(test_scalbnf(-0.6787636876, 7, -86.88175201, 0.0, 0));

// special
assert(test_scalbnf(0.0, 2147483647, 0.0, 0.0, 0));
assert(test_scalbnf(0.0, -2147483647, 0.0, 0.0, 0));
assert(test_scalbnf(-0.0, 2147483647, -0.0, 0.0, 0));
assert(test_scalbnf(NaN, 0, NaN, 0.0, 0));
assert(test_scalbnf(Infinity, 0, Infinity, 0.0, 0));
assert(test_scalbnf(-Infinity, 0, -Infinity, 0.0, 0));
assert(test_scalbnf(1.0, 0, 1.0, 0.0, 0));
assert(test_scalbnf(1.0, 1, 2.0, 0.0, 0));
assert(test_scalbnf(1.0, -1, 0.5, 0.0, 0));
assert(test_scalbnf(1.0, 2147483647, Infinity, 0.0, INEXACT | OVERFLOW));
assert(test_scalbnf(NaN, 1, NaN, 0.0, 0));
assert(test_scalbnf(Infinity, 2147483647, Infinity, 0.0, 0));
assert(test_scalbnf(Infinity, -2147483647, Infinity, 0.0, 0));
assert(test_scalbnf(-Infinity, 2147483647, -Infinity, 0.0, 0));
assert(test_scalbnf(1.701411835e+38, -276, 1.401298464e-45, 0.0, 0));
assert(test_scalbnf(1.401298464e-45, 276, 1.701411835e+38, 0.0, 0));
assert(test_scalbnf(1.000244141, -149, 1.401298464e-45, 0.0, INEXACT | UNDERFLOW));
assert(test_scalbnf(0.7499999404, -148, 1.401298464e-45, 0.0, INEXACT | UNDERFLOW));
assert(test_scalbnf(0.5000006557, -128, 1.469369340e-39, 0.0, INEXACT | UNDERFLOW));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.abs
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_abs(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.abs(value), expected, error, flags) &&
  (!js || check<f64>(    JSMath.abs(value), expected, error, flags));
}

// sanity
assert(test_abs(-8.06684839057968084, 8.06684839057968084, 0.0, 0));
assert(test_abs(4.34523984933830487, 4.34523984933830487, 0.0, 0));
assert(test_abs(-8.38143342755524934, 8.38143342755524934, 0.0, 0));
assert(test_abs(-6.53167358191348413, 6.53167358191348413, 0.0, 0));
assert(test_abs(9.26705696697258574, 9.26705696697258574, 0.0, 0));
assert(test_abs(0.661985898099504477, 0.661985898099504477, 0.0, 0));
assert(test_abs(-0.40660392238535531, 0.40660392238535531, 0.0, 0));
assert(test_abs(0.56175974622072411, 0.56175974622072411, 0.0, 0));
assert(test_abs(0.77415229659130369, 0.77415229659130369, 0.0, 0));
assert(test_abs(-0.678763702639402444, 0.678763702639402444, 0.0, 0));

// special
assert(test_abs(0.0, 0.0, 0.0, 0));
assert(test_abs(-0.0, 0.0, 0.0, 0));
assert(test_abs(1.0, 1.0, 0.0, 0));
assert(test_abs(-1.0, 1.0, 0.0, 0));
assert(test_abs(Infinity, Infinity, 0.0, 0));
assert(test_abs(-Infinity, Infinity, 0.0, 0));
assert(test_abs(NaN, NaN, 0.0, 0));

// Mathf.abs ///////////////////////////////////////////////////////////////////////////////////////

function test_absf(value: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.abs(value), expected, error, flags);
}

// sanity
assert(test_absf(-8.066848755, 8.066848755, 0.0, 0));
assert(test_absf(4.345239639, 4.345239639, 0.0, 0));
assert(test_absf(-8.381433487, 8.381433487, 0.0, 0));
assert(test_absf(-6.531673431, 6.531673431, 0.0, 0));
assert(test_absf(9.267057419, 9.267057419, 0.0, 0));
assert(test_absf(0.6619858742, 0.6619858742, 0.0, 0));
assert(test_absf(-0.4066039324, 0.4066039324, 0.0, 0));
assert(test_absf(0.5617597699, 0.5617597699, 0.0, 0));
assert(test_absf(0.7741522789, 0.7741522789, 0.0, 0));
assert(test_absf(-0.6787636876, 0.6787636876, 0.0, 0));

// special
assert(test_absf(0.0, 0.0, 0.0, 0));
assert(test_absf(-0.0, 0.0, 0.0, 0));
assert(test_absf(1.0, 1.0, 0.0, 0));
assert(test_absf(-1.0, 1.0, 0.0, 0));
assert(test_absf(Infinity, Infinity, 0.0, 0));
assert(test_absf(-Infinity, Infinity, 0.0, 0));
assert(test_absf(NaN, NaN, 0.0, 0));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.acos
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_acos(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.acos(value), expected, error, flags) &&
  (!js || check<f64>(    JSMath.acos(value), expected, error, flags));
}

// sanity
assert(test_acos(-8.06684839057968084, NaN, 0.0, INVALID));
assert(test_acos(4.34523984933830487, NaN, 0.0, INVALID));
assert(test_acos(-8.38143342755524934, NaN, 0.0, INVALID));
assert(test_acos(-6.53167358191348413, NaN, 0.0, INVALID));
assert(test_acos(9.26705696697258574, NaN, 0.0, INVALID));
assert(test_acos(0.661985898099504477, 0.84733108284335068, -0.415532767772674561, INEXACT));
assert(test_acos(-0.40660392238535531, 1.98953007108866897, 0.4973946213722229, INEXACT));
assert(test_acos(0.56175974622072411, 0.974284964567490364, -0.442889750003814697, INEXACT));
assert(test_acos(0.77415229659130369, 0.68542151586362221, -0.125895276665687561, INEXACT));
assert(test_acos(-0.678763702639402444, 2.31687413820596388, -0.172849491238594055, INEXACT));

// special
assert(test_acos(0.0, 1.57079632679489656, -0.275765955448150635, INEXACT));
assert(test_acos(-1.0, 3.14159265358979312, -0.275765955448150635, INEXACT));
assert(test_acos(1.0, 0.0, 0.0, 0));
assert(test_acos(1.00000000000000022, NaN, 0.0, INVALID));
assert(test_acos(-1.00000000000000022, NaN, 0.0, INVALID));
assert(test_acos(Infinity, NaN, 0.0, INVALID));
assert(test_acos(-Infinity, NaN, 0.0, INVALID));
assert(test_acos(NaN, NaN, 0.0, 0));
assert(test_acos(-0.530922720959298489, 2.13048537997054632, 0.139100849628448486, INEXACT));
assert(test_acos(0.493955674639974585, 1.05416298758519456, 0.220547676086425781, INEXACT));

// Mathf.acos //////////////////////////////////////////////////////////////////////////////////////

function test_acosf(value: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.acos(value), expected, error, flags);
}

// sanity
assert(test_acosf(-8.066848755, NaN, 0.0, INVALID));
assert(test_acosf(4.345239639, NaN, 0.0, INVALID));
assert(test_acosf(-8.381433487, NaN, 0.0, INVALID));
assert(test_acosf(-6.531673431, NaN, 0.0, INVALID));
assert(test_acosf(9.267057419, NaN, 0.0, INVALID));
assert(test_acosf(0.6619858742, 0.8473311067, -0.1358813196, INEXACT));
assert(test_acosf(-0.4066039324, 1.989530087, 0.03764917701, INEXACT));
assert(test_acosf(0.5617597699, 0.9742849469, 0.1844373941, INEXACT));
assert(test_acosf(0.7741522789, 0.6854215264, -0.2915834486, INEXACT));
assert(test_acosf(-0.6787636876, 2.316874027, -0.3795364499, INEXACT));

// special
assert(test_acosf(0.0, 1.570796371, 0.3666777015, INEXACT));
assert(test_acosf(-1.0, 3.141592741, 0.3666777015, INEXACT));
assert(test_acosf(1.0, 0.0, 0.0, 0));
assert(test_acosf(1.000000119, NaN, 0.0, INVALID));
assert(test_acosf(-1.000000119, NaN, 0.0, INVALID));
assert(test_acosf(Infinity, NaN, 0.0, INVALID));
assert(test_acosf(-Infinity, NaN, 0.0, INVALID));
assert(test_acosf(NaN, NaN, 0.0, 0));
assert(test_acosf(0.4996506572, 1.047600865, -0.2116181403, INEXACT));
assert(test_acosf(-0.505140543, 2.100341082, -0.2085270584, INEXACT));
assert(test_acosf(-0.5189794898, 2.116452932, -0.146008268, INEXACT));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.acosh
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_acosh(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.acosh(value), expected, error, flags) &&
  (!js || check<f64>(    JSMath.acosh(value), expected, error, flags));
}

// sanity
assert(test_acosh(-8.06684839057968084, NaN, 0.0, INVALID));
assert(test_acosh(4.34523984933830487, 2.14871639805975034, -0.291634738445281982, INEXACT));
assert(test_acosh(-8.38143342755524934, NaN, 0.0, INVALID));
assert(test_acosh(-6.53167358191348413, NaN, 0.0, INVALID));
assert(test_acosh(9.26705696697258574, 2.91668914109907984, -0.241919085383415222, INEXACT));
assert(test_acosh(0.661985898099504477, NaN, 0.0, INVALID));
assert(test_acosh(-0.40660392238535531, NaN, 0.0, INVALID));
assert(test_acosh(0.56175974622072411, NaN, 0.0, INVALID));
assert(test_acosh(0.77415229659130369, NaN, 0.0, INVALID));
assert(test_acosh(-0.678763702639402444, NaN, 0.0, INVALID));

// special
assert(test_acosh(NaN, NaN, 0.0, 0));
assert(test_acosh(Infinity, Infinity, 0.0, 0));
assert(test_acosh(1.0, 0.0, 0.0, 0));
assert(test_acosh(0.99999237060546875, NaN, 0.0, INVALID));
assert(test_acosh(-9784.8207664738350, NaN, 0.0, INVALID));
assert(test_acosh(0.0, NaN, 0.0, INVALID));
assert(test_acosh(-0.0, NaN, 0.0, INVALID));
assert(test_acosh(-Infinity, NaN, 0.0, INVALID));

// TODO: hard cases close to 1
// assert(test_acosh(1.00047471439683111, 0.030811583621269234, -0.147202208638191223, INEXACT));
// assert(test_acosh(1.00183940730320464, 0.0606439391272710696, -0.27641335129737854, INEXACT));
// assert(test_acosh(1.00188411580836734, 0.0613762895053152624, 0.144539892673492432, INEXACT));
// assert(test_acosh(1.00710219219241903, 0.11911172253310362, -0.0701267644762992859, INEXACT));
// assert(test_acosh(1.00721657615236126, 0.1200659234653388, 0.348167449235916138, INEXACT));
// assert(test_acosh(1.00755889036240331, 0.122877066266470714, 0.238077804446220398, INEXACT));
// assert(test_acosh(1.02542398474864016, 0.225019907470933367, -0.326139897108078003, INEXACT));
// assert(test_acosh(1.0256625220747686, 0.226068601206439679, -0.038667779415845871, INEXACT));
// assert(test_acosh(1.0258391651139116, 0.226842008792436378, -0.214941442012786865, INEXACT));
// assert(test_acosh(1.02779264167821971, 0.235222655703679978, -0.18194638192653656, INEXACT));
// assert(test_acosh(1.02795793845257588, 0.235917895367856345, -0.21022343635559082, INEXACT));
// assert(test_acosh(1.03023030515918168, 0.245272131775117419, -0.281468182802200317, INEXACT));
// assert(test_acosh(1.10422493637863384, 0.452687876797022049, 0.276559263467788696, INEXACT));
assert(test_acosh(1.10608311999264286, 0.45663734043848031, -0.293816089630126953, INEXACT));
// assert(test_acosh(1.10669650280664866, 0.457933064962976033, -0.261756330728530884, INEXACT));
assert(test_acosh(1.10898095576286582, 0.462724685995942797, -0.399009555578231812, INEXACT));
assert(test_acosh(1.11694291598755213, 0.47902433134075284, -0.321674108505249023, INEXACT));

// Mathf.acosh /////////////////////////////////////////////////////////////////////////////////////

function test_acoshf(value: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.acosh(value), expected, error, flags);
}

// sanity
assert(test_acoshf(-8.066848755, NaN, 0.0, INVALID));
assert(test_acoshf(4.345239639, 2.14871645, 0.4251045287, INEXACT));
assert(test_acoshf(-8.381433487, NaN, 0.0, INVALID));
assert(test_acoshf(-6.531673431, NaN, 0.0, INVALID));
assert(test_acoshf(9.267057419, 2.916689157, -0.1369788945, INEXACT));
assert(test_acoshf(0.6619858742, NaN, 0.0, INVALID));
assert(test_acoshf(-0.4066039324, NaN, 0.0, INVALID));
assert(test_acoshf(0.5617597699, NaN, 0.0, INVALID));
assert(test_acoshf(0.7741522789, NaN, 0.0, INVALID));
assert(test_acoshf(-0.6787636876, NaN, 0.0, INVALID));

// special
assert(test_acoshf(NaN, NaN, 0.0, 0));
assert(test_acoshf(Infinity, Infinity, 0.0, 0));
assert(test_acoshf(1.0, 0.0, 0.0, 0));
assert(test_acoshf(0.9999923706, NaN, 0.0, INVALID));
assert(test_acoshf(0.0, NaN, 0.0, INVALID));
assert(test_acoshf(-0.0, NaN, 0.0, INVALID));
assert(test_acoshf(-Infinity, NaN, 0.0, INVALID));
assert(test_acoshf(-1.125899907e+15, NaN, 0.0, INVALID));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.asin
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_asin(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.asin(value), expected, error, flags) &&
  (!js || check<f64>(    JSMath.asin(value), expected, error, flags));
}

// sanity
assert(test_asin(-8.06684839057968084, NaN, 0.0, INVALID));
assert(test_asin(4.34523984933830487, NaN, 0.0, INVALID));
assert(test_asin(-8.38143342755524934, NaN, 0.0, INVALID));
assert(test_asin(-6.53167358191348413, NaN, 0.0, INVALID));
assert(test_asin(9.26705696697258574, NaN, 0.0, INVALID));
assert(test_asin(0.661985898099504477, 0.723465243951545878, -0.135999128222465515, INEXACT));
assert(test_asin(-0.40660392238535531, -0.418733744293772248, -0.0926423072814941406, INEXACT));
assert(test_asin(0.56175974622072411, 0.596511362227406194, -0.108642138540744781, INEXACT));
assert(test_asin(0.77415229659130369, 0.885374810931274348, -0.425636619329452515, INEXACT));
assert(test_asin(-0.678763702639402444, -0.746077811411067326, 0.139866068959236145, INEXACT));

// special
assert(test_asin(1.0, 1.57079632679489656, -0.275765955448150635, INEXACT));
assert(test_asin(-1.0, -1.57079632679489656, 0.275765955448150635, INEXACT));
assert(test_asin(0.0, 0.0, 0.0, 0));
assert(test_asin(-0.0, -0.0, 0.0, 0));
assert(test_asin(1.00000000000000022, NaN, 0.0, INVALID));
assert(test_asin(-1.00000000000000022, NaN, 0.0, INVALID));
assert(test_asin(Infinity, NaN, 0.0, INVALID));
assert(test_asin(-Infinity, NaN, 0.0, INVALID));
assert(test_asin(NaN, NaN, 0.0, 0));
assert(test_asin(0.507304392911914759, 0.53205389977723494, -0.161573171615600586, INEXACT));

// Mathf.asin //////////////////////////////////////////////////////////////////////////////////////

function test_asinf(value: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.asin(value), expected, error, flags);
}

// sanity
assert(test_asinf(-8.066848755, NaN, 0.0, INVALID));
assert(test_asinf(4.345239639, NaN, 0.0, INVALID));
assert(test_asinf(-8.381433487, NaN, 0.0, INVALID));
assert(test_asinf(-6.531673431, NaN, 0.0, INVALID));
assert(test_asinf(9.267057419, NaN, 0.0, INVALID));
assert(test_asinf(0.6619858742, 0.7234652042, -0.1307632476, INEXACT));
assert(test_asinf(-0.4066039324, -0.4187337458, 0.3161141574, INEXACT));
assert(test_asinf(0.5617597699, 0.596511364, -0.4510819614, INEXACT));
assert(test_asinf(0.7741522789, 0.8853747845, 0.02493886836, INEXACT));
assert(test_asinf(-0.6787636876, -0.746077776, 0.2515012324, INEXACT));

// special
assert(test_asinf(1.0, 1.570796371, 0.3666777015, INEXACT));
assert(test_asinf(-1.0, -1.570796371, -0.3666777015, INEXACT));
assert(test_asinf(0.0, 0.0, 0.0, 0));
assert(test_asinf(-0.0, -0.0, 0.0, 0));
assert(test_asinf(1.000000119, NaN, 0.0, INVALID));
assert(test_asinf(-1.000000119, NaN, 0.0, INVALID));
assert(test_asinf(Infinity, NaN, 0.0, INVALID));
assert(test_asinf(-Infinity, NaN, 0.0, INVALID));
assert(test_asinf(NaN, NaN, 0.0, 0));
assert(test_asinf(0.500477016, 0.5241496563, -0.2942709923, INEXACT));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.asinh
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_asinh(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.asinh(value), expected, error, flags) &&
  (!js || check<f64>(    JSMath.asinh(value), expected, error, flags));
}

// sanity
assert(test_asinh(-8.06684839057968084, -2.78472987838786112, -0.476218998432159424, INEXACT));
assert(test_asinh(4.34523984933830487, 2.17521338901316419, -0.0272875130176544189, INEXACT));
assert(test_asinh(-8.38143342755524934, -2.82270608369769604, 0.20985257625579834, INEXACT));
assert(test_asinh(-6.53167358191348413, -2.57561944659192221, 0.311313420534133911, INEXACT));
assert(test_asinh(9.26705696697258574, 2.92251149510486741, 0.499175608158111572, INEXACT));
assert(test_asinh(0.661985898099504477, 0.621246276270716602, -0.469734758138656616, INEXACT));
assert(test_asinh(-0.40660392238535531, -0.396159903931920354, -0.408144384622573853, INEXACT));
assert(test_asinh(0.56175974622072411, 0.535758887025547414, 0.352071315050125122, INEXACT));
assert(test_asinh(0.77415229659130369, 0.712357126319734912, 0.13371451199054718, INEXACT));
assert(test_asinh(-0.678763702639402444, -0.635182348903198024, 0.0474967099726200104, INEXACT));

// special
assert(test_asinh(NaN, NaN, 0.0, 0));
assert(test_asinh(Infinity, Infinity, 0.0, 0));
assert(test_asinh(-Infinity, -Infinity, 0.0, 0));
assert(test_asinh(0.0, 0.0, 0.0, 0));
assert(test_asinh(-0.0, -0.0, 0.0, 0));

// TODO: hard cases around 0.125?
// assert(test_asinh(0.247980229031791038, 0.245506531315820731, -0.487455964088439941, INEXACT));
// assert(test_asinh(0.233961368245165308, 0.231877865394494953, 0.448774427175521851, INEXACT));
// assert(test_asinh(0.24189636405949258, 0.239597351837045336, -0.43224412202835083, INEXACT));
// assert(test_asinh(0.24297705017513252, 0.240647613714979003, 0.464605927467346191, INEXACT));
// assert(test_asinh(0.243009640747287647, 0.240679282734723166, 0.474347352981567383, INEXACT));
// assert(test_asinh(0.243762819057833202, 0.241411097647160899, -0.471239805221557617, INEXACT));
// assert(test_asinh(0.244209582852871615, 0.241845129387203428, 0.357721567153930664, INEXACT));
// assert(test_asinh(0.245142613572556872, 0.242751426027184358, 0.488074928522109985, INEXACT));
// assert(test_asinh(0.248925886656024803, 0.246424287018607635, 0.423774600028991699, INEXACT));
// assert(test_asinh(0.249687050136605942, 0.247162844410159732, 0.467378854751586914, INEXACT));
// assert(test_asinh(0.252496955340698215, 0.249888150492394823, -0.330307126045227051, INEXACT));
// assert(test_asinh(0.46527661837878348, 0.449940706126732537, 0.415301203727722168, INEXACT));
// assert(test_asinh(0.467958660300663964, 0.452371172681032996, 0.495325148105621338, INEXACT));
// assert(test_asinh(0.479083566135035333, 0.462425786301167263, 0.421210944652557373, INEXACT));
// assert(test_asinh(0.481281048969517788, 0.464406726694242211, -0.483110427856445313, INEXACT));
// assert(test_asinh(0.487328868799273951, 0.469849798263134111, -0.424072027206420898, INEXACT));
// assert(test_asinh(0.489993198082535886, 0.472243604962259256, -0.437918633222579956, INEXACT));
// assert(test_asinh(0.519085143365399015, 0.498216616337933904, -0.420524448156356812, INEXACT));

// Mathf.asinh /////////////////////////////////////////////////////////////////////////////////////

function test_asinhf(value: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.asinh(value), expected, error, flags);
}

// sanity
assert(test_asinhf(-8.066848755, -2.784729958, -0.1441801339, INEXACT));
assert(test_asinhf(4.345239639, 2.175213337, -0.02079696581, INEXACT));
assert(test_asinhf(-8.381433487, -2.822705984, 0.4471853375, INEXACT));
assert(test_asinhf(-6.531673431, -2.575619459, -0.1482227296, INEXACT));
assert(test_asinhf(9.267057419, 2.922511578, 0.1427068114, INEXACT));
assert(test_asinhf(0.6619858742, 0.6212462783, 0.368491292, INEXACT));
assert(test_asinhf(-0.4066039324, -0.3961599171, -0.1317030638, INEXACT));
assert(test_asinhf(0.5617597699, 0.5357589126, 0.08184859902, INEXACT));
assert(test_asinhf(0.7741522789, 0.7123571038, -0.1427073777, INEXACT));
assert(test_asinhf(-0.6787636876, -0.6351823211, 0.2583143711, INEXACT));

// special
assert(test_asinhf(NaN, NaN, 0.0, 0));
assert(test_asinhf(Infinity, Infinity, 0.0, 0));
assert(test_asinhf(-Infinity, -Infinity, 0.0, 0));
assert(test_asinhf(0.0, 0.0, 0.0, 0));
assert(test_asinhf(-0.0, -0.0, 0.0, 0));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.atan
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_atan(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.atan(value), expected, error, flags) &&
  (!js || check<f64>(    JSMath.atan(value), expected, error, flags));
}

// sanity
assert(test_atan(-8.06684839057968084, -1.44746137626334681, 0.148571118712425232, INEXACT));
assert(test_atan(4.34523984933830487, 1.34459792711453807, -0.0817033573985099792, INEXACT));
assert(test_atan(-8.38143342755524934, -1.45204634632955387, -0.0750548020005226135, INEXACT));
assert(test_atan(-6.53167358191348413, -1.41887586587525316, -0.0576334968209266663, INEXACT));
assert(test_atan(9.26705696697258574, 1.46330314544870599, 0.160695642232894897, INEXACT));
assert(test_atan(0.661985898099504477, 0.584755067023832509, 0.458255648612976074, INEXACT));
assert(test_atan(-0.40660392238535531, -0.386186417755213118, -0.257428169250488281, INEXACT));
assert(test_atan(0.56175974622072411, 0.511826953162888065, -0.114442773163318634, INEXACT));
assert(test_atan(0.77415229659130369, 0.658780243165382196, -0.112864881753921509, INEXACT));
assert(test_atan(-0.678763702639402444, -0.596330782697347184, -0.218284234404563904, INEXACT));

// special
assert(test_atan(0.0, 0.0, 0.0, 0));
assert(test_atan(-0.0, -0.0, 0.0, 0));
assert(test_atan(1.0, 0.785398163397448279, -0.275765955448150635, INEXACT));
assert(test_atan(-1.0, -0.785398163397448279, 0.275765955448150635, INEXACT));
assert(test_atan(Infinity, 1.57079632679489656, -0.275765955448150635, INEXACT));
assert(test_atan(-Infinity, -1.57079632679489656, 0.275765955448150635, INEXACT));
assert(test_atan(NaN, NaN, 0.0, 0));
assert(test_atan(0.6929821535674624, 0.606000455515256164, -0.170757904648780823, INEXACT));

// Mathf.atan //////////////////////////////////////////////////////////////////////////////////////

function test_atanf(value: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.atan(value), expected, error, flags);
}

// sanity
assert(test_atanf(-8.066848755, -1.447461367, 0.1268648058, INEXACT));
assert(test_atanf(4.345239639, 1.344597936, 0.1604543477, INEXACT));
assert(test_atanf(-8.381433487, -1.452046394, -0.3958175182, INEXACT));
assert(test_atanf(-6.531673431, -1.418875813, 0.4105703533, INEXACT));
assert(test_atanf(9.267057419, 1.463303208, 0.4840350151, INEXACT));
assert(test_atanf(0.6619858742, 0.5847550631, 0.2125193477, INEXACT));
assert(test_atanf(-0.4066039324, -0.3861864209, 0.1816962808, INEXACT));
assert(test_atanf(0.5617597699, 0.511826992, 0.3499770761, INEXACT));
assert(test_atanf(0.7741522789, 0.6587802172, -0.2505330741, INEXACT));
assert(test_atanf(-0.6787636876, -0.5963307619, 0.1761482656, INEXACT));

// special
assert(test_atanf(0.0, 0.0, 0.0, 0));
assert(test_atanf(-0.0, -0.0, 0.0, 0));
assert(test_atanf(1.0, 0.7853981853, 0.3666777015, INEXACT));
assert(test_atanf(-1.0, -0.7853981853, -0.3666777015, INEXACT));
assert(test_atanf(Infinity, 1.570796371, 0.3666777015, INEXACT));
assert(test_atanf(-Infinity, -1.570796371, -0.3666777015, INEXACT));
assert(test_atanf(NaN, NaN, 0.0, 0));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.atanh
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_atanh(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.atanh(value), expected, error, flags) &&
  (!js || check<f64>(    JSMath.atanh(value), expected, error, flags));
}

// sanity
assert(test_atanh(-8.06684839057968084, NaN, 0.0, INVALID));
assert(test_atanh(4.34523984933830487, NaN, 0.0, INVALID));
assert(test_atanh(-8.38143342755524934, NaN, 0.0, INVALID));
assert(test_atanh(-6.53167358191348413, NaN, 0.0, INVALID));
assert(test_atanh(9.26705696697258574, NaN, 0.0, INVALID));
assert(test_atanh(0.661985898099504477, 0.796340437134794299, 0.213383659720420837, INEXACT));
assert(test_atanh(-0.40660392238535531, -0.431535707306028971, -0.432566612958908081, INEXACT));
assert(test_atanh(0.56175974622072411, 0.635400611164457785, -0.0652786567807197571, INEXACT));
assert(test_atanh(0.77415229659130369, 1.03060855752779945, 0.146320521831512451, INEXACT));
assert(test_atanh(-0.678763702639402444, -0.826817964520525472, 0.139712870121002197, INEXACT));

// special
assert(test_atanh(NaN, NaN, 0.0, 0));
assert(test_atanh(Infinity, NaN, 0.0, INVALID));
assert(test_atanh(-Infinity, NaN, 0.0, INVALID));
assert(test_atanh(0.0, 0.0, 0.0, 0));
assert(test_atanh(-0.0, -0.0, 0.0, 0));
assert(test_atanh(1.0, Infinity, 0.0, DIVBYZERO));
assert(test_atanh(-1.0, -Infinity, 0.0, DIVBYZERO));
assert(test_atanh(1.0000152587890625, NaN, 0.0, INVALID));
assert(test_atanh(-1.0000152587890625, NaN, 0.0, INVALID));
assert(test_atanh(1.35525271560688054e-20, 1.35525271560688054e-20, 0.0, INEXACT));
assert(test_atanh(9.33263618503218879e-302, 9.33263618503218879e-302, 0.0, INEXACT));
assert(test_atanh(5.56268464626800346e-309, 5.56268464626800346e-309, 0.0, INEXACT | UNDERFLOW));
assert(test_atanh(-5.56268464626800346e-309, -5.56268464626800346e-309, 0.0, INEXACT | UNDERFLOW));
assert(test_atanh(8.98846567431157954e+307, NaN, 0.0, INVALID));

// Mathf.atanh /////////////////////////////////////////////////////////////////////////////////////

function test_atanhf(value: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.atanh(value), expected, error, flags);
}

// sanity
assert(test_atanhf(-8.066848755, NaN, 0.0, INVALID));
assert(test_atanhf(4.345239639, NaN, 0.0, INVALID));
assert(test_atanhf(-8.381433487, NaN, 0.0, INVALID));
assert(test_atanhf(-6.531673431, NaN, 0.0, INVALID));
assert(test_atanhf(9.267057419, NaN, 0.0, INVALID));
assert(test_atanhf(0.6619858742, 0.7963404059, 0.1911219656, INEXACT));
assert(test_atanhf(-0.4066039324, -0.4315357208, -0.05180925131, INEXACT));
assert(test_atanhf(0.5617597699, 0.6354006529, 0.1191105619, INEXACT));
assert(test_atanhf(0.7741522789, 1.030608535, 0.1798270345, INEXACT));
assert(test_atanhf(-0.6787636876, -0.8268179297, 0.1158898324, INEXACT));

// special
assert(test_atanhf(NaN, NaN, 0.0, 0));
assert(test_atanhf(Infinity, NaN, 0.0, INVALID));
assert(test_atanhf(-Infinity, NaN, 0.0, INVALID));
assert(test_atanhf(0.0, 0.0, 0.0, 0));
assert(test_atanhf(-0.0, -0.0, 0.0, 0));
assert(test_atanhf(1.0, Infinity, 0.0, DIVBYZERO));
assert(test_atanhf(-1.0, -Infinity, 0.0, DIVBYZERO));
assert(test_atanhf(1.000015259, NaN, 0.0, INVALID));
assert(test_atanhf(-1.000015259, NaN, 0.0, INVALID));
assert(test_atanhf(1.355252716e-20, 1.355252716e-20, 0.0, INEXACT));
assert(test_atanhf(7.888609052e-31, 7.888609052e-31, 0.0, INEXACT));
assert(test_atanhf(2.938735877e-39, 2.938735877e-39, 0.0, INEXACT | UNDERFLOW));
assert(test_atanhf(-2.938735877e-39, -2.938735877e-39, 0.0, INEXACT | UNDERFLOW));
assert(test_atanhf(1.701411835e+38, NaN, 0.0, INVALID));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.atan2
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_atan2(value1: f64, value2: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.atan2(value1, value2), expected, error, flags) &&
  (!js || check<f64>(    JSMath.atan2(value1, value2), expected, error, flags));
}

// sanity
assert(test_atan2(-8.06684839057968084, 4.53566256067686879, -1.05858954024890228, 0.0976626351475715637, INEXACT));
assert(test_atan2(4.34523984933830487, -8.88799136300345083, 2.68687341260130674, 0.358339488506317139, INEXACT));
assert(test_atan2(-8.38143342755524934, -2.76360733737958819, -1.88930009184952796, -0.462359577417373657, INEXACT));
assert(test_atan2(-6.53167358191348413, 4.56753527684274374, -0.960546902111148904, -0.215244770050048828, INEXACT));
assert(test_atan2(9.26705696697258574, 4.81139208435979615, 1.09191239461421086, 0.389444321393966675, INEXACT));
assert(test_atan2(-6.45004555606023633, 0.662071792337673881, -1.46850850061642402, -0.448591411113739014, INEXACT));
assert(test_atan2(7.85889025304169664, 0.0521545267500622481, 1.5641600512601268, 0.378484278917312622, INEXACT));
assert(test_atan2(-0.792054511984895959, 7.67640268511753998, -0.102816589106785081, -0.139932602643966675, INEXACT));
assert(test_atan2(0.615702673197924044, 2.01190257903248026, 0.296979740044935159, 0.44753071665763855, INEXACT));
assert(test_atan2(-0.558758682360915193, 0.0322398306026380407, -1.51316120533039156, 0.397088766098022461, INEXACT));

// special
assert(test_atan2(0.0, 0.0, 0.0, 0.0, 0));
assert(test_atan2(0.0, -0.0, 3.14159265358979312, -0.275765955448150635, INEXACT));
assert(test_atan2(0.0, -1.0, 3.14159265358979312, -0.275765955448150635, INEXACT));
assert(test_atan2(0.0, -Infinity, 3.14159265358979312, -0.275765955448150635, INEXACT));
assert(test_atan2(0.0, 1.0, 0.0, 0.0, 0));
assert(test_atan2(0.0, Infinity, 0.0, 0.0, 0));
assert(test_atan2(-0.0, 0.0, -0.0, 0.0, 0));
assert(test_atan2(-0.0, -0.0, -3.14159265358979312, 0.275765955448150635, INEXACT));
assert(test_atan2(-0.0, -1.0, -3.14159265358979312, 0.275765955448150635, INEXACT));
assert(test_atan2(-0.0, -Infinity, -3.14159265358979312, 0.275765955448150635, INEXACT));
assert(test_atan2(-0.0, 1.0, -0.0, 0.0, 0));
assert(test_atan2(-0.0, Infinity, -0.0, 0.0, 0));
assert(test_atan2(-1.0, 0.0, -1.57079632679489656, 0.275765955448150635, INEXACT));
assert(test_atan2(-1.0, -0.0, -1.57079632679489656, 0.275765955448150635, INEXACT));
assert(test_atan2(1.0, 0.0, 1.57079632679489656, -0.275765955448150635, INEXACT));
assert(test_atan2(1.0, -0.0, 1.57079632679489656, -0.275765955448150635, INEXACT));
assert(test_atan2(-1.0, Infinity, -0.0, 0.0, 0));
assert(test_atan2(1.0, Infinity, 0.0, 0.0, 0));
assert(test_atan2(-1.0, -Infinity, -3.14159265358979312, 0.275765955448150635, INEXACT));
assert(test_atan2(1.0, -Infinity, 3.14159265358979312, -0.275765955448150635, INEXACT));
assert(test_atan2(Infinity, 0.0, 1.57079632679489656, -0.275765955448150635, INEXACT));
assert(test_atan2(-Infinity, 0.0, -1.57079632679489656, 0.275765955448150635, INEXACT));
assert(test_atan2(Infinity, Infinity, 0.785398163397448279, -0.275765955448150635, INEXACT));
assert(test_atan2(Infinity, -Infinity, 2.35619449019234484, -0.206824451684951782, INEXACT));
assert(test_atan2(-Infinity, Infinity, -0.785398163397448279, 0.275765955448150635, INEXACT));
assert(test_atan2(-Infinity, -Infinity, -2.35619449019234484, 0.206824451684951782, INEXACT));
assert(test_atan2(1.11253692925360069e-308, 1.0, 1.11253692925360069e-308, 0.0, INEXACT | UNDERFLOW));
assert(test_atan2(1.0, 8.98846567431157954e+307, 1.11253692925360069e-308, 0.0, INEXACT | UNDERFLOW));
assert(test_atan2(1.5, 8.98846567431157954e+307, 1.66880539388040104e-308, 0.0, INEXACT | UNDERFLOW));
assert(test_atan2(1.5, -8.98846567431157954e+307, 3.14159265358979312, 0.0, INEXACT));

// Mathf.atan2 /////////////////////////////////////////////////////////////////////////////////////

function test_atan2f(value1: f32, value2: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.atan2(value1, value2), expected, error, flags);
}

// sanity
assert(test_atan2f(-8.066848755, 4.535662651, -1.058589578, -0.2235258818, INEXACT));
assert(test_atan2f(4.345239639, -8.887990952, 2.686873436, 0.09464472532, INEXACT));
assert(test_atan2f(-8.381433487, -2.763607264, -1.889300108, -0.2194190174, INEXACT));
assert(test_atan2f(-6.531673431, 4.5675354, -0.9605468512, 0.4601557553, INEXACT));
assert(test_atan2f(9.267057419, 4.811392307, 1.091912389, -0.05708503723, INEXACT));
assert(test_atan2f(-6.450045586, 0.6620717645, -1.468508482, 0.1961120665, INEXACT));
assert(test_atan2f(7.858890057, 0.05215452611, 1.564160109, 0.4814318717, INEXACT));
assert(test_atan2f(-0.792054534, 7.676402569, -0.1028165966, -0.4216274917, INEXACT));
assert(test_atan2f(0.6157026887, 2.011902571, 0.2969797552, 0.2322007567, INEXACT));
assert(test_atan2f(-0.5587586761, 0.03223983198, -1.513161182, 0.1662072688, INEXACT));

// special
assert(test_atan2f(0.0, 0.0, 0.0, 0.0, 0));
assert(test_atan2f(0.0, -0.0, 3.141592741, 0.3666777015, INEXACT));
assert(test_atan2f(0.0, -1.0, 3.141592741, 0.3666777015, INEXACT));
assert(test_atan2f(0.0, -Infinity, 3.141592741, 0.3666777015, INEXACT));
assert(test_atan2f(0.0, 1.0, 0.0, 0.0, 0));
assert(test_atan2f(0.0, Infinity, 0.0, 0.0, 0));
assert(test_atan2f(-0.0, 0.0, -0.0, 0.0, 0));
assert(test_atan2f(-0.0, -0.0, -3.141592741, -0.3666777015, INEXACT));
assert(test_atan2f(-0.0, -1.0, -3.141592741, -0.3666777015, INEXACT));
assert(test_atan2f(-0.0, -Infinity, -3.141592741, -0.3666777015, INEXACT));
assert(test_atan2f(-0.0, 1.0, -0.0, 0.0, 0));
assert(test_atan2f(-0.0, Infinity, -0.0, 0.0, 0));
assert(test_atan2f(-1.0, 0.0, -1.570796371, -0.3666777015, INEXACT));
assert(test_atan2f(-1.0, -0.0, -1.570796371, -0.3666777015, INEXACT));
assert(test_atan2f(1.0, 0.0, 1.570796371, 0.3666777015, INEXACT));
assert(test_atan2f(1.0, -0.0, 1.570796371, 0.3666777015, INEXACT));
assert(test_atan2f(-1.0, Infinity, -0.0, 0.0, 0));
assert(test_atan2f(1.0, Infinity, 0.0, 0.0, 0));
assert(test_atan2f(-1.0, -Infinity, -3.141592741, -0.3666777015, INEXACT));
assert(test_atan2f(1.0, -Infinity, 3.141592741, 0.3666777015, INEXACT));
assert(test_atan2f(Infinity, 0.0, 1.570796371, 0.3666777015, INEXACT));
assert(test_atan2f(-Infinity, 0.0, -1.570796371, -0.3666777015, INEXACT));
assert(test_atan2f(Infinity, Infinity, 0.7853981853, 0.3666777015, INEXACT));
assert(test_atan2f(Infinity, -Infinity, 2.356194496, 0.02500828728, INEXACT));
assert(test_atan2f(-Infinity, Infinity, -0.7853981853, -0.3666777015, INEXACT));
assert(test_atan2f(-Infinity, -Infinity, -2.356194496, -0.02500828728, INEXACT));
assert(test_atan2f(5.877471754e-39, 1.0, 5.877471754e-39, 0.0, INEXACT | UNDERFLOW));
assert(test_atan2f(1.0, 1.701411835e+38, 5.877471754e-39, 0.0, INEXACT | UNDERFLOW));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.cbrt
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_cbrt(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.cbrt(value), expected, error, flags) &&
  (!js || check<f64>(    JSMath.cbrt(value), expected, error, flags));
}

// sanity
assert(test_cbrt(-8.06684839057968084, -2.00555525450202454, 0.466679513454437256, INEXACT));
assert(test_cbrt(4.34523984933830487, 1.63181624105156353, -0.0816027149558067322, INEXACT));
assert(test_cbrt(-8.38143342755524934, -2.03129391067336096, -0.048101816326379776, INEXACT));
assert(test_cbrt(-6.53167358191348413, -1.86928200122049248, 0.0862401872873306274, INEXACT));
assert(test_cbrt(9.26705696697258574, 2.10045772085970217, -0.272298902273178101, INEXACT));
assert(test_cbrt(0.661985898099504477, 0.87153114704559731, 0.441491812467575073, INEXACT));
assert(test_cbrt(-0.40660392238535531, -0.740839030300223023, 0.016453813761472702, INEXACT));
assert(test_cbrt(0.56175974622072411, 0.82511954005592858, 0.306806385517120361, INEXACT));
assert(test_cbrt(0.77415229659130369, 0.918210247895991372, 0.0654399842023849487, INEXACT));
assert(test_cbrt(-0.678763702639402444, -0.878832690658009397, -0.201671317219734192, INEXACT));

// special
assert(test_cbrt(NaN, NaN, 0.0, 0));
assert(test_cbrt(Infinity, Infinity, 0.0, 0));
assert(test_cbrt(-Infinity, -Infinity, 0.0, 0));
assert(test_cbrt(0.0, 0.0, 0.0, 0));
assert(test_cbrt(-0.0, -0.0, 0.0, 0));
assert(test_cbrt(9.31322574615478516e-10, 0.0009765625, 0.0, 0));
assert(test_cbrt(-9.31322574615478516e-10, -0.0009765625, 0.0, 0));
assert(test_cbrt(1.0, 1.0, 0.0, 0));
assert(test_cbrt(-1.0, -1.0, 0.0, 0));
assert(test_cbrt(8.0, 2.0, 0.0, 0));

// Mathf.cbrt //////////////////////////////////////////////////////////////////////////////////////

function test_cbrtf(value: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.cbrt(value), expected, error, flags);
}

// sanity
assert(test_cbrtf(-8.066848755, -2.005555391, -0.4471924007, INEXACT));
assert(test_cbrtf(4.345239639, 1.631816268, 0.4463625252, INEXACT));
assert(test_cbrtf(-8.381433487, -2.031293869, 0.1948342621, INEXACT));
assert(test_cbrtf(-6.531673431, -1.869282007, -0.1707551479, INEXACT));
assert(test_cbrtf(9.267057419, 2.100457668, -0.3636204302, INEXACT));
assert(test_cbrtf(0.6619858742, 0.8715311289, -0.1285720915, INEXACT));
assert(test_cbrtf(-0.4066039324, -0.7408390641, -0.4655757546, INEXACT));
assert(test_cbrtf(0.5617597699, 0.825119555, 0.05601907894, INEXACT));
assert(test_cbrtf(0.7741522789, 0.918210268, 0.4549820423, INEXACT));
assert(test_cbrtf(-0.6787636876, -0.8788326979, -0.2297896743, INEXACT));

// special
assert(test_cbrtf(NaN, NaN, 0.0, 0));
assert(test_cbrtf(Infinity, Infinity, 0.0, 0));
assert(test_cbrtf(-Infinity, -Infinity, 0.0, 0));
assert(test_cbrtf(0.0, 0.0, 0.0, 0));
assert(test_cbrtf(-0.0, -0.0, 0.0, 0));
assert(test_cbrtf(9.313225746e-10, 0.0009765625, 0.0, 0));
assert(test_cbrtf(-9.313225746e-10, -0.0009765625, 0.0, 0));
assert(test_cbrtf(1.0, 1.0, 0.0, 0));
assert(test_cbrtf(-1.0, -1.0, 0.0, 0));
assert(test_cbrtf(8.0, 2.0, 0.0, 0));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.ceil
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_ceil(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.ceil(value), expected, error, flags) &&
  (!js || check<f64>(    JSMath.ceil(value), expected, error, flags));
}

// sanity
assert(test_ceil(-8.06684839057968084, -8.0, 0.0, INEXACT));
assert(test_ceil(4.34523984933830487, 5.0, 0.0, INEXACT));
assert(test_ceil(-8.38143342755524934, -8.0, 0.0, INEXACT));
assert(test_ceil(-6.53167358191348413, -6.0, 0.0, INEXACT));
assert(test_ceil(9.26705696697258574, 10.0, 0.0, INEXACT));
assert(test_ceil(0.661985898099504477, 1.0, 0.0, INEXACT));
assert(test_ceil(-0.40660392238535531, -0.0, 0.0, INEXACT));
assert(test_ceil(0.56175974622072411, 1.0, 0.0, INEXACT));
assert(test_ceil(0.77415229659130369, 1.0, 0.0, INEXACT));
assert(test_ceil(-0.678763702639402444, -0.0, 0.0, INEXACT));

// special
assert(test_ceil(NaN, NaN, 0.0, 0));
assert(test_ceil(Infinity, Infinity, 0.0, 0));
assert(test_ceil(-Infinity, -Infinity, 0.0, 0));
assert(test_ceil(0.0, 0.0, 0.0, 0));
assert(test_ceil(-0.0, -0.0, 0.0, 0));
assert(test_ceil(1.0, 1.0, 0.0, 0));
assert(test_ceil(-1.0, -1.0, 0.0, 0));
assert(test_ceil(0.5, 1.0, 0.0, INEXACT));
assert(test_ceil(-0.5, -0.0, 0.0, INEXACT));
assert(test_ceil(1.0000152587890625, 2.0, 0.0, INEXACT));
assert(test_ceil(-1.0000152587890625, -1.0, 0.0, INEXACT));
assert(test_ceil(0.99999237060546875, 1.0, 0.0, INEXACT));
assert(test_ceil(-0.99999237060546875, -0.0, 0.0, INEXACT));
assert(test_ceil(7.88860905221011805e-31, 1.0, 0.0, INEXACT));
assert(test_ceil(-7.88860905221011805e-31, -0.0, 0.0, INEXACT));
assert(test_ceil(NaN, NaN, 0.0, 0));
assert(test_ceil(Infinity, Infinity, 0.0, 0));
assert(test_ceil(-Infinity, -Infinity, 0.0, 0));
assert(test_ceil(0.0, 0.0, 0.0, 0));
assert(test_ceil(-0.0, -0.0, 0.0, 0));
assert(test_ceil(1.0, 1.0, 0.0, 0));
assert(test_ceil(-1.0, -1.0, 0.0, 0));
assert(test_ceil(0.5, 1.0, 0.0, INEXACT));
assert(test_ceil(-0.5, -0.0, 0.0, INEXACT));
assert(test_ceil(1.0000152587890625, 2.0, 0.0, INEXACT));
assert(test_ceil(-1.0000152587890625, -1.0, 0.0, INEXACT));
assert(test_ceil(0.99999237060546875, 1.0, 0.0, INEXACT));
assert(test_ceil(-0.99999237060546875, -0.0, 0.0, INEXACT));
assert(test_ceil(7.88860905221011805e-31, 1.0, 0.0, INEXACT));
assert(test_ceil(-7.88860905221011805e-31, -0.0, 0.0, INEXACT));
assert(test_ceil(NaN, NaN, 0.0, 0));
assert(test_ceil(Infinity, Infinity, 0.0, 0));
assert(test_ceil(-Infinity, -Infinity, 0.0, 0));
assert(test_ceil(0.0, 0.0, 0.0, 0));
assert(test_ceil(-0.0, -0.0, 0.0, 0));
assert(test_ceil(1.0, 1.0, 0.0, 0));
assert(test_ceil(-1.0, -1.0, 0.0, 0));
assert(test_ceil(0.5, 1.0, 0.0, INEXACT));
assert(test_ceil(-0.5, -0.0, 0.0, INEXACT));
assert(test_ceil(1.0000152587890625, 2.0, 0.0, INEXACT));
assert(test_ceil(-1.0000152587890625, -1.0, 0.0, INEXACT));
assert(test_ceil(0.99999237060546875, 1.0, 0.0, INEXACT));
assert(test_ceil(-0.99999237060546875, -0.0, 0.0, INEXACT));
assert(test_ceil(7.88860905221011805e-31, 1.0, 0.0, INEXACT));
assert(test_ceil(-7.88860905221011805e-31, -0.0, 0.0, INEXACT));

// Mathf.ceil //////////////////////////////////////////////////////////////////////////////////////

function test_ceilf(value: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.ceil(value), expected, error, flags);
}

// sanity
assert(test_ceilf(-8.066848755, -8.0, 0.0, INEXACT));
assert(test_ceilf(4.345239639, 5.0, 0.0, INEXACT));
assert(test_ceilf(-8.381433487, -8.0, 0.0, INEXACT));
assert(test_ceilf(-6.531673431, -6.0, 0.0, INEXACT));
assert(test_ceilf(9.267057419, 10.0, 0.0, INEXACT));
assert(test_ceilf(0.6619858742, 1.0, 0.0, INEXACT));
assert(test_ceilf(-0.4066039324, -0.0, 0.0, INEXACT));
assert(test_ceilf(0.5617597699, 1.0, 0.0, INEXACT));
assert(test_ceilf(0.7741522789, 1.0, 0.0, INEXACT));
assert(test_ceilf(-0.6787636876, -0.0, 0.0, INEXACT));

// special
assert(test_ceilf(NaN, NaN, 0.0, 0));
assert(test_ceilf(Infinity, Infinity, 0.0, 0));
assert(test_ceilf(-Infinity, -Infinity, 0.0, 0));
assert(test_ceilf(0.0, 0.0, 0.0, 0));
assert(test_ceilf(-0.0, -0.0, 0.0, 0));
assert(test_ceilf(1.0, 1.0, 0.0, 0));
assert(test_ceilf(-1.0, -1.0, 0.0, 0));
assert(test_ceilf(0.5, 1.0, 0.0, INEXACT));
assert(test_ceilf(-0.5, -0.0, 0.0, INEXACT));
assert(test_ceilf(1.000015259, 2.0, 0.0, INEXACT));
assert(test_ceilf(-1.000015259, -1.0, 0.0, INEXACT));
assert(test_ceilf(0.9999923706, 1.0, 0.0, INEXACT));
assert(test_ceilf(-0.9999923706, -0.0, 0.0, INEXACT));
assert(test_ceilf(7.888609052e-31, 1.0, 0.0, INEXACT));
assert(test_ceilf(-7.888609052e-31, -0.0, 0.0, INEXACT));
assert(test_ceilf(NaN, NaN, 0.0, 0));
assert(test_ceilf(Infinity, Infinity, 0.0, 0));
assert(test_ceilf(-Infinity, -Infinity, 0.0, 0));
assert(test_ceilf(0.0, 0.0, 0.0, 0));
assert(test_ceilf(-0.0, -0.0, 0.0, 0));
assert(test_ceilf(1.0, 1.0, 0.0, 0));
assert(test_ceilf(-1.0, -1.0, 0.0, 0));
assert(test_ceilf(0.5, 1.0, 0.0, INEXACT));
assert(test_ceilf(-0.5, -0.0, 0.0, INEXACT));
assert(test_ceilf(1.000015259, 2.0, 0.0, INEXACT));
assert(test_ceilf(-1.000015259, -1.0, 0.0, INEXACT));
assert(test_ceilf(0.9999923706, 1.0, 0.0, INEXACT));
assert(test_ceilf(-0.9999923706, -0.0, 0.0, INEXACT));
assert(test_ceilf(7.888609052e-31, 1.0, 0.0, INEXACT));
assert(test_ceilf(-7.888609052e-31, -0.0, 0.0, INEXACT));
assert(test_ceilf(NaN, NaN, 0.0, 0));
assert(test_ceilf(Infinity, Infinity, 0.0, 0));
assert(test_ceilf(-Infinity, -Infinity, 0.0, 0));
assert(test_ceilf(0.0, 0.0, 0.0, 0));
assert(test_ceilf(-0.0, -0.0, 0.0, 0));
assert(test_ceilf(1.0, 1.0, 0.0, 0));
assert(test_ceilf(-1.0, -1.0, 0.0, 0));
assert(test_ceilf(0.5, 1.0, 0.0, INEXACT));
assert(test_ceilf(-0.5, -0.0, 0.0, INEXACT));
assert(test_ceilf(1.000015259, 2.0, 0.0, INEXACT));
assert(test_ceilf(-1.000015259, -1.0, 0.0, INEXACT));
assert(test_ceilf(0.9999923706, 1.0, 0.0, INEXACT));
assert(test_ceilf(-0.9999923706, -0.0, 0.0, INEXACT));
assert(test_ceilf(7.888609052e-31, 1.0, 0.0, INEXACT));
assert(test_ceilf(-7.888609052e-31, -0.0, 0.0, INEXACT));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.cos
////////////////////////////////////////////////////////////////////////////////////////////////////
function test_cos(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.cos(value), expected, error, flags) &&
  (!js || check<f64>(    JSMath.cos(value), expected, error, flags));
}

// sanity
assert(test_cos(-8.066848390579680840, -0.211262815998871367, -0.1096246913075447080, INEXACT));
assert(test_cos( 4.345239849338304870, -0.358956022975789546, -0.1075982823967933650, INEXACT));
assert(test_cos(-8.381433427555249340, -0.503333091765515994, -0.0214304737746715546, INEXACT));
assert(test_cos(-6.531673581913484130,  0.969285321250328291, -0.4787876307964324950, INEXACT));
assert(test_cos( 9.267056966972585740, -0.987587806478862684,  0.4880668818950653080, INEXACT));
assert(test_cos( 0.661985898099504477,  0.788773086924857592,  0.1270866692066192630, INEXACT));
assert(test_cos(-0.406603922385355310,  0.918469239700729356, -0.2612071335315704350, INEXACT));
assert(test_cos( 0.561759746220724110,  0.846319046741589642, -0.3025861680507659910, INEXACT));
assert(test_cos( 0.774152296591303690,  0.715013928995238301, -0.0853774622082710266, INEXACT));
assert(test_cos(-0.678763702639402444,  0.778349499475744722,  0.3089075088500976560, INEXACT));

// special
assert(test_cos(      0.0, 1.0, 0.0, 0));
assert(test_cos(     -0.0, 1.0, 0.0, 0));
assert(test_cos( Infinity, NaN, 0.0, INVALID));
assert(test_cos(-Infinity, NaN, 0.0, INVALID));
assert(test_cos(      NaN, NaN, 0.0, 0));
assert(test_cos(1.000000000000000000,  0.540302305868139765,  0.428828656673431396, INEXACT));
assert(test_cos(2.000000000000000000, -0.416146836547142407, -0.358593970537185669, INEXACT));
assert(test_cos(3.000000000000000000, -0.989992496600445415,  0.378845155239105225, INEXACT));
assert(test_cos(4.000000000000000000, -0.653643620863611940, -0.232805609703063965, INEXACT));
assert(test_cos(5.000000000000000000,  0.283662185463226246, -0.327735781669616699, INEXACT));
assert(test_cos(0.100000000000000006,  0.995004165278025821,  0.495585262775421143, INEXACT));
assert(test_cos(0.200000000000000011,  0.980066577841241626, -0.024076409637928009, INEXACT));
assert(test_cos(0.299999999999999989,  0.955336489125605981, -0.377722293138504028, INEXACT));
assert(test_cos(0.400000000000000022,  0.921060994002885103,  0.258184850215911865, INEXACT));
assert(test_cos(0.500000000000000000,  0.877582561890372759,  0.383915215730667114, INEXACT));
assert(test_cos( 2.36414097466390147e-308,              1.0,                   0.0, INEXACT));
assert(test_cos( 1.18207048733195073e-308,              1.0,                   0.0, INEXACT));
assert(test_cos( 4.94065645841246544e-324,              1.0,                   0.0, INEXACT));
assert(test_cos(-4.94065645841246544e-324,              1.0,                   0.0, INEXACT));
assert(test_cos(-3.14000000000000012, -0.999998731727539503,  0.385551601648330688, INEXACT));
assert(test_cos( 8.98846567431157954e+307, -0.826369834614148036, -0.369596511125564575, INEXACT));
assert(test_cos( 1.79769313486231571e+308, -0.999987689426559911,  0.234483435750007629, INEXACT));
assert(test_cos(-8.98846567431157954e+307, -0.826369834614148036, -0.369596511125564575, INEXACT));
assert(test_cos(3.140000000000000120, -0.999998731727539503,  0.385551601648330688000, INEXACT));
assert(test_cos(3.141500000000000180, -0.999999995707656186, -0.306089758872985840000, INEXACT));
assert(test_cos(3.141592000000000160, -0.999999999999786393,  0.154033288359642029000, INEXACT));
assert(test_cos(3.141592650000000210,                  -1.0, -0.029018074274063110400, INEXACT));
assert(test_cos(3.141592653500000050,                  -1.0, -0.000018155848010792397, INEXACT));
assert(test_cos(3.141592653588999970,                  -1.0, -1.41699141309459264e-09, INEXACT));
assert(test_cos(3.141592653589790010,                  -1.0, -2.35086489798518386e-14, INEXACT));
assert(test_cos(3.141592653589793120,                  -1.0, -3.37715874188331791e-17, INEXACT));
assert(test_cos(1.570000000000000060,  0.000796326710733263345,  0.296815931797027588, INEXACT));
assert(test_cos(1.570796000000000080,  3.26794896538138351e-07, -0.325708955526351929, INEXACT));
assert(test_cos(1.570796326700000020,  9.48965963067801342e-11, -0.272456467151641846, INEXACT));
assert(test_cos(1.570796326794889900,  6.72257048770830682e-15, -0.107476837933063507, INEXACT));
assert(test_cos(1.570796326794896560,  6.12323399573676604e-17,  0.121482297778129578, INEXACT));
assert(test_cos(0.670063519948610575,  0.783782219301615846, -0.07278502732515335080, INEXACT));
assert(test_cos(0.534389018943755345,  0.860579971903951746, -0.48434028029441833500, INEXACT));
assert(test_cos(0.439997027548900854,  0.904752929300197573,  0.02977747283875942230, INEXACT));
assert(test_cos(0.990284084468731285,  0.548452336448076783,  0.19765280187129974400, INEXACT));
assert(test_cos(0.453814475343389145,  0.898781390226378263, -0.01772486604750156400, INEXACT));
assert(test_cos(0.460988881358358915,  0.895613047471305657,  0.36449819803237915000, INEXACT));
assert(test_cos(0.928543409795642205,  0.599000979429298419, -0.28994163870811462400, INEXACT));
assert(test_cos(0.910909212448835159,  0.613027669277437792, -0.49353134632110595700, INEXACT));
assert(test_cos(0.832860065035955555,  0.672762471004635709, -0.36606088280677795400, INEXACT));
assert(test_cos(0.953620125220343340,  0.578734618348708429, -0.17089833319187164300, INEXACT));
assert(test_cos(0.872659006545769889,  0.642791914425904665, -0.27449861168861389200, INEXACT));
assert(test_cos(0.181004475359684475,  0.983663365688489333,  0.00301952729932963848, INEXACT));
assert(test_cos(2.356194490349838850, -0.707106781297912601, -0.482787460088729858, INEXACT));
assert(test_cos(2.356194490372272020, -0.707106781313775246, -0.486605018377304077, INEXACT));
assert(test_cos(2.356194490225111520, -0.707106781209717039, -0.353395223617553711, INEXACT));
assert(test_cos(2.356194490314999610, -0.707106781273277529, -0.419119864702224731, INEXACT));
assert(test_cos(2.356194490360352670, -0.707106781305346987, -0.470620006322860718, INEXACT));
assert(test_cos(2.356194490382619740, -0.707106781321092170, -0.306183516979217529, INEXACT));
assert(test_cos(2.356194490371803060, -0.707106781313443622, -0.305648207664489746, INEXACT));
assert(test_cos(2.356194490399930790, -0.707106781333332934, -0.388455718755722046, INEXACT));
assert(test_cos(2.356194490260191010, -0.707106781234521975, -0.237968519330024719, INEXACT));
assert(test_cos(2.356194490404315280, -0.707106781336433232, -0.327458947896957397, INEXACT));
assert(test_cos(2.094395102475944630, -0.500000000071662898, -0.417113423347473145, INEXACT));
assert(test_cos(2.094395102433240120, -0.500000000034679704, -0.356616497039794922, INEXACT));
assert(test_cos(2.094395102513388450, -0.500000000104090181, -0.225348591804504395, INEXACT));
assert(test_cos(2.094395102546670720, -0.500000000132913458, -0.129822596907615662, INEXACT));
assert(test_cos(2.094395102413896040, -0.500000000017927215, -0.158867642283439636, INEXACT));
assert(test_cos(2.094395102422340390, -0.500000000025240254, -0.266656756401062012, INEXACT));
assert(test_cos(2.094395102496047660, -0.500000000089072638, -0.465207785367965698, INEXACT));
assert(test_cos(2.094395102517331520, -0.500000000107505005, -0.467109948396682739, INEXACT));
assert(test_cos(2.094395102405924190, -0.500000000011023404, -0.246960371732711792, INEXACT));
assert(test_cos(2.094395102428558090, -0.500000000030624947, -0.379944115877151489, INEXACT));
assert(test_cos(8.513210770864056090, -0.612507693998775915,  0.498996615409851074, INEXACT));
assert(test_cos(6.802886129801017030,  0.867967796134545222,  0.497216552495956421, INEXACT));
assert(test_cos(9.171925393086407750, -0.968202744042454433, -0.498275846242904663, INEXACT));
assert(test_cos(8.854690112888572880, -0.841853566381852714,  0.497497975826263428, INEXACT));
assert(test_cos(9.213510813859608460, -0.977765980283850644, -0.499560445547103882, INEXACT));
assert(test_cos(7.782449081542151430,  0.0714715638129333891, 0.498581260442733765, INEXACT));
assert(test_cos(7.500261332273615800,  0.346390176334581135, -0.499621003866195679, INEXACT));
assert(test_cos(9.121739418731587890, -0.954434129754181071,  0.498281508684158325, INEXACT));
assert(test_cos(6.784954020476315680,  0.876733223316664589, -0.498808383941650391, INEXACT));
assert(test_cos(8.770846542666664190, -0.793698411740070497,  0.499968290328979492, INEXACT));

// ucb
assert(test_cos( 9.313225746154785156e-010,                      1.0,  1.953125000000000000e-03, INEXACT));
assert(test_cos(-9.313225746154785156e-010,                      1.0,  1.953125000000000000e-03, INEXACT));
assert(test_cos( 2.225073858507201383e-308,                      1.0,                       0.0, INEXACT));
assert(test_cos(-2.225073858507201383e-308,                      1.0,                       0.0, INEXACT));
assert(test_cos( 4.940656458412465442e-324,                      1.0,                       0.0, INEXACT));
assert(test_cos(-4.940656458412465442e-324,                      1.0,                       0.0, INEXACT));
assert(test_cos(                       0.0,                      1.0,                       0.0, 0));
assert(test_cos(                      -0.0,                      1.0,                       0.0, 0));
assert(test_cos( 9.881312916824930884e-324,                      1.0,                       0.0, INEXACT));
assert(test_cos( 4.446590812571218898e-323,                      1.0,                       0.0, INEXACT));
assert(test_cos( 5.562684646268003458e-309,                      1.0,                       0.0, INEXACT));
assert(test_cos( 1.112536929253600692e-308,                      1.0,                       0.0, INEXACT));
assert(test_cos( 2.225073858507200395e-308,                      1.0,                       0.0, INEXACT));
assert(test_cos( 2.225073858507200889e-308,                      1.0,                       0.0, INEXACT));
assert(test_cos( 2.225073858507201877e-308,                      1.0,                       0.0, INEXACT));
assert(test_cos( 2.225073858507202371e-308,                      1.0,                       0.0, INEXACT));
assert(test_cos( 4.450147717014400296e-308,                      1.0,                       0.0, INEXACT));
assert(test_cos( 4.450147717014402766e-308,                      1.0,                       0.0, INEXACT));
assert(test_cos( 4.450147717014405731e-308,                      1.0,                       0.0, INEXACT));
assert(test_cos( 8.900295434028805532e-308,                      1.0,                       0.0, INEXACT));
assert(test_cos( 7.450580596923828125e-009,                      1.0,  1.250000000000000000e-01, INEXACT));
assert(test_cos( 1.490116119384765625e-008, 9.999999999999998890e-01, -1.850372590034580957e-17, INEXACT));
assert(test_cos( 4.470348358154296875e-008, 9.999999999999990008e-01, -1.498801083243961330e-15, INEXACT));
assert(test_cos(-9.881312916824930884e-324,                      1.0,                       0.0, INEXACT));
assert(test_cos(-4.446590812571218898e-323,                      1.0,                       0.0, INEXACT));
assert(test_cos(-5.562684646268003458e-309,                      1.0,                       0.0, INEXACT));
assert(test_cos(-1.112536929253600692e-308,                      1.0,                       0.0, INEXACT));
assert(test_cos(-2.225073858507200395e-308,                      1.0,                       0.0, INEXACT));
assert(test_cos(-2.225073858507200889e-308,                      1.0,                       0.0, INEXACT));
assert(test_cos(-2.225073858507201877e-308,                      1.0,                       0.0, INEXACT));
assert(test_cos(-2.225073858507202371e-308,                      1.0,                       0.0, INEXACT));
assert(test_cos(-4.450147717014400296e-308,                      1.0,                       0.0, INEXACT));
assert(test_cos(-4.450147717014402766e-308,                      1.0,                       0.0, INEXACT));
assert(test_cos(-4.450147717014405731e-308,                      1.0,                       0.0, INEXACT));
assert(test_cos(-8.900295434028805532e-308,                      1.0,                       0.0, INEXACT));
assert(test_cos(-7.450580596923828125e-009,                      1.0,  1.250000000000000000e-01, INEXACT));
assert(test_cos(-1.490116119384765625e-008, 9.999999999999998890e-01, -1.850372590034580957e-17, INEXACT));
assert(test_cos(-4.470348358154296875e-008, 9.999999999999990008e-01, -1.498801083243961330e-15, INEXACT));

assert(NativeMath.cos(kPI / 2) == JSMath.cos(kPI / 2));
assert(NativeMath.cos(2 * kPI / 2) == JSMath.cos(2 * kPI / 2));
assert(NativeMath.cos(1e90 * kPI) == JSMath.cos(1e90 * kPI));

// v8 ieee754-unittest.cc
// cos(x) = 1 for |x| < 2^-27
assert(NativeMath.cos(2.3283064365386963e-10) == 1.0);
assert(NativeMath.cos(-2.3283064365386963e-10) == 1.0);
// Test KERNELCOS for |x| < 0.3.
// cos(pi/20) = sqrt(sqrt(2)*sqrt(sqrt(5)+5)+4)/2^(3/2)
assert(NativeMath.cos(0.15707963267948966) == 0.9876883405951378);
// Test KERNELCOS for x ~= 0.78125
assert(NativeMath.cos(0.7812504768371582) == 0.7100335477927638);
assert(NativeMath.cos(0.78125) == 0.7100338835660797);
// Test KERNELCOS for |x| > 0.3.
// cos(pi/8) = sqrt(sqrt(2)+1)/2^(3/4)
assert(0.9238795325112867 == NativeMath.cos(0.39269908169872414));
// Test KERNELTAN for |x| < 0.67434.
assert(0.9238795325112867 == NativeMath.cos(-0.39269908169872414));

// Tests for cos.
assert(NativeMath.cos(3.725290298461914e-9) == 1.0);
// Cover different code paths in KERNELCOS.
assert(0.9689124217106447 == NativeMath.cos(0.25));
assert(0.8775825618903728 == NativeMath.cos(0.5));
assert(0.7073882691671998 == NativeMath.cos(0.785));
// Test that cos(Math.PI/2) != 0 since Math.PI is not exact.
assert(6.123233995736766e-17 == NativeMath.cos(1.5707963267948966));
// Test cos for various phases.
assert(0.7071067811865474 == NativeMath.cos(7.0 / 4 * kPI));
assert(0.7071067811865477 == NativeMath.cos(9.0 / 4 * kPI));
assert(-0.7071067811865467 == NativeMath.cos(11.0 / 4 * kPI));
assert(-0.7071067811865471 == NativeMath.cos(13.0 / 4 * kPI));
assert(0.9367521275331447 == NativeMath.cos(1000000.0));
assert(-3.435757038074824e-12 == NativeMath.cos(1048575.0 / 2 * kPI));

// Mathf.cos ///////////////////////////////////////////////////////////////////////////////////////

function test_cosf(value: f32, expected: f32, error: f32, flags: i32): bool {
  return  check<f32>(NativeMathf.cos(value), expected, error, flags);
}

// sanity
assert(test_cosf(-8.066848754882812500,-0.211263164877891541, 0.4832856953144073490, INEXACT));
assert(test_cosf( 4.345239639282226560,-0.358956217765808105, 0.0425052084028720856, INEXACT));
assert(test_cosf(-8.381433486938476560,-0.503333151340484619,-0.1386195719242095950, INEXACT));
assert(test_cosf(-6.531673431396484380, 0.969285368919372559, 0.1786951720714569090, INEXACT));
assert(test_cosf( 9.267057418823242190,-0.987587869167327881, 0.1389600932598114010, INEXACT));
assert(test_cosf( 0.661985874176025391, 0.788773119449615479, 0.2989593744277954100, INEXACT));
assert(test_cosf(-0.406603932380676270, 0.918469250202178955, 0.2425066530704498290, INEXACT));
assert(test_cosf( 0.561759769916534424, 0.846319019794464111,-0.2403324097394943240, INEXACT));
assert(test_cosf( 0.774152278900146484, 0.715013921260833740,-0.3372635245323181150, INEXACT));
assert(test_cosf(-0.678763687610626221, 0.778349518775939941, 0.1655015349388122560, INEXACT));

// special
assert(test_cosf(      0.0, 1.0, 0.0, 0));
assert(test_cosf(     -0.0, 1.0, 0.0, 0));
assert(test_cosf( Infinity, NaN, 0.0, INVALID));
assert(test_cosf(-Infinity, NaN, 0.0, INVALID));
assert(test_cosf(      NaN, NaN, 0.0, 0));

// ubc
assert(test_cosf( 1.862645149e-09,             1.0, 1.455191523e-11, INEXACT));
assert(test_cosf(-1.862645149e-09,             1.0, 1.455191523e-11, INEXACT));
assert(test_cosf( 1.175494351e-38,             1.0,             0.0, INEXACT));
assert(test_cosf(-1.175494351e-38,             1.0,             0.0, INEXACT));
assert(test_cosf( 1.401298464e-45,             1.0,             0.0, INEXACT));
assert(test_cosf(-1.401298464e-45,             1.0,             0.0, INEXACT));
assert(test_cosf( 2.802596929e-45,             1.0,             0.0, INEXACT));
assert(test_cosf( 1.261168618e-44,             1.0,             0.0, INEXACT));
assert(test_cosf( 2.938735877e-39,             1.0,             0.0, INEXACT));
assert(test_cosf( 5.877471754e-39,             1.0,             0.0, INEXACT));
assert(test_cosf( 1.175494071e-38,             1.0,             0.0, INEXACT));
assert(test_cosf( 1.175494211e-38,             1.0,             0.0, INEXACT));
assert(test_cosf( 1.175494491e-38,             1.0,             0.0, INEXACT));
assert(test_cosf( 1.175494631e-38,             1.0,             0.0, INEXACT));
assert(test_cosf( 2.350988001e-38,             1.0,             0.0, INEXACT));
assert(test_cosf( 2.350988702e-38,             1.0,             0.0, INEXACT));
assert(test_cosf( 2.350989542e-38,             1.0,             0.0, INEXACT));
assert(test_cosf( 4.701977403e-38,             1.0,             0.0, INEXACT));
assert(test_cosf( 7.450580597e-09,             1.0, 2.328306437e-10, INEXACT));
assert(test_cosf( 2.441406250e-04,             1.0, 2.500000000e-01, INEXACT));
assert(test_cosf( 4.882812500e-04, 9.999998808e-01,-3.973643103e-08, INEXACT));
assert(test_cosf( 9.765625000e-04, 9.999995232e-01,-6.357828397e-07, INEXACT));
assert(test_cosf(-2.802596929e-45,             1.0,             0.0, INEXACT));
assert(test_cosf(-1.261168618e-44,             1.0,             0.0, INEXACT));
assert(test_cosf(-2.938735877e-39,             1.0,             0.0, INEXACT));
assert(test_cosf(-5.877471754e-39,             1.0,             0.0, INEXACT));
assert(test_cosf(-1.175494071e-38,             1.0,             0.0, INEXACT));
assert(test_cosf(-1.175494211e-38,             1.0,             0.0, INEXACT));
assert(test_cosf(-1.175494491e-38,             1.0,             0.0, INEXACT));
assert(test_cosf(-1.175494631e-38,             1.0,             0.0, INEXACT));
assert(test_cosf(-2.350988001e-38,             1.0,             0.0, INEXACT));
assert(test_cosf(-2.350988702e-38,             1.0,             0.0, INEXACT));
assert(test_cosf(-2.350989542e-38,             1.0,             0.0, INEXACT));
assert(test_cosf(-4.701977403e-38,             1.0,             0.0, INEXACT));
assert(test_cosf(-7.450580597e-09,             1.0, 2.328306437e-10, INEXACT));
assert(test_cosf(-2.441406250e-04,             1.0, 2.500000000e-01, INEXACT));
assert(test_cosf(-4.882812500e-04, 9.999998808e-01,-3.973643103e-08, INEXACT));
assert(test_cosf(-9.765625000e-04, 9.999995232e-01,-6.357828397e-07, INEXACT));

// large arguments
assert(test_cosf( 255.99993896484,-0.039851747453212740, 0.0, INEXACT));
assert(test_cosf( 5033165.25,      0.847187161445617700, 0.0, INEXACT));
assert(test_cosf( 421657440.0,     0.672892928123474100, 0.0, INEXACT));
assert(test_cosf( 2147483392.0,    0.961078047752380400, 0.0, INEXACT));
assert(test_cosf( 68719474688.0,   0.169419050216674800, 0.0, INEXACT));
assert(test_cosf( 549755797504.0,  0.207359507679939270, 0.0, INEXACT));
assert(test_cosf( f32.MAX_VALUE,   0.853021025657653800, 0.0, INEXACT));
assert(test_cosf(-255.99993896484,-0.039851747453212740, 0.0, INEXACT));
assert(test_cosf(-5033165.25,      0.847187161445617700, 0.0, INEXACT));
assert(test_cosf(-421657440.0,     0.672892928123474100, 0.0, INEXACT));
assert(test_cosf(-2147483392.0,    0.961078047752380400, 0.0, INEXACT));
assert(test_cosf(-68719474688.0,   0.169419050216674800, 0.0, INEXACT));
assert(test_cosf(-549755797504.0,  0.207359507679939270, 0.0, INEXACT));
assert(test_cosf(-f32.MAX_VALUE,   0.853021025657653800, 0.0, INEXACT));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.cosh
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_cosh(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.cosh(value), expected, error, flags) &&
  (!js || check<f64>(    JSMath.cosh(value), expected, error, flags));
}
// sanity
assert(test_cosh(-8.06684839057968084, 1593.52099388623287, -0.380988568067550659, INEXACT));
assert(test_cosh(4.34523984933830487, 38.5617492842672931, -0.271227836608886719, INEXACT));
assert(test_cosh(-8.38143342755524934, 2182.63097959589322, 0.0817827582359313965, INEXACT));
assert(test_cosh(-6.53167358191348413, 343.273849250878982, -0.429940402507781982, INEXACT));
assert(test_cosh(9.26705696697258574, 5291.77917000558682, -0.159299582242965698, INEXACT));
assert(test_cosh(0.661985898099504477, 1.22723219573428421, 0.23280741274356842, INEXACT));
assert(test_cosh(-0.40660392238535531, 1.08380854187119691, -0.396091699600219727, INEXACT));
assert(test_cosh(0.56175974622072411, 1.16198035831750768, 0.377483904361724854, INEXACT));
assert(test_cosh(0.77415229659130369, 1.31492368762767065, 0.435870081186294556, INEXACT));
assert(test_cosh(-0.678763702639402444, 1.23934132459345325, 0.102016061544418335, INEXACT));

// special
assert(test_cosh(0.0, 1.0, 0.0, 0));
assert(test_cosh(-0.0, 1.0, 0.0, 0));
assert(test_cosh(Infinity, Infinity, 0.0, 0));
assert(test_cosh(-Infinity, Infinity, 0.0, 0));
assert(test_cosh(NaN, NaN, 0.0, 0));

// Mathf.cosh //////////////////////////////////////////////////////////////////////////////////////

function test_coshf(value: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.cosh(value), expected, error, flags);
}

// sanity
assert(test_coshf(-8.066848755, 1593.521606, 0.2624258101, INEXACT));
assert(test_coshf(4.345239639, 38.56174088, -0.08168885857, INEXACT));
assert(test_coshf(-8.381433487, 2182.631104, -0.02331414446, INEXACT));
assert(test_coshf(-6.531673431, 343.2738037, 0.2008149326, INEXACT));
assert(test_coshf(9.267057419, 5291.781738, 0.3628672361, INEXACT));
assert(test_coshf(0.6619858742, 1.227232218, 0.3277741671, INEXACT));
assert(test_coshf(-0.4066039324, 1.083808541, -0.03984870389, INEXACT));
assert(test_coshf(0.5617597699, 1.161980391, 0.1527447701, INEXACT));
assert(test_coshf(0.7741522789, 1.314923644, -0.2387111485, INEXACT));
assert(test_coshf(-0.6787636876, 1.239341259, -0.4579193294, INEXACT));

// special
assert(test_coshf(0.0, 1.0, 0.0, 0));
assert(test_coshf(-0.0, 1.0, 0.0, 0));
assert(test_coshf(Infinity, Infinity, 0.0, 0));
assert(test_coshf(-Infinity, Infinity, 0.0, 0));
assert(test_coshf(NaN, NaN, 0.0, 0));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.exp
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_exp(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.exp(value), expected, error, flags) &&
  (!js || check<f64>(    JSMath.exp(value), expected, error, flags));
}

// sanity
assert(test_exp(-8.06684839057968084, 0.000313770606816174511, -0.259919732809066772, INEXACT));
assert(test_exp(4.34523984933830487, 77.1105301711214111, -0.0279267579317092896, INEXACT));
assert(test_exp(-8.38143342755524934, 0.000229081338491632304, -0.249743342399597168, INEXACT));
assert(test_exp(-6.53167358191348413, 0.00145656612609315877, -0.481682240962982178, INEXACT));
assert(test_exp(9.26705696697258574, 10583.5582455249933, 0.176967620849609375, INEXACT));
assert(test_exp(0.661985898099504477, 1.9386384525571998, -0.496424645185470581, INEXACT));
assert(test_exp(-0.40660392238535531, 0.665907889283802512, -0.106083184480667114, INEXACT));
assert(test_exp(0.56175974622072411, 1.75375595186263111, -0.391621112823486328, INEXACT));
assert(test_exp(0.77415229659130369, 2.16875288851292458, -0.299612581729888916, INEXACT));
assert(test_exp(-0.678763702639402444, 0.507243708940284255, 0.472617387771606445, INEXACT));

// special
assert(test_exp(0.0, 1.0, 0.0, 0));
assert(test_exp(-0.0, 1.0, 0.0, 0));
assert(test_exp(1.0, 2.71828182845904509, -0.325530737638473511, INEXACT));
assert(test_exp(-1.0, 0.367879441171442334, 0.223896518349647522, INEXACT));
assert(test_exp(Infinity, Infinity, 0.0, 0));
assert(test_exp(-Infinity, 0.0, 0.0, 0));
assert(test_exp(NaN, NaN, 0.0, 0));
assert(test_exp(1.0397214889526365, 2.82842915587641119, 0.188030809164047241, INEXACT));
assert(test_exp(-1.0397214889526365, 0.353553136702178472, 0.252727240324020386, INEXACT));
assert(test_exp(1.03972101211547852, 2.82842780717661224, -0.418413937091827393, INEXACT));
assert(test_exp(1.03972148895263672, 2.82842915587641164, -0.226183772087097168, INEXACT));

// some vectors from crlibm
assert(test_exp( f64.MIN_VALUE, 1.0, 0.0, INEXACT)); // smallest denorm positive
assert(test_exp(-f64.MIN_VALUE, 1.0, 0.0, INEXACT)); // smallest denorm negative

assert(test_exp(
  reinterpret<f64>(0x40862E42FEFA39EF),
  reinterpret<f64>(0x7FEFFFFFFFFFFF2A),
  reinterpret<f64>(0xBFBB0E2640000000),
  INEXACT
));

assert(test_exp(reinterpret<f64>(0x40862E42FEFA39F0), Infinity, 0.0, INEXACT | OVERFLOW));
assert(test_exp(
  reinterpret<f64>(0xC0874910D52D3051),
  f64.MIN_VALUE,
  reinterpret<f64>(0x3FE0000000000000),
  INEXACT | UNDERFLOW
));

assert(test_exp(
  reinterpret<f64>(0xC0874910D52D3052),
  0.0,
  reinterpret<f64>(0xBFE0000000000000),
  INEXACT | UNDERFLOW
));

assert(test_exp(
  reinterpret<f64>(0xC086232BDD7ABCD2),
  reinterpret<f64>(0x001000000000007C),
  reinterpret<f64>(0x3FD0C013E0000000),
  INEXACT
));

assert(test_exp(
  reinterpret<f64>(0xC086232BDD7ABCD3),
  reinterpret<f64>(0x000FFFFFFFFFFE7C),
  reinterpret<f64>(0x000FFFFFFFFFFE7C),
  INEXACT | UNDERFLOW
));

assert(test_exp(
  reinterpret<f64>(0x3FE005AE04256BAB),
  reinterpret<f64>(0x3FFA65D89ABF3D1F),
  reinterpret<f64>(0x3FE0000000000000),
  INEXACT
)); // 5.006933289508784801213892023952e-01

assert(test_exp(
  reinterpret<f64>(0x3FE41C9E095CD545),
  reinterpret<f64>(0x3FFDFF1D425DE879),
  reinterpret<f64>(0x3FE0000000000000),
  INEXACT
)); // 6.284933264602520219810344315192e-01

assert(test_exp(
  reinterpret<f64>(0x3FEACCFBE46B4EF0),
  reinterpret<f64>(0x40027C2E4BC1EE70),
  reinterpret<f64>(0xBFE0000000000000),
  INEXACT
)); // 8.375224553405740124389922129922e-01
assert(test_exp(
  reinterpret<f64>(0x3FEB3738E335EA89),
  reinterpret<f64>(0x4002B9F331610FB0),
  reinterpret<f64>(0x3FE0000000000000),
  INEXACT
)); // 8.504909932810998940411195690103e-01
assert(test_exp(
  reinterpret<f64>(0x3FFA083788425AB6),
  reinterpret<f64>(0x40145ABE6A4C4281),
  reinterpret<f64>(0x3FE0000000000000),
  INEXACT
)); // 1.627006084692465659458093796275e+00
assert(test_exp(
  reinterpret<f64>(0x3FFACA7AE8DA5A7B),
  reinterpret<f64>(0x401557D4ACD7E557),
  reinterpret<f64>(0x3FE0000000000000),
  INEXACT
)); // 1.674433621961411544631914694037e+00

assert(test_exp(
  reinterpret<f64>(0x401AA1B465630FA4),
  reinterpret<f64>(0x4088576653F47E5E),
  reinterpret<f64>(0x3FE0000000000000),
  INEXACT
)); // 6.657914718791207775439033866860e+00

assert(test_exp(
  reinterpret<f64>(0x40260BB5FB993B99),
  reinterpret<f64>(0x40EDE96D34FCCCFE),
  reinterpret<f64>(0x3FE0000000000000),
  INEXACT
)); // 1.102287279363172167734319373267e+01

assert(test_exp(
  reinterpret<f64>(0x4026D2883E37B4D7),
  reinterpret<f64>(0x40F60D75C9585CA5),
  reinterpret<f64>(0x3FE0000000000000),
  INEXACT
)); // 1.141119570188531717747082439018e+01

assert(test_exp(
  reinterpret<f64>(0x402796C771AF1E4B),
  reinterpret<f64>(0x41002D419F8E15F2),
  reinterpret<f64>(0x3FE0000000000000),
  INEXACT
)); // 1.179449038756060552657345397165e+01

assert(test_exp(
  reinterpret<f64>(0x4079CD6B6D99965B),
  reinterpret<f64>(0x65284208270E2E4C),
  reinterpret<f64>(0x3FE0000000000000),
  INEXACT
)); // 4.128387275695328639812942128628e+02

assert(test_exp(
  reinterpret<f64>(0x407FEE02D3D0EC9A),
  reinterpret<f64>(0x6E006CCF59E5ED14),
  reinterpret<f64>(0xBFE0000000000000),
  INEXACT
)); // 5.108756902848341496792272664607e+02

assert(test_exp(
  reinterpret<f64>(0xBD1DF00000000070),
  reinterpret<f64>(0x3FEFFFFFFFFFFF11),
  reinterpret<f64>(0x3FE0000000000000),
  INEXACT
)); // -2.658984143977285255283151746406e-14

assert(test_exp(
  reinterpret<f64>(0xBD1E900000000075),
  reinterpret<f64>(0x3FEFFFFFFFFFFF0B),
  reinterpret<f64>(0xBFE0000000000000),
  INEXACT
)); // -2.714495295208544660026143771835e-14

// Mathf.exp ///////////////////////////////////////////////////////////////////////////////////////

function test_expf(value: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.exp(value), expected, error, flags);
}

// sanity
assert(test_expf(-8.066848755, 0.0003137704916, -0.03019333631, INEXACT));
assert(test_expf(4.345239639, 77.11051178, -0.2875460684, INEXACT));
assert(test_expf(-8.381433487, 0.0002290813281, 0.2237040401, INEXACT));
assert(test_expf(-6.531673431, 0.001456566388, 0.3646970391, INEXACT));
assert(test_expf(9.267057419, 10583.56348, 0.459621042, INEXACT));
assert(test_expf(0.6619858742, 1.938638449, 0.3568260968, INEXACT));
assert(test_expf(-0.4066039324, 0.6659078598, -0.3829499185, INEXACT));
assert(test_expf(0.5617597699, 1.753756046, 0.443554908, INEXACT));
assert(test_expf(0.7741522789, 2.168752909, 0.2456246912, INEXACT));
assert(test_expf(-0.6787636876, 0.5072436929, -0.3974292278, INEXACT));

// special
assert(test_expf(0.0, 1.0, 0.0, 0));
assert(test_expf(-0.0, 1.0, 0.0, 0));
assert(test_expf(1.0, 2.718281746, -0.3462330997, INEXACT));
assert(test_expf(-1.0, 0.3678794503, 0.3070148528, INEXACT));
assert(test_expf(Infinity, Infinity, 0.0, 0));
assert(test_expf(-Infinity, 0.0, 0.0, 0));
assert(test_expf(NaN, NaN, 0.0, 0));
assert(test_expf(88.72283173, 3.402798519e+38, -0.09067153931, INEXACT));
assert(test_expf(88.72283936, Infinity, 0.0, INEXACT | OVERFLOW));
assert(test_expf(-103.9720764, 1.401298464e-45, 0.4999996722, INEXACT | UNDERFLOW));
assert(test_expf(-103.972084, 0.0, -0.4999965131, INEXACT | UNDERFLOW));
assert(test_expf(0.3465735614, 1.414213538, 0.1392242163, INEXACT));
assert(test_expf(0.3465735912, 1.414213538, -0.2143291682, INEXACT));
assert(test_expf(0.346573621, 1.414213657, 0.4321174324, INEXACT));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.expm1
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_expm1(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.expm1(value), expected, error, flags) &&
  (!js || check<f64>(    JSMath.expm1(value), expected, error, flags));
}

// sanity
assert(test_expm1(-8.06684839057968084, -0.999686229393183856, -0.276005834341049194, INEXACT));
assert(test_expm1(4.34523984933830487, 76.1105301711214111, -0.0279267579317092896, INEXACT));
assert(test_expm1(-8.38143342755524934, -0.999770918661508357, 0.100524961948394775, INEXACT));
assert(test_expm1(-6.53167358191348413, -0.998543433873906872, -0.274378299713134766, INEXACT));
assert(test_expm1(9.26705696697258574, 10582.5582455249933, 0.176967620849609375, INEXACT));
assert(test_expm1(0.661985898099504477, 0.938638452557199909, 0.00715068448334932327, INEXACT));
assert(test_expm1(-0.40660392238535531, -0.334092110716197488, -0.212166368961334229, INEXACT));
assert(test_expm1(0.56175974622072411, 0.753755951862631224, 0.216757774353027344, INEXACT));
assert(test_expm1(0.77415229659130369, 1.1687528885129248, 0.40077480673789978, INEXACT));
assert(test_expm1(-0.678763702639402444, -0.492756291059715801, -0.0547651983797550201, INEXACT));

// special
assert(test_expm1(0.0, 0.0, 0.0, 0));
assert(test_expm1(-0.0, -0.0, 0.0, 0));
assert(test_expm1(1.0, 1.71828182845904531, 0.348938524723052979, INEXACT));
assert(test_expm1(-1.0, -0.632120558828557666, 0.111948259174823761, INEXACT));
assert(test_expm1(Infinity, Infinity, 0.0, 0));
assert(test_expm1(-Infinity, -1.0, 0.0, 0));
assert(test_expm1(NaN, NaN, 0.0, 0));
assert(test_expm1(2.22507385850720089e-308, 2.22507385850720089e-308, 0.0, INEXACT | UNDERFLOW));
assert(test_expm1(-2.22507385850720089e-308,-2.22507385850720089e-308, 0.0, INEXACT | UNDERFLOW));

// Mathf.expm1 /////////////////////////////////////////////////////////////////////////////////////

function test_expm1f(value: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.expm1(value), expected, error, flags);
}

// sanity
assert(test_expm1f(-8.066848755, -0.9996862411, -0.1953272372, INEXACT));
assert(test_expm1f(4.345239639, 76.11051178, -0.2875460684, INEXACT));
assert(test_expm1f(-8.381433487, -0.9997709394, -0.3468692005, INEXACT));
assert(test_expm1f(-6.531673431, -0.9985434413, -0.1281939447, INEXACT));
assert(test_expm1f(9.267057419, 10582.56348, 0.459621042, INEXACT));
assert(test_expm1f(0.6619858742, 0.9386383891, -0.2863478065, INEXACT));
assert(test_expm1f(-0.4066039324, -0.3340921104, 0.2341001779, INEXACT));
assert(test_expm1f(0.5617597699, 0.7537559867, -0.1128901765, INEXACT));
assert(test_expm1f(0.7741522789, 1.168752909, 0.4912493825, INEXACT));
assert(test_expm1f(-0.6787636876, -0.4927562773, 0.2051415443, INEXACT));

// special
assert(test_expm1f(0.0, 0.0, 0.0, 0));
assert(test_expm1f(-0.0, -0.0, 0.0, 0));
assert(test_expm1f(1.0, 1.718281865, 0.3075338304, INEXACT));
assert(test_expm1f(-1.0, -0.6321205497, 0.1535074264, INEXACT));
assert(test_expm1f(Infinity, Infinity, 0.0, 0));
assert(test_expm1f(-Infinity, -1.0, 0.0, 0));
assert(test_expm1f(NaN, NaN, 0.0, 0));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.exp2
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_exp2(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.exp2(value), expected, error, flags) &&
  (!js || check<f64>(    JSMath.pow(2, value), expected, error, flags));
}

// sanity
assert(test_exp2(reinterpret<f64>(0xC0202239F3C6A8F1), reinterpret<f64>(0x3F6E8D13C396F452), reinterpret<f64>(0x3FC06779A0000000), INEXACT));
assert(test_exp2(reinterpret<f64>(0x401161868E18BC67), reinterpret<f64>(0x4034536746BB6F12), reinterpret<f64>(0x3F9F79AD40000000), INEXACT));
assert(test_exp2(reinterpret<f64>(0xC020C34B3E01E6E7), reinterpret<f64>(0x3F6890CA0C00B9A2), reinterpret<f64>(0xBFD3D71FE0000000), INEXACT));
assert(test_exp2(reinterpret<f64>(0xC01A206F0A19DCC4), reinterpret<f64>(0x3F8622D4B0EBC6C1), reinterpret<f64>(0xBFD24F1D00000000), INEXACT));
assert(test_exp2(reinterpret<f64>(0x402288BBB0D6A1E6), reinterpret<f64>(0x408340EC7F3E607E), reinterpret<f64>(0xBFB6BD9B00000000), INEXACT));
assert(test_exp2(reinterpret<f64>(0x3FE52EFD0CD80497), reinterpret<f64>(0x3FF950EEF4BC5451), reinterpret<f64>(0xBFC01D6DC0000000), INEXACT));
assert(test_exp2(reinterpret<f64>(0xBFDA05CC754481D1), reinterpret<f64>(0x3FE824056EFC687C), reinterpret<f64>(0xBFCF036340000000), INEXACT));
assert(test_exp2(reinterpret<f64>(0x3FE1F9EF934745CB), reinterpret<f64>(0x3FF79DFA14AB121E), reinterpret<f64>(0x3FD16408C0000000), INEXACT));
assert(test_exp2(reinterpret<f64>(0x3FE8C5DB097F7442), reinterpret<f64>(0x3FFB5CEAD2247372), reinterpret<f64>(0xBF950AE360000000), INEXACT));
assert(test_exp2(reinterpret<f64>(0xBFE5B86EA8118A0E), reinterpret<f64>(0x3FE3FD8BA33216B9), reinterpret<f64>(0xBFD3F71A00000000), INEXACT));

// special
assert(test_exp2(                                   0, reinterpret<f64>(0x3FF0000000000000),                                    0, 0));
assert(test_exp2(                                  -0, reinterpret<f64>(0x3FF0000000000000),                                    0, 0));
assert(test_exp2(                                   1, reinterpret<f64>(0x4000000000000000),                                    0, 0));
assert(test_exp2(                                  -1, reinterpret<f64>(0x3FE0000000000000),                                    0, 0));
assert(test_exp2(                            Infinity,                             Infinity,                                    0, 0));
assert(test_exp2(                           -Infinity,                                    0,                                    0, 0));
assert(test_exp2(                                 NaN,                                  NaN,                                    0, 0));
assert(test_exp2(reinterpret<f64>(0x3FFFF80000000000), reinterpret<f64>(0x400FF4EACA4391B6), reinterpret<f64>(0x3FC2E60C60000000), INEXACT));
assert(test_exp2(reinterpret<f64>(0xC08FEF3333333333), reinterpret<f64>(0x1125FBEE2506B0),   reinterpret<f64>(0xBFCC612EC0000000), INEXACT));
assert(test_exp2(reinterpret<f64>(0xC08FF00000000000), reinterpret<f64>(0x10000000000000),                                      0, 0));
assert(test_exp2(reinterpret<f64>(0xC08FF0CCCCCCCCCD), reinterpret<f64>(0xEEDB4008BD547),    reinterpret<f64>(0x3FC966DFC0000000), INEXACT | UNDERFLOW));
assert(test_exp2(reinterpret<f64>(0xC08FF80000000000), reinterpret<f64>(0x8000000000000),                                       0, 0));
assert(test_exp2(reinterpret<f64>(0x408FFF3333333333), reinterpret<f64>(0x7FEDDB680117AA8E), reinterpret<f64>(0x3FD966DFC0000000), INEXACT));
assert(test_exp2(reinterpret<f64>(0x4090000000000000),                             Infinity,                                    0, INEXACT | UNDERFLOW));
assert(test_exp2(reinterpret<f64>(0x4090006666666666),                             Infinity,                                    0, INEXACT | UNDERFLOW));
assert(test_exp2(reinterpret<f64>(0x40091EB851EB851F), reinterpret<f64>(0x4021A167423FC31C), reinterpret<f64>(0x3FD9287B80000000), INEXACT));
assert(test_exp2(reinterpret<f64>(0xC08FF40000000000), reinterpret<f64>(0xB504F333F9DE6),    reinterpret<f64>(0xBFD2116600000000), INEXACT | UNDERFLOW));
assert(test_exp2(reinterpret<f64>(0xC08FF80000000000), reinterpret<f64>(0x8000000000000),                                       0, 0));
assert(test_exp2(reinterpret<f64>(0xC08FFC0000000000), reinterpret<f64>(0x5A827999FCEF3),    reinterpret<f64>(0xBFC2116600000000), INEXACT | UNDERFLOW));
assert(test_exp2(reinterpret<f64>(0xC090000000000000), reinterpret<f64>(0x4000000000000),                                       0, 0));
assert(test_exp2(reinterpret<f64>(0xC090040000000000), reinterpret<f64>(0x2000000000000),                                       0, 0));
assert(test_exp2(reinterpret<f64>(0xC090C80000000000),               reinterpret<f64>(0x1),                                     0, 0));
assert(test_exp2(reinterpret<f64>(0xC090CA0000000000),               reinterpret<f64>(0x1),  reinterpret<f64>(0x3FD2BEC340000000), INEXACT | UNDERFLOW));
assert(test_exp2(reinterpret<f64>(0xC090CC0000000000),                                   0,  reinterpret<f64>(0xBFE0000000000000), INEXACT | UNDERFLOW));
assert(test_exp2(reinterpret<f64>(0xC0A0000000000000),                                   0,                                     0, INEXACT | UNDERFLOW));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Mathf.exp2
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_exp2f(value: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.exp2(value), expected, error, flags);
}

// sanity
assert(test_exp2f(<f32>reinterpret<f64>(0xC020223A00000000), <f32>reinterpret<f64>(0x3F6E8D1340000000), <f32>reinterpret<f64>(0xBFB1471420000000), INEXACT));
assert(test_exp2f(<f32>reinterpret<f64>(0x4011618680000000), <f32>reinterpret<f64>(0x4034536720000000), <f32>reinterpret<f64>(0x3FD5D67360000000), INEXACT));
assert(test_exp2f(<f32>reinterpret<f64>(0xC020C34B40000000), <f32>reinterpret<f64>(0x3F6890CA00000000), <f32>reinterpret<f64>(0x3FC3D88DC0000000), INEXACT));
assert(test_exp2f(<f32>reinterpret<f64>(0xC01A206F00000000), <f32>reinterpret<f64>(0x3F8622D4E0000000), <f32>reinterpret<f64>(0x3FD0AA4C00000000), INEXACT));
assert(test_exp2f(<f32>reinterpret<f64>(0x402288BBC0000000), <f32>reinterpret<f64>(0x408340ECE0000000), <f32>reinterpret<f64>(0xBFC1A7C340000000), INEXACT));
assert(test_exp2f(<f32>reinterpret<f64>(0x3FE52EFD00000000), <f32>reinterpret<f64>(0x3FF950EEE0000000), <f32>reinterpret<f64>(0xBFDB629020000000), INEXACT));
assert(test_exp2f(<f32>reinterpret<f64>(0xBFDA05CC80000000), <f32>reinterpret<f64>(0x3FE8240560000000), <f32>reinterpret<f64>(0xBFD85C2120000000), INEXACT));
assert(test_exp2f(<f32>reinterpret<f64>(0x3FE1F9EFA0000000), <f32>reinterpret<f64>(0x3FF79DFA20000000), <f32>reinterpret<f64>(0x3FC34B9680000000), INEXACT));
assert(test_exp2f(<f32>reinterpret<f64>(0x3FE8C5DB00000000), <f32>reinterpret<f64>(0x3FFB5CEAC0000000), <f32>reinterpret<f64>(0xBFD906A1E0000000), INEXACT));
assert(test_exp2f(<f32>reinterpret<f64>(0xBFE5B86EA0000000), <f32>reinterpret<f64>(0x3FE3FD8BA0000000), <f32>reinterpret<f64>(0xBFCAC1F220000000), INEXACT));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.floor
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_floor(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.floor(value), expected, error, flags) &&
  (!js || check<f64>(    JSMath.floor(value), expected, error, flags));
}

// sanity
assert(test_floor(-8.06684839057968084, -9.0, 0.0, INEXACT));
assert(test_floor(4.34523984933830487, 4.0, 0.0, INEXACT));
assert(test_floor(-8.38143342755524934, -9.0, 0.0, INEXACT));
assert(test_floor(-6.53167358191348413, -7.0, 0.0, INEXACT));
assert(test_floor(9.26705696697258574, 9.0, 0.0, INEXACT));
assert(test_floor(0.661985898099504477, 0.0, 0.0, INEXACT));
assert(test_floor(-0.40660392238535531, -1.0, 0.0, INEXACT));
assert(test_floor(0.56175974622072411, 0.0, 0.0, INEXACT));
assert(test_floor(0.77415229659130369, 0.0, 0.0, INEXACT));
assert(test_floor(-0.678763702639402444, -1.0, 0.0, INEXACT));

// special
assert(test_floor(NaN, NaN, 0.0, 0));
assert(test_floor(Infinity, Infinity, 0.0, 0));
assert(test_floor(-Infinity, -Infinity, 0.0, 0));
assert(test_floor(0.0, 0.0, 0.0, 0));
assert(test_floor(-0.0, -0.0, 0.0, 0));
assert(test_floor(1.0, 1.0, 0.0, 0));
assert(test_floor(-1.0, -1.0, 0.0, 0));
assert(test_floor(0.5, 0.0, 0.0, INEXACT));
assert(test_floor(-0.5, -1.0, 0.0, INEXACT));
assert(test_floor(1.0000152587890625, 1.0, 0.0, INEXACT));
assert(test_floor(-1.0000152587890625, -2.0, 0.0, INEXACT));
assert(test_floor(0.99999237060546875, 0.0, 0.0, INEXACT));
assert(test_floor(-0.99999237060546875, -1.0, 0.0, INEXACT));
assert(test_floor(7.88860905221011805e-31, 0.0, 0.0, INEXACT));
assert(test_floor(-7.88860905221011805e-31, -1.0, 0.0, INEXACT));

// Mathf.floor /////////////////////////////////////////////////////////////////////////////////////

function test_floorf(value: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.floor(value), expected, error, flags);
}

// sanity
assert(test_floorf(-8.066848755, -9.0, 0.0, INEXACT));
assert(test_floorf(4.345239639, 4.0, 0.0, INEXACT));
assert(test_floorf(-8.381433487, -9.0, 0.0, INEXACT));
assert(test_floorf(-6.531673431, -7.0, 0.0, INEXACT));
assert(test_floorf(9.267057419, 9.0, 0.0, INEXACT));
assert(test_floorf(0.6619858742, 0.0, 0.0, INEXACT));
assert(test_floorf(-0.4066039324, -1.0, 0.0, INEXACT));
assert(test_floorf(0.5617597699, 0.0, 0.0, INEXACT));
assert(test_floorf(0.7741522789, 0.0, 0.0, INEXACT));
assert(test_floorf(-0.6787636876, -1.0, 0.0, INEXACT));

// special
assert(test_floorf(NaN, NaN, 0.0, 0));
assert(test_floorf(Infinity, Infinity, 0.0, 0));
assert(test_floorf(-Infinity, -Infinity, 0.0, 0));
assert(test_floorf(0.0, 0.0, 0.0, 0));
assert(test_floorf(-0.0, -0.0, 0.0, 0));
assert(test_floorf(1.0, 1.0, 0.0, 0));
assert(test_floorf(-1.0, -1.0, 0.0, 0));
assert(test_floorf(0.5, 0.0, 0.0, INEXACT));
assert(test_floorf(-0.5, -1.0, 0.0, INEXACT));
assert(test_floorf(1.000015259, 1.0, 0.0, INEXACT));
assert(test_floorf(-1.000015259, -2.0, 0.0, INEXACT));
assert(test_floorf(0.9999923706, 0.0, 0.0, INEXACT));
assert(test_floorf(-0.9999923706, -1.0, 0.0, INEXACT));
assert(test_floorf(7.888609052e-31, 0.0, 0.0, INEXACT));
assert(test_floorf(-7.888609052e-31, -1.0, 0.0, INEXACT));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.hypot
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_hypot(value1: f64, value2: f64, expected: f64, error: f64, flags: i32): bool {
  return check<f64>(NativeMath.hypot(value1, value2), expected, error, flags) /* &&
  (!js || check<f64>(    JSMath.hypot(value1, value2), expected, error, flags))*/;
  // ^ FIXME: Math.hypot is broken in v8 7.7 (node 12.11) due to
  //   https://bugs.chromium.org/p/v8/issues/detail?id=9546
}

// sanity
assert(test_hypot(-8.06684839057968084, 4.53566256067686879, 9.25452742288464059, -0.311886817216873169, INEXACT));
assert(test_hypot(4.34523984933830487, -8.88799136300345083, 9.89330580832825213, 0.459367334842681885, INEXACT));
assert(test_hypot(-8.38143342755524934, -2.76360733737958819, 8.82530179743213239, -0.170175433158874512, INEXACT));
assert(test_hypot(-6.53167358191348413, 4.56753527684274374, 7.97026588551909221, -0.317678272724151611, INEXACT));
assert(test_hypot(9.26705696697258574, 4.81139208435979615, 10.4416396518245751, -0.269363343715667725, INEXACT));
assert(test_hypot(-6.45004555606023633, 0.662071792337673881, 6.48393605254259331, 0.356188982725143433, INEXACT));
assert(test_hypot(7.85889025304169664, 0.0521545267500622481, 7.85906330958176635, 0.0804465562105178833, INEXACT));
assert(test_hypot(-0.792054511984895959, 7.67640268511753998, 7.7171567648995838, 0.0517808496952056885, INEXACT));
assert(test_hypot(0.615702673197924044, 2.01190257903248026, 2.10400612387431396, -0.0918039008975028992, INEXACT));
assert(test_hypot(-0.558758682360915193, 0.0322398306026380407, 0.559688012906291332, 0.138340771198272705, INEXACT));

// special
assert(test_hypot(3.0, 4.0, 5.0, 0.0, 0));
assert(test_hypot(-3.0, 4.0, 5.0, 0.0, 0));
assert(test_hypot(4.0, 3.0, 5.0, 0.0, 0));
assert(test_hypot(4.0, -3.0, 5.0, 0.0, 0));
assert(test_hypot(-3.0, -4.0, 5.0, 0.0, 0));
assert(test_hypot(1.79769313486231571e+308, 0.0, 1.79769313486231571e+308, 0.0, 0));
assert(test_hypot(1.79769313486231571e+308, -0.0, 1.79769313486231571e+308, 0.0, 0));
assert(test_hypot(4.94065645841246544e-324, 0.0, 4.94065645841246544e-324, 0.0, 0));
assert(test_hypot(4.94065645841246544e-324, -0.0, 4.94065645841246544e-324, 0.0, 0));
assert(test_hypot(Infinity, 1.0, Infinity, 0.0, 0));
assert(test_hypot(1.0, Infinity, Infinity, 0.0, 0));
assert(test_hypot(Infinity, NaN, Infinity, 0.0, 0));
assert(test_hypot(NaN, Infinity, Infinity, 0.0, 0));
assert(test_hypot(-Infinity, 1.0, Infinity, 0.0, 0));
assert(test_hypot(1.0, -Infinity, Infinity, 0.0, 0));
assert(test_hypot(-Infinity, NaN, Infinity, 0.0, 0));
assert(test_hypot(NaN, -Infinity, Infinity, 0.0, 0));
assert(test_hypot(NaN, 1.0, NaN, 0.0, 0));
assert(test_hypot(1.0, NaN, NaN, 0.0, 0));
assert(test_hypot(NaN, 0.0, NaN, 0.0, 0));
assert(test_hypot(0.0, NaN, NaN, 0.0, 0));

// Mathf.hypot /////////////////////////////////////////////////////////////////////////////////////

function test_hypotf(value1: f32, value2: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.hypot(value1, value2), expected, error, flags);
}

// sanity
assert(test_hypotf(-8.066848755, 4.535662651, 9.254528046, 0.2735958993, INEXACT));
assert(test_hypotf(4.345239639, -8.887990952, 9.893305779, 0.4530770779, INEXACT));
assert(test_hypotf(-8.381433487, -2.763607264, 8.825302124, 0.3075572848, INEXACT));
assert(test_hypotf(-6.531673431, 4.5675354, 7.970265865, 0.06785223633, INEXACT));
assert(test_hypotf(9.267057419, 4.811392307, 10.4416399, -0.2677630782, INEXACT));
assert(test_hypotf(-6.450045586, 0.6620717645, 6.48393631, 0.4838129282, INEXACT));
assert(test_hypotf(7.858890057, 0.05215452611, 7.859063148, 0.07413065434, INEXACT));
assert(test_hypotf(-0.792054534, 7.676402569, 7.717156887, 0.4940592647, INEXACT));
assert(test_hypotf(0.6157026887, 2.011902571, 2.104006052, -0.287089467, INEXACT));
assert(test_hypotf(-0.5587586761, 0.03223983198, 0.5596880317, 0.4191940725, INEXACT));

// special
assert(test_hypotf(3.0, 4.0, 5.0, 0.0, 0));
assert(test_hypotf(-3.0, 4.0, 5.0, 0.0, 0));
assert(test_hypotf(4.0, 3.0, 5.0, 0.0, 0));
assert(test_hypotf(4.0, -3.0, 5.0, 0.0, 0));
assert(test_hypotf(-3.0, -4.0, 5.0, 0.0, 0));
assert(test_hypotf(3.402823466e+38, 0.0, 3.402823466e+38, 0.0, 0));
assert(test_hypotf(3.402823466e+38, -0.0, 3.402823466e+38, 0.0, 0));
assert(test_hypotf(1.401298464e-45, 0.0, 1.401298464e-45, 0.0, 0));
assert(test_hypotf(1.401298464e-45, -0.0, 1.401298464e-45, 0.0, 0));
assert(test_hypotf(Infinity, 1.0, Infinity, 0.0, 0));
assert(test_hypotf(1.0, Infinity, Infinity, 0.0, 0));
assert(test_hypotf(Infinity, NaN, Infinity, 0.0, 0));
assert(test_hypotf(NaN, Infinity, Infinity, 0.0, 0));
assert(test_hypotf(-Infinity, 1.0, Infinity, 0.0, 0));
assert(test_hypotf(1.0, -Infinity, Infinity, 0.0, 0));
assert(test_hypotf(-Infinity, NaN, Infinity, 0.0, 0));
assert(test_hypotf(NaN, -Infinity, Infinity, 0.0, 0));
assert(test_hypotf(NaN, 1.0, NaN, 0.0, 0));
assert(test_hypotf(1.0, NaN, NaN, 0.0, 0));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.log
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_log(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.log(value), expected, error, flags) &&
  (!js || check<f64>(    JSMath.log(value), expected, error, flags));
}

// sanity
assert(test_log(-8.06684839057968084, NaN, 0.0, INVALID));
assert(test_log(4.34523984933830487, 1.46908095842243225, -0.341253340244293213, INEXACT));
assert(test_log(-8.38143342755524934, NaN, 0.0, INVALID));
assert(test_log(-6.53167358191348413, NaN, 0.0, INVALID));
assert(test_log(9.26705696697258574, 2.22646584987956153, 0.363811403512954712, INEXACT));
assert(test_log(0.661985898099504477, -0.412511025236513673, -0.291087478399276733, INEXACT));
assert(test_log(-0.40660392238535531, NaN, 0.0, INVALID));
assert(test_log(0.56175974622072411, -0.576681018319586181, -0.109831996262073517, INEXACT));
assert(test_log(0.77415229659130369, -0.255986659126386518, -0.0579900443553924561, INEXACT));
assert(test_log(-0.678763702639402444, NaN, 0.0, INVALID));

// special
assert(test_log(0.0, -Infinity, 0.0, DIVBYZERO));
assert(test_log(-0.0, -Infinity, 0.0, DIVBYZERO));
assert(test_log(-7.88860905221011805e-31, NaN, 0.0, INVALID));
assert(test_log(1.0, 0.0, 0.0, 0));
assert(test_log(-1.0, NaN, 0.0, INVALID));
assert(test_log(Infinity, Infinity, 0.0, 0));
assert(test_log(-Infinity, NaN, 0.0, INVALID));
assert(test_log(NaN, NaN, 0.0, 0));

// Mathf.log ///////////////////////////////////////////////////////////////////////////////////////

function test_logf(value: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.log(value), expected, error, flags);
}

// sanity
assert(test_logf(0.0, -Infinity, 0.0, DIVBYZERO));
assert(test_logf(-0.0, -Infinity, 0.0, DIVBYZERO));
assert(test_logf(-7.888609052e-31, NaN, 0.0, INVALID));
assert(test_logf(1.0, 0.0, 0.0, 0));
assert(test_logf(-1.0, NaN, 0.0, INVALID));
assert(test_logf(Infinity, Infinity, 0.0, 0));
assert(test_logf(-Infinity, NaN, 0.0, INVALID));
assert(test_logf(NaN, NaN, 0.0, 0));

// special
assert(test_logf(0.0, -Infinity, 0.0, DIVBYZERO));
assert(test_logf(-0.0, -Infinity, 0.0, DIVBYZERO));
assert(test_logf(-7.888609052e-31, NaN, 0.0, INVALID));
assert(test_logf(1.0, 0.0, 0.0, 0));
assert(test_logf(-1.0, NaN, 0.0, INVALID));
assert(test_logf(Infinity, Infinity, 0.0, 0));
assert(test_logf(-Infinity, NaN, 0.0, INVALID));
assert(test_logf(NaN, NaN, 0.0, 0));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.log10
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_log10(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.log10(value), expected, error, flags) &&
  (!js || check<f64>(    JSMath.log10(value), expected, error, flags));
}

// sanity
assert(test_log10(-8.06684839057968084, NaN, 0.0, INVALID));
assert(test_log10(4.34523984933830487, 0.638013753712002862, -0.2088824063539505, INEXACT));
assert(test_log10(-8.38143342755524934, NaN, 0.0, INVALID));
assert(test_log10(-6.53167358191348413, NaN, 0.0, INVALID));
assert(test_log10(9.26705696697258574, 0.966941832748727359, -0.0612043179571628571, INEXACT));
assert(test_log10(0.661985898099504477, -0.179151261984470928, 0.390908747911453247, INEXACT));
assert(test_log10(-0.40660392238535531, NaN, 0.0, INVALID));
assert(test_log10(0.56175974622072411, -0.250449384074544368, -0.304684162139892578, INEXACT));
assert(test_log10(0.77415229659130369, -0.111173593499438367, -0.315033614635467529, INEXACT));
assert(test_log10(-0.678763702639402444, NaN, 0.0, INVALID));

// special
assert(test_log10(0.0, -Infinity, 0.0, DIVBYZERO));
assert(test_log10(-0.0, -Infinity, 0.0, DIVBYZERO));
assert(test_log10(-7.88860905221011805e-31, NaN, 0.0, INVALID));
assert(test_log10(1.0, 0.0, 0.0, 0));
assert(test_log10(-1.0, NaN, 0.0, INVALID));
assert(test_log10(Infinity, Infinity, 0.0, 0));
assert(test_log10(-Infinity, NaN, 0.0, INVALID));
assert(test_log10(NaN, NaN, 0.0, 0));

// Mathf.log10 /////////////////////////////////////////////////////////////////////////////////////

function test_log10f(value: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.log10(value), expected, error, flags);
}

// sanity
assert(test_log10f(-8.066848755, NaN, 0.0, INVALID));
assert(test_log10f(4.345239639, 0.6380137205, -0.2047675848, INEXACT));
assert(test_log10f(-8.381433487, NaN, 0.0, INVALID));
assert(test_log10f(-6.531673431, NaN, 0.0, INVALID));
assert(test_log10f(9.267057419, 0.9669418335, -0.3427302539, INEXACT));
assert(test_log10f(0.6619858742, -0.1791512817, -0.2707855403, INEXACT));
assert(test_log10f(-0.4066039324, NaN, 0.0, INVALID));
assert(test_log10f(0.5617597699, -0.2504493594, 0.2126826048, INEXACT));
assert(test_log10f(0.7741522789, -0.1111736, 0.4651509523, INEXACT));
assert(test_log10f(-0.6787636876, NaN, 0.0, INVALID));

// special
assert(test_log10f(0.0, -Infinity, 0.0, DIVBYZERO));
assert(test_log10f(-0.0, -Infinity, 0.0, DIVBYZERO));
assert(test_log10f(-7.888609052e-31, NaN, 0.0, INVALID));
assert(test_log10f(1.0, 0.0, 0.0, 0));
assert(test_log10f(-1.0, NaN, 0.0, INVALID));
assert(test_log10f(Infinity, Infinity, 0.0, 0));
assert(test_log10f(-Infinity, NaN, 0.0, INVALID));
assert(test_log10f(NaN, NaN, 0.0, 0));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.log1p
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_log1p(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.log1p(value), expected, error, flags) &&
  (!js || check<f64>(    JSMath.log1p(value), expected, error, flags));
}

// sanity
assert(test_log1p(-8.06684839057968084, NaN, 0.0, INVALID));
assert(test_log1p(4.34523984933830487, 1.67620641706017337, 0.46188199520111084, INEXACT));
assert(test_log1p(-8.38143342755524934, NaN, 0.0, INVALID));
assert(test_log1p(-6.53167358191348413, NaN, 0.0, INVALID));
assert(test_log1p(9.26705696697258574, 2.32894041685238262, -0.411114901304244995, INEXACT));
assert(test_log1p(0.661985898099504477, 0.508013211499247719, -0.293060451745986938, INEXACT));
assert(test_log1p(-0.40660392238535531, -0.521893181166397935, -0.258257269859313965, INEXACT));
assert(test_log1p(0.56175974622072411, 0.445813227948810176, -0.132748872041702271, INEXACT));
assert(test_log1p(0.77415229659130369, 0.573322729464841419, 0.027165830135345459, INEXACT));
assert(test_log1p(-0.678763702639402444, -1.13557829781285635, 0.27130928635597229, INEXACT));

// special
assert(test_log1p(0.0, 0.0, 0.0, 0));
assert(test_log1p(-0.0, -0.0, 0.0, 0));
assert(test_log1p(-7.88860905221011805e-31, -7.88860905221011805e-31, 1.77635683940025046e-15, INEXACT));
assert(test_log1p(1.0, 0.693147180559945286, -0.208881169557571411, INEXACT));
assert(test_log1p(-1.0, -Infinity, 0.0, DIVBYZERO));
assert(test_log1p(Infinity, Infinity, 0.0, 0));
assert(test_log1p(-Infinity, NaN, 0.0, INVALID));
assert(test_log1p(NaN, NaN, 0.0, 0));

// Mathf.log1p /////////////////////////////////////////////////////////////////////////////////////

function test_log1pf(value: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.log1p(value), expected, error, flags);
}

// sanity
assert(test_log1pf(-8.066848755, NaN, 0.0, INVALID));
assert(test_log1pf(4.345239639, 1.67620635, -0.2301485986, INEXACT));
assert(test_log1pf(-8.381433487, NaN, 0.0, INVALID));
assert(test_log1pf(-6.531673431, NaN, 0.0, INVALID));
assert(test_log1pf(9.267057419, 2.328940392, -0.2907558978, INEXACT));
assert(test_log1pf(0.6619858742, 0.5080131888, -0.1386766881, INEXACT));
assert(test_log1pf(-0.4066039324, -0.5218932033, -0.08804433048, INEXACT));
assert(test_log1pf(0.5617597699, 0.4458132386, -0.1510136873, INEXACT));
assert(test_log1pf(0.7741522789, 0.5733227134, -0.1026453301, INEXACT));
assert(test_log1pf(-0.6787636876, -1.135578275, -0.198794812, INEXACT));

// special
assert(test_log1pf(0.0, 0.0, 0.0, 0));
assert(test_log1pf(-0.0, -0.0, 0.0, 0));
assert(test_log1pf(-7.888609052e-31, -7.888609052e-31, 3.308722450e-24, INEXACT));
assert(test_log1pf(1.0, 0.6931471825, 0.03195479512, INEXACT));
assert(test_log1pf(-1.0, -Infinity, 0.0, DIVBYZERO));
assert(test_log1pf(Infinity, Infinity, 0.0, 0));
assert(test_log1pf(-Infinity, NaN, 0.0, INVALID));
assert(test_log1pf(NaN, NaN, 0.0, 0));
assert(test_log1pf(-1.175494211e-38,-1.175494211e-38, 4.930380658e-32, INEXACT | UNDERFLOW));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.log2
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_log2(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.log2(value), expected, error, flags) &&
  (!js || check<f64>(    JSMath.log2(value), expected, error, flags));
}

// sanity
assert(test_log2(-8.06684839057968084, NaN, 0.0, INVALID));
assert(test_log2(4.34523984933830487, 2.11943581338044851, -0.101648777723312378, INEXACT));
assert(test_log2(-8.38143342755524934, NaN, 0.0, INVALID));
assert(test_log2(-6.53167358191348413, NaN, 0.0, INVALID));
assert(test_log2(9.26705696697258574, 3.21211124032987438, -0.157394468784332275, INEXACT));
assert(test_log2(0.661985898099504477, -0.59512761042074025, 0.332148522138595581, INEXACT));
assert(test_log2(-0.40660392238535531, NaN, 0.0, INVALID));
assert(test_log2(0.56175974622072411, -0.831974845304464417, 0.0575554370880126953, INEXACT));
assert(test_log2(0.77415229659130369, -0.369310683655371341, -0.198382794857025146, INEXACT));
assert(test_log2(-0.678763702639402444, NaN, 0.0, INVALID));

// special
assert(test_log2(0.0, -Infinity, 0.0, DIVBYZERO));
assert(test_log2(-0.0, -Infinity, 0.0, DIVBYZERO));
assert(test_log2(-7.88860905221011805e-31, NaN, 0.0, INVALID));
assert(test_log2(1.0, 0.0, 0.0, 0));
assert(test_log2(-1.0, NaN, 0.0, INVALID));
assert(test_log2(Infinity, Infinity, 0.0, 0));
assert(test_log2(-Infinity, NaN, 0.0, INVALID));
assert(test_log2(NaN, NaN, 0.0, 0));

// Mathf.log2 //////////////////////////////////////////////////////////////////////////////////////

function test_log2f(value: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.log2(value), expected, error, flags);
}

// sanity
assert(test_log2f(-8.066848755, NaN, 0.0, INVALID));
assert(test_log2f(4.345239639, 2.119435787, 0.1827153862, INEXACT));
assert(test_log2f(-8.381433487, NaN, 0.0, INVALID));
assert(test_log2f(-6.531673431, NaN, 0.0, INVALID));
assert(test_log2f(9.267057419, 3.212111235, -0.3188050389, INEXACT));
assert(test_log2f(0.6619858742, -0.5951276422, 0.3423146009, INEXACT));
assert(test_log2f(-0.4066039324, NaN, 0.0, INVALID));
assert(test_log2f(0.5617597699, -0.8319748044, -0.3347360492, INEXACT));
assert(test_log2f(0.7741522789, -0.3693107069, 0.3278401792, INEXACT));
assert(test_log2f(-0.6787636876, NaN, 0.0, INVALID));

// special
assert(test_log2f(0.0, -Infinity, 0.0, DIVBYZERO));
assert(test_log2f(-0.0, -Infinity, 0.0, DIVBYZERO));
assert(test_log2f(-7.888609052e-31, NaN, 0.0, INVALID));
assert(test_log2f(1.0, 0.0, 0.0, 0));
assert(test_log2f(-1.0, NaN, 0.0, INVALID));
assert(test_log2f(Infinity, Infinity, 0.0, 0));
assert(test_log2f(-Infinity, NaN, 0.0, INVALID));
assert(test_log2f(NaN, NaN, 0.0, 0));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.max
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_max(left: f64, right: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.max(left, right), expected, error, flags) &&
  (!js || check<f64>(    JSMath.max(left, right), expected, error, flags));
}

// sanity
assert(test_max(-8.06684839057968084, 4.53566256067686879, 4.53566256067686879, 0.0, 0));
assert(test_max(4.34523984933830487, -8.88799136300345083, 4.34523984933830487, 0.0, 0));
assert(test_max(-8.38143342755524934, -2.76360733737958819, -2.76360733737958819, 0.0, 0));
assert(test_max(-6.53167358191348413, 4.56753527684274374, 4.56753527684274374, 0.0, 0));
assert(test_max(9.26705696697258574, 4.81139208435979615, 9.26705696697258574, 0.0, 0));
assert(test_max(-6.45004555606023633, 0.662071792337673881, 0.662071792337673881, 0.0, 0));
assert(test_max(7.85889025304169664, 0.0521545267500622481, 7.85889025304169664, 0.0, 0));
assert(test_max(-0.792054511984895959, 7.67640268511753998, 7.67640268511753998, 0.0, 0));
assert(test_max(0.615702673197924044, 2.01190257903248026, 2.01190257903248026, 0.0, 0));
assert(test_max(-0.558758682360915193, 0.0322398306026380407, 0.0322398306026380407, 0.0, 0));

// special
assert(test_max(0.0, 1.0, 1.0, 0.0, 0));
assert(test_max(-0.0, 1.0, 1.0, 0.0, 0));
assert(test_max(0.5, 1.0, 1.0, 0.0, 0));
assert(test_max(-0.5, 1.0, 1.0, 0.0, 0));
assert(test_max(1.0, 1.0, 1.0, 0.0, 0));
assert(test_max(-1.0, 1.0, 1.0, 0.0, 0));
assert(test_max(Infinity, 1.0, Infinity, 0.0, 0));
assert(test_max(-Infinity, 1.0, 1.0, 0.0, 0));
assert(test_max(NaN, 1.0, NaN, 0.0, 0)); // C: 1.0, JS: NaN
assert(test_max(0.0, -1.0, 0.0, 0.0, 0));
assert(test_max(-0.0, -1.0, -0.0, 0.0, 0));
assert(test_max(0.5, -1.0, 0.5, 0.0, 0));
assert(test_max(-0.5, -1.0, -0.5, 0.0, 0));
assert(test_max(1.0, -1.0, 1.0, 0.0, 0));
assert(test_max(-1.0, -1.0, -1.0, 0.0, 0));
assert(test_max(Infinity, -1.0, Infinity, 0.0, 0));
assert(test_max(-Infinity, -1.0, -1.0, 0.0, 0));
assert(test_max(NaN, -1.0, NaN, 0.0, 0)); // C: -1.0, JS: NaN
assert(test_max(0.0, 0.0, 0.0, 0.0, 0));
assert(test_max(0.0, -0.0, 0.0, 0.0, 0));
assert(test_max(0.0, Infinity, Infinity, 0.0, 0));
assert(test_max(0.0, -Infinity, 0.0, 0.0, 0));
assert(test_max(0.0, NaN, NaN, 0.0, 0)); // C: 0.0, JS: NaN
assert(test_max(-0.0, 0.0, 0.0, 0.0, 0));
assert(test_max(-0.0, -0.0, -0.0, 0.0, 0));
assert(test_max(-0.0, Infinity, Infinity, 0.0, 0));
assert(test_max(-0.0, -Infinity, -0.0, 0.0, 0));
assert(test_max(-0.0, NaN, NaN, 0.0, 0)); // C: -0.0, JS: NaN
assert(test_max(1.0, 0.0, 1.0, 0.0, 0));
assert(test_max(-1.0, 0.0, 0.0, 0.0, 0));
assert(test_max(Infinity, 0.0, Infinity, 0.0, 0));
assert(test_max(-Infinity, 0.0, 0.0, 0.0, 0));
assert(test_max(NaN, 0.0, NaN, 0.0, 0)); // C: 0.0, JS: NaN
assert(test_max(-1.0, -0.0, -0.0, 0.0, 0));
assert(test_max(Infinity, -0.0, Infinity, 0.0, 0));
assert(test_max(-Infinity, -0.0, -0.0, 0.0, 0));
assert(test_max(NaN, -0.0, NaN, 0.0, 0)); // C: -0.0, JS: NaN
assert(test_max(Infinity, 2.0, Infinity, 0.0, 0));
assert(test_max(Infinity, -0.5, Infinity, 0.0, 0));
assert(test_max(Infinity, NaN, NaN, 0.0, 0)); // C: Infinity, JS: NaN
assert(test_max(-Infinity, 2.0, 2.0, 0.0, 0));
assert(test_max(-Infinity, -0.5, -0.5, 0.0, 0));
assert(test_max(-Infinity, NaN, NaN, 0.0, 0)); // C: -Infinity, JS: NaN
assert(test_max(NaN, NaN, NaN, 0.0, 0));
assert(test_max(1.0, NaN, NaN, 0.0, 0)); // C: 1.0, JS: NaN
assert(test_max(-1.0, NaN, NaN, 0.0, 0)); // C: -1.0, JS: NaN
assert(test_max(1.0, Infinity, Infinity, 0.0, 0));
assert(test_max(-1.0, Infinity, Infinity, 0.0, 0));
assert(test_max(Infinity, Infinity, Infinity, 0.0, 0));
assert(test_max(-Infinity, Infinity, Infinity, 0.0, 0));
assert(test_max(1.0, -Infinity, 1.0, 0.0, 0));
assert(test_max(-1.0, -Infinity, -1.0, 0.0, 0));
assert(test_max(Infinity, -Infinity, Infinity, 0.0, 0));
assert(test_max(-Infinity, -Infinity, -Infinity, 0.0, 0));
assert(test_max(1.75, 0.5, 1.75, 0.0, 0));
assert(test_max(-1.75, 0.5, 0.5, 0.0, 0));
assert(test_max(1.75, -0.5, 1.75, 0.0, 0));
assert(test_max(-1.75, -0.5, -0.5, 0.0, 0));

// Mathf.max ///////////////////////////////////////////////////////////////////////////////////////

function test_maxf(left: f32, right: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.max(left, right), expected, error, flags);
}

// sanity
assert(test_maxf(-8.066848755, 4.535662651, 4.535662651, 0.0, 0));
assert(test_maxf(4.345239639, -8.887990952, 4.345239639, 0.0, 0));
assert(test_maxf(-8.381433487, -2.763607264, -2.763607264, 0.0, 0));
assert(test_maxf(-6.531673431, 4.5675354, 4.5675354, 0.0, 0));
assert(test_maxf(9.267057419, 4.811392307, 9.267057419, 0.0, 0));
assert(test_maxf(-6.450045586, 0.6620717645, 0.6620717645, 0.0, 0));
assert(test_maxf(7.858890057, 0.05215452611, 7.858890057, 0.0, 0));
assert(test_maxf(-0.792054534, 7.676402569, 7.676402569, 0.0, 0));
assert(test_maxf(0.6157026887, 2.011902571, 2.011902571, 0.0, 0));
assert(test_maxf(-0.5587586761, 0.03223983198, 0.03223983198, 0.0, 0));

// special
assert(test_maxf(0.0, 1.0, 1.0, 0.0, 0));
assert(test_maxf(-0.0, 1.0, 1.0, 0.0, 0));
assert(test_maxf(0.5, 1.0, 1.0, 0.0, 0));
assert(test_maxf(-0.5, 1.0, 1.0, 0.0, 0));
assert(test_maxf(1.0, 1.0, 1.0, 0.0, 0));
assert(test_maxf(-1.0, 1.0, 1.0, 0.0, 0));
assert(test_maxf(Infinity, 1.0, Infinity, 0.0, 0));
assert(test_maxf(-Infinity, 1.0, 1.0, 0.0, 0));
assert(test_maxf(NaN, 1.0, NaN, 0.0, 0)); // C: 1.0, JS: NaN
assert(test_maxf(0.0, -1.0, 0.0, 0.0, 0));
assert(test_maxf(-0.0, -1.0, -0.0, 0.0, 0));
assert(test_maxf(0.5, -1.0, 0.5, 0.0, 0));
assert(test_maxf(-0.5, -1.0, -0.5, 0.0, 0));
assert(test_maxf(1.0, -1.0, 1.0, 0.0, 0));
assert(test_maxf(-1.0, -1.0, -1.0, 0.0, 0));
assert(test_maxf(Infinity, -1.0, Infinity, 0.0, 0));
assert(test_maxf(-Infinity, -1.0, -1.0, 0.0, 0));
assert(test_maxf(NaN, -1.0, NaN, 0.0, 0)); // C: -1.0, JS: NaN
assert(test_maxf(0.0, 0.0, 0.0, 0.0, 0));
assert(test_maxf(0.0, -0.0, 0.0, 0.0, 0));
assert(test_maxf(0.0, Infinity, Infinity, 0.0, 0));
assert(test_maxf(0.0, -Infinity, 0.0, 0.0, 0));
assert(test_maxf(0.0, NaN, NaN, 0.0, 0)); // C: 0.0, JS: NaN
assert(test_maxf(-0.0, 0.0, 0.0, 0.0, 0));
assert(test_maxf(-0.0, -0.0, -0.0, 0.0, 0));
assert(test_maxf(-0.0, Infinity, Infinity, 0.0, 0));
assert(test_maxf(-0.0, -Infinity, -0.0, 0.0, 0));
assert(test_maxf(-0.0, NaN, NaN, 0.0, 0)); // C: -0.0, JS: NaN
assert(test_maxf(1.0, 0.0, 1.0, 0.0, 0));
assert(test_maxf(-1.0, 0.0, 0.0, 0.0, 0));
assert(test_maxf(Infinity, 0.0, Infinity, 0.0, 0));
assert(test_maxf(-Infinity, 0.0, 0.0, 0.0, 0));
assert(test_maxf(NaN, 0.0, NaN, 0.0, 0)); // C: 0.0, JS: NaN
assert(test_maxf(-1.0, -0.0, -0.0, 0.0, 0));
assert(test_maxf(Infinity, -0.0, Infinity, 0.0, 0));
assert(test_maxf(-Infinity, -0.0, -0.0, 0.0, 0));
assert(test_maxf(NaN, -0.0, NaN, 0.0, 0)); // C: -0.0, JS: NaN
assert(test_maxf(Infinity, 2.0, Infinity, 0.0, 0));
assert(test_maxf(Infinity, -0.5, Infinity, 0.0, 0));
assert(test_maxf(Infinity, NaN, NaN, 0.0, 0)); // C: Infinity, JS: NaN
assert(test_maxf(-Infinity, 2.0, 2.0, 0.0, 0));
assert(test_maxf(-Infinity, -0.5, -0.5, 0.0, 0));
assert(test_maxf(-Infinity, NaN, NaN, 0.0, 0)); // C: -Infinity, JS: NaN
assert(test_maxf(NaN, NaN, NaN, 0.0, 0));
assert(test_maxf(1.0, NaN, NaN, 0.0, 0)); // C: 1.0, JS: NaN
assert(test_maxf(-1.0, NaN, NaN, 0.0, 0)); // C: -1.0, JS: NaN
assert(test_maxf(1.0, Infinity, Infinity, 0.0, 0));
assert(test_maxf(-1.0, Infinity, Infinity, 0.0, 0));
assert(test_maxf(Infinity, Infinity, Infinity, 0.0, 0));
assert(test_maxf(-Infinity, Infinity, Infinity, 0.0, 0));
assert(test_maxf(1.0, -Infinity, 1.0, 0.0, 0));
assert(test_maxf(-1.0, -Infinity, -1.0, 0.0, 0));
assert(test_maxf(Infinity, -Infinity, Infinity, 0.0, 0));
assert(test_maxf(-Infinity, -Infinity, -Infinity, 0.0, 0));
assert(test_maxf(1.75, 0.5, 1.75, 0.0, 0));
assert(test_maxf(-1.75, 0.5, 0.5, 0.0, 0));
assert(test_maxf(1.75, -0.5, 1.75, 0.0, 0));
assert(test_maxf(-1.75, -0.5, -0.5, 0.0, 0));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.min
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_min(left: f64, right: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.min(left, right), expected, error, flags) &&
  (!js || check<f64>(    JSMath.min(left, right), expected, error, flags));
}

// sanity
assert(test_min(-8.06684839057968084, 4.53566256067686879, -8.06684839057968084, 0.0, 0));
assert(test_min(4.34523984933830487, -8.88799136300345083, -8.88799136300345083, 0.0, 0));
assert(test_min(-8.38143342755524934, -2.76360733737958819, -8.38143342755524934, 0.0, 0));
assert(test_min(-6.53167358191348413, 4.56753527684274374, -6.53167358191348413, 0.0, 0));
assert(test_min(9.26705696697258574, 4.81139208435979615, 4.81139208435979615, 0.0, 0));
assert(test_min(-6.45004555606023633, 0.662071792337673881, -6.45004555606023633, 0.0, 0));
assert(test_min(7.85889025304169664, 0.0521545267500622481, 0.0521545267500622481, 0.0, 0));
assert(test_min(-0.792054511984895959, 7.67640268511753998, -0.792054511984895959, 0.0, 0));
assert(test_min(0.615702673197924044, 2.01190257903248026, 0.615702673197924044, 0.0, 0));
assert(test_min(-0.558758682360915193, 0.0322398306026380407, -0.558758682360915193, 0.0, 0));

// special
assert(test_min(0.0, 1.0, 0.0, 0.0, 0));
assert(test_min(-0.0, 1.0, -0.0, 0.0, 0));
assert(test_min(0.5, 1.0, 0.5, 0.0, 0));
assert(test_min(-0.5, 1.0, -0.5, 0.0, 0));
assert(test_min(1.0, 1.0, 1.0, 0.0, 0));
assert(test_min(-1.0, 1.0, -1.0, 0.0, 0));
assert(test_min(Infinity, 1.0, 1.0, 0.0, 0));
assert(test_min(-Infinity, 1.0, -Infinity, 0.0, 0));
assert(test_min(NaN, 1.0, NaN, 0.0, 0)); // C: 1.0, JS: NaN
assert(test_min(0.0, -1.0, -1.0, 0.0, 0));
assert(test_min(-0.0, -1.0, -1.0, 0.0, 0));
assert(test_min(0.5, -1.0, -1.0, 0.0, 0));
assert(test_min(-0.5, -1.0, -1.0, 0.0, 0));
assert(test_min(1.0, -1.0, -1.0, 0.0, 0));
assert(test_min(-1.0, -1.0, -1.0, 0.0, 0));
assert(test_min(Infinity, -1.0, -1.0, 0.0, 0));
assert(test_min(-Infinity, -1.0, -Infinity, 0.0, 0));
assert(test_min(NaN, -1.0, NaN, 0.0, 0)); // C: -1.0, JS: NaN
assert(test_min(0.0, 0.0, 0.0, 0.0, 0));
assert(test_min(0.0, -0.0, -0.0, 0.0, 0));
assert(test_min(0.0, Infinity, 0.0, 0.0, 0));
assert(test_min(0.0, -Infinity, -Infinity, 0.0, 0));
assert(test_min(0.0, NaN, NaN, 0.0, 0)); // C: 0.0, JS: NaN
assert(test_min(-0.0, 0.0, -0.0, 0.0, 0));
assert(test_min(-0.0, -0.0, -0.0, 0.0, 0));
assert(test_min(-0.0, Infinity, -0.0, 0.0, 0));
assert(test_min(-0.0, -Infinity, -Infinity, 0.0, 0));
assert(test_min(-0.0, NaN, NaN, 0.0, 0)); // C: -0.0, JS: NaN
assert(test_min(1.0, 0.0, 0.0, 0.0, 0));
assert(test_min(-1.0, 0.0, -1.0, 0.0, 0));
assert(test_min(Infinity, 0.0, 0.0, 0.0, 0));
assert(test_min(-Infinity, 0.0, -Infinity, 0.0, 0));
assert(test_min(NaN, 0.0, NaN, 0.0, 0)); // C: 0.0, JS: NaN
assert(test_min(-1.0, -0.0, -1.0, 0.0, 0));
assert(test_min(Infinity, -0.0, -0.0, 0.0, 0));
assert(test_min(-Infinity, -0.0, -Infinity, 0.0, 0));
assert(test_min(NaN, -0.0, NaN, 0.0, 0)); // C: -0.0, JS: NaN
assert(test_min(Infinity, 2.0, 2.0, 0.0, 0));
assert(test_min(Infinity, -0.5, -0.5, 0.0, 0));
assert(test_min(Infinity, NaN, NaN, 0.0, 0)); // C: Infinity, JS: NaN
assert(test_min(-Infinity, 2.0, -Infinity, 0.0, 0));
assert(test_min(-Infinity, -0.5, -Infinity, 0.0, 0));
assert(test_min(-Infinity, NaN, NaN, 0.0, 0)); // C: -Infinity, JS: NaN
assert(test_min(NaN, NaN, NaN, 0.0, 0));
assert(test_min(1.0, NaN, NaN, 0.0, 0)); // C: 1.0, JS: NaN
assert(test_min(-1.0, NaN, NaN, 0.0, 0)); // C: -1.0, JS: NaN
assert(test_min(1.0, Infinity, 1.0, 0.0, 0));
assert(test_min(-1.0, Infinity, -1.0, 0.0, 0));
assert(test_min(Infinity, Infinity, Infinity, 0.0, 0));
assert(test_min(-Infinity, Infinity, -Infinity, 0.0, 0));
assert(test_min(1.0, -Infinity, -Infinity, 0.0, 0));
assert(test_min(-1.0, -Infinity, -Infinity, 0.0, 0));
assert(test_min(Infinity, -Infinity, -Infinity, 0.0, 0));
assert(test_min(-Infinity, -Infinity, -Infinity, 0.0, 0));
assert(test_min(1.75, 0.5, 0.5, 0.0, 0));
assert(test_min(-1.75, 0.5, -1.75, 0.0, 0));
assert(test_min(1.75, -0.5, -0.5, 0.0, 0));
assert(test_min(-1.75, -0.5, -1.75, 0.0, 0));

// Mathf.min ///////////////////////////////////////////////////////////////////////////////////////

function test_minf(left: f32, right: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.min(left, right), expected, error, flags);
}

// sanity
assert(test_minf(-8.066848755, 4.535662651, -8.066848755, 0.0, 0));
assert(test_minf(4.345239639, -8.887990952, -8.887990952, 0.0, 0));
assert(test_minf(-8.381433487, -2.763607264, -8.381433487, 0.0, 0));
assert(test_minf(-6.531673431, 4.5675354, -6.531673431, 0.0, 0));
assert(test_minf(9.267057419, 4.811392307, 4.811392307, 0.0, 0));
assert(test_minf(-6.450045586, 0.6620717645, -6.450045586, 0.0, 0));
assert(test_minf(7.858890057, 0.05215452611, 0.05215452611, 0.0, 0));
assert(test_minf(-0.792054534, 7.676402569, -0.792054534, 0.0, 0));
assert(test_minf(0.6157026887, 2.011902571, 0.6157026887, 0.0, 0));
assert(test_minf(-0.5587586761, 0.03223983198, -0.5587586761, 0.0, 0));

// special
assert(test_minf(0.0, 1.0, 0.0, 0.0, 0));
assert(test_minf(-0.0, 1.0, -0.0, 0.0, 0));
assert(test_minf(0.5, 1.0, 0.5, 0.0, 0));
assert(test_minf(-0.5, 1.0, -0.5, 0.0, 0));
assert(test_minf(1.0, 1.0, 1.0, 0.0, 0));
assert(test_minf(-1.0, 1.0, -1.0, 0.0, 0));
assert(test_minf(Infinity, 1.0, 1.0, 0.0, 0));
assert(test_minf(-Infinity, 1.0, -Infinity, 0.0, 0));
assert(test_minf(NaN, 1.0, NaN, 0.0, 0)); // C: 1.0, JS: NaN
assert(test_minf(0.0, -1.0, -1.0, 0.0, 0));
assert(test_minf(-0.0, -1.0, -1.0, 0.0, 0));
assert(test_minf(0.5, -1.0, -1.0, 0.0, 0));
assert(test_minf(-0.5, -1.0, -1.0, 0.0, 0));
assert(test_minf(1.0, -1.0, -1.0, 0.0, 0));
assert(test_minf(-1.0, -1.0, -1.0, 0.0, 0));
assert(test_minf(Infinity, -1.0, -1.0, 0.0, 0));
assert(test_minf(-Infinity, -1.0, -Infinity, 0.0, 0));
assert(test_minf(NaN, -1.0, NaN, 0.0, 0)); // C: -1.0, JS: NaN
assert(test_minf(0.0, 0.0, 0.0, 0.0, 0));
assert(test_minf(0.0, -0.0, -0.0, 0.0, 0));
assert(test_minf(0.0, Infinity, 0.0, 0.0, 0));
assert(test_minf(0.0, -Infinity, -Infinity, 0.0, 0));
assert(test_minf(0.0, NaN, NaN, 0.0, 0)); // C: 0.0, JS: NaN
assert(test_minf(-0.0, 0.0, -0.0, 0.0, 0));
assert(test_minf(-0.0, -0.0, -0.0, 0.0, 0));
assert(test_minf(-0.0, Infinity, -0.0, 0.0, 0));
assert(test_minf(-0.0, -Infinity, -Infinity, 0.0, 0));
assert(test_minf(-0.0, NaN, NaN, 0.0, 0)); // C: -0.0, JS: NaN
assert(test_minf(1.0, 0.0, 0.0, 0.0, 0));
assert(test_minf(-1.0, 0.0, -1.0, 0.0, 0));
assert(test_minf(Infinity, 0.0, 0.0, 0.0, 0));
assert(test_minf(-Infinity, 0.0, -Infinity, 0.0, 0));
assert(test_minf(NaN, 0.0, NaN, 0.0, 0)); // C: 0.0, JS: NaN
assert(test_minf(-1.0, -0.0, -1.0, 0.0, 0));
assert(test_minf(Infinity, -0.0, -0.0, 0.0, 0));
assert(test_minf(-Infinity, -0.0, -Infinity, 0.0, 0));
assert(test_minf(NaN, -0.0, NaN, 0.0, 0)); // C: -0.0, JS: NaN
assert(test_minf(Infinity, 2.0, 2.0, 0.0, 0));
assert(test_minf(Infinity, -0.5, -0.5, 0.0, 0));
assert(test_minf(Infinity, NaN, NaN, 0.0, 0)); // C: Infinity, JS: NaN
assert(test_minf(-Infinity, 2.0, -Infinity, 0.0, 0));
assert(test_minf(-Infinity, -0.5, -Infinity, 0.0, 0));
assert(test_minf(-Infinity, NaN, NaN, 0.0, 0)); // C: -Infinity, JS: NaN
assert(test_minf(NaN, NaN, NaN, 0.0, 0));
assert(test_minf(1.0, NaN, NaN, 0.0, 0)); // C: 1.0, JS: NaN
assert(test_minf(-1.0, NaN, NaN, 0.0, 0)); // C: -1.0, JS: NaN
assert(test_minf(1.0, Infinity, 1.0, 0.0, 0));
assert(test_minf(-1.0, Infinity, -1.0, 0.0, 0));
assert(test_minf(Infinity, Infinity, Infinity, 0.0, 0));
assert(test_minf(-Infinity, Infinity, -Infinity, 0.0, 0));
assert(test_minf(1.0, -Infinity, -Infinity, 0.0, 0));
assert(test_minf(-1.0, -Infinity, -Infinity, 0.0, 0));
assert(test_minf(Infinity, -Infinity, -Infinity, 0.0, 0));
assert(test_minf(-Infinity, -Infinity, -Infinity, 0.0, 0));
assert(test_minf(1.75, 0.5, 0.5, 0.0, 0));
assert(test_minf(-1.75, 0.5, -1.75, 0.0, 0));
assert(test_minf(1.75, -0.5, -0.5, 0.0, 0));
assert(test_minf(-1.75, -0.5, -1.75, 0.0, 0));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.mod
////////////////////////////////////////////////////////////////////////////////////////////////////

declare function mod(x: f64, y: f64): f64;

function test_mod(left: f64, right: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.mod(left, right), expected, error, flags) &&
  (!js || check<f64>(           mod(left, right), expected, error, flags));
}

// sanity
assert(test_mod(-8.06684839057968084, 4.53566256067686879, -3.53118582990281205, 0.0, 0));
assert(test_mod(4.34523984933830487, -8.88799136300345083, 4.34523984933830487, 0.0, 0));
assert(test_mod(-8.38143342755524934, -2.76360733737958819, -0.0906114154164847641, 0.0, 0));
assert(test_mod(-6.53167358191348413, 4.56753527684274374, -1.96413830507074039, 0.0, 0));
assert(test_mod(9.26705696697258574, 4.81139208435979615, 4.45566488261278959, 0.0, 0));
assert(test_mod(-6.45004555606023633, 0.662071792337673881, -0.491399425021171399, 0.0, 0));
assert(test_mod(7.85889025304169664, 0.0521545267500622481, 0.0357112405323594256, 0.0, 0));
assert(test_mod(-0.792054511984895959, 7.67640268511753998, -0.792054511984895959, 0.0, 0));
assert(test_mod(0.615702673197924044, 2.01190257903248026, 0.615702673197924044, 0.0, 0));
assert(test_mod(-0.558758682360915193, 0.0322398306026380407, -0.0106815621160685006, 0.0, 0));

// special
assert(test_mod(0.0, 1.0, 0.0, 0.0, 0));
assert(test_mod(-0.0, 1.0, -0.0, 0.0, 0));
assert(test_mod(0.5, 1.0, 0.5, 0.0, 0));
assert(test_mod(-0.5, 1.0, -0.5, 0.0, 0));
assert(test_mod(1.0, 1.0, 0.0, 0.0, 0));
assert(test_mod(-1.0, 1.0, -0.0, 0.0, 0));
assert(test_mod(1.5, 1.0, 0.5, 0.0, 0));
assert(test_mod(-1.5, 1.0, -0.5, 0.0, 0));
assert(test_mod(2.0, 1.0, 0.0, 0.0, 0));
assert(test_mod(-2.0, 1.0, -0.0, 0.0, 0));
assert(test_mod(Infinity, 1.0, NaN, 0.0, INVALID));
assert(test_mod(-Infinity, 1.0, NaN, 0.0, INVALID));
assert(test_mod(NaN, 1.0, NaN, 0.0, 0));
assert(test_mod(0.0, -1.0, 0.0, 0.0, 0));
assert(test_mod(-0.0, -1.0, -0.0, 0.0, 0));
assert(test_mod(0.5, -1.0, 0.5, 0.0, 0));
assert(test_mod(-0.5, -1.0, -0.5, 0.0, 0));
assert(test_mod(1.0, -1.0, 0.0, 0.0, 0));
assert(test_mod(-1.0, -1.0, -0.0, 0.0, 0));
assert(test_mod(1.5, -1.0, 0.5, 0.0, 0));
assert(test_mod(-1.5, -1.0, -0.5, 0.0, 0));
assert(test_mod(2.0, -1.0, 0.0, 0.0, 0));
assert(test_mod(-2.0, -1.0, -0.0, 0.0, 0));
assert(test_mod(Infinity, -1.0, NaN, 0.0, INVALID));
assert(test_mod(-Infinity, -1.0, NaN, 0.0, INVALID));
assert(test_mod(NaN, -1.0, NaN, 0.0, 0));
assert(test_mod(0.0, 0.0, NaN, 0.0, INVALID));
assert(test_mod(0.0, -0.0, NaN, 0.0, INVALID));
assert(test_mod(0.0, Infinity, 0.0, 0.0, 0));
assert(test_mod(0.0, -Infinity, 0.0, 0.0, 0));
assert(test_mod(0.0, NaN, NaN, 0.0, 0));
assert(test_mod(-0.0, 0.0, NaN, 0.0, INVALID));
assert(test_mod(-0.0, -0.0, NaN, 0.0, INVALID));
assert(test_mod(-0.0, Infinity, -0.0, 0.0, 0));
assert(test_mod(-0.0, -Infinity, -0.0, 0.0, 0));
assert(test_mod(-0.0, NaN, NaN, 0.0, 0));
assert(test_mod(1.0, 0.0, NaN, 0.0, INVALID));
assert(test_mod(-1.0, 0.0, NaN, 0.0, INVALID));
assert(test_mod(Infinity, 0.0, NaN, 0.0, INVALID));
assert(test_mod(-Infinity, 0.0, NaN, 0.0, INVALID));
assert(test_mod(NaN, 0.0, NaN, 0.0, 0));
assert(test_mod(-1.0, -0.0, NaN, 0.0, INVALID));
assert(test_mod(Infinity, -0.0, NaN, 0.0, INVALID));
assert(test_mod(-Infinity, -0.0, NaN, 0.0, INVALID));
assert(test_mod(NaN, -0.0, NaN, 0.0, 0));
assert(test_mod(Infinity, 2.0, NaN, 0.0, INVALID));
assert(test_mod(Infinity, -0.5, NaN, 0.0, INVALID));
assert(test_mod(Infinity, NaN, NaN, 0.0, 0));
assert(test_mod(-Infinity, 2.0, NaN, 0.0, INVALID));
assert(test_mod(-Infinity, -0.5, NaN, 0.0, INVALID));
assert(test_mod(-Infinity, NaN, NaN, 0.0, 0));
assert(test_mod(NaN, NaN, NaN, 0.0, 0));
assert(test_mod(1.0, NaN, NaN, 0.0, 0));
assert(test_mod(-1.0, NaN, NaN, 0.0, 0));
assert(test_mod(1.0, Infinity, 1.0, 0.0, 0));
assert(test_mod(-1.0, Infinity, -1.0, 0.0, 0));
assert(test_mod(Infinity, Infinity, NaN, 0.0, INVALID));
assert(test_mod(-Infinity, Infinity, NaN, 0.0, INVALID));
assert(test_mod(1.0, -Infinity, 1.0, 0.0, 0));
assert(test_mod(-1.0, -Infinity, -1.0, 0.0, 0));
assert(test_mod(Infinity, -Infinity, NaN, 0.0, INVALID));
assert(test_mod(-Infinity, -Infinity, NaN, 0.0, INVALID));
assert(test_mod(1.75, 0.5, 0.25, 0.0, 0));
assert(test_mod(-1.75, 0.5, -0.25, 0.0, 0));
assert(test_mod(1.75, -0.5, 0.25, 0.0, 0));
assert(test_mod(-1.75, -0.5, -0.25, 0.0, 0));

// mod(x,x) = 0
assert(test_mod(reinterpret<f64>(0x0010000000000000), reinterpret<f64>(0x0010000000000000),  0.0, 0.0, 0));
assert(test_mod(reinterpret<f64>(0x0010000000000000), reinterpret<f64>(0x8010000000000000),  0.0, 0.0, 0));
assert(test_mod(reinterpret<f64>(0x8010000000000000), reinterpret<f64>(0x0010000000000000), -0.0, 0.0, 0));
assert(test_mod(reinterpret<f64>(0x8010000000000000), reinterpret<f64>(0x8010000000000000), -0.0, 0.0, 0));
assert(test_mod(reinterpret<f64>(0x7FEFFFFFFFFFFFFF), reinterpret<f64>(0x7FEFFFFFFFFFFFFF),  0.0, 0.0, 0));
assert(test_mod(reinterpret<f64>(0x7FEFFFFFFFFFFFFF), reinterpret<f64>(0xFFEFFFFFFFFFFFFF),  0.0, 0.0, 0));
assert(test_mod(reinterpret<f64>(0xFFEFFFFFFFFFFFFF), reinterpret<f64>(0x7FEFFFFFFFFFFFFF), -0.0, 0.0, 0));
assert(test_mod(reinterpret<f64>(0xFFEFFFFFFFFFFFFF), reinterpret<f64>(0xFFEFFFFFFFFFFFFF), -0.0, 0.0, 0));

// mod(0,y) = 0 for all y except nan,0
assert(test_mod(reinterpret<f64>(0x0000000000000000), reinterpret<f64>(0x0010000000000000),  0.0, 0.0, 0));
assert(test_mod(reinterpret<f64>(0x0000000000000000), reinterpret<f64>(0x7FEFFFFFFFFFFFFF),  0.0, 0.0, 0));
assert(test_mod(reinterpret<f64>(0x0000000000000000), reinterpret<f64>(0x8010000000000000),  0.0, 0.0, 0));
assert(test_mod(reinterpret<f64>(0x0000000000000000), reinterpret<f64>(0xFFEFFFFFFFFFFFFF),  0.0, 0.0, 0));
assert(test_mod(reinterpret<f64>(0x8000000000000000), reinterpret<f64>(0x0010000000000000), -0.0, 0.0, 0));
assert(test_mod(reinterpret<f64>(0x8000000000000000), reinterpret<f64>(0x7FEFFFFFFFFFFFFF), -0.0, 0.0, 0));
assert(test_mod(reinterpret<f64>(0x8000000000000000), reinterpret<f64>(0x8010000000000000), -0.0, 0.0, 0));
assert(test_mod(reinterpret<f64>(0x8000000000000000), reinterpret<f64>(0xFFEFFFFFFFFFFFFF), -0.0, 0.0, 0));

// mod(max, max-ulp) = ulp
assert(test_mod(reinterpret<f64>(0x7FEFFFFFFFFFFFFF), reinterpret<f64>(0x7FEFFFFFFFFFFFFE), reinterpret<f64>(0x7CA0000000000000), 0.0, 0));
assert(test_mod(reinterpret<f64>(0xFFEFFFFFFFFFFFFF), reinterpret<f64>(0x7FEFFFFFFFFFFFFE), reinterpret<f64>(0xFCA0000000000000), 0.0, 0));
// mod(max, max/2 + ulp) = max/2 - ulp
assert(test_mod(reinterpret<f64>(0x7FEFFFFFFFFFFFFF), reinterpret<f64>(0xFFE0000000000000), reinterpret<f64>(0x7FDFFFFFFFFFFFFE), 0.0, 0));
assert(test_mod(reinterpret<f64>(0xFFEFFFFFFFFFFFFF), reinterpret<f64>(0xFFE0000000000000), reinterpret<f64>(0xFFDFFFFFFFFFFFFE), 0.0, 0));
// mod(max, max/2) = 0
assert(test_mod(reinterpret<f64>(0x7FEFFFFFFFFFFFFF), reinterpret<f64>(0x7FDFFFFFFFFFFFFF), reinterpret<f64>(0x0000000000000000), 0.0, 0));
assert(test_mod(reinterpret<f64>(0xFFEFFFFFFFFFFFFF), reinterpret<f64>(0x7FDFFFFFFFFFFFFF), reinterpret<f64>(0x8000000000000000), 0.0, 0));
// mod(max, max/2 - ulp) = 2ulp
assert(test_mod(reinterpret<f64>(0x7FEFFFFFFFFFFFFF), reinterpret<f64>(0xFFDFFFFFFFFFFFFE), reinterpret<f64>(0x7CA0000000000000), 0.0, 0));
assert(test_mod(reinterpret<f64>(0xFFEFFFFFFFFFFFFF), reinterpret<f64>(0xFFDFFFFFFFFFFFFE), reinterpret<f64>(0xFCA0000000000000), 0.0, 0));
// mod(max/2 + ulp,max) = max/2 + ulp
assert(test_mod(reinterpret<f64>(0x7FE0000000000000), reinterpret<f64>(0x7FEFFFFFFFFFFFFF), reinterpret<f64>(0x7FE0000000000000), 0.0, 0));
assert(test_mod(reinterpret<f64>(0xFFE0000000000000), reinterpret<f64>(0x7FEFFFFFFFFFFFFF), reinterpret<f64>(0xFFE0000000000000), 0.0, 0));
// mod(max/2, max) = max/2
assert(test_mod(reinterpret<f64>(0x7FDFFFFFFFFFFFFF), reinterpret<f64>(0xFFEFFFFFFFFFFFFF), reinterpret<f64>(0x7FDFFFFFFFFFFFFF), 0.0, 0));
assert(test_mod(reinterpret<f64>(0xFFDFFFFFFFFFFFFF), reinterpret<f64>(0xFFEFFFFFFFFFFFFF), reinterpret<f64>(0xFFDFFFFFFFFFFFFF), 0.0, 0));
// mod(max/2 - ulp, max) = max/2 - ulp
assert(test_mod(reinterpret<f64>(0x7FDFFFFFFFFFFFFE), reinterpret<f64>(0x7FEFFFFFFFFFFFFF), reinterpret<f64>(0x7FDFFFFFFFFFFFFE), 0.0, 0));
assert(test_mod(reinterpret<f64>(0xFFDFFFFFFFFFFFFE), reinterpret<f64>(0x7FEFFFFFFFFFFFFF), reinterpret<f64>(0xFFDFFFFFFFFFFFFE), 0.0, 0));
// mod(max-ulp, max)= max - ulp
assert(test_mod(reinterpret<f64>(0x7FEFFFFFFFFFFFFE), reinterpret<f64>(0xFFEFFFFFFFFFFFFF), reinterpret<f64>(0x7FEFFFFFFFFFFFFE), 0.0, 0));
assert(test_mod(reinterpret<f64>(0xFFEFFFFFFFFFFFFE), reinterpret<f64>(0xFFEFFFFFFFFFFFFF), reinterpret<f64>(0xFFEFFFFFFFFFFFFE), 0.0, 0));
// mod(max-ulp, max/2) = max/2 - 2ulp
assert(test_mod(reinterpret<f64>(0x7FEFFFFFFFFFFFFE), reinterpret<f64>(0x7FDFFFFFFFFFFFFF), reinterpret<f64>(0x7FDFFFFFFFFFFFFD), 0.0, 0));
assert(test_mod(reinterpret<f64>(0xFFEFFFFFFFFFFFFE), reinterpret<f64>(0x7FDFFFFFFFFFFFFF), reinterpret<f64>(0xFFDFFFFFFFFFFFFD), 0.0, 0));
// mod(x, 1) for small x = n+0.5
assert(test_mod(reinterpret<f64>(0x401E000000000000), 1.0,  0.5, 0.0, 0));
assert(test_mod(reinterpret<f64>(0x401A000000000000), 1.0,  0.5, 0.0, 0));
assert(test_mod(reinterpret<f64>(0x4016000000000000), 1.0,  0.5, 0.0, 0));
assert(test_mod(reinterpret<f64>(0x4012000000000000), 1.0,  0.5, 0.0, 0));
assert(test_mod(reinterpret<f64>(0xC01E000000000000), 1.0, -0.5, 0.0, 0));
assert(test_mod(reinterpret<f64>(0xC01A000000000000), 1.0, -0.5, 0.0, 0));
assert(test_mod(reinterpret<f64>(0xC016000000000000), 1.0, -0.5, 0.0, 0));
assert(test_mod(reinterpret<f64>(0xC012000000000000), 1.0, -0.5, 0.0, 0));

assert(test_mod(reinterpret<f64>(0x000FFFFFFFFFFFFC), reinterpret<f64>(0x000FFFFFFFFFFFFE), reinterpret<f64>(0x000FFFFFFFFFFFFC), 0.0, 0));
assert(test_mod(reinterpret<f64>(0x000FFFFFFFFFFFFC), reinterpret<f64>(0x800FFFFFFFFFFFFE), reinterpret<f64>(0x000FFFFFFFFFFFFC), 0.0, 0));
assert(test_mod(reinterpret<f64>(0x000FFFFFFFFFFFFF), reinterpret<f64>(0x0000000000000003), reinterpret<f64>(0x0000000000000000), 0.0, 0));
assert(test_mod(reinterpret<f64>(0x000FFFFFFFFFFFFF), reinterpret<f64>(0x001FFFFFFFFFFFFF), reinterpret<f64>(0x000FFFFFFFFFFFFF), 0.0, 0));
assert(test_mod(reinterpret<f64>(0x000FFFFFFFFFFFFF), reinterpret<f64>(0x7FF0000000000000), reinterpret<f64>(0x000FFFFFFFFFFFFF), 0.0, 0));
assert(test_mod(reinterpret<f64>(0x000FFFFFFFFFFFFF), reinterpret<f64>(0x8000000000000003), reinterpret<f64>(0x0000000000000000), 0.0, 0));
assert(test_mod(reinterpret<f64>(0x0010000000000000), reinterpret<f64>(0x0000000000000003), reinterpret<f64>(0x0000000000000001), 0.0, 0));
assert(test_mod(reinterpret<f64>(0x0010000000000000), reinterpret<f64>(0x000FFFFFFFFFFFFE), reinterpret<f64>(0x0000000000000002), 0.0, 0));
assert(test_mod(reinterpret<f64>(0x0010000000000000), reinterpret<f64>(0x001FFFFFFFFFFFFF), reinterpret<f64>(0x0010000000000000), 0.0, 0));
assert(test_mod(reinterpret<f64>(0x0010000000000000), reinterpret<f64>(0x8000000000000003), reinterpret<f64>(0x0000000000000001), 0.0, 0));
assert(test_mod(reinterpret<f64>(0x0010000000000001), reinterpret<f64>(0x000FFFFFFFFFFFFE), reinterpret<f64>(0x0000000000000003), 0.0, 0));
assert(test_mod(reinterpret<f64>(0x0010000000000002), reinterpret<f64>(0x0000000000000003), reinterpret<f64>(0x0000000000000000), 0.0, 0));
assert(test_mod(reinterpret<f64>(0x0010000000000002), reinterpret<f64>(0x8000000000000003), reinterpret<f64>(0x0000000000000000), 0.0, 0));
assert(test_mod(reinterpret<f64>(0x0010000000000003), reinterpret<f64>(0x0000000000000003), reinterpret<f64>(0x0000000000000001), 0.0, 0));
assert(test_mod(reinterpret<f64>(0x0010000000000003), reinterpret<f64>(0x0010000000000005), reinterpret<f64>(0x0010000000000003), 0.0, 0));
assert(test_mod(reinterpret<f64>(0x0010000000000003), reinterpret<f64>(0x8000000000000003), reinterpret<f64>(0x0000000000000001), 0.0, 0));
assert(test_mod(reinterpret<f64>(0x0010000000000004), reinterpret<f64>(0x0010000000000005), reinterpret<f64>(0x0010000000000004), 0.0, 0));
assert(test_mod(reinterpret<f64>(0x0010000000000006), reinterpret<f64>(0x0010000000000005), reinterpret<f64>(0x0000000000000001), 0.0, 0));
assert(test_mod(reinterpret<f64>(0x001FFFFFFFFFFFFF), reinterpret<f64>(0x0020000000000000), reinterpret<f64>(0x001FFFFFFFFFFFFF), 0.0, 0));
assert(test_mod(reinterpret<f64>(0x009FFFFFFFFFFFFF), reinterpret<f64>(0x0090000000000000), reinterpret<f64>(0x008FFFFFFFFFFFFE), 0.0, 0));

// Mathf.mod ///////////////////////////////////////////////////////////////////////////////////////

function test_modf(left: f32, right: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.mod(left, right), expected, error, flags);
}

// sanity
assert(test_modf(-8.066848755, 4.535662651, -3.531186104, 0.0, 0));
assert(test_modf(4.345239639, -8.887990952, 4.345239639, 0.0, 0));
assert(test_modf(-8.381433487, -2.763607264, -0.09061169624, 0.0, 0));
assert(test_modf(-6.531673431, 4.5675354, -1.964138031, 0.0, 0));
assert(test_modf(9.267057419, 4.811392307, 4.455665112, 0.0, 0));
assert(test_modf(-6.450045586, 0.6620717645, -0.4913997054, 0.0, 0));
assert(test_modf(7.858890057, 0.05215452611, 0.03571113944, 0.0, 0));
assert(test_modf(-0.792054534, 7.676402569, -0.792054534, 0.0, 0));
assert(test_modf(0.6157026887, 2.011902571, 0.6157026887, 0.0, 0));
assert(test_modf(-0.5587586761, 0.03223983198, -0.01068153232, 0.0, 0));

// special
assert(test_modf(0.0, 1.0, 0.0, 0.0, 0));
assert(test_modf(-0.0, 1.0, -0.0, 0.0, 0));
assert(test_modf(0.5, 1.0, 0.5, 0.0, 0));
assert(test_modf(-0.5, 1.0, -0.5, 0.0, 0));
assert(test_modf(1.0, 1.0, 0.0, 0.0, 0));
assert(test_modf(-1.0, 1.0, -0.0, 0.0, 0));
assert(test_modf(1.5, 1.0, 0.5, 0.0, 0));
assert(test_modf(-1.5, 1.0, -0.5, 0.0, 0));
assert(test_modf(2.0, 1.0, 0.0, 0.0, 0));
assert(test_modf(-2.0, 1.0, -0.0, 0.0, 0));
assert(test_modf(Infinity, 1.0, NaN, 0.0, INVALID));
assert(test_modf(-Infinity, 1.0, NaN, 0.0, INVALID));
assert(test_modf(NaN, 1.0, NaN, 0.0, 0));
assert(test_modf(0.0, -1.0, 0.0, 0.0, 0));
assert(test_modf(-0.0, -1.0, -0.0, 0.0, 0));
assert(test_modf(0.5, -1.0, 0.5, 0.0, 0));
assert(test_modf(-0.5, -1.0, -0.5, 0.0, 0));
assert(test_modf(1.0, -1.0, 0.0, 0.0, 0));
assert(test_modf(-1.0, -1.0, -0.0, 0.0, 0));
assert(test_modf(1.5, -1.0, 0.5, 0.0, 0));
assert(test_modf(-1.5, -1.0, -0.5, 0.0, 0));
assert(test_modf(2.0, -1.0, 0.0, 0.0, 0));
assert(test_modf(-2.0, -1.0, -0.0, 0.0, 0));
assert(test_modf(Infinity, -1.0, NaN, 0.0, INVALID));
assert(test_modf(-Infinity, -1.0, NaN, 0.0, INVALID));
assert(test_modf(NaN, -1.0, NaN, 0.0, 0));
assert(test_modf(0.0, 0.0, NaN, 0.0, INVALID));
assert(test_modf(0.0, -0.0, NaN, 0.0, INVALID));
assert(test_modf(0.0, Infinity, 0.0, 0.0, 0));
assert(test_modf(0.0, -Infinity, 0.0, 0.0, 0));
assert(test_modf(0.0, NaN, NaN, 0.0, 0));
assert(test_modf(-0.0, 0.0, NaN, 0.0, INVALID));
assert(test_modf(-0.0, -0.0, NaN, 0.0, INVALID));
assert(test_modf(-0.0, Infinity, -0.0, 0.0, 0));
assert(test_modf(-0.0, -Infinity, -0.0, 0.0, 0));
assert(test_modf(-0.0, NaN, NaN, 0.0, 0));
assert(test_modf(1.0, 0.0, NaN, 0.0, INVALID));
assert(test_modf(-1.0, 0.0, NaN, 0.0, INVALID));
assert(test_modf(Infinity, 0.0, NaN, 0.0, INVALID));
assert(test_modf(-Infinity, 0.0, NaN, 0.0, INVALID));
assert(test_modf(NaN, 0.0, NaN, 0.0, 0));
assert(test_modf(-1.0, -0.0, NaN, 0.0, INVALID));
assert(test_modf(Infinity, -0.0, NaN, 0.0, INVALID));
assert(test_modf(-Infinity, -0.0, NaN, 0.0, INVALID));
assert(test_modf(NaN, -0.0, NaN, 0.0, 0));
assert(test_modf(Infinity, 2.0, NaN, 0.0, INVALID));
assert(test_modf(Infinity, -0.5, NaN, 0.0, INVALID));
assert(test_modf(Infinity, NaN, NaN, 0.0, 0));
assert(test_modf(-Infinity, 2.0, NaN, 0.0, INVALID));
assert(test_modf(-Infinity, -0.5, NaN, 0.0, INVALID));
assert(test_modf(-Infinity, NaN, NaN, 0.0, 0));
assert(test_modf(NaN, NaN, NaN, 0.0, 0));
assert(test_modf(1.0, NaN, NaN, 0.0, 0));
assert(test_modf(-1.0, NaN, NaN, 0.0, 0));
assert(test_modf(1.0, Infinity, 1.0, 0.0, 0));
assert(test_modf(-1.0, Infinity, -1.0, 0.0, 0));
assert(test_modf(Infinity, Infinity, NaN, 0.0, INVALID));
assert(test_modf(-Infinity, Infinity, NaN, 0.0, INVALID));
assert(test_modf(1.0, -Infinity, 1.0, 0.0, 0));
assert(test_modf(-1.0, -Infinity, -1.0, 0.0, 0));
assert(test_modf(Infinity, -Infinity, NaN, 0.0, INVALID));
assert(test_modf(-Infinity, -Infinity, NaN, 0.0, INVALID));
assert(test_modf(1.75, 0.5, 0.25, 0.0, 0));
assert(test_modf(-1.75, 0.5, -0.25, 0.0, 0));
assert(test_modf(1.75, -0.5, 0.25, 0.0, 0));
assert(test_modf(-1.75, -0.5, -0.25, 0.0, 0));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.pow
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_pow(left: f64, right: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.pow(left, right), expected, error, flags) &&
  (!js || check<f64>(    JSMath.pow(left, right), expected, error, flags));
}

// sanity
assert(test_pow(-8.06684839057968084, 4.53566256067686879, NaN, 0.0, INVALID));
assert(test_pow(4.34523984933830487, -8.88799136300345083, 0.00000213471188255872853, 0.325016021728515625, INEXACT));
assert(test_pow(-8.38143342755524934, -2.76360733737958819, NaN, 0.0, INVALID));
assert(test_pow(-6.53167358191348413, 4.56753527684274374, NaN, 0.0, INVALID));
assert(test_pow(9.26705696697258574, 4.81139208435979615, 44909.2994151296589, -0.266590803861618042, INEXACT));
assert(test_pow(-6.45004555606023633, 0.662071792337673881, NaN, 0.0, INVALID));
assert(test_pow(7.85889025304169664, 0.0521545267500622481, 1.11351774134586523, -0.371686071157455444, INEXACT));
assert(test_pow(-0.792054511984895959, 7.67640268511753998, NaN, 0.0, INVALID));
assert(test_pow(0.615702673197924044, 2.01190257903248026, 0.376907735213801831, 0.32473301887512207, INEXACT));
assert(test_pow(-0.558758682360915193, 0.0322398306026380407, NaN, 0.0, INVALID));

// special
assert(test_pow(0.0, NaN, NaN, 0.0, 0));
assert(test_pow(0.0, Infinity, 0.0, 0.0, 0));
assert(test_pow(0.0, 3.0, 0.0, 0.0, 0));
assert(test_pow(0.0, 2.0, 0.0, 0.0, 0));
assert(test_pow(0.0, 1.0, 0.0, 0.0, 0));
assert(test_pow(0.0, 0.5, 0.0, 0.0, 0));
assert(test_pow(0.0, 0.0, 1.0, 0.0, 0));
assert(test_pow(0.0, -0.0, 1.0, 0.0, 0));
assert(test_pow(0.0, -0.5, Infinity, 0.0, DIVBYZERO));
assert(test_pow(0.0, -1.0, Infinity, 0.0, DIVBYZERO));
assert(test_pow(0.0, -2.0, Infinity, 0.0, DIVBYZERO));
assert(test_pow(0.0, -3.0, Infinity, 0.0, DIVBYZERO));
assert(test_pow(0.0, -4.0, Infinity, 0.0, DIVBYZERO));
assert(test_pow(0.0, -Infinity, Infinity, 0.0, 0));
assert(test_pow(-0.0, NaN, NaN, 0.0, 0));
assert(test_pow(-0.0, Infinity, 0.0, 0.0, 0));
assert(test_pow(-0.0, 3.0, -0.0, 0.0, 0));
assert(test_pow(-0.0, 2.0, 0.0, 0.0, 0));
assert(test_pow(-0.0, 1.0, -0.0, 0.0, 0));
assert(test_pow(-0.0, 0.5, 0.0, 0.0, 0));
assert(test_pow(-0.0, 0.0, 1.0, 0.0, 0));
assert(test_pow(-0.0, -0.0, 1.0, 0.0, 0));
assert(test_pow(-0.0, -0.5, Infinity, 0.0, DIVBYZERO));
assert(test_pow(-0.0, -1.0, -Infinity, 0.0, DIVBYZERO));
assert(test_pow(-0.0, -2.0, Infinity, 0.0, DIVBYZERO));
assert(test_pow(-0.0, -3.0, -Infinity, 0.0, DIVBYZERO));
assert(test_pow(-0.0, -4.0, Infinity, 0.0, DIVBYZERO));
assert(test_pow(-0.0, -Infinity, Infinity, 0.0, 0));
assert(test_pow(NaN, 0.0, 1.0, 0.0, 0));
assert(test_pow(Infinity, 0.0, 1.0, 0.0, 0));
assert(test_pow(-Infinity, 0.0, 1.0, 0.0, 0));
assert(test_pow(1.0, 0.0, 1.0, 0.0, 0));
assert(test_pow(-1.0, 0.0, 1.0, 0.0, 0));
assert(test_pow(-0.5, 0.0, 1.0, 0.0, 0));
assert(test_pow(NaN, -0.0, 1.0, 0.0, 0));
assert(test_pow(Infinity, -0.0, 1.0, 0.0, 0));
assert(test_pow(-Infinity, -0.0, 1.0, 0.0, 0));
assert(test_pow(1.0, -0.0, 1.0, 0.0, 0));
assert(test_pow(-1.0, -0.0, 1.0, 0.0, 0));
assert(test_pow(-0.5, -0.0, 1.0, 0.0, 0));
assert(test_pow(-1.0, NaN, NaN, 0.0, 0));
assert(test_pow(-1.0, Infinity, NaN, 0.0, 0));  // C: 1.0, JS: NaN
assert(test_pow(-1.0, -Infinity, NaN, 0.0, 0)); // C: 1.0, JS: NaN
assert(test_pow(-1.0, 2.0, 1.0, 0.0, 0));
assert(test_pow(-1.0, -1.0, -1.0, 0.0, 0));
assert(test_pow(-1.0, -2.0, 1.0, 0.0, 0));
assert(test_pow(-1.0, -3.0, -1.0, 0.0, 0));
assert(test_pow(-1.0, 0.5, NaN, 0.0, INVALID));
assert(test_pow(1.0, NaN, NaN, 0.0, 0));        // C: 1.0, JS: NaN
assert(test_pow(1.0, Infinity, NaN, 0.0, 0));   // C: 1.0, JS: NaN
assert(test_pow(1.0, -Infinity, NaN, 0.0, 0));  // C: 1.0, JS: NaN
assert(test_pow(1.0, 3.0, 1.0, 0.0, 0));
assert(test_pow(1.0, 0.5, 1.0, 0.0, 0));
assert(test_pow(1.0, -0.5, 1.0, 0.0, 0));
assert(test_pow(1.0, -3.0, 1.0, 0.0, 0));
assert(test_pow(-0.5, 0.5, NaN, 0.0, INVALID));
assert(test_pow(-0.5, 1.5, NaN, 0.0, INVALID));
assert(test_pow(-0.5, 2.0, 0.25, 0.0, 0));
assert(test_pow(-0.5, 3.0, -0.125, 0.0, 0));
assert(test_pow(-0.5, Infinity, 0.0, 0.0, 0));
assert(test_pow(-0.5, -Infinity, Infinity, 0.0, 0));
assert(test_pow(-0.5, NaN, NaN, 0.0, 0));
assert(test_pow(0.5, Infinity, 0.0, 0.0, 0));
assert(test_pow(0.5, -Infinity, Infinity, 0.0, 0));
assert(test_pow(0.5, NaN, NaN, 0.0, 0));
assert(test_pow(1.5, Infinity, Infinity, 0.0, 0));
assert(test_pow(1.5, -Infinity, 0.0, 0.0, 0));
assert(test_pow(1.5, NaN, NaN, 0.0, 0));
assert(test_pow(Infinity, NaN, NaN, 0.0, 0));
assert(test_pow(Infinity, Infinity, Infinity, 0.0, 0));
assert(test_pow(Infinity, -Infinity, 0.0, 0.0, 0));
assert(test_pow(Infinity, 3.0, Infinity, 0.0, 0));
assert(test_pow(Infinity, 2.0, Infinity, 0.0, 0));
assert(test_pow(Infinity, 1.0, Infinity, 0.0, 0));
assert(test_pow(Infinity, 0.5, Infinity, 0.0, 0));
assert(test_pow(Infinity, -0.5, 0.0, 0.0, 0));
assert(test_pow(Infinity, -1.0, 0.0, 0.0, 0));
assert(test_pow(Infinity, -2.0, 0.0, 0.0, 0));
assert(test_pow(-Infinity, NaN, NaN, 0.0, 0));
assert(test_pow(-Infinity, Infinity, Infinity, 0.0, 0));
assert(test_pow(-Infinity, -Infinity, 0.0, 0.0, 0));
assert(test_pow(-Infinity, 3.0, -Infinity, 0.0, 0));
assert(test_pow(-Infinity, 2.0, Infinity, 0.0, 0));
assert(test_pow(-Infinity, 1.0, -Infinity, 0.0, 0));
assert(test_pow(-Infinity, 0.5, Infinity, 0.0, 0));
assert(test_pow(-Infinity, -0.5, 0.0, 0.0, 0));
assert(test_pow(-Infinity, -1.0, -0.0, 0.0, 0));
assert(test_pow(-Infinity, -2.0, 0.0, 0.0, 0));
assert(test_pow(NaN, 1.0, NaN, 0.0, 0));
assert(test_pow(NaN, -1.0, NaN, 0.0, 0));
assert(test_pow(-2.0, 1.0, -2.0, 0.0, 0));
assert(test_pow(-2.0, -1.0, -0.5, 0.0, 0));

// Fast paths
assert(NativeMath.pow(+0.0,+0.0) == 1.0);
assert(NativeMath.pow(-0.0,+0.0) == 1.0);
assert(NativeMath.pow(-0.0,-0.0) == 1.0);
assert(NativeMath.pow(+0.0,-0.0) == 1.0);
assert(NativeMath.pow(-1.0, 0.0) == 1.0);
assert(NativeMath.pow(+Infinity, 0.0) == 1.0);
assert(NativeMath.pow(-Infinity, 0.0) == 1.0);
assert(NativeMath.pow(NaN, 0.0) == 1.0);

assert(NativeMath.pow(+0.0,+1.0) == +0.0);
assert(NativeMath.pow(-0.0,+1.0) == -0.0);
assert(NativeMath.pow(-1.0, 1.0) == -1.0);
assert(NativeMath.pow(+Infinity, 1.0) == +Infinity);
assert(NativeMath.pow(-Infinity, 1.0) == -Infinity);
assert(isNaN(NativeMath.pow(NaN, 1.0)));

assert(NativeMath.pow(+0.0,-1.0) == +Infinity);
assert(NativeMath.pow(-0.0,-1.0) == -Infinity);
assert(NativeMath.pow(-1.0,-1.0) == -1.0);
assert(NativeMath.pow( 0.5,-1.0) == +2.0);
assert(NativeMath.pow( 1.0,-1.0) == +1.0);
assert(NativeMath.pow(+Infinity,-1.0) == +0.0);
assert(NativeMath.pow(-Infinity,-1.0) == -0.0);
assert(isNaN(NativeMath.pow(NaN,-1.0)));

assert(NativeMath.pow(+0.0, 2.0) == +0.0);
assert(NativeMath.pow(-0.0, 2.0) == +0.0);
assert(NativeMath.pow(-1.0, 2.0) == +1.0);
assert(NativeMath.pow( 0.5, 2.0) == +0.25);
assert(NativeMath.pow( 1.0, 2.0) == +1.0);
assert(NativeMath.pow(+Infinity, 2.0) == +Infinity);
assert(NativeMath.pow(-Infinity, 2.0) == +Infinity);
assert(isNaN(NativeMath.pow(NaN, 2.0)));

assert(NativeMath.pow(+0.0, 0.5) == +0.0);
assert(NativeMath.pow(-0.0, 0.5) == +0.0);
assert(isNaN(NativeMath.pow(-1.0, 0.5)));
assert(NativeMath.pow( 4.0, 0.5) == +2.0);
assert(NativeMath.pow( 1.0, 0.5) == +1.0);
assert(NativeMath.pow(+Infinity, 0.5) == +Infinity);
assert(NativeMath.pow(-Infinity, 0.5) == +Infinity);
assert(isNaN(NativeMath.pow(NaN, 0.5)));

// Mathf.pow ///////////////////////////////////////////////////////////////////////////////////////

function test_powf(left: f32, right: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.pow(left, right), expected, error, flags);
}

// sanity
assert(test_powf(-8.0668487550, 4.535662651,                 NaN,            0.0, INVALID));
assert(test_powf( 4.3452396390,-8.887990952,   0.000002134714123,   0.1436440796, INEXACT));
assert(test_powf(-8.3814334870,-2.763607264,                 NaN,            0.0, INVALID));
assert(test_powf(-6.5316734310, 4.5675354,                   NaN,            0.0, INVALID));
assert(test_powf( 9.2670574190, 4.811392307,         44909.33203, -0.05356409028, INEXACT));
assert(test_powf(-6.4500455860, 0.6620717645,                NaN,            0.0, INVALID));
assert(test_powf( 7.8588900570, 0.05215452611,       1.113517761,   0.1912208945, INEXACT));
assert(test_powf(-0.7920545340, 7.676402569,                 NaN,            0.0, INVALID));
assert(test_powf( 0.6157026887, 2.011902571,        0.3769077659,   0.3371490538, INEXACT));
assert(test_powf(-0.5587586761, 0.03223983198,               NaN,            0.0, INVALID));

// special
assert(test_powf(      0.0,       NaN,       NaN, 0.0, 0));
assert(test_powf(      0.0,  Infinity,       0.0, 0.0, 0));
assert(test_powf(      0.0,       3.0,       0.0, 0.0, 0));
assert(test_powf(      0.0,       2.0,       0.0, 0.0, 0));
assert(test_powf(      0.0,       1.0,       0.0, 0.0, 0));
assert(test_powf(      0.0,       0.5,       0.0, 0.0, 0));
assert(test_powf(      0.0,       0.0,       1.0, 0.0, 0));
assert(test_powf(      0.0,      -0.0,       1.0, 0.0, 0));
assert(test_powf(      0.0,      -0.5,  Infinity, 0.0, DIVBYZERO));
assert(test_powf(      0.0,      -1.0,  Infinity, 0.0, DIVBYZERO));
assert(test_powf(      0.0,      -2.0,  Infinity, 0.0, DIVBYZERO));
assert(test_powf(      0.0,      -3.0,  Infinity, 0.0, DIVBYZERO));
assert(test_powf(      0.0,      -4.0,  Infinity, 0.0, DIVBYZERO));
assert(test_powf(      0.0, -Infinity,  Infinity, 0.0, 0));
assert(test_powf(     -0.0,       NaN,       NaN, 0.0, 0));
assert(test_powf(     -0.0,  Infinity,       0.0, 0.0, 0));
assert(test_powf(     -0.0,       3.0,      -0.0, 0.0, 0));
assert(test_powf(     -0.0,       2.0,       0.0, 0.0, 0));
assert(test_powf(     -0.0,       1.0,      -0.0, 0.0, 0));
assert(test_powf(     -0.0,       0.5,       0.0, 0.0, 0));
assert(test_powf(     -0.0,       0.0,       1.0, 0.0, 0));
assert(test_powf(     -0.0,      -0.0,       1.0, 0.0, 0));
assert(test_powf(     -0.0,      -0.5,  Infinity, 0.0, DIVBYZERO));
assert(test_powf(     -0.0,      -1.0, -Infinity, 0.0, DIVBYZERO));
assert(test_powf(     -0.0,      -2.0,  Infinity, 0.0, DIVBYZERO));
assert(test_powf(     -0.0,      -3.0, -Infinity, 0.0, DIVBYZERO));
assert(test_powf(     -0.0,      -4.0,  Infinity, 0.0, DIVBYZERO));
assert(test_powf(     -0.0, -Infinity,  Infinity, 0.0, 0));
assert(test_powf(      NaN,       0.0,       1.0, 0.0, 0));
assert(test_powf( Infinity,       0.0,       1.0, 0.0, 0));
assert(test_powf(-Infinity,       0.0,       1.0, 0.0, 0));
assert(test_powf(      1.0,       0.0,       1.0, 0.0, 0));
assert(test_powf(     -1.0,       0.0,       1.0, 0.0, 0));
assert(test_powf(     -0.5,       0.0,       1.0, 0.0, 0));
assert(test_powf(      NaN,      -0.0,       1.0, 0.0, 0));
assert(test_powf( Infinity,      -0.0,       1.0, 0.0, 0));
assert(test_powf(-Infinity,      -0.0,       1.0, 0.0, 0));
assert(test_powf(      1.0,      -0.0,       1.0, 0.0, 0));
assert(test_powf(     -1.0,      -0.0,       1.0, 0.0, 0));
assert(test_powf(     -0.5,      -0.0,       1.0, 0.0, 0));
assert(test_powf(     -1.0,       NaN,       NaN, 0.0, 0));
assert(test_powf(     -1.0,  Infinity,       NaN, 0.0, 0)); // C: 1.0, JS: NaN
assert(test_powf(     -1.0, -Infinity,       NaN, 0.0, 0)); // C: 1.0, JS: NaN
assert(test_powf(     -1.0,       2.0,       1.0, 0.0, 0));
assert(test_powf(     -1.0,      -1.0,      -1.0, 0.0, 0));
assert(test_powf(     -1.0,      -2.0,       1.0, 0.0, 0));
assert(test_powf(     -1.0,      -3.0,      -1.0, 0.0, 0));
assert(test_powf(     -1.0,       0.5,       NaN, 0.0, INVALID));
assert(test_powf(      1.0,       NaN,       NaN, 0.0, 0));  // C: 1.0, JS: NaN
assert(test_powf(      1.0,  Infinity,       NaN, 0.0, 0));  // C: 1.0, JS: NaN
assert(test_powf(      1.0, -Infinity,       NaN, 0.0, 0));  // C: 1.0, JS: NaN
assert(test_powf(      1.0,       3.0,       1.0, 0.0, 0));
assert(test_powf(      1.0,       0.5,       1.0, 0.0, 0));
assert(test_powf(      1.0,      -0.5,       1.0, 0.0, 0));
assert(test_powf(      1.0,      -3.0,       1.0, 0.0, 0));
assert(test_powf(     -0.5,       0.5,       NaN, 0.0, INVALID));
assert(test_powf(     -0.5,       1.5,       NaN, 0.0, INVALID));
assert(test_powf(     -0.5,       2.0,      0.25, 0.0, 0));
assert(test_powf(     -0.5,       3.0,    -0.125, 0.0, 0));
assert(test_powf(     -0.5,  Infinity,       0.0, 0.0, 0));
assert(test_powf(     -0.5, -Infinity,  Infinity, 0.0, 0));
assert(test_powf(     -0.5,       NaN,       NaN, 0.0, 0));
assert(test_powf(      0.5,  Infinity,       0.0, 0.0, 0));
assert(test_powf(      0.5, -Infinity,  Infinity, 0.0, 0));
assert(test_powf(      0.5,       NaN,       NaN, 0.0, 0));
assert(test_powf(      1.5,  Infinity,  Infinity, 0.0, 0));
assert(test_powf(      1.5, -Infinity,       0.0, 0.0, 0));
assert(test_powf(      1.5,       NaN,       NaN, 0.0, 0));
assert(test_powf( Infinity,       NaN,       NaN, 0.0, 0));
assert(test_powf( Infinity,  Infinity,  Infinity, 0.0, 0));
assert(test_powf( Infinity, -Infinity,       0.0, 0.0, 0));
assert(test_powf( Infinity,       3.0,  Infinity, 0.0, 0));
assert(test_powf( Infinity,       2.0,  Infinity, 0.0, 0));
assert(test_powf( Infinity,       1.0,  Infinity, 0.0, 0));
assert(test_powf( Infinity,       0.5,  Infinity, 0.0, 0));
assert(test_powf( Infinity,      -0.5,       0.0, 0.0, 0));
assert(test_powf( Infinity,      -1.0,       0.0, 0.0, 0));
assert(test_powf( Infinity,      -2.0,       0.0, 0.0, 0));
assert(test_powf(-Infinity,       NaN,       NaN, 0.0, 0));
assert(test_powf(-Infinity,  Infinity,  Infinity, 0.0, 0));
assert(test_powf(-Infinity, -Infinity,       0.0, 0.0, 0));
assert(test_powf(-Infinity,       3.0, -Infinity, 0.0, 0));
assert(test_powf(-Infinity,       2.0,  Infinity, 0.0, 0));
assert(test_powf(-Infinity,       1.0, -Infinity, 0.0, 0));
assert(test_powf(-Infinity,       0.5,  Infinity, 0.0, 0));
assert(test_powf(-Infinity,      -0.5,       0.0, 0.0, 0));
assert(test_powf(-Infinity,      -1.0,      -0.0, 0.0, 0));
assert(test_powf(-Infinity,      -2.0,       0.0, 0.0, 0));
assert(test_powf(      NaN,       1.0,       NaN, 0.0, 0));
assert(test_powf(      NaN,      -1.0,       NaN, 0.0, 0));
assert(test_powf(     -2.0,       1.0,      -2.0, 0.0, 0));
assert(test_powf(     -2.0,      -1.0,      -0.5, 0.0, 0));

// some ucb
assert(test_powf(                         0.0, 1.0,                          0.0, 0.0, 0));
assert(test_powf(                        -0.0, 1.0,                         -0.0, 0.0, 0));
assert(test_powf(reinterpret<f32>(0x00800000), 1.0, reinterpret<f32>(0x00800000), 0.0, 0));
assert(test_powf(reinterpret<f32>(0x80800000), 1.0, reinterpret<f32>(0x80800000), 0.0, 0));
assert(test_powf(reinterpret<f32>(0x7F7FFFFF), 1.0, reinterpret<f32>(0x7F7FFFFF), 0.0, 0));
assert(test_powf(reinterpret<f32>(0xFF7FFFFF), 1.0, reinterpret<f32>(0xFF7FFFFF), 0.0, 0));

assert(test_powf(                         0.0, reinterpret<f32>(0x7F7FFFFF), 0.0, 0.0, 0));
assert(test_powf(                         0.0, reinterpret<f32>(0x00800000), 0.0, 0.0, 0));
assert(test_powf(                        -0.0, reinterpret<f32>(0x7F7FFFFF), 0.0, 0.0, 0));
assert(test_powf(                        -0.0, reinterpret<f32>(0x41880000),-0.0, 0.0, 0));
assert(test_powf(                        -0.0,                          2.0, 0.0, 0.0, 0));
assert(test_powf(                        -0.0, reinterpret<f32>(0x00800000), 0.0, 0.0, 0));

assert(test_powf(reinterpret<f32>(0xBF8CCCCD), reinterpret<f32>(0x42CA0000), reinterpret<f32>(0xC66CDAD4), reinterpret<f32>(0xBE8F4B96), INEXACT));

assert(test_powf(reinterpret<f32>(0x41980000), reinterpret<f32>(0x40A00000), reinterpret<f32>(0x4A17210C), 0.0, 0));
assert(test_powf(reinterpret<f32>(0xC1980000), reinterpret<f32>(0x40A00000), reinterpret<f32>(0xCA17210C), 0.0, 0));
assert(test_powf(reinterpret<f32>(0xC3410000), reinterpret<f32>(0x40400000), reinterpret<f32>(0xCADB6482), 0.0, 0));
assert(test_powf(reinterpret<f32>(0xC4962000), reinterpret<f32>(0x40000000), reinterpret<f32>(0x49B01308), 0.0, 0));

assert(test_powf(reinterpret<f32>(0x40EA036E), reinterpret<f32>(0x4188FA68), reinterpret<f32>(0x580DE25B), reinterpret<f32>(0xBE198D91), INEXACT));
assert(test_powf(reinterpret<f32>(0x41966F98), reinterpret<f32>(0x405492A0), reinterpret<f32>(0x468568B4), reinterpret<f32>(0x3E9BCD25), INEXACT));
assert(test_powf(reinterpret<f32>(0x40E94F9F), reinterpret<f32>(0x4119B699), reinterpret<f32>(0x4D397562), reinterpret<f32>(0xBDDBB5A6), INEXACT));
assert(test_powf(reinterpret<f32>(0x417C8877), reinterpret<f32>(0x41946832), reinterpret<f32>(0x6464E6C5), reinterpret<f32>(0x3DBC02F2), INEXACT));
assert(test_powf(reinterpret<f32>(0x41051BE1), reinterpret<f32>(0x3ED6EA42), reinterpret<f32>(0x401BBCB2), reinterpret<f32>(0x3C1E499E), INEXACT));
assert(test_powf(reinterpret<f32>(0x40BA9990), reinterpret<f32>(0x41276511), reinterpret<f32>(0x4CC3DDA4), reinterpret<f32>(0xBABA9E01), INEXACT));
assert(test_powf(reinterpret<f32>(0x401A9C08), reinterpret<f32>(0x4188F979), reinterpret<f32>(0x4A5CE681), reinterpret<f32>(0x3E97A6B3), INEXACT));
assert(test_powf(reinterpret<f32>(0x3D1CF8A7), reinterpret<f32>(0x3C38642F), reinterpret<f32>(0x3F76C5E6), reinterpret<f32>(0xBEF7DBB5), INEXACT));
assert(test_powf(reinterpret<f32>(0x40AE4811), reinterpret<f32>(0x417D0909), reinterpret<f32>(0x52CBD7DB), reinterpret<f32>(0xBECE5DCB), INEXACT));
assert(test_powf(reinterpret<f32>(0x414DECA7), reinterpret<f32>(0x416EFF5C), reinterpret<f32>(0x5B054ECC), reinterpret<f32>(0x3DD5EB58), INEXACT));

assert(test_powf(                         NaN, 0.0,             1.0,             0.0, 0));
assert(test_powf(                         NaN, 0.0,             1.0,             0.0, 0));
assert(test_powf(                    Infinity, 0.0,             1.0,             0.0, 0));
assert(test_powf(                   -Infinity, 0.0,             1.0,             0.0, 0));
assert(test_powf(reinterpret<f32>(0x00000001), 0.0,             1.0,             0.0, 0));
assert(test_powf(reinterpret<f32>(0x80000001), 0.0,             1.0,             0.0, 0));

assert(test_powf(             NaN,             1.0,             NaN,             0.0, 0));
assert(test_powf(             NaN,             1.0,             NaN,             0.0, 0));
assert(test_powf(        Infinity,             1.0,        Infinity,             0.0, 0));
assert(test_powf(       -Infinity,             1.0,       -Infinity,             0.0, 0));

assert(test_powf(             NaN,             NaN,             NaN,             0.0, 0));
assert(test_powf(        Infinity,             NaN,             NaN,             0.0, 0));
assert(test_powf(       -Infinity,             NaN,             NaN,             0.0, 0));
assert(test_powf(             1.0,             NaN,             NaN,             0.0, 0)); // C: 1.0, JS: NaN
assert(test_powf(            -1.0,             NaN,             NaN,             0.0, 0));
assert(test_powf(            -0.0,             NaN,             NaN,             0.0, 0));
assert(test_powf(             0.0,             NaN,             NaN,             0.0, 0));

assert(test_powf(reinterpret<f32>(0x3F800001),        Infinity,        Infinity, 0.0, 0));
assert(test_powf(                    Infinity,        Infinity,        Infinity, 0.0, 0));
assert(test_powf(reinterpret<f32>(0xBF800001),        Infinity,        Infinity, 0.0, 0));
assert(test_powf(                   -Infinity,        Infinity,        Infinity, 0.0, 0));

assert(test_powf(reinterpret<f32>(0x3F800001),       -Infinity,             0.0, 0.0, 0));
assert(test_powf(                    Infinity,       -Infinity,             0.0, 0.0, 0));
assert(test_powf(reinterpret<f32>(0xBF800001),       -Infinity,             0.0, 0.0, 0));
assert(test_powf(                   -Infinity,       -Infinity,             0.0, 0.0, 0));

assert(test_powf(reinterpret<f32>(0x3F7FFFFF),        Infinity,             0.0, 0.0, 0));
assert(test_powf(reinterpret<f32>(0x00000001),        Infinity,             0.0, 0.0, 0));
assert(test_powf(                         0.0,        Infinity,             0.0, 0.0, 0));
assert(test_powf(reinterpret<f32>(0xBF7FFFFF),        Infinity,             0.0, 0.0, 0));
assert(test_powf(reinterpret<f32>(0x80000001),        Infinity,             0.0, 0.0, 0));
assert(test_powf(                        -0.0,        Infinity,             0.0, 0.0, 0));

assert(test_powf(                         0.0, reinterpret<f32>(0x00000001),0.0, 0.0, 0));
assert(test_powf(                        -0.0, reinterpret<f32>(0x00000001),0.0, 0.0, 0));

assert(test_powf(             0.0, reinterpret<f32>(0xFF7FFFFF),       Infinity, 0.0, DIVBYZERO));
assert(test_powf(             0.0, reinterpret<f32>(0x80000001),       Infinity, 0.0, DIVBYZERO));
assert(test_powf(            -0.0, reinterpret<f32>(0xFF7FFFFF),       Infinity, 0.0, DIVBYZERO));
assert(test_powf(            -0.0,                         -2.0,       Infinity, 0.0, DIVBYZERO));
assert(test_powf(            -0.0, reinterpret<f32>(0x80000001),       Infinity, 0.0, DIVBYZERO));
assert(test_powf(            -0.0,                         -1.0,      -Infinity, 0.0, DIVBYZERO));
assert(test_powf(            -0.0, reinterpret<f32>(0xC1880000),      -Infinity, 0.0, DIVBYZERO));

assert(test_powf(        Infinity, reinterpret<f32>(0x00000001),       Infinity, 0.0, 0));
assert(test_powf(        Infinity, reinterpret<f32>(0x80000001),            0.0, 0.0, 0));

assert(test_powf(       -Infinity, reinterpret<f32>(0x7F7FFFFF),       Infinity, 0.0, 0));
assert(test_powf(       -Infinity, reinterpret<f32>(0x00000001),       Infinity, 0.0, 0));
assert(test_powf(       -Infinity, reinterpret<f32>(0xFF7FFFFF),            0.0, 0.0, 0));
assert(test_powf(       -Infinity, reinterpret<f32>(0x80000001),            0.0, 0.0, 0));
assert(test_powf(       -Infinity, reinterpret<f32>(0x40A00000),      -Infinity, 0.0, 0));
assert(test_powf(       -Infinity, reinterpret<f32>(0xC0A00000),           -0.0, 0.0, 0));
assert(test_powf(       -Infinity, reinterpret<f32>(0x40C00000),       Infinity, 0.0, 0));
assert(test_powf(       -Infinity, reinterpret<f32>(0xC0C00000),            0.0, 0.0, 0));

assert(test_powf(                   -Infinity, reinterpret<f32>(0x40000001), Infinity, 0.0, 0));
assert(test_powf(                        -1.0, reinterpret<f32>(0x3F800001),      NaN, 0.0, INVALID));
assert(test_powf(reinterpret<f32>(0x80000001), reinterpret<f32>(0xBFFFFFFF),      NaN, 0.0, INVALID));

assert(test_powf(reinterpret<f32>(0xC1200000), reinterpret<f32>(0x439A8000),-Infinity, 0.0, INEXACT | OVERFLOW));
assert(test_powf(                   -Infinity,                          0.5, Infinity, 0.0, 0));

assert(test_powf(reinterpret<f32>(0x00000002),  0.5, reinterpret<f32>(0x1A800000), 0.0, 0));
assert(test_powf(reinterpret<f32>(0x00000008),  0.5, reinterpret<f32>(0x1B000000), 0.0, 0));
assert(test_powf(reinterpret<f32>(0x00200000),  0.5, reinterpret<f32>(0x1F800000), 0.0, 0));
assert(test_powf(reinterpret<f32>(0x00400000), -1.0, reinterpret<f32>(0x7F000000), 0.0, 0));
assert(test_powf(reinterpret<f32>(0x00800000),  0.5, reinterpret<f32>(0x20000000), 0.0, 0));
assert(test_powf(reinterpret<f32>(0x00800000), -1.0, reinterpret<f32>(0x7E800000), 0.0, 0));
assert(test_powf(reinterpret<f32>(0x01000000), -1.0, reinterpret<f32>(0x7E000000), 0.0, 0));
assert(test_powf(reinterpret<f32>(0x01800000),  0.5, reinterpret<f32>(0x20800000), 0.0, 0));
assert(test_powf(reinterpret<f32>(0x01800000), -1.0, reinterpret<f32>(0x7D800000), 0.0, 0));
assert(test_powf(reinterpret<f32>(0x1A800000),  2.0, reinterpret<f32>(0x00000002), 0.0, 0));
assert(test_powf(reinterpret<f32>(0x20800000),  0.5, reinterpret<f32>(0x30000000), 0.0, 0));
assert(test_powf(reinterpret<f32>(0x2F800000),  2.0, reinterpret<f32>(0x1F800000), 0.0, 0));
assert(test_powf(reinterpret<f32>(0x30000000),  2.0, reinterpret<f32>(0x20800000), 0.0, 0));
assert(test_powf(reinterpret<f32>(0x34000000), -1.0, reinterpret<f32>(0x4B000000), 0.0, 0));
assert(test_powf(reinterpret<f32>(0x38100000),  0.5, reinterpret<f32>(0x3BC00000), 0.0, 0));
assert(test_powf(reinterpret<f32>(0x38800000),  0.5, reinterpret<f32>(0x3C000000), 0.0, 0));
assert(test_powf(reinterpret<f32>(0x3B800000),  0.5, reinterpret<f32>(0x3D800000), 0.0, 0));
assert(test_powf(reinterpret<f32>(0x3D100000),  0.5, reinterpret<f32>(0x3E400000), 0.0, 0));
assert(test_powf(                      0.0625,  0.5,                         0.25, 0.0, 0));
assert(test_powf(                        0.25,  2.0,                       0.0625, 0.0, 0));

assert(test_powf(reinterpret<f32>(0x7D800000),       0.5, reinterpret<f32>(0x5E800000), 0.0, 0));
assert(test_powf(reinterpret<f32>(0x7D800000),      -1.0, reinterpret<f32>(0x01800000), 0.0, 0));
assert(test_powf(reinterpret<f32>(0x7E000000),  Infinity,                     Infinity, 0.0, 0));
assert(test_powf(reinterpret<f32>(0x7E000000),      -1.0, reinterpret<f32>(0x01000000), 0.0, 0));
assert(test_powf(reinterpret<f32>(0x7E000000), -Infinity,                          0.0, 0.0, 0));
assert(test_powf(reinterpret<f32>(0x7E800000),       0.5, reinterpret<f32>(0x5F000000), 0.0, 0));
assert(test_powf(reinterpret<f32>(0x7E800000),      -1.0, reinterpret<f32>(0x00800000), 0.0, 0));

assert(test_powf(reinterpret<f32>(0x7F7FFFFF),  Infinity,                     Infinity, 0.0, 0));
assert(test_powf(reinterpret<f32>(0x7F7FFFFF), -Infinity,                          0.0, 0.0, 0));

assert(test_powf(reinterpret<f32>(0x7F000000),                         -2.0,                          0.0, reinterpret<f32>(0x8B000000), INEXACT | UNDERFLOW));
assert(test_powf(reinterpret<f32>(0x7F000000), reinterpret<f32>(0xC0400000),                          0.0,                         -0.0, INEXACT | UNDERFLOW));
assert(test_powf(reinterpret<f32>(0x7F000000), reinterpret<f32>(0xC37F0000),                          0.0,                         -0.0, INEXACT | UNDERFLOW));
assert(test_powf(reinterpret<f32>(0x7F000000),                       -256.0,                          0.0,                         -0.0, INEXACT | UNDERFLOW));
assert(test_powf(reinterpret<f32>(0x7F000000), reinterpret<f32>(0xC3808000),                          0.0,                         -0.0, INEXACT | UNDERFLOW));
assert(test_powf(reinterpret<f32>(0x7F000000), reinterpret<f32>(0xC3820000),                          0.0,                         -0.0, INEXACT | UNDERFLOW));
assert(test_powf(reinterpret<f32>(0x7F000000), reinterpret<f32>(0xC3828000),                          0.0,                         -0.0, INEXACT | UNDERFLOW));
assert(test_powf(reinterpret<f32>(0x7F000000), reinterpret<f32>(0xC6FFFE00),                          0.0,                         -0.0, INEXACT | UNDERFLOW));
assert(test_powf(reinterpret<f32>(0x7F000000),                     -32768.0,                          0.0,                         -0.0, INEXACT | UNDERFLOW));
assert(test_powf(reinterpret<f32>(0x7F7FFFF8),                         -1.0, reinterpret<f32>(0x00200001), reinterpret<f32>(0xB5000004), INEXACT | UNDERFLOW));
assert(test_powf(reinterpret<f32>(0x7F7FFFF8),                         -2.0,                          0.0, reinterpret<f32>(0x8A000008), INEXACT | UNDERFLOW));

assert(test_powf(reinterpret<f32>(0xFF000000), reinterpret<f32>(0xC6FFFE00),                         -0.0,                          0.0, INEXACT | UNDERFLOW));
assert(test_powf(reinterpret<f32>(0xFF000000),                     -32768.0,                          0.0,                         -0.0, INEXACT | UNDERFLOW));
assert(test_powf(reinterpret<f32>(0xFF7FFFF8),                         -1.0, reinterpret<f32>(0x80200001), reinterpret<f32>(0x35000004), INEXACT | UNDERFLOW));
assert(test_powf(reinterpret<f32>(0xFF7FFFF8),                         -2.0,                          0.0, reinterpret<f32>(0x8A000008), INEXACT | UNDERFLOW));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.random
////////////////////////////////////////////////////////////////////////////////////////////////////

NativeMath.seedRandom(reinterpret<u64>(JSMath.random()));
for (let i = 0; i < 1e6; ++i) {
  let r = NativeMath.random();
  assert(r >= 0.0 && r < 1.0);
}

// Mathf.random ////////////////////////////////////////////////////////////////////////////////////

NativeMathf.seedRandom(reinterpret<u64>(JSMath.random()));
for (let i = 0; i < 1e6; ++i) {
  let r = NativeMathf.random();
  assert(r >= 0.0 && r < 1.0);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.round
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_round(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.round(value), expected, error, flags);
  // (!js || check<f64>(    JSMath.round(value), expected, error, flags));
  // FIXME: JS rounds fractional 0.5 towards +inf (why would one do that?)
}

// sanity
assert(test_round(-8.06684839057968084, -8.0, 0.0, INEXACT));
assert(test_round(4.34523984933830487, 4.0, 0.0, INEXACT));
assert(test_round(-8.38143342755524934, -8.0, 0.0, INEXACT));
assert(test_round(-6.53167358191348413, -7.0, 0.0, INEXACT));
assert(test_round(9.26705696697258574, 9.0, 0.0, INEXACT));
assert(test_round(0.661985898099504477, 1.0, 0.0, INEXACT));
assert(test_round(-0.406603922385355310, -0.0, 0.0, INEXACT));
assert(test_round(0.561759746220724110, 1.0, 0.0, INEXACT));
assert(test_round(0.774152296591303690, 1.0, 0.0, INEXACT));
assert(test_round(-0.678763702639402444, -1.0, 0.0, INEXACT));

// special
assert(test_round(NaN, NaN, 0.0, 0));
assert(test_round(Infinity, Infinity, 0.0, 0));
assert(test_round(-Infinity, -Infinity, 0.0, 0));
assert(test_round(0.0, 0.0, 0.0, 0));
assert(test_round(-0.0, -0.0, 0.0, 0));
assert(test_round(1.0, 1.0, 0.0, 0));
assert(test_round(-1.0, -1.0, 0.0, 0));
assert(test_round(0.5, 1.0, 0.0, INEXACT));
assert(test_round(-0.5, -0.0, 0.0, INEXACT)); // C: -1.0, JS: -0.0
assert(test_round(1.5, 2.0, 0.0, INEXACT));
assert(test_round(-1.5, -1.0, 0.0, INEXACT)); // C: -2.0, JS: -1.0
assert(test_round(1.00001525878906250, 1.0, 0.0, INEXACT));
assert(test_round(-1.00001525878906250, -1.0, 0.0, INEXACT));
assert(test_round(0.999992370605468750, 1.0, 0.0, INEXACT));
assert(test_round(-0.999992370605468750, -1.0, 0.0, INEXACT));
assert(test_round(7.88860905221011805e-31, 0.0, 0.0, INEXACT));
assert(test_round(-7.88860905221011805e-31, -0.0, 0.0, INEXACT));

assert(NativeMath.round( 9007199254740990.0) ==  9007199254740990.0); // round(+2 ** 53) == +2 ** 53
assert(NativeMath.round(-9007199254740990.0) == -9007199254740990.0); // round(-2 ** 53) == -2 ** 53
assert(NativeMath.round( 9007199254740991.0) ==  9007199254740991.0); // round(+(2 ** 53 - 1)) == +(2 ** 53 - 1)
assert(NativeMath.round(-9007199254740991.0) == -9007199254740991.0); // round(-(2 ** 53 - 1)) == -(2 ** 53 - 1)
assert(NativeMath.round(-1.7976931348623157e+308) == -1.7976931348623157e+308);

// Mathf.round /////////////////////////////////////////////////////////////////////////////////////

function test_roundf(value: f32, expected: f32, error: f32, flags: i32): bool {
  return  check<f32>(NativeMathf.round(value), expected, error, flags);
}

// sanity
assert(test_roundf(-8.066848755, -8.0, 0.0, INEXACT));
assert(test_roundf(4.345239639, 4.0, 0.0, INEXACT));
assert(test_roundf(-8.381433487, -8.0, 0.0, INEXACT));
assert(test_roundf(-6.531673431, -7.0, 0.0, INEXACT));
assert(test_roundf(9.267057419, 9.0, 0.0, INEXACT));
assert(test_roundf(0.6619858742, 1.0, 0.0, INEXACT));
assert(test_roundf(-0.4066039324, -0.0, 0.0, INEXACT));
assert(test_roundf(0.5617597699, 1.0, 0.0, INEXACT));
assert(test_roundf(0.7741522789, 1.0, 0.0, INEXACT));
assert(test_roundf(-0.6787636876, -1.0, 0.0, INEXACT));

// special
assert(test_roundf(NaN, NaN, 0.0, 0));
assert(test_roundf(Infinity, Infinity, 0.0, 0));
assert(test_roundf(-Infinity, -Infinity, 0.0, 0));
assert(test_roundf(0.0, 0.0, 0.0, 0));
assert(test_roundf(-0.0, -0.0, 0.0, 0));
assert(test_roundf(1.0, 1.0, 0.0, 0));
assert(test_roundf(-1.0, -1.0, 0.0, 0));
assert(test_roundf(0.5, 1.0, 0.0, INEXACT));
assert(test_roundf(-0.5, -0.0, 0.0, INEXACT)); // C: -1.0, JS: -0.0
assert(test_round(1.5, 2.0, 0.0, INEXACT));
assert(test_round(-1.5, -1.0, 0.0, INEXACT)); // C: -2.0, JS: -1.0
assert(test_roundf(1.000015259, 1.0, 0.0, INEXACT));
assert(test_roundf(-1.000015259, -1.0, 0.0, INEXACT));
assert(test_roundf(0.9999923706, 1.0, 0.0, INEXACT));
assert(test_roundf(-0.9999923706, -1.0, 0.0, INEXACT));
assert(test_roundf(7.888609052e-31, 0.0, 0.0, INEXACT));
assert(test_roundf(-7.888609052e-31, -0.0, 0.0, INEXACT));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.sign
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_sign(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.sign(value), expected, error, flags) &&
  (!js || check<f64>(    JSMath.sign(value), expected, error, flags));
}

assert(test_sign(0.0, 0.0, 0.0, 0));
assert(test_sign(-0.0, -0.0, 0.0, 0));
assert(test_sign(1.0, 1.0, 0.0, 0));
assert(test_sign(2.0, 1.0, 0.0, 0));
assert(test_sign(-1.0, -1.0, 0.0, 0));
assert(test_sign(-2.0, -1.0, 0.0, 0));
assert(test_sign(Infinity, 1.0, 0.0, 0));
assert(test_sign(-Infinity, -1.0, 0.0, 0));
assert(test_sign(NaN, NaN, 0.0, 0));

// Mathf.sign //////////////////////////////////////////////////////////////////////////////////////

function test_signf(value: f32, expected: f32, error: f32, flags: i32): bool {
  return  check<f32>(NativeMathf.sign(value), expected, error, flags);
}

assert(test_signf(0.0, 0.0, 0.0, 0));
assert(test_signf(-0.0, -0.0, 0.0, 0));
assert(test_signf(1.0, 1.0, 0.0, 0));
assert(test_signf(2.0, 1.0, 0.0, 0));
assert(test_signf(-1.0, -1.0, 0.0, 0));
assert(test_signf(-2.0, -1.0, 0.0, 0));
assert(test_signf(Infinity, 1.0, 0.0, 0));
assert(test_signf(-Infinity, -1.0, 0.0, 0));
assert(test_signf(NaN, NaN, 0.0, 0));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.signbit
////////////////////////////////////////////////////////////////////////////////////////////////////

assert(NativeMath.signbit(0.0)  == false);
assert(NativeMath.signbit(-0.0) == true);
assert(NativeMath.signbit(1.0)  == false);
assert(NativeMath.signbit(-1.0) == true);
assert(NativeMath.signbit(+NaN) == false);
assert(NativeMath.signbit(-NaN) == true);
assert(NativeMath.signbit(+Infinity) == false);
assert(NativeMath.signbit(-Infinity) == true);

////////////////////////////////////////////////////////////////////////////////////////////////////
// Mathf.signbit
////////////////////////////////////////////////////////////////////////////////////////////////////

assert(NativeMathf.signbit(0.0)  == false);
assert(NativeMathf.signbit(-0.0) == true);
assert(NativeMathf.signbit(1.0)  == false);
assert(NativeMathf.signbit(-1.0) == true);
assert(NativeMathf.signbit(+NaN) == false);
assert(NativeMathf.signbit(-NaN) == true);
assert(NativeMathf.signbit(+Infinity) == false);
assert(NativeMathf.signbit(-Infinity) == true);

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.rem
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_rem(left: f64, right: f64, expected: f64, error: f64, flags: i32): bool {
  return check<f64>(NativeMath.rem(left, right), expected, error, flags);
}

// sanity
assert(test_rem(-8.06684839057968084, 4.53566256067686879, 1.00447673077405675, 0.0, 0));
assert(test_rem(4.34523984933830487, -8.88799136300345083, 4.34523984933830487, 0.0, 0));
assert(test_rem(-8.38143342755524934, -2.76360733737958819, -0.0906114154164847641, 0.0, 0));
assert(test_rem(-6.53167358191348413, 4.56753527684274374, -1.96413830507074039, 0.0, 0));
assert(test_rem(9.26705696697258574, 4.81139208435979615, -0.355727201747006561, 0.0, 0));
assert(test_rem(-6.45004555606023633, 0.662071792337673881, 0.170672367316502482, 0.0, 0));
assert(test_rem(7.85889025304169664, 0.0521545267500622481, -0.0164432862177028224, 0.0, 0));
assert(test_rem(-0.792054511984895959, 7.67640268511753998, -0.792054511984895959, 0.0, 0));
assert(test_rem(0.615702673197924044, 2.01190257903248026, 0.615702673197924044, 0.0, 0));
assert(test_rem(-0.558758682360915193, 0.0322398306026380407, -0.0106815621160685006, 0.0, 0));

// special
assert(test_rem(0.0, 1.0, 0.0, 0.0, 0));
assert(test_rem(-0.0, 1.0, -0.0, 0.0, 0));
assert(test_rem(0.5, 1.0, 0.5, 0.0, 0));
assert(test_rem(-0.5, 1.0, -0.5, 0.0, 0));
assert(test_rem(1.0, 1.0, 0.0, 0.0, 0));
assert(test_rem(-1.0, 1.0, -0.0, 0.0, 0));
assert(test_rem(1.5, 1.0, -0.5, 0.0, 0));
assert(test_rem(-1.5, 1.0, 0.5, 0.0, 0));
assert(test_rem(2.0, 1.0, 0.0, 0.0, 0));
assert(test_rem(-2.0, 1.0, -0.0, 0.0, 0));
assert(test_rem(Infinity, 1.0, NaN, 0.0, INVALID));
assert(test_rem(-Infinity, 1.0, NaN, 0.0, INVALID));
assert(test_rem(NaN, 1.0, NaN, 0.0, 0));
assert(test_rem(0.0, -1.0, 0.0, 0.0, 0));
assert(test_rem(-0.0, -1.0, -0.0, 0.0, 0));
assert(test_rem(0.5, -1.0, 0.5, 0.0, 0));
assert(test_rem(-0.5, -1.0, -0.5, 0.0, 0));
assert(test_rem(1.0, -1.0, 0.0, 0.0, 0));
assert(test_rem(-1.0, -1.0, -0.0, 0.0, 0));
assert(test_rem(1.5, -1.0, -0.5, 0.0, 0));
assert(test_rem(-1.5, -1.0, 0.5, 0.0, 0));
assert(test_rem(2.0, -1.0, 0.0, 0.0, 0));
assert(test_rem(-2.0, -1.0, -0.0, 0.0, 0));
assert(test_rem(Infinity, -1.0, NaN, 0.0, INVALID));
assert(test_rem(-Infinity, -1.0, NaN, 0.0, INVALID));
assert(test_rem(NaN, -1.0, NaN, 0.0, 0));
assert(test_rem(0.0, 0.0, NaN, 0.0, INVALID));
assert(test_rem(0.0, -0.0, NaN, 0.0, INVALID));
assert(test_rem(0.0, Infinity, 0.0, 0.0, 0));
assert(test_rem(0.0, -Infinity, 0.0, 0.0, 0));
assert(test_rem(0.0, NaN, NaN, 0.0, 0));
assert(test_rem(-0.0, 0.0, NaN, 0.0, INVALID));
assert(test_rem(-0.0, -0.0, NaN, 0.0, INVALID));
assert(test_rem(-0.0, Infinity, -0.0, 0.0, 0));
assert(test_rem(-0.0, -Infinity, -0.0, 0.0, 0));
assert(test_rem(-0.0, NaN, NaN, 0.0, 0));
assert(test_rem(1.0, 0.0, NaN, 0.0, INVALID));
assert(test_rem(-1.0, 0.0, NaN, 0.0, INVALID));
assert(test_rem(Infinity, 0.0, NaN, 0.0, INVALID));
assert(test_rem(-Infinity, 0.0, NaN, 0.0, INVALID));
assert(test_rem(NaN, 0.0, NaN, 0.0, 0));
assert(test_rem(-1.0, -0.0, NaN, 0.0, INVALID));
assert(test_rem(Infinity, -0.0, NaN, 0.0, INVALID));
assert(test_rem(-Infinity, -0.0, NaN, 0.0, INVALID));
assert(test_rem(NaN, -0.0, NaN, 0.0, 0));
assert(test_rem(Infinity, 2.0, NaN, 0.0, INVALID));
assert(test_rem(Infinity, -0.5, NaN, 0.0, INVALID));
assert(test_rem(Infinity, NaN, NaN, 0.0, 0));
assert(test_rem(-Infinity, 2.0, NaN, 0.0, INVALID));
assert(test_rem(-Infinity, -0.5, NaN, 0.0, INVALID));
assert(test_rem(-Infinity, NaN, NaN, 0.0, 0));
assert(test_rem(NaN, NaN, NaN, 0.0, 0));
assert(test_rem(1.0, NaN, NaN, 0.0, 0));
assert(test_rem(-1.0, NaN, NaN, 0.0, 0));
assert(test_rem(1.0, Infinity, 1.0, 0.0, 0));
assert(test_rem(-1.0, Infinity, -1.0, 0.0, 0));
assert(test_rem(Infinity, Infinity, NaN, 0.0, INVALID));
assert(test_rem(-Infinity, Infinity, NaN, 0.0, INVALID));
assert(test_rem(1.0, -Infinity, 1.0, 0.0, 0));
assert(test_rem(-1.0, -Infinity, -1.0, 0.0, 0));
assert(test_rem(Infinity, -Infinity, NaN, 0.0, INVALID));
assert(test_rem(-Infinity, -Infinity, NaN, 0.0, INVALID));
assert(test_rem(1.75, 0.5, -0.25, 0.0, 0));
assert(test_rem(-1.75, 0.5, 0.25, 0.0, 0));
assert(test_rem(1.75, -0.5, -0.25, 0.0, 0));
assert(test_rem(-1.75, -0.5, 0.25, 0.0, 0));
assert(test_rem(7.90505033345994471e-323, Infinity, 7.90505033345994471e-323, 0.0, 0));

// Mathf.rem ///////////////////////////////////////////////////////////////////////////////////////

function test_remf(left: f32, right: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.rem(left, right), expected, error, flags);
}

// sanity
assert(test_remf(-8.066848755, 4.535662651, 1.004476547, 0.0, 0));
assert(test_remf(4.345239639, -8.887990952, 4.345239639, 0.0, 0));
assert(test_remf(-8.381433487, -2.763607264, -0.09061169624, 0.0, 0));
assert(test_remf(-6.531673431, 4.5675354, -1.964138031, 0.0, 0));
assert(test_remf(9.267057419, 4.811392307, -0.3557271957, 0.0, 0));
assert(test_remf(-6.450045586, 0.6620717645, 0.1706720591, 0.0, 0));
assert(test_remf(7.858890057, 0.05215452611, -0.01644338667, 0.0, 0));
assert(test_remf(-0.792054534, 7.676402569, -0.792054534, 0.0, 0));
assert(test_remf(0.6157026887, 2.011902571, 0.6157026887, 0.0, 0));
assert(test_remf(-0.5587586761, 0.03223983198, -0.01068153232, 0.0, 0));

// special
assert(test_remf(0.0, 1.0, 0.0, 0.0, 0));
assert(test_remf(-0.0, 1.0, -0.0, 0.0, 0));
assert(test_remf(0.5, 1.0, 0.5, 0.0, 0));
assert(test_remf(-0.5, 1.0, -0.5, 0.0, 0));
assert(test_remf(1.0, 1.0, 0.0, 0.0, 0));
assert(test_remf(-1.0, 1.0, -0.0, 0.0, 0));
assert(test_remf(1.5, 1.0, -0.5, 0.0, 0));
assert(test_remf(-1.5, 1.0, 0.5, 0.0, 0));
assert(test_remf(2.0, 1.0, 0.0, 0.0, 0));
assert(test_remf(-2.0, 1.0, -0.0, 0.0, 0));
assert(test_remf(Infinity, 1.0, NaN, 0.0, INVALID));
assert(test_remf(-Infinity, 1.0, NaN, 0.0, INVALID));
assert(test_remf(NaN, 1.0, NaN, 0.0, 0));
assert(test_remf(0.0, -1.0, 0.0, 0.0, 0));
assert(test_remf(-0.0, -1.0, -0.0, 0.0, 0));
assert(test_remf(0.5, -1.0, 0.5, 0.0, 0));
assert(test_remf(-0.5, -1.0, -0.5, 0.0, 0));
assert(test_remf(1.0, -1.0, 0.0, 0.0, 0));
assert(test_remf(-1.0, -1.0, -0.0, 0.0, 0));
assert(test_remf(1.5, -1.0, -0.5, 0.0, 0));
assert(test_remf(-1.5, -1.0, 0.5, 0.0, 0));
assert(test_remf(2.0, -1.0, 0.0, 0.0, 0));
assert(test_remf(-2.0, -1.0, -0.0, 0.0, 0));
assert(test_remf(Infinity, -1.0, NaN, 0.0, INVALID));
assert(test_remf(-Infinity, -1.0, NaN, 0.0, INVALID));
assert(test_remf(NaN, -1.0, NaN, 0.0, 0));
assert(test_remf(0.0, 0.0, NaN, 0.0, INVALID));
assert(test_remf(0.0, -0.0, NaN, 0.0, INVALID));
assert(test_remf(0.0, Infinity, 0.0, 0.0, 0));
assert(test_remf(0.0, -Infinity, 0.0, 0.0, 0));
assert(test_remf(0.0, NaN, NaN, 0.0, 0));
assert(test_remf(-0.0, 0.0, NaN, 0.0, INVALID));
assert(test_remf(-0.0, -0.0, NaN, 0.0, INVALID));
assert(test_remf(-0.0, Infinity, -0.0, 0.0, 0));
assert(test_remf(-0.0, -Infinity, -0.0, 0.0, 0));
assert(test_remf(-0.0, NaN, NaN, 0.0, 0));
assert(test_remf(1.0, 0.0, NaN, 0.0, INVALID));
assert(test_remf(-1.0, 0.0, NaN, 0.0, INVALID));
assert(test_remf(Infinity, 0.0, NaN, 0.0, INVALID));
assert(test_remf(-Infinity, 0.0, NaN, 0.0, INVALID));
assert(test_remf(NaN, 0.0, NaN, 0.0, 0));
assert(test_remf(-1.0, -0.0, NaN, 0.0, INVALID));
assert(test_remf(Infinity, -0.0, NaN, 0.0, INVALID));
assert(test_remf(-Infinity, -0.0, NaN, 0.0, INVALID));
assert(test_remf(NaN, -0.0, NaN, 0.0, 0));
assert(test_remf(Infinity, 2.0, NaN, 0.0, INVALID));
assert(test_remf(Infinity, -0.5, NaN, 0.0, INVALID));
assert(test_remf(Infinity, NaN, NaN, 0.0, 0));
assert(test_remf(-Infinity, 2.0, NaN, 0.0, INVALID));
assert(test_remf(-Infinity, -0.5, NaN, 0.0, INVALID));
assert(test_remf(-Infinity, NaN, NaN, 0.0, 0));
assert(test_remf(NaN, NaN, NaN, 0.0, 0));
assert(test_remf(1.0, NaN, NaN, 0.0, 0));
assert(test_remf(-1.0, NaN, NaN, 0.0, 0));
assert(test_remf(1.0, Infinity, 1.0, 0.0, 0));
assert(test_remf(-1.0, Infinity, -1.0, 0.0, 0));
assert(test_remf(Infinity, Infinity, NaN, 0.0, INVALID));
assert(test_remf(-Infinity, Infinity, NaN, 0.0, INVALID));
assert(test_remf(1.0, -Infinity, 1.0, 0.0, 0));
assert(test_remf(-1.0, -Infinity, -1.0, 0.0, 0));
assert(test_remf(Infinity, -Infinity, NaN, 0.0, INVALID));
assert(test_remf(-Infinity, -Infinity, NaN, 0.0, INVALID));
assert(test_remf(1.75, 0.5, -0.25, 0.0, 0));
assert(test_remf(-1.75, 0.5, 0.25, 0.0, 0));
assert(test_remf(1.75, -0.5, -0.25, 0.0, 0));
assert(test_remf(-1.75, -0.5, 0.25, 0.0, 0));
assert(test_remf(5.877471754e-39, Infinity, 5.877471754e-39, 0.0, 0));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.sin
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_sin(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.sin(value), expected, error, flags) &&
  (!js || check<f64>(    JSMath.sin(value), expected, error, flags));
}

// sanity
assert(test_sin(-8.066848390579680840, -0.977429292878122746, -0.1456491202116012570, INEXACT));
assert(test_sin( 4.345239849338304870, -0.933354473696571763, -0.0881374701857566833, INEXACT));
assert(test_sin(-8.381433427555249340, -0.864092471170630372, -0.1174388304352760310, INEXACT));
assert(test_sin(-6.531673581913484130, -0.245938947726153739, -0.1269785165786743160, INEXACT));
assert(test_sin( 9.267056966972585740,  0.157067897720280070, -0.0295501593500375748, INEXACT));
assert(test_sin( 0.661985898099504477,  0.614684486011344733, -0.0997673794627189636, INEXACT));
assert(test_sin(-0.406603922385355310, -0.395492421828236962, -0.3668774962425231930, INEXACT));
assert(test_sin( 0.561759746220724110,  0.532676328667237575, -0.3550407588481903080, INEXACT));
assert(test_sin( 0.774152296591303690,  0.699110206864977934, -0.4276724159717559810, INEXACT));
assert(test_sin(-0.678763702639402444, -0.627831232630121527, -0.3828115463256835940, INEXACT));

// ucb
assert(test_sin( 9.313225746154785156e-010,  9.313225746154785156e-010,  6.510416860692203045e-04, INEXACT));
assert(test_sin(-9.313225746154785156e-010, -9.313225746154785156e-010, -6.510416860692203045e-04, INEXACT));
assert(test_sin( 2.225073858507201383e-308,  2.225073858507201383e-308,  0.000000000000000000e+00, INEXACT));
assert(test_sin(-2.225073858507201383e-308, -2.225073858507201383e-308,  0.000000000000000000e+00, INEXACT));
assert(test_sin( 4.940656458412465442e-324,  4.940656458412465442e-324,  0.000000000000000000e+00, INEXACT | UNDERFLOW));
assert(test_sin(-4.940656458412465442e-324, -4.940656458412465442e-324,  0.000000000000000000e+00, INEXACT | UNDERFLOW));
assert(test_sin(                       0.0,                        0.0,                       0.0, 0));
assert(test_sin(                      -0.0,                       -0.0,                       0.0, 0));
assert(test_sin( 2.225073858507201877e-308,  2.225073858507201877e-308,                       0.0, INEXACT));
assert(test_sin( 2.225073858507202371e-308,  2.225073858507202371e-308,                       0.0, INEXACT));
assert(test_sin( 4.450147717014400296e-308,  4.450147717014400296e-308,                       0.0, INEXACT));
assert(test_sin( 4.450147717014402766e-308,  4.450147717014402766e-308,                       0.0, INEXACT));
assert(test_sin( 4.450147717014405731e-308,  4.450147717014405731e-308,                       0.0, INEXACT));
assert(test_sin( 8.900295434028805532e-308,  8.900295434028805532e-308,                       0.0, INEXACT));
assert(test_sin( 1.117587089538574219e-008,  1.117587089538574219e-008,  1.406250000000000000e-01, INEXACT));
assert(test_sin( 1.490116119384765625e-008,  1.490116119384765625e-008,  1.666666716337203979e-01, INEXACT));
assert(test_sin(-2.225073858507201877e-308, -2.225073858507201877e-308,                       0.0, INEXACT));
assert(test_sin(-2.225073858507202371e-308, -2.225073858507202371e-308,                       0.0, INEXACT));
assert(test_sin(-4.450147717014400296e-308, -4.450147717014400296e-308,                       0.0, INEXACT));
assert(test_sin(-4.450147717014402766e-308, -4.450147717014402766e-308,                       0.0, INEXACT));
assert(test_sin(-4.450147717014405731e-308, -4.450147717014405731e-308,                       0.0, INEXACT));
assert(test_sin(-8.900295434028805532e-308, -8.900295434028805532e-308,                       0.0, INEXACT));
assert(test_sin(-1.117587089538574219e-008, -1.117587089538574219e-008, -1.406250000000000000e-01, INEXACT));
assert(test_sin(-1.490116119384765625e-008, -1.490116119384765625e-008, -1.666666716337203979e-01, INEXACT));
assert(test_sin(-1.490116119384765625e-008, -1.490116119384765625e-008, -1.666666716337203979e-01, INEXACT));
assert(test_sin( 9.881312916824930884e-324,  9.881312916824930884e-324,                       0.0, INEXACT | UNDERFLOW));
assert(test_sin( 4.446590812571218898e-323,  4.446590812571218898e-323,                       0.0, INEXACT | UNDERFLOW));
assert(test_sin( 5.562684646268003458e-309,  5.562684646268003458e-309,                       0.0, INEXACT | UNDERFLOW));
assert(test_sin( 1.112536929253600692e-308,  1.112536929253600692e-308,                       0.0, INEXACT | UNDERFLOW));
assert(test_sin( 2.225073858507200395e-308,  2.225073858507200395e-308,                       0.0, INEXACT | UNDERFLOW));
assert(test_sin( 2.225073858507200889e-308,  2.225073858507200889e-308,                       0.0, INEXACT | UNDERFLOW));
assert(test_sin(-9.881312916824930884e-324, -9.881312916824930884e-324,                       0.0, INEXACT | UNDERFLOW));
assert(test_sin(-4.446590812571218898e-323, -4.446590812571218898e-323,                       0.0, INEXACT | UNDERFLOW));
assert(test_sin(-5.562684646268003458e-309, -5.562684646268003458e-309,                       0.0, INEXACT | UNDERFLOW));
assert(test_sin(-1.112536929253600692e-308, -1.112536929253600692e-308,                       0.0, INEXACT | UNDERFLOW));
assert(test_sin(-2.225073858507200395e-308, -2.225073858507200395e-308,                       0.0, INEXACT | UNDERFLOW));
assert(test_sin(-2.225073858507200889e-308, -2.225073858507200889e-308,                       0.0, INEXACT | UNDERFLOW));

// special
assert(test_sin(      0.0,  0.0, 0.0, 0));
assert(test_sin(     -0.0, -0.0, 0.0, 0));
assert(test_sin(+Infinity,  NaN, 0.0, INVALID));
assert(test_sin(-Infinity,  NaN, 0.0, INVALID));
assert(test_sin(      NaN,  NaN, 0.0, 0));

// from v8
assert(NativeMath.sin(kPI / 2) == JSMath.sin(kPI / 2));
assert(NativeMath.sin(2 * kPI / 2) == JSMath.sin(2 * kPI / 2));

// sin(x) = x for x < 2^-27
assert(+2.3283064365386963e-10 == NativeMath.sin(+2.3283064365386963e-10));
assert(-2.3283064365386963e-10 == NativeMath.sin(-2.3283064365386963e-10));
// sin(pi/8) = sqrt(sqrt(2)-1)/2^(3/4)
assert(+0.3826834323650898 == NativeMath.sin(+0.39269908169872414));
assert(-0.3826834323650898 == NativeMath.sin(-0.39269908169872414));

// Tests for sin.
assert(+0.479425538604203 == NativeMath.sin(+0.5));
assert(-0.479425538604203 == NativeMath.sin(-0.5));
assert(+1.0 == NativeMath.sin(+kPI / 2.0));
assert(-1.0 == NativeMath.sin(-kPI / 2.0));
// Test that sin(Math.PI) != 0 since Math.PI is not exact.
assert(1.2246467991473532e-16 == NativeMath.sin(kPI));
assert(-7.047032979958965e-14 == NativeMath.sin(2200.0 * kPI));
// Test sin for various phases.
assert(-0.7071067811865477 == NativeMath.sin(7.0 / 4.0 * kPI));
assert(+0.7071067811865474 == NativeMath.sin(9.0 / 4.0 * kPI));
assert(+0.7071067811865483 == NativeMath.sin(11.0 / 4.0 * kPI));
assert(-0.7071067811865479 == NativeMath.sin(13.0 / 4.0 * kPI));
assert(-3.2103381051568376e-11 == NativeMath.sin(1048576.0 / 4 * kPI));

// Test Hayne-Panek reduction.
assert( 0.377820109360752e0 == NativeMath.sin(+kTwo120));
assert(-0.377820109360752e0 == NativeMath.sin(-kTwo120));

// Mathf.sin ///////////////////////////////////////////////////////////////////////////////////////

function test_sinf(value: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.sin(value), expected, error, flags);
}

// sanity
assert(test_sinf(-8.0668487550,-0.9774292111, 0.080105729400, INEXACT));
assert(test_sinf( 4.3452396390,-0.9333543777, 0.344756275400, INEXACT));
assert(test_sinf(-8.3814334870,-0.8640924692,-0.468659907600, INEXACT));
assert(test_sinf(-6.5316734310,-0.2459388077,-0.395517766500, INEXACT));
assert(test_sinf( 9.2670574190, 0.1570674479,-0.240068092900, INEXACT));
assert(test_sinf( 0.6619858742, 0.6146844625,-0.077071942390, INEXACT));
assert(test_sinf(-0.4066039324,-0.3954924345,-0.117206171200, INEXACT));
assert(test_sinf( 0.5617597699, 0.5326763391,-0.160591140400, INEXACT));
assert(test_sinf( 0.7741522789, 0.6991102099, 0.263843685400, INEXACT));
assert(test_sinf(-0.6787636876,-0.6278312206, 0.005127954297, INEXACT));

// special
assert(test_sinf(      0.0, 0.0, 0.0, 0));
assert(test_sinf(     -0.0,-0.0, 0.0, 0));
assert(test_sinf( Infinity, NaN, 0.0, INVALID));
assert(test_sinf(-Infinity, NaN, 0.0, INVALID));
assert(test_sinf(      NaN, NaN, 0.0, 0));

// ubc
assert(test_sinf( 1.862645149e-09, 1.862645149e-09, 4.850638554e-12, INEXACT));
assert(test_sinf(-1.862645149e-09,-1.862645149e-09,-4.850638554e-12, INEXACT));
assert(test_sinf( 1.175494351e-38, 1.175494351e-38,             0.0, INEXACT));
assert(test_sinf(-1.175494351e-38,-1.175494351e-38,             0.0, INEXACT));
assert(test_sinf( 1.401298464e-45, 1.401298464e-45,             0.0, INEXACT | UNDERFLOW));
assert(test_sinf(-1.401298464e-45,-1.401298464e-45,             0.0, INEXACT | UNDERFLOW));
assert(test_sinf( 1.175494491e-38, 1.175494491e-38,             0.0, INEXACT));
assert(test_sinf( 1.175494631e-38, 1.175494631e-38,             0.0, INEXACT));
assert(test_sinf( 2.350988001e-38, 2.350988001e-38,             0.0, INEXACT));
assert(test_sinf( 2.350988702e-38, 2.350988702e-38,             0.0, INEXACT));
assert(test_sinf( 2.350989542e-38, 2.350989542e-38,             0.0, INEXACT));
assert(test_sinf( 4.701977403e-38, 4.701977403e-38,             0.0, INEXACT));
assert(test_sinf( 1.117587090e-08, 1.117587090e-08, 2.619344741e-10, INEXACT));
assert(test_sinf( 1.490116119e-08, 1.490116119e-08, 3.104408675e-10, INEXACT));
assert(test_sinf( 2.441406250e-04, 2.441406250e-04, 8.333333582e-02, INEXACT));
assert(test_sinf( 3.662109375e-04, 3.662109375e-04, 2.812500000e-01, INEXACT));
assert(test_sinf(-1.175494491e-38,-1.175494491e-38,             0.0, INEXACT));
assert(test_sinf(-1.175494631e-38,-1.175494631e-38,             0.0, INEXACT));
assert(test_sinf(-2.350988001e-38,-2.350988001e-38,             0.0, INEXACT));
assert(test_sinf(-2.350988702e-38,-2.350988702e-38,             0.0, INEXACT));
assert(test_sinf(-2.350989542e-38,-2.350989542e-38,             0.0, INEXACT));
assert(test_sinf(-4.701977403e-38,-4.701977403e-38,             0.0, INEXACT));
assert(test_sinf(-1.117587090e-08,-1.117587090e-08,-2.619344741e-10, INEXACT));
assert(test_sinf(-1.490116119e-08,-1.490116119e-08,-3.104408675e-10, INEXACT));
assert(test_sinf(-2.441406250e-04,-2.441406250e-04,-8.333333582e-02, INEXACT));
assert(test_sinf(-3.662109375e-04,-3.662109375e-04,-2.812500000e-01, INEXACT));
assert(test_sinf( 2.802596929e-45, 2.802596929e-45,             0.0, INEXACT | UNDERFLOW));
assert(test_sinf( 1.261168618e-44, 1.261168618e-44,             0.0, INEXACT | UNDERFLOW));
assert(test_sinf( 2.938735877e-39, 2.938735877e-39,             0.0, INEXACT | UNDERFLOW));
assert(test_sinf( 5.877471754e-39, 5.877471754e-39,             0.0, INEXACT | UNDERFLOW));
assert(test_sinf( 1.175494071e-38, 1.175494071e-38,             0.0, INEXACT | UNDERFLOW));
assert(test_sinf( 1.175494211e-38, 1.175494211e-38,             0.0, INEXACT | UNDERFLOW));
assert(test_sinf(-2.802596929e-45,-2.802596929e-45,             0.0, INEXACT | UNDERFLOW));
assert(test_sinf(-1.261168618e-44,-1.261168618e-44,             0.0, INEXACT | UNDERFLOW));
assert(test_sinf(-2.938735877e-39,-2.938735877e-39,             0.0, INEXACT | UNDERFLOW));
assert(test_sinf(-5.877471754e-39,-5.877471754e-39,             0.0, INEXACT | UNDERFLOW));
assert(test_sinf(-1.175494071e-38,-1.175494071e-38,             0.0, INEXACT | UNDERFLOW));
assert(test_sinf(-1.175494211e-38,-1.175494211e-38,             0.0, INEXACT | UNDERFLOW));

// large arguments
assert(test_sinf( 255.9999389645,-0.9992055892944336,  0.0, INEXACT));
assert(test_sinf( 5033165.25,     0.5312945246696472,  0.0, INEXACT));
assert(test_sinf( 421657440.0,   -0.7397398948669434,  0.0, INEXACT));
assert(test_sinf( 2147483392.0,   0.2762770354700000,  0.0, INEXACT));
assert(test_sinf( 68719474688.0,  0.9855440855026245,  0.0, INEXACT));
assert(test_sinf( 549755797504.0,-0.9782648086547852,  0.0, INEXACT));
assert(test_sinf( f32.MAX_VALUE, -0.5218765139579773,  0.0, INEXACT));
assert(test_sinf(-255.9999389645, 0.9992055892944336,  0.0, INEXACT));
assert(test_sinf(-5033165.25,    -0.5312945246696472,  0.0, INEXACT));
assert(test_sinf(-421657440.0,    0.7397398948669434,  0.0, INEXACT));
assert(test_sinf(-2147483392.0,  -0.2762770354700000,  0.0, INEXACT));
assert(test_sinf(-68719474688.0, -0.9855440855026245,  0.0, INEXACT));
assert(test_sinf(-549755797504.0, 0.9782648086547852,  0.0, INEXACT));
assert(test_sinf(-f32.MAX_VALUE,  0.5218765139579773,  0.0, INEXACT));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.sinh
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_sinh(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.sinh(value), expected, error, flags) &&
  (!js || check<f64>(    JSMath.sinh(value), expected, error, flags));
}

// sanity
assert(test_sinh(-8.06684839057968084, -1593.52068011562619, -0.213872760534286499, INEXACT));
assert(test_sinh(4.34523984933830487, 38.548780886854118, 0.215374305844306946, INEXACT));
assert(test_sinh(-8.38143342755524934, -2182.63075051455462, 0.162138268351554871, INEXACT));
assert(test_sinh(-6.53167358191348413, -343.272392684752901, 0.204795137047767639, INEXACT));
assert(test_sinh(9.26705696697258574, 5291.77907551940552, -0.486765176057815552, INEXACT));
assert(test_sinh(0.661985898099504477, 0.711406256822915695, -0.458464145660400391, INEXACT));
assert(test_sinh(-0.40660392238535531, -0.41790065258739445, 0.372200459241867065, INEXACT));
assert(test_sinh(0.56175974622072411, 0.591775593545123657, 0.461789965629577637, INEXACT));
assert(test_sinh(0.77415229659130369, 0.853829200885254158, -0.0701905190944671631, INEXACT));
assert(test_sinh(-0.678763702639402444, -0.732097615653168998, 0.268585294485092163, INEXACT));

// special
assert(test_sinh(0.0, 0.0, 0.0, 0));
assert(test_sinh(-0.0, -0.0, 0.0, 0));
assert(test_sinh(Infinity, Infinity, 0.0, 0));
assert(test_sinh(-Infinity, -Infinity, 0.0, 0));
assert(test_sinh(NaN, NaN, 0.0, 0));

// Mathf.sinh //////////////////////////////////////////////////////////////////////////////////////

function test_sinhf(value: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.sinh(value), expected, error, flags);
}

// sanity
assert(test_sinhf(-8.066848755, -1593.52124, 0.1671663225, INEXACT));
assert(test_sinhf(4.345239639, 38.5487709, -0.4934032857, INEXACT));
assert(test_sinhf(-8.381433487, -2182.630859, 0.08499703556, INEXACT));
assert(test_sinhf(-6.531673431, -343.2723389, 0.07041906565, INEXACT));
assert(test_sinhf(9.267057419, 5291.78125, -0.4436251521, INEXACT));
assert(test_sinhf(0.6619858742, 0.7114062309, 0.0581038855, INEXACT));
assert(test_sinhf(-0.4066039324, -0.4179006517, 0.3934949934, INEXACT));
assert(test_sinhf(0.5617597699, 0.5917755961, -0.418379724, INEXACT));
assert(test_sinhf(0.7741522789, 0.853829205, 0.459921062, INEXACT));
assert(test_sinhf(-0.6787636876, -0.7320976257, -0.4815905988, INEXACT));

// special
assert(test_sinhf(0.0, 0.0, 0.0, 0));
assert(test_sinhf(-0.0, -0.0, 0.0, 0));
assert(test_sinhf(Infinity, Infinity, 0.0, 0));
assert(test_sinhf(-Infinity, -Infinity, 0.0, 0));
assert(test_sinhf(NaN, NaN, 0.0, 0));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.sqrt
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_sqrt(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.sqrt(value), expected, error, flags) &&
  (!js || check<f64>(    JSMath.sqrt(value), expected, error, flags));
}

// sanity
assert(test_sqrt(-8.06684839057968084, NaN, 0.0, INVALID));
assert(test_sqrt(4.34523984933830487, 2.08452389032563135, -0.0718026161193847656, INEXACT));
assert(test_sqrt(-8.38143342755524934, NaN, 0.0, INVALID));
assert(test_sqrt(-6.53167358191348413, NaN, 0.0, INVALID));
assert(test_sqrt(9.26705696697258574, 3.04418412172663855, -0.0154626257717609406, INEXACT));
assert(test_sqrt(0.661985898099504477, 0.8136251582267503, -0.0861815735697746277, INEXACT));
assert(test_sqrt(-0.40660392238535531, NaN, 0.0, INVALID));
assert(test_sqrt(0.56175974622072411, 0.749506335010401425, -0.0981396734714508057, INEXACT));
assert(test_sqrt(0.77415229659130369, 0.87985924817058303, -0.371243536472320557, INEXACT));
assert(test_sqrt(-0.678763702639402444, NaN, 0.0, INVALID));

// special
assert(test_sqrt(NaN, NaN, 0.0, 0));
assert(test_sqrt(Infinity, Infinity, 0.0, 0));
assert(test_sqrt(-Infinity, NaN, 0.0, INVALID));
assert(test_sqrt(0.0, 0.0, 0.0, 0));
assert(test_sqrt(-0.0, -0.0, 0.0, 0));
assert(test_sqrt(1.0, 1.0, 0.0, 0));
assert(test_sqrt(-1.0, NaN, 0.0, INVALID));
assert(test_sqrt(4.0, 2.0, 0.0, 0));
assert(test_sqrt(9.88131291682493088e-324, 3.14345556940525759e-162, 0.435376197099685669, INEXACT));
assert(test_sqrt(1.48219693752373963e-323, 3.84993108707641605e-162, -0.451940029859542847, INEXACT));
assert(test_sqrt(4.94065645841246544e-324, 2.22275874948507748e-162, 0.0, 0));
assert(test_sqrt(-4.94065645841246544e-324, NaN, 0.0, INVALID));
assert(test_sqrt(0.999999999999999889, 0.999999999999999889, -0.5, INEXACT));
assert(test_sqrt(1.99999999999999978, 1.41421356237309492, -0.211070418357849121, INEXACT));
assert(test_sqrt(1.00000000000000022, 1.0, -0.5, INEXACT));
assert(test_sqrt(2.00000000000000044, 1.41421356237309515, -0.271730601787567139, INEXACT));
assert(test_sqrt(1.00000000000000022, 1.0, -0.5, INEXACT));
assert(test_sqrt(0.999999999999999889, 0.999999999999999889, -0.5, INEXACT));
assert(test_sqrt(-1.79769313486231571e+308, NaN, 0.0, INVALID));
assert(test_sqrt(1.79769313486231571e+308, 1.34078079299425956e+154, -0.5, INEXACT));
assert(test_sqrt(1.79769313486231491e+308, 1.34078079299425926e+154, -0.5, INEXACT));
assert(test_sqrt(1.79769313486231411e+308, 1.34078079299425897e+154, -0.5, INEXACT));
assert(test_sqrt(1.79769313486231331e+308, 1.34078079299425867e+154, -0.5, INEXACT));
assert(test_sqrt(1.79769313486231251e+308, 1.34078079299425837e+154, -0.5, INEXACT));
assert(test_sqrt(1.79769313486231172e+308, 1.34078079299425807e+154, -0.5, INEXACT));
assert(test_sqrt(1.79769313486231092e+308, 1.34078079299425777e+154, -0.5, INEXACT));
assert(test_sqrt(1.79769313486231012e+308, 1.34078079299425748e+154, -0.5, INEXACT));
assert(test_sqrt(1.79769313486230932e+308, 1.34078079299425718e+154, -0.5, INEXACT));
assert(test_sqrt(1.79769313486230852e+308, 1.34078079299425688e+154, -0.5, INEXACT));
assert(test_sqrt(1.79769313486230772e+308, 1.34078079299425658e+154, -0.5, INEXACT));
assert(test_sqrt(2.22507385850720287e-308, 1.49166814624004168e-154, -0.5, INEXACT));
assert(test_sqrt(2.22507385850720484e-308, 1.49166814624004234e-154, -0.5, INEXACT));
assert(test_sqrt(2.22507385850720682e-308, 1.49166814624004300e-154, -0.5, INEXACT));
assert(test_sqrt(2.22507385850720879e-308, 1.49166814624004367e-154, -0.5, INEXACT));
assert(test_sqrt(2.22507385850721077e-308, 1.49166814624004433e-154, -0.5, INEXACT));
assert(test_sqrt(2.22507385850721275e-308, 1.49166814624004499e-154, -0.5, INEXACT));
assert(test_sqrt(2.22507385850721472e-308, 1.49166814624004565e-154, -0.5, INEXACT));
assert(test_sqrt(2.22507385850721670e-308, 1.49166814624004632e-154, -0.5, INEXACT));
assert(test_sqrt(2.22507385850721868e-308, 1.49166814624004698e-154, -0.5, INEXACT));
assert(test_sqrt(2.22507385850722065e-308, 1.49166814624004764e-154, -0.5, INEXACT));
assert(test_sqrt(2.22507385850722263e-308, 1.49166814624004830e-154, -0.5, INEXACT));
assert(test_sqrt(2.22507385850722460e-308, 1.49166814624004897e-154, -0.5, INEXACT));
assert(test_sqrt(2.22507385850722658e-308, 1.49166814624004963e-154, -0.5, INEXACT));
assert(test_sqrt(2.22507385850722856e-308, 1.49166814624005029e-154, -0.5, INEXACT));
assert(test_sqrt(92.3513039189064529, 9.60995858049900598, 0.499813705682754517, INEXACT));
assert(test_sqrt(93.3599596388915955, 9.66229577475723822, -0.499799787998199463, INEXACT));
assert(test_sqrt(95.4204962888612442, 9.76834153215689049, -0.499972701072692871, INEXACT));
assert(test_sqrt(95.8791694188544881, 9.79179091989072781, 0.499876677989959717, INEXACT));
assert(test_sqrt(96.8480417488402168, 9.84114026669878506, 0.499801903963088989, INEXACT));
assert(test_sqrt(97.4363905088315505, 9.87098731175517052, 0.499769628047943115, INEXACT));
assert(test_sqrt(97.5095797988304724, 9.87469390912095513, 0.499998182058334351, INEXACT));
assert(test_sqrt(97.8049689388261214, 9.88963947466367976, -0.499958068132400513, INEXACT));
assert(test_sqrt(98.2751822888191953, 9.91338399784953417, 0.49979931116104126, INEXACT));
assert(test_sqrt(99.4729356488015526, 9.97361196602321876, -0.499954044818878174, INEXACT));
assert(test_sqrt(100.570471308785386, 10.0284830013709136, -0.499964535236358643, INEXACT));
assert(test_sqrt(100.609546088784811, 10.030431002144665, 0.499756723642349243, INEXACT));
assert(test_sqrt(100.679091098783786, 10.0338971042553435, -0.499777138233184814, INEXACT));
assert(test_sqrt(101.122680958777252, 10.0559773746154217, 0.499886780977249146, INEXACT));
assert(test_sqrt(101.302769128774599, 10.064927676281366, 0.499910563230514526, INEXACT));
assert(test_sqrt(2.45932313565506984e-307, 4.95915631499458737e-154, -0.499899983406066895, INEXACT));
assert(test_sqrt(5.61095730518040884e-307, 7.49063235326658376e-154, -0.499934375286102295, INEXACT));
assert(test_sqrt(5.80738879774085241e-307, 7.62062254526547942e-154, -0.499895691871643066, INEXACT));
assert(test_sqrt(7.02613708047142671e-307, 8.38220560501317447e-154, 0.499806404113769531, INEXACT));
assert(test_sqrt(8.43869776919497201e-307, 9.18623849526832761e-154, -0.499906569719314575, INEXACT));
assert(test_sqrt(1.16077925158367949e-306, 1.07739465915869443e-153, -0.499976843595504761, INEXACT));
assert(test_sqrt(1.28274138274231934e-306, 1.13258173336069622e-153, -0.499951303005218506, INEXACT));
assert(test_sqrt(1.71166045960874567e-306, 1.30830442161170782e-153, -0.499863952398300171, INEXACT));
assert(test_sqrt(2.03817325168699409e-306, 1.42764605266396281e-153, 0.499840378761291504, INEXACT));
assert(test_sqrt(2.17157206085693087e-306, 1.47362548188368786e-153, 0.499929040670394897, INEXACT));
assert(test_sqrt(2.46813996318040945e-306, 1.57103149655899957e-153, 0.499890446662902832, INEXACT));
assert(test_sqrt(2.51755339642005881e-306, 1.58667999181311239e-153, -0.499770104885101318, INEXACT));
assert(test_sqrt(2.64615054688296253e-306, 1.62669927979419815e-153, 0.499867290258407593, INEXACT));
assert(test_sqrt(3.81670763677204135e-306, 1.95363958722483965e-153, 0.499834716320037842, INEXACT));
assert(test_sqrt(4.57432207785627658e-306, 2.13876648511619359e-153, 0.499859392642974854, INEXACT));

// Mathf.sqrt //////////////////////////////////////////////////////////////////////////////////////

function test_sqrtf(value: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.sqrt(value), expected, error, flags);
}

// sanity
assert(test_sqrtf(-8.066848755, NaN, 0.0, INVALID));
assert(test_sqrtf(4.345239639, 2.084523916, 0.3200402558, INEXACT));
assert(test_sqrtf(-8.381433487, NaN, 0.0, INVALID));
assert(test_sqrtf(-6.531673431, NaN, 0.0, INVALID));
assert(test_sqrtf(9.267057419, 3.044184208, 0.05022354797, INEXACT));
assert(test_sqrtf(0.6619858742, 0.8136251569, 0.2240506113, INEXACT));
assert(test_sqrtf(-0.4066039324, NaN, 0.0, INVALID));
assert(test_sqrtf(0.5617597699, 0.7495063543, 0.05895441771, INEXACT));
assert(test_sqrtf(0.7741522789, 0.8798592091, -0.4874873757, INEXACT));
assert(test_sqrtf(-0.6787636876, NaN, 0.0, INVALID));

// special
assert(test_sqrtf(NaN, NaN, 0.0, 0));
assert(test_sqrtf(Infinity, Infinity, 0.0, 0));
assert(test_sqrtf(-Infinity, NaN, 0.0, INVALID));
assert(test_sqrtf(0.0, 0.0, 0.0, 0));
assert(test_sqrtf(-0.0, -0.0, 0.0, 0));
assert(test_sqrtf(1.0, 1.0, 0.0, 0));
assert(test_sqrtf(-1.0, NaN, 0.0, INVALID));
assert(test_sqrtf(4.0, 2.0, 0.0, 0));
assert(test_sqrtf(2.802596929e-45, 5.293955920e-23, 0.0, 0));
assert(test_sqrtf(4.203895393e-45, 6.483745599e-23, 0.3738855422, INEXACT));
assert(test_sqrtf(1.401298464e-45, 3.743392067e-23, -0.2030314505, INEXACT));
assert(test_sqrtf(-1.401298464e-45, NaN, 0.0, INVALID));
assert(test_sqrtf(3.402823466e+38, 1.844674297e+19, -0.5, INEXACT));
assert(test_sqrtf(-3.402823466e+38, NaN, 0.0, INVALID));
assert(test_sqrtf(0.9999998808, 0.9999999404, 2.980232594e-8, INEXACT));
assert(test_sqrtf(0.9999999404, 0.9999999404, -0.5, INEXACT));
assert(test_sqrtf(1.999999762, 1.414213419, -0.4959246516, INEXACT));
assert(test_sqrtf(1.999999881, 1.414213538, 0.1505219489, INEXACT));
assert(test_sqrtf(1.000000119, 1.0, -0.5, INEXACT));
assert(test_sqrtf(1.000000238, 1.000000119, 5.960463767e-8, INEXACT));
assert(test_sqrtf(2.000000238, 1.414213657, 0.08986179531, INEXACT));
assert(test_sqrtf(2.000000477, 1.414213777, 0.3827550709, INEXACT));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.tan
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_tan(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.tan(value), expected, error, flags) &&
  (!js || check<f64>(    JSMath.tan(value), expected, error, flags));
}

// sanity
assert(test_tan(-8.066848390579680840,  4.626603542401633180, -0.2727603316307067870, INEXACT));
assert(test_tan( 4.345239849338304870,  2.600191705822202160,  0.2651003301143646240, INEXACT));
assert(test_tan(-8.381433427555249340,  1.716740832874105170, -0.2468751966953277590, INEXACT));
assert(test_tan(-6.531673581913484130, -0.253732252345372500, -0.4679703712463378910, INEXACT));
assert(test_tan( 9.267056966972585740, -0.159041957271919582, -0.0670407786965370178, INEXACT));
assert(test_tan( 0.661985898099504477,  0.779291910691043421, -0.0380561351776123047, INEXACT));
assert(test_tan(-0.406603922385355310, -0.430599528795436559, -0.0924271419644355774, INEXACT));
assert(test_tan( 0.561759746220724110,  0.629403687318739968, -0.3219134807586669920, INEXACT));
assert(test_tan( 0.774152296591303690,  0.977757465294964545, -0.1966651827096939090, INEXACT));
assert(test_tan(-0.678763702639402444, -0.806618663020912341, -0.0676656961441040039, INEXACT));

// ucb
assert(test_tan( 9.313225746154785156e-010,  9.313225746154785156e-010, -1.302083372138440609e-03, INEXACT));
assert(test_tan(-9.313225746154785156e-010, -9.313225746154785156e-010,  1.302083372138440609e-03, INEXACT));
assert(test_tan( 2.225073858507201383e-308,  2.225073858507201383e-308,  0.000000000000000000e+00, INEXACT));
assert(test_tan(-2.225073858507201383e-308, -2.225073858507201383e-308,  0.000000000000000000e+00, INEXACT));
assert(test_tan( 4.940656458412465442e-324,  4.940656458412465442e-324,  0.000000000000000000e+00, INEXACT | UNDERFLOW));
assert(test_tan(-4.940656458412465442e-324, -4.940656458412465442e-324,  0.000000000000000000e+00, INEXACT | UNDERFLOW));
assert(test_tan( 0.000000000000000000e+000,  0.000000000000000000e+000,  0.000000000000000000e+00, 0));
assert(test_tan(-0.000000000000000000e+000, -0.000000000000000000e+000,  0.000000000000000000e+00, 0));
assert(test_tan( 7.853981633974482790e-001,  9.999999999999998890e-001, -4.484681189060211182e-01, INEXACT));
assert(test_tan(-7.853981633974482790e-001, -9.999999999999998890e-001,  4.484681189060211182e-01, INEXACT));
assert(test_tan( 2.225073858507201877e-308,  2.225073858507201877e-308,  0.000000000000000000e+00, INEXACT));
assert(test_tan( 2.225073858507202371e-308,  2.225073858507202371e-308,  0.000000000000000000e+00, INEXACT));
assert(test_tan( 4.450147717014400296e-308,  4.450147717014400296e-308,  0.000000000000000000e+00, INEXACT));
assert(test_tan( 4.450147717014402766e-308,  4.450147717014402766e-308,  0.000000000000000000e+00, INEXACT));
assert(test_tan( 4.450147717014405731e-308,  4.450147717014405731e-308,  0.000000000000000000e+00, INEXACT));
assert(test_tan( 8.900295434028805532e-308,  8.900295434028805532e-308,  0.000000000000000000e+00, INEXACT));
assert(test_tan( 1.117587089538574219e-008,  1.117587089538574219e-008, -2.812500000000000000e-01, INEXACT));
assert(test_tan( 1.490116119384765625e-008,  1.490116119384765625e-008, -3.333333432674407959e-01, INEXACT));
assert(test_tan(-2.225073858507201877e-308, -2.225073858507201877e-308,  0.000000000000000000e+00, INEXACT));
assert(test_tan(-2.225073858507202371e-308, -2.225073858507202371e-308,  0.000000000000000000e+00, INEXACT));
assert(test_tan(-4.450147717014400296e-308, -4.450147717014400296e-308,  0.000000000000000000e+00, INEXACT));
assert(test_tan(-4.450147717014402766e-308, -4.450147717014402766e-308,  0.000000000000000000e+00, INEXACT));
assert(test_tan(-4.450147717014405731e-308, -4.450147717014405731e-308,  0.000000000000000000e+00, INEXACT));
assert(test_tan(-8.900295434028805532e-308, -8.900295434028805532e-308,  0.000000000000000000e+00, INEXACT));
assert(test_tan(-1.117587089538574219e-008, -1.117587089538574219e-008,  2.812500000000000000e-01, INEXACT));
assert(test_tan(-1.490116119384765625e-008, -1.490116119384765625e-008,  3.333333432674407959e-01, INEXACT));
assert(test_tan( 9.881312916824930884e-324,  9.881312916824930884e-324,  0.000000000000000000e+00, INEXACT | UNDERFLOW));
assert(test_tan( 4.446590812571218898e-323,  4.446590812571218898e-323,  0.000000000000000000e+00, INEXACT | UNDERFLOW));
assert(test_tan( 5.562684646268003458e-309,  5.562684646268003458e-309,  0.000000000000000000e+00, INEXACT | UNDERFLOW));
assert(test_tan( 1.112536929253600692e-308,  1.112536929253600692e-308,  0.000000000000000000e+00, INEXACT | UNDERFLOW));
assert(test_tan( 2.225073858507200395e-308,  2.225073858507200395e-308,  0.000000000000000000e+00, INEXACT | UNDERFLOW));
assert(test_tan( 2.225073858507200889e-308,  2.225073858507200889e-308,  0.000000000000000000e+00, INEXACT | UNDERFLOW));
assert(test_tan(-9.881312916824930884e-324, -9.881312916824930884e-324,  0.000000000000000000e+00, INEXACT | UNDERFLOW));
assert(test_tan(-4.446590812571218898e-323, -4.446590812571218898e-323,  0.000000000000000000e+00, INEXACT | UNDERFLOW));
assert(test_tan(-5.562684646268003458e-309, -5.562684646268003458e-309,  0.000000000000000000e+00, INEXACT | UNDERFLOW));
assert(test_tan(-1.112536929253600692e-308, -1.112536929253600692e-308,  0.000000000000000000e+00, INEXACT | UNDERFLOW));
assert(test_tan(-2.225073858507200395e-308, -2.225073858507200395e-308,  0.000000000000000000e+00, INEXACT | UNDERFLOW));
assert(test_tan(-2.225073858507200889e-308, -2.225073858507200889e-308,  0.000000000000000000e+00, INEXACT | UNDERFLOW));

// from v8 ieee754-unittest.cc
assert(NativeMath.tan(2.3283064365386963e-10) == JSMath.tan(2.3283064365386963e-10));
assert(NativeMath.tan(-2.3283064365386963e-10) == JSMath.tan(-2.3283064365386963e-10));
assert(NativeMath.tan(11.0 / 16.0) == JSMath.tan(11.0 / 16.0));
assert(NativeMath.tan(-11.0 / 16.0) == JSMath.tan(-11.0 / 16.0));
assert(NativeMath.tan(0.39269908169872414) == JSMath.tan(0.39269908169872414));
assert(NativeMath.tan(0.6743358) == JSMath.tan(0.6743358));
assert(NativeMath.tan(3.725290298461914e-9) == JSMath.tan(3.725290298461914e-9));
assert(NativeMath.tan(kPI / 2) == JSMath.tan(kPI / 2));

assert(NativeMath.tan(0.5) == JSMath.tan(0.5));
assert(NativeMath.tan(1.107148717794091) == JSMath.tan(1.107148717794091));
assert(NativeMath.tan(7.0 / 4.0 * kPI) == JSMath.tan(7.0 / 4.0 * kPI));
assert(NativeMath.tan(9.0 / 4.0 * kPI) == JSMath.tan(9.0 / 4.0 * kPI));
assert(NativeMath.tan(1048576.0 / 2.0 * kPI) == JSMath.tan(1048576.0 / 2.0 * kPI));
assert(NativeMath.tan(1048575.0 / 2.0 * kPI) == JSMath.tan(1048575.0 / 2.0 * kPI));
assert(NativeMath.tan(kTwo120) == JSMath.tan(kTwo120));
assert(NativeMath.tan(-kTwo120) == JSMath.tan(-kTwo120));

// special
assert(test_tan(0.0, 0.0, 0.0, 0));
assert(test_tan(-0.0, -0.0, 0.0, 0));
assert(test_tan(Infinity, NaN, 0.0, INVALID));
assert(test_tan(-Infinity, NaN, 0.0, INVALID));
assert(test_tan(NaN, NaN, 0.0, 0));

// Mathf.tan ///////////////////////////////////////////////////////////////////////////////////////

function test_tanf(value: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.tan(value), expected, error, flags);
}

// sanity
assert(test_tanf(-8.0668487550, 4.6265954970, 0.245566695900, INEXACT));
assert(test_tanf( 4.3452396390, 2.6001901630, 0.365240722900, INEXACT));
assert(test_tanf(-8.3814334870, 1.7167406080, 0.081693492830, INEXACT));
assert(test_tanf(-6.5316734310,-0.2537320852, 0.231865137800, INEXACT));
assert(test_tanf( 9.2670574190,-0.1590414941,-0.009332014248, INEXACT));
assert(test_tanf( 0.6619858742, 0.7792918682,-0.067597009240, INEXACT));
assert(test_tanf(-0.4066039324,-0.4305995405, 0.005771996453, INEXACT));
assert(test_tanf( 0.5617597699, 0.6294037104,-0.168381631400, INEXACT));
assert(test_tanf( 0.7741522789, 0.9777574539, 0.389693886000, INEXACT));
assert(test_tanf(-0.6787636876,-0.8066186309, 0.122940599900, INEXACT));

// special
assert(test_tanf(      0.0, 0.0, 0.0, 0));
assert(test_tanf(     -0.0,-0.0, 0.0, 0));
assert(test_tanf( Infinity, NaN, 0.0, INVALID));
assert(test_tanf(-Infinity, NaN, 0.0, INVALID));
assert(test_tanf(      NaN, NaN, 0.0, 0));

// ubc
assert(test_tanf( 1.862645149e-09, 1.862645149e-09,-9.701277108e-12, INEXACT));
assert(test_tanf(-1.862645149e-09,-1.862645149e-09, 9.701277108e-12, INEXACT));
assert(test_tanf( 1.175494351e-38, 1.175494351e-38,             0.0, INEXACT));
assert(test_tanf(-1.175494351e-38,-1.175494351e-38,             0.0, INEXACT));
assert(test_tanf( 1.401298464e-45, 1.401298464e-45,             0.0, INEXACT | UNDERFLOW));
assert(test_tanf(-1.401298464e-45,-1.401298464e-45,             0.0, INEXACT | UNDERFLOW));
assert(test_tanf( 1.175494491e-38, 1.175494491e-38,             0.0, INEXACT));
assert(test_tanf( 1.175494631e-38, 1.175494631e-38,             0.0, INEXACT));
assert(test_tanf( 2.350988001e-38, 2.350988001e-38,             0.0, INEXACT));
assert(test_tanf( 2.350988702e-38, 2.350988702e-38,             0.0, INEXACT));
assert(test_tanf( 2.350989542e-38, 2.350989542e-38,             0.0, INEXACT));
assert(test_tanf( 4.701977403e-38, 4.701977403e-38,             0.0, INEXACT));
assert(test_tanf( 1.117587090e-08, 1.117587090e-08,-5.238689482e-10, INEXACT));
assert(test_tanf( 1.490116119e-08, 1.490116119e-08,-6.208817349e-10, INEXACT));
assert(test_tanf( 2.441406250e-04, 2.441406250e-04,-1.666666716e-01, INEXACT));
assert(test_tanf(-1.175494491e-38,-1.175494491e-38,             0.0, INEXACT));
assert(test_tanf(-1.175494631e-38,-1.175494631e-38,             0.0, INEXACT));
assert(test_tanf(-2.350988001e-38,-2.350988001e-38,             0.0, INEXACT));
assert(test_tanf( 2.350988702e-38, 2.350988702e-38,             0.0, INEXACT));
assert(test_tanf(-2.350989542e-38,-2.350989542e-38,             0.0, INEXACT));
assert(test_tanf(-4.701977403e-38,-4.701977403e-38,             0.0, INEXACT));
assert(test_tanf(-1.117587090e-08,-1.117587090e-08, 5.238689482e-10, INEXACT));
assert(test_tanf(-1.490116119e-08,-1.490116119e-08, 6.208817349e-10, INEXACT));
assert(test_tanf(-2.441406250e-04,-2.441406250e-04, 1.666666716e-01, INEXACT));
assert(test_tanf( 2.802596929e-45, 2.802596929e-45,             0.0, INEXACT | UNDERFLOW));
assert(test_tanf( 1.261168618e-44, 1.261168618e-44,             0.0, INEXACT | UNDERFLOW));
assert(test_tanf( 2.938735877e-39, 2.938735877e-39,             0.0, INEXACT | UNDERFLOW));
assert(test_tanf( 5.877471754e-39, 5.877471754e-39,             0.0, INEXACT | UNDERFLOW));
assert(test_tanf( 1.175494071e-38, 1.175494071e-38,             0.0, INEXACT | UNDERFLOW));
assert(test_tanf( 1.175494211e-38, 1.175494211e-38,             0.0, INEXACT | UNDERFLOW));
assert(test_tanf(-2.802596929e-45,-2.802596929e-45,             0.0, INEXACT | UNDERFLOW));
assert(test_tanf(-1.261168618e-44,-1.261168618e-44,             0.0, INEXACT | UNDERFLOW));
assert(test_tanf(-2.938735877e-39,-2.938735877e-39,             0.0, INEXACT | UNDERFLOW));
assert(test_tanf(-5.877471754e-39,-5.877471754e-39,             0.0, INEXACT | UNDERFLOW));
assert(test_tanf(-1.175494071e-38,-1.175494071e-38,             0.0, INEXACT | UNDERFLOW));
assert(test_tanf(-1.175494211e-38,-1.175494211e-38,             0.0, INEXACT | UNDERFLOW));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.tanh
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_tanh(value: f64, expected: f64, error: f64, flags: i32): bool {
  return check<f64>(NativeMath.tanh(value), expected, error, flags) &&
  (!js || check<f64>(   JSMath.tanh(value), expected, error, flags));
}

// sanity
assert(test_tanh(-8.06684839057968084, -0.999999803096031981, 0.0127933314070105553, INEXACT));
assert(test_tanh(4.34523984933830487, 0.999663697896130743, 0.157350823283195496, INEXACT));
assert(test_tanh(-8.38143342755524934, -0.999999895043486187, 0.279850661754608154, INEXACT));
assert(test_tanh(-6.53167358191348413, -0.999995756839242911, -0.442855745553970337, INEXACT));
assert(test_tanh(9.26705696697258574, 0.999999982144723409, 0.446275502443313599, INEXACT));
assert(test_tanh(0.661985898099504477, 0.579683501863527462, 0.489204317331314087, INEXACT));
assert(test_tanh(-0.40660392238535531, -0.385585309990165215, 0.359938710927963257, INEXACT));
assert(test_tanh(0.56175974622072411, 0.509281924870043867, -0.394365221261978149, INEXACT));
assert(test_tanh(0.77415229659130369, 0.649337455031855471, -0.489939600229263306, INEXACT));
assert(test_tanh(-0.678763702639402444, -0.590715084799841028, -0.0145387789234519005, INEXACT));

// special
assert(test_tanh(0.0, 0.0, 0.0, 0));
assert(test_tanh(-0.0, -0.0, 0.0, 0));
assert(test_tanh(Infinity, 1.0, 0.0, 0));
assert(test_tanh(-Infinity, -1.0, 0.0, 0));
assert(test_tanh(NaN, NaN, 0.0, 0));

// Mathf.tanh //////////////////////////////////////////////////////////////////////////////////////

function test_tanhf(value: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.tanh(value), expected, error, flags);
}

// sanity
assert(test_tanhf(-8.066848755, -0.9999998212, -0.3034979999, INEXACT));
assert(test_tanhf(4.345239639, 0.9996637106, 0.2154078335, INEXACT));
assert(test_tanhf(-8.381433487, -0.9999998808, 0.2391221076, INEXACT));
assert(test_tanhf(-6.531673431, -0.9999957681, -0.1884459704, INEXACT));
assert(test_tanhf(9.267057419, 1.0, 0.1497807801, INEXACT));
assert(test_tanhf(0.6619858742, 0.5796834826, -0.05590476096, INEXACT));
assert(test_tanhf(-0.4066039324, -0.3855853081, 0.3497871757, INEXACT));
assert(test_tanhf(0.5617597699, 0.5092819333, -0.152878508, INEXACT));
assert(test_tanhf(0.7741522789, 0.6493374705, 0.4317026138, INEXACT));
assert(test_tanhf(-0.6787636876, -0.5907150507, 0.407987386, INEXACT));

// special
assert(test_tanhf(0.0, 0.0, 0.0, 0));
assert(test_tanhf(-0.0, -0.0, 0.0, 0));
assert(test_tanhf(Infinity, 1.0, 0.0, 0));
assert(test_tanhf(-Infinity, -1.0, 0.0, 0));
assert(test_tanhf(NaN, NaN, 0.0, 0));

////////////////////////////////////////////////////////////////////////////////////////////////////
// Math.trunc
////////////////////////////////////////////////////////////////////////////////////////////////////

function test_trunc(value: f64, expected: f64, error: f64, flags: i32): bool {
  return  check<f64>(NativeMath.trunc(value), expected, error, flags) &&
  (!js || check<f64>(    JSMath.trunc(value), expected, error, flags));
}

// sanity
assert(test_trunc(-8.06684839057968084, -8.0, 0.0, INEXACT));
assert(test_trunc(4.34523984933830487, 4.0, 0.0, INEXACT));
assert(test_trunc(-8.38143342755524934, -8.0, 0.0, INEXACT));
assert(test_trunc(-6.53167358191348413, -6.0, 0.0, INEXACT));
assert(test_trunc(9.26705696697258574, 9.0, 0.0, INEXACT));
assert(test_trunc(0.661985898099504477, 0.0, 0.0, INEXACT));
assert(test_trunc(-0.40660392238535531, -0.0, 0.0, INEXACT));
assert(test_trunc(0.56175974622072411, 0.0, 0.0, INEXACT));
assert(test_trunc(0.77415229659130369, 0.0, 0.0, INEXACT));
assert(test_trunc(-0.678763702639402444, -0.0, 0.0, INEXACT));

// special
assert(test_trunc(NaN, NaN, 0.0, 0));
assert(test_trunc(Infinity, Infinity, 0.0, 0));
assert(test_trunc(-Infinity, -Infinity, 0.0, 0));
assert(test_trunc(0.0, 0.0, 0.0, 0));
assert(test_trunc(-0.0, -0.0, 0.0, 0));
assert(test_trunc(1.0, 1.0, 0.0, 0));
assert(test_trunc(-1.0, -1.0, 0.0, 0));
assert(test_trunc(0.5, 0.0, 0.0, INEXACT));
assert(test_trunc(-0.5, -0.0, 0.0, INEXACT));
assert(test_trunc(1.0000152587890625, 1.0, 0.0, INEXACT));
assert(test_trunc(-1.0000152587890625, -1.0, 0.0, INEXACT));
assert(test_trunc(0.99999237060546875, 0.0, 0.0, INEXACT));
assert(test_trunc(-0.99999237060546875, -0.0, 0.0, INEXACT));
assert(test_trunc(7.88860905221011805e-31, 0.0, 0.0, INEXACT));
assert(test_trunc(-7.88860905221011805e-31, -0.0, 0.0, INEXACT));

// Mathf.trunc /////////////////////////////////////////////////////////////////////////////////////

function test_truncf(value: f32, expected: f32, error: f32, flags: i32): bool {
  return check<f32>(NativeMathf.trunc(value), expected, error, flags);
}

// sanity
assert(test_truncf(-8.066848755, -8.0, 0.0, INEXACT));
assert(test_truncf(4.345239639, 4.0, 0.0, INEXACT));
assert(test_truncf(-8.381433487, -8.0, 0.0, INEXACT));
assert(test_truncf(-6.531673431, -6.0, 0.0, INEXACT));
assert(test_truncf(9.267057419, 9.0, 0.0, INEXACT));
assert(test_truncf(0.6619858742, 0.0, 0.0, INEXACT));
assert(test_truncf(-0.4066039324, -0.0, 0.0, INEXACT));
assert(test_truncf(0.5617597699, 0.0, 0.0, INEXACT));
assert(test_truncf(0.7741522789, 0.0, 0.0, INEXACT));
assert(test_truncf(-0.6787636876, -0.0, 0.0, INEXACT));

// special
assert(test_truncf(NaN, NaN, 0.0, 0));
assert(test_truncf(Infinity, Infinity, 0.0, 0));
assert(test_truncf(-Infinity, -Infinity, 0.0, 0));
assert(test_truncf(0.0, 0.0, 0.0, 0));
assert(test_truncf(-0.0, -0.0, 0.0, 0));
assert(test_truncf(1.0, 1.0, 0.0, 0));
assert(test_truncf(-1.0, -1.0, 0.0, 0));
assert(test_truncf(0.5, 0.0, 0.0, INEXACT));
assert(test_truncf(-0.5, -0.0, 0.0, INEXACT));
assert(test_truncf(1.000015259, 1.0, 0.0, INEXACT));
assert(test_truncf(-1.000015259, -1.0, 0.0, INEXACT));
assert(test_truncf(0.9999923706, 0.0, 0.0, INEXACT));
assert(test_truncf(-0.9999923706, -0.0, 0.0, INEXACT));
assert(test_truncf(7.888609052e-31, 0.0, 0.0, INEXACT));
assert(test_truncf(-7.888609052e-31, -0.0, 0.0, INEXACT));

// Math.sincos ////////////////////////////////////////////////////////////////////////////////

function test_sincos(value: u64, expected_sin: u64, error_sin: u64, expected_cos: u64, error_cos: u64, flags: i32): bool {
  var arg    = reinterpret<f64>(value);
  var expsin = reinterpret<f64>(expected_sin);
  var expcos = reinterpret<f64>(expected_cos);
  var errsin = reinterpret<f64>(error_sin);
  var errcos = reinterpret<f64>(error_cos);
  NativeMath.sincos(arg);
  return (
    check<f64>(NativeMath.sincos_sin, expsin, errsin, flags) &&
    check<f64>(NativeMath.sincos_cos, expcos, errcos, flags)
  );
}

// sanity
// -0x1.02239f3c6a8f1p+3,      -0x1.f4719cbe20bd2p-1,  -0x1.2a4a16p-3,  -0x1.b0aa8f2c9baf6p-3, -0x1.c105d2p-4,
//  0x1.161868e18bc67p+2,      -0x1.dde0a33834424p-1,  -0x1.6902d6p-4,  -0x1.6f922aed88704p-2, -0x1.b8b8fap-4,
// -0x1.0c34b3e01e6e7p+3,      -0x1.ba6a5410cb9ccp-1,  -0x1.e1078ap-4,  -0x1.01b4e00041423p-1, -0x1.5f1decp-6,
// -0x1.a206f0a19dcc4p+2,      -0x1.f7aed6ca5f32fp-3,   -0x1.040d5p-3,   0x1.f0462a6686a9cp-1, -0x1.ea474ep-2,
//  0x1.288bbb0d6a1e6p+3,       0x1.41acd05fae3c4p-3,  -0x1.e4265ap-6,  -0x1.f9a51be5829b7p-1,  0x1.f3c7cep-2,
//  0x1.52efd0cd80497p-1,       0x1.3ab7ecc98df9ap-1,  -0x1.98a5aep-4,   0x1.93da10e89d4d1p-1,  0x1.044604p-3,
// -0x1.a05cc754481d1p-2,      -0x1.94fbf72645bfcp-2,  -0x1.77aebcp-2,   0x1.d64199a5cb117p-1, -0x1.0b79e2p-2,
//  0x1.1f9ef934745cbp-1,       0x1.10baf3a5f550ep-1,  -0x1.6b8fcep-2,   0x1.b150bae7795b1p-1, -0x1.35d926p-2,
//  0x1.8c5db097f7442p-1,       0x1.65f1c5e591db2p-1,  -0x1.b5efc2p-2,   0x1.6e164e427022bp-1, -0x1.5db4c2p-4,
// -0x1.5b86ea8118a0ep-1,      -0x1.417318671b83dp-1,   -0x1.87ffcp-2,   0x1.8e83d35a366cp-1,   0x1.3c524p-2,
test_sincos(0xC0202239F3C6A8F1, 0xBFEF4719CBE20BD2, 0xBFC2A4A160000000, 0xBFCB0AA8F2C9BAF6, 0xBFBC105D20000000, INEXACT);
test_sincos(0x401161868E18BC67, 0xBFEDDE0A33834424, 0xBFB6902D60000000, 0xBFD6F922AED88704, 0xBFBB8B8FA0000000, INEXACT);
test_sincos(0xC020C34B3E01E6E7, 0xBFEBA6A5410CB9CC, 0xBFBE1078A0000000, 0xBFE01B4E00041423, 0xBF95F1DEC0000000, INEXACT);
test_sincos(0xC01A206F0A19DCC4, 0xBFCF7AED6CA5F32F, 0xBFC040D500000000, 0x3FEF0462A6686A9C, 0xBFDEA474E0000000, INEXACT);
test_sincos(0x402288BBB0D6A1E6, 0x3FC41ACD05FAE3C4, 0xBF9E4265A0000000, 0xBFEF9A51BE5829B7, 0x3FDF3C7CE0000000, INEXACT);
test_sincos(0x3FE52EFD0CD80497, 0x3FE3AB7ECC98DF9A, 0xBFB98A5AE0000000, 0x3FE93DA10E89D4D1, 0x3FC0446040000000, INEXACT);
test_sincos(0xBFDA05CC754481D1, 0xBFD94FBF72645BFC, 0xBFD77AEBC0000000, 0x3FED64199A5CB117, 0xBFD0B79E20000000, INEXACT);
test_sincos(0x3FE1F9EF934745CB, 0x3FE10BAF3A5F550E, 0xBFD6B8FCE0000000, 0x3FEB150BAE7795B1, 0xBFD35D9260000000, INEXACT);
test_sincos(0x3FE8C5DB097F7442, 0x3FE65F1C5E591DB2, 0xBFDB5EFC20000000, 0x3FE6E164E427022B, 0xBFB5DB4C20000000, INEXACT);
test_sincos(0xBFE5B86EA8118A0E, 0xBFE417318671B83D, 0xBFD87FFC00000000, 0x3FE8E83D35A366C0, 0x3FD3C52400000000, INEXACT);

// Math.imul //////////////////////////////////////////////////////////////////////////////////

assert(NativeMath.imul(2, 4) == 8);
assert(NativeMath.imul(-1, 8) == -8);
assert(NativeMath.imul(-2, -2) == 4);
assert(NativeMath.imul(0xffffffff, 5) == -5);
assert(NativeMath.imul(0xfffffffe, 5) == -10);
assert(NativeMath.imul(1e+60, 1e+60) == 0);
assert(NativeMath.imul(1e+60,-1e+60) == 0);
assert(NativeMath.imul(-1e+60,-1e+60) == 0);
assert(NativeMath.imul(1e+24, 1e2) == -2147483648);
assert(NativeMath.imul(NaN, 1) == 0);
assert(NativeMath.imul(1, Infinity) == 0);
assert(NativeMath.imul(f64.MAX_VALUE, f64.MAX_VALUE) == 0);

// Math.clz32 /////////////////////////////////////////////////////////////////////////////////

assert(NativeMath.clz32(0) == 32);
assert(NativeMath.clz32(1) == 31);
assert(NativeMath.clz32(-1) == 0);
assert(NativeMath.clz32(-128) == 0);
assert(NativeMath.clz32(4294967295.) == 0);
assert(NativeMath.clz32(4294967295.5) == 0);
assert(NativeMath.clz32(4294967296) == 32);
assert(NativeMath.clz32(4294967297) == 31);
assert(NativeMath.clz32(NaN) == 32);
assert(NativeMath.clz32(Infinity) == 32);
assert(NativeMath.clz32(f64.MAX_SAFE_INTEGER) == 0);
assert(NativeMath.clz32(-f64.MAX_SAFE_INTEGER) == 31);
assert(NativeMath.clz32(f64.MAX_VALUE) == 32);
assert(NativeMath.clz32(f64.MIN_VALUE) == 32);
assert(NativeMath.clz32(-f64.MAX_VALUE) == 32);
assert(NativeMath.clz32(f64.EPSILON) == 32);

// ipow64 /////////////////////////////////////////////////////////////////////////////////////

assert(ipow64(0, 0) == 1);
assert(ipow64(0, 1) == 0);
assert(ipow64(0, 2) == 0);
assert(ipow64(0, 3) == 0);

assert(ipow64(1, 0) == 1);
assert(ipow64(1, 1) == 1);
assert(ipow64(1, 2) == 1);
assert(ipow64(1, 3) == 1);

assert(ipow64(2, 0) == 1);
assert(ipow64(2, 1) == 2);
assert(ipow64(2, 2) == 4);
assert(ipow64(2, 3) == 8);

assert(ipow64(-1, 0) ==  1);
assert(ipow64(-1, 1) == -1);
assert(ipow64(-1, 2) ==  1);
assert(ipow64(-1, 3) == -1);

assert(ipow64(-2, 0) ==  1);
assert(ipow64(-2, 1) == -2);
assert(ipow64(-2, 2) ==  4);
assert(ipow64(-2, 3) == -8);

assert(ipow64(2,  63) ==  9223372036854775808);
assert(ipow64(3,  40) ==  12157665459056928801);
assert(ipow64(2,  64) ==  0);                   // should overflow
assert(ipow64(3,  41) == -420491770248316829);  // should overflow
assert(ipow64(3, 128) == -9204772141784466943); // should overflow

assert(ipow64(1, -1) == 1);
assert(ipow64(2, -1) == 0);
assert(ipow64(2, 64) == 0);
assert(ipow64(2, 128) == 0);

// integer pow operators

assert(  0  ** 0 ==  1);
assert(  0  ** 1 ==  0);
assert(  1  ** 3 ==  1);
assert((-2) ** 3 == -8);
assert((-1) ** 0 ==  1);
assert((-1) ** -1 == -1);
assert((-1) ** -2 ==  1);
assert((-1) ** -3 == -1);

assert(false ** -2 == 0);
assert(false ** -1 == 0);
assert(false **  0 == 1);
assert(false **  1 == 0);
assert(false **  2 == 0);

assert(true ** -2 == 1);
assert(true ** -1 == 1);
assert(true **  0 == 1);
assert(true **  1 == 1);
assert(true **  2 == 1);

assert((<i8> 1) ** 3 ==  1);
assert((<i8>-2) ** 3 == -8);
assert((<u16>4) ** 7 ==  16384);
assert((<u16>4) ** 8 ==  0);   // should overflow
assert((<u16>5) ** 10 == 761); // should overflow

assert((<u64>0) ** 0 == 1);
assert((<u64>0) ** 1 == 0);
assert((<u64>1) ** 3 == 1);
assert((<u64>2) ** 3 == 8);
assert((<u64>0xFFFFFFFF) ** 3 == 12884901887);
assert((<u64>0xFFFF) ** 3 == 281462092005375);
assert((<u64>0xFFFF) ** 8 == 18430981595272314881);
assert(0xF123 ** 4 as u64 == 14521559183993082321);
assert(0xF123 as u64 ** 4 == 14521559183993082321);
// Fermat's Last Theorem
assert((<u64>57055) ** 3 + (<u64>339590) ** 3 != (<u64>340126) ** 3); // On JS it return false
assert((<u64>57055) ** 3 + (<u64>339590) ** 3 == 39347712995520375);

assert(1 ** 0.5 == 1.0);
assert(0 ** 0.5 == 0.0);
assert(0 ** -1.0 == Infinity);
assert(0.0 ** 0 == 1.0);
assert(1.0 ** 1 == 1.0);

'''
'''--- tests/compiler/std/mod.js ---
exports.preInstantiate = function(imports, exports) {
  imports.mod = {
    mod: function(a, b) { return a % b; }
  };
};

'''
'''--- tests/compiler/std/mod.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/std/mod.ts ---
const js = true;

export declare function mod(x: f64, y: f64): f64;

function check<T>(actual: T, expected: T): bool {
  if (isNaN(expected)) return isNaN(actual);
  if (expected == 0) return 1 / expected == 1 / actual;
  return actual == expected;
}

// === f64 % f64 ================================

function test_fmod(left: f64, right: f64, expected: f64): bool {
  return  check<f64>(         left % right , expected) &&
  (!js || check<f64>(mod(left , right), expected));
}

// sanity
assert(test_fmod(3.0, 2.0, 1.0));
assert(test_fmod(3.0, -2.0, 1.0));
assert(test_fmod(-3.0, 2.0, -1.0));
assert(test_fmod(-3.0, -2.0, -1.0));
assert(test_fmod(3.5, 2.0, 1.5));
assert(test_fmod(3.5, -2.0, 1.5));
assert(test_fmod(-3.5, 2.0, -1.5));
assert(test_fmod(-3.5, -2.0, -1.5));
assert(test_fmod(3.0, 2.5, 0.5));
assert(test_fmod(3.0, -2.5, 0.5));
assert(test_fmod(-3.0, 2.5, -0.5));
assert(test_fmod(-3.0, -2.5, -0.5));
assert(test_fmod(0.5, 1.0, 0.5));
assert(test_fmod(0.5, -1.0, 0.5));
assert(test_fmod(-0.5, 1.0, -0.5));
assert(test_fmod(-0.5, -1.0, -0.5));
assert(test_fmod(1.5, 1.0, 0.5));
assert(test_fmod(1.5, -1.0, 0.5));
assert(test_fmod(-1.5, 1.0, -0.5));
assert(test_fmod(-1.5, -1.0, -0.5));
assert(test_fmod(1.25, 1.0, 0.25));
assert(test_fmod(1.25, -1.0, 0.25));
assert(test_fmod(-1.25, 1.0, -0.25));
assert(test_fmod(-1.25, -1.0, -0.25));
assert(test_fmod(1.0, 1.25, 1.0));
assert(test_fmod(1.0, -1.25, 1.0));
assert(test_fmod(-1.0, 1.25, -1.0));
assert(test_fmod(-1.0, -1.25, -1.0));
assert(test_fmod(-13, 64, -13));

// special
assert(test_fmod(0.0, 0.0, NaN));
assert(test_fmod(-0.0, 0.0, NaN));
assert(test_fmod(0.0, -0.0, NaN));
assert(test_fmod(-0.0, -0.0, NaN));
assert(test_fmod(0.0, 1.0, 0.0));
assert(test_fmod(-0.0, 1.0, -0.0));
assert(test_fmod(0.0, -1.0, 0.0));
assert(test_fmod(-0.0, -1.0, -0.0));
assert(test_fmod(1.0, 0.0, NaN));
assert(test_fmod(-1.0, 0.0, NaN));
assert(test_fmod(1.0, -0.0, NaN));
assert(test_fmod(-1.0, -0.0, NaN));
assert(test_fmod(NaN, 0.0, NaN));
assert(test_fmod(NaN, -0.0, NaN));
assert(test_fmod(NaN, 1.0, NaN));
assert(test_fmod(NaN, -1.0, NaN));
assert(test_fmod(NaN, 0.0, NaN));
assert(test_fmod(NaN, -0.0, NaN));
assert(test_fmod(NaN, 1.0, NaN));
assert(test_fmod(NaN, -1.0, NaN));
assert(test_fmod(NaN, NaN, NaN));
assert(test_fmod(0.0, Infinity, 0.0));
assert(test_fmod(-0.0, Infinity, -0.0));
assert(test_fmod(0.0, -Infinity, 0.0));
assert(test_fmod(-0.0, -Infinity, -0.0));
assert(test_fmod(1.0, Infinity, 1.0));
assert(test_fmod(-1.0, Infinity, -1.0));
assert(test_fmod(1.0, -Infinity, 1.0));
assert(test_fmod(-1.0, -Infinity, -1.0));
assert(test_fmod(Infinity, 0.0, NaN));
assert(test_fmod(Infinity, -0.0, NaN));
assert(test_fmod(-Infinity, 0.0, NaN));
assert(test_fmod(-Infinity, -0.0, NaN));
assert(test_fmod(Infinity, 1.0, NaN));
assert(test_fmod(Infinity, -1.0, NaN));
assert(test_fmod(-Infinity, 1.0, NaN));
assert(test_fmod(-Infinity, -1.0, NaN));
assert(test_fmod(Infinity, Infinity, NaN));
assert(test_fmod(-Infinity, Infinity, NaN));
assert(test_fmod(Infinity, -Infinity, NaN));
assert(test_fmod(-Infinity, -Infinity, NaN));
assert(test_fmod(Infinity, NaN, NaN));
assert(test_fmod(-Infinity, NaN, NaN));
assert(test_fmod(NaN, Infinity, NaN));
assert(test_fmod(NaN, -Infinity, NaN));

// === f32 % f32 ================================

function test_fmodf(left: f32, right: f32, expected: f32): bool {
  return  check<f32>(left % right, expected);
}

// sanity
assert(test_fmodf(3.0, 2.0, 1.0));
assert(test_fmodf(3.0, -2.0, 1.0));
assert(test_fmodf(-3.0, 2.0, -1.0));
assert(test_fmodf(-3.0, -2.0, -1.0));
assert(test_fmodf(3.5, 2.0, 1.5));
assert(test_fmodf(3.5, -2.0, 1.5));
assert(test_fmodf(-3.5, 2.0, -1.5));
assert(test_fmodf(-3.5, -2.0, -1.5));
assert(test_fmodf(3.0, 2.5, 0.5));
assert(test_fmodf(3.0, -2.5, 0.5));
assert(test_fmodf(-3.0, 2.5, -0.5));
assert(test_fmodf(-3.0, -2.5, -0.5));
assert(test_fmodf(0.5, 1.0, 0.5));
assert(test_fmodf(0.5, -1.0, 0.5));
assert(test_fmodf(-0.5, 1.0, -0.5));
assert(test_fmodf(-0.5, -1.0, -0.5));
assert(test_fmodf(1.5, 1.0, 0.5));
assert(test_fmodf(1.5, -1.0, 0.5));
assert(test_fmodf(-1.5, 1.0, -0.5));
assert(test_fmodf(-1.5, -1.0, -0.5));

// special
assert(test_fmodf(0.0, 0.0, NaN));
assert(test_fmodf(-0.0, 0.0, NaN));
assert(test_fmodf(0.0, -0.0, NaN));
assert(test_fmodf(-0.0, -0.0, NaN));
assert(test_fmodf(1.0, 0.0, NaN));
assert(test_fmodf(-1.0, 0.0, NaN));
assert(test_fmodf(1.0, -0.0, NaN));
assert(test_fmodf(-1.0, -0.0, NaN));
assert(test_fmodf(NaN, 0.0, NaN));
assert(test_fmodf(NaN, -0.0, NaN));
assert(test_fmodf(NaN, 1.0, NaN));
assert(test_fmodf(NaN, -1.0, NaN));
assert(test_fmodf(NaN, 0.0, NaN));
assert(test_fmodf(NaN, -0.0, NaN));
assert(test_fmodf(NaN, 1.0, NaN));
assert(test_fmodf(NaN, -1.0, NaN));
assert(test_fmodf(NaN, NaN, NaN));
assert(test_fmodf(0.0, Infinity, 0.0));
assert(test_fmodf(-0.0, Infinity, -0.0));
assert(test_fmodf(0.0, -Infinity, 0.0));
assert(test_fmodf(-0.0, -Infinity, -0.0));
assert(test_fmodf(1.0, Infinity, 1.0));
assert(test_fmodf(-1.0, Infinity, -1.0));
assert(test_fmodf(1.0, -Infinity, 1.0));
assert(test_fmodf(-1.0, -Infinity, -1.0));
assert(test_fmodf(Infinity, 0.0, NaN));
assert(test_fmodf(Infinity, -0.0, NaN));
assert(test_fmodf(-Infinity, 0.0, NaN));
assert(test_fmodf(-Infinity, -0.0, NaN));
assert(test_fmodf(Infinity, 1.0, NaN));
assert(test_fmodf(Infinity, -1.0, NaN));
assert(test_fmodf(-Infinity, 1.0, NaN));
assert(test_fmodf(-Infinity, -1.0, NaN));
assert(test_fmodf(Infinity, Infinity, NaN));
assert(test_fmodf(-Infinity, Infinity, NaN));
assert(test_fmodf(Infinity, -Infinity, NaN));
assert(test_fmodf(-Infinity, -Infinity, NaN));
assert(test_fmodf(Infinity, NaN, NaN));
assert(test_fmodf(-Infinity, NaN, NaN));
assert(test_fmodf(NaN, Infinity, NaN));
assert(test_fmodf(NaN, -Infinity, NaN));

'''
'''--- tests/compiler/std/new.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/std/new.ts ---
class AClass {
  static aStaticField: i32 = 0;
  aField: i32 = 1;
  anotherField: f32 = 2;
  constructor(value: f32) {
    this.aField += 1;
    this.anotherField = value;
  }
}

var aClass = new AClass(3);

'''
'''--- tests/compiler/std/object.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/std/object.ts ---

// Object.is

assert(Object.is(+0.0, +0.0) == true);
assert(Object.is(+0.0, -0.0) == false);
assert(Object.is(-0.0, +0.0) == false);
assert(Object.is(+0.0, +1.0) == false);
assert(Object.is(+1.0, -1.0) == false);
assert(Object.is(+1.0, +1.0) == true);

assert(Object.is(+Infinity, +Infinity) == true);
assert(Object.is(-Infinity, -Infinity) == true);
assert(Object.is(+Infinity, -Infinity) == false);
assert(Object.is(-Infinity, +Infinity) == false);
assert(Object.is(+Infinity, NaN) == false);
assert(Object.is(NaN, Infinity) == false);
assert(Object.is(NaN, NaN) == true);

assert(Object.is<f32>(+0.0, +0.0) == true);
assert(Object.is<f32>(+0.0, -0.0) == false);
assert(Object.is<f32>(-0.0, +0.0) == false);
assert(Object.is<f32>(+0.0, +1.0) == false);
assert(Object.is<f32>(+1.0, -1.0) == false);
assert(Object.is<f32>(+1.0, +1.0) == true);

assert(Object.is<f32>(+Infinity, +Infinity) == true);
assert(Object.is<f32>(-Infinity, -Infinity) == true);
assert(Object.is<f32>(+Infinity, -Infinity) == false);
assert(Object.is<f32>(-Infinity, +Infinity) == false);
assert(Object.is<f32>(+Infinity, NaN) == false);
assert(Object.is<f32>(NaN, Infinity) == false);
assert(Object.is<f32>(NaN, NaN) == true);

assert(Object.is(-0, 1e-1 * (-1e-308)) == false);
assert(Object.is(-0.0, 1e-1 * (-1e-308)) == false);
assert(Object.is(0, 0.0) == true);

assert(Object.is<i32>(+0, -0) == true);
assert(Object.is<i32>(+1, -1) == false);

assert(Object.is(true, true) == true);
assert(Object.is(true, false) == false);
assert(Object.is(false, false) == true);

assert(Object.is("a", "a") == true);
assert(Object.is("a", "b") == false);
assert(Object.is("a", "ab") == false);

assert(Object.is<string | null>(null, null) == true);
assert(Object.is<string | null>("", null) == false);
assert(Object.is<string | null>(null, "") == false);

'''
'''--- tests/compiler/std/operator-overloading.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/std/operator-overloading.ts ---
class Tester {
  constructor(public x: i32, public y: i32) {
  }

  @operator("+")
  static add(a: Tester, b: Tester): Tester {
    return new Tester(a.x + b.x, a.y + b.y);
  }

  @operator("-")
  static sub(a: Tester, b: Tester): Tester {
    return new Tester(a.x - b.x, a.y - b.y);
  }

  @operator("*")
  static mul(a: Tester, b: Tester): Tester {
    return new Tester(a.x * b.x, a.y * b.y);
  }

  @operator("/")
  static div(a: Tester, b: Tester): Tester {
    return new Tester(a.x / b.x, a.y / b.y);
  }

  @operator("%")
  static mod(a: Tester, b: Tester): Tester {
    return new Tester(a.x % b.x, a.y % b.y);
  }

  @operator("**")
  static pow(a: Tester, b: Tester): Tester {
    return new Tester(<i32>(a.x ** b.x), <i32>(a.y ** b.y));
  }

  @operator("|")
  static or(a: Tester, b: Tester): Tester {
    return new Tester(a.x | b.x, a.y | b.y);
  }

  @operator("&")
  static and(a: Tester, b: Tester): Tester {
    return new Tester(a.x & b.x, a.y & b.y);
  }

  @operator("^")
  static xor(a: Tester, b: Tester): Tester {
    return new Tester(a.x ^ b.x, a.y ^ b.y);
  }

  @operator("==")
  static equals(a: Tester, b: Tester): bool {
    return a.x == b.x && a.y == b.y;
  }

  @operator("!=")
  static notEquals(a: Tester, b: Tester): bool {
    return a.x != b.x && a.y != b.y;
  }

  @operator(">")
  static greater(a: Tester, b: Tester): bool {
    return a.x > b.x && a.y > b.y;
  }

  @operator(">=")
  static greaterEquals(a: Tester, b: Tester): bool {
    return a.x >= b.x && a.y >= b.y;
  }

  @operator("<")
  static less(a: Tester, b: Tester): bool {
    return a.x < b.x && a.y < b.y;
  }

  @operator("<=")
  static lessEquals(a: Tester, b: Tester): bool {
    return a.x <= b.x && a.y <= b.y;
  }

  @operator(">>")
  static shr(value: Tester, shift: i32): Tester {
    return new Tester(value.x >> shift, value.y >> shift);
  }

  @operator(">>>")
  static shu(value: Tester, shift: i32): Tester {
    return new Tester(value.x >>> shift, value.y >>> shift);
  }

  @operator("<<")
  static shl(value: Tester, shift: i32): Tester {
    return new Tester(value.x << shift, value.y << shift);
  }

  // unary opterators
  @operator.prefix("~")
  static not(value: Tester): Tester {
    return new Tester(~value.x, ~value.y);
  }

  @operator.prefix("!")
  static excl(value: Tester): bool {
    return !value.x && !value.y;
  }

  @operator.prefix("+")
  static pos(value: Tester): Tester {
    return new Tester(+value.x, +value.y);
  }

  @operator.prefix("-")
  static neg(value: Tester): Tester {
    return new Tester(-value.x, -value.y);
  }

  @operator.prefix("++")
  inc(): this {
    ++this.x;
    ++this.y;
    return this;
  }

  @operator.prefix("--")
  dec(): this {
    --this.x;
    --this.y;
    return this;
  }

  @operator.postfix("++")
  postInc(): Tester {
    return new Tester(this.x + 1, this.y + 1);
  }

  @operator.postfix("--")
  postDec(): Tester {
    return new Tester(this.x - 1, this.y - 1);
  }
}

// check additional
var a1 = new Tester(1, 2);
var a2 = new Tester(2, 3);
var a  = a1 + a2;
assert(a.x == 3 && a.y == 5);

// check subtraction
var s1 = new Tester(2, 3);
var s2 = new Tester(2,-3);
var s  = s1 - s2;
assert(s.x == 0 && s.y == 6);

// check multiplication
var m1 = new Tester(2, 5);
var m2 = new Tester(3, 2);
var m  = m1 * m2;
assert(m.x == 6 && m.y == 10);

// check division
var d1 = new Tester(6, 50);
var d2 = new Tester(3, 10);
var d  = d1 / d2;
assert(d.x == 2 && d.y == 5);

// check remainder
var f1 = new Tester(10, 10);
var f2 = new Tester(6, 10);
var f  = f1 % f2;
assert(f.x == 4 && f.y == 0);

// check power
var p1 = new Tester(2, 3);
var p2 = new Tester(4, 5);
var p  = p1 ** p2;
assert(p.x == 16 && p.y == 243);

// check bitwise and
var n1 = new Tester(0xFF, 0x0F);
var n2 = new Tester(0x0F, 0xFF);
var n  = n1 & n2;
assert(n.x == 0xF && n.y == 0xF);

// check bitwise or
var o1 = new Tester(0x0F0F, 0xFF);
var o2 = new Tester(0xF0F0, 0x00);
var o  = o1 | o2;
assert(o.x == 0xFFFF && o.y == 0xFF);

// check bitwise xor
var x1 = new Tester(0x00FF, 0xFF);
var x2 = new Tester(0xFF00, 0x00);
var x  = x1 ^ x2;
assert(x.x == 0xFFFF && x.y == 0xFF);

// check truthfully equal
var eq1 = new Tester(1, -2);
var eq2 = new Tester(1, -2);
var eq  = eq1 == eq2;
assert(eq == true);

// check falsely equal
var eq3 = new Tester(1, 0);
var eq4 = new Tester(0, 1);
var eqf = eq3 == eq4;
assert(eqf == false);

// check falsely non-equal
eq = eq1 != eq2;
assert(eq == false);

// check truthfully non-equal
eqf = eq3 != eq4;
assert(eqf == true);

// check greater
var gt1 = new Tester(2, i32.MAX_VALUE);
var gt2 = new Tester(1, 0);
var gt  = gt1 > gt2;
assert(gt == true);

// check greater or equal
var gte1 = new Tester(2, 2);
var gte2 = new Tester(2, 2);
var gte  = gte1 >= gte2;
assert(gte == true);

// check less
var le1 = new Tester(5,-1);
var le2 = new Tester(6, 6);
var le  = le1 < le2;
assert(le == true);

// check less or equal
var leq1 = new Tester(4, 3);
var leq2 = new Tester(4, 3);
var leq  = leq1 <= leq2;
assert(leq == true);

// check right shift
var shr  = new Tester(8, 16);
var sres = shr >> 3;
assert(sres.x == 1 && sres.y == 2);

// check right shift
var shu  = new Tester(-8, -16);
var ures = shu >>> 3;
assert(ures.x == 536870911 && ures.y == 536870910);

// check left shift
var shl = new Tester(1, 2);
sres = shl << 3;
assert(sres.x == 8 && sres.y == 16);

// check unary positive
var pos = new Tester(1, -2);
var pres = +pos;
assert(pres.x == pos.x && pres.y == pos.y);

// check unary negative
var neg = new Tester(-1, -2);
var nres = -neg;
assert(nres.x == -neg.x && nres.y == -neg.y);

// check unary not "~"
var not = new Tester(0xFF, 0x10);
var res = ~not;
assert(res.x == ~not.x && res.y == ~not.y);

// check unary exclamation "!"
var excl = new Tester(0, 0);
var bres = !excl;
assert(bres == (!excl.x && !excl.y));
assert(bres == true);

//
var incdec = new Tester(0, 1);

++incdec;
assert(incdec.x == 1 && incdec.y == 2);

--incdec;
assert(incdec.x == 0 && incdec.y == 1);

incdec = new Tester(0, 1);

var tmp = incdec++;
assert(tmp.x == 0 && tmp.y == 1);
assert(incdec.x == 1 && incdec.y == 2);

tmp = incdec--;
assert(tmp.x == 1 && tmp.y == 2);
assert(incdec.x == 0 && incdec.y == 1);

// check inlined static
class TesterInlineStatic {
  constructor(public x: i32, public y: i32) {
  }
  @inline @operator("+")
  static add(a: TesterInlineStatic, b: TesterInlineStatic): TesterInlineStatic {
    return new TesterInlineStatic(a.x + b.x, a.y + b.y);
  }

  @inline @operator.postfix("++")
  static postInc(a: TesterInlineStatic): TesterInlineStatic {
    return new TesterInlineStatic(a.x + 1, a.y + 1);
  }
}
var ais1 = new TesterInlineStatic(1, 2);
ais1 = ais1++; // 2, 3 (static skips re-assign)
var ais2 = new TesterInlineStatic(2, 3);
var ais  = ais1 + ais2;
assert(ais.x == 4 && ais.y == 6);

// check inlined instance
class TesterInlineInstance {
  constructor(public x: i32, public y: i32) {
  }
  @inline @operator("+")
  add(b: TesterInlineInstance): TesterInlineInstance {
    return new TesterInlineInstance(this.x + b.x, this.y + b.y);
  }

  @inline @operator.postfix("++")
  postInc(): TesterInlineInstance {
    return new TesterInlineInstance(this.x + 1, this.y + 1);
  }
}
var aii1 = new TesterInlineInstance(1, 2);
aii1++; // 2, 3
var aii2 = new TesterInlineInstance(2, 3);
var aii  = aii1 + aii2;
assert(aii.x == 4 && aii.y == 6);

'''
'''--- tests/compiler/std/pointer.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/std/pointer.ts ---
// A pointer arithmetic experiment

@final @unmanaged class Pointer<T> {

  @inline constructor(offset: usize = 0) {
    return changetype<Pointer<T>>(offset);
  }

  @inline get offset(): usize {
    return changetype<usize>(this);
  }

  @inline get value(): T {
    if (isReference<T>()) {
      return changetype<T>(changetype<usize>(this));
    } else {
      return load<T>(changetype<usize>(this));
    }
  }

  @inline set value(value: T) {
    if (isReference<T>()) {
      if (isManaged<T>()) ERROR("Unsafe unmanaged set of a managed object");
      if (value === null) {
        memory.fill(changetype<usize>(this), 0, offsetof<T>());
      } else {
        memory.copy(changetype<usize>(this), changetype<usize>(value), offsetof<T>());
      }
    } else {
      store<T>(changetype<usize>(this), value);
    }
  }

  // FIXME: in general, inlining any of the following always yields a block. one could argue that
  // this helps debuggability, or that it is unnecessary overhead due to the simplicity of the
  // functions. a compromise could be to inline a block consisting of a single 'return' as is,
  // where possible.

  @inline @operator("+") add(other: Pointer<T>): Pointer<T> {
    return changetype<Pointer<T>>(changetype<usize>(this) + changetype<usize>(other));
  }

  @inline @operator("-") sub(other: Pointer<T>): Pointer<T> {
    return changetype<Pointer<T>>(changetype<usize>(this) - changetype<usize>(other));
  }

  @inline @operator.prefix("++") inc(): Pointer<T> {
    // FIXME: this should take alignment into account, but then would require a new builtin to
    // determine the minimal alignment of a struct by evaluating its field layout.
    const size = isReference<T>() ? offsetof<T>() : sizeof<T>();
    return changetype<Pointer<T>>(changetype<usize>(this) + size);
  }

  @inline @operator.prefix("--") dec(): Pointer<T> {
    const size = isReference<T>() ? offsetof<T>() : sizeof<T>();
    return changetype<Pointer<T>>(changetype<usize>(this) - size);
  }

  @inline @operator("[]") get(index: i32): T {
    const size = isReference<T>() ? offsetof<T>() : sizeof<T>();
    return load<T>(changetype<usize>(this) + (<usize>index * size));
  }

  @inline @operator("[]=") set(index: i32, value: T): void {
    const size = isReference<T>() ? offsetof<T>() : sizeof<T>();
    store<T>(changetype<usize>(this) + (<usize>index * size), value);
  }
}

@unmanaged
class Entry {
  key: i32;
  val: i32;
}

var one = new Pointer<Entry>(8);
var two = new Pointer<Entry>(24);
assert(one.offset == 8);
assert(two.offset == 24);

one.value.key = 1;
one.value.val = 2;
assert(one.value.key == 1);
assert(one.value.val == 2);

var add = one + two;
assert(add.offset == 32);

var sub = two - one;
assert(sub.offset == 16);

assert(one.offset == 8);
var nextOne = ++one;
assert(nextOne === one);
assert(one.offset == 16);

assert(two.offset == 24);
--two;
--two;
assert(two.offset == 8);
assert(two.value.key == 1);
assert(two.value.val == 2);

one.value = two.value;
assert(one.offset != two.offset);
assert(one.value.key == 1);
assert(one.value.val == 2);

var buf = new Pointer<f32>(0);
buf[0] = 1.1;
buf[1] = 1.2;

assert(buf[0] == 1.1);
assert(buf[1] == 1.2);

assert(buf.get(0) == 1.1);
assert(buf.get(1) == 1.2);

assert(load<f32>(0) == 1.1);
assert(load<f32>(4) == 1.2);

buf.set(2, 1.3);
assert(buf[2] == 1.3);
assert(buf.get(2) == 1.3);
assert(load<f32>(8) == 1.3);

buf.value = 1.4;
assert(buf.value == 1.4);
assert(load<f32>(0) == 1.4);

'''
'''--- tests/compiler/std/polyfills.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/std/polyfills.ts ---
// bswap / bswap16 tests

// check bswap<T> for i8/u8
assert(bswap<u8>(<u8>0xaa) == <u8>0xaa);
assert(bswap<i8>(<i8>0xaa) == <i8>0xaa);

// check bswap<T> for i16/u16
assert(bswap<u16>(<u16>0xaabb) == <u16>0xbbaa);
assert(bswap<i16>(<i16>0xaabb) == <i16>0xbbaa);

// check bswap<T> for i32/u32
assert(bswap<u32>(<u32>0xaabbccdd) == <u32>0xddccbbaa);
assert(bswap<i32>(<i32>0xaabbccdd) == <i32>0xddccbbaa);

// check bswap<T> for i64/u64
assert(bswap<u64>(<u64>0x00112233aabbccdd) == <u64>0xddccbbaa33221100);
assert(bswap<i64>(<i64>0x00112233aabbccdd) == <i64>0xddccbbaa33221100);

// check bswap<T> for i32/u32
assert(bswap<usize>(<usize>0xaabbccdd) == <usize>0xddccbbaa);
assert(bswap<isize>(<isize>0xaabbccdd) == <isize>0xddccbbaa);

// check bswap16<T> for i8/u8
assert(bswap16<u8>(<u8>0xaa) == <u8>0xaa);
assert(bswap16<i8>(<i8>0xaa) == <i8>0xaa);

// check bswap16<T> for i16/u16
assert(bswap16<u16>(<u16>0xaabb) == <u16>0xbbaa);
assert(bswap16<i16>(<i16>0xaabb) == <i16>0xbbaa);

// check bswap16<T> for i32/u32
assert(bswap16<u32>(<u32>0xff88aabb) == <u32>0xff88bbaa);
assert(bswap16<i32>(<i32>0xff88aabb) == <i32>0xff88bbaa);

'''
'''--- tests/compiler/std/set.json ---
{
  "asc_flags": [
  ],
  "asc_rtrace": true
}

'''
'''--- tests/compiler/std/set.ts ---
function testNumeric<K extends number>(): void {
  var set = new Set<K>();

  // insert new
  for (let k: K = 0; k < 100; ++k) {
    assert(!set.has(k));
    set.add(k);
    assert(set.has(k));
  }
  assert(set.size == 100);

  // insert duplicate
  for (let k: K = 50; k < 100; ++k) {
    assert(set.has(k));
    set.add(k);
    assert(set.has(k));
  }
  assert(set.size == 100);

  // values 
  let vals = set.values();
  let valSet = new Set<K>(); 
  for (let index = 0; index < vals.length; ++index) {
    assert(set.has(vals[index]));
    valSet.add(vals[index]);
  }
  assert(valSet.size == set.size);

  // delete
  for (let k: K = 0; k < 50; ++k) {
    assert(set.has(k));
    set.delete(k);
    assert(!set.has(k));
  }
  assert(set.size == 50);

  // insert + delete
  for (let k: K = 0; k < 50; ++k) {
    assert(!set.has(k));
    set.add(k);
    assert(set.has(k));
    set.delete(k);
    assert(!set.has(k));
  }
  assert(set.size == 50);

  // clear
  set.clear();
  assert(set.size == 0);
}

testNumeric<i8>();
testNumeric<u8>();
testNumeric<i16>();
testNumeric<u16>();
testNumeric<i32>();
testNumeric<u32>();
testNumeric<i64>();
testNumeric<u64>();
testNumeric<f32>();
testNumeric<f64>();

__collect();

'''
'''--- tests/compiler/std/simd.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/std/simd.ts ---
// hint: asc tests/compiler/std/simd --enable simd

@final
class I8x16 {

  @inline static from(vec: v128): I8x16 {
    return changetype<I8x16>(vec);
  }

  // TODO: not possible due to arguments becoming locals, no longer being compile-time constants
  // @inline constructor(
  //   a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8, i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8
  // ) {
  //   return changetype<I8x16>(i8x16(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p));
  // }
  private constructor() { unreachable(); }

  @inline @operator("+")
  add(vec: I8x16): I8x16 {
    return changetype<I8x16>(v128.add<i8>(changetype<v128>(this), changetype<v128>(vec)));
  }
}

function test_I8x16(): void {
  var a = I8x16.from(i8x16(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16));
  var c = a + a;
}

if (ASC_FEATURE_SIMD) {
  test_I8x16();
}

'''
'''--- tests/compiler/std/static-array.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/std/static-array.ts ---
const i: i32[] = [1, 2];
const I: i64[] = [3, 4];
const f: f32[] = [1.5, 2.5];
const F: f64[] = [1.25, 2.25];

assert(i.length == 2);
assert(i[0] == 1);
assert(i[1] == 2);
i[0] = 2;
assert(i[0] == 2);

assert(I.length == 2);
assert(I[0] == 3);
assert(I[1] == 4);
I[0] = 4;
assert(I[0] == 4);

assert(f.length == 2);
assert(f[0] == 1.5);
assert(f[1] == 2.5);
f[0] = 2.5;
assert(f[0] == 2.5);

assert(F.length == 2);
assert(F[0] == 1.25);
assert(F[1] == 2.25);
F[0] = 2.25;
assert(F[0] == 2.25);

'''
'''--- tests/compiler/std/staticarray.json ---
{
  "asc_flags": [
  ],
  "asc_rtrace": true
}

'''
'''--- tests/compiler/std/staticarray.ts ---
import { OBJECT, TOTAL_OVERHEAD } from "rt/common";

// from contextual type
const arr1: StaticArray<i32> = [1,2,3];
assert(arr1[1] == 2);
assert(arr1.length == 3);
arr1[1] = 4;
assert(arr1[1] == 4);
assert(changetype<OBJECT>(changetype<usize>(arr1) - TOTAL_OVERHEAD).rtId == idof<StaticArray<i32>>());

// from assertion
const arr2 = [1,2,3] as StaticArray<i32>;
assert(arr2[1] == 2);
assert(arr2.length == 3);
arr2[1] = 4;
assert(arr2[1] == 4);

// unique copy
function test(): StaticArray<i32> {
  return [5,6,7];
}
var arr3 = test();
assert(arr3[0] == 5);
assert(arr3[1] == 6);
assert(arr3[2] == 7);
assert(arr3.length == 3);
arr3[1] = 8;
assert(arr3[1] == 8);
arr3 = test();
assert(arr3[1] == 6);

// non-static instantiation
class Ref {}
var arr4: StaticArray<Ref> = [ new Ref(), new Ref() ];

arr3 = changetype<StaticArray<i32>>(0); // unleak
arr4 = changetype<StaticArray<Ref>>(0);

// constructor

{
  const source = new StaticArray<i32>(3);
  assert(source.length == 3);
  for (let i = 0; i < source.length; i++) {
    assert(source[i] == 0);
  }
}

// fromArray

{
  const source: i32[] = [0, 1, 1, 2, 3, 5];
  let subject = StaticArray.fromArray(source);
  assert(subject.length == source.length);
  for (let i = 0; i < source.length; i++) {
    assert(subject[i] == source[i]);
  }
  subject = StaticArray.fromArray<i32>([]);
  assert(subject.length == 0);
}

// concat

{
  let source: StaticArray<i32> = [1, 2];
  let result = StaticArray.concat(source, [1]);
  assert(result.length == 3);
  result = StaticArray.concat(source, []);
  assert(result.length == source.length);
}

// slice
{
  const source: StaticArray<string> = ['ant', 'bison', 'camel', 'duck', 'elephant'];
  let result = StaticArray.slice(source);
  assert(result.length == source.length);

  for(let i = 0; i < source.length; i++) {
    assert(source[i] == result[i]);
  }

  result = StaticArray.slice(source, 1, 3);
  assert(result.length == 2);
  assert(result[0] == "bison");
  assert(result[1] == "camel");

  result = StaticArray.slice(source, 1);
  assert(result.length == (source.length - 1));

  result = StaticArray.slice(source, 0, 50);
  assert(result.length == source.length);

  result = StaticArray.slice(source, 100);
  assert(result.length == 0);

  result = StaticArray.slice(source, -1);
  assert(result.length == 1);
  assert(result[0] == "elephant");

  result = StaticArray.slice(source, -2, -2);
  assert(result.length == 0);

  result = StaticArray.slice(source, 2, -2);
  assert(result.length == 1);
  assert(result[0] == "camel");
}

// concat
{
  const source: StaticArray<string> = ['ant', 'bison', 'camel', 'duck', 'elephant'];

  let result = source.concat([]);
  assert(result.length == source.length);
  assert(isArray(result));

  result = source.concat(["foo"]);
  assert(result.length == (source.length + 1));
  assert(isArray(result));
}

// includes
{
  const source: StaticArray<string> = ['ant', 'bison', 'camel', 'duck', 'elephant'];
  assert(source.includes("bison") == true);
  assert(source.includes("foo") == false);
  assert(source.includes("elephant", 5) == false);
  assert(source.includes("elephant", -1) == true);

  assert(([NaN] as StaticArray<f64>).includes(NaN) == true);
  assert(([NaN] as StaticArray<f32>).includes(NaN) == true);
}

// indexOf
{
  const array: StaticArray<i32> = [2, 9, 9];
  assert(array.indexOf(2) == 0);
  assert(array.indexOf(7) == -1);
  assert(array.indexOf(9, 2) == 2);
  assert(array.indexOf(2, -1) == -1);
  assert(array.indexOf(2, -3) == 0);
}

// join + toString
{
  const elements = ['Fire', 'Air', 'Water'];
  assert(elements.join() == "Fire,Air,Water");
  assert(elements.join('') == "FireAirWater");
  assert(elements.join('-') == "Fire-Air-Water");
  assert(elements.join(' + ') == "Fire + Air + Water");
  assert(elements.join() == elements.toString());
}

// lastIndexOf
{
  var numbers = [2, 5, 9, 2];
  assert(numbers.lastIndexOf(2) == 3);
  assert(numbers.lastIndexOf(7) == -1);
  assert(numbers.lastIndexOf(2, 3) == 3);
  assert(numbers.lastIndexOf(2, 2) == 0);
  assert(numbers.lastIndexOf(2, -2) == 0);
  assert(numbers.lastIndexOf(2, -1) == 3);
}

__stack_pointer = __heap_base;
__collect();

'''
'''--- tests/compiler/std/string-casemapping.js ---
exports.preInstantiate = function preInstantiate(imports) {
  imports.string_casemapping = {
    toUpperCaseFromIndex: function toUpperCaseFromIndex(index, codePointIndex) {
      const code = String.fromCodePoint(index).toUpperCase().codePointAt(codePointIndex|0);
      return code !== undefined ? code : -1;
    },
    toLowerCaseFromIndex: function toLowerCaseFromIndex(index, codePointIndex) {
      const code = String.fromCodePoint(index).toLowerCase().codePointAt(codePointIndex|0);
      return code !== undefined ? code : -1;
    }
  };
};

'''
'''--- tests/compiler/std/string-casemapping.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/std/string-casemapping.ts ---
@external("string_casemapping", "toUpperCaseFromIndex")
declare function toUpperCaseFromIndex(index: i32, codePointIndex: i32): i32;

@external("string_casemapping", "toLowerCaseFromIndex")
declare function toLowerCaseFromIndex(index: i32, codePointIndex: i32): i32;

// Basic case mapping tests
assert("".toUpperCase() == "");
assert("".toLowerCase() == "");
assert("09_AZ az.!\n".toUpperCase() == "09_AZ AZ.!\n");
assert("09_AZ az.!\t".toLowerCase() == "09_az az.!\t");
assert("Der Wechsel allein ist das BestÃ¤ndige".toUpperCase() == "DER WECHSEL ALLEIN IST DAS BESTÃ„NDIGE");
assert("DER WECHSEL ALLEIN IST DAS BESTÃ„NDIGE".toLowerCase() == "der wechsel allein ist das bestÃ¤ndige");
assert("@ â€” Ð”Ñ€ÑƒÐ³ Ñ‡ÐµÐ»Ð¾Ð²ÐµÐºÐ°!".toUpperCase() == "@ â€” Ð”Ð Ð£Ð“ Ð§Ð•Ð›ÐžÐ’Ð•ÐšÐ!");
assert("@ â€” Ð”Ð Ð£Ð“ Ð§Ð•Ð›ÐžÐ’Ð•ÐšÐ!".toLowerCase() == "@ â€” Ð´Ñ€ÑƒÐ³ Ñ‡ÐµÐ»Ð¾Ð²ÐµÐºÐ°!");
assert("âˆ® Eâ‹…da = Q, n â†’ âˆž, âˆ‘ f(i) = âˆ g(i)".toUpperCase() == "âˆ® Eâ‹…DA = Q, N â†’ âˆž, âˆ‘ F(I) = âˆ G(I)");
assert("âˆ® Eâ‹…DA = Q, N â†’ âˆž, âˆ‘ F(I) = âˆ G(I)".toLowerCase() == "âˆ® eâ‹…da = q, n â†’ âˆž, âˆ‘ f(i) = âˆ g(i)");
assert("Ã°i Ä±ntÉ™ËˆnÃ¦ÊƒÉ™nÉ™l fÉ™ËˆnÉ›tÄ±k É™soÊŠsiËˆeÄ±Êƒn".toUpperCase() == "ÃI INTÆËˆNÃ†Æ©ÆNÆL FÆËˆNÆTIK ÆSOÆ±SIËˆEIÆ©N");
assert("ÃI INTÆËˆNÃ†Æ©ÆNÆL FÆËˆNÆTIK ÆSOÆ±SIËˆEIÆ©N".toLowerCase() == "Ã°i intÉ™ËˆnÃ¦ÊƒÉ™nÉ™l fÉ™ËˆnÉ›tik É™soÊŠsiËˆeiÊƒn");
assert("Î£á½² Î³Î½Ï‰ÏÎ¯Î¶Ï‰ á¼€Ï€á½¸ Ï„á½´Î½ ÎºÏŒÏˆÎ·".toUpperCase() == "Î£á¿ˆ Î“ÎÎ©Î¡ÎŠÎ–Î© á¼ˆÎ á¿¸ Î¤á¿ŠÎ ÎšÎŒÎ¨Î—");
assert("Ï„Î¿á¿¦ ÏƒÏ€Î±Î¸Î¹Î¿á¿¦ Ï„á½´Î½ Ï„ÏÎ¿Î¼ÎµÏÎ®,".toUpperCase() == "Î¤ÎŸÎ¥Í‚ Î£Î Î‘Î˜Î™ÎŸÎ¥Í‚ Î¤á¿ŠÎ Î¤Î¡ÎŸÎœÎ•Î¡Î‰,");
assert("Ïƒá½² Î³Î½Ï‰ÏÎ¯Î¶Ï‰ á¼€Ï€á½¸ Ï„á½´Î½ á½„ÏˆÎ·".toUpperCase() == "Î£á¿ˆ Î“ÎÎ©Î¡ÎŠÎ–Î© á¼ˆÎ á¿¸ Î¤á¿ŠÎ á½ŒÎ¨Î—");
assert("Ï€Î¿á½º Î¼á½² Î²Î¯Î± Î¼ÎµÏ„ÏÎ¬ÎµÎ¹ Ï„á½´ Î³á¿†.".toUpperCase() == "Î ÎŸá¿ª Îœá¿ˆ Î’ÎŠÎ‘ ÎœÎ•Î¤Î¡Î†Î•Î™ Î¤á¿Š Î“Î—Í‚.");
assert("Î‘Ï€á¾¿ Ï„á½° ÎºÏŒÎºÎºÎ±Î»Î± Î²Î³Î±Î»Î¼Î­Î½Î·".toUpperCase() == "Î‘Î á¾¿ Î¤á¾º ÎšÎŒÎšÎšÎ‘Î›Î‘ Î’Î“Î‘Î›ÎœÎˆÎÎ—");
assert("Ï„á¿¶Î½ á¿¾Î•Î»Î»Î®Î½Ï‰Î½ Ï„á½° á¼±ÎµÏÎ¬".toUpperCase() == "Î¤Î©Í‚Î á¿¾Î•Î›Î›Î‰ÎÎ©Î Î¤á¾º á¼¹Î•Î¡Î†");
assert("ÎºÎ±á½¶ Ïƒá½°Î½ Ï€Ïá¿¶Ï„Î± á¼€Î½Î´ÏÎµÎ¹Ï‰Î¼Î­Î½Î·".toUpperCase() == "ÎšÎ‘á¿š Î£á¾ºÎ Î Î¡Î©Í‚Î¤Î‘ á¼ˆÎÎ”Î¡Î•Î™Î©ÎœÎˆÎÎ—");
assert("Ï‡Î±á¿–ÏÎµ, á½¦ Ï‡Î±á¿–ÏÎµ, á¾¿Î•Î»ÎµÏ…Î¸ÎµÏÎ¹Î¬!".toUpperCase() == "Î§Î‘Î™Í‚Î¡Î•, á½® Î§Î‘Î™Í‚Î¡Î•, á¾¿Î•Î›Î•Î¥Î˜Î•Î¡Î™Î†!");
assert(
  "ABCDEFGHIJKLMNOPQRSTUVWXYZ /0123456789abcdefghijklmnopqrstuvwxyz".toUpperCase() ==
  "ABCDEFGHIJKLMNOPQRSTUVWXYZ /0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
);
assert(
  "ABCDEFGHIJKLMNOPQRSTUVWXYZ /0123456789abcdefghijklmnopqrstuvwxyz".toLowerCase() ==
  "abcdefghijklmnopqrstuvwxyz /0123456789abcdefghijklmnopqrstuvwxyz"
);
assert("ÃŸ".toUpperCase() == "SS");
assert("Ä°".toLowerCase() == "iÌ‡"); // 0x0130
assert(
  "Â£Â©ÂµÃ€Ã†Ã–ÃžÃŸÃ©Ã¶Ã¿â€“â€”â€˜â€œâ€â€žâ€ â€¢â€¦â€°â„¢Å“Å Å¸Å¾â‚¬ Î‘Î’Î“Î”Î©Î±Î²Î³Î´Ï‰ ÐÐ‘Ð’Ð“Ð”Ð°Ð±Ð²Ð³Ð´âˆ€âˆ‚âˆˆâ„âˆ§âˆªâ‰¡âˆž â†‘â†—â†¨â†»â‡£ â”â”¼â•”â•˜â–‘â–ºâ˜ºâ™€ ï¬ï¿½â‘€â‚‚á¼ á¸‚Ó¥áº„ÉËâŽ×Ô±áƒ".toUpperCase() ==
  "Â£Â©ÎœÃ€Ã†Ã–ÃžSSÃ‰Ã–Å¸â€“â€”â€˜â€œâ€â€žâ€ â€¢â€¦â€°â„¢Å’Å Å¸Å½â‚¬ Î‘Î’Î“Î”Î©Î‘Î’Î“Î”Î© ÐÐ‘Ð’Ð“Ð”ÐÐ‘Ð’Ð“Ð”âˆ€âˆ‚âˆˆâ„âˆ§âˆªâ‰¡âˆž â†‘â†—â†¨â†»â‡£ â”â”¼â•”â•˜â–‘â–ºâ˜ºâ™€ FIï¿½â‘€â‚‚á¼¨á¸‚Ó¤áº„â±¯ËâŽ×Ô±á²"
);
assert("ÃŸ".toUpperCase().toLowerCase() == "ss");
assert("ï¬".toUpperCase().toLowerCase() == "fi");
assert(
  "ð œŽ ð œ± ð ¹ ð ±“ ð ±¸ ð ²– ð ³ ð ³• ð ´• ð µ¼ ð µ¿ ð ¸Ž ð ¸ ð ¹· ð º ð º¢ ð »— ð »¹ ð »º ð ¼­ ð ¼® ð ½Œ ð ¾´ ð ¾¼ ð ¿ª ð¡œ ð¡¯ ð¡µ ð¡¶ ð¡» ð¡ƒ".toUpperCase().toLowerCase()
  ==
  "ð œŽ ð œ± ð ¹ ð ±“ ð ±¸ ð ²– ð ³ ð ³• ð ´• ð µ¼ ð µ¿ ð ¸Ž ð ¸ ð ¹· ð º ð º¢ ð »— ð »¹ ð »º ð ¼­ ð ¼® ð ½Œ ð ¾´ ð ¾¼ ð ¿ª ð¡œ ð¡¯ ð¡µ ð¡¶ ð¡» ð¡ƒ"
);

assert(String.fromCodePoint(0x10000).toLowerCase() == "ð€€");
assert(String.fromCodePoint(0x10000).toUpperCase() == "ð€€");

// Tests some special casing for lower case mapping
assert("\u1F88".toLowerCase() == "\u1F80");
assert("\u1F8F".toLowerCase() == "\u1F87");
assert("\u1FFC".toLowerCase() == "\u1FF3");

// Tests sigma 'Î£' special cases
assert("Î£".toLowerCase() == "Ïƒ");
assert(" Î£".toLowerCase() == " Ïƒ");
assert("Î£ ".toLowerCase() == "Ïƒ ");
assert(" Î£ ".toLowerCase() == " Ïƒ ");
assert("aÎ£ ".toLowerCase() == "aÏ‚ ");
assert("aÎ£\n".toLowerCase() == "aÏ‚\n");
assert("aÎ£".toLowerCase() == "aÏ‚");
assert("aÎ£b".toLowerCase() == "aÏƒb");
assert("Î£Î£ ".toLowerCase() == "ÏƒÏ‚ ");
assert("1Î£ ".toLowerCase() == "1Ïƒ ");
assert(";Î£ ".toLowerCase() == ";Ïƒ ");
assert("\u0301Î£ ".toLowerCase() == "\u0301Ïƒ ");

assert("Î£\u0301Î£\u0301 ".toLowerCase() == "ÏƒÌÏ‚Ì ");
assert("Î£Î£-".toLowerCase() == "ÏƒÏ‚-");
assert("Î£\u0301Î£\u0301-".toLowerCase() == "ÏƒÌÏ‚Ì-");
assert("Î£\u0301Î£\u0301çŒª".toLowerCase() == "ÏƒÌÏ‚ÌçŒª");

// sigma tests from Test262
assert("\uD835\uDCA2\u03A3".toLowerCase() == "\uD835\uDCA2\u03C2");
assert("A.\u03A3".toLowerCase() == "a.\u03C2");
assert("A\u00AD\u03A3".toLowerCase() == "a\u00AD\u03C2");
assert("A\uD834\uDE42\u03A3".toLowerCase() == "a\uD834\uDE42\u03C2");
assert("\u0345\u03A3".toLowerCase() == "\u0345\u03C3");
assert("\u0391\u0345\u03A3".toLowerCase() == "\u03B1\u0345\u03C2");
assert("A\u03A3B".toLowerCase() == "a\u03C3b");
assert("A\u03A3\uD835\uDCA2".toLowerCase() == "a\u03C3\uD835\uDCA2");
assert("A\u03A3.b".toLowerCase() == "a\u03C3.b");
assert("A\u03A3\u00ADB".toLowerCase() == "a\u03C3\u00ADb");
assert("A\u03A3\uD834\uDE42B".toLowerCase() == "a\u03C3\uD834\uDE42b");
assert("A\u03A3\u0345".toLowerCase() == "a\u03C2\u0345");
assert("A\u03A3\u0345\u0391".toLowerCase() == "a\u03C3\u0345\u03B1");
assert("A\u180E\u03A3".toLowerCase() == "a\u180E\u03C2");
assert("A\u180E\u03A3B".toLowerCase() == "a\u180E\u03C3b");
assert("A\u03A3\u180E".toLowerCase() == "a\u03C2\u180E");
assert("A\u03A3\u180EB".toLowerCase() == "a\u03C3\u180Eb");
assert("A\u180E\u03A3\u180E".toLowerCase() == "a\u180E\u03C2\u180E");
assert("A\u180E\u03A3\u180EB".toLowerCase() == "a\u180E\u03C3\u180Eb");

// Tests some special casing for upper case mapping
assert("\uFB00".toUpperCase() == "FF");
assert("\uFB01".toUpperCase() == "FI");
assert("\uFB02".toUpperCase() == "FL");
assert("\uFB03".toUpperCase() == "FFI");
assert("\uFB04".toUpperCase() == "FFL");
assert("\uFB05".toUpperCase() == "ST");
assert("\uFB06".toUpperCase() == "ST");
assert("\u01F0".toUpperCase() == "J\u030C");
assert("\u1E96".toUpperCase() == "H\u0331");
assert("\u1E97".toUpperCase() == "T\u0308");
assert("\u1E98".toUpperCase() == "W\u030A");
assert("\u1E99".toUpperCase() == "Y\u030A");
assert("\u1E9A".toUpperCase() == "A\u02BE");

// Test full unicode range `0x0 - 0x10FFFF` and asserting with v8 engine.
for (let i = 0; i <= 0x10FFFF; i++) {
  let source = String.fromCodePoint(i);
  let origLower = source.toLowerCase();
  let origUpper = source.toUpperCase();
  let code1: i64, code2: i64;

  // collect all code points for lower case on AssemblyScript side
  let origLowerCode = <i64>origLower.codePointAt(0);
  if ((code1 = origLower.codePointAt(1)) >= 0) origLowerCode += <i64>code1 << 16;
  if ((code2 = origLower.codePointAt(2)) >= 0) origLowerCode += <i64>code2 << 32;

  // collect all code points for upper case on AssemblyScript side
  let origUpperCode = <i64>origUpper.codePointAt(0);
  if ((code1 = origUpper.codePointAt(1)) >= 0) origUpperCode += <i64>code1 << 16;
  if ((code2 = origUpper.codePointAt(2)) >= 0) origUpperCode += <i64>code2 << 32;

  // collect all code points for lower case on JavaScript side
  let expectLowerCode = <i64>toLowerCaseFromIndex(i, 0);
  if ((code1 = <i64>toLowerCaseFromIndex(i, 1)) >= 0) expectLowerCode += <i64>code1 << 16;
  if ((code2 = <i64>toLowerCaseFromIndex(i, 2)) >= 0) expectLowerCode += <i64>code2 << 32;

  // collect all code points for upper case on JavaScript side
  let expectUpperCode = <i64>toUpperCaseFromIndex(i, 0);
  if ((code1 = <i64>toUpperCaseFromIndex(i, 1)) >= 0) expectUpperCode += <i64>code1 << 16;
  if ((code2 = <i64>toUpperCaseFromIndex(i, 2)) >= 0) expectUpperCode += <i64>code2 << 32;

  if (origLowerCode != expectLowerCode) {
    trace("origLowerCode != expectLowerCode", 1, i);
    trace(" origLowerCode = " + origLowerCode.toString());
    trace(" expectLowerCode = " + expectLowerCode.toString());
  }

  if (origUpperCode != expectUpperCode) {
    trace("origUpperCode != expectUpperCode", 1, i);
    trace(" origUpperCode = " + origUpperCode.toString());
    trace(" expectUpperCode = " + expectUpperCode.toString());
  }

  // FIXME: enable these again once issue #1195 has been solved
  // assert(origLowerCode == expectLowerCode);
  // assert(origUpperCode == expectUpperCode);
}

'''
'''--- tests/compiler/std/string-encoding.json ---
{
  "asc_flags": [
  ],
  "asc_rtrace": true
}

'''
'''--- tests/compiler/std/string-encoding.ts ---
var str = "ð·hið¤­¢";
// utf8  : f0 90 90 b7 68 69 f0 a4 ad a2 [00]
// utf16 : d801_dc37 0068 0069 d852_df62

// UTF-16

function testUTF16Length(): void {
  assert(String.UTF16.byteLength(str) == 12);
}
testUTF16Length();

function testUTF16Encode(): void {
  var buf = String.UTF16.encode(str);
  var ptr = changetype<usize>(buf);
  assert(buf.byteLength == 12);
  assert(load<u8>(ptr, 0) == 0x01);
  assert(load<u8>(ptr, 1) == 0xD8);
  assert(load<u8>(ptr, 2) == 0x37);
  assert(load<u8>(ptr, 3) == 0xDC);
  assert(load<u8>(ptr, 4) == 0x68);
  assert(load<u8>(ptr, 5) == 0x00);
  assert(load<u8>(ptr, 6) == 0x69);
  assert(load<u8>(ptr, 7) == 0x00);
  assert(load<u8>(ptr, 8) == 0x52);
  assert(load<u8>(ptr, 9) == 0xD8);
  assert(load<u8>(ptr, 10) == 0x62);
  assert(load<u8>(ptr, 11) == 0xDF);
}
testUTF16Encode();

function testUTF16Decode(): void {
  var buf = String.UTF16.encode(str);
  assert(String.UTF16.decode(buf) == str);
}
testUTF16Decode();

function testUTF16DecodeUnsafe(): void {
  var buf = String.UTF16.encode(str);
  var len = String.UTF16.byteLength(str);
  var ptr = changetype<usize>(buf);

  assert(String.UTF16.decodeUnsafe(ptr, 0) == "");
  assert(String.UTF16.decodeUnsafe(ptr, len) == str);
  assert(String.UTF16.decodeUnsafe(ptr, 4) == "ð·");
  assert(String.UTF16.decodeUnsafe(ptr + 4, 2) == "h");
  assert(String.UTF16.decodeUnsafe(ptr + 4, 4) == "hi");
  assert(String.UTF16.decodeUnsafe(ptr + 8, 4) == "ð¤­¢");
  assert(String.UTF16.decodeUnsafe(ptr + 12, 0) == "");
}
testUTF16DecodeUnsafe();

// UTF-8

function testUTF8Length(): void {
  assert(String.UTF8.byteLength(str) == 10);
  assert(String.UTF8.byteLength(str, true) == 11);
}
testUTF8Length();

function testUTF8Encode(): void {
  var buf = String.UTF8.encode(str);
  var ptr = changetype<usize>(buf);
  assert(buf.byteLength == 10);
  assert(load<u8>(ptr, 0) == 0xF0);
  assert(load<u8>(ptr, 1) == 0x90);
  assert(load<u8>(ptr, 2) == 0x90);
  assert(load<u8>(ptr, 3) == 0xB7);
  assert(load<u8>(ptr, 4) == 0x68);
  assert(load<u8>(ptr, 5) == 0x69);
  assert(load<u8>(ptr, 6) == 0xF0);
  assert(load<u8>(ptr, 7) == 0xA4);
  assert(load<u8>(ptr, 8) == 0xAD);
  assert(load<u8>(ptr, 9) == 0xA2);
}
testUTF8Encode();

function testUTF8EncodeNullTerminated(): void {
  var buf = String.UTF8.encode(str, true);
  var ptr = changetype<usize>(buf);
  assert(buf.byteLength == 11);
  assert(load<u8>(ptr, 0) == 0xF0);
  assert(load<u8>(ptr, 1) == 0x90);
  assert(load<u8>(ptr, 2) == 0x90);
  assert(load<u8>(ptr, 3) == 0xB7);
  assert(load<u8>(ptr, 4) == 0x68);
  assert(load<u8>(ptr, 5) == 0x69);
  assert(load<u8>(ptr, 6) == 0xF0);
  assert(load<u8>(ptr, 7) == 0xA4);
  assert(load<u8>(ptr, 8) == 0xAD);
  assert(load<u8>(ptr, 9) == 0xA2);
  assert(load<u8>(ptr, 10) == 0x00);
}
testUTF8EncodeNullTerminated();

function testUTF8ErrorMode(): void {
  // Unpaired lead surrogate
  var str = String.UTF8.decode(String.UTF8.encode("\uD834", false, String.UTF8.ErrorMode.WTF8));
  assert(str == "\uD834");
  str = String.UTF8.decode(String.UTF8.encode("\uD834", false, String.UTF8.ErrorMode.REPLACE));
  assert(str == "\uFFFD");
  // Unpaired trail surrogate
  str = String.UTF8.decode(String.UTF8.encode("\uDD1E", false, String.UTF8.ErrorMode.WTF8));
  assert(str == "\uDD1E");
  str = String.UTF8.decode(String.UTF8.encode("\uDD1E", false, String.UTF8.ErrorMode.REPLACE));
  assert(str == "\uFFFD");
}
testUTF8ErrorMode();

function testUTF8Decode(): void {
  var buf = String.UTF8.encode(str);
  assert(String.UTF8.decode(buf) == str);
}
testUTF8Decode();

function testUTF8DecodeNullTerminated(): void {
  var buf = String.UTF8.encode(str, true);
  assert(String.UTF8.decode(buf, true) == str);
  var str2 = "123\0456";
  assert(String.UTF8.byteLength(str2, true) == 4);
  var buf2 = String.UTF8.encode(str2, true);
  assert(buf2.byteLength == 4);
  var str3 = "123";
  assert(String.UTF8.byteLength(str3, true) == 4);
  assert(String.UTF8.decode(buf2, true) == str3);
  var buf3 = String.UTF8.encode(str2, false);
  assert(String.UTF8.decode(buf3, true) == str3);
}
testUTF8DecodeNullTerminated();

function testUTF8DecodeUnsafe(): void {
  var buf = String.UTF8.encode(str, true);
  var len = String.UTF8.byteLength(str, false); // !
  var ptr = changetype<usize>(buf);

  assert(String.UTF8.decodeUnsafe(ptr, 0) == "");
  assert(String.UTF8.decodeUnsafe(ptr, len) == str);
  assert(String.UTF8.decodeUnsafe(ptr, 4) == "ð·");
  assert(String.UTF8.decodeUnsafe(ptr + 4, 2) == "hi");
  assert(String.UTF8.decodeUnsafe(ptr + 6, 4) == "ð¤­¢");
  assert(String.UTF8.decodeUnsafe(ptr + 10, 0) == "");

  assert(String.UTF8.decodeUnsafe(ptr + 4, 100, true) == "hið¤­¢");
  assert(String.UTF8.decodeUnsafe(ptr + 6, 100, true) == "ð¤­¢");
  assert(String.UTF8.decodeUnsafe(ptr + 10, 100, true) == "");
}
testUTF8DecodeUnsafe();

function testLarge(str: string): void {
  var buf8 = String.UTF8.encode(str);
  assert(String.UTF8.decode(buf8) == str);
  var buf16 = String.UTF16.encode(str);
  assert(String.UTF16.decode(buf16) == str);
}

// https://www.w3.org/2001/06/utf-8-test/UTF-8-demo.html
testLarge(`Mathematics and Sciences:

âˆ® Eâ‹…da = Q,  n â†’ âˆž, âˆ‘ f(i) = âˆ g(i), âˆ€xâˆˆâ„: âŒˆxâŒ‰ = âˆ’âŒŠâˆ’xâŒ‹, Î± âˆ§ Â¬Î² = Â¬(Â¬Î± âˆ¨ Î²),

â„• âŠ† â„•â‚€ âŠ‚ â„¤ âŠ‚ â„š âŠ‚ â„ âŠ‚ â„‚, âŠ¥ < a â‰  b â‰¡ c â‰¤ d â‰ª âŠ¤ â‡’ (A â‡” B),

2Hâ‚‚ + Oâ‚‚ â‡Œ 2Hâ‚‚O, R = 4.7 kÎ©, âŒ€ 200 mm

Linguistics and dictionaries:

Ã°i Ä±ntÉ™ËˆnÃ¦ÊƒÉ™nÉ™l fÉ™ËˆnÉ›tÄ±k É™soÊŠsiËˆeÄ±Êƒn
Y [ËˆÊpsilÉ”n], Yen [jÉ›n], Yoga [ËˆjoËgÉ‘]

APL:

((Vâ³V)=â³â´V)/Vâ†,V    âŒ·â†â³â†’â´âˆ†âˆ‡âŠƒâ€¾âŽâ•âŒˆ

Nicer typography in plain text files:

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                          â•‘
â•‘   â€¢ â€˜singleâ€™ and â€œdoubleâ€ quotes         â•‘
â•‘                                          â•‘
â•‘   â€¢ Curly apostrophes: â€œWeâ€™ve been hereâ€ â•‘
â•‘                                          â•‘
â•‘   â€¢ Latin-1 apostrophe and accents: 'Â´\`  â•‘
â•‘                                          â•‘
â•‘   â€¢ â€šdeutscheâ€˜ â€žAnfÃ¼hrungszeichenâ€œ       â•‘
â•‘                                          â•‘
â•‘   â€¢ â€ , â€¡, â€°, â€¢, 3â€“4, â€”, âˆ’5/+5, â„¢, â€¦      â•‘
â•‘                                          â•‘
â•‘   â€¢ ASCII safety test: 1lI|, 0OD, 8B     â•‘
â•‘                      â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®         â•‘
â•‘   â€¢ the euro symbol: â”‚ 14.95 â‚¬ â”‚         â•‘
â•‘                      â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Greek (in Polytonic):

The Greek anthem:

Î£á½² Î³Î½Ï‰Ïá½·Î¶Ï‰ á¼€Ï€á½¸ Ï„á½´Î½ Îºá½¹ÏˆÎ·
Ï„Î¿á¿¦ ÏƒÏ€Î±Î¸Î¹Î¿á¿¦ Ï„á½´Î½ Ï„ÏÎ¿Î¼ÎµÏá½µ,
Ïƒá½² Î³Î½Ï‰Ïá½·Î¶Ï‰ á¼€Ï€á½¸ Ï„á½´Î½ á½„ÏˆÎ·
Ï€Î¿á½º Î¼á½² Î²á½·Î± Î¼ÎµÏ„Ïá½±ÎµÎ¹ Ï„á½´ Î³á¿†.

á¾¿Î‘Ï€á¾¿ Ï„á½° Îºá½¹ÎºÎºÎ±Î»Î± Î²Î³Î±Î»Î¼á½³Î½Î·
Ï„á¿¶Î½ á¿¾Î•Î»Î»á½µÎ½Ï‰Î½ Ï„á½° á¼±ÎµÏá½±
ÎºÎ±á½¶ Ïƒá½°Î½ Ï€Ïá¿¶Ï„Î± á¼€Î½Î´ÏÎµÎ¹Ï‰Î¼á½³Î½Î·
Ï‡Î±á¿–ÏÎµ, á½¦ Ï‡Î±á¿–ÏÎµ, á¾¿Î•Î»ÎµÏ…Î¸ÎµÏÎ¹á½±!

From a speech of Demosthenes in the 4th century BC:

ÎŸá½Ï‡á½¶ Ï„Î±á½Ï„á½° Ï€Î±Ïá½·ÏƒÏ„Î±Ï„Î±á½· Î¼Î¿Î¹ Î³Î¹Î³Î½á½½ÏƒÎºÎµÎ¹Î½, á½¦ á¼„Î½Î´ÏÎµÏ‚ á¾¿Î‘Î¸Î·Î½Î±á¿–Î¿Î¹,
á½…Ï„Î±Î½ Ï„á¾¿ Îµá¼°Ï‚ Ï„á½° Ï€Ïá½±Î³Î¼Î±Ï„Î± á¼€Ï€Î¿Î²Î»á½³ÏˆÏ‰ ÎºÎ±á½¶ á½…Ï„Î±Î½ Ï€Ïá½¸Ï‚ Ï„Î¿á½ºÏ‚
Î»á½¹Î³Î¿Ï…Ï‚ Î¿á½“Ï‚ á¼€ÎºÎ¿á½»Ï‰Î‡ Ï„Î¿á½ºÏ‚ Î¼á½²Î½ Î³á½°Ï Î»á½¹Î³Î¿Ï…Ï‚ Ï€ÎµÏá½¶ Ï„Î¿á¿¦
Ï„Î¹Î¼Ï‰Ïá½µÏƒÎ±ÏƒÎ¸Î±Î¹ Î¦á½·Î»Î¹Ï€Ï€Î¿Î½ á½Ïá¿¶ Î³Î¹Î³Î½Î¿Î¼á½³Î½Î¿Ï…Ï‚, Ï„á½° Î´á½² Ï€Ïá½±Î³Î¼Î±Ï„á¾¿
Îµá¼°Ï‚ Ï„Î¿á¿¦Ï„Î¿ Ï€ÏÎ¿á½µÎºÎ¿Î½Ï„Î±,  á½¥ÏƒÎ¸á¾¿ á½…Ï€Ï‰Ï‚ Î¼á½´ Ï€ÎµÎ¹Ïƒá½¹Î¼ÎµÎ¸á¾¿ Î±á½Ï„Î¿á½¶
Ï€Ïá½¹Ï„ÎµÏÎ¿Î½ ÎºÎ±Îºá¿¶Ï‚ ÏƒÎºá½³ÏˆÎ±ÏƒÎ¸Î±Î¹ Î´á½³Î¿Î½. Î¿á½Î´á½³Î½ Î¿á½–Î½ á¼„Î»Î»Î¿ Î¼Î¿Î¹ Î´Î¿ÎºÎ¿á¿¦ÏƒÎ¹Î½
Î¿á¼± Ï„á½° Ï„Î¿Î¹Î±á¿¦Ï„Î± Î»á½³Î³Î¿Î½Ï„ÎµÏ‚ á¼¢ Ï„á½´Î½ á½‘Ï€á½¹Î¸ÎµÏƒÎ¹Î½, Ï€ÎµÏá½¶ á¼§Ï‚ Î²Î¿Ï…Î»Îµá½»ÎµÏƒÎ¸Î±Î¹,
Î¿á½Ï‡á½¶ Ï„á½´Î½ Î¿á½–ÏƒÎ±Î½ Ï€Î±ÏÎ¹ÏƒÏ„á½±Î½Ï„ÎµÏ‚ á½‘Î¼á¿–Î½ á¼Î¼Î±ÏÏ„á½±Î½ÎµÎ¹Î½. á¼Î³á½¼ Î´á½³, á½…Ï„Î¹ Î¼á½³Î½
Ï€Î¿Ï„á¾¿ á¼Î¾á¿†Î½ Ï„á¿‡ Ï€á½¹Î»ÎµÎ¹ ÎºÎ±á½¶ Ï„á½° Î±á½‘Ï„á¿†Ï‚ á¼”Ï‡ÎµÎ¹Î½ á¼€ÏƒÏ†Î±Î»á¿¶Ï‚ ÎºÎ±á½¶ Î¦á½·Î»Î¹Ï€Ï€Î¿Î½
Ï„Î¹Î¼Ï‰Ïá½µÏƒÎ±ÏƒÎ¸Î±Î¹, ÎºÎ±á½¶ Î¼á½±Î»á¾¿ á¼€ÎºÏÎ¹Î²á¿¶Ï‚ Î¿á¼¶Î´Î±Î‡ á¼Ï€á¾¿ á¼Î¼Î¿á¿¦ Î³á½±Ï, Î¿á½ Ï€á½±Î»Î±Î¹
Î³á½³Î³Î¿Î½ÎµÎ½ Ï„Î±á¿¦Ï„á¾¿ á¼€Î¼Ï†á½¹Ï„ÎµÏÎ±Î‡ Î½á¿¦Î½ Î¼á½³Î½Ï„Î¿Î¹ Ï€á½³Ï€ÎµÎ¹ÏƒÎ¼Î±Î¹ Ï„Î¿á¿¦Î¸á¾¿ á¼±ÎºÎ±Î½á½¸Î½
Ï€ÏÎ¿Î»Î±Î²Îµá¿–Î½ á¼¡Î¼á¿–Î½ Îµá¼¶Î½Î±Î¹ Ï„á½´Î½ Ï€Ïá½½Ï„Î·Î½, á½…Ï€Ï‰Ï‚ Ï„Î¿á½ºÏ‚ ÏƒÏ…Î¼Î¼á½±Ï‡Î¿Ï…Ï‚
Ïƒá½½ÏƒÎ¿Î¼ÎµÎ½. á¼á½°Î½ Î³á½°Ï Ï„Î¿á¿¦Ï„Î¿ Î²ÎµÎ²Î±á½·Ï‰Ï‚ á½‘Ï€á½±ÏÎ¾á¿ƒ, Ï„á½¹Ï„Îµ ÎºÎ±á½¶ Ï€ÎµÏá½¶ Ï„Î¿á¿¦
Ï„á½·Î½Î± Ï„Î¹Î¼Ï‰Ïá½µÏƒÎµÏ„Î±á½· Ï„Î¹Ï‚ ÎºÎ±á½¶ á½ƒÎ½ Ï„Ïá½¹Ï€Î¿Î½ á¼Î¾á½³ÏƒÏ„Î±Î¹ ÏƒÎºÎ¿Ï€Îµá¿–Î½Î‡ Ï€Ïá½¶Î½ Î´á½²
Ï„á½´Î½ á¼€ÏÏ‡á½´Î½ á½€ÏÎ¸á¿¶Ï‚ á½‘Ï€Î¿Î¸á½³ÏƒÎ¸Î±Î¹, Î¼á½±Ï„Î±Î¹Î¿Î½ á¼¡Î³Î¿á¿¦Î¼Î±Î¹ Ï€ÎµÏá½¶ Ï„á¿†Ï‚
Ï„ÎµÎ»ÎµÏ…Ï„á¿†Ï‚ á½Î½Ï„Î¹Î½Î¿á¿¦Î½ Ï€Î¿Î¹Îµá¿–ÏƒÎ¸Î±Î¹ Î»á½¹Î³Î¿Î½.

Î”Î·Î¼Î¿ÏƒÎ¸á½³Î½Î¿Ï…Ï‚, Î“á¿½ á¾¿ÎŸÎ»Ï…Î½Î¸Î¹Î±Îºá½¸Ï‚

Georgian:

From a Unicode conference invitation:

áƒ’áƒ—áƒ®áƒáƒ•áƒ— áƒáƒ®áƒšáƒáƒ•áƒ” áƒ’áƒáƒ˜áƒáƒ áƒáƒ— áƒ áƒ”áƒ’áƒ˜áƒ¡áƒ¢áƒ áƒáƒªáƒ˜áƒ Unicode-áƒ˜áƒ¡ áƒ›áƒ”áƒáƒ—áƒ” áƒ¡áƒáƒ”áƒ áƒ—áƒáƒ¨áƒáƒ áƒ˜áƒ¡áƒ
áƒ™áƒáƒœáƒ¤áƒ”áƒ áƒ”áƒœáƒªáƒ˜áƒáƒ–áƒ” áƒ“áƒáƒ¡áƒáƒ¡áƒ¬áƒ áƒ”áƒ‘áƒáƒ“, áƒ áƒáƒ›áƒ”áƒšáƒ˜áƒª áƒ’áƒáƒ˜áƒ›áƒáƒ áƒ—áƒ”áƒ‘áƒ 10-12 áƒ›áƒáƒ áƒ¢áƒ¡,
áƒ¥. áƒ›áƒáƒ˜áƒœáƒªáƒ¨áƒ˜, áƒ’áƒ”áƒ áƒ›áƒáƒœáƒ˜áƒáƒ¨áƒ˜. áƒ™áƒáƒœáƒ¤áƒ”áƒ áƒ”áƒœáƒªáƒ˜áƒ áƒ¨áƒ”áƒ°áƒ™áƒ áƒ”áƒ‘áƒ¡ áƒ”áƒ áƒ—áƒáƒ“ áƒ›áƒ¡áƒáƒ¤áƒšáƒ˜áƒáƒ¡
áƒ”áƒ¥áƒ¡áƒžáƒ”áƒ áƒ¢áƒ”áƒ‘áƒ¡ áƒ˜áƒ¡áƒ”áƒ— áƒ“áƒáƒ áƒ’áƒ”áƒ‘áƒ¨áƒ˜ áƒ áƒáƒ’áƒáƒ áƒ˜áƒªáƒáƒ áƒ˜áƒœáƒ¢áƒ”áƒ áƒœáƒ”áƒ¢áƒ˜ áƒ“áƒ Unicode-áƒ˜,
áƒ˜áƒœáƒ¢áƒ”áƒ áƒœáƒáƒªáƒ˜áƒáƒœáƒáƒšáƒ˜áƒ–áƒáƒªáƒ˜áƒ áƒ“áƒ áƒšáƒáƒ™áƒáƒšáƒ˜áƒ–áƒáƒªáƒ˜áƒ, Unicode-áƒ˜áƒ¡ áƒ’áƒáƒ›áƒáƒ§áƒ”áƒœáƒ”áƒ‘áƒ
áƒáƒžáƒ”áƒ áƒáƒªáƒ˜áƒ£áƒš áƒ¡áƒ˜áƒ¡áƒ¢áƒ”áƒ›áƒ”áƒ‘áƒ¡áƒ, áƒ“áƒ áƒ’áƒáƒ›áƒáƒ§áƒ”áƒœáƒ”áƒ‘áƒ˜áƒ— áƒžáƒ áƒáƒ’áƒ áƒáƒ›áƒ”áƒ‘áƒ¨áƒ˜, áƒ¨áƒ áƒ˜áƒ¤áƒ¢áƒ”áƒ‘áƒ¨áƒ˜,
áƒ¢áƒ”áƒ¥áƒ¡áƒ¢áƒ”áƒ‘áƒ˜áƒ¡ áƒ“áƒáƒ›áƒ£áƒ¨áƒáƒ•áƒ”áƒ‘áƒáƒ¡áƒ áƒ“áƒ áƒ›áƒ áƒáƒ•áƒáƒšáƒ”áƒœáƒáƒ•áƒáƒœ áƒ™áƒáƒ›áƒžáƒ˜áƒ£áƒ¢áƒ”áƒ áƒ£áƒš áƒ¡áƒ˜áƒ¡áƒ¢áƒ”áƒ›áƒ”áƒ‘áƒ¨áƒ˜.

Russian:

From a Unicode conference invitation:

Ð—Ð°Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð¸Ñ€ÑƒÐ¹Ñ‚ÐµÑÑŒ ÑÐµÐ¹Ñ‡Ð°Ñ Ð½Ð° Ð”ÐµÑÑÑ‚ÑƒÑŽ ÐœÐµÐ¶Ð´ÑƒÐ½Ð°Ñ€Ð¾Ð´Ð½ÑƒÑŽ ÐšÐ¾Ð½Ñ„ÐµÑ€ÐµÐ½Ñ†Ð¸ÑŽ Ð¿Ð¾
Unicode, ÐºÐ¾Ñ‚Ð¾Ñ€Ð°Ñ ÑÐ¾ÑÑ‚Ð¾Ð¸Ñ‚ÑÑ 10-12 Ð¼Ð°Ñ€Ñ‚Ð° 1997 Ð³Ð¾Ð´Ð° Ð² ÐœÐ°Ð¹Ð½Ñ†Ðµ Ð² Ð“ÐµÑ€Ð¼Ð°Ð½Ð¸Ð¸.
ÐšÐ¾Ð½Ñ„ÐµÑ€ÐµÐ½Ñ†Ð¸Ñ ÑÐ¾Ð±ÐµÑ€ÐµÑ‚ ÑˆÐ¸Ñ€Ð¾ÐºÐ¸Ð¹ ÐºÑ€ÑƒÐ³ ÑÐºÑÐ¿ÐµÑ€Ñ‚Ð¾Ð² Ð¿Ð¾  Ð²Ð¾Ð¿Ñ€Ð¾ÑÐ°Ð¼ Ð³Ð»Ð¾Ð±Ð°Ð»ÑŒÐ½Ð¾Ð³Ð¾
Ð˜Ð½Ñ‚ÐµÑ€Ð½ÐµÑ‚Ð° Ð¸ Unicode, Ð»Ð¾ÐºÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸ Ð¸ Ð¸Ð½Ñ‚ÐµÑ€Ð½Ð°Ñ†Ð¸Ð¾Ð½Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸, Ð²Ð¾Ð¿Ð»Ð¾Ñ‰ÐµÐ½Ð¸ÑŽ Ð¸
Ð¿Ñ€Ð¸Ð¼ÐµÐ½ÐµÐ½Ð¸ÑŽ Unicode Ð² Ñ€Ð°Ð·Ð»Ð¸Ñ‡Ð½Ñ‹Ñ… Ð¾Ð¿ÐµÑ€Ð°Ñ†Ð¸Ð¾Ð½Ð½Ñ‹Ñ… ÑÐ¸ÑÑ‚ÐµÐ¼Ð°Ñ… Ð¸ Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð½Ñ‹Ñ…
Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸ÑÑ…, ÑˆÑ€Ð¸Ñ„Ñ‚Ð°Ñ…, Ð²ÐµÑ€ÑÑ‚ÐºÐµ Ð¸ Ð¼Ð½Ð¾Ð³Ð¾ÑÐ·Ñ‹Ñ‡Ð½Ñ‹Ñ… ÐºÐ¾Ð¼Ð¿ÑŒÑŽÑ‚ÐµÑ€Ð½Ñ‹Ñ… ÑÐ¸ÑÑ‚ÐµÐ¼Ð°Ñ….

Thai (UCS Level 2):

Excerpt from a poetry on The Romance of The Three Kingdoms (a Chinese
classic 'San Gua'):

[----------------------------|------------------------]
  à¹ à¹à¸œà¹ˆà¸™à¸”à¸´à¸™à¸®à¸±à¹ˆà¸™à¹€à¸ªà¸·à¹ˆà¸­à¸¡à¹‚à¸—à¸£à¸¡à¹à¸ªà¸™à¸ªà¸±à¸‡à¹€à¸§à¸Š  à¸žà¸£à¸°à¸›à¸à¹€à¸à¸¨à¸à¸­à¸‡à¸šà¸¹à¹Šà¸à¸¹à¹‰à¸‚à¸¶à¹‰à¸™à¹ƒà¸«à¸¡à¹ˆ
à¸ªà¸´à¸šà¸ªà¸­à¸‡à¸à¸©à¸±à¸•à¸£à¸´à¸¢à¹Œà¸à¹ˆà¸­à¸™à¸«à¸™à¹‰à¸²à¹à¸¥à¸–à¸±à¸”à¹„à¸›       à¸ªà¸­à¸‡à¸­à¸‡à¸„à¹Œà¹„à¸‹à¸£à¹‰à¹‚à¸‡à¹ˆà¹€à¸‚à¸¥à¸²à¹€à¸šà¸²à¸›à¸±à¸à¸à¸²
  à¸—à¸£à¸‡à¸™à¸±à¸šà¸–à¸·à¸­à¸‚à¸±à¸™à¸—à¸µà¹€à¸›à¹‡à¸™à¸—à¸µà¹ˆà¸žà¸¶à¹ˆà¸‡           à¸šà¹‰à¸²à¸™à¹€à¸¡à¸·à¸­à¸‡à¸ˆà¸¶à¸‡à¸§à¸´à¸›à¸£à¸´à¸•à¹€à¸›à¹‡à¸™à¸™à¸±à¸à¸«à¸™à¸²
à¹‚à¸®à¸ˆà¸´à¹‹à¸™à¹€à¸£à¸µà¸¢à¸à¸—à¸±à¸žà¸—à¸±à¹ˆà¸§à¸«à¸±à¸§à¹€à¸¡à¸·à¸­à¸‡à¸¡à¸²         à¸«à¸¡à¸²à¸¢à¸ˆà¸°à¸†à¹ˆà¸²à¸¡à¸”à¸Šà¸±à¹ˆà¸§à¸•à¸±à¸§à¸ªà¸³à¸„à¸±à¸
  à¹€à¸«à¸¡à¸·à¸­à¸™à¸‚à¸±à¸šà¹„à¸ªà¹„à¸¥à¹ˆà¹€à¸ªà¸·à¸­à¸ˆà¸²à¸à¹€à¸„à¸«à¸²      à¸£à¸±à¸šà¸«à¸¡à¸²à¸›à¹ˆà¸²à¹€à¸‚à¹‰à¸²à¸¡à¸²à¹€à¸¥à¸¢à¸­à¸²à¸ªà¸±à¸
à¸à¹ˆà¸²à¸¢à¸­à¹‰à¸­à¸‡à¸­à¸¸à¹‰à¸™à¸¢à¸¸à¹à¸¢à¸à¹ƒà¸«à¹‰à¹à¸•à¸à¸à¸±à¸™          à¹ƒà¸Šà¹‰à¸ªà¸²à¸§à¸™à¸±à¹‰à¸™à¹€à¸›à¹‡à¸™à¸Šà¸™à¸§à¸™à¸Šà¸·à¹ˆà¸™à¸Šà¸§à¸™à¹ƒà¸ˆ
  à¸žà¸¥à¸±à¸™à¸¥à¸´à¸‰à¸¸à¸¢à¸à¸¸à¸¢à¸à¸µà¸à¸¥à¸±à¸šà¸à¹ˆà¸­à¹€à¸«à¸•à¸¸          à¸Šà¹ˆà¸²à¸‡à¸­à¸²à¹€à¸žà¸¨à¸ˆà¸£à¸´à¸‡à¸«à¸™à¸²à¸Ÿà¹‰à¸²à¸£à¹‰à¸­à¸‡à¹„à¸«à¹‰
à¸•à¹‰à¸­à¸‡à¸£à¸šà¸£à¸²à¸†à¹ˆà¸²à¸Ÿà¸±à¸™à¸ˆà¸™à¸šà¸£à¸£à¸¥à¸±à¸¢           à¸¤à¹…à¸«à¸²à¹ƒà¸„à¸£à¸„à¹‰à¸³à¸Šà¸¹à¸à¸¹à¹‰à¸šà¸£à¸£à¸¥à¸±à¸‡à¸à¹Œ à¸¯

(The above is a two-column text. If combining characters are handled
correctly, the lines of the second column should be aligned with the
| character above.)

Ethiopian:

Proverbs in the Amharic language:

áˆ°áˆ›á‹­ áŠ á‹­á‰³áˆ¨áˆµ áŠ•áŒ‰áˆ¥ áŠ á‹­áŠ¨áˆ°áˆµá¢
á‰¥áˆ‹ áŠ«áˆˆáŠ áŠ¥áŠ•á‹°áŠ á‰£á‰´ á‰ á‰†áˆ˜áŒ áŠá¢
áŒŒáŒ¥ á‹«áˆˆá‰¤á‰± á‰áˆáŒ¥áŠ“ áŠá‹á¢
á‹°áˆ€ á‰ áˆ•áˆáˆ™ á‰…á‰¤ á‰£á‹­áŒ áŒ£ áŠ•áŒ£á‰µ á‰ áŒˆá‹°áˆˆá‹á¢
á‹¨áŠ á á‹ˆáˆˆáˆá‰³ á‰ á‰…á‰¤ áŠ á‹­á‰³áˆ½áˆá¢
áŠ á‹­áŒ¥ á‰ á‰ áˆ‹ á‹³á‹‹ á‰°áˆ˜á‰³á¢
áˆ²á‰°áˆ¨áŒ‰áˆ™ á‹­á‹°áˆ¨áŒáˆ™á¢
á‰€áˆµ á‰ á‰€áˆµá¥ á‹•áŠ•á‰áˆ‹áˆ á‰ áŠ¥áŒáˆ© á‹­áˆ„á‹³áˆá¢
á‹µáˆ­ á‰¢á‹«á‰¥áˆ­ áŠ áŠ•á‰ áˆ³ á‹«áˆµáˆ­á¢
áˆ°á‹ áŠ¥áŠ•á‹°á‰¤á‰± áŠ¥áŠ•áŒ… áŠ¥áŠ•á‹° áŒ‰áˆ¨á‰¤á‰± áŠ á‹­á‰°á‹³á‹°áˆ­áˆá¢
áŠ¥áŒá‹œáˆ­ á‹¨áŠ¨áˆá‰°á‹áŠ• áŒ‰áˆ®áˆ® áˆ³á‹­á‹˜áŒ‹á‹ áŠ á‹­á‹µáˆ­áˆá¢
á‹¨áŒŽáˆ¨á‰¤á‰µ áˆŒá‰£á¥ á‰¢á‹«á‹©á‰µ á‹­áˆµá‰… á‰£á‹«á‹©á‰µ á‹«áŒ áˆá‰…á¢
áˆ¥áˆ« áŠ¨áˆ˜áá‰³á‰µ áˆáŒ„áŠ• áˆ‹á‹á‰³á‰µá¢
á‹“á‰£á‹­ áˆ›á‹°áˆªá‹« á‹¨áˆˆá‹á¥ áŒáŠ•á‹µ á‹­á‹ž á‹­á‹žáˆ«áˆá¢
á‹¨áŠ¥áˆµáˆ‹áˆ áŠ áŒˆáˆ© áˆ˜áŠ« á‹¨áŠ áˆžáˆ« áŠ áŒˆáˆ© á‹‹áˆ­áŠ«á¢
á‰°áŠ•áŒ‹áˆŽ á‰¢á‰°á‰ á‰°áˆ˜áˆáˆ¶ á‰£á‰á¢
á‹ˆá‹³áŒ…áˆ… áˆ›áˆ­ á‰¢áˆ†áŠ• áŒ¨áˆ­áˆµáˆ… áŠ á‰µáˆ‹áˆ°á‹á¢
áŠ¥áŒáˆ­áˆ…áŠ• á‰ ááˆ«áˆ½áˆ… áˆáŠ­ á‹˜áˆ­áŒ‹á¢

Runes:

áš»á›– áš³áš¹áš«áš¦ áš¦áš«á› áš»á›– á›’áš¢á›žá›– áš©áš¾ áš¦áš«á›— á›šášªáš¾á›žá›– áš¾áš©áš±áš¦áš¹á›–ášªáš±á›žáš¢á›— áš¹á›áš¦ áš¦ášª áš¹á›–á›¥áš«

(Old English, which transcribed into Latin reads 'He cwaeth that he
bude thaem lande northweardum with tha Westsae.' and means 'He said
that he lived in the northern land near the Western Sea.')

Braille:

â¡Œâ â §â ‘ â ¼â â ’  â¡â œâ ‡â ‘â ¹â °â Ž â¡£â •â Œ

â¡â œâ ‡â ‘â ¹ â ºâ â Ž â ™â ‘â â ™â ’ â žâ • â ƒâ ‘â ›â ” â ºâ Šâ ¹â ² â¡¹â »â ‘ â Šâ Ž â â • â ™â ³â ƒâ ž
â ±â â žâ ‘â §â » â â ƒâ ³â ž â ¹â â žâ ² â¡¹â ‘ â —â ‘â ›â Šâ Œâ » â •â ‹ â ™â Šâ Ž â ƒâ ¥â —â Šâ â ‡ â ºâ â Ž
â Žâ Šâ ›â â « â ƒâ ¹ â ¹â ‘ â Šâ ‡â »â ›â ¹â â â â ‚ â ¹â ‘ â Šâ ‡â »â …â ‚ â ¹â ‘ â ¥â â ™â »â žâ â …â »â ‚
â â â ™ â ¹â ‘ â ¡â Šâ ‘â ‹ â â ³â —â â »â ² â¡Žâ Šâ —â •â •â ›â ‘ â Žâ Šâ ›â â « â Šâ žâ ² â¡â â ™
â¡Žâ Šâ —â •â •â ›â ‘â °â Ž â â â â ‘ â ºâ â Ž â ›â •â •â ™ â ¥â â •â  â °â¡¡â â â ›â ‘â ‚ â ‹â •â — â â â ¹â ¹â ”â › â ™â ‘
â ¡â •â Žâ ‘ â žâ • â â ¥â ž â ™â Šâ Ž â ™â â â ™ â žâ •â ²

â¡•â ‡â ™ â¡â œâ ‡â ‘â ¹ â ºâ â Ž â â Ž â ™â ‘â â ™ â â Ž â  â ™â •â •â —â ¤â â â Šâ ‡â ²

â¡â ”â ™â – â¡Š â ™â •â â °â ž â â ‘â â  â žâ • â Žâ â ¹ â ¹â â ž â¡Š â …â â ªâ ‚ â •â ‹ â â ¹
â ªâ  â …â â ªâ ‡â «â ›â ‘â ‚ â ±â â ž â ¹â »â ‘ â Šâ Ž â â œâ žâ Šâ Šâ ¥â ‡â œâ ‡â ¹ â ™â ‘â â ™ â â ƒâ ³â ž
â  â ™â •â •â —â ¤â â â Šâ ‡â ² â¡Š â â Šâ £â ž â ™â â §â ‘ â ƒâ ‘â ² â ”â Šâ ‡â ”â «â ‚ â â ¹â Žâ ‘â ‡â ‹â ‚ â žâ •
â —â ‘â ›â œâ ™ â  â Šâ •â ‹â ‹â ”â ¤â â â Šâ ‡ â â Ž â ¹â ‘ â ™â ‘â â ™â ‘â Œ â â Šâ ‘â Šâ ‘ â •â ‹ â Šâ —â •â â â •â â ›â »â ¹
â ” â ¹â ‘ â žâ —â â ™â ‘â ² â¡ƒâ ¥â ž â ¹â ‘ â ºâ Šâ Žâ ™â •â  â •â ‹ â ³â — â â â Šâ ‘â Œâ •â —â Ž
â Šâ Ž â ” â ¹â ‘ â Žâ Šâ â Šâ ‡â ‘â † â â â ™ â â ¹ â ¥â â ™â â ‡â ‡â ªâ « â ™â â â ™â Ž
â ©â â ‡â ‡ â â •â ž â ™â Šâ Œâ ¥â —â ƒ â Šâ žâ ‚ â •â — â ¹â ‘ â¡Šâ ³â â žâ —â ¹â °â Ž â ™â •â â ‘ â ‹â •â —â ² â¡¹â ³
â ºâ Šâ ‡â ‡ â ¹â »â ‘â ‹â •â —â ‘ â â »â â Šâ ž â â ‘ â žâ • â —â ‘â â ‘â â žâ ‚ â ‘â â â ™â â žâ Šâ Šâ â ‡â ‡â ¹â ‚ â ¹â â ž
â¡â œâ ‡â ‘â ¹ â ºâ â Ž â â Ž â ™â ‘â â ™ â â Ž â  â ™â •â •â —â ¤â â â Šâ ‡â ²

(The first couple of paragraphs of "A Christmas Carol" by Dickens)

Compact font selection example text:

ABCDEFGHIJKLMNOPQRSTUVWXYZ /0123456789
abcdefghijklmnopqrstuvwxyz Â£Â©ÂµÃ€Ã†Ã–ÃžÃŸÃ©Ã¶Ã¿
â€“â€”â€˜â€œâ€â€žâ€ â€¢â€¦â€°â„¢Å“Å Å¸Å¾â‚¬ Î‘Î’Î“Î”Î©Î±Î²Î³Î´Ï‰ ÐÐ‘Ð’Ð“Ð”Ð°Ð±Ð²Ð³Ð´
âˆ€âˆ‚âˆˆâ„âˆ§âˆªâ‰¡âˆž â†‘â†—â†¨â†»â‡£ â”â”¼â•”â•˜â–‘â–ºâ˜ºâ™€ ï¬ï¿½â‘€â‚‚á¼ á¸‚Ó¥áº„ÉËâŽ×Ô±áƒ

Greetings in various languages:

Hello world, ÎšÎ±Î»Î·Î¼á½³ÏÎ± Îºá½¹ÏƒÎ¼Îµ, ã‚³ãƒ³ãƒ‹ãƒãƒ

Box drawing alignment tests:                                          â–ˆ
                                                                    â–‰
â•”â•â•â•¦â•â•â•—  â”Œâ”€â”€â”¬â”€â”€â”  â•­â”€â”€â”¬â”€â”€â•®  â•­â”€â”€â”¬â”€â”€â•®  â”â”â”â”³â”â”â”“  â”Žâ”’â”â”‘   â•·  â•» â”â”¯â”“ â”Œâ”°â”    â–Š â•±â•²â•±â•²â•³â•³â•³
â•‘â”Œâ”€â•¨â”€â”â•‘  â”‚â•”â•â•§â•â•—â”‚  â”‚â•’â•â•ªâ•â••â”‚  â”‚â•“â”€â•â”€â•–â”‚  â”ƒâ”Œâ”€â•‚â”€â”â”ƒ  â”—â•ƒâ•„â”™  â•¶â”¼â•´â•ºâ•‹â•¸â” â”¼â”¨ â”â•‹â”¥    â–‹ â•²â•±â•²â•±â•³â•³â•³
â•‘â”‚â•² â•±â”‚â•‘  â”‚â•‘   â•‘â”‚  â”‚â”‚ â”‚ â”‚â”‚  â”‚â•‘ â”ƒ â•‘â”‚  â”ƒâ”‚ â•¿ â”‚â”ƒ  â”â•…â•†â”“   â•µ  â•¹ â”—â”·â”› â””â”¸â”˜    â–Œ â•±â•²â•±â•²â•³â•³â•³
â• â•¡ â•³ â•žâ•£  â”œâ•¢   â•Ÿâ”¤  â”œâ”¼â”€â”¼â”€â”¼â”¤  â”œâ•«â”€â•‚â”€â•«â”¤  â”£â”¿â•¾â”¼â•¼â”¿â”«  â”•â”›â”–â”š     â”Œâ”„â”„â” â•Ž â”â”…â”…â”“ â”‹ â– â•²â•±â•²â•±â•³â•³â•³
â•‘â”‚â•± â•²â”‚â•‘  â”‚â•‘   â•‘â”‚  â”‚â”‚ â”‚ â”‚â”‚  â”‚â•‘ â”ƒ â•‘â”‚  â”ƒâ”‚ â•½ â”‚â”ƒ  â–‘â–‘â–’â–’â–“â–“â–ˆâ–ˆ â”Š  â”† â•Ž â•  â”‡ â”‹ â–Ž
â•‘â””â”€â•¥â”€â”˜â•‘  â”‚â•šâ•â•¤â•â•â”‚  â”‚â•˜â•â•ªâ•â•›â”‚  â”‚â•™â”€â•€â”€â•œâ”‚  â”ƒâ””â”€â•‚â”€â”˜â”ƒ  â–‘â–‘â–’â–’â–“â–“â–ˆâ–ˆ â”Š  â”† â•Ž â•  â”‡ â”‹ â–
â•šâ•â•â•©â•â•â•  â””â”€â”€â”´â”€â”€â”˜  â•°â”€â”€â”´â”€â”€â•¯  â•°â”€â”€â”´â”€â”€â•¯  â”—â”â”â”»â”â”â”›           â””â•Œâ•Œâ”˜ â•Ž â”—â•â•â”› â”‹  â–â–‚â–ƒâ–„â–…â–†â–‡â–ˆ
`);

// https://www.cl.cam.ac.uk/~mgk25/ucs/examples/quickbrown.txt
testLarge(`Sentences that contain all letters commonly used in a language
--------------------------------------------------------------

Markus Kuhn <http://www.cl.cam.ac.uk/~mgk25/> -- 2012-04-11

This is an example of a plain-text file encoded in UTF-8.

Danish (da)
---------

  Quizdeltagerne spiste jordbÃ¦r med flÃ¸de, mens cirkusklovnen
  Wolther spillede pÃ¥ xylofon.
  (= Quiz contestants were eating strawbery with cream while Wolther
  the circus clown played on xylophone.)

German (de)
-----------

  Falsches Ãœben von Xylophonmusik quÃ¤lt jeden grÃ¶ÃŸeren Zwerg
  (= Wrongful practicing of xylophone music tortures every larger dwarf)

  ZwÃ¶lf BoxkÃ¤mpfer jagten Eva quer Ã¼ber den Sylter Deich
  (= Twelve boxing fighters hunted Eva across the dike of Sylt)

  HeizÃ¶lrÃ¼ckstoÃŸabdÃ¤mpfung
  (= fuel oil recoil absorber)
  (jqvwxy missing, but all non-ASCII letters in one word)

Greek (el)
----------

  Î“Î±Î¶Î­ÎµÏ‚ ÎºÎ±á½¶ Î¼Ï…ÏÏ„Î¹á½²Ï‚ Î´á½²Î½ Î¸á½° Î²Ïá¿¶ Ï€Î¹á½° ÏƒÏ„á½¸ Ï‡ÏÏ…ÏƒÎ±Ï†á½¶ Î¾Î­Ï†Ï‰Ï„Î¿
  (= No more shall I see acacias or myrtles in the golden clearing)

  ÎžÎµÏƒÎºÎµÏ€Î¬Î¶Ï‰ Ï„á½´Î½ ÏˆÏ…Ï‡Î¿Ï†Î¸ÏŒÏÎ± Î²Î´ÎµÎ»Ï…Î³Î¼Î¯Î±
  (= I uncover the soul-destroying abhorrence)

English (en)
------------

  The quick brown fox jumps over the lazy dog

Spanish (es)
------------

  El pingÃ¼ino Wenceslao hizo kilÃ³metros bajo exhaustiva lluvia y
  frÃ­o, aÃ±oraba a su querido cachorro.
  (Contains every letter and every accent, but not every combination
  of vowel + acute.)

French (fr)
-----------

  Portez ce vieux whisky au juge blond qui fume sur son Ã®le intÃ©rieure, Ã 
  cÃ´tÃ© de l'alcÃ´ve ovoÃ¯de, oÃ¹ les bÃ»ches se consument dans l'Ã¢tre, ce
  qui lui permet de penser Ã  la cÃ¦nogenÃ¨se de l'Ãªtre dont il est question
  dans la cause ambiguÃ« entendue Ã  MoÃ¿, dans un capharnaÃ¼m qui,
  pense-t-il, diminue Ã§Ã  et lÃ  la qualitÃ© de son Å“uvre.

  l'Ã®le exiguÃ«
  OÃ¹ l'obÃ¨se jury mÃ»r
  FÃªte l'haÃ¯ volapÃ¼k,
  Ã‚ne ex aÃ©quo au whist,
  Ã”tez ce vÅ“u dÃ©Ã§u.

  Le cÅ“ur dÃ©Ã§u mais l'Ã¢me plutÃ´t naÃ¯ve, LouÃ¿s rÃªva de crapaÃ¼ter en
  canoÃ« au delÃ  des Ã®les, prÃ¨s du mÃ¤lstrÃ¶m oÃ¹ brÃ»lent les novÃ¦.

Irish Gaelic (ga)
-----------------

  D'fhuascail Ãosa, Ãšrmhac na hÃ“ighe Beannaithe, pÃ³r Ã‰ava agus Ãdhaimh

Hungarian (hu)
--------------

  ÃrvÃ­ztÅ±rÅ‘ tÃ¼kÃ¶rfÃºrÃ³gÃ©p
  (= flood-proof mirror-drilling machine, only all non-ASCII letters)

Icelandic (is)
--------------

  KÃ¦mi nÃ½ Ã¶xi hÃ©r ykist Ã¾jÃ³fum nÃº bÃ¦Ã°i vÃ­l og Ã¡drepa

  SÃ¦vÃ¶r grÃ©t Ã¡Ã°an Ã¾vÃ­ Ãºlpan var Ã³nÃ½t
  (some ASCII letters missing)

Japanese (jp)
-------------

  Hiragana: (Iroha)

  ã„ã‚ã¯ã«ã»ã¸ã¨ã¡ã‚Šã¬ã‚‹ã‚’
  ã‚ã‹ã‚ˆãŸã‚Œãã¤ã­ãªã‚‰ã‚€
  ã†ã‚ã®ãŠãã‚„ã¾ã‘ãµã“ãˆã¦
  ã‚ã•ãã‚†ã‚ã¿ã—ã‚‘ã²ã‚‚ã›ã™

  Katakana:

  ã‚¤ãƒ­ãƒãƒ‹ãƒ›ãƒ˜ãƒˆ ãƒãƒªãƒŒãƒ«ãƒ² ãƒ¯ã‚«ãƒ¨ã‚¿ãƒ¬ã‚½ ãƒ„ãƒãƒŠãƒ©ãƒ 
  ã‚¦ãƒ°ãƒŽã‚ªã‚¯ãƒ¤ãƒž ã‚±ãƒ•ã‚³ã‚¨ãƒ† ã‚¢ã‚µã‚­ãƒ¦ãƒ¡ãƒŸã‚· ãƒ±ãƒ’ãƒ¢ã‚»ã‚¹ãƒ³

Hebrew (iw)
-----------

  ? ×“×’ ×¡×§×¨×Ÿ ×©×˜ ×‘×™× ×ž××•×›×–×‘ ×•×œ×¤×ª×¢ ×ž×¦× ×œ×• ×—×‘×¨×” ××™×š ×”×§×œ×™×˜×”

Polish (pl)
-----------

  PchnÄ…Ä‡ w tÄ™ Å‚Ã³dÅº jeÅ¼a lub oÅ›m skrzyÅ„ fig
  (= To push a hedgehog or eight bins of figs in this boat)

Russian (ru)
------------

  Ð’ Ñ‡Ð°Ñ‰Ð°Ñ… ÑŽÐ³Ð° Ð¶Ð¸Ð» Ð±Ñ‹ Ñ†Ð¸Ñ‚Ñ€ÑƒÑ? Ð”Ð°, Ð½Ð¾ Ñ„Ð°Ð»ÑŒÑˆÐ¸Ð²Ñ‹Ð¹ ÑÐºÐ·ÐµÐ¼Ð¿Ð»ÑÑ€!
  (= Would a citrus live in the bushes of south? Yes, but only a fake one!)

  Ð¡ÑŠÐµÑˆÑŒ Ð¶Ðµ ÐµÑ‰Ñ‘ ÑÑ‚Ð¸Ñ… Ð¼ÑÐ³ÐºÐ¸Ñ… Ñ„Ñ€Ð°Ð½Ñ†ÑƒÐ·ÑÐºÐ¸Ñ… Ð±ÑƒÐ»Ð¾Ðº Ð´Ð° Ð²Ñ‹Ð¿ÐµÐ¹ Ñ‡Ð°ÑŽ
  (= Eat some more of these fresh French loafs and have some tea)

Thai (th)
---------

  [--------------------------|------------------------]
  à¹ à¹€à¸›à¹‡à¸™à¸¡à¸™à¸¸à¸©à¸¢à¹Œà¸ªà¸¸à¸”à¸›à¸£à¸°à¹€à¸ªà¸£à¸´à¸à¹€à¸¥à¸´à¸¨à¸„à¸¸à¸“à¸„à¹ˆà¸²  à¸à¸§à¹ˆà¸²à¸šà¸£à¸£à¸”à¸²à¸à¸¹à¸‡à¸ªà¸±à¸•à¸§à¹Œà¹€à¸”à¸£à¸±à¸ˆà¸‰à¸²à¸™
  à¸ˆà¸‡à¸à¹ˆà¸²à¸Ÿà¸±à¸™à¸žà¸±à¸’à¸™à¸²à¸§à¸´à¸Šà¸²à¸à¸²à¸£           à¸­à¸¢à¹ˆà¸²à¸¥à¹‰à¸²à¸‡à¸œà¸¥à¸²à¸à¸¤à¹…à¹€à¸‚à¹ˆà¸™à¸†à¹ˆà¸²à¸šà¸µà¸‘à¸²à¹ƒà¸„à¸£
  à¹„à¸¡à¹ˆà¸–à¸·à¸­à¹‚à¸—à¸©à¹‚à¸à¸£à¸˜à¹à¸Šà¹ˆà¸‡à¸‹à¸±à¸”à¸®à¸¶à¸”à¸®à¸±à¸”à¸”à¹ˆà¸²     à¸«à¸±à¸”à¸­à¸ à¸±à¸¢à¹€à¸«à¸¡à¸·à¸­à¸™à¸à¸µà¸¬à¸²à¸­à¸±à¸Šà¸Œà¸²à¸ªà¸±à¸¢
  à¸›à¸à¸´à¸šà¸±à¸•à¸´à¸›à¸£à¸°à¸žà¸¤à¸•à¸´à¸à¸Žà¸à¸³à¸«à¸™à¸”à¹ƒà¸ˆ        à¸žà¸¹à¸”à¸ˆà¸²à¹ƒà¸«à¹‰à¸ˆà¹Šà¸°à¹† à¸ˆà¹‹à¸²à¹† à¸™à¹ˆà¸²à¸Ÿà¸±à¸‡à¹€à¸­à¸¢ à¸¯

  [The copyright for the Thai example is owned by The Computer
  Association of Thailand under the Royal Patronage of His Majesty the
  King.]

Turkish (tr)
------------

  PijamalÄ± hasta, yaÄŸÄ±z ÅŸofÃ¶re Ã§abucak gÃ¼vendi.
  (=Patient with pajamas, trusted swarthy driver quickly)
`);

__collect();

'''
'''--- tests/compiler/std/string.json ---
{
  "asc_flags": [
  ],
  "asc_rtrace": true
}

'''
'''--- tests/compiler/std/string.ts ---
import { utoa32, itoa32, utoa64, itoa64, dtoa } from "util/number";

// preliminary
var str: string = "hi, I'm a string";
var nullStr: string;

// exactly once in static memory
assert(changetype<usize>(str) == changetype<usize>("hi, I'm a string"));

assert("\xDF" == "ÃŸ");
assert("\xDF\xDF" == "ÃŸÃŸ");
assert("\xDFab" == "ÃŸab");

assert(str.length == 16);
assert(str.charCodeAt(0) == 0x68);
assert(str.codePointAt(1) == 105);
assert(str.at(15) == str.charAt(15));
assert(str.at(-1) == str.charAt(str.length - 1));
assert(str.at(-str.length) == "h");

assert(!!"" == false);
assert(!!"\0" == true);
assert(!!"a" == true);

assert(String.fromCharCode(0) == "\0");
assert(String.fromCharCode(65600) == "@");
assert(String.fromCharCode(54) == "6");
assert(String.fromCharCode(0x10000 + 54) == "6");
assert(String.fromCharCode(0xD800, 0xDF00) == "ðŒ€");
assert(String.fromCharCodes([0, 54]) == "\06");
assert(String.fromCharCodes([65, 66, 67]) == "ABC");
assert(String.fromCharCodes([0xD834, 0xDF06, 0x61, 0xD834, 0xDF07]) == "\uD834\uDF06a\uD834\uDF07");

assert(String.fromCodePoint(0) == "\0");
assert(String.fromCodePoint(54) == "6");
assert(String.fromCodePoint(0x1D306) == "\uD834\uDF06");

assert(str.startsWith("hi"));
assert(str.endsWith("string"));
assert(str.includes("I'm"));

assert(str.padStart(0) == str);
assert(str.padStart(15) == str);
assert("".padStart(3) == "   ");
assert("".padStart(10, "") == "");
assert("a".padStart(100, "") == "a");
assert("abc".padStart(5) == "  abc");
assert("abc".padStart(6, "123") == "123abc");
assert("abc".padStart(8, "123") == "12312abc");

assert(str.padEnd(0) == str);
assert(str.padEnd(15) == str);
assert("".padEnd(3) == "   ");
assert("".padEnd(10, "") == "");
assert("a".padEnd(100, "") == "a");
assert("abc".padEnd(5) == "abc  ");
assert("abc".padEnd(6, "abc") == "abcabc");
assert("abc".padEnd(8, "abc") == "abcabcab");

assert("".indexOf("") == 0);
assert("".indexOf("hi") == -1);
assert("a".indexOf("a") == 0);
assert(str.indexOf(str) == 0);
assert(str.indexOf("") == 0);
assert(str.indexOf(",") == 2);
assert(str.indexOf("x") == -1);
assert(str.indexOf(",", 2) == 2);
assert(str.indexOf(",", 3) == -1);
assert(str.indexOf(", I", -1) == 2);

assert("".lastIndexOf("") == 0);
assert("".lastIndexOf("hi") == -1);
assert(str.lastIndexOf("") == str.length);
assert(str.lastIndexOf(",") == 2);
assert(str.lastIndexOf("x") == -1);
assert(str.lastIndexOf("g") == 15);
assert(str.lastIndexOf(",", 2) == 2);
assert(str.lastIndexOf(",", 3) == 2);
assert(str.lastIndexOf(", I", -1) == -1);
assert(str.lastIndexOf("i", 0) == -1);
assert(str.lastIndexOf("hi", 0) == 0);

assert("".localeCompare("") == 0);
assert("a".localeCompare("") == 1);
assert("".localeCompare("a") == -1);
assert("null".localeCompare("null") == 0);
assert("abc".localeCompare("abd") == -1);
assert("abd".localeCompare("abc") == 1);
assert("abcd".localeCompare("abc") == 1);
assert("abc".localeCompare("abcd") == -1);
assert("".localeCompare("   ") == -1);
assert("\0".localeCompare("") == 1);

assert("".trimStart() == "");
assert("ab c".trimStart() == "ab c");
assert(" \n\t\rabc \t\r ".trimStart() == "abc \t\r ");

assert("".trimEnd() == "");
assert("ab c".trimEnd() == "ab c");
assert(" \n\t\rabc \t\r ".trimEnd() == " \n\t\rabc");

assert("".trim() == "");
assert("ab c".trim() == "ab c");
assert(" \n\t\rabc \t\r ".trim() == "abc");

assert(parseInt("0") == 0);
assert(parseInt("000") == 0);
assert(parseInt("1") == 1);
assert(parseInt("0001") == 1);
assert(parseInt("0b101") == 0b101);
assert(parseInt("0o707") == 0o707);
assert(parseInt("0xf0f") == 0xf0f);
assert(parseInt("0XF0F") == 0xf0f); // uppercase
assert(parseInt("011") == 11); // not octal
assert(parseInt("0x1g") == 1); // not valid
assert(parseInt("-123") == -123);
assert(parseInt("+123") == 123);
assert(parseInt("-12.3") == -12);
assert(parseInt("0", 0) == 0);
assert(parseInt("0x0", 0) == 0);
assert(parseInt("0b11", 16) == 0xb11);
assert(parseInt("\u000A1") == 1); // from test262
assert(parseInt("\u20281") == 1); // from test262
assert(parseInt("\u20291") == 1); // from test262
assert(Math.signbit(parseInt("-0")));
assert(parseInt("0XABCDEF") == parseInt("ABCDEF", 16));
assert(parseInt("36893488147419103232") == 36893488147419103000.0); // bigger than 2 ** 64 - 1
assert(parseInt("36893488147419103232", 13) == 5.135857308667095e+21);
assert(parseInt("-1000000000000000000000000", 10) == -1000000000000000000000000.0);
assert(parseInt("0x10000000000000000000", 16) == 75557863725914323419136.0); // from test262
assert(parseInt("1ðŸ”¥") == 1);
assert(parseInt("2badnum") == 2);

assert(parseInt(" \t\n1") == 1);
assert(parseInt(" \t\n0x02") == 2);
assert(isNaN(parseInt("")));
assert(isNaN(parseInt("-")));
assert(isNaN(parseInt("+")));
assert(isNaN(parseInt("123", 37)));
assert(isNaN(parseInt("ðŸ”¥")));
assert(isNaN(parseInt("badnum")));
assert(isNaN(F32.parseInt("badnum")));
assert(isNaN(F64.parseInt("badnum")));

assert(I32.parseInt("0x7FFFFFFF") == I32.MAX_VALUE);
assert(I64.parseInt("0x7FFFFFFFFFFFFFFF") == I64.MAX_VALUE);

// quick draft tests
assert(parseFloat("0") == 0);
assert(parseFloat("1") == 1);
assert(parseFloat("1.") == 1);
assert(parseFloat("1.00") == 1);
assert(parseFloat("1e-5") == 1e-5);
assert(parseFloat("-1e-5") == -1e-5);
assert(parseFloat("-0.3e-22") == -0.3e-22);
assert(parseFloat("0.3e+22") == 0.3e+22);
assert(parseFloat("1e-1") == 0.1);
assert(parseFloat("0.1e-0") == 0.1);
assert(parseFloat("0.1") == 0.1);
assert(parseFloat(".25") == 0.25);
assert(parseFloat("1.e+3a") == 1e+3);
assert(parseFloat("1.0e-10") == 1e-10);
assert(parseFloat("1.0e-30") == 1e-30);
assert(parseFloat("1.0e-323") == 1e-323);
assert(parseFloat("1.0e-324") == 0);
assert(parseFloat("1e+308") == 1e+308);
assert(parseFloat("1e+309") == Infinity);
assert(isNaN(parseFloat("")));

// with numeric separators (from tc39/test262)
assert(parseFloat("1.0e-1_0") == 1e-1);
assert(parseFloat("1.0e-10_0") == 1e-10);
assert(parseFloat("1.0e+1_0") == 1e+1);
assert(parseFloat("1_0") == 1);
assert(parseFloat("1_1") == 1);
assert(parseFloat("10.00_01e2") == 10.00);
assert(parseFloat("123456789_4") == 123456789);
assert(parseFloat("1_0123456789") == 1);

assert(parseFloat("1e-60") == 1e-60);
assert(parseFloat("1e60") == 1e+60);

// special cases
assert(parseFloat("123.4e") == 123.4);
assert(parseFloat("-.00000") == -0.0);
assert(parseFloat("1x") == 1.0);
assert(parseFloat("-11e-1string") == -1.1);
assert(parseFloat("01e1string") == 10);
assert(parseFloat("010string") == 10);
assert(parseFloat("+.22e-1") == 0.022);
assert(parseFloat("11.s1") == 11);
assert(parseFloat("0x0") == 0.0);
assert(parseFloat("0x5") == 0.0);
assert(parseFloat("0xD") == 0.0);
assert(parseFloat("\u000B1.1") == 1.1);
assert(parseFloat("\u000B\u000B-1.1") == -1.1);
assert(parseFloat("\u000C\u000C-1.1") == -1.1);
assert(parseFloat("\u2028\u2028-1.1") == -1.1);
assert(parseFloat("\u2029\u2029-1.1") == -1.1);
assert(parseFloat("00000") == 0.0);
assert(parseFloat("0000a") == 0.0);
assert(parseFloat("00001") == 1.0);
assert(parseFloat("00.00") == 0.0);
assert(parseFloat("00.0a") == 0.0);
assert(parseFloat("1e1e") == 10.0);
assert(parseFloat("1e+0001") == 10.0);
assert(parseFloat("0e+100") == 0.0);
assert(parseFloat("1.-1.") == 1.0);
assert(parseFloat("1e-1.2") == 0.1);
assert(parseFloat("1ex") == 1.0);
assert(parseFloat("1e1x") == 10);
assert(parseFloat("1e-x") == 1.0);
assert(parseFloat("1e-1x") == 0.1);
assert(parseFloat("0.1e-1x") == 0.01);
assert(parseFloat("00.") == 0.0);
assert(parseFloat(".00") == 0.0);
assert(parseFloat(".0.") == 0.0);
assert(parseFloat(".1.") == 0.1);
assert(parseFloat("0..") == 0.0);
assert(parseFloat("0.a") == 0.0);
assert(parseFloat("1..1") == 1.0);
assert(parseFloat("0.1.1") == 0.1);
assert(parseFloat("0. 1") == +0.0);
assert(parseFloat("+0.0") == +0.0);
assert(parseFloat("-0.0") == -0.0);
assert(parseFloat("+0") == +0);
assert(parseFloat("-0") == -0);
assert(isNaN(parseFloat("+")));
assert(isNaN(parseFloat("-")));
assert(isNaN(parseFloat("--0")));
assert(isNaN(parseFloat("++0")));
assert(isNaN(parseFloat(".a")));
assert(isNaN(parseFloat("..0")));
assert(isNaN(parseFloat(".")));
assert(isNaN(parseFloat("..")));
assert(isNaN(parseFloat("NaN")));
assert(isNaN(parseFloat("\u000B")));
assert(isNaN(parseFloat("\u180E")));
assert(isNaN(parseFloat("\u180E1.1")));
assert(isNaN(parseFloat("\u180E\u180E1.1")));
assert(isNaN(parseFloat("\u000C")));
assert(isNaN(parseFloat("true")));
assert(isNaN(parseFloat("false")));
assert(parseFloat("1e22") == 1e22);
assert(parseFloat("1e-22") == 1e-22);
assert(parseFloat("1e23") == 1e23);
assert(parseFloat("1e-23") == 1e-23);
assert(parseFloat("1e37") == 1e37);
assert(parseFloat("1e-37") == 1e-37);
assert(parseFloat("1e38") == 1e38);
assert(parseFloat("1e-38") == 1e-38);
assert(parseFloat("2.220446049250313e-16") == f64.EPSILON);
assert(parseFloat("1.7976931348623157e+308") == f64.MAX_VALUE);
assert(parseFloat("5e-324") == f64.MIN_VALUE);
assert(parseFloat("0.000001e+314") == 1e+308);
assert(parseFloat("0.00000000000000000000000000000000000000000000000000000001e+56") == 1.0);
assert(parseFloat("+1E-325") == 0.0);
assert(parseFloat("+1E+309") == Infinity);
assert(parseFloat("-1E-325") == 0.0);
assert(parseFloat("-1E+309") == -Infinity);
assert(parseFloat("1e-1000000") == 0.0);
assert(parseFloat("1e+1000000") == Infinity);
assert(parseFloat("1.e360") == Infinity);
assert(parseFloat(" Infinity") == Infinity);
assert(parseFloat("+Infinity") == Infinity);
assert(parseFloat("-Infinity") == -Infinity);
assert(parseFloat("Infinityx") == Infinity);
assert(parseFloat("Infinity+1") == Infinity);
assert(isNaN(parseFloat("Infi")));
assert(isNaN(parseFloat("+Infinit")));
assert(isNaN(parseFloat("infinity")));

// precision tests
// 2^-1074 * 0.5 - eps
assert(parseFloat(".2470328229206232720882843964341106861825299013071623822127928412503377536351043e-323") == 0);

// 2^-1074 * 0.5 + eps
// const Ox1p_1074 = reinterpret<f64>(0x1); // 0x1p-1074
// assert(parseFloat(".2470328229206232720882843964341106861825299013071623822127928412503377536351044e-323") == Ox1p_1074);
// FAIL! expected: 5e-324, actual: 0

// 2^-1074 * 1.5 - eps
// assert(parseFloat(".7410984687618698162648531893023320585475897039214871466383785237510132609053131e-323") == Ox1p_1074);
// FAIL! expected: 5e-324, actual: 0

// 2^-1074 * 1.5 + eps
const Ox1p_1073 = reinterpret<f64>(0x2); // 0x1p-1073
assert(parseFloat(".7410984687618698162648531893023320585475897039214871466383785237510132609053132e-323") == Ox1p_1073);

// 2^-1022 + 2^-1075 + eps
const Ox1_0000000000001p_1022 = reinterpret<f64>(0x10000000000001); // 0x1.0000000000001p-1022
assert(parseFloat(".2225073858507201630123055637955676152503612414573018013083228724049586647606760e-307") == Ox1_0000000000001p_1022);

// 2^1024 - 2^970 - eps = f64.MAX_VALUE
assert(parseFloat(
  "17976931348623158079372897140530341507993413271003782693617377898044" +
  "49682927647509466490179775872070963302864166928879109465555478519404" +
  "02630657488671505820681908902000708383676273854845817711531764475730" +
  "27006985557136695962284291481986083493647529271907416844436551070434" +
  "2711559699508093042880177904174497791.999999999999999999999999999999"
) == f64.MAX_VALUE); // 0x1.fffffffffffffp1023

// 2^1024 - 2^970
// assert(parseFloat(
//   "17976931348623158079372897140530341507993413271003782693617377898044" +
//   "49682927647509466490179775872070963302864166928879109465555478519404" +
//   "02630657488671505820681908902000708383676273854845817711531764475730" +
//   "27006985557136695962284291481986083493647529271907416844436551070434" +
//   "2711559699508093042880177904174497792"
// ) == Infinity); // FAIL expect: Infinity actual: 1.7976931348623157e+308

// tests for random values
assert(parseFloat("0.975353188879950261380713527614716440439e-103") == 9.753531888799502e-104);
assert(parseFloat(".5961860348131807091861002266453941950428e00") == 0.59618603481318067);
assert(parseFloat("1.815013169218038729887460898733526957442e-1") == 0.18150131692180388);
assert(parseFloat("42.07082357534453600681618685682257590772e-2") == 0.42070823575344535);
assert(parseFloat("665.4686306516261456328973225579833470816e-3") == 0.66546863065162609);
assert(parseFloat("6101.852922970868621786690495485449831753e-4") == 0.61018529229708685);
assert(parseFloat("76966.95208236968077849464348875471158549e-5") == 0.76966952082369677);
assert(parseFloat("250506.5322228682496132604807222923702304e-6") == 0.25050653222286823);
assert(parseFloat("2740037.230228005325852424697698331177377e-7") == 0.27400372302280052);
assert(parseFloat("20723093.50049742645941529268715428324490e-8") == 0.20723093500497428);
assert(parseFloat("0.7900280238081604956226011047460238748912e1") == 7.9002802380816046);
assert(parseFloat("0.9822860653737296848190558448760465863597e2") == 98.228606537372968);
assert(parseFloat("0.7468949723190370809405570560160405324869e3") == 746.89497231903704);
assert(parseFloat("0.1630268320282728475980459844271031751665e4") == 1630.2683202827284);
assert(parseFloat("0.4637168629719170695109918769645492022088e5") == 46371.686297191707);
assert(parseFloat("0.6537805944497711554209461686415872067523e6") == 653780.59444977110);
assert(parseFloat("0.2346324356502437045212230713960457676531e6") == 234632.43565024371);
assert(parseFloat("0.9709481716420048341897258980454298205278e8") == 97094817.164200485);
assert(parseFloat("0.4996908522051874110779982354932499499602e9") == 499690852.20518744);
assert(parseFloat("0.7925201200557245861944011267041787505149e22") == 7.9252012005572460e+21);
assert(parseFloat("0.6096564585983177408934352570213377475739e30") == 6.0965645859831775e+29);
assert(parseFloat("0.4800416117477028787874360205023549497128e67") == 4.8004161174770290e+66);
assert(parseFloat("0.8524829079817968224830337931052781641483e105") == 8.524829079817968e+104);
assert(parseFloat("0.0327123929170978211544706937274895608425e269") == 3.271239291709782e+267);

// with whitespaces
assert(isNaN(parseFloat(" \t\n")));
assert(parseFloat(" \t\n\r.1") == 0.1);

{
  let c = "a" + "b";
  assert(c == "ab");
  assert(c != "a");
}
assert("" == "");
// @ts-ignore
assert(nullStr == null);
// @ts-ignore
assert("" != nullStr);
// @ts-ignore
assert(nullStr != "");
// @ts-ignore
assert("a" != "b");
assert("a" == "a");
// @ts-ignore
assert("key1" != "key2");
assert("key1" == "key1");
// @ts-ignore
assert("ke1" != "ke2");
// @ts-ignore
assert("key12" != "key11");
assert("ã‚¤ãƒ­ãƒãƒ‹ãƒ›ãƒ˜ãƒˆ" == "ã‚¤ãƒ­ãƒãƒ‹ãƒ›ãƒ˜ãƒˆ");
// @ts-ignore
assert("ã‚¤ãƒ­ãƒãƒ‹ãƒ›ãƒ˜ãƒˆ" != "ã‚¦ãƒ°ãƒŽã‚ªã‚¯ãƒ¤ãƒž");
// @ts-ignore
assert("Dâ€™fhuascail" != "Dâ€™á¸Ÿuascail");

assert("b" > "a");
assert("ba" > "a");
assert("ba" >= "aa");
assert("ba" > "ab");
assert(!("ba" < "ab"));

assert("abc" > "");
assert("" < "abc");
assert("abc" >= "");
assert("" <= "abc");
assert(!("abc" < ""));
assert(!("" > "abc"));
assert(!("" < ""));
assert(!("" > ""));
assert("" >= "");
assert("" <= "");

assert("1" < "10");
assert("10" > "1");
assert(!("11" < "10"));
assert(!("10" > "11"));
assert("11" > "10");
assert("10" < "11");
assert(!("11" < "11"));
assert(!("11" > "11"));
assert("11" <= "11");
assert("11" >= "11");
assert(!("10" >= "101"));
assert("101" >= "10");
assert("10" <= "101");
assert("1" == "1");
assert("11" == "11");
assert("123" == "123");
// @ts-ignore
assert("123" != "122");
assert("1234" == "1234");
// @ts-ignore
assert("1233" != "1234");

{
  let a = String.fromCodePoint(0xFF61);
  let b = String.fromCodePoint(0xD800) + String.fromCodePoint(0xDC02);
  assert(a > b);
}

assert("123".length == 3);

assert("".repeat(100) == "");
assert("a".repeat() == "");
assert("a".repeat(1) == "a");
assert("a".repeat(2) == "aa");
assert("a".repeat(3) == "aaa");
assert("ab".repeat(4) == "abababab");
assert("a".repeat(5) == "aaaaa");
assert("a".repeat(6) == "aaaaaa");
assert("a".repeat(7) == "aaaaaaa");

assert("".replace("", "") == "");
assert("".replace("", "+") == "+");
assert("+".replace("+", "") == "");
assert("+".replace("", "") == "+");
assert("abc".replace("-", "+") == "abc");
assert("abc".replace("abc", "+") == "+");
assert("abc".replace("abcd", "+") == "abc");
assert("abc".replace("ab", "ab") == "abc");
assert("a-b-c".replace("-", "+") == "a+b-c");
assert("abc".replace("", "+") == "+abc");
assert("\nabc".replace("\n", "+") == "+abc");
assert("abc".replace("c", "++") == "ab++");
assert("abc".replace("c", "") == "ab");

assert("".replaceAll("", "abc") == "abc");
assert("abc".replaceAll("-", "+") == "abc");

assert("abcabc".replaceAll("abc", "+") == "++");
assert("abcabcabc".replaceAll("abc", "+") == "+++");
assert("abcabc".replaceAll("ab", "ab") == "abcabc");
assert("abcabca".replaceAll("a", "+++") == "+++bc+++bc+++");
assert("abcabc".replaceAll("ab", "++") == "++c++c");
assert("cccc".replaceAll("cc", "++") == "++++");
assert("abc".replaceAll("abcd", "+") == "abc");
assert("abcd".replaceAll("e", "++") == "abcd");
assert("abc".replaceAll("bc", "+") == "a+");
assert("ab".replaceAll("ab", "+") == "+");
assert("a-b-c".replaceAll("-", "+") == "a+b+c");
// cpecial cases
assert("".replaceAll("", "") == "");
assert("".replaceAll("", "+") == "+");
assert("+".replaceAll("+", "") == "");
assert("+".replaceAll("", "") == "+");
assert("abc".replaceAll("abc", "-") == "-");
assert("abc".replaceAll("abd", "-") == "abc");
assert("abc".replaceAll("", "+") == "+a+b+c+");
assert("abc".replaceAll("", "") == "abc");

// regressions
assert("abcde".replaceAll("a", "---") == "---bcde");
assert("ab".replaceAll("ab", "-----") == "-----");
assert("aaa".replaceAll("a", "----") == "------------");
assert("aaa".replaceAll("aa", "---") == "---a");

// test cases for slice method
str = "abcdefghijklmn";
assert(str.slice(0) == "abcdefghijklmn");
assert(str.slice(-1) == "n");
assert(str.slice(-5) == "jklmn");
assert(str.slice(2, 7) == "cdefg");
assert(str.slice(-11, -6) == "defgh");
assert(str.slice(4, 3) == "");
assert(str.slice(0, -1) == "abcdefghijklm");

assert(str.substr(0) == "abcdefghijklmn");
assert(str.substr(-1) == "n");
assert(str.substr(-5) == "jklmn");
assert(str.substr(2, 7) == "cdefghi");
assert(str.substr(-11, -6) == "");
assert(str.substr(4, 3) == "efg");
assert(str.substr(0, -1) == "");
assert(str.substr(0, 100) == "abcdefghijklmn");
assert(str.substr(4, 4) == "efgh");
assert(str.substr(4, -3) == "");

assert(str.substring(0) == "abcdefghijklmn");
assert(str.substring(-1) == "abcdefghijklmn");
assert(str.substring(-5) == "abcdefghijklmn");
assert(str.substring(2, 7) == "cdefg");
assert(str.substring(-11, -6) == "");
assert(str.substring(4, 3) == "d");
assert(str.substring(0, -1) == "");
assert(str.substring(0, 100) == "abcdefghijklmn");
assert(str.substring(4, 4) == "");
assert(str.substring(4, -3) == "abcd");

{
  let sa: string[];

  sa = "".split();
  assert(sa.length == 1 && sa[0] == "");
  sa = "".split("");
  assert(sa.length == 0);
  sa = "".split(",");
  assert(sa.length == 1 && sa[0] == "");
  sa = "a,b,c".split(".");
  assert(sa.length == 1 && sa[0] == "a,b,c");
  sa = "a,b,c".split(",");
  assert(sa.length == 3 && sa[0] == "a" && sa[1] == "b" && sa[2] == "c");
  sa = "a, b, c".split(", ");
  assert(sa.length == 3 && sa[0] == "a" && sa[1] == "b" && sa[2] == "c");
  sa = "a,b,,c".split(",");
  assert(sa.length == 4 && sa[0] == "a" && sa[1] == "b" && sa[2] == "" && sa[3] == "c");
  sa = ",a,b,c".split(",");
  assert(sa.length == 4 && sa[0] == "" && sa[1] == "a" && sa[2] == "b" && sa[3] == "c");
  sa = "a,b,c,".split(",");
  assert(sa.length == 4 && sa[0] == "a" && sa[1] == "b" && sa[2] == "c" && sa[3] == "");
  sa = "abc".split("");
  assert(sa.length == 3 && sa[0] == "a" && sa[1] == "b" && sa[2] == "c");
  sa = "abc".split("", 0);
  assert(sa.length == 0);
  sa = "abc".split("", 1);
  assert(sa.length == 1 && sa[0] == "a");
  sa = "a,b,c".split(",", 1);
  assert(sa.length == 1 && sa[0] == "a");
  sa = "abc".split("", 4);
  assert(sa.length == 3 && sa[0] == "a" && sa[1] == "b" && sa[2] == "c");
  sa = "abc".split("", -1);
  assert(sa.length == 3 && sa[0] == "a" && sa[1] == "b" && sa[2] == "c");
  sa = "a,b,c".split(",", -1);
  assert(sa.length == 3 && sa[0] == "a" && sa[1] == "b" && sa[2] == "c");
}

// 32-bit radix 10

assert(itoa32(0, 10) == "0");
assert(itoa32(1, 10) == "1");
assert(itoa32(8, 10) == "8");
assert(itoa32(12, 10) == "12");
assert(itoa32(123, 10) == "123");
assert(itoa32(-1000, 10) == "-1000");
assert(itoa32(1234, 10) == "1234");
assert(itoa32(12345, 10) == "12345");
assert(itoa32(123456, 10) == "123456");
assert(itoa32(1111111, 10) == "1111111");
assert(itoa32(1234567, 10) == "1234567");
assert(itoa32(12345678, 10) == "12345678");
assert(itoa32(123456789, 10) == "123456789");
assert(itoa32(0x7ffffffe, 10) == "2147483646");
assert(itoa32(0x7fffffff, 10) == "2147483647");
assert(itoa32(0x80000000, 10) == "-2147483648");
assert(itoa32(0xffffffff, 10) == "-1");

assert(utoa32(0, 10) == "0");
assert(utoa32(1000, 10) == "1000");
assert(utoa32(0x7fffffff, 10) == "2147483647");
assert(utoa32(0x80000000, 10) == "2147483648");
assert(utoa32(u32.MAX_VALUE, 10) == "4294967295");

// 32-bit radix 16

assert(utoa32(0x00000000, 16) == "0");
assert(utoa32(0x00000001, 16) == "1");
assert(utoa32(0x00000008, 16) == "8");
assert(utoa32(0x0000000c, 16) == "c");
assert(utoa32(0x0000007b, 16) == "7b");
assert(utoa32(0x000004d2, 16) == "4d2");
assert(utoa32(0x00003039, 16) == "3039");
assert(utoa32(0x0001e240, 16) == "1e240");
assert(utoa32(0x0010f447, 16) == "10f447");
assert(utoa32(0x0012d687, 16) == "12d687");
assert(utoa32(0x00bc614e, 16) == "bc614e");
assert(utoa32(0x075bcd15, 16) == "75bcd15");
assert(utoa32(0x7ffffffe, 16) == "7ffffffe");
assert(utoa32(0x7fffffff, 16) == "7fffffff");
assert(utoa32(0x80000000, 16) == "80000000");
assert(utoa32(0xffffffff, 16) == "ffffffff");

assert(itoa32( 0, 16) == "0");
assert(itoa32(-0x1000, 16) == "-1000");
assert(itoa32( 0x7fffffff, 16) == "7fffffff");
assert(itoa32(-0x7fffffff, 16) == "-7fffffff");
assert(itoa32(-0x0fffffff, 16) == "-fffffff");
assert(itoa32( 0x80000000, 16) == "-80000000");
assert(itoa32(-0x80000000, 16) == "-80000000");

// 32-bit radix 2

assert(utoa32(0, 2) == "0");
assert(utoa32(0b1, 2) == "1");
assert(utoa32(0b11, 2) == "11");
assert(utoa32(0b111, 2) == "111");
assert(utoa32(0b1110, 2) == "1110");
assert(utoa32(0b11101, 2) == "11101");
assert(utoa32(0b111011, 2) == "111011");
assert(utoa32(0b111111111111, 2) == "111111111111");
assert(utoa32(0b1111111111111111111111111, 2) == "1111111111111111111111111");
assert(utoa32(0b11111111111111111111111111110100, 2) == "11111111111111111111111111110100");
assert(utoa32(0b11111111111111111111111111111100, 2) == "11111111111111111111111111111100");
assert(utoa32(0b11111111111111111111111111111110, 2) == "11111111111111111111111111111110");
assert(utoa32(0b11111111111111111111111111111111, 2) == "11111111111111111111111111111111");

assert(itoa32(-0b11111111111, 2) == "-11111111111");

// 32-bit radix random

assert(utoa32(0xffffffff,  3) == "102002022201221111210");
assert(utoa32(0xffffffff,  4) == "3333333333333333");
assert(utoa32(0xffffffff,  5) == "32244002423140");
assert(utoa32(0xffffffff,  8) == "37777777777");
assert(utoa32(0xffffffff, 11) == "1904440553");
assert(utoa32(0xffffffff, 15) == "1a20dcd80");
assert(utoa32(0xffffffff, 17) == "a7ffda90");
assert(utoa32(0xffffffff, 21) == "281d55i3");
assert(utoa32(0xffffffff, 27) == "b28jpdl");
assert(utoa32(0xffffffff, 32) == "3vvvvvv");
assert(utoa32(0xffffffff, 36) == "1z141z3");

// 64-bit radix 10

assert(utoa64(0, 10) == "0");
assert(utoa64(12, 10) == "12");
assert(utoa64(123, 10) == "123");
assert(utoa64(1234, 10) == "1234");
assert(utoa64(12345, 10) == "12345");
assert(utoa64(123456, 10) == "123456");
assert(utoa64(1234567, 10) == "1234567");
assert(utoa64(99999999, 10) == "99999999");
assert(utoa64(100000000, 10) == "100000000");
assert(utoa64(0xffffffff, 10) == "4294967295");
assert(utoa64(4294967297, 10) == "4294967297");
assert(utoa64(0xfffffffff, 10) == "68719476735");
assert(utoa64(868719476735, 10) == "868719476735");
assert(utoa64(8687194767350, 10) == "8687194767350");
assert(utoa64(86871947673501, 10) == "86871947673501");
assert(utoa64(999868719476735, 10) == "999868719476735");
assert(utoa64(9999868719476735, 10) == "9999868719476735");
assert(utoa64(19999868719476735, 10) == "19999868719476735");
assert(utoa64(129999868719476735, 10) == "129999868719476735");
assert(utoa64(1239999868719476735, 10) == "1239999868719476735");
assert(utoa64(u64.MAX_VALUE, 10)       == "18446744073709551615");

assert(itoa64(0, 10) == "0");
assert(itoa64(-1234, 10) == "-1234");
assert(itoa64(0xffffffff, 10) == "4294967295");
assert(itoa64(4294967297, 10) == "4294967297");
assert(itoa64(-0xffffffff, 10) == "-4294967295");
assert(itoa64(68719476735, 10) == "68719476735");
assert(itoa64(-68719476735, 10) == "-68719476735");
assert(itoa64(-868719476735, 10) == "-868719476735");
assert(itoa64(-999868719476735, 10) == "-999868719476735");
assert(itoa64(-19999868719476735, 10) == "-19999868719476735");
assert(itoa64(i64.MAX_VALUE, 10) == "9223372036854775807");
assert(itoa64(i64.MIN_VALUE, 10) == "-9223372036854775808");

// 64-bit radix 16

assert(utoa64(0x0000000000000000, 16) == "0");
assert(utoa64(0x0000000000000001, 16) == "1");
assert(utoa64(0x000000000000000c, 16) == "c");
assert(utoa64(0x00000000000004d2, 16) == "4d2");
assert(utoa64(0x000000000010f447, 16) == "10f447");
assert(utoa64(0x00000001ffffffff, 16) == "1ffffffff");
assert(utoa64(0x0000056789abcde1, 16) == "56789abcde1");
assert(utoa64(0x0000456789abcde1, 16) == "456789abcde1");
assert(utoa64(0x0003456789abcdef, 16) == "3456789abcdef");
assert(utoa64(0x0023456789abcdef, 16) == "23456789abcdef");
assert(utoa64(0x0123456789abcdef, 16) == "123456789abcdef");
assert(utoa64(0x123456789abcdef0, 16) == "123456789abcdef0");
assert(utoa64(0x7fffffffffffffff, 16) == "7fffffffffffffff");
assert(utoa64(0xffffffffffffffff, 16) == "ffffffffffffffff");

assert(itoa64(-0x7fffffffffffffff, 16) == "-7fffffffffffffff");
assert(itoa64( 0x8000000000000000, 16) == "-8000000000000000");
assert(itoa64(-0x8000000000000000, 16) == "-8000000000000000");

// 64-bit radix 2

assert(utoa64(0, 2) == "0");
assert(utoa64(0b1, 2) == "1");
assert(utoa64(0b111, 2) == "111");
assert(utoa64(0b1110, 2) == "1110");
assert(utoa64(0b111011, 2) == "111011");
assert(utoa64(0b111111111111, 2) == "111111111111");
assert(utoa64(0b11111111111111111111111111111111, 2) == "11111111111111111111111111111111");
assert(utoa64(0b1111111111111111111111111111111111111111111111111, 2) == "1111111111111111111111111111111111111111111111111");
assert(utoa64(0xffffffffffffffff, 2) == "1111111111111111111111111111111111111111111111111111111111111111");

assert(itoa64(-0b111111111111111111111111111111111, 2) == "-111111111111111111111111111111111");

// 64-bit radix random

assert(utoa64(0xffffffffffffffff,  3) == "11112220022122120101211020120210210211220");
assert(utoa64(0xffffffffffffffff,  4) == "33333333333333333333333333333333");
assert(utoa64(0xffffffffffffffff,  5) == "2214220303114400424121122430");
assert(utoa64(0xffffffffffffffff,  8) == "1777777777777777777777");
assert(utoa64(0xffffffffffffffff, 11) == "335500516a429071284");
assert(utoa64(0xffffffffffffffff, 15) == "2c1d56b648c6cd110");
assert(utoa64(0xffffffffffffffff, 17) == "67979g60f5428010");
assert(utoa64(0xffffffffffffffff, 21) == "5e8g4ggg7g56dif");
assert(utoa64(0xffffffffffffffff, 27) == "4eo8hfam6fllmo");
assert(utoa64(0xffffffffffffffff, 32) == "fvvvvvvvvvvvv");
assert(utoa64(0xffffffffffffffff, 36) == "3w5e11264sgsf");

// special cases
assert(dtoa(0.0) == "0.0");
assert(dtoa(-0.0) == "0.0");
assert(dtoa(NaN) == "NaN");
assert(dtoa(+Infinity) == "Infinity");
assert(dtoa(-Infinity) == "-Infinity");
assert(dtoa(+f64.EPSILON) == "2.220446049250313e-16");
assert(dtoa(-f64.EPSILON) == "-2.220446049250313e-16");
assert(dtoa(+f64.MAX_VALUE) == "1.7976931348623157e+308");
assert(dtoa(-f64.MAX_VALUE) == "-1.7976931348623157e+308");
assert(dtoa(4.185580496821357e+298) == "4.185580496821357e+298");
assert(dtoa(2.2250738585072014e-308) == "2.2250738585072014e-308");
// assert(dtoa(2.98023223876953125e-8) == "2.9802322387695312e-8"); // FIXME
// assert(dtoa(-2.109808898695963e+16) == "-21098088986959630.0"); // FIXME
assert(dtoa(4.940656E-318) == "4.940656e-318");
assert(dtoa(9.0608011534336e+15) == "9060801153433600.0");
assert(dtoa(4.708356024711512e+18) == "4708356024711512000.0");
assert(dtoa(9.409340012568248e+18) == "9409340012568248000.0");
assert(dtoa(5e-324) == "5e-324");
// Known imprecise issue for Grisu alghoritm. Need workaround
// Expeced: 1.2345e+21
// Actual:  1.2344999999999999e+21
// assert(dtoa(1.2345e+21) == "1.2345e+21");

assert(dtoa(1.0) == "1.0");
assert(dtoa(0.1) == "0.1");
assert(dtoa(-1.0) == "-1.0");
assert(dtoa(-0.1) == "-0.1");

assert(dtoa(1e+6) == "1000000.0");
assert(dtoa(1e-6) == "0.000001");
assert(dtoa(-1e+6) == "-1000000.0");
assert(dtoa(-1e-6) == "-0.000001");
assert(dtoa(1e+7) == "10000000.0");
assert(dtoa(1e-7) == "1e-7");

assert(dtoa(1e+308) == "1e+308");
assert(dtoa(-1e+308) == "-1e+308");
assert(dtoa(1e+309) == "Infinity");
assert(dtoa(-1e+309) == "-Infinity");
assert(dtoa(1e-308) == "1e-308");
assert(dtoa(-1e-308) == "-1e-308");
assert(dtoa(1e-323) == "1e-323");
assert(dtoa(-1e-323) == "-1e-323");
assert(dtoa(1e-324) == "0.0");

assert(dtoa(4294967272) == "4294967272.0");
assert(dtoa(1.23121456734562345678e-8) == "1.2312145673456234e-8");
// assert(dtoa(-0.0000010471975511965976) == "-0.0000010471975511965976"); // FIXME
assert(dtoa(555555555.55555555) == "555555555.5555556");
assert(dtoa(0.9999999999999999) == "0.9999999999999999");
assert(dtoa(0.99999999999999995) == "1.0");
assert(dtoa(1234e-2) == "12.34");
// assert(dtoa(0.1 + 0.2)   == "0.30000000000000004"); // FIXME
assert(dtoa(1.0 / 3.0) == "0.3333333333333333");
assert(dtoa(1.234e+20) == "123400000000000000000.0");
assert(dtoa(1.234e+21) == "1.234e+21");
assert(dtoa(2.71828) == "2.71828");
assert(dtoa(2.71828e-2) == "0.0271828");
assert(dtoa(2.71828e+2) == "271.828");
assert(dtoa(1.1e+128) == "1.1e+128");
assert(dtoa(1.1e-64) == "1.1e-64");
assert(dtoa(0.000035689) == "0.000035689");

// concat

assert("Hello ".concat("World") == "Hello World");
assert("".concat("bar") == "bar");
assert("bar".concat("") == "bar");
assert("".concat("") == "");

// assert(dtoa(f32.MAX_VALUE) == "3.4028234663852886e+38"); // FIXME
// assert(dtoa(f32.EPSILON) == "1.1920928955078125e-7"); // FIXME

export function getString(): string {
  return str;
}

// Unleak globals

str = changetype<string>(0);

__stack_pointer = __heap_base;
__collect();

'''
'''--- tests/compiler/std/symbol.json ---
{
  "asc_flags": [
    "--explicitStart"
  ]
}

'''
'''--- tests/compiler/std/symbol.ts ---
var sym1 = Symbol("123");
var sym2 = Symbol("123");

assert(sym1 !== sym2);

var sym3 = Symbol.for("123");
var sym4 = Symbol.for("123");

assert(sym3 === sym4);

var key1 = Symbol.keyFor(sym1);
var key2 = Symbol.keyFor(sym2);

assert(key1 === null);
assert(key2 === null);

var key3 = Symbol.keyFor(sym3)!;
var key4 = Symbol.keyFor(sym4)!;

assert(key3 == "123");
assert(key3 == key4);

assert(Symbol().toString() == "Symbol()");
assert(sym3.toString() == "Symbol(123)");

var hasInstance = Symbol.hasInstance;
var isConcatSpreadable = Symbol.isConcatSpreadable;
assert(hasInstance.toString() == "Symbol(hasInstance)");
assert(isConcatSpreadable.toString() == "Symbol(isConcatSpreadable)");

Symbol.hasInstance;
Symbol.isConcatSpreadable;
// ...

'''
'''--- tests/compiler/std/trace.json ---
{
  "asc_flags": [
    "--explicitStart"
  ]
}

'''
'''--- tests/compiler/std/trace.ts ---
trace("zero_implicit");
trace("zero_explicit", 0);
trace("one_int", 1, 1);
trace("two_int", 2, 1, 2);
trace("three_int", 3, 1, 2, 3);
trace("four_int", 4, 1, 2, 3, 4);
trace("five_int", 5, 1, 2, 3, 4, 5);
trace("five_dbl", 5, 1.1, 2.2, 3.3, 4.4, 5.5);

'''
'''--- tests/compiler/std/typedarray.json ---
{
  "asc_flags": [
  ],
  "asc_rtrace": true
}

'''
'''--- tests/compiler/std/typedarray.ts ---
assert(Int8Array.BYTES_PER_ELEMENT == 1);
assert(Uint8Array.BYTES_PER_ELEMENT == 1);
assert(Uint8ClampedArray.BYTES_PER_ELEMENT == 1);
assert(Int16Array.BYTES_PER_ELEMENT == 2);
assert(Uint16Array.BYTES_PER_ELEMENT == 2);
assert(Int32Array.BYTES_PER_ELEMENT == 4);
assert(Uint32Array.BYTES_PER_ELEMENT == 4);
assert(Int64Array.BYTES_PER_ELEMENT == 8);
assert(Uint64Array.BYTES_PER_ELEMENT == 8);
assert(Float32Array.BYTES_PER_ELEMENT == 4);
assert(Float64Array.BYTES_PER_ELEMENT == 8);

function isInt8ArrayEqual(a: Int8Array, b: Array<i8>): bool {
  if (a.length != b.length) return false;
  for (let i = 0, len = a.length; i < len; i++) {
    if (a[i] != b[i]) return false;
  }
  return true;
}

function isInt32ArrayEqual(a: Int32Array, b: Array<i32>): bool {
  if (a.length != b.length) return false;
  for (let i = 0, len = a.length; i < len; i++) {
    if (a[i] != b[i]) return false;
  }
  return true;
}

function testInstantiate(len: i32): void {

  var i8a = new Int8Array(len);
  assert(i8a.byteOffset == 0);
  assert(i8a.byteLength == len * Int8Array.BYTES_PER_ELEMENT);
  assert(i8a.length == len);

  var u8a = new Uint8Array(len);
  assert(u8a.byteOffset == 0);
  assert(u8a.byteLength == len * Uint8Array.BYTES_PER_ELEMENT);
  assert(u8a.length == len);

  var c8a = new Uint8ClampedArray(len);
  assert(c8a.byteOffset == 0);
  assert(c8a.byteLength == len * Uint8Array.BYTES_PER_ELEMENT);
  assert(c8a.length == len);

  var i16a = new Int16Array(len);
  assert(i16a.byteOffset == 0);
  assert(i16a.byteLength == len * Int16Array.BYTES_PER_ELEMENT);
  assert(i16a.length == len);

  var u16a = new Uint16Array(len);
  assert(u16a.byteOffset == 0);
  assert(u16a.byteLength == len * Uint16Array.BYTES_PER_ELEMENT);
  assert(u16a.length == len);

  var i32a = new Int32Array(len);
  assert(i32a.byteOffset == 0);
  assert(i32a.byteLength == len * Int32Array.BYTES_PER_ELEMENT);
  assert(i32a.length == len);

  var u32a = new Uint32Array(len);
  assert(u32a.byteOffset == 0);
  assert(u32a.byteLength == len * Uint32Array.BYTES_PER_ELEMENT);
  assert(u32a.length == len);

  var i64a = new Int64Array(len);
  assert(i64a.byteOffset == 0);
  assert(i64a.byteLength == len * Int64Array.BYTES_PER_ELEMENT);
  assert(i64a.length == len);

  var u64a = new Uint64Array(len);
  assert(u64a.byteOffset == 0);
  assert(u64a.byteLength == len * Uint64Array.BYTES_PER_ELEMENT);
  assert(u64a.length == len);

  var f32a = new Float32Array(len);
  assert(f32a.byteOffset == 0);
  assert(f32a.byteLength == len * Float32Array.BYTES_PER_ELEMENT);
  assert(f32a.length == len);

  var f64a = new Float64Array(len);
  assert(f64a.byteOffset == 0);
  assert(f64a.byteLength == len * Float64Array.BYTES_PER_ELEMENT);
  assert(f64a.length == len);
}

testInstantiate(0);
testInstantiate(5);

{
  let arr = new Int32Array(3);
  arr[0] = 1;
  arr[1] = 2;
  arr[2] = 3;
  assert(arr.length == 3);
  assert(arr.byteOffset == 0);
  assert(arr.byteLength == 3 * sizeof<i32>());
  assert(arr[0] == 1);
  assert(arr[1] == 2);
  assert(arr[2] == 3);

  arr = arr.subarray(1, 2);
  assert(arr.length == 1);
  assert(arr.byteOffset == 1 * sizeof<i32>());
  assert(arr.byteLength == 1 * sizeof<i32>());
  assert(arr[0] == 2);
}

{
  let af64 = new Float64Array(8);
  af64[0] = 1;
  af64[1] = 2;

  af64[2] = 7;
  af64[3] = 6;
  af64[4] = 5;
  af64[5] = 4;

  af64[6] = 3;
  af64[7] = 8;
  af64 = af64.subarray(2, 6);
  assert(af64.length == 4);
  assert(af64.byteOffset == 2 * sizeof<f64>());
  assert(af64.byteLength == 4 * sizeof<f64>());
  af64.sort();
  assert(af64[0] == 4 && af64[1] == 5 && af64[2] == 6 && af64[3] == 7);
}

{
  let clampedArr = new Uint8ClampedArray(3);
  clampedArr[0] = -32;
  clampedArr[1] = 2;
  clampedArr[2] = 256;

  assert(clampedArr[0] == 0);
  assert(clampedArr[1] == 2);
  assert(clampedArr[2] == 255);
}

{
  let arr8 = new Int8Array(5);
  arr8[0] = 1;
  arr8[1] = 2;
  arr8[2] = 3;
  arr8[3] = 4;
  arr8[4] = 5;

  arr8.fill(1, 1, 3);
  assert(isInt8ArrayEqual(arr8, <i8[]>[1, 1, 1, 4, 5]));

  arr8.fill(0);
  assert(isInt8ArrayEqual(arr8, <i8[]>[0, 0, 0, 0, 0]));

  arr8.fill(1, 0, -3);
  assert(isInt8ArrayEqual(arr8, <i8[]>[1, 1, 0, 0, 0]));

  arr8.fill(2, -2);
  assert(isInt8ArrayEqual(arr8, <i8[]>[1, 1, 0, 2, 2]));

  arr8.fill(0, 1, 0);
  assert(isInt8ArrayEqual(arr8, <i8[]>[1, 1, 0, 2, 2]));

  let sub8 = arr8.subarray(1, 4);
  sub8.fill(0);
  assert(sub8.length == 3);
  assert(sub8.byteOffset == 1);
  assert(sub8.byteLength == 3);
  assert(isInt8ArrayEqual(sub8, <i8[]>[0, 0, 0]));
  assert(isInt8ArrayEqual(arr8, <i8[]>[1, 0, 0, 0, 2]));
}

{
  let arr32 = new Int32Array(5);
  arr32[0] = 1;
  arr32[1] = 2;
  arr32[2] = 3;
  arr32[3] = 4;
  arr32[4] = 5;

  arr32.fill(1, 1, 3);
  assert(isInt32ArrayEqual(arr32, <i32[]>[1, 1, 1, 4, 5]));

  arr32.fill(0);
  assert(isInt32ArrayEqual(arr32, <i32[]>[0, 0, 0, 0, 0]));

  arr32.fill(1, 0, -3);
  assert(isInt32ArrayEqual(arr32, <i32[]>[1, 1, 0, 0, 0]));

  arr32.fill(2, -2);
  assert(isInt32ArrayEqual(arr32, <i32[]>[1, 1, 0, 2, 2]));

  arr32.fill(0, 1, 0);
  assert(isInt32ArrayEqual(arr32, <i32[]>[1, 1, 0, 2, 2]));

  let sub32 = arr32.subarray(1, 4);
  sub32.fill(0);
  assert(sub32.length == 3);
  assert(sub32.byteOffset == 1 * sizeof<i32>());
  assert(sub32.byteLength == 3 * sizeof<i32>());
  assert(isInt32ArrayEqual(sub32, <i32[]>[0, 0, 0]));
  assert(isInt32ArrayEqual(arr32, <i32[]>[1, 0, 0, 0, 2]));
}

// import { BLOCK_MAXSIZE } from "rt/common";

// FIXME: this does not work / failing assertion on insertBlock(addMemory)
{
  // const MAX_F64LENGTH = (BLOCK_MAXSIZE >> alignof<f64>()) >> 1;
  // new Float64Array(MAX_F64LENGTH + 200);
}

{
  let multisubarr = new Int8Array(6);
  multisubarr[0] = 1;
  multisubarr[1] = 2;
  multisubarr[2] = 3;
  multisubarr[3] = 4;
  multisubarr[4] = 5;
  multisubarr[5] = 6;

  let multisubarr1 = multisubarr.subarray(1, 6);
  assert(multisubarr1[0] == 2);
  assert(multisubarr1.length == 5);
  assert(multisubarr1.byteOffset == 1);
  assert(multisubarr1.byteLength == 5);

  let multisubarr2 = multisubarr1.subarray(1, 5);
  assert(multisubarr2[0] == 3);
  assert(multisubarr2.length == 4);
  assert(multisubarr2.byteOffset == 2);
  assert(multisubarr2.byteLength == 4);

  let multisubarr3 = multisubarr2.subarray(1, 4);
  assert(multisubarr3[0] == 4);
  assert(multisubarr3.length == 3);
  assert(multisubarr3.byteOffset == 3);
  assert(multisubarr3.byteLength == 3);
}

{
  let cwAr = new Int32Array(5);
  cwAr[0] = 1;
  cwAr[1] = 2;
  cwAr[2] = 3;
  cwAr[3] = 4;
  cwAr[4] = 5;
  let copy = cwAr.slice(0);
  assert(isInt32ArrayEqual(cwAr.copyWithin(0, 3), <i32[]>[4, 5, 3, 4, 5]));
  cwAr = copy.slice(0);
  assert(isInt32ArrayEqual(cwAr.copyWithin(1, 3), <i32[]>[1, 4, 5, 4, 5]));
  cwAr = copy.slice(0);
  assert(isInt32ArrayEqual(cwAr.copyWithin(1, 2), <i32[]>[1, 3, 4, 5, 5]));
  cwAr = copy.slice(0);
  assert(isInt32ArrayEqual(cwAr.copyWithin(2, 2), <i32[]>[1, 2, 3, 4, 5]));
  cwAr = copy.slice(0);
  assert(isInt32ArrayEqual(cwAr.copyWithin(0, 3, 4), <i32[]>[4, 2, 3, 4, 5]));
  cwAr = copy.slice(0);
  assert(isInt32ArrayEqual(cwAr.copyWithin(1, 3, 4), <i32[]>[1, 4, 3, 4, 5]));
  cwAr = copy.slice(0);
  assert(isInt32ArrayEqual(cwAr.copyWithin(1, 2, 4), <i32[]>[1, 3, 4, 4, 5]));
  cwAr = copy.slice(0);
  assert(isInt32ArrayEqual(cwAr.copyWithin(0, -2), <i32[]>[4, 5, 3, 4, 5]));
  cwAr = copy.slice(0);
  assert(isInt32ArrayEqual(cwAr.copyWithin(0, -2, -1), <i32[]>[4, 2, 3, 4, 5]));
  cwAr = copy.slice(0);
  assert(isInt32ArrayEqual(cwAr.copyWithin(-4, -3, -2), <i32[]>[1, 3, 3, 4, 5]));
  cwAr = copy.slice(0);
  assert(isInt32ArrayEqual(cwAr.copyWithin(-4, -3, -1), <i32[]>[1, 3, 4, 4, 5]));
  cwAr = copy.slice(0);
  assert(isInt32ArrayEqual(cwAr.copyWithin(-4, -3), <i32[]>[1, 3, 4, 5, 5]));
}

{
  let arr = new Int32Array(5);
  arr[0] = 1;
  arr[1] = 2;
  arr[2] = 3;
  arr[3] = 4;
  arr[4] = 5;

  let sub = arr.subarray(1, 4);
  assert(sub.length == 3);
  assert(sub.byteOffset == 4);
  assert(sub.byteLength == 12);

  let sliced = arr.slice(1, 3);
  assert(sliced[0] == 2);
  assert(sliced[1] == 3);
  assert(sliced.length == 2);
  assert(sliced.byteOffset == 0);
  assert(sliced.byteLength == 8);

  let subsliced = sub.slice(1, 2);
  assert(subsliced[0] == 3);
  assert(subsliced.length == 1);
  assert(subsliced.byteOffset == 0);
  assert(subsliced.byteLength == 4);

  let copy = arr.slice();
  assert(copy !== arr);
  assert(copy.length == arr.length);
  assert(copy.byteOffset == arr.byteOffset);
  assert(copy.byteLength == arr.byteLength);
}

// Reduce test suite:

// The reduce test is designed to test a simple sum reduction. In each test it instantiates the
// tested typedarray, and sets the values manually. Then it calls `TypedArray.prototype.reduce` with a
// single sum arrow function reduction. For each reduction, it verifies the `self` parameter is the
// instantiated array, the index is the correct index, and it increments the testIndex variable.
// Finally, it asserts the value is 6.

// TODO: When function closure support is added, remove the function comments to fully verify the
// tests work.

function testReduce<ArrayType extends TypedArray<T>, T extends number>(): void {
  var array = instantiate<ArrayType>(3);
  array[0] = <T>1;
  array[1] = <T>2;
  array[2] = <T>3;
  var result = array.reduce((acc, val) => <T>(acc + val), <T>0);
  assert(result == <T>6);
}

testReduce<Int8Array, i8>();
testReduce<Uint8Array, u8>();
testReduce<Uint8ClampedArray, u8>();
testReduce<Int16Array, i16>();
testReduce<Uint16Array, u16>();
testReduce<Int32Array, i32>();
testReduce<Uint32Array, u32>();
testReduce<Int64Array, i64>();
testReduce<Uint64Array, u64>();
testReduce<Float32Array, f32>();
testReduce<Float64Array, f64>();

function testAt<ArrayType extends TypedArray<T>, T extends number>(): void {
  var array = instantiate<ArrayType>(3);
  array[0] = <T>1;
  array[1] = <T>2;
  array[2] = <T>3;

  assert(array.at( 0) == <T>1);
  assert(array.at(-1) == <T>3);
  assert(array.at(-3) == <T>1);
}

testAt<Int8Array, i8>();
testAt<Uint8Array, u8>();
testAt<Uint8ClampedArray, u8>();
testAt<Int16Array, i16>();
testAt<Uint16Array, u16>();
testAt<Int32Array, i32>();
testAt<Uint32Array, u32>();
testAt<Int64Array, i64>();
testAt<Uint64Array, u64>();
testAt<Float32Array, f32>();
testAt<Float64Array, f64>();

function testReduceRight<ArrayType extends TypedArray<T>, T extends number>(): void {
  var array = instantiate<ArrayType>(3);
  array[0] = <T>1;
  array[1] = <T>2;
  array[2] = <T>3;
  var result = array.reduceRight((acc, val) => <T>(acc + val), <T>0);
  assert(result == <T>6);
}

testReduceRight<Int8Array, i8>();
testReduceRight<Uint8Array, u8>();
testReduceRight<Uint8ClampedArray, u8>();
testReduceRight<Int16Array, i16>();
testReduceRight<Uint16Array, u16>();
testReduceRight<Int32Array, i32>();
testReduceRight<Uint32Array, u32>();
testReduceRight<Int64Array, i64>();
testReduceRight<Uint64Array, u64>();
testReduceRight<Float32Array, f32>();
testReduceRight<Float64Array, f64>();

function testArrayMap<ArrayType extends TypedArray<T>, T extends number>(): void {
  var source = instantiate<ArrayType>(3);
  source[0] = <T>1;
  source[1] = <T>2;
  source[2] = <T>3;
  var result = source.map(value => <T>(value * value));
  assert(result[0] == <T>1);
  assert(result[1] == <T>4);
  assert(result[2] == <T>9);
}

testArrayMap<Int8Array, i8>();
testArrayMap<Uint8Array, u8>();
testArrayMap<Uint8ClampedArray, u8>();
testArrayMap<Int16Array, i16>();
testArrayMap<Uint16Array, u16>();
testArrayMap<Int32Array, i32>();
testArrayMap<Uint32Array, u32>();
testArrayMap<Int64Array, i64>();
testArrayMap<Uint64Array, u64>();
testArrayMap<Float32Array, f32>();
testArrayMap<Float64Array, f64>();

function testArrayFilter<ArrayType extends TypedArray<T>, T extends number>(): void {
  var source = instantiate<ArrayType>(6);
  source[0] = <T>1;
  source[1] = <T>2;
  source[2] = <T>3;
  source[3] = <T>4;
  source[5] = <T>5;
  var result = source.filter(value => value > 2);
  assert(result.byteOffset == 0);
  assert(result.length == 3);
  assert(result[0] == <T>3);
  assert(result[1] == <T>4);
  assert(result[2] == <T>5);
}

testArrayFilter<Int8Array, i8>();
testArrayFilter<Uint8Array, u8>();
testArrayFilter<Uint8ClampedArray, u8>();
testArrayFilter<Int16Array, i16>();
testArrayFilter<Uint16Array, u16>();
testArrayFilter<Int32Array, i32>();
testArrayFilter<Uint32Array, u32>();
testArrayFilter<Int64Array, i64>();
testArrayFilter<Uint64Array, u64>();
testArrayFilter<Float32Array, f32>();
testArrayFilter<Float64Array, f64>();

function testArraySome<ArrayType extends TypedArray<T>, T extends number>(): void {
  var source = instantiate<ArrayType>(3);
  source[0] = <T>2;
  source[1] = <T>4;
  source[2] = <T>6;
  var result: bool = source.some(value => value == <T>2);
  assert(result);
  var failResult = source.some(value => value == <T>0);
  assert(!failResult);
}

testArraySome<Int8Array, i8>();
testArraySome<Uint8Array, u8>();
testArraySome<Uint8ClampedArray, u8>();
testArraySome<Int16Array, i16>();
testArraySome<Uint16Array, u16>();
testArraySome<Int32Array, i32>();
testArraySome<Uint32Array, u32>();
testArraySome<Int64Array, i64>();
testArraySome<Uint64Array, u64>();
testArraySome<Float32Array, f32>();
testArraySome<Float64Array, f64>();

function testArrayFindIndex<ArrayType extends TypedArray<T>, T extends number>(): void {
  var source = instantiate<ArrayType>(3);
  source[0] = <T>1;
  source[1] = <T>2;
  source[2] = <T>3;
  var result = source.findIndex(value => value == <T>2);
  assert(result == 1);
  var failResult = source.findIndex(value => value == <T>4);
  assert(failResult == -1);
}

testArrayFindIndex<Int8Array, i8>();
testArrayFindIndex<Uint8Array, u8>();
testArrayFindIndex<Uint8ClampedArray, u8>();
testArrayFindIndex<Int16Array, i16>();
testArrayFindIndex<Uint16Array, u16>();
testArrayFindIndex<Int32Array, i32>();
testArrayFindIndex<Uint32Array, u32>();
testArrayFindIndex<Int64Array, i64>();
testArrayFindIndex<Uint64Array, u64>();
testArrayFindIndex<Float32Array, f32>();
testArrayFindIndex<Float64Array, f64>();

function testArrayFindLastIndex<ArrayType extends TypedArray<T>, T extends number>(): void {
  var source = instantiate<ArrayType>(3);
  source[0] = <T>1;
  source[1] = <T>2;
  source[2] = <T>3;
  var result = source.findLastIndex(value => value == <T>2);
  assert(result == 1);
  var failResult = source.findLastIndex(value => value == <T>4);
  assert(failResult == -1);
}

testArrayFindLastIndex<Int8Array, i8>();
testArrayFindLastIndex<Uint8Array, u8>();
testArrayFindLastIndex<Uint8ClampedArray, u8>();
testArrayFindLastIndex<Int16Array, i16>();
testArrayFindLastIndex<Uint16Array, u16>();
testArrayFindLastIndex<Int32Array, i32>();
testArrayFindLastIndex<Uint32Array, u32>();
testArrayFindLastIndex<Int64Array, i64>();
testArrayFindLastIndex<Uint64Array, u64>();
testArrayFindLastIndex<Float32Array, f32>();
testArrayFindLastIndex<Float64Array, f64>();

function testArrayEvery<ArrayType extends TypedArray<T>, T extends number>(): void {
  var source = instantiate<ArrayType>(3);
  source[0] = <T>2;
  source[1] = <T>4;
  source[2] = <T>6;
  var result = source.every(value => value % <T>2 == <T>0);
  assert(result);
  var failResult = source.every(value => value == <T>2);
  assert(!failResult);
}

testArrayEvery<Int8Array, i8>();
testArrayEvery<Uint8Array, u8>();
testArrayEvery<Uint8ClampedArray, u8>();
testArrayEvery<Int16Array, i16>();
testArrayEvery<Uint16Array, u16>();
testArrayEvery<Int32Array, i32>();
testArrayEvery<Uint32Array, u32>();
testArrayEvery<Int64Array, i64>();
testArrayEvery<Uint64Array, u64>();
testArrayEvery<Float32Array, f32>();
testArrayEvery<Float64Array, f64>();

var forEachCallCount = 0;
var forEachSelf: usize;
const forEachValues: i32[] = [10, 12, 14];
function testArrayForEach<TArray extends TypedArray<T>, T extends number>(): void {
  forEachCallCount = 0;
  var array = instantiate<TArray>(3);
  forEachSelf = changetype<usize>(array);
  array[0] = <T>forEachValues[0];
  array[1] = <T>forEachValues[1];
  array[2] = <T>forEachValues[2];
  array.forEach((value: T, index: i32, self: TArray) => {
    var matchedValue = forEachValues[index];
    assert(value == <T>matchedValue);
    assert(index == forEachCallCount);
    assert(forEachSelf == changetype<usize>(self));
    forEachCallCount++;
  });
  assert(forEachCallCount == 3);
}

testArrayForEach<Int8Array, i8>();
testArrayForEach<Uint8Array, u8>();
testArrayForEach<Uint8ClampedArray, u8>();
testArrayForEach<Int16Array, i16>();
testArrayForEach<Uint16Array, u16>();
testArrayForEach<Int32Array, i32>();
testArrayForEach<Uint32Array, u32>();
testArrayForEach<Int64Array, i64>();
testArrayForEach<Uint64Array, u64>();
testArrayForEach<Float32Array, f32>();
testArrayForEach<Float64Array, f64>();

const testArrayReverseValues: i32[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];
function testArrayReverse<TArray extends TypedArray<T>, T extends number>(): void {
  var values = testArrayReverseValues;
  var length = values.length;
  var array = instantiate<TArray>(length);
  var arrayWithOffset = instantiate<TArray>(length);
  for (let i = 0; i < length; i++) {
    array[i] = <T>values[i];
    arrayWithOffset[i] = <T>values[i];
  }

  array.reverse();

  for (let i = 0; i < length; i++) {
    assert(array[i] == <T>values[length - 1 - i]);
  }

  var reversedSlice = arrayWithOffset.subarray(4, 8).reverse();

  assert(reversedSlice[0] == <T>8);
  assert(reversedSlice[1] == <T>7);
  assert(reversedSlice[2] == <T>6);
  assert(reversedSlice[3] == <T>5);
}

testArrayReverse<Int8Array, i8>();
testArrayReverse<Uint8Array, u8>();
testArrayReverse<Uint8ClampedArray, u8>();
testArrayReverse<Int16Array, i16>();
testArrayReverse<Uint16Array, u16>();
testArrayReverse<Int32Array, i32>();
testArrayReverse<Uint32Array, u32>();
testArrayReverse<Int64Array, i64>();
testArrayReverse<Uint64Array, u64>();
testArrayReverse<Float32Array, f32>();
testArrayReverse<Float64Array, f64>();

const testArrayIndexOfAndLastIndexOfValues: i32[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
function testArrayIndexOfAndLastIndexOf<TArray extends TypedArray<T>, T extends number>(): void {
  var values = testArrayIndexOfAndLastIndexOfValues;
  var length = values.length;
  var array  = instantiate<TArray>(length);

  for (let i = 0; i < length; i++) {
    array[i] = <T>values[i];
  }

  assert(array.indexOf(<T>0)  ==  0);
  assert(array.indexOf(<T>11) == -1);
  assert(array.indexOf(<T>-1) == -1);
  assert(array.indexOf(<T>3)  ==  3);
  assert(array.indexOf(<T>3, 2) ==  3);
  assert(array.indexOf(<T>3, 3) ==  3);
  assert(array.indexOf(<T>3, 4) == -1);
  assert(array.indexOf(<T>1, 10) == -1);
  assert(array.indexOf(<T>1, -100) == 1);

  assert(array.lastIndexOf(<T>0)  ==  0);
  assert(array.lastIndexOf(<T>11) == -1);
  assert(array.lastIndexOf(<T>-1) == -1);
  assert(array.lastIndexOf(<T>3)  ==  3);
  assert(array.lastIndexOf(<T>3, 4) ==  3);
  assert(array.lastIndexOf(<T>3, 3) ==  3);
  assert(array.lastIndexOf(<T>3, 2) == -1);
  assert(array.lastIndexOf(<T>1, 100) == 1);
  assert(array.lastIndexOf(<T>1, -10) == 1);
  assert(array.lastIndexOf(<T>1, -11) == -1);

  var sliced = array.subarray(4, 9);

  assert(sliced.indexOf(<T>3)  == -1);
  assert(sliced.indexOf(<T>4)  ==  4 - 4);
  assert(sliced.indexOf(<T>5)  ==  5 - 4);
  assert(sliced.indexOf(<T>9)  == -1);
  assert(sliced.indexOf(<T>10) == -1);
  assert(sliced.indexOf(<T>11) == -1);
  assert(sliced.indexOf(<T>5, 1) == 5 - 4);
  assert(sliced.indexOf(<T>5, 2) == -1);
}

testArrayIndexOfAndLastIndexOf<Int8Array, i8>();
testArrayIndexOfAndLastIndexOf<Uint8Array, u8>();
testArrayIndexOfAndLastIndexOf<Uint8ClampedArray, u8>();
testArrayIndexOfAndLastIndexOf<Int16Array, i16>();
testArrayIndexOfAndLastIndexOf<Uint16Array, u16>();
testArrayIndexOfAndLastIndexOf<Int32Array, i32>();
testArrayIndexOfAndLastIndexOf<Uint32Array, u32>();
testArrayIndexOfAndLastIndexOf<Int64Array, i64>();
testArrayIndexOfAndLastIndexOf<Uint64Array, u64>();
testArrayIndexOfAndLastIndexOf<Float32Array, f32>();
testArrayIndexOfAndLastIndexOf<Float64Array, f64>();

{
  // special tests
  let arrNaN64 = new Float64Array(1);
  arrNaN64[0] = NaN;

  assert(arrNaN64.indexOf(NaN) == -1);
  assert(arrNaN64.includes(NaN) == true);

  let arrNaN32 = new Float32Array(1);
  arrNaN32[0] = NaN;

  assert(arrNaN32.indexOf(NaN) == -1);
  assert(arrNaN32.includes(NaN) == true);
}

function testArrayJoinAndToString<TArray extends TypedArray<T>, T extends number>(): void {
  var array = instantiate<TArray>(5);
  array[0] = <T>1;
  array[1] = <T>2;
  array[2] = <T>3;
  array[3] = <T>4;
  array[4] = <T>5;

  if (isFloat<T>()) {
    assert(array.join() == "1.0,2.0,3.0,4.0,5.0");
    assert(array.toString() == "1.0,2.0,3.0,4.0,5.0");
  } else {
    assert(array.join() == "1,2,3,4,5");
    assert(array.toString() == "1,2,3,4,5");
  }
}

testArrayJoinAndToString<Int8Array, i8>();
testArrayJoinAndToString<Uint8Array, u8>();
testArrayJoinAndToString<Uint8ClampedArray, u8>();
testArrayJoinAndToString<Int16Array, i16>();
testArrayJoinAndToString<Uint16Array, u16>();
testArrayJoinAndToString<Int32Array, i32>();
testArrayJoinAndToString<Uint32Array, u32>();
testArrayJoinAndToString<Int64Array, i64>();
testArrayJoinAndToString<Uint64Array, u64>();
testArrayJoinAndToString<Float32Array, f32>();
testArrayJoinAndToString<Float64Array, f64>();

const testArrayWrapValues: i32[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
function testArrayWrap<TArray extends TypedArray<T>, T extends number>(): void {
  var values = testArrayWrapValues;
  var length = values.length;
  var array = instantiate<TArray>(length);

  for (let i = 0; i < length; i++) {
    array[i] = <T>values[i];
  }
  var buffer = array.buffer.slice(array.byteOffset, array.byteOffset + array.byteLength);
  var result: TArray;
  if (array instanceof Int8Array) {
    result = <TArray>Int8Array.wrap(buffer);
  } else if (array instanceof Uint8Array) {
    result = <TArray>Uint8Array.wrap(buffer);
  } else if (array instanceof Uint8ClampedArray) {
    result = <TArray>Uint8ClampedArray.wrap(buffer);
  } else if (array instanceof Int16Array) {
    result = <TArray>Int16Array.wrap(buffer);
  } else if (array instanceof Uint16Array) {
    result = <TArray>Uint16Array.wrap(buffer);
  } else if (array instanceof Int32Array) {
    result = <TArray>Int32Array.wrap(buffer);
  } else if (array instanceof Uint32Array) {
    result = <TArray>Uint32Array.wrap(buffer);
  } else if (array instanceof Int64Array) {
    result = <TArray>Int64Array.wrap(buffer);
  } else if (array instanceof Uint64Array) {
    result = <TArray>Uint64Array.wrap(buffer);
  } else if (array instanceof Float32Array) {
    result = <TArray>Float32Array.wrap(buffer);
  } else if (array instanceof Float64Array) {
    result = <TArray>Float64Array.wrap(buffer);
  } else {
    assert(false);
    return;
  }
  for (let i = 0; i < length; i++) {
    assert(array[i] == result[i]);
  }
}

{
  let buffer = new ArrayBuffer(0);
  let array = Uint8Array.wrap(buffer, 0);
  assert(array.length == 0);

  buffer = new ArrayBuffer(2);
  array = Uint8Array.wrap(buffer, 2);
  assert(array.length == 0);
}

testArrayWrap<Int8Array, i8>();
testArrayWrap<Uint8Array, u8>();
testArrayWrap<Uint8ClampedArray, u8>();
testArrayWrap<Int16Array, i16>();
testArrayWrap<Uint16Array, u16>();
testArrayWrap<Int32Array, i32>();
testArrayWrap<Uint32Array, u32>();
testArrayWrap<Int64Array, i64>();
testArrayWrap<Uint64Array, u64>();
testArrayWrap<Float32Array, f32>();
testArrayWrap<Float64Array, f64>();

function valuesEqual<T extends ArrayBufferView>(target: T, compare: valueof<T>[]): void {
  let len = target.length;
  assert(len == compare.length);
  for (let i = 0; i < len; i++) {
    let vala = unchecked(target[i]);
    let valb = unchecked(compare[i]);
    if (vala != valb) {
      trace(nameof<T>(), 3, i, <f64>vala, <f64>valb);
      assert(false);
    }
  }
}

let setSource1: i32[] = [1, 2, 3];
let setSource2: f32[] = [4, 5, 6];
let setSource3: f64[] = [Infinity, NaN, -Infinity];
let setSource7: i8[] = [-110, -111, -112];

function testTypedArraySet<T extends ArrayBufferView>(): void {
  let setSource4 = new Int64Array(3);
  setSource4[0] = 7;
  setSource4[1] = 8;
  setSource4[2] = 9;

  let setSource5 = new Uint8Array(4);
  setSource5[0] = 100;
  setSource5[1] = 101;
  setSource5[2] = 102;
  setSource5[3] = 103;

  let setSource6 = new Int16Array(3);
  setSource6[0] = 1000;
  setSource6[1] = 1001;
  setSource6[2] = 1002;

  let a = instantiate<T>(10);

  a.set(setSource1);
  valuesEqual<T>(a, [1, 2, 3, 0, 0, 0, 0, 0, 0, 0]);

  a.set(setSource2, 3);
  valuesEqual<T>(a, [1, 2, 3, 4, 5, 6, 0, 0, 0, 0]);

  a.set(setSource4, 6);
  valuesEqual<T>(a, [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]);

  if (isInteger<valueof<T>>()) {
    a.set(setSource3, 2);
    valuesEqual<T>(a, [1, 2, 0, 0, 0, 6, 7, 8, 9, 0]);
  }

  a.set(setSource5, 0);
  a.set(setSource6, 4);
  a.set(setSource7, 7);

  if (a instanceof Uint8ClampedArray) {
    valuesEqual<T>(a, [100, 101, 102, 103, 255, 255, 255, 0, 0, 0]);
  } else {
    // explicitly case the input values to valueof<T>
    valuesEqual<T>(a, [100, 101, 102, 103, <valueof<T>>1000, <valueof<T>>1001, <valueof<T>>1002, <valueof<T>>-110, <valueof<T>>-111, <valueof<T>>-112]);
  }

}

testTypedArraySet<Int8Array>();
testTypedArraySet<Uint8Array>();
testTypedArraySet<Uint8ClampedArray>();
testTypedArraySet<Int16Array>();
testTypedArraySet<Uint16Array>();
testTypedArraySet<Int32Array>();
testTypedArraySet<Uint32Array>();
testTypedArraySet<Int64Array>();
testTypedArraySet<Uint64Array>();
testTypedArraySet<Float32Array>();
testTypedArraySet<Float64Array>();

{
  let targetClampedArray = new Uint8ClampedArray(10);
  let a = new Float32Array(3);
  a[0] = 400;
  a[1] = NaN;
  a[2] = Infinity;

  let b = new Int64Array(4);
  b[0] = -10;
  b[1] = 100;
  b[2] = 10;
  b[3] = 300;

  let c = new Int32Array(2);
  c[0] = 300;
  c[1] = -1;

  targetClampedArray.set(a, 1);
  targetClampedArray.set(b, 4);
  targetClampedArray.set(c, 8);
  valuesEqual<Uint8ClampedArray>(targetClampedArray, [0, 255, 0, 0, 0, 100, 10, 255, 255, 0]);

  let d = new Uint32Array(4);
  d[0] = 1;
  d[1] = 300;
  d[2] = 100;
  d[3] = 0xFFFFFFFF;

  let e = new Int16Array(4);
  e[0] = -10;
  e[1] = 100;
  e[2] = 10;
  e[3] = 300;

  targetClampedArray.set(d, 0);
  targetClampedArray.set(e, 5);
  valuesEqual<Uint8ClampedArray>(targetClampedArray, [1, 255, 100, 255, 0, 0, 100, 10, 255, 0]);
}

function testArraySort<ArrayType extends TypedArray<T>, T extends number>(): void {
  var source: ArrayType = instantiate<ArrayType>(3);
  source[2] = <T>1;
  source[1] = <T>2;
  source[0] = <T>3;

  let result = source.sort();
  assert(result[0] == <T>1);
  assert(result[1] == <T>2);
  assert(result[2] == <T>3);
  result.sort((a, b) => i32(b > a) - i32(b < a));
  assert(result[0] == <T>3);
  assert(result[1] == <T>2);
  assert(result[2] == <T>1);
}

testArraySort<Int8Array, i8>();
testArraySort<Uint8Array, u8>();
testArraySort<Uint8ClampedArray, u8>();
testArraySort<Int16Array, i16>();
testArraySort<Uint16Array, u16>();
testArraySort<Int32Array, i32>();
testArraySort<Uint32Array, u32>();
testArraySort<Int64Array, i64>();
testArraySort<Uint64Array, u64>();
testArraySort<Float32Array, f32>();
testArraySort<Float64Array, f64>();

__stack_pointer = __heap_base;
__collect();

'''
'''--- tests/compiler/std/uri.json ---
{
  "asc_flags": [
  ],
  "asc_rtrace": true
}

'''
'''--- tests/compiler/std/uri.ts ---

// encodeURIComponent

assert(encodeURIComponent("") == "");
assert(encodeURIComponent("a") == "a");
assert(encodeURIComponent("a1") == "a1");
assert(encodeURIComponent("ab_") == "ab_");
assert(
  encodeURIComponent("ABCDXYZafgklmnwyz0123456789-_.!~*'()") ==
  "ABCDXYZafgklmnwyz0123456789-_.!~*'()"
);
assert(encodeURIComponent("\0") == "%00");
assert(encodeURIComponent("+") == "%2B");
assert(encodeURIComponent("#0=") !== "%230%3D");
assert(encodeURIComponent(" 123 ") !== "%20123%20");
assert(encodeURIComponent("?+") == "%3F%2B");
assert(encodeURIComponent("-?1.-") == "-%3F1.-");
assert(encodeURIComponent("ðŸ‡­ðŸ‡ºðŸŽ") == "%F0%9F%87%AD%F0%9F%87%BA%F0%9F%8D%8E");
assert(encodeURIComponent("ì•ˆë…•í•˜ì„¸ìš”") == "%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94");
assert(encodeURIComponent("\x7E\x7F\x80") == "~%7F%C2%80");
assert(encodeURIComponent("\uD800\uDFFF") == "%F0%90%8F%BF");
assert(encodeURIComponent('\uDA7B\uDC01-\uDA50\uDC02') == "%F2%AE%B0%81-%F2%A4%80%82");
// line terminators
assert(encodeURIComponent("\n\t\v\f\r") == "%0A%09%0B%0C%0D");
// From test262/test/built-ins/encodeURIComponent/S15.1.3.4_A4_T1.js
assert(encodeURIComponent(";/?:@&=+$,") == "%3B%2F%3F%3A%40%26%3D%2B%24%2C");
// From test262/test/built-ins/encodeURIComponent/S15.1.3.4_A4_T4.js
assert(
  encodeURIComponent("http://en.wikipedia.org/wiki/UTF-8#Description") ==
  "http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FUTF-8%23Description"
);

// assert(encodeURIComponent("\uD800"));    // malformed URI sequence (ok)
// assert(encodeURIComponent("\uDFFF"));    // malformed URI sequence (ok)

// encodeURI

assert(encodeURI("") == "");
assert(encodeURI("a") == "a");
assert(encodeURI(";,/?:@&=+$#") == ";,/?:@&=+$#");
assert(
  encodeURI("ABCDXYZafgklmnwyz0123456789-_.!~*'()") ==
  "ABCDXYZafgklmnwyz0123456789-_.!~*'()"
);
assert(encodeURI(" ") == "%20");
assert(encodeURI("\x7E\x7F\x80") == "~%7F%C2%80");
assert(encodeURI("\uD800\uDFFF") == "%F0%90%8F%BF");
// line terminators
assert(encodeURI("\n\t\v\f\r") == "%0A%09%0B%0C%0D");
assert(
  encodeURI("http://en.wikipedia.org/wiki/UTF-8#Description") ==
  "http://en.wikipedia.org/wiki/UTF-8#Description"
);

// assert(encodeURI("\uD800"));         // malformed URI sequence (ok)
// assert(encodeURI("\uDFFF"));         // malformed URI sequence (ok)

// decodeURIComponent

assert(decodeURIComponent("") == "");
assert(decodeURIComponent("a") == "a");
assert(decodeURIComponent("%26") == "&");
assert(decodeURIComponent('%5E') == "^");
assert(decodeURIComponent("\uD800") == "\uD800");
assert(decodeURIComponent("\uD800\uDFFF") == "\uD800\uDFFF");
assert(decodeURIComponent("%3b%2f%3f%3a%40%3d%2b%24%2c%23") == ";/?:@=+$,#");
assert(decodeURIComponent("%3B%2F%3F%3A%40%3D%2B%24%2C%23") == ";/?:@=+$,#");
assert(
  decodeURIComponent("http:%2F%2Fen.wikipedia.org/wiki/UTF-8%23Description") ==
  "http://en.wikipedia.org/wiki/UTF-8#Description"
);

assert(decodeURIComponent("%F0%9F%87%AD%F0%9F%87%BA%F0%9F%8D%8E") == "ðŸ‡­ðŸ‡ºðŸŽ");

// assert(decodeURIComponent("%1"));        // malformed URI sequence (ok)
// assert(decodeURIComponent("%1/"));       // malformed URI sequence (ok)
// assert(decodeURIComponent("%1`"));       // malformed URI sequence (ok)
// assert(decodeURIComponent("%1g"));       // malformed URI sequence (ok)
// assert(decodeURIComponent("%\uFFFF"));   // malformed URI sequence (ok)

// decodeURI

assert(decodeURI("") == "");
assert(decodeURI("a") == "a");
assert(decodeURI("%26") == "%26");
assert(decodeURI("%DF%80") == "ß€");
assert(decodeURI("%C2%BF") == "Â¿");
assert(decodeURI("\uD800") == "\uD800");
assert(decodeURI("\uD800\uDFFF") == "\uD800\uDFFF");
assert(decodeURI("%3b%2f%3f%3a%40%3d%2b%24%2c%23") == "%3b%2f%3f%3a%40%3d%2b%24%2c%23");
assert(decodeURI("%F0%9F%87%AD%F0%9F%87%BA%F0%9F%8D%8E") == "ðŸ‡­ðŸ‡ºðŸŽ");
assert(decodeURI("\xf7\xb8W\xef\x0f\xf4V") == "Ã·Â¸WÃ¯Ã´V");
assert(decodeURI("\xF4\xB8\xEF") == "Ã´Â¸Ã¯");
assert(
  decodeURI("http:%2F%2Fen.wikipedia.org/wiki/UTF-8%23Description") ==
  "http:%2F%2Fen.wikipedia.org/wiki/UTF-8%23Description"
);

// assert(decodeURI("%\x10"));        // malformed URI sequence (ok)
// assert(decodeURI("%\x10\x10"));    // malformed URI sequence (ok)
// assert(decodeURI("%C2%0x80"));     // malformed URI sequence (ok)
// assert(decodeURI("%80%BF"));       // malformed URI sequence (ok)

__stack_pointer = __heap_base;
__collect();

'''
'''--- tests/compiler/super-inline.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/super-inline.ts ---
class Foo {
  @inline
  a(): i32 { return 1; }
}

class Bar extends Foo {
  a(): i32 { return super.a(); } // no AS228
}

var foo = new Foo();
foo.a(); // AS228

var bar = new Bar();
bar.a();

'''
'''--- tests/compiler/switch.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/switch.ts ---
function doSwitch(n: i32): i32 {
  switch (n) {
    case 1: return 1;
    case 0:
    default: return 0;
    case 2:
    case 3: return 23;
  }
}
assert(doSwitch(0) == 0);
assert(doSwitch(1) == 1);
assert(doSwitch(2) == 23);
assert(doSwitch(3) == 23);
assert(doSwitch(4) == 0);

function doSwitchDefaultFirst(n: i32): i32 {
  switch (n) {
    default: return 0;
    case 1: return 1;
    case 2:
    case 3: return 23;
  }
}
assert(doSwitch(0) == 0);
assert(doSwitch(1) == 1);
assert(doSwitch(2) == 23);
assert(doSwitch(3) == 23);
assert(doSwitch(4) == 0);

function doSwitchDefaultOmitted(n: i32): i32 {
  switch (n) {
    case 1: return 1;
    case 2:
    case 3: return 23;
  }
  return 0;
}
assert(doSwitchDefaultOmitted(0) == 0);
assert(doSwitchDefaultOmitted(1) == 1);
assert(doSwitchDefaultOmitted(2) == 23);
assert(doSwitchDefaultOmitted(3) == 23);
assert(doSwitchDefaultOmitted(4) == 0);

function doSwitchBreakCase(n: i32): i32 {
  switch (n) {
    case 1: break;
    default: return 2;
  }
  return 1;
}
assert(doSwitchBreakCase(0) == 2);
assert(doSwitchBreakCase(1) == 1);
assert(doSwitchBreakCase(2) == 2);

function doSwitchBreakDefault(n: i32): i32 {
  switch (n) {
    case 1: return 1;
    default: break;
  }
  return 2;
}
assert(doSwitchBreakDefault(0) == 2);
assert(doSwitchBreakDefault(1) == 1);
assert(doSwitchBreakDefault(2) == 2);

function doSwitchFallThroughCase(n: i32): i32 {
  switch (n) {
    default: return 2;
    case 1:
  }
  return 1;
}
assert(doSwitchFallThroughCase(0) == 2);
assert(doSwitchFallThroughCase(1) == 1);
assert(doSwitchFallThroughCase(2) == 2);

function doSwitchFallThroughDefault(n: i32): i32 {
  switch (n) {
    case 1: return 1;
    default:
  }
  return 2;
}
assert(doSwitchFallThroughDefault(0) == 2);
assert(doSwitchFallThroughDefault(1) == 1);
assert(doSwitchFallThroughDefault(2) == 2);

function doSwitchEmpty(n: i32): i32 {
  switch (n) {} // (drop n)
  return 2;
}
assert(doSwitchEmpty(0) == 2);
assert(doSwitchEmpty(1) == 2);
assert(doSwitchEmpty(2) == 2);

'''
'''--- tests/compiler/tablebase.json ---
{
  "asc_flags": [
    "--tableBase 32"
  ]
}

'''
'''--- tests/compiler/tablebase.ts ---
function foo(): void {}

const staticFunction = foo;

assert(ASC_TABLE_BASE == 32);
assert(staticFunction.index == 32);

'''
'''--- tests/compiler/templateliteral.json ---
{
  "asc_flags": [
    "--explicitStart"
  ]
}

'''
'''--- tests/compiler/templateliteral.ts ---
function test_string(): void {
  var a = "a";
  var b = "b";
  assert(`${a}` == "a");
  assert(`${a}${b}` == "ab");
  assert(`(A=${a}, B=${b})` == "(A=a, B=b)");
}
test_string();

function test_integer(): void {
  var a = 1;
  var b = 2;
  assert(`${a}` == "1");
  assert(`${a}${b}` == "12");
  assert(`(A=${a}, B=${b})` == "(A=1, B=2)");
}
test_integer();

function test_float(): void {
  var a = 1.0;
  var b = 2.0;
  assert(`${a}` == "1.0");
  assert(`${a}${b}` == "1.02.0");
  assert(`(A=${a}, B=${b})` == "(A=1.0, B=2.0)");
}
test_float();

function test_fast_paths_string(): void {
  var a = 2;
  var b = "b";
  assert(`${a}` == "2");
  assert(`${b}` == "b");
  assert(`pref${a}` == "pref2");
  assert(`pref${b}` == "prefb");
  assert(`${a}suff` == "2suff");
  assert(`${b}suff` == "bsuff");
  assert(`${a}${b}` == "2b");
}
test_fast_paths_string();

class Ref {
  constructor(public value: i32) {}
  toString(): string {
    return "ref#" + this.value.toString();
  }
}

function test_ref(): void {
  var a = new Ref(1);
  var b = new Ref(2);
  assert(`${a}` == "ref#1");
  assert(`${a}${b}` == "ref#1ref#2");
  assert(`(A=${a}, B=${b})` == "(A=ref#1, B=ref#2)");
}
test_ref();

function tag(parts: TemplateStringsArray, a: i32): string {
  var raw = parts.raw;
  assert(parts.length == 2);
  assert(raw.length == 2);
  assert(parts[0] == "a");
  assert(raw[0] == "a");
  assert(parts[1] == "b");
  assert(raw[1] == "b");
  assert(a == 1);
  return parts[0] + a.toString() + parts[1];
}

namespace ns {
  export function tag(parts: string[] /* ! */, a: i32, b: i32): string {
    assert(!(parts instanceof TemplateStringsArray)); // optimized away
    assert(parts.length == 3);
    assert(parts[0] == "r");
    assert(parts[1] == "d");
    assert(parts[2] == "");
    assert(a == 2);
    assert(b == 2);
    return parts[0] + a.toString() + parts[1] + b.toString();
  }
}

function test_tag(): void {
  assert(tag`a${1}b` == "a1b");
  assert(ns.tag`r${2}d${2}` == "r2d2");
}
// test_tag(); // TODO: Requires ReadonlyArray to be safe

function raw(parts: TemplateStringsArray): string {
  return parts.raw.join("");
}

function test_raw(): void {
  assert(raw`` == "");
  assert(raw`\u` == "\\u");
  assert(raw`\u1` == "\\u1");
  assert(raw`\u1000` == "\\u1000");
}
// test_raw(); // TODO: Requires ReadonlyArray to be safe

'''
'''--- tests/compiler/ternary.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/ternary.ts ---
0 ? unreachable() : 1;
1 ? 1 : unreachable();
(0 ? unreachable() : 1) ? 1 : unreachable();

var a: i32;

a = 0 ? unreachable() : 1;
a = 1 ? 1 : unreachable();
a = (0 ? unreachable() : 1) ? 1 : unreachable();

export function test(x: i32, y: i32, z: i32): i32 {
  return x ? y : z;
}

'''
'''--- tests/compiler/throw.json ---
{
  "asc_flags": [
  ],
  "asc_rtrace": true
}

'''
'''--- tests/compiler/throw.ts ---
export function doThrow(): void {
  var a = "123";
  throw new Error("doThrow");
}

function doThrowIf(cond: bool): void {
  var a = "123";
  if (cond) {
    let b = "234";
    throw new Error("doThrowIf");
  }
  var c = "345";
}
doThrowIf(false);

function doThrowIfLoop(max: i32): void {
  var a = "123";
  var i = 0;
  while (++i < max) {
    let b = "234";
    if (i > max) { // never
      let c = "345";
      throw new Error("doThrowIfLoop");
    }
    let d = "456";
  }
  var e = "567";
}
doThrowIfLoop(10);

__collect();

'''
'''--- tests/compiler/tsconfig.json ---
{
  "extends": "../../std/assembly.json",
  "compilerOptions": {
    "module": "ES6"
  },
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- tests/compiler/typealias.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/typealias.ts ---
export type alias = i32;
// TODO: Without 'export' this yields 'ERROR TS2395: Individual declarations in merged declaration...'
// which differs from TypeScript, but we don't have individual element and type spaces per file and this
// just merges.

export function alias(a: alias): alias {
  return a;
}

'''
'''--- tests/compiler/typeof.json ---
{
  "asc_flags": [
    "--explicitStart"
  ]
}

'''
'''--- tests/compiler/typeof.ts ---
assert(typeof 1 === "number"); // static string === static string precomputes

// non-precomputed

class SomeClass {
  static someStaticMethod(): void {}
  someInstanceMethod(): void {}
}
enum SomeEnum {}
namespace SomeNamespace { const a: i32 = 1; }
function SomeFunction(): void {}

assert(typeof SomeClass == "object"); // ClassPrototype
assert(typeof SomeEnum == "object"); // Enum
assert(typeof SomeNamespace == "object"); // Namespace (TS complains if empty)
assert(typeof SomeFunction == "function"); // FunctionPrototype
assert(typeof SomeClass.someStaticMethod == "function");

assert(typeof true == "boolean");
assert(typeof null == "object");
assert(typeof 1 == "number");
assert(typeof 1.0 == "number");
assert(typeof <i64>1 == "number");
assert(typeof "1" == "string");

var b = true;
assert(typeof b == "boolean");
var i = 1;
assert(typeof i == "number");
var f = <f32>1.0;
assert(typeof f == "number");
var I = <i64>1;
assert(typeof I == "number");
var F = 1.0;
assert(typeof F == "number");
var s = "1";
assert(typeof s == "string");
var fn = (): void => {};
assert(typeof fn == "function");
var c = new SomeClass();
assert(typeof c == "object");
assert(typeof c.someInstanceMethod == "function");

// would normally error but doesn't with typeof:

assert(typeof d == "undefined");
assert(typeof c.ba == "undefined");
assert(typeof c[0] == "undefined");

'''
'''--- tests/compiler/unary.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/unary.ts ---
+1;
-1;
!1;
~1;
+1.25;
-1.25;
!1.25;

var i: i32 = 0;

+i;
-i;
!i;
~i;
++i;
--i;
i++;
i--;

i = +1;
i = -1;
i = !1;
i = ~1;
i = +i;
i = -i;
i = !i;
i = ~i;
i = ++i;
i = --i;
i = i++;
i = i--;

var I: i64 = 0;

+I;
-I;
!I;
~I;
++I;
--I;
I++;
I--;

I = +1;
I = -1;
I = !1;
I = ~1;
I = +I;
I = -I;
I = !I;
I = ~I;
I = ++I;
I = --I;
I = I++;
I = I--;

var f: f32 = 0;

+f;
-f;
!f;
++f;
--f;
f++;
f--;

f = +1.25;
f = -1.25;
i = !1.25;
f = +f;
f = -f;
i = !f;
f = ++f;
f = --f;
f = f++;
f = f--;

var F: f64 = 0;

+F;
-F;
!F;
++F;
--F;
F++;
F--;

F = +1.25;
F = -1.25;
I = !1.25;
F = +F;
F = -F;
I = !F;
F = ++F;
F = --F;
F = F++;
F = F--;

'''
'''--- tests/compiler/unify-local-flags.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/unify-local-flags.ts ---
// Test that locals depending on each other don't break recompilation of loops
// when local flags must be unified. In the test cases below, x depends on i's
// wrapped state, so triggers recompilation twice, in this order:
//
// * i WRAPPED, x WRAPPED
//   -> recompile with i not WRAPPED due to ++i
// * i not WRAPPED, x WRAPPED
//   -> recompile with x not WRAPPED due to x=i
// * i not WRAPPED, x not WRAPPED
//   -> success

export function testFor(): void {
  let x: u8 = 0;
  for (let i: u8 = 0; i < 255; ++i) {
    x = i;
  }
}

export function testWhile(): void {
  let x: u8 = 0;
  let i: u8 = 0;
  while (i < 255) {
    x = i;
    ++i;
  }
}

export function testDo(): void {
  let x: u8 = 0;
  let i: u8 = 0;
  do {
    x = i;
  } while (++i < 255);
}

'''
'''--- tests/compiler/unknown-bool-ident.json ---
{
  "asc_flags": [
  ],
  "stderr": [
    "TS2304: Cannot find name 'unknown_var'.",
    "EOF"
  ]
}

'''
'''--- tests/compiler/unknown-bool-ident.ts ---
if (1 <= unknown_var) {}
ERROR("EOF");
'''
'''--- tests/compiler/unsafe.json ---
{
  "asc_flags": [
    "--noUnsafe"
  ],
  "stderr": [
    "AS212: Decorator '@unsafe' is not valid here.",
    "AS101: Operation is unsafe.", "f1();",
    "AS101: Operation is unsafe.", "f2();",
    "AS101: Operation is unsafe.", "= new Foo();",
    "AS101: Operation is unsafe.", "super();",
    "AS101: Operation is unsafe.", "= instantiate<Foo>()",
    "AS101: Operation is unsafe.", "Foo.bar();",
    "AS101: Operation is unsafe.", "foo.bar();",
    "AS101: Operation is unsafe.", " = Foo.foo;",
    "AS101: Operation is unsafe.", "Foo.foo = 1;",
    "AS101: Operation is unsafe.", "Foo.foo++;",
    "AS101: Operation is unsafe.", "Foo.foo += 1;",
    "AS101: Operation is unsafe.", " = foo.foo;",
    "AS101: Operation is unsafe.", "foo.foo = 1;",
    "AS101: Operation is unsafe.", "foo.foo++;",
    "AS101: Operation is unsafe.", "foo.foo += 1;",
    "AS101: Operation is unsafe.", "= Foo.baz;",
    "AS101: Operation is unsafe.", "Foo.baz = 1;",
    "AS101: Operation is unsafe.", "Foo.baz++;",
    "AS101: Operation is unsafe.", "Foo.baz += 1;",
    "AS101: Operation is unsafe.", "= foo.baz;",
    "AS101: Operation is unsafe.", "foo.baz = 1;",
    "AS101: Operation is unsafe.", "foo.baz++;",
    "AS101: Operation is unsafe.", "foo.baz += 1;",
    "EOF"
  ]
}

'''
'''--- tests/compiler/unsafe.ts ---
// Global

@unsafe var g = 0; // not valid here

// Function

@unsafe function f1(): void {}
f1();

// Inline function

@unsafe @inline function f2(): void {}
f2();

// === Class members ===

class Foo {
  @unsafe constructor() {}
  @unsafe static foo: i32 = 0;
  @unsafe static bar(): void {}
  @unsafe foo: i32 = 0;
  @unsafe bar(): void {}
  @unsafe static get baz(): i32 { return 0; }
  @unsafe static set baz(i: i32) { }
  @unsafe get baz(): i32 { return 0; }
  @unsafe set baz(i: i32) { }
}

// Constructor

var foo = new Foo();

// Constructor via super

class Bar extends Foo {
  constructor() { super(); }
}

var bar = new Bar();

// Constructor via instantiate

var foo3 = instantiate<Foo>();

// Static method

Foo.bar();

// Instance method

foo.bar();

// Static field

var n1 = Foo.foo;
Foo.foo = 1;
Foo.foo++;
Foo.foo += 1;

// Instance field

var n2 = foo.foo;
foo.foo = 1;
foo.foo++;
foo.foo += 1;

// Static property

var n3 = Foo.baz;
Foo.baz = 1;
Foo.baz++;
Foo.baz += 1;

// Instance property

var n4 = foo.baz;
foo.baz = 1;
foo.baz++;
foo.baz += 1;

ERROR("EOF"); // mark end and ensure fail

'''
'''--- tests/compiler/variable-access-in-initializer.json ---
{
  "asc_flags": [
  ],
  "stderr": [
    "TS2448: Variable 'variable-access-in-initializer/a' used before its declaration.",
    "TS2448: Variable 'variable-access-in-initializer/test~b' used before its declaration.",
    "EOF"
  ]
}

'''
'''--- tests/compiler/variable-access-in-initializer.ts ---
var a = (a = 4, 3); // TS2448

function test(): void {
  let b = (b = 4, 3); // TS2448
}
test();

ERROR("EOF");

'''
'''--- tests/compiler/void.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/void.ts ---
void 1;

function anInt(): i32 {
  return 2;
}

void anInt();

var u8Val1: u8 = 1;
var u8Val2: u8 = 255;

void (u8Val1 + u8Val2); // can remain unwrapped

'''
'''--- tests/compiler/wasi/abort.js ---
var memory;
var failed;

exports.preInstantiate = function(imports, exports) {
  imports["wasi_snapshot_preview1"] = {
    fd_write: function(fd, iov, iov_len, nptr) {
      if (fd != 2) failed = "unexpected fd: " + fd;
      const messagePtr = new Uint32Array(memory.buffer)[ iov >>> 2     ];
      const messageLen = new Uint32Array(memory.buffer)[(iov >>> 2) + 1];
      const message = Array.from(new Uint8Array(memory.buffer, messagePtr, messageLen)).map(c => String.fromCharCode(c)).join("");
      if (message != "abort: the message in wasi/abort.ts(4:3)\n") failed = "unexpected message: " + message;
    },
    proc_exit: function(code) {
      if (code != 255) failed = "unexpected exit code: " + code;
    }
  };
  if (failed) throw Error(failed);
};

exports.postInstantiate = function(instance) {
  const exports = instance.exports;
  memory = exports.memory;
  var thrown = false;
  try {
    exports.test();
  } catch (e) {
    thrown = true;
  }
  if (!thrown) failed = "unexpected missing throw";
  if (failed) throw Error(failed);
};

'''
'''--- tests/compiler/wasi/abort.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/wasi/abort.ts ---
import "wasi";

export function test(): void {
  assert(false, "the message");
}

'''
'''--- tests/compiler/wasi/seed.js ---
var memory;
var failed;

exports.preInstantiate = function(imports, exports) {
  imports["wasi_snapshot_preview1"] = {
    fd_write: function(fd, iov, iov_len, nptr) {
      if (fd != 2) failed = "unexpected fd: " + fd;
      const messagePtr = new Uint32Array(memory.buffer)[ iov >>> 2     ];
      const messageLen = new Uint32Array(memory.buffer)[(iov >>> 2) + 1];
      const message = Array.from(new Uint8Array(memory.buffer, messagePtr, messageLen)).map(c => String.fromCharCode(c)).join("");
      (fd == 1 ? process.stdout : process.stderr).write(message);
    },
    proc_exit: function(code) {
      console.log("exit: " + code);
    },
    random_get: function(buf, len) {
      new Uint8Array(memory.buffer, buf, len).set(require("crypto").randomBytes(len));
    }
  };
};

exports.postInstantiate = function(instance) {
  const exports = instance.exports;
  memory = exports.memory;
  console.log("Math.random = " + exports.test());
  if (failed) throw Error(failed);
};

'''
'''--- tests/compiler/wasi/seed.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/wasi/seed.ts ---
import "wasi";

export function test(): f64 {
  return Math.random();
}

'''
'''--- tests/compiler/wasi/snapshot_preview1.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/wasi/snapshot_preview1.ts ---
import {
  dirent,
  event,
  event_fd_readwrite,
  fdstat,
  filestat,
  iovec,
  subscription,
  subscription_clock,
  subscription_fd_readwrite,
  signal,
  prestat,
  prestat_dir
} from "bindings/wasi";

import { Target } from "shared/target";

assert(offsetof<dirent>("next") == 0);
assert(offsetof<dirent>("ino") == 8);
assert(offsetof<dirent>("namlen") == 16);
assert(offsetof<dirent>("type") == 20);
assert(offsetof<dirent>() == 24);

assert(offsetof<event_fd_readwrite>("userdata") == 0);
assert(offsetof<event_fd_readwrite>("error") == 8);
assert(offsetof<event_fd_readwrite>("type") == 10);
assert(offsetof<event_fd_readwrite>("nbytes") == 16);
assert(offsetof<event_fd_readwrite>("flags") == 24);
assert(offsetof<event_fd_readwrite>() == 32);

assert(offsetof<event>() == 32);

assert(offsetof<fdstat>("filetype") == 0);
assert(offsetof<fdstat>("flags") == 2);
assert(offsetof<fdstat>("rights_base") == 8);
assert(offsetof<fdstat>("rights_inheriting") == 16);
assert(offsetof<fdstat>() == 24);

assert(offsetof<filestat>("dev") == 0);
assert(offsetof<filestat>("ino") == 8);
assert(offsetof<filestat>("filetype") == 16);
assert(offsetof<filestat>("nlink") == 24);
assert(offsetof<filestat>("size") == 32);
assert(offsetof<filestat>("atim") == 40);
assert(offsetof<filestat>("mtim") == 48);
assert(offsetof<filestat>("ctim") == 56);
assert(offsetof<filestat>() == 64);

assert(offsetof<iovec>("buf") == 0);
if (ASC_TARGET == Target.WASM32) {
  assert(offsetof<iovec>("buf_len") == 4);
  assert(offsetof<iovec>() == 8);
} else if (ASC_TARGET == Target.WASM64) {
  assert(offsetof<iovec>("buf_len") == 8);
  assert(offsetof<iovec>() == 16);
} else {
  assert(false);
}

assert(offsetof<subscription_clock>("userdata") == 0);
assert(offsetof<subscription_clock>("type") == 8);
assert(offsetof<subscription_clock>("clock_id") == 16);
assert(offsetof<subscription_clock>("timeout") == 24);
assert(offsetof<subscription_clock>("precision") == 32);
assert(offsetof<subscription_clock>("flags") == 40);
assert(offsetof<subscription_clock>() == 48);

assert(offsetof<subscription_fd_readwrite>("userdata") == 0);
assert(offsetof<subscription_fd_readwrite>("type") == 8);
assert(offsetof<subscription_fd_readwrite>("file_descriptor") == 16);
assert(offsetof<subscription_fd_readwrite>() == 48);

assert(offsetof<subscription>() == 48);

assert(offsetof<prestat_dir>("type") == 0);
if (ASC_TARGET == Target.WASM32) {
  assert(offsetof<prestat_dir>("name_len") == 4);
  assert(offsetof<prestat_dir>() == 8);
  assert(offsetof<prestat>() == 8);
} else if (ASC_TARGET == Target.WASM64) {
  assert(offsetof<prestat_dir>("name_len") == 8);
  assert(offsetof<prestat_dir>() == 16);
  assert(offsetof<prestat>() == 16);
} else {
  assert(false);
}

// check assignability of mimicked typed enums
var sig: signal = signal.HUP;
sig = signal.KILL;

'''
'''--- tests/compiler/wasi/trace.js ---
var memory;
var failed;

exports.preInstantiate = function(imports, exports) {
  imports["wasi_snapshot_preview1"] = {
    fd_write: function(fd, iov, iov_len, nptr) {
      if (fd != 2) failed = "unexpected fd: " + fd;
      const messagePtr = new Uint32Array(memory.buffer)[ iov >>> 2     ];
      const messageLen = new Uint32Array(memory.buffer)[(iov >>> 2) + 1];
      const message = Array.from(new Uint8Array(memory.buffer, messagePtr, messageLen)).map(c => String.fromCharCode(c)).join("");
      process.stderr.write(message);
    },
    proc_exit: function(code) {
      console.log("exit: " + code);
    }
  };
};

exports.postInstantiate = function(instance) {
  const exports = instance.exports;
  memory = exports.memory;
  if (failed) throw Error(failed);
};

'''
'''--- tests/compiler/wasi/trace.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/compiler/wasi/trace.ts ---
import "wasi";

trace("the message");
trace("the message", 1, 1.5);
trace("the message", 5, -2.00001, 3, NaN, Infinity, -Infinity);

'''
'''--- tests/compiler/while.json ---
{
  "asc_flags": [
  ],
  "asc_rtrace": true
}

'''
'''--- tests/compiler/while.ts ---
var ran: bool;

function testSimple(): void {
  var i = 10;
  var j = 0;
  while (i) {
    i--;
    j++;
  }
  assert(i == 0);
  assert(j == 10);
  ran = true;
}
ran = false;
testSimple();
assert(ran);

function testNested(): void {
  var i = 10;
  var j = 0;
  var k = 0;
  while (i) {
    i--;
    j++;
    while (i) {
      i--;
      k++;
    }
    assert(i == 0);
    assert(k == 9);
  }
  assert(i == 0);
  assert(j == 1);
  assert(k == 9);
  ran = true;
}
ran = false;
testNested();
assert(ran);

function testEmpty(): void {
  var i = 1;
  var j = 0;
  while (i-- && ++j);
  assert(i == -1);
  assert(j == 1);
  ran = true;
}
ran = false;
testEmpty();
assert(ran);

function testAlwaysTrue(): void {
  var i = 0;
  while (true) {
    if (++i == 10) break;
  }
  assert(i == 10);
  ran = true;
}
ran = false;
testAlwaysTrue();
assert(ran);

function testAlwaysTrueNeverBreaks(): i32 {
  var i = 0;
  while (true) {
    if (++i == 10) return i;
  }
  // no return required
}
assert(testAlwaysTrueNeverBreaks() == 10);

function testAlwaysFalse(): void {
  var i = 0;
  while (false) {
    ++i;
    assert(false);
  }
  assert(i == 0);
  ran = true;
}
ran = false;
testAlwaysFalse();
assert(ran);

function testAlwaysBreaks(): void {
  var i = 0;
  while (++i) {
    break;
  }
  assert(i == 1);
  ran = true;
}
ran = false;
testAlwaysBreaks();
assert(ran);

function testAlwaysReturns(): void {
  var i = 0;
  while (++i) {
    ran = true;
    return;
  }
  assert(false);
}
ran = false;
testAlwaysReturns();
assert(ran);

function testContinue(): void {
  var i = 10;
  while (i) {
    --i;
    continue;
  }
  assert(i == 0);
  ran = true;
}
ran = false;
testContinue();
assert(ran);

function testNestedContinue(): void {
  var i = 10;
  var j = 10;
  while (i) {
    while (j) {
      --j;
      continue;
    }
    --i;
    continue;
  }
  assert(i == 0);
  assert(j == 0);
  ran = true;
}
ran = false;
testNestedContinue();
assert(ran);

class Ref {}
function testRef(): void {
  var i = 0;
  var ref: Ref | null = new Ref();
  while (ref) {
    if (++i == 10) ref = null;
    else ref = new Ref();
  }
  assert(i == 10);
  assert(!ref);
  ran = true;
}
ran = false;
testRef();
assert(ran);

function getRef(): Ref {
  return new Ref();
}
function testRefAutorelease(): void {
  var i = 0;
  var ref: Ref | null = new Ref();
  while (getRef()) { // must not leak
    if (++i == 10) {
      ref = null;
      break;
    }
  }
  assert(i == 10);
  assert(!ref);
  ran = true;
}
ran = false;
testRefAutorelease();
assert(ran);

function testIfImplicitContinueThen(): void {
  var i = 0;
  while (true) {
    i++;
    if (i < 1) {
      // continue
    } else {
      break;
    }
  }
  ran = true;
}
ran = false;
testIfImplicitContinueThen();
assert(ran);

function testIfImplicitContinueElse(): void {
  var i = 0;
  while (true) {
    i++;
    if (i >= 1) {
      break;
    } else {
      // continue
    }
  }
  ran = true;
}
ran = false;
testIfImplicitContinueElse();
assert(ran);

__collect();

'''
'''--- tests/decompiler.js ---
var binaryen = global.binaryen = require("../lib/binaryen");

require("ts-node").register({ project: require("path").join(__dirname, "..", "src", "tsconfig.json") });
require("../src/glue/js");

var mod = new binaryen.Module();
var ftype = mod.addFunctionType("i", binaryen.i32, [ ]);
var fn = mod.addFunction("main", ftype, [],
  mod.block(null, [
    mod.return(
      mod.i32.add(
        mod.i32.const(1),
        mod.i32.const(2)
      )
    )
  ])
);

mod.validate();
mod.emitText();

var Decompiler = require("../src/decompiler").Decompiler;
var decompiler = new Decompiler();
decompiler.decompileFunction(fn);
console.log(decompiler.finish());

'''
'''--- tests/extension/package.json ---
{
  "scripts": {
    "test": "npm run asbuild",
    "asbuild": "node ../../bin/asc assembly/index.as --extension .as --noEmit"
  }
}

'''
'''--- tests/features.json ---
{
  "mutable-globals": {
  },
  "nontrapping-f2i": {
    "asc_flags": [
      "--enable nontrapping-f2i"
    ]
  },
  "simd": {
    "asc_flags": [
      "--enable simd"
    ],
    "v8_flags": [
      "--experimental-wasm-simd"
    ]
  },
  "threads": {
    "asc_flags": [
      "--enable threads"
    ],
    "v8_flags": [
      "--experimental-wasm-threads"
    ]
  },
  "reference-types": {
    "asc_flags": [
      "--enable reference-types"
    ],
    "v8_flags": [
      "--experimental-wasm-reftypes"
    ]
  },
  "gc": {
    "asc_flags": [
      "--enable reference-types",
      "--enable gc"
    ],
    "v8_flags": [
      "--experimental-wasm-reftypes",
      "--experimental-wasm-gc"
    ]
  },
  "bigint-integration": {
    "v8_flags": [
      "--experimental-wasm-bigint"
    ]
  },
  "exception-handling": {
    "asc_flags": [
      "--enable exception-handling"
    ],
    "v8_flags": [
      "--experimental-wasm-eh"
    ]
  }
}

'''
'''--- tests/packages/package.json ---
{
  "scripts": {
    "test": "npm run a && npm run b && npm run c && npm run d && npm run e && npm run f && npm run g && npm run as && npm run h",
    "a": "cd ./packages/a && node ../../../../bin/asc assembly/index.ts --noEmit",
    "as": "cd ./packages/as && node ../../../../bin/asc as/index.ts --noEmit",
    "b": "cd ./packages/b && node ../../../../bin/asc assembly/index.ts --noEmit && node ../../../../bin/asc assembly/index.ts --noEmit --listFiles",
    "c": "cd ./packages/c && node ../../../../bin/asc assembly/index.ts --noEmit",
    "d": "cd ./packages/d && node ../../../../bin/asc assembly/index.ts --path packages --noEmit --traceResolution",
    "e": "cd ./packages/d/packages/e && node ../../../../../../bin/asc assembly/index.ts --noEmit",
    "f": "cd ./packages/d/packages/e/packages/f && node ../../../../../../../../bin/asc assembly/index.ts --noEmit",
    "g": "cd ./packages/g && node test.js",
    "h": "cd ./packages/h && node ../../../../bin/asc assembly/index.ts --noEmit --traceResolution"
  },
  "author": "Willem Wyndham",
  "license": "Apache-2.0"
}

'''
'''--- tests/packages/packages/a/assembly/a.ts ---
export function A(): string {
  return "A";
}

'''
'''--- tests/packages/packages/a/assembly/index.ts ---
export * from "./a";

'''
'''--- tests/packages/packages/as/as/as.ts ---
export function AS(str: string): string {
  return str + "S";
}

'''
'''--- tests/packages/packages/as/as/index.ts ---
export * from "./as";

'''
'''--- tests/packages/packages/as/package.json ---
{
  "ascMain": "as/index.ts"
}

'''
'''--- tests/packages/packages/b/assembly/b.ts ---
import { A } from "a";

export function B(): string {
  return "B";
}

export function AB(): string {
  return A() + B();
}

'''
'''--- tests/packages/packages/b/assembly/index.ts ---
export * from "./b";

'''
'''--- tests/packages/packages/b/node_modules/a/assembly/a.ts ---
export function A(): string {
  return "A";
}

'''
'''--- tests/packages/packages/b/node_modules/a/assembly/index.ts ---
export * from "./a";

'''
'''--- tests/packages/packages/c/assembly/c.ts ---
import { B, AB } from "b";

export function C(): string {
  return "C";
}

export function BC(): string {
  return B() + C();
}

export function ABC(): string {
  return AB() + C();
}

'''
'''--- tests/packages/packages/c/assembly/index.ts ---
export * from "./c";

'''
'''--- tests/packages/packages/c/node_modules/b/assembly/b.ts ---
import { A } from "a";

export function B(): string {
  return "B";
}

export function AB(): string {
  return A() + B();
}

'''
'''--- tests/packages/packages/c/node_modules/b/assembly/index.ts ---
export * from "./b";

'''
'''--- tests/packages/packages/c/node_modules/b/node_modules/a/assembly/a.ts ---
export function A(): string {
  return "A";
}

'''
'''--- tests/packages/packages/c/node_modules/b/node_modules/a/assembly/index.ts ---
export * from "./a";

'''
'''--- tests/packages/packages/d/assembly/d.ts ---
import { C, BC, ABC } from "c";
import { E } from "e";
import { AS } from "as";

export function D(): string {
  return "D";
}

export function CD(): string {
  return C() + D();
}

export function BCD(): string {
  return BC() + D();
}

export function ABCD(): string {
  return ABC() + D();
}

export function ABCDE(): string {
  return ABCD() + E();
}

export function ABCDS(): string {
  return AS(ABCD());
}

'''
'''--- tests/packages/packages/d/assembly/index.ts ---
export * from "./d";

'''
'''--- tests/packages/packages/d/node_modules/as/notassembly/as.ts ---
export function AS(str: string): string {
  return str + "S";
}

'''
'''--- tests/packages/packages/d/node_modules/as/notassembly/index.ts ---
export * from "./as";

'''
'''--- tests/packages/packages/d/node_modules/as/package.json ---
{
  "ascMain": "./notassembly/index.ts"
}

'''
'''--- tests/packages/packages/d/node_modules/c/assembly/c.ts ---
import { B, AB } from "b";

export function C(): string {
  return "C";
}

export function BC(): string {
  return B() + C();
}

export function ABC(): string {
  return AB() + C();
}

'''
'''--- tests/packages/packages/d/node_modules/c/assembly/index.ts ---
export * from "./c";

'''
'''--- tests/packages/packages/d/node_modules/c/node_modules/b/assembly/b.ts ---
import { A } from "a";

export function B(): string {
  return "B";
}

export function AB(): string {
  return A() + B();
}

'''
'''--- tests/packages/packages/d/node_modules/c/node_modules/b/assembly/index.ts ---
export * from "./b";

'''
'''--- tests/packages/packages/d/node_modules/c/node_modules/b/node_modules/a/assembly/a.ts ---
export function A(): string {
  return "A";
}

'''
'''--- tests/packages/packages/d/node_modules/c/node_modules/b/node_modules/a/assembly/index.ts ---
export * from "./a";

'''
'''--- tests/packages/packages/d/packages/e/assembly/e.ts ---
import { C } from "c";

export function E(): string {
  return "E";
}

export function EC(): string {
  return C() + E();
}

'''
'''--- tests/packages/packages/d/packages/e/assembly/index.ts ---
export * from "./e";

'''
'''--- tests/packages/packages/d/packages/e/packages/f/assembly/f.ts ---
export function F(): string {
  return "F";
}

'''
'''--- tests/packages/packages/d/packages/e/packages/f/assembly/index.ts ---
export * from "./f";

'''
'''--- tests/packages/packages/g/assembly/g.ts ---
import { ABC } from "c";
import { A } from "a";

export function AAG(): string {
  return A() + A() + "G";
}

export function ABCG(): string {
  return ABC() + "G";
}

'''
'''--- tests/packages/packages/g/assembly/index.ts ---
export * from "./g";

'''
'''--- tests/packages/packages/g/node_modules/c/assembly/c.ts ---
import { B, AB } from "b";

export function C(): string {
  return "C";
}

export function BC(): string {
  return B() + C();
}

export function ABC(): string {
  return AB() + C();
}

'''
'''--- tests/packages/packages/g/node_modules/c/assembly/index.ts ---
export * from "./c";

'''
'''--- tests/packages/packages/g/node_modules/c/node_modules/b/assembly/b.ts ---
import { A } from "a";

export function B(): string {
  return "B";
}

export function AB(): string {
  return A() + B();
}

'''
'''--- tests/packages/packages/g/node_modules/c/node_modules/b/assembly/index.ts ---
export * from "./b";

'''
'''--- tests/packages/packages/g/node_modules/c/node_modules/b/node_modules/a/assembly/a.ts ---
export function A(): string {
  return "A";
}

'''
'''--- tests/packages/packages/g/node_modules/c/node_modules/b/node_modules/a/assembly/index.ts ---
export * from "./a";

'''
'''--- tests/packages/packages/g/test.js ---
#!/usr/bin/env node
const asc = require("../../../../cli/asc");

const stderr = asc.createMemoryStream();
asc.main([
  "assembly/index.ts",
  "--noEmit",
  "--traceResolution"
], { stderr }, err => {
  if (stderr.toString().includes("File '~lib/a.ts' not found.")) {
    process.exit(0);
  }
  console.error("Failed!\n" + err);
  process.exit(1);
});

'''
'''--- tests/packages/packages/h/assembly/index.ts ---
import { h } from "@foo/bar";

export function getH(): i32 {
  return h;
}

'''
'''--- tests/packages/packages/h/node_modules/@foo/bar/assembly/index.ts ---
import { h2 } from "@bar/baz";

export const h = h2;

'''
'''--- tests/packages/packages/h/node_modules/@foo/bar/node_modules/@bar/baz/assembly/index.ts ---
export const h2 = 3;

'''
'''--- tests/packages/tsconfig.json ---
{
  "extends": "../../std/assembly.json",
  "include": ["**/*/assembly/**/*.ts"]
}

'''
'''--- tests/parser.js ---
const fs = require("fs");
const path = require("path");
const os = require("os");
const glob = require("glob");
const colorsUtil = require("../cli/util/colors");
const optionsUtil = require("../cli/util/options");
const diff = require("./util/diff");

const config = {
  "create": {
    "description": [
      "Recreates the fixture for the specified test(s)",
      "or all the fixtures if no specific test is given."
    ],
    "type": "b"
  },
  "help": {
    "description": "Prints this message and exits.",
    "type": "b",
    "alias": "h"
  }
};
const opts = optionsUtil.parse(process.argv.slice(2), config);
const args = opts.options;
const argv = opts.arguments;

if (args.help) {
  console.log([
    colorsUtil.white("SYNTAX"),
    "  " + colorsUtil.cyan("npm run test:parser --") + " [test1, test2 ...] [options]",
    "",
    colorsUtil.white("OPTIONS"),
    optionsUtil.help(config)
  ].join(os.EOL) + os.EOL);
  process.exit(0);
}

const basedir = path.join(__dirname, "parser");

// Get a list of all tests
var tests = glob.sync("**/!(_*).ts", { cwd: basedir });

// Run specific tests only if arguments are provided
if (argv.length) {
  tests = tests.filter(filename => argv.indexOf(filename.replace(/\.ts$/, "")) >= 0);
  if (!tests.length) {
    console.error("No matching tests: " + argv.join(" "));
    process.exit(1);
  }
}

require("ts-node").register({ project: path.join(__dirname, "..", "src", "tsconfig.json") });
require("../src/glue/js");

const { Program, Options } = require("../src");
const ASTBuilder = require("../src/extra/ast").ASTBuilder;

var failures = 0;

tests.forEach(filename => {
  if (filename.charAt(0) == "_" || filename.endsWith(".fixture.ts")) return;

  console.log(colorsUtil.white("Testing parser/" + filename));

  var failed = false;
  var program = new Program(new Options());
  var parser = program.parser;
  var sourceText = fs.readFileSync(basedir + "/" + filename, { encoding: "utf8" }).replace(/\r?\n/g, "\n");
  parser.parseFile(sourceText, filename, true);
  var serializedSourceText = ASTBuilder.build(program.sources[0]);
  var actual = serializedSourceText + parser.diagnostics.map(diagnostic => "// " + diagnostic +"\n").join("");
  var fixture = filename + ".fixture.ts";

  if (args.create) {
    fs.writeFileSync(basedir + "/" + fixture, actual, { encoding: "utf8" });
    console.log("Created\n");
  } else {
    var expected = fs.readFileSync(basedir + "/" + fixture, { encoding: "utf8" }).replace(/\r\n/g, "\n");
    var diffs = diff("parser/" + fixture, expected, actual);
    if (diffs !== null) {
      failed = true;
      console.log(diffs);
      console.log(colorsUtil.red("diff ERROR"));
    } else {
      console.log(colorsUtil.green("diff OK"));
    }
  }

  console.log();
  if (failed)
    ++failures;
});

if (failures) {
  process.exitCode = 1;
  console.log(colorsUtil.red("ERROR: ") + failures + " parser tests failed");
} else
  console.log("[ " + colorsUtil.white("SUCCESS") + " ]");

'''
'''--- tests/parser/also-identifier.ts ---
class Foo {
  as: i32;
  declare: i32;
  delete: i32;
  from: i32;
  for: i32;
  get: i32;
  instanceof: i32;
  is: i32;
  keyof: i32;
  module: i32;
  namespace: i32;
  null: i32;
  readonly: i32;
  set: i32;
  type: i32;
  void: i32;
}

var as: i32;
var constructor: i32;
var declare: i32;
var from: i32;
var get: i32;
var is: i32;
var keyof: i32;
var module: i32;
var namespace: i32;
var readonly: i32;
var set: i32;

// -- illegal --
// var delete: i32;
// var for: i32;
// var instanceof: i32;
// var null: i32;
// var type: i32;
// var void: i32;

'''
'''--- tests/parser/also-identifier.ts.fixture.ts ---
class Foo {
  as: i32;
  declare: i32;
  delete: i32;
  from: i32;
  for: i32;
  get: i32;
  instanceof: i32;
  is: i32;
  keyof: i32;
  module: i32;
  namespace: i32;
  null: i32;
  readonly: i32;
  set: i32;
  type: i32;
  void: i32;
}
var as: i32;
var constructor: i32;
var declare: i32;
var from: i32;
var get: i32;
var is: i32;
var keyof: i32;
var module: i32;
var namespace: i32;
var readonly: i32;
var set: i32;

'''
'''--- tests/parser/arrow-functions.ts ---
// array function
(x): i32 => x;
(x: i32) => x;
(x?) => x;
(x?, y?) => x;
(x?: i32) => x;
x => x;

// not an array function
(b ? x : y);
(b ? f : g)();

'''
'''--- tests/parser/arrow-functions.ts.fixture.ts ---
(x): i32 => x;
(x: i32) => x;
(x?) => x;
(x?, y?) => x;
(x?: i32) => x;
x => x;
(b ? x : y);
(b ? f : g)();

'''
'''--- tests/parser/call-function-return.ts ---
a = fn()(1, 2);

'''
'''--- tests/parser/call-function-return.ts.fixture.ts ---
a = fn()(1, 2);

'''
'''--- tests/parser/calls.ts ---
// Identifier
id();

// Call
id()();

// ElementAccess
arr[0]();
arr[0](1);

// PropertyAccess
obj.a();
obj.a(1);

// Everything
id(a)[0](b)(c).a(d)(e)[1](f)(g);

'''
'''--- tests/parser/calls.ts.fixture.ts ---
id();
id()();
arr[0]();
arr[0](1);
obj.a();
obj.a(1);
id(a)[0](b)(c).a(d)(e)[1](f)(g);

'''
'''--- tests/parser/class-abstract.ts ---
class Foo {
  abstract bar(): void;
}

'''
'''--- tests/parser/class-abstract.ts.fixture.ts ---
class Foo {
  bar(): void;
}
// ERROR 1042: "'abstract' modifier cannot be used here." in class-abstract.ts(2,3+8)
// ERROR 2391: "Function implementation is missing or not immediately following the declaration." in class-abstract.ts(2,19+4)

'''
'''--- tests/parser/class-expression.ts ---
var a = class {
  foo(): void {}
  bar: i32;
};
var b = class Foo {};

'''
'''--- tests/parser/class-expression.ts.fixture.ts ---
var a = class {
  foo(): void {}
  bar: i32;
};
var b = class Foo {};

'''
'''--- tests/parser/class.ts ---
export class Valid<T> {
  constructor() {}
  instanceFunction(): void {}
  static staticFunction(): void {}
  get instanceGetter(): i32 {}
  static set staticSetter(v: i32) {}
  instanceField: i32;
  static staticField: i32;
  static void: i32;
  void: i32 = Valid.void;
}
export class Invalid<T> {

  // 1092: Type parameters cannot appear on a constructor declaration
  constructor<T>() {}

  // 1110: Type expected.
  instanceFunction() {}

  // 1094: An accessor cannot have type parameters.
  // 1054: A 'get' accessor cannot have parameters.
  // 1110: Type expected.
  get instanceGetter<T>(a: i32) {}

  // 1094: An accessor cannot have type parameters.
  // 1049: A 'set' accessor must have exactly one parameter.
  // 1095: A 'set' accessor cannot have a return type annotation.
  set instanceSetter<T>(): i32 {}
}

'''
'''--- tests/parser/class.ts.fixture.ts ---
export class Valid<T> {
  constructor() {}
  instanceFunction(): void {}
  static staticFunction(): void {}
  get instanceGetter(): i32 {}
  static set staticSetter(v: i32) {}
  instanceField: i32;
  static staticField: i32;
  static void: i32;
  void: i32 = Valid.void;
}
export class Invalid<T> {
  constructor<T>() {}
  instanceFunction() {}
  get instanceGetter<T>(a: i32) {}
  set instanceSetter<T>() {}
}
// ERROR 1092: "Type parameters cannot appear on a constructor declaration." in class.ts(15,14+3)
// ERROR 1110: "Type expected." in class.ts(18,21+0)
// ERROR 1094: "An accessor cannot have type parameters." in class.ts(23,21+3)
// ERROR 1054: "A 'get' accessor cannot have parameters." in class.ts(23,7+14)
// ERROR 1110: "Type expected." in class.ts(23,32+0)
// ERROR 1094: "An accessor cannot have type parameters." in class.ts(28,21+3)
// ERROR 1049: "A 'set' accessor must have exactly one parameter." in class.ts(28,7+14)
// ERROR 1095: "A 'set' accessor cannot have a return type annotation." in class.ts(28,26+1)

'''
'''--- tests/parser/constructor.ts ---
class MyClass {
  constructor() {}
  constructor(a: i32) {}
  constructor(a: i32, b: i32) {}
}

class MyClassImplicit {
  constructor(public a: i32, private readonly b: i32 = 2, c: i32 = 3) {}
}

'''
'''--- tests/parser/constructor.ts.fixture.ts ---
class MyClass {
  constructor() {}
  constructor(a: i32) {}
  constructor(a: i32, b: i32) {}
}
class MyClassImplicit {
  constructor(public a: i32, private readonly b: i32 = 2, c: i32 = 3) {}
}

'''
'''--- tests/parser/continue-on-error.ts ---
// 1003: Identifier expected.
var;
// 1005: '(' expected.
while for let; a from "./other";
do {
  ;
} while (false);

'''
'''--- tests/parser/continue-on-error.ts.fixture.ts ---
do {
  ;
} while (false);
// ERROR 1003: "Identifier expected." in continue-on-error.ts(2,1+3)
// ERROR 1005: "'(' expected." in continue-on-error.ts(4,1+5)

'''
'''--- tests/parser/decorators.ts ---
@global
@operator("+")
@operator.binary("-")
@operator.prefix("~")
@operator.postfix("++")
@unmanaged
@final
@inline
@external("a", "b")
@custom
function a(): void {}

'''
'''--- tests/parser/decorators.ts.fixture.ts ---
@global
@operator("+")
@operator.binary("-")
@operator.prefix("~")
@operator.postfix("++")
@unmanaged
@final
@inline
@external("a", "b")
@custom
function a(): void {}

'''
'''--- tests/parser/definite-assignment-assertion.ts ---
class C {
  x!: i32;
  x!: i32 = 0; // invalid
  static x!: i32; // invlaid
}
function f(): void {
  let x!: i32;
  let x!: i32 = 0; // invalid
}

'''
'''--- tests/parser/definite-assignment-assertion.ts.fixture.ts ---
class C {
  x!: i32;
  x!: i32 = 0;
  static x!: i32;
}
function f(): void {
  let x!: i32;
  let x!: i32 = 0;
}
// ERROR 1255: "A definite assignment assertion '!' is not permitted in this context." in definite-assignment-assertion.ts(3,3+11)
// ERROR 1255: "A definite assignment assertion '!' is not permitted in this context." in definite-assignment-assertion.ts(4,3+14)
// ERROR 1255: "A definite assignment assertion '!' is not permitted in this context." in definite-assignment-assertion.ts(8,7+11)

'''
'''--- tests/parser/do.ts ---
do {
  ;
} while (a != b);
do b;
while (a);

'''
'''--- tests/parser/do.ts.fixture.ts ---
do {
  ;
} while (a != b);
do b;
while (a);

'''
'''--- tests/parser/empty.ts ---

'''
'''--- tests/parser/empty.ts.fixture.ts ---

'''
'''--- tests/parser/enum.ts ---
export const enum A {
  B = 1,
  C,
  D = 3
}
enum E {
  F,
  G = 1 + 2,
  H = 3 * 4
}

'''
'''--- tests/parser/enum.ts.fixture.ts ---
export const enum A {
  B = 1,
  C,
  D = 3
}
enum E {
  F,
  G = 1 + 2,
  H = 3 * 4
}

'''
'''--- tests/parser/export-default.ts ---
export default function theFunction(): void {}
export default class TheClass {}
// not so ts-y:
export default enum TheEnum {}
export default namespace theNamespace {}
export default something;

'''
'''--- tests/parser/export-default.ts.fixture.ts ---
export default function theFunction(): void {}
export default class TheClass {}
export default enum TheEnum {}
export default namespace theNamespace {}
export {
  something as default
};

'''
'''--- tests/parser/for.ts ---
for (var i: i32 = 0; i < 10; ++i) {
  ;
}
for (i = 0; i < 10; ++i) {
  ;
}
for (;;) {
  ;
}

'''
'''--- tests/parser/for.ts.fixture.ts ---
for (var i: i32 = 0; i < 10; ++i) {
  ;
}
for (i = 0; i < 10; ++i) {
  ;
}
for (;;) {
  ;
}

'''
'''--- tests/parser/forof.ts ---
for (foo of bar) {
  ;
}
for (var foo of bar) {
  ;
}
for (let foo of bar) {
  ;
}
for (const foo of bar) {
  ;
}
for (foo of bar) ;
for (var foo of bar) ;
for (let foo of bar) ;
for (const foo of bar) ;

'''
'''--- tests/parser/forof.ts.fixture.ts ---
for (foo of bar) {
  ;
}
for (var foo of bar) {
  ;
}
for (let foo of bar) {
  ;
}
for (const foo of bar) {
  ;
}
for (foo of bar) ;
for (var foo of bar) ;
for (let foo of bar) ;
for (const foo of bar) ;

'''
'''--- tests/parser/function-expression.ts ---
var a = function(): void {
  ;
};
var b = function someName(): void {
  ;
};
var c = function(a: i32, b: i32): i32 {
  ;
};
var d = (): void => {
  ;
};
var e = (a: i32, b: i32): i32 => {
  ;
};
var f = (a: i32): i32 => a;

'''
'''--- tests/parser/function-expression.ts.fixture.ts ---
var a = function(): void {
  ;
};
var b = function someName(): void {
  ;
};
var c = function(a: i32, b: i32): i32 {
  ;
};
var d = (): void => {
  ;
};
var e = (a: i32, b: i32): i32 => {
  ;
};
var f = (a: i32): i32 => a;

'''
'''--- tests/parser/function-type.ts ---
var a: () => void;
var b: (a: i32, b: i32) => void;
var c: (a: i32, b: i32) => (a: i32, b: i32) => void;
var d: (a: i32, a: i32) => void; // NOTE: duplicates in type signatures doesn't in TypeScript
var e: (a) => void; // TS1110

'''
'''--- tests/parser/function-type.ts.fixture.ts ---
var a: () => void;
var b: (a: i32, b: i32) => void;
var c: (a: i32, b: i32) => (a: i32, b: i32) => void;
var d: (a: i32, a: i32) => void;
var e: (a) => void;
// ERROR 1110: "Type expected." in function-type.ts(5,10+0)

'''
'''--- tests/parser/function.ts ---
function simple(): void {}
function typeparams<T, V extends T>(a: V | null = null): void {}
@decorator()
function withdecorator(): void {}
function withthis(this: i32): i32 { return this; }
function withthisp(this: i32, a: f32, b: f64): i32 { return this; }

'''
'''--- tests/parser/function.ts.fixture.ts ---
function simple(): void {}
function typeparams<T, V extends T>(a: V | null = null): void {}
@decorator()
function withdecorator(): void {}
function withthis(this: i32): i32 {
  return this;
}
function withthisp(this: i32, a: f32, b: f64): i32 {
  return this;
}

'''
'''--- tests/parser/import.ts ---
import {
  A
} from "./other";
import {
  A,
  B,
  C
} from "./other";
import {
  A as B,
  C,
  D as E,
  F
} from "./other";
import * as A from "./other";
import "./other";

'''
'''--- tests/parser/import.ts.fixture.ts ---
import {
  A
} from "./other";
import {
  A,
  B,
  C
} from "./other";
import {
  A as B,
  C,
  D as E,
  F
} from "./other";
import * as A from "./other";
import "./other";

'''
'''--- tests/parser/index-declaration.ts ---
class A {
  [key: i32]: f64;
}

'''
'''--- tests/parser/index-declaration.ts.fixture.ts ---
class A {
  [key: i32]: f64;
}

'''
'''--- tests/parser/interface-errors.ts ---
abstract interface Foo { // ERROR 1242: "'abstract' modifier can only appear on a class, method, or property declaration
}

abstract
interface Foo { // no error
}

interface Foo implements Bar { // ERROR 1176: "Interface declaration cannot have 'implements' clause."
}

interface Foo extends Bar { // no error
}

interface Foo {
  abstract a: i32; // ERROR 1042: "'abstract' modifier cannot be used here." (TS1070)
  private b: i32; // ERROR 1042: "'private' modifier cannot be used here." (TS1070)
  protected c: i32; // ERROR 1042: "'protected' modifier cannot be used here."
  public c: i32; // ERROR 1042: "'public' modifier cannot be used here."
  static d: i32; // ERROR 1042: "'static' modifier cannot be used here."
  constructor(): i32; // ERROR 229: "'constructor' keyword cannot be used here." (TS: none?)
  constructor(); // ^ + ERROR 1110: "Type expected."
}

'''
'''--- tests/parser/interface-errors.ts.fixture.ts ---
abstract;
interface Foo {
}
abstract;
interface Foo {
}
interface Foo {
}
interface Foo extends Bar {
}
interface Foo {
  a: i32;
  b: i32;
  c: i32;
  c: i32;
  d: i32;
  constructor(): i32;
  constructor();
}
// ERROR 1242: "'abstract' modifier can only appear on a class, method, or property declaration." in interface-errors.ts(1,1+8)
// ERROR 1176: "Interface declaration cannot have 'implements' clause." in interface-errors.ts(8,15+10)
// ERROR 1042: "'abstract' modifier cannot be used here." in interface-errors.ts(15,3+8)
// ERROR 1042: "'private' modifier cannot be used here." in interface-errors.ts(16,3+7)
// ERROR 1042: "'protected' modifier cannot be used here." in interface-errors.ts(17,3+9)
// ERROR 1042: "'public' modifier cannot be used here." in interface-errors.ts(18,3+6)
// ERROR 1042: "'static' modifier cannot be used here." in interface-errors.ts(19,3+6)
// ERROR 230: "'constructor' keyword cannot be used here." in interface-errors.ts(20,3+11)
// ERROR 230: "'constructor' keyword cannot be used here." in interface-errors.ts(21,3+11)
// ERROR 1110: "Type expected." in interface-errors.ts(21,16+0)

'''
'''--- tests/parser/interface.ts ---
interface Foo {
  bar(): void;
  baz: i32;
  readonly baz2: f64;
}

interface Boo {
  bar(): void,
  baz: i32,
  readonly baz2: f64,
}

'''
'''--- tests/parser/interface.ts.fixture.ts ---
interface Foo {
  bar(): void;
  baz: i32;
  readonly baz2: f64;
}
interface Boo {
  bar(): void;
  baz: i32;
  readonly baz2: f64;
}

'''
'''--- tests/parser/literals.ts ---
0;
1;
2;
3;
4;
5;
6;
7;
8;
9;
2147483647;
0x0;
0x1;
0x2;
0x3;
0x4;
0x5;
0x6;
0x7;
0x8;
0x9;
0xA;
0xB;
0xC;
0xD;
0xE;
0xF;
0x7FFFFFFF;
0xa;
0xb;
0xc;
0xd;
0xe;
0xf;
0x7fffffff;
0o0;
0o1;
0o2;
0o3;
0o4;
0o5;
0o6;
0o7;
0o17777777777;
0b0;
0b1;
0b1111111111111111111111111111111;
0.0;
0.123;
.0;
.123;
12.34;
1e1;
1.0e1;
1e+1;
1.0e+1;
1e-1;
1.0e-1;
"";
"\"";
"123";
"1\"23";
"1\"2\\3";
"\0\n\\n\r";
``;
`123`;
`123${a}`;
`123${a}456`;
`123${a}456${b}`;
`123${a}456${b}789`;
`${a}`;
`${a}456`;
`${a}456${b}`;
`${a}456${b}789`;
`${a}${b}`;
`${a}456${b}`;
`123${a}${b}`;
`${a}${b}789`;
`\``;
`\`${a}\`${b}\``;
tag`123`;
ns.tag`123`;
tag`\unicode\xGG\u\x`; // see https://tc39.es/proposal-template-literal-revision/

// invalid
1..;
3u8;
4b;
5-;
6=;
7_;
1.a;
2.0b;
`\unicode\xGG\u\x`;

// technically invalid, but not handled by AS yet, TS1005: ';' expected
3 4;
5 c;
6.7 d;
a b;

'''
'''--- tests/parser/literals.ts.fixture.ts ---
0;
1;
2;
3;
4;
5;
6;
7;
8;
9;
2147483647;
0;
1;
2;
3;
4;
5;
6;
7;
8;
9;
10;
11;
12;
13;
14;
15;
2147483647;
10;
11;
12;
13;
14;
15;
2147483647;
0;
1;
2;
3;
4;
5;
6;
7;
2147483647;
0;
1;
2147483647;
0;
0.123;
0;
0.123;
12.34;
10;
10;
10;
10;
0.1;
0.1;
"";
"\"";
"123";
"1\"23";
"1\"2\\3";
"\0\n\\n\r";
``;
`123`;
`123${a}`;
`123${a}456`;
`123${a}456${b}`;
`123${a}456${b}789`;
`${a}`;
`${a}456`;
`${a}456${b}`;
`${a}456${b}789`;
`${a}${b}`;
`${a}456${b}`;
`123${a}${b}`;
`${a}${b}789`;
`\``;
`\`${a}\`${b}\``;
tag`123`;
ns.tag`123`;
tag`\\unicode\\xGG\\u\\x`;
4;
b;
7;
1;
a;
2;
b;
`icodeGx`;
3;
4;
5;
c;
6.7;
d;
a;
b;
// ERROR 1109: "Expression expected." in literals.ts(86,4+1)
// ERROR 1351: "An identifier or keyword cannot immediately follow a numeric literal." in literals.ts(87,2+0)
// ERROR 1351: "An identifier or keyword cannot immediately follow a numeric literal." in literals.ts(88,2+0)
// ERROR 1109: "Expression expected." in literals.ts(89,3+1)
// ERROR 6188: "Numeric separators are not allowed here." in literals.ts(91,2+0)
// ERROR 1351: "An identifier or keyword cannot immediately follow a numeric literal." in literals.ts(92,3+0)
// ERROR 1351: "An identifier or keyword cannot immediately follow a numeric literal." in literals.ts(93,4+0)
// ERROR 1125: "Hexadecimal digit expected." in literals.ts(94,4+1)
// ERROR 1125: "Hexadecimal digit expected." in literals.ts(94,12+1)
// ERROR 1125: "Hexadecimal digit expected." in literals.ts(94,16+1)

'''
'''--- tests/parser/namespace.ts ---
declare namespace A {
  namespace B {
    export namespace C {
      var aVar: i32;
      const aConst: i32;
      const aConstInvalid: i32 = 0; // 1039: Initializers are not allowed in ambient contexts.
      function aFunc(): void;
      function aFuncInvalid(): void {} // 1183: An implementation cannot be declared in ambient contexts.
      enum AnEnum {}
      class AClass {}
    }
    namespace D {
      var aVar: i32;
    }
  }
}

'''
'''--- tests/parser/namespace.ts.fixture.ts ---
declare namespace A {
  namespace B {
    export namespace C {
      var aVar: i32;
      const aConst: i32;
      const aConstInvalid: i32 = 0;
      function aFunc(): void;
      function aFuncInvalid(): void {}
      enum AnEnum {}
      class AClass {}
    }
    namespace D {
      var aVar: i32;
    }
  }
}
// ERROR 1039: "Initializers are not allowed in ambient contexts." in namespace.ts(6,32+1)
// ERROR 1183: "An implementation cannot be declared in ambient contexts." in namespace.ts(8,37+1)

'''
'''--- tests/parser/nonNullAssertion.ts ---
foo!;
foo!!;
foo!.bar;
foo.bar!;
foo![0];
foo[0]!;
foo![0]!.bar!;
foo!![0]!!.bar!!;

'''
'''--- tests/parser/nonNullAssertion.ts.fixture.ts ---
foo!;
foo!!;
foo!.bar;
foo.bar!;
foo![0];
foo[0]!;
foo![0]!.bar!;
foo!![0]!!.bar!!;

'''
'''--- tests/parser/numeric-separators.ts ---
11_11_11;
0b01_01_01;
0o12_12_12;
0x23_23_23;
1_000_000.1234_1234;
1_0e1_0;
1_000_000e-1_0;
0.0_0;
1_0e0_0;
1_0e0_1;

// error cases that should still continue parsing:

11_11_11_; // 6188
11__11_11; // 6189

0b01_01_01_; // 6188
0b01__01_01; // 6189

0o12_12_12_; // 6188
0o12__12_12; // 6189

0x23_23_23_; // 6188
0x23__23_23; // 6189

1000_.1234; // 6188
1000._1234; // 6188
1000.1234_; // 6188

10__00.1234; // 6189
1000.12__34; // 6189

1_e2; // 6188
1e_2; // 6188
1e2_; // 6188
1e-1__0; // 6189

0_0; // 6188
0_0.0; // 6188
0_0.0_0; // 6188
0_0e0_0; // 6188

0x_11_11; // 6188
0o_11_11; // 6188
0b_11_11; // 6188

00_01 // 1121

'''
'''--- tests/parser/numeric-separators.ts.fixture.ts ---
111111;
21;
41610;
2302755;
1000000.12341234;
100000000000;
0.0001;
0;
10;
100;
111111;
111111;
21;
21;
41610;
41610;
2302755;
2302755;
1000.1234;
1000.1234;
1000.1234;
1000.1234;
1000.1234;
100;
100;
100;
1e-10;
0;
0;
0;
0;
4369;
585;
15;
1;
// ERROR 6188: "Numeric separators are not allowed here." in numeric-separators.ts(14,9+0)
// ERROR 6189: "Multiple consecutive numeric separators are not permitted." in numeric-separators.ts(15,4+0)
// ERROR 6188: "Numeric separators are not allowed here." in numeric-separators.ts(17,11+0)
// ERROR 6189: "Multiple consecutive numeric separators are not permitted." in numeric-separators.ts(18,6+0)
// ERROR 6188: "Numeric separators are not allowed here." in numeric-separators.ts(20,11+0)
// ERROR 6189: "Multiple consecutive numeric separators are not permitted." in numeric-separators.ts(21,6+0)
// ERROR 6188: "Numeric separators are not allowed here." in numeric-separators.ts(23,11+0)
// ERROR 6189: "Multiple consecutive numeric separators are not permitted." in numeric-separators.ts(24,6+0)
// ERROR 6188: "Numeric separators are not allowed here." in numeric-separators.ts(26,5+0)
// ERROR 6188: "Numeric separators are not allowed here." in numeric-separators.ts(27,6+0)
// ERROR 6188: "Numeric separators are not allowed here." in numeric-separators.ts(28,10+0)
// ERROR 6189: "Multiple consecutive numeric separators are not permitted." in numeric-separators.ts(30,4+0)
// ERROR 6189: "Multiple consecutive numeric separators are not permitted." in numeric-separators.ts(31,9+0)
// ERROR 6188: "Numeric separators are not allowed here." in numeric-separators.ts(33,2+0)
// ERROR 6188: "Numeric separators are not allowed here." in numeric-separators.ts(34,3+0)
// ERROR 6188: "Numeric separators are not allowed here." in numeric-separators.ts(35,4+0)
// ERROR 6189: "Multiple consecutive numeric separators are not permitted." in numeric-separators.ts(36,6+0)
// ERROR 6188: "Numeric separators are not allowed here." in numeric-separators.ts(38,2+0)
// ERROR 6188: "Numeric separators are not allowed here." in numeric-separators.ts(39,2+0)
// ERROR 6188: "Numeric separators are not allowed here." in numeric-separators.ts(40,2+0)
// ERROR 6188: "Numeric separators are not allowed here." in numeric-separators.ts(41,2+0)
// ERROR 6188: "Numeric separators are not allowed here." in numeric-separators.ts(43,3+0)
// ERROR 6188: "Numeric separators are not allowed here." in numeric-separators.ts(44,3+0)
// ERROR 6188: "Numeric separators are not allowed here." in numeric-separators.ts(45,3+0)
// ERROR 1121: "Octal literals are not allowed in strict mode." in numeric-separators.ts(47,1+5)

'''
'''--- tests/parser/object-literal.ts ---
var obj = {
  a: 123,
  b: "234",
  "c": false,
  d: {
    a: 123,
    "b": {},
    c,
    d: d
  }
};

'''
'''--- tests/parser/object-literal.ts.fixture.ts ---
var obj = {
  a: 123,
  b: "234",
  "c": false,
  d: {
    a: 123,
    "b": {},
    c,
    d: d
  }
};

'''
'''--- tests/parser/optional-property.ts ---
class C {
  x?: i32;
}

'''
'''--- tests/parser/optional-property.ts.fixture.ts ---
class C {
  x: i32;
}
// ERROR 219: "Optional properties are not supported." in optional-property.ts(2,3+2)

'''
'''--- tests/parser/optional-typeparameters.ts ---
function a<T=i32>(): T { return 0; }
function a<T,U=i32>(): T { return 0; }
function a<T,U=i32,V>(): T { return 0; } // ERROR 2706

'''
'''--- tests/parser/optional-typeparameters.ts.fixture.ts ---
function a<T=i32>(): T {
  return 0;
}
function a<T, U=i32>(): T {
  return 0;
}
function a<T, U=i32, V>(): T {
  return 0;
}
// ERROR 2706: "Required type parameters may not follow optional type parameters." in optional-typeparameters.ts(3,20+1)

'''
'''--- tests/parser/parameter-optional.ts ---
function optionalParam(a: string = ""): void {}

'''
'''--- tests/parser/parameter-optional.ts.fixture.ts ---
function optionalParam(a: string = ""): void {}

'''
'''--- tests/parser/parameter-order.ts ---
function restValid(a: i32, ...b: i32[]): void {}
function optionalValid(a: i32, b?: i32): void {}

// 1014: A rest parameter must be last in a parameter list.
function restParameterMustBeLast(...a: i32[], b: i32): void {}

// 1016: A required parameter cannot follow an optional parameter.
function optionalCannotPrecedeRequired(a?: i32, b: i32): void {}

// 1016: A required parameter cannot follow an optional parameter.
function optionalWithInitializerCannotPrecedeRequired(a: i32 = 1, b: i32): void {}

'''
'''--- tests/parser/parameter-order.ts.fixture.ts ---
function restValid(a: i32, ...b: Array<i32>): void {}
function optionalValid(a: i32, b?: i32): void {}
function restParameterMustBeLast(...a: Array<i32>, b: i32): void {}
function optionalCannotPrecedeRequired(a?: i32, b: i32): void {}
function optionalWithInitializerCannotPrecedeRequired(a: i32 = 1, b: i32): void {}
// ERROR 1014: "A rest parameter must be last in a parameter list." in parameter-order.ts(5,37+1)
// ERROR 1016: "A required parameter cannot follow an optional parameter." in parameter-order.ts(8,49+1)
// ERROR 1016: "A required parameter cannot follow an optional parameter." in parameter-order.ts(11,67+1)

'''
'''--- tests/parser/propertyelementaccess.ts ---
(((this).values[0].prop1.prop2.another[1]).prop)[2];

'''
'''--- tests/parser/propertyelementaccess.ts.fixture.ts ---
(((this).values[0].prop1.prop2.another[1]).prop)[2];

'''
'''--- tests/parser/regexp.ts ---
/(abc)\//ig; // with modifiers
/(abc)\//; // without modifiers
var re = /(abc)\//ig; // can be assigned
var noRe = !/(abc)\//i; // generally behaves like an expression
/a
b/ig; // inner line break is unterminated
//ig;
/(abc)\//iig; // duplicate flags
/(abc)\//iX; // invalid flags
false && /abc/gX.test(someString) || true; // surrounding AST remains intact

'''
'''--- tests/parser/regexp.ts.fixture.ts ---
/(abc)\//ig;
/(abc)\//;
var re = /(abc)\//ig;
var noRe = !/(abc)\//i;
/(abc)\//iig;
/(abc)\//iX;
false && /abc/gX.test(someString) || true;
// ERROR 1161: "Unterminated regular expression literal." in regexp.ts(5,2+1)
// ERROR 1005: "'/' expected." in regexp.ts(5,1+2)
// ERROR 209: "Invalid regular expression flags." in regexp.ts(8,10+3)
// ERROR 209: "Invalid regular expression flags." in regexp.ts(9,10+2)
// ERROR 209: "Invalid regular expression flags." in regexp.ts(10,15+2)

'''
'''--- tests/parser/reserved-keywords.ts ---
function alsoIdentifier(readonly: i32): void {}
class AClass {
  constructor(readonly: i32) {}
  constructor(readonly readonly: i32) {}
}

type type = i32;
var type: i32;
type = 123;

namespace namespace {}
var namespace: i32;
namespace = 123;

abstract class AClass {}
var abstract: i32;
abstract = 123;

'''
'''--- tests/parser/reserved-keywords.ts.fixture.ts ---
function alsoIdentifier(readonly: i32): void {}
class AClass {
  constructor(readonly: i32) {}
  constructor(readonly readonly: i32) {}
}
type type = i32;
var type: i32;
type = 123;
namespace namespace {}
var namespace: i32;
namespace = 123;
abstract class AClass {}
var abstract: i32;
abstract = 123;

'''
'''--- tests/parser/string-binding.ts ---
// a host-bindings syntax experiment
@binding(BindingCall.NEW, [ BindingType.STRING ], BindingType.OBJECT_HANDLE)
export class ExternalString {

  @binding(BindingCall.FUNCTION, [ BindingType.U32, BindingType.U32 ], BindingType.OBJECT_HANDLE)
  static fromCharCode(char: u16, schar: u16 = <u16>-1): String { return unreachable(); }

  @binding(BindingCall.FUNCTION, [ BindingType.U32 ], BindingType.OBJECT_HANDLE)
  static fromCodePoint(codepoint: u32): String { return unreachable(); }

  @binding(BindingCall.THIS, [ BindingType.U32 ], BindingType.OBJECT_HANDLE)
  charAt(index: u32): String { return unreachable(); }

  @binding(BindingCall.THIS, [ BindingType.U32 ], BindingType.PASS_THRU)
  charCodeAt(index: u32): u16 { return unreachable(); }

  @binding(BindingCall.THIS, [ BindingType.U32 ], BindingType.PASS_THRU)
  codePointAt(index: u32): u32 { return unreachable(); }

  @binding(BindingCall.THIS, [ BindingType.OBJECT_HANDLE ], BindingType.OBJECT_HANDLE)
  @operator("+")
  concat(other: String): String { return unreachable(); }

  @binding(BindingCall.THIS, [ BindingType.OBJECT_HANDLE ], BindingType.PASS_THRU)
  endsWith(other: String): bool { return unreachable(); }

  @binding(BindingCall.THIS, [ BindingType.OBJECT_HANDLE ], BindingType.PASS_THRU)
  indexOf(other: String): i32 { return unreachable(); }

  @binding(BindingCall.THIS, [ BindingType.OBJECT_HANDLE ], BindingType.PASS_THRU)
  startsWith(other: String): bool { return unreachable(); }

  @binding(BindingCall.THIS, [ BindingType.U32, BindingType.U32 ], BindingType.OBJECT_HANDLE)
  substr(start: i32, length: i32): String { return unreachable(); }

  @binding(BindingCall.THIS, [ BindingType.U32, BindingType.U32 ], BindingType.OBJECT_HANDLE)
  substring(start: i32, end: i32): String { return unreachable(); }

  @binding(BindingCall.THIS, [], BindingType.OBJECT_HANDLE)
  trim(): String { return unreachable(); }

  @binding(BindingCall.THIS, [], BindingType.OBJECT_HANDLE)
  trimStart(): String { return unreachable(); }

  @binding(BindingCall.THIS, [], BindingType.OBJECT_HANDLE)
  trimEnd(): String { return unreachable(); }

  @binding(BindingCall.THIS, [ BindingType.OBJECT_HANDLE ], BindingType.PASS_THRU)
  @operator("==")
  equals(other: String): bool { return unreachable(); }
}

'''
'''--- tests/parser/string-binding.ts.fixture.ts ---
@binding(BindingCall.NEW, [BindingType.STRING], BindingType.OBJECT_HANDLE)
export class ExternalString {
  @binding(BindingCall.FUNCTION, [BindingType.U32, BindingType.U32], BindingType.OBJECT_HANDLE)
  static fromCharCode(char: u16, schar: u16 = <u16>-1): String {
    return unreachable();
  }
  @binding(BindingCall.FUNCTION, [BindingType.U32], BindingType.OBJECT_HANDLE)
  static fromCodePoint(codepoint: u32): String {
    return unreachable();
  }
  @binding(BindingCall.THIS, [BindingType.U32], BindingType.OBJECT_HANDLE)
  charAt(index: u32): String {
    return unreachable();
  }
  @binding(BindingCall.THIS, [BindingType.U32], BindingType.PASS_THRU)
  charCodeAt(index: u32): u16 {
    return unreachable();
  }
  @binding(BindingCall.THIS, [BindingType.U32], BindingType.PASS_THRU)
  codePointAt(index: u32): u32 {
    return unreachable();
  }
  @binding(BindingCall.THIS, [BindingType.OBJECT_HANDLE], BindingType.OBJECT_HANDLE)
  @operator("+")
  concat(other: String): String {
    return unreachable();
  }
  @binding(BindingCall.THIS, [BindingType.OBJECT_HANDLE], BindingType.PASS_THRU)
  endsWith(other: String): bool {
    return unreachable();
  }
  @binding(BindingCall.THIS, [BindingType.OBJECT_HANDLE], BindingType.PASS_THRU)
  indexOf(other: String): i32 {
    return unreachable();
  }
  @binding(BindingCall.THIS, [BindingType.OBJECT_HANDLE], BindingType.PASS_THRU)
  startsWith(other: String): bool {
    return unreachable();
  }
  @binding(BindingCall.THIS, [BindingType.U32, BindingType.U32], BindingType.OBJECT_HANDLE)
  substr(start: i32, length: i32): String {
    return unreachable();
  }
  @binding(BindingCall.THIS, [BindingType.U32, BindingType.U32], BindingType.OBJECT_HANDLE)
  substring(start: i32, end: i32): String {
    return unreachable();
  }
  @binding(BindingCall.THIS, [], BindingType.OBJECT_HANDLE)
  trim(): String {
    return unreachable();
  }
  @binding(BindingCall.THIS, [], BindingType.OBJECT_HANDLE)
  trimStart(): String {
    return unreachable();
  }
  @binding(BindingCall.THIS, [], BindingType.OBJECT_HANDLE)
  trimEnd(): String {
    return unreachable();
  }
  @binding(BindingCall.THIS, [BindingType.OBJECT_HANDLE], BindingType.PASS_THRU)
  @operator("==")
  equals(other: String): bool {
    return unreachable();
  }
}

'''
'''--- tests/parser/trailing-commas.ts ---
import {
  a,
  b,
} from "c";

enum Foo {
  A,
  B,
}

function add(
  x: i32,
  y: i32,
): i32 {
  return x + y;
}

function parameterized<
  A,
  B,
>(a: A, b: B): void {
}

export function compute(): i32 {
  const arr: Array<i8> = [
    1,
    2,
  ];
  parameterized<
    i8,
    // @ts-ignore: Waiting on https://github.com/Microsoft/TypeScript/issues/21984
    i32,
  >(0, 0);
  return add(
    1,
    2,
  );
}

export {
  a,
  b,
};

'''
'''--- tests/parser/trailing-commas.ts.fixture.ts ---
import {
  a,
  b
} from "c";
enum Foo {
  A,
  B
}
function add(x: i32, y: i32): i32 {
  return x + y;
}
function parameterized<A, B>(a: A, b: B): void {}
export function compute(): i32 {
  const arr: Array<i8> = [1, 2];
  parameterized<i8, i32>(0, 0);
  return add(1, 2);
}
export {
  a,
  b
};

'''
'''--- tests/parser/tsconfig.json ---
{
  "extends": "../../std/assembly.json",
  "include": [
    "./*.ts"
  ]
}

'''
'''--- tests/parser/type-signature.ts ---
type foo = () => void;
type foo = (() => void) | null;
type foo = (a: i32) => i32;
type foo = (a?: i32) => i32;
type foo = (this: AClass, a: i32) => i32;
type foo = () => () => void;
type foo = () => (() => void) | null;
type foo = (this: AClass, a: i32) => ((this: BClass, b?: f32) => i32) | null;

'''
'''--- tests/parser/type-signature.ts.fixture.ts ---
type foo = () => void;
type foo = (() => void) | null;
type foo = (a: i32) => i32;
type foo = (a?: i32) => i32;
type foo = (this: AClass, a: i32) => i32;
type foo = () => () => void;
type foo = () => (() => void) | null;
type foo = (this: AClass, a: i32) => ((this: BClass, b?: f32) => i32) | null;

'''
'''--- tests/parser/type.ts ---
type int32_t = i32;
@nonportable()
export type uint64_t = u64;

'''
'''--- tests/parser/type.ts.fixture.ts ---
type int32_t = i32;
@nonportable()
export type uint64_t = u64;

'''
'''--- tests/parser/var.ts ---
var a: i32;
var b: i32;
const c: i32 = 0;
var d = 2;

// 1110: Type expected.
var e;

// 1155: 'const' declarations must be initialized.
const f: i32;

const t = 0 < (c / 10);

'''
'''--- tests/parser/var.ts.fixture.ts ---
var a: i32;
var b: i32;
const c: i32 = 0;
var d = 2;
var e;
const f: i32;
const t = 0 < (c / 10);
// ERROR 1110: "Type expected." in var.ts(7,6+0)
// ERROR 1155: "'const' declarations must be initialized." in var.ts(10,7+1)

'''
'''--- tests/parser/while.ts ---
while (1) {
  ;
}
while (false) {
  ;
}
while ("str") {
  ;
}
while (1);

'''
'''--- tests/parser/while.ts.fixture.ts ---
while (1) {
  ;
}
while (false) {
  ;
}
while ("str") {
  ;
}
while (1);

'''
'''--- tests/require/index-release.ts ---
// used to check `require`ing distribution files
// - dist/assemblyscript.js
// - dist/assemblyscript.d.ts
import * as as from "../../index.release";
var program: as.Program = as.newProgram(as.newOptions());
as.parse(program, "", "empty");

'''
'''--- tests/require/index.ts ---
// used to check `require`ing portable sources
// - src/glue/js/index.ts
// - src/index.ts
import * as as from "../../index";
var program: as.Program = as.newProgram(as.newOptions());
as.parse(program, "", "empty");

'''
'''--- tests/resolve-ternary.json ---
{
  "asc_flags": [
  ]
}

'''
'''--- tests/tokenizer.js ---
const fs = require("fs");
const path = require("path");

require("ts-node").register({ project: path.join(__dirname, "..", "src", "tsconfig.json") });
require("../src/glue/js");

const { Tokenizer, Token } = require("../src/tokenizer");
const { Source, SourceKind } = require("../src/ast");

var file = process.argv.length > 2 ? process.argv[2] : path.join(__dirname, "..", "src", "tokenizer.ts");
const text = fs.readFileSync(file).toString();
const tn = new Tokenizer(new Source("compiler.ts", text, SourceKind.ENTRY));

do {
  let token = tn.next();
  let range = tn.range();
  process.stdout.write(Token[token] + " @ " + range.line + ":" + range.column);
  if (token == Token.IDENTIFIER) {
    process.stdout.write(" > " + tn.readIdentifier());
  } else if (token == Token.INTEGERLITERAL) {
    process.stdout.write(" > " + tn.readInteger());
  } else if (token == Token.FLOATLITERAL) {
    process.stdout.write(" > " + tn.readFloat());
  } else if (token == Token.STRINGLITERAL) {
    process.stdout.write(" > " + tn.readString());
  } else if (token == Token.ENDOFFILE) {
    process.stdout.write("\n");
    break;
  } else {
    process.stdout.write(" > " + range.source.text.substring(range.start, range.end));
  }
  process.stdout.write("\n");
} while (true);

'''
'''--- tests/util-path.js ---
const path = require("path");
const assert = require("assert");

require("ts-node").register({ project: path.join(__dirname, "..", "src", "tsconfig.json") });
require("../src/glue/js");

const { normalize, resolve } = require("../src/util/path");

var test = "./Y/./N/./N/../../././../Y/./.";
assert.strictEqual(normalize(test), path.posix.normalize(test));

assert.strictEqual(resolve("../../..", "lib/util/i64.ts"), "..");

'''
'''--- tests/util/diff.js ---
var Diff = require("diff");
var colors = require("../../cli/util/colors");

module.exports = function diff(filename, expected, actual) {
  var diff = Diff.structuredPatch(filename, filename, expected, actual, "expected", "actual", { context: 5 });
  if (!diff.hunks.length)
    return null;

  var ret = [];
  ret.push('--- ' + diff.oldHeader);
  ret.push('+++ ' + diff.newHeader);

  for (var i = 0; i < diff.hunks.length; i++) {
    var hunk = diff.hunks[i];
    ret.push(
      '@@ -' + hunk.oldStart + ',' + hunk.oldLines
      + ' +' + hunk.newStart + ',' + hunk.newLines
      + ' @@'
    );
    ret.push.apply(ret, hunk.lines.map(line =>
      line.charAt(0) === "+"
        ? colors.green(line)
        : line.charAt(0) === "-"
        ? line = colors.red(line)
        : line
    ));
  }

  return ret.join('\n') + '\n';
};

'''
'''--- tsconfig-base.json ---
{
  "compilerOptions": {
    "alwaysStrict": true,
    "noImplicitAny": true,
    "noImplicitReturns": true,
    "noImplicitThis": true,
    "noEmitOnError": true,
    "strictNullChecks": true,
    "experimentalDecorators": true
  }
}

'''
'''--- tsconfig-docs.json ---
{
  "extends": "./src/tsconfig.json",
  "include": [
    "./src/**/*.ts"
  ],
  "exclude": [
    "./std/**"
  ]
}

'''
'''--- webpack.config.js ---
const path = require("path");
const fs = require("fs");
const webpack = require("webpack");
const TerserPlugin = require('terser-webpack-plugin');

function preamble(name) {
  return [
    "/**",
    " * @license",
    " * " + name,
    " * Copyright Daniel Wirtz / The AssemblyScript Authors.",
    " * SPDX-License-Identifier: Apache-2.0",
    " */"
  ].join("\n");
}

// Build the C-like library
const lib = {
  mode: "production",
  target: ["web", "es6"],
  entry: [ "./src/glue/js", "./src/index.ts" ],
  module: {
    rules: [
      {
        test: /\.ts$/,
        use: "ts-loader",
        exclude: /node_modules/
      }
    ]
  },
  externals: [
    "binaryen"
  ],
  resolve: {
    extensions: [ ".ts", ".js" ]
  },
  output: {
    filename: "assemblyscript.js",
    path: path.resolve(__dirname, "dist"),
    library: "assemblyscript",
    libraryTarget: "umd",
    globalObject: "typeof self !== 'undefined' ? self : this"
  },
  devtool: "source-map",
  performance: {
    hints : false
  },
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          output: {
            comments: false,
            preamble: preamble("The AssemblyScript Compiler.")
          }
        },
        parallel: true,
        extractComments: false
      })
    ],
  }
};

// Build asc for browser usage
const shimDir = path.join(__dirname, "cli", "shim");
const bin = {
  mode: "production",
  target: ["web", "es6"],
  context: path.join(__dirname, "cli"),
  entry: [ "./asc.js" ],
  externals: [
    "binaryen",
    "assemblyscript"
  ],
  node: {
    global: true
  },
  output: {
    filename: "asc.js",
    path: path.resolve(__dirname, "dist"),
    library: "asc",
    libraryTarget: "umd",
    globalObject: "typeof self !== 'undefined' ? self : this"
  },
  devtool: "source-map",
  performance: {
    hints : false
  },
  plugins: [
    new webpack.DefinePlugin({
      BUNDLE_VERSION: JSON.stringify(require("./package.json").version),
      BUNDLE_LIBRARY: (() => {
        const libDir = path.join(__dirname, "std", "assembly");
        const libFiles = require("glob").sync("**/!(*.d).ts", { cwd: libDir });
        const lib = {};
        libFiles.forEach(file => lib[file.replace(/\.ts$/, "")] = bundleFile(path.join(libDir, file)));
        return lib;
      })(),
      BUNDLE_DEFINITIONS: {
        "assembly": bundleFile(path.join(__dirname, "std", "assembly", "index.d.ts")),
        "portable": bundleFile(path.join(__dirname, "std", "portable", "index.d.ts"))
      },
      __dirname: JSON.stringify(".")
    }),

    // Browser shims
    new webpack.NormalModuleReplacementPlugin(/^path$/, path.join(shimDir, "path")),
    new webpack.NormalModuleReplacementPlugin(/^process$/, path.join(shimDir, "process")),
    new webpack.NormalModuleReplacementPlugin(/^fs$/, path.join(shimDir, "fs"))
  ],
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          output: {
            comments: false,
            preamble: preamble("The AssemblyScript Compiler Frontend.")
          }
        },
        parallel: true,
        extractComments: false
      })
    ],
  }
};

function bundleFile(filename) {
  return JSON.stringify(fs.readFileSync(filename, { encoding: "utf8" }).replace(/\r\n/g, "\n"));
}

module.exports = [ lib, bin ];

'''