*GitHub Repository "andrew-sol/workspaces-reproduction"*

'''--- Cargo.toml ---
[package]
name = "integration-tests"
version = "1.0.0"
authors = []
edition = "2018"

[dependencies]
near-sdk = "4.1.1"
near-contract-standards = "4.1.1"
near-units = "0.2.0"
workspaces = "0.7.0"
anyhow = "1.0.68"
tokio = "1.24.1"

[[example]]
name = "integration-tests"
path = "src/lib.rs"

'''
'''--- README.md ---
## Setup

```sh
chmod +x run.sh
```

## Run the tests

```bash
./run.sh
```

or

```bash
cargo run --example integration-tests
```

'''
'''--- run.sh ---
#!/bin/bash
set -e

cargo run --example integration-tests

'''
'''--- src/lib.rs ---
use near_sdk::serde_json;
use near_units::parse_gas;
use near_units::parse_near;
use serde_json::json;
use workspaces::{network::Sandbox, result::ExecutionFinalResult, Account, Contract, Worker};

use crate::staking_farm::*;
use crate::types::*;
use crate::utils::*;
use crate::validator::*;

pub mod staking_farm;
pub mod types;
pub mod utils;
pub mod validator;

pub const STAKING_FARM_WASM_FILEPATH: &str = "./contracts/staking_farm.wasm";
pub const VALIDATOR_WASM_FILEPATH: &str = "./contracts/staking_pool.wasm";

pub const ONE_DAY_IN_NANOSECONDS: u64 = 86400000000000;

#[tokio::main]
#[allow(dead_code, unused_must_use)]
async fn main() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;

    // create accounts
    let owner = worker.root_account().unwrap();
    let alice = create_account(&worker, "alice", parse_near!("2000000 N")).await?;

    // deploy contracts
    let (validator_contract, staking_farm_contract) = deploy_contracts(&worker).await?;

    // initialize contracts
    init_contracts(&owner, &validator_contract, &staking_farm_contract).await?;

    // begin tests
    test_deposit_stake_unstake(&alice, &staking_farm_contract, &validator_contract).await?;
    test_withdraw(&worker, &alice, &staking_farm_contract).await?;

    Ok(())
}

async fn deploy_contracts(worker: &Worker<Sandbox>) -> anyhow::Result<(Contract, Contract)> {
    println!("Deploying contracts...");

    let validator_account = create_account(&worker, "validator", parse_near!("100000 N")).await?;
    let validator_wasm = std::fs::read(VALIDATOR_WASM_FILEPATH)?;
    let validator_contract = validator_account.deploy(&validator_wasm).await?.unwrap();

    let staking_farm_wasm = std::fs::read(STAKING_FARM_WASM_FILEPATH)?;
    let staking_farm_contract = worker.dev_deploy(&staking_farm_wasm).await?;

    Ok((validator_contract, staking_farm_contract))
}

async fn init_contracts(
    owner: &Account,
    validator_contract: &Contract,
    staking_farm_contract: &Contract,
) -> anyhow::Result<()> {
    println!("Initializing contracts...");

    let pk = owner.secret_key().public_key();
    let res = validator_contract
        .call("new")
        .args_json(json!({
            "owner_id": owner.id(),
            "stake_public_key": pk,
            "reward_fee_fraction": {
                "numerator": 1,
                "denominator": 100,
            },
        }))
        .gas(parse_gas!("50 T") as u64)
        .transact()
        .await?;
    check_res(&res, "validator_contract::new()");

    let res = staking_farm_contract
        .call("new")
        .args_json(json!({
            "owner_id": owner.id(),
            "validator_id": validator_contract.id(),
            "reward_fee_fraction": {
                "numerator": 1,
                "denominator": 2,
            },
        }))
        .transact()
        .await?;
    check_res(&res, "staking_farm_contract::new()");

    Ok(())
}

#[allow(unused_must_use)]
pub async fn test_deposit_stake_unstake(
    user: &Account,
    staking_farm_contract: &Contract,
    validator_contract: &Contract,
) -> anyhow::Result<()> {
    println!("Start: test_deposit_stake_unstake");

    let pool_summary = get_pool_summary(staking_farm_contract, user).await?;
    println!("pool_summary {:#?}", pool_summary);

    let farm_account = staking_farm_contract.as_account();

    // DEPOSIT #################
    deposit(staking_farm_contract, user, parse_near!("1000 N")).await?;

    let account = get_account(staking_farm_contract, user).await?;
    let total_balance = get_account_total_balance(staking_farm_contract, user).await?;
    let staked_balance = get_account_staked_balance(staking_farm_contract, user).await?;
    let unstaked_balance = get_account_unstaked_balance(staking_farm_contract, user).await?;
    let validator_total_balance =
        validator_get_account_total_balance(&validator_contract, farm_account).await?;
    let validator_staked_balance =
        validator_get_account_staked_balance(&validator_contract, farm_account).await?;
    let validator_unstaked_balance =
        validator_get_account_unstaked_balance(&validator_contract, farm_account).await?;

    assert_eq!(total_balance, parse_near!("1000 N"));
    assert_eq!(account.staked_balance.0, parse_near!("0 N"));
    assert_eq!(account.unstaked_balance.0, parse_near!("1000 N"));
    assert_eq!(account.can_withdraw, true);
    assert_eq!(account.staked_balance.0, staked_balance);
    assert_eq!(account.unstaked_balance.0, unstaked_balance);
    assert_eq!(validator_total_balance, parse_near!("1000 N"));
    assert_eq!(validator_staked_balance, parse_near!("0 N"));
    assert_eq!(validator_unstaked_balance, parse_near!("1000 N"));

    // STAKE #################
    stake(staking_farm_contract, user, parse_near!("200 N")).await?;

    let account = get_account(staking_farm_contract, user).await?;
    let staked_balance = get_account_staked_balance(staking_farm_contract, user).await?;
    let unstaked_balance = get_account_unstaked_balance(staking_farm_contract, user).await?;
    let validator_staked_balance =
        validator_get_account_staked_balance(&validator_contract, farm_account).await?;
    let validator_unstaked_balance =
        validator_get_account_unstaked_balance(&validator_contract, farm_account).await?;

    assert_eq!(account.staked_balance.0, parse_near!("200 N"));
    assert_eq!(account.unstaked_balance.0, parse_near!("800 N"));
    assert_eq!(account.can_withdraw, true);
    assert_eq!(account.staked_balance.0, staked_balance);
    assert_eq!(account.unstaked_balance.0, unstaked_balance);
    assert_eq!(validator_staked_balance, parse_near!("200 N"));
    assert_eq!(validator_unstaked_balance, parse_near!("800 N"));

    // STAKE_ALL #################
    stake_all(staking_farm_contract, user).await?;

    let account = get_account(staking_farm_contract, user).await?;
    let staked_balance = get_account_staked_balance(staking_farm_contract, user).await?;
    let unstaked_balance = get_account_unstaked_balance(staking_farm_contract, user).await?;
    let validator_staked_balance =
        validator_get_account_staked_balance(&validator_contract, farm_account).await?;
    let validator_unstaked_balance =
        validator_get_account_unstaked_balance(&validator_contract, farm_account).await?;

    assert_eq!(account.staked_balance.0, parse_near!("1000 N"));
    assert_eq!(account.unstaked_balance.0, parse_near!("0 N"));
    assert_eq!(account.can_withdraw, true);
    assert_eq!(account.staked_balance.0, staked_balance);
    assert_eq!(account.unstaked_balance.0, unstaked_balance);
    assert_eq!(validator_staked_balance, parse_near!("1000 N"));
    assert_eq!(validator_unstaked_balance, parse_near!("0 N"));

    // UNSTAKE #################
    unstake(staking_farm_contract, user, parse_near!("100 N")).await?;

    let account = get_account(staking_farm_contract, user).await?;
    let staked_balance = get_account_staked_balance(staking_farm_contract, user).await?;
    let unstaked_balance = get_account_unstaked_balance(staking_farm_contract, user).await?;
    let validator_staked_balance =
        validator_get_account_staked_balance(&validator_contract, farm_account).await?;
    let validator_unstaked_balance =
        validator_get_account_unstaked_balance(&validator_contract, farm_account).await?;

    assert_eq!(account.staked_balance.0, parse_near!("900 N"));
    assert_eq!(account.unstaked_balance.0, parse_near!("100 N"));
    assert_eq!(account.can_withdraw, false);
    assert_eq!(account.staked_balance.0, staked_balance);
    assert_eq!(account.unstaked_balance.0, unstaked_balance);
    assert_eq!(validator_staked_balance, parse_near!("900 N"));
    assert_eq!(validator_unstaked_balance, parse_near!("100 N"));

    // UNSTAKE_ALL #################
    unstake_all(staking_farm_contract, user).await?;

    let account = get_account(staking_farm_contract, user).await?;
    let staked_balance = get_account_staked_balance(staking_farm_contract, user).await?;
    let unstaked_balance = get_account_unstaked_balance(staking_farm_contract, user).await?;
    let validator_staked_balance =
        validator_get_account_staked_balance(&validator_contract, farm_account).await?;
    let validator_unstaked_balance =
        validator_get_account_unstaked_balance(&validator_contract, farm_account).await?;

    assert_eq!(account.staked_balance.0, parse_near!("0 N"));
    assert_eq!(account.unstaked_balance.0, parse_near!("1000 N"));
    assert_eq!(account.can_withdraw, false);
    assert_eq!(account.staked_balance.0, staked_balance);
    assert_eq!(account.unstaked_balance.0, unstaked_balance);
    assert_eq!(validator_staked_balance, parse_near!("0 N"));
    assert_eq!(validator_unstaked_balance, parse_near!("1000 N"));

    // DEPOSIT_AND_STAKE #################
    deposit_and_stake(staking_farm_contract, user, parse_near!("1000 N")).await?;

    let staked_balance = get_account_staked_balance(staking_farm_contract, user).await?;
    let unstaked_balance = get_account_unstaked_balance(staking_farm_contract, user).await?;

    assert_eq!(staked_balance, parse_near!("1000 N"));
    assert_eq!(unstaked_balance, parse_near!("1000 N"));

    println!("Passed ✅ test_deposit_stake_unstake");
    Ok(())
}

#[allow(unused_must_use)]
pub async fn test_withdraw(
    worker: &Worker<Sandbox>,
    user: &Account,
    staking_farm_contract: &Contract,
) -> anyhow::Result<()> {
    println!("Start: test_withdraw");

    wait_epochs(worker, 5).await?;

    let pool_summary = get_pool_summary(staking_farm_contract, user).await?;
    println!("pool_summary {:#?}", pool_summary);

    let can_withdraw = is_contract_can_withdraw(staking_farm_contract, user).await?;
    println!("Can withdraw {}", can_withdraw);

    let account = get_account(staking_farm_contract, user).await?;
    println!("Account state: {:?}", account);

    assert_eq!(account.can_withdraw, true);
    assert_eq!(account.unstaked_balance.0, parse_near!("1000 N"));

    // WITHDRAW 200 NEAR ##############
    println!("Withdrawing 200 NEAR...");
    withdraw(staking_farm_contract, user, parse_near!("200 N")).await?;

    let account = get_account(staking_farm_contract, user).await?;

    assert_eq!(account.can_withdraw, true);
    assert_eq!(account.unstaked_balance.0, parse_near!("800 N"));

    // WITHDRAW_ALL ##############
    println!("Withdrawing the rest of NEAR...");
    let prev_total_balance = get_account_total_balance(staking_farm_contract, user).await?;
    withdraw_all(staking_farm_contract, user).await?;

    let account = get_account(staking_farm_contract, user).await?;
    let total_balance = get_account_total_balance(staking_farm_contract, user).await?;

    assert_eq!(account.can_withdraw, true);
    assert_eq!(account.unstaked_balance.0, 0);
    assert_eq!(prev_total_balance - total_balance, parse_near!("800 N"));

    println!("Passed ✅ test_withdraw");
    Ok(())
}

'''
'''--- src/staking_farm.rs ---
use near_sdk::{json_types::U128, Balance};
use workspaces::AccountId;

use crate::*;

const ONE_SEC_IN_NS: u64 = 1_000_000_000;

// STAKE METHODS ===========================
// ========================================

pub async fn deposit(
    staking_farm_contract: &Contract,
    user: &Account,
    amount: Balance,
) -> anyhow::Result<()> {
    let res = user
        .call(staking_farm_contract.id(), "deposit")
        .deposit(amount)
        .gas(parse_gas!("100 T") as u64)
        .transact()
        .await?;
    check_res(&res, "staking_farm_contract::deposit");

    Ok(())
}

pub async fn deposit_and_stake(
    staking_farm_contract: &Contract,
    user: &Account,
    amount: Balance,
) -> anyhow::Result<()> {
    let res = user
        .call(staking_farm_contract.id(), "deposit_and_stake")
        .deposit(amount)
        .gas(parse_gas!("130 T") as u64)
        .transact()
        .await?;
    check_res(&res, "staking_farm_contract::deposit_and_stake");

    Ok(())
}

pub async fn stake(
    staking_farm_contract: &Contract,
    user: &Account,
    amount: Balance,
) -> anyhow::Result<()> {
    let res = user
        .call(staking_farm_contract.id(), "stake")
        .args_json(json!({ "amount": U128(amount) }))
        .gas(parse_gas!("130 T") as u64)
        .transact()
        .await?;
    check_res(&res, "staking_farm_contract::stake");

    Ok(())
}

pub async fn unstake(
    staking_farm_contract: &Contract,
    user: &Account,
    amount: Balance,
) -> anyhow::Result<()> {
    let res = user
        .call(staking_farm_contract.id(), "unstake")
        .args_json(json!({ "amount": U128(amount) }))
        .gas(parse_gas!("200 T") as u64)
        .transact()
        .await?;
    check_res(&res, "staking_farm_contract::unstake");

    Ok(())
}

pub async fn stake_all(staking_farm_contract: &Contract, user: &Account) -> anyhow::Result<()> {
    let res = user
        .call(staking_farm_contract.id(), "stake_all")
        .gas(parse_gas!("130 T") as u64)
        .transact()
        .await?;
    check_res(&res, "staking_farm_contract::stake_all");

    Ok(())
}

pub async fn unstake_all(staking_farm_contract: &Contract, user: &Account) -> anyhow::Result<()> {
    let res = user
        .call(staking_farm_contract.id(), "unstake_all")
        .gas(parse_gas!("200 T") as u64)
        .transact()
        .await?;
    check_res(&res, "staking_farm_contract::unstake_all");

    Ok(())
}

pub async fn withdraw(
    staking_farm_contract: &Contract,
    user: &Account,
    amount: Balance,
) -> anyhow::Result<()> {
    let res = user
        .call(staking_farm_contract.id(), "withdraw")
        .args_json(json!({ "amount": U128(amount) }))
        .gas(parse_gas!("130 T") as u64)
        .transact()
        .await?;
    check_res(&res, "staking_farm_contract::withdraw");

    Ok(())
}

pub async fn withdraw_all(staking_farm_contract: &Contract, user: &Account) -> anyhow::Result<()> {
    let res = user
        .call(staking_farm_contract.id(), "withdraw_all")
        .gas(parse_gas!("130 T") as u64)
        .transact()
        .await?;
    check_res(&res, "staking_farm_contract::withdraw_all");

    Ok(())
}

pub async fn get_account_unstaked_balance(
    staking_farm_contract: &Contract,
    user: &Account,
) -> anyhow::Result<u128> {
    let res: U128 = view_call(
        user,
        staking_farm_contract,
        "get_account_unstaked_balance",
        json!({"account_id": user.id()}),
    )
    .await?
    .json()?;

    Ok(res.0)
}

pub async fn get_account_staked_balance(
    staking_farm_contract: &Contract,
    user: &Account,
) -> anyhow::Result<u128> {
    let res: U128 = view_call(
        user,
        staking_farm_contract,
        "get_account_staked_balance",
        json!({"account_id": user.id()}),
    )
    .await?
    .json()?;

    Ok(res.0)
}

pub async fn get_account_total_balance(
    staking_farm_contract: &Contract,
    user: &Account,
) -> anyhow::Result<u128> {
    let res: U128 = view_call(
        user,
        staking_farm_contract,
        "get_account_total_balance",
        json!({"account_id": user.id()}),
    )
    .await?
    .json()?;

    Ok(res.0)
}

pub async fn is_account_unstaked_balance_available(
    staking_farm_contract: &Contract,
    user: &Account,
) -> anyhow::Result<bool> {
    let res: bool = view_call(
        user,
        staking_farm_contract,
        "is_account_unstaked_balance_available",
        json!({"account_id": user.id()}),
    )
    .await?
    .json()?;

    Ok(res)
}

pub async fn get_account(
    staking_farm_contract: &Contract,
    user: &Account,
) -> anyhow::Result<HumanReadableAccount> {
    let res: HumanReadableAccount = view_call(
        user,
        staking_farm_contract,
        "get_account",
        json!({"account_id": user.id()}),
    )
    .await?
    .json()?;

    Ok(res)
}

pub async fn get_pool_summary(
    staking_farm_contract: &Contract,
    user: &Account,
) -> anyhow::Result<PoolSummary> {
    let res: PoolSummary = view_call(user, staking_farm_contract, "get_pool_summary", json!({}))
        .await?
        .json()?;

    Ok(res)
}

pub async fn is_contract_can_withdraw(
    staking_farm_contract: &Contract,
    user: &Account,
) -> anyhow::Result<bool> {
    let res: bool = view_call(
        user,
        staking_farm_contract,
        "is_contract_can_withdraw",
        json!({}),
    )
    .await?
    .json()?;

    Ok(res)
}

// FARM METHODS ===========================
// ========================================

/// Transfer the given amount of ft_contract token to the staking_farm_contract.
pub async fn transfer_farm_token(
    worker: &Worker<Sandbox>,
    ft_contract: &Contract,
    staking_farm_contract: &Contract,
    user: &Account,
    amount: Balance,
) -> anyhow::Result<()> {
    let block = worker.view_block().await?;
    let start_date = block.timestamp() + ONE_SEC_IN_NS * 3;
    let end_date = start_date + ONE_SEC_IN_NS * 100;
    let msg =
        serde_json::to_string(&json!({ "name": "Test", "start_date": format!("{}", start_date), "end_date": format!("{}", end_date) }))
            .unwrap();
    let res = user
        .call(ft_contract.id(), "ft_transfer_call")
        .deposit(1)
        .args_json(json!({
            "receiver_id": staking_farm_contract.id(),
            "amount": amount,
            "msg": msg,
        }))
        .transact()
        .await?;
    check_res(&res, "transfer_farm_token - ft_contract::ft_transfer_call");

    Ok(())
}

pub async fn get_active_farms(
    staking_farm_contract: &Contract,
    user: &Account,
) -> anyhow::Result<Vec<HumanReadableFarm>> {
    let res: Vec<HumanReadableFarm> =
        view_call(user, staking_farm_contract, "get_active_farms", json!({}))
            .await?
            .json()?;

    Ok(res)
}

pub async fn get_unclaimed_reward(
    staking_farm_contract: &Contract,
    user: &Account,
    farm_id: u64,
) -> anyhow::Result<u128> {
    let res: U128 = view_call(
        user,
        staking_farm_contract,
        "get_unclaimed_reward",
        json!({"account_id": user.id(), "farm_id": farm_id}),
    )
    .await?
    .json()?;

    Ok(res.0)
}

pub async fn claim(
    staking_farm_contract: &Contract,
    user: &Account,
    token_id: AccountId,
    delegator_id: Option<AccountId>,
) -> anyhow::Result<()> {
    let res = user
        .call(staking_farm_contract.id(), "claim")
        .deposit(1)
        .gas(parse_gas!("100 T") as u64)
        .args_json(json!({
            "token_id": token_id,
            "delegator_id": delegator_id,
        }))
        .transact()
        .await?;
    check_res(&res, "staking_farm_contract::claim");

    Ok(())
}

pub async fn stop_farm(
    staking_farm_contract: &Contract,
    user: &Account,
    farm_id: u64,
) -> anyhow::Result<()> {
    let res = user
        .call(staking_farm_contract.id(), "stop_farm")
        .deposit(1)
        .gas(parse_gas!("100 T") as u64)
        .args_json(json!({
            "farm_id": farm_id,
        }))
        .transact()
        .await?;
    check_res(&res, "staking_farm_contract::stop_farm");

    Ok(())
}

'''
'''--- src/types.rs ---
use near_sdk::{
    json_types::{U128, U64},
    serde::{Deserialize, Serialize},
};
use workspaces::AccountId;

#[derive(Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalanceBoundsJson {
    pub min: String,
    pub max: Option<String>,
}

#[derive(Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct HumanReadableAccount {
    pub account_id: AccountId,
    /// The unstaked balance that can be withdrawn or staked.
    pub unstaked_balance: U128,
    /// The amount balance staked at the current "stake" share price.
    pub staked_balance: U128,
    /// Whether the unstaked balance is available for withdrawal now.
    pub can_withdraw: bool,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct Ratio {
    pub numerator: u32,
    pub denominator: u32,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct HumanReadableFarm {
    pub farm_id: u64,
    pub name: String,
    pub token_id: AccountId,
    pub amount: U128,
    pub start_date: U64,
    pub end_date: U64,
    pub active: bool,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct PoolSummary {
    /// Pool owner.
    pub owner: AccountId,
    /// The total staked balance.
    pub total_staked_balance: U128,
    /// The fraction of the reward that goes to the owner of the staking pool for running the
    /// validator node.
    pub reward_fee_fraction: Ratio,
    /// If reward fee fraction is changing, this will be different from current.
    pub next_reward_fee_fraction: Ratio,
    /// Active farms that affect stakers.
    pub farms: Vec<HumanReadableFarm>,
}

'''
'''--- src/utils.rs ---
use workspaces::{result::ViewResultDetails, types::Balance};

use crate::*;

/// Check the result of a contract method call
pub fn check_res(res: &ExecutionFinalResult, msg: &str) {
    if res.is_failure() {
        println!("{} | FAIL", msg);
        println!("{:#?}", res);
        panic!("FAIL: {}", msg);
    } else if res.receipt_failures().len() > 0 {
        println!("{} | FAIL", msg);
        println!("RECEIPTS:");
        res.receipt_outcomes()
            .into_iter()
            .for_each(|row| println!("{:?}", row));

        println!("FAILURES:");
        println!("{:?}", res.receipt_failures());

        panic!("FAIL: {}", msg);
    } else {
        res.logs().into_iter().for_each(|row| println!("{:?}", row));
        println!(
            "{} | OK ({} TGas)",
            msg,
            res.total_gas_burnt / 1_000_000_000_000
        );
    }
}

/// Checks that two amount are within epsilon
pub fn assert_almost_eq(left: Balance, right: Balance, epsilon: Balance) {
    println!("{} ~= {}", left, right);

    if left > right {
        assert!((left - right) < epsilon);
    } else {
        assert!((right - left) < epsilon);
    }
}

pub async fn create_account(
    worker: &Worker<Sandbox>,
    account_name: &str,
    near_amount: u128,
) -> anyhow::Result<Account> {
    println!("Creating account \"{}\"", account_name);

    let owner = worker.root_account().unwrap();

    let account = owner
        .create_subaccount(account_name)
        .initial_balance(near_amount)
        .transact()
        .await?
        .into_result()?;

    Ok(account)
}

pub async fn view_call(
    user: &Account,
    contract: &Contract,
    method: &str,
    args_json: serde_json::Value,
) -> anyhow::Result<ViewResultDetails> {
    println!("view {}@{} {:?}", contract.id(), method, args_json);

    let res = user
        .call(contract.id(), method.clone())
        .args_json(args_json)
        .view()
        .await?;

    Ok(res)
}

/// Fast-forward for a given number of epochs.
pub async fn wait_epochs(worker: &Worker<Sandbox>, epochs_num: u64) -> anyhow::Result<()> {
    println!("Fast-forwarding {} epochs...", epochs_num);

    let mut i = 0;

    while i < epochs_num {
        wait_epoch(worker).await?;
        i += 1;
    }

    Ok(())
}

/// Fast-forward for an epoch (approximate).
pub async fn wait_epoch(worker: &Worker<Sandbox>) -> anyhow::Result<()> {
    let start_block = worker.view_block().await?;
    let blocks_per_iteration = 100;
    let mut skipped_blocks = 0;

    loop {
        worker.fast_forward(blocks_per_iteration).await?;
        skipped_blocks += blocks_per_iteration;

        let block = worker.view_block().await?;

        if block.epoch_id() != start_block.epoch_id() {
            break;
        }
    }

    println!("Fast-forwarded {} blocks.", skipped_blocks);

    Ok(())
}

'''
'''--- src/validator.rs ---
use near_sdk::json_types::U128;

use crate::*;

pub async fn validator_get_account_unstaked_balance(
    validator_contract: &Contract,
    user: &Account,
) -> anyhow::Result<u128> {
    let res: U128 = view_call(
        user,
        validator_contract,
        "get_account_unstaked_balance",
        json!({"account_id": user.id()}),
    )
    .await?
    .json()?;

    Ok(res.0)
}

pub async fn validator_get_account_staked_balance(
    validator_contract: &Contract,
    user: &Account,
) -> anyhow::Result<u128> {
    let res: U128 = view_call(
        user,
        validator_contract,
        "get_account_staked_balance",
        json!({"account_id": user.id()}),
    )
    .await?
    .json()?;

    Ok(res.0)
}

pub async fn validator_get_account_total_balance(
    validator_contract: &Contract,
    user: &Account,
) -> anyhow::Result<u128> {
    let res: U128 = view_call(
        user,
        validator_contract,
        "get_account_total_balance",
        json!({"account_id": user.id()}),
    )
    .await?
    .json()?;

    Ok(res.0)
}

pub async fn validator_is_account_unstaked_balance_available(
    validator_contract: &Contract,
    user: &Account,
) -> anyhow::Result<bool> {
    let res: bool = view_call(
        user,
        validator_contract,
        "is_account_unstaked_balance_available",
        json!({"account_id": user.id()}),
    )
    .await?
    .json()?;

    Ok(res)
}

pub async fn validator_get_account(
    validator_contract: &Contract,
    user: &Account,
) -> anyhow::Result<HumanReadableAccount> {
    let res: HumanReadableAccount = view_call(
        user,
        validator_contract,
        "get_account",
        json!({"account_id": user.id()}),
    )
    .await?
    .json()?;

    Ok(res)
}

'''