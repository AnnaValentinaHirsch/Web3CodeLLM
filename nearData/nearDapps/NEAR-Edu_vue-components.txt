*GitHub Repository "NEAR-Edu/vue-components"*

'''--- .eslintrc.json ---
{
  "parser": "@typescript-eslint/parser",
  "env": {
    "browser": true,
    "commonjs": true,
    "es6": true,
    "jest/globals": true
  },
  "extends": [
    "standard",
    "plugin:jest/recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:prettier/recommended"
  ],
  "plugins": ["jest", "prettier", "@typescript-eslint"],
  "rules": {
    "@typescript-eslint/camelcase": "off",
    "@typescript-eslint/explicit-function-return-type": "off",
    "@typescript-eslint/no-use-before-define": "off",
    "@typescript-eslint/explicit-module-boundary-types": "off"
  }
}

'''
'''--- .prettierrc.js ---
// prettier.config.js or .prettierrc.js
module.exports = {
  printWidth: 120,
  tabWidth: 2,
  semi: true,
  singleQuote: true,
  bracketSpacing: true,
  arrowParens: 'avoid',
  endOfLine: 'lf'
};

'''
'''--- README.md ---
# Installation

```sh
# install with yarn
yarn add @neardev/vue-use-near-api

# install with npm
npm install @neardev/vue-use-near-api
```

# Usage of wallet component

## Initialize near connection

near api require [initialization](https://docs.near.org/docs/develop/front-end/introduction#connection) to connect to near network.
To do this, you can use `initNear` function from vue-use-near-api package.
Don't forget the call of initNear must be come up before root component will be mounted and initNear will return promise.

```js
import { initNear } from '@neardev/vue-use-near-api';
const app = createApp(App);
const nearConfig = {
  ...getConfig('development'),
  appKeyPrefix: 'app',
  contractName: 'dev-1622023860692-5474128',
};
initNear(app, nearConfig).then(() => {
  app1.mount('#app');
});
```

for near configuration file, you can refer [this configuration example](https://github.com/near/create-near-app/blob/master/templates/vue/src/config.js)

## For multiple near sign in on the same page

currently, near api doesn't want to support multiple login on the same page, but you can try to implement it via this package.

```js
const app1 = createApp(App);
const nearConfig1 = {
  ...getConfig('development'),
  appKeyPrefix: 'app1',
  contractName: 'dev-1622023860692-5474128',
};
initNear(app1, nearConfig1).then(() => {
  app1.mount('#app1');
});

const nearConfig2 = {
  ...getConfig('development'),
  appKeyPrefix: 'app2',
  contractName: 'dev-1622023860692-5474128',
};

const app2 = createApp(App); // or maybe you can use another root component.
initNear(app2, nearConfig2).then(() => {
  app2.mount('#app2');
});
```

## Declarative Component

wallet component offers two styles to integrate near wallet api into your Vue.js app
Higher-order component(HOC) are better suited for most developers not familiar with composition api. Register the NearWallet components and use functions and data which are exported via v-slot.

```vue
<near-wallet #="{ isSignedIn, handleSignIn }">
  <div>
    <my-profile v-if="isSignedIn" />
    <my-button size="large" label="Log in" @click="handleSignIn" v-else />
  </div>
</near-wallet>
```

```js
import { NearWallet } from '@neardev/vue-use-near-api';

export default defineComponent({
  name: 'my-header',
  components: {
    MyButton,
    MyProfile,
    NearWallet,
  },
});
```

## Composition API

If you want more nice grained control, you can use `useNearWallet` function to compose near wallet logic into your component.

```js
import { useNearWallet } from '@neardev/vue-use-near-api';

export default defineComponent({
  components: {
    MyButton,
    MyProfile,
  },

  setup() {
    const { isSignedIn, handleSignIn, lastStatusCode } = useNearWallet();
    return {
      lastStatusCode,
      isSignedIn,
      handleSignIn,
    };
  },
});
```

Then, in your template, you can use functions and data as your demand.

```vue
<div>
  <my-profile v-if="isSignedIn" />
  <my-button size="large" label="Log in" @click="handleSignIn" v-else />
</div>
```

## State

The useNearWallet function exposes the following reactive state:

```js
import { useNearWallet } from '@neardev/vue-use-near-api';

const { 
  status, 
  lastStatusCode, 
  lastStatusMessage, 
  unitSymbol, 
  accountId, 
  amount, 
  formattedAmount, 
  isSignedIn 
} = useNearWallet();
```

| State             | Type                             | Description                                                                                                                                                                     |
|-------------------|----------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| status            | `MaybeRef<NearWalletStatus>`     | Show the status of wallet. Below describe kinds of details.                                                                                                                     |
| lastStatusCode    | `MaybeRef<NearWalletStatusCode>` | Show the detail code of wallet status. Below describe kinds of details.<br> You can use this value to make your vue component to supply user-friendly view of the wallet status |
| lastStatusMessage | `MaybeRef<string>`               | Show the default status message of wallet.                                                                                                                                      |
| unitSymbol        | `MaybeRef<string>`               | Near symbol `Ⓝ`.                                                                                                                                                                 |
| accountId         | `MaybeRef<string>`               | Account id string. ex : sherif.testnet                                                                                                                                           |
| amount            | `MaybeRef<string>`               | The amount with native format of Near. ex : 199.997772695975                                                                                                                                     |
| formattedAmount   | `MaybeRef<string>`               | The human readable format of amount. ex : 199997772695975000000000000 |
| isSignedIn        | `MaybeRef<boolean>`              | Show whether logged in or not.                                                                                                                                                  |

## Methods

| Signature              | Description                       |
|------------------------|-----------------------------------|
| handleSignIn(void)     | Sign in near network.             |
| handleSignOut(void)    | Sign out from near network        |
| handleSyncAmount(void) | Sync amount of the wallet account |

## Types

[MaybeRef](https://github.com/KittyDragon88/vue-use-near-api/blob/master/packages/vue-near-api-js/src/types.ts)

[NearWalletStatus](https://github.com/KittyDragon88/vue-use-near-api/blob/master/packages/vue-near-api-js/src/near-wallet/wallet-types.ts)

* `SUCCESS`: last action has been successed.

* `LOADING`: last action is working.

* `ERROR`: last action has resulted in error.

[NearWalletStatusCode](https://github.com/KittyDragon88/vue-use-near-api/blob/master/packages/vue-near-api-js/src/near-wallet/wallet-types.ts)
  
  * `INITAL`: connection action has successed.
    - status will be `SUCCESS`.
    - lastStatusMessage will be empty string.

  * `CONNECTION_FAILED`: connection action has been failed.
    - status will be `ERROR`.
    - lastStatusMessage will be `invalid connection`

  * `SIGN_IN_FAILED`: sign in action has been failed.
    - status will be `ERROR`.
    - lastStatusMessage will be `error while signing in near network`

  * `SIGNING_IN`: sign in action is doing now on.
    - status will be `LOADING`.
    - lastStatusMessage will be `signing in near network`

  * `SIGNED_IN`:  sign in action has successed.
    - status will be `SUCCESS`.
    - lastStatusMessage will be `signed in to near network`

  * `SYNC_FAILED`: sync account action has been failed.
    - status will be `ERROR`.
    - lastStatusMessage will be `syncing with near account`

  * `SYNCING`:  sync account action is doing now on.
    - status will be `LOADING`.
    - lastStatusMessage will be `error while syncing with near account`

  * `SYNCED`:  sync account action has successed.
    - status will be `SUCCESS`.
    - lastStatusMessage will be `synced with near account`

# Build this repository

in root directory, please type following command.

```sh
npx lerna bootstrap
```

## Build package

```sh
yarn build
```

## Build example app

- Link local package with example

```sh
cd ./packages/vue-near-api-js
yarn link

cd ./packages/wallet-example-ts
yarn link @neardev/vue-use-near-api
```

- Build app.

  then, in root directory

```sh
yarn serve
```

- Issue

  just now, if you encounter eslint problem for files built in package, then please try again(yarn serve).
  I already add eslint ignore pattern for this, but it not working well, but I will try to fix it soon.

# Documentation

After finishing the components for near api, then documentation will be written for detailed description for functions and data supported by this package.

# Contributing

# License

'''
'''--- commitlint.config.js ---
module.exports = {
  extends: ['@commitlint/config-conventional'],
  rules: {
    'body-leading-blank': [1, 'always'],
    'footer-leading-blank': [1, 'always'],
    'header-max-length': [2, 'always', 72],
    'scope-case': [2, 'always', 'lower-case'],
    'subject-case': [2, 'never', ['sentence-case', 'start-case', 'pascal-case', 'upper-case']],
    'subject-empty': [2, 'never'],
    'subject-full-stop': [2, 'never', '.'],
    'type-case': [2, 'always', 'lower-case'],
    'type-empty': [2, 'never'],
    'type-enum': [
      2,
      'always',
      ['build', 'chore', 'ci', 'docs', 'feat', 'fix', 'perf', 'refactor', 'revert', 'style', 'test', 'dev'],
    ],
  },
};

'''
'''--- jest.config.js ---
module.exports = {
  preset: 'ts-jest',
  rootDir: __dirname,
  testMatch: ['<rootDir>/packages/**/tests/**/*spec.[jt]s?(x)'],
  testPathIgnorePatterns: ['/helpers/', '/setup.ts'],
  collectCoverageFrom: ['packages/*/src/**/*.ts'],
  moduleFileExtensions: ['ts', 'tsx', 'js', 'json'],
  moduleNameMapper: {
    '^@/(.+)$': '<rootDir>/packages/$1/src',
  },
};

'''
'''--- lerna.json ---
{
  "packages": [
    "packages/*"
  ],
  "npmClient": "yarn",
  "version": "0.0.1-alpha.1",
  "useWorkspaces": true,
  "command": {
    "version": {
      "conventionalCommits": true,
      "message": "chore(release): publish"
    }
  }
}

'''
'''--- package.json ---
{
  "name": "use-near-api-monorepo",
  "private": true,
  "workspaces": [
    "packages/*"
  ],
  "description": "Wrapper of Near Api for Vue.js",
  "author": "Yegor Loginov <kittydragon88@gmail.com>",
  "license": "MIT",
  "homepage": "https://vue-use-near.near.org/",
  "repository": "https://github.com/sherif/vue-use-near-api",
  "scripts": {
    "test": "jest",
    "test:ci": "jest --ci --detectOpenHandles --runInBand",
    "lint": "eslint . '**/*.{js,jsx,ts,tsx}' --fix",
    "format": "prettier \"./**/*.ts\" --write",
    "build": "node scripts/build.js && cd ./packages/vue-near-api-js",
    "serve": "lerna bootstrap && cd ./packages/wallet-example-ts && vue-cli-service serve",
    "cover": "jest --coverage",
    "cover:ci": "jest --coverage --ci --runInBand --detectOpenHandles",
    "postversion": "npm run build",
    "docs:dev": "cd ./docs && npm run dev && cd -",
    "postinstall": "husky install"
  },
  "devDependencies": {
    "@commitlint/cli": "^12.0.1",
    "@commitlint/config-conventional": "^12.0.1",
    "@types/jest": "^26.0.22",
    "@typescript-eslint/eslint-plugin": "^4.19.0",
    "@typescript-eslint/parser": "^4.19.0",
    "chalk": "^4.1.0",
    "eslint": "^7.25.0",
    "eslint-config-prettier": "^8.1.0",
    "eslint-config-standard": "^16.0.2",
    "eslint-plugin-import": "^2.22.0",
    "eslint-plugin-jest": "^24.2.1",
    "eslint-plugin-node": "^11.1.0",
    "eslint-plugin-prettier": "^3.3.1",
    "eslint-plugin-promise": "^5.1.0",
    "eslint-plugin-standard": "^5.0.0",
    "fast-deep-equal": "^3.1.3",
    "filesize": "^6.1.0",
    "flush-promises": "^1.0.2",
    "fs-extra": "^10.0.0",
    "gzip-size": "^6.0.0",
    "husky": "^6.0.0",
    "jest": "^26.6.3",
    "klona": "^2.0.4",
    "lerna": "^4.0.0",
    "lint-staged": "^11.0.0",
    "prettier": "^2.2.1",
    "raf-stub": "^3.0.0",
    "rollup": "^2.43.1",
    "rollup-plugin-commonjs": "^10.1.0",
    "rollup-plugin-dts": "^3.0.1",
    "rollup-plugin-json": "^4.0.0",
    "rollup-plugin-node-resolve": "^5.2.0",
    "rollup-plugin-replace": "^2.2.0",
    "rollup-plugin-typescript2": "0.30.0",
    "terser": "^5.6.0",
    "ts-jest": "^26.5.3",
    "tslint-config-prettier": "^1.18.0",
    "tslint-config-standard": "^9.0.0",
    "typescript": "~4.1.5",
    "vue": "^3.0.0"
  },
  "peerDependencies": {
    "vue": "^3.0.0"
  },
  "lint-staged": {
    "*.ts": [
      "eslint --fix",
      "prettier --write",
      "jest --maxWorkers=1 --bail --findRelatedTests"
    ],
    "*.js": [
      "eslint --fix",
      "jest --maxWorkers=1 --bail --findRelatedTests"
    ]
  }
}

'''
'''--- packages/vue-near-api-js/README.md ---

'''
'''--- packages/vue-near-api-js/package-lock.json ---
{
  "name": "@neardev/vue-use-near-api",
  "version": "0.0.1-alpha.1",
  "lockfileVersion": 1
}

'''
'''--- packages/vue-near-api-js/package.json ---
{
  "name": "@neardev/vue-use-near-api",
  "version": "0.0.1-alpha.1",
  "description": "Near api js for Vue.js",
  "author": "Yegor Loginov <kittydragon88@gmail.com>",
  "license": "MIT",
  "module": "dist/vue-near-api-js.esm.js",
  "unpkg": "dist/vue-near-api-js.js",
  "main": "dist/vue-near-api-js.js",
  "types": "dist/vue-near-api-js.d.ts",
  "homepage": "https://vue-use-near.near.org/",
  "repository": "https://github.com/sherif/vue-use-near-api",
  "sideEffects": false,
  "keywords": [
    "VueJS",
    "Vue",
    "Near",
    "near",
    "wallet",
    "Wallet"
  ],
  "files": [
    "dist/*.js",
    "dist/*.d.ts"
  ],
  "dependencies": {
    "near-api-js": "^0.41.0"
  },  
  "peerDependencies": {
    "vue": "^3.0.0"
  }
}

'''
'''--- packages/vue-near-api-js/src/index.ts ---
export * from './near-wallet';
export { initNear } from './init';
export { NearNetworkConfig } from './types';

'''
'''--- packages/vue-near-api-js/src/init.ts ---
import * as NearAPI from 'near-api-js';
import { App } from 'vue';
import { NearNetworkConfig } from './types';

const { connect, keyStores, WalletConnection } = NearAPI;

export async function initNear(app: App, nearConfig: NearNetworkConfig): Promise<void> {
  console.log('initializing to connect near network');
  try {
    if (!app) {
      console.log('please call initNear after created App(root component) and before mounting it');
    }

    if (app.config.globalProperties.$walletConnection) {
      console.log('already connected to near network');
      return;
    }

    const near = await connect({
      ...nearConfig,
      keyStore: new keyStores.BrowserLocalStorageKeyStore(window.localStorage, `${nearConfig.appKeyPrefix}:keystore:`),
    });
    const walletConnection = new WalletConnection(near, nearConfig.appKeyPrefix);
    app.config.globalProperties.$walletConnection = walletConnection;
    app.config.globalProperties.$accountId = walletConnection.getAccountId();
    app.config.globalProperties.$config = nearConfig;
    app.config.globalProperties.$near = near;
    console.log('near initialized successfully');
  } catch (e) {
    // The connection function in near api js module, isn't going to return error when failed,
    // so I think there is no case which this code will be run.
    console.log('error while initializing');
    console.log('connect', e);
    throw new Error(e);
  }
}

'''
'''--- packages/vue-near-api-js/src/near-account/account-types.ts ---
import { Account, Near } from 'near-api-js';
import { MaybeRef } from '../types';

export interface PrivateNearAccountComposite {
  account: MaybeRef<Account | null>;
  near: MaybeRef<Near | null>;
  loadAccount(): Promise<void>;
  createAccount(accountName: string, publicKey: string, intialBalance: string): Promise<void>;
  deleteAccount(accountName: string): Promise<void>;
  getAccountBalance(): Promise<void>;
  getAccountDetails(): Promise<void>;
  sendMoney(recevierId: string, amount: string): Promise<void>;
  getState(): Promise<void>;
}

export type NearAccountComposable = PrivateNearAccountComposite;

'''
'''--- packages/vue-near-api-js/src/near-account/index.ts ---
export { NearAccountComposable } from './account-types';
export { useNearAccount } from './useNearAccount';

'''
'''--- packages/vue-near-api-js/src/near-account/useNearAccount.ts ---
import { Near } from 'near-api-js';
import { getCurrentInstance, reactive, toRef, toRefs, unref } from 'vue';
import { NearAccountComposable, PrivateNearAccountComposite } from './account-types';

export function useNearAccount(accountId: string): NearAccountComposable {
  const internalInstance = getCurrentInstance();
  const near = internalInstance ? internalInstance.appContext.config.globalProperties.$near : null;
  if (!near) {
    console.log(`you can't use near account without initializing`);
  }

  const state = reactive({
    account: null,
    near: near,
  }) as PrivateNearAccountComposite;

  const loadAccount = async (): Promise<void> => {
    const account = toRef(state, 'account');
    if (state.near) {
      try {
        account.value = await (unref(state.near) as Near).account(accountId);
      } catch (e) {
        console.log('error in loadAccount', e);
      }
    } else {
      console.log(`you can't call loadAccount method without near connection`);
    }
  };

  const createAccount = async (accountName: string, publicKey: string, intialBalance: string): Promise<void> => {
    const account = toRef(state, 'account');
    if (account && unref(account.value)) {
      try {
        const executionOutcome = await unref(account.value!).createAccount(accountName, publicKey, intialBalance);
        console.log(executionOutcome);
      } catch (e) {
        console.log('error in createAccount', e);
      }
    } else {
      console.log(`you can't call createAccount method without near connection`);
    }
  };

  const deleteAccount = async (accountName: string): Promise<void> => {
    const account = toRef(state, 'account');
    if (account && unref(account.value)) {
      try {
        const executionOutcome = await unref(account.value!).deleteAccount(accountName);
        console.log(executionOutcome);
      } catch (e) {
        console.log('error in deleteAccount', e);
      }
    } else {
      console.log(`you can't call deleteAccount method without near connection`);
    }
  };

  const getAccountBalance = async () => {
    const account = toRef(state, 'account');
    if (account && unref(account.value)) {
      try {
        const balance = await unref(account.value!).getAccountBalance();
        console.log(balance);
      } catch (e) {
        console.log('error in getAccountBalance', e);
      }
    } else {
      console.log(`you can't call getAccountBalance method without near connection`);
    }
  };

  const getAccountDetails = async () => {
    const account = toRef(state, 'account');
    if (account && unref(account.value)) {
      try {
        const { authorizedApps } = await unref(account.value!).getAccountDetails();
        console.log(authorizedApps);
      } catch (e) {
        console.log('error in getAccountDetails', e);
      }
    } else {
      console.log(`you can't call getAccountDetails method without near connection`);
    }
  };

  const sendMoney = async (recevierId: string, amount: string) => {
    const account = toRef(state, 'account');
    if (account && unref(account.value)) {
      try {
        const executionOutcome = await unref(account.value!).sendMoney(recevierId, amount);
        console.log(executionOutcome);
      } catch (e) {
        console.log('error in sendMoney', e);
      }
    } else {
      console.log(`you can't call sendMoney method without near connection`);
    }
  };

  const getState = async () => {
    const account = toRef(state, 'account');
    if (account && unref(account.value)) {
      try {
        const accountView = await unref(account.value!).state();
        console.log(accountView);
      } catch (e) {
        console.log('error in getState', e);
      }
    } else {
      console.log(`you can't call getState method without near connection`);
    }
  };

  return {
    ...toRefs(state),
    loadAccount,
    createAccount,
    deleteAccount,
    getAccountBalance,
    getAccountDetails,
    sendMoney,
    getState,
  } as NearAccountComposable;
}

'''
'''--- packages/vue-near-api-js/src/near-contract/contract-types.ts ---
import { Contract } from 'near-api-js';
import { MaybeRef } from '../types';

export interface PrivateNearContractComposite {
  contract: MaybeRef<Contract | null>;
  loadContract(): void;
  callContract(): void;
}

// derived from near api library

export interface ContractMethods {
  changeMethods: string[];
  viewMethods: string[];
}

export type NearContractComposable = PrivateNearContractComposite;

'''
'''--- packages/vue-near-api-js/src/near-contract/index.ts ---
export { useNearContract } from './useNearContract';
export { NearContractComposable } from './contract-types';

'''
'''--- packages/vue-near-api-js/src/near-contract/useNearContract.ts ---
import { Account, Contract } from 'near-api-js';
import { reactive, toRef, toRefs } from 'vue';
import { ContractMethods, PrivateNearContractComposite } from './contract-types';

export function useNearContract(account: Account, contractId: string, options: ContractMethods) {
  const state = reactive({
    contract: null,
  }) as PrivateNearContractComposite;

  const loadContract = async () => {
    const contract = toRef(state, 'contract');
    contract.value = new Contract(account, contractId, options);
    if (!contract.value) {
      console.log(`no contract to match the contractId: ${contractId}`);
    }
  };

  loadContract();

  const callContract = async (methodName: string) => {
    const contract = toRef(state, 'contract');
    if (contract.value) {
      // contract.value?[methodName as keyof Contract]();
    }
  };

  return {
    ...toRefs(state),
    loadContract,
    callContract,
  };
}

'''
'''--- packages/vue-near-api-js/src/near-wallet/NearWallet.ts ---
import { defineComponent } from '@vue/runtime-core';
import { useNearWallet } from './useNearWallet';
import { unref } from 'vue';

export const NearWallet = defineComponent({
  name: 'near-wallet',
  setup(props, { slots }) {
    const {
      status,
      lastStatusCode,
      lastStatusMessage,
      unitSymbol,
      accountId,
      amount,
      formattedAmount,
      isSignedIn,
      handleSignOut,
      handleSignIn,
      handleSyncAmount,
    } = useNearWallet();

    function slotProps() {
      return {
        status: unref(status),
        lastStatusCode: unref(lastStatusCode),
        lastStatusMessage: unref(lastStatusMessage),
        unitSymbol: unref(unitSymbol),
        accountId: unref(accountId),
        amount: unref(amount),
        formattedAmount: unref(formattedAmount),
        isSignedIn: unref(isSignedIn),
        handleSignOut,
        handleSignIn,
        handleSyncAmount,
      };
    }
    return () => slots.default?.(slotProps());
  },
});

'''
'''--- packages/vue-near-api-js/src/near-wallet/index.ts ---
export { NearWallet } from './NearWallet';
export { useNearWallet, useNearWalletStatus } from './useNearWallet';
export * from './wallet-symbols';
export { NearWalletStatus, NearWalletStatusCode, NearWalletComposable } from './wallet-types';

'''
'''--- packages/vue-near-api-js/src/near-wallet/useNearWallet.ts ---
import * as NearAPI from 'near-api-js';
import { computed, onMounted, reactive, provide, inject, toRefs, toRef, watch, getCurrentInstance } from 'vue';
import {
  NearWalletComposable,
  NearWalletStatus,
  NearWalletStatusCode,
  PrivateNearWalletComposite,
} from './wallet-types';
import { NearWalletContextSymbol } from './wallet-symbols';

const LOCAL_STORAGE_KEY_SUFFIX = '_wallet_auth_key';
const { utils } = NearAPI;

declare global {
  interface Window {
    walletConnection: any;
    accountId: any;
  }
}
export function useNearWallet(): NearWalletComposable {
  const internalInstance = getCurrentInstance();
  const walletConnection = internalInstance
    ? internalInstance.appContext.config.globalProperties.$walletConnection
    : null;
  const accountId = internalInstance ? internalInstance.appContext.config.globalProperties.$accountId : null;
  const nearConfig = internalInstance ? internalInstance.appContext.config.globalProperties.$config : null;

  const state = reactive({
    status: NearWalletStatus.SUCCESS,
    lastStatusCode: NearWalletStatusCode.INITAL,
    lastStatusMessage: '',
    unitSymbol: 'Ⓝ',
    accountId: accountId,
    amount: '',
    formattedAmount: '',
    isSignedIn: false,
    rawConnection: walletConnection,
    config: nearConfig,
  }) as PrivateNearWalletComposite;

  const setStatus = (newStatus: NearWalletStatus, newCode: NearWalletStatusCode, newMessage: string) => {
    const { status, lastStatusCode, lastStatusMessage } = toRefs(state);
    status.value = newStatus;
    lastStatusCode.value = newCode;
    lastStatusMessage.value = newMessage;
  };

  onMounted(async () => {
    const connection = toRef(state, 'rawConnection');
    const config = toRef(state, 'config');
    if (!connection.value) {
      console.log(`warning in package, connection not established.
      please try to check you did call the initNear function globally`);
      setStatus(NearWalletStatus.ERROR, NearWalletStatusCode.CONNECTION_FAILED, 'invalid connection');
      return;
    }

    /****************************
    After authorizing from near, page will be redrected here.
    At this time, near pakcage will initialize all of auth data(_authData) of wallet connection on this page
    as following,
    /// In WalletConnection's constructor
        if (!this.isSignedIn()) {
            this._completeSignInWithAccessKey();
        }
    so all wallet components will recognized as signed in already, because isSignedIn function only check if
    wallet connection's _authData is valid.
    so when you are going to use multiple wallet connection on the same page, then we have to check if the accounts
    of its network id exist.
    ****************************/

    const accounts = await connection.value._near.config.keyStore.getAccounts(config.value.networkId);
    if (connection.value.isSignedIn() && accounts && accounts.length > 0) {
      const isSignedIn = toRef(state, 'isSignedIn');
      isSignedIn.value = true;
      setStatus(NearWalletStatus.SUCCESS, NearWalletStatusCode.SIGNED_IN, 'signed in to near network');
      handleSyncAmount();
    } else {
      setStatus(NearWalletStatus.SUCCESS, NearWalletStatusCode.INITAL, '');
    }
  });

  const handleSignIn = () => {
    const connection = toRef(state, 'rawConnection');
    const nearConfig = toRef(state, 'config');
    // In multiple login situation, if authData of the app has already initialized by another signin, then clear it.
    const authDataKey = nearConfig.value.appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;
    window.localStorage.removeItem(authDataKey);

    setStatus(NearWalletStatus.LOADING, NearWalletStatusCode.SIGNING_IN, 'signing in near network');
    connection.value
      .requestSignIn(nearConfig.value.contractName)
      .then(() => {
        // // there's no need to make signed in flag to be true, because page will be refreshed.
        // const isSignedIn = toRef(state, 'isSignedIn');
        // isSignedIn.value = true;
        // setStatus(NearWalletStatus.SUCCESS, NearWalletStatusCode.SIGNED_IN, 'signed in to near network');
      })
      .catch((e: Error) => {
        console.log('handleSignIn', e);
        setStatus(NearWalletStatus.ERROR, NearWalletStatusCode.SIGN_IN_FAILED, 'error while signing in near network');
      });
  };

  const handleSignOut = () => {
    const connection = toRef(state, 'rawConnection');
    connection.value.signOut();
    // setStatus(NearWalletStatus.SUCCESS, NearWalletStatusCode.INITAL, '');
    // to render again.
    window.location.replace(window.location.origin + window.location.pathname);
  };

  function getAccountState(): Promise<any> {
    const connection = toRef(state, 'rawConnection');
    if (connection.value && connection.value.account()) {
      return connection.value.account().state();
    }
    return new Promise(resolve => {
      resolve(null);
    });
  }

  const handleSyncAmount = () => {
    setStatus(NearWalletStatus.LOADING, NearWalletStatusCode.SYNCING, 'syncing with near account');
    getAccountState()
      .then((res: any) => {
        setStatus(NearWalletStatus.SUCCESS, NearWalletStatusCode.SYNCED, 'synced with near account');
        const amount = toRef(state, 'amount');
        amount.value = res ? res.amount : '';
      })
      .catch(e => {
        console.log('getAccountState', e);
        setStatus(NearWalletStatus.ERROR, NearWalletStatusCode.SYNC_FAILED, 'error while syncing with near account');
      });
  };

  provide(NearWalletContextSymbol, {
    ...toRefs(state),
    handleSignIn,
    handleSignOut,
    handleSyncAmount,
  } as NearWalletComposable);

  const amount = toRef(state, 'amount');
  watch(amount, amount => {
    const formattedAmount = toRef(state, 'formattedAmount');
    formattedAmount.value = utils.format.formatNearAmount(amount);
  });

  return {
    ...toRefs(state),
    handleSignIn,
    handleSignOut,
    handleSyncAmount,
  } as NearWalletComposable;
}

export function useNearWalletStatus() {
  const walletState = inject(NearWalletContextSymbol);
  return computed(() => {
    return {
      status: walletState?.status,
      lastStatusCode: walletState?.lastStatusCode,
      lastStatusMessage: walletState?.lastStatusMessage,
    };
  });
}

'''
'''--- packages/vue-near-api-js/src/near-wallet/wallet-symbols.ts ---
import { InjectionKey } from '@vue/runtime-core';
import { NearWalletComposable } from './wallet-types';
export const NearWalletContextSymbol: InjectionKey<NearWalletComposable> = Symbol('near-wallet-api');

'''
'''--- packages/vue-near-api-js/src/near-wallet/wallet-types.ts ---
import { WalletConnection } from 'near-api-js';
import { MaybeRef, NearNetworkConfig } from '../types';

export enum NearWalletStatus {
  SUCCESS = 1,
  LOADING,
  ERROR,
}

export enum NearWalletStatusCode {
  INITAL = 1,
  CONNECTION_FAILED,
  SIGN_IN_FAILED,
  SIGNING_IN,
  SIGNED_IN,
  SYNC_FAILED,
  SYNCING,
  SYNCED,
}

export interface PrivateNearWalletComposite {
  accountId: MaybeRef<string>;
  amount: MaybeRef<string>;
  formattedAmount: MaybeRef<string>;
  status: MaybeRef<NearWalletStatus>;
  lastStatusCode: MaybeRef<NearWalletStatusCode>;
  lastStatusMessage: MaybeRef<string>;
  unitSymbol: MaybeRef<string>;
  isSignedIn: MaybeRef<boolean>;
  rawConnection: MaybeRef<WalletConnection>;
  config: NearNetworkConfig;
  handleSignOut(): void;
  handleSignIn(): void;
  handleSyncAmount(): void;
}

export type NearWalletComposable = Omit<PrivateNearWalletComposite, 'rawConnection' | 'config'>;

'''
'''--- packages/vue-near-api-js/src/types.ts ---
import { ComputedRef, Ref } from 'vue';
export type MaybeRef<T> = Ref<T> | ComputedRef<T> | T;

export interface NearNetworkConfig {
  appKeyPrefix: string;
  networkId: string;
  nodeUrl: string;
  contractName?: string;
  walletUrl?: string;
  helperUrl?: string;
  keyPath?: string;
  masterAccount?: string;
  explorerUrl?: string;
}

'''
'''--- packages/vue-near-api-js/tests/.eslintrc.json ---
{
  "rules": {
    "@typescript-eslint/no-explicit-any": "off"
  }
}

'''
'''--- packages/wallet-example-ts/.eslint.js ---
const path = require('path');
module.exports = {
  chainWebpack: config => {
    config.module
      .rule('eslint')
      .use('eslint-loader')
      .tap(options => {
        options.configFile = path.resolve(__dirname, ".eslintrc.js");
        return options;
      })
  },
  css: {
    loaderOptions: {
      postcss: {
        config:{
          path:__dirname
        }
      }
    }
  }
}
'''
'''--- packages/wallet-example-ts/.eslintrc.js ---
module.exports = {
  root: true,
  env: {
    node: true,
  },
  extends: [
    'plugin:vue/vue3-essential',
    'eslint:recommended',
    '@vue/typescript/recommended',
    '@vue/prettier',
    '@vue/prettier/@typescript-eslint',
  ],
  parserOptions: {
    ecmaVersion: 2020,
  },
  rules: {
    'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
  },
};

'''
'''--- packages/wallet-example-ts/README.md ---
# wallet-example-ts

## Project setup
```
npm install
```

### Compiles and hot-reloads for development
```
npm run serve
```

### Compiles and minifies for production
```
npm run build
```

### Customize configuration
See [Configuration Reference](https://cli.vuejs.org/config/).

'''
'''--- packages/wallet-example-ts/babel.config.js ---
module.exports = {
  presets: ['@vue/cli-plugin-babel/preset'],
};

'''
'''--- packages/wallet-example-ts/package.json ---
{
  "name": "wallet-example-ts",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "serve": "vue-cli-service serve",
    "build": "vue-cli-service build",
    "build:tailwind": "postcss src/scss/index.scss -o src/scss/tailwind.scss"
  },
  "dependencies": {
    "@vue/cli-plugin-babel": "~4.5.0",
    "@vue/cli-plugin-eslint": "~4.5.0",
    "@vue/cli-plugin-typescript": "~4.5.0",
    "@vue/cli-service": "~4.5.0",
    "@vue/compiler-sfc": "^3.0.0",
    "@vue/eslint-config-prettier": "^6.0.0",
    "@vue/eslint-config-typescript": "^7.0.0",
    "classnames": "^2.3.1",
    "core-js": "^3.6.5",
    "eslint-plugin-vue": "^7.0.0",
    "vue": "^3.0.0"
  },
  "devDependencies": {
    "node-sass": "4.14.1",
    "postcss": "^7.0.35",
    "postcss-cli": "^7.1.2",
    "sass-loader": "10.2.0",
    "tailwindcss": "npm:@tailwindcss/postcss7-compat@^2.1.2"
  }
}

'''
'''--- packages/wallet-example-ts/postcss.config.js ---
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

'''
'''--- packages/wallet-example-ts/public/index.html ---
<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <link rel="icon" href="<%= BASE_URL %>favicon.ico">
    <title><%= htmlWebpackPlugin.options.title %></title>
  </head>
  <body>
    <noscript>
      <strong>We're sorry but <%= htmlWebpackPlugin.options.title %> doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>
    </noscript>
    <div id="app1"></div>
    <div id="app2"></div>
    <!-- built files will be auto injected -->
  </body>
</html>

'''
'''--- packages/wallet-example-ts/src/config.ts ---
import type { NearNetworkConfig } from '@neardev/vue-use-near-api';
const CONTRACT_NAME = process.env.VUE_APP_DEFAULT_CONTRACT_NAME;
const APP_PREFIX = process.env.VUE_APP_DEFAULT_APP_PREFIX || 'null';

export default function getConfig(env: string): NearNetworkConfig {
  switch (env) {
    case 'production':
    case 'mainnet':
      return {
        appKeyPrefix: APP_PREFIX,
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.near.org',
        helperUrl: 'https://helper.mainnet.near.org',
        explorerUrl: 'https://explorer.mainnet.near.org',
      };
    case 'development':
    case 'testnet':
      return {
        appKeyPrefix: APP_PREFIX,
        networkId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org',
        explorerUrl: 'https://explorer.testnet.near.org',
      };
    case 'betanet':
      return {
        appKeyPrefix: APP_PREFIX,
        networkId: 'betanet',
        nodeUrl: 'https://rpc.betanet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.betanet.near.org',
        helperUrl: 'https://helper.betanet.near.org',
        explorerUrl: 'https://explorer.betanet.near.org',
      };
    case 'local':
      return {
        appKeyPrefix: APP_PREFIX,
        networkId: 'local',
        nodeUrl: 'http://localhost:3030',
        keyPath: `${process.env.HOME}/.near/validator_key.json`,
        walletUrl: 'http://localhost:4000/wallet',
        contractName: CONTRACT_NAME,
      };
    case 'test':
    case 'ci':
      return {
        appKeyPrefix: APP_PREFIX,
        networkId: 'shared-test',
        nodeUrl: 'https://rpc.ci-testnet.near.org',
        contractName: CONTRACT_NAME,
        masterAccount: 'test.near',
      };
    case 'ci-betanet':
      return {
        appKeyPrefix: APP_PREFIX,
        networkId: 'shared-test-staging',
        nodeUrl: 'https://rpc.ci-betanet.near.org',
        contractName: CONTRACT_NAME,
        masterAccount: 'test.near',
      };
    default:
      throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`);
  }
}

'''
'''--- packages/wallet-example-ts/src/main.ts ---
import { createApp } from 'vue';
import { initNear } from '@neardev/vue-use-near-api';
import App from './App.vue';
import './scss/tailwind.scss';
import getConfig from './config';

const app1 = createApp(App);
const nearConfig1 = {
  ...getConfig('development'),
  appKeyPrefix: 'app1',
  contractName: 'dev-1622023860692-5474128',
};
initNear(app1, nearConfig1).then(() => {
  app1.mount('#app1');
});

const nearConfig2 = {
  ...getConfig('development'),
  appKeyPrefix: 'app2',
  contractName: 'dev-1622023860692-5474128',
};

const app2 = createApp(App);
initNear(app2, nearConfig2).then(() => {
  app2.mount('#app2');
});

'''
'''--- packages/wallet-example-ts/src/shims-vue.d.ts ---
/* eslint-disable */
declare module '*.vue' {
  import type { DefineComponent } from 'vue'
  const component: DefineComponent<{}, {}, any>
  export default component
}

'''
'''--- packages/wallet-example-ts/tailwind.config.js ---
module.exports = {
  purge: ['./index.html', './src/**/*.{vue,js,ts,jsx,tsx}'],
  darkMode: false, // or 'media' or 'class'
  theme: {
    extend: {},
  },
  variants: {
    extend: {},
  },
  plugins: [],
}

'''
'''--- packages/wallet-example-ts/tsconfig.json ---
{
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "strict": true,
    "jsx": "preserve",
    "importHelpers": true,
    "moduleResolution": "node",
    "experimentalDecorators": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "sourceMap": true,
    "baseUrl": ".",
    "types": [
      "webpack-env"
    ],
    "paths": {
      "@/*": [
        "src/*"
      ]
    },
    "lib": [
      "esnext",
      "dom",
      "dom.iterable",
      "scripthost"
    ]
  },
  "include": [
    "src/**/*.ts",
    "src/**/*.tsx",
    "src/**/*.vue",
    "tests/**/*.ts",
    "tests/**/*.tsx"
, "src/components/Test.js"  ],
  "exclude": [
    "node_modules"
  ]
}

'''
'''--- scripts/.eslintrc.json ---
{
  "rules": {
    "@typescript-eslint/no-var-requires": "off"
  }
}

'''
'''--- scripts/build.js ---
const path = require('path');
const fs = require('fs-extra');
const { rollup } = require('rollup');
const chalk = require('chalk');
const Terser = require('terser');
const { createConfig } = require('./config');
const { reportSize } = require('./info');
const { generateDts } = require('./generate-dts');

async function minify({ code, pkg, bundleName }) {
  const pkgout = path.join(__dirname, `../packages/${pkg}/dist`);
  const output = await Terser.minify(code, {
    compress: true,
    mangle: true,
  });

  const fileName = bundleName.replace(/\.js$/, '.min.js');
  const filePath = `${pkgout}/${fileName}`;
  fs.outputFileSync(filePath, output.code);
  const stats = reportSize({ code: output.code, path: filePath });
  console.log(`${chalk.green('Output File:')} ${fileName} ${stats}`);
}

async function build(pkg) {
  console.log(chalk.magenta(`Generating bundle for ${pkg}`));
  const pkgout = path.join(__dirname, `../packages/${pkg}/dist`);
  for (const format of ['es', 'umd']) {
    const { input, output, bundleName } = createConfig(pkg, format);
    const bundle = await rollup(input);
    const {
      output: [{ code }],
    } = await bundle.generate(output);

    const outputPath = path.join(pkgout, bundleName);
    fs.outputFileSync(outputPath, code);
    const stats = reportSize({ code, path: outputPath });
    // eslint-disable-next-line
    console.log(`${chalk.green('Output File:')} ${bundleName} ${stats}`);

    if (format === 'umd') {
      await minify({ bundleName, pkg, code });
    }
  }

  await generateDts(pkg);
  console.log(`${chalk.magenta('✅ Bundled ' + pkg)}`);

  return true;
}

(async function Bundle() {
  const arg = [...process.argv][2];
  if (arg === 'vue-near-api-js' || !arg) {
    await build('vue-near-api-js');
  }

  // if (arg === 'near-api-rpc' || !arg) {
  //   await build('near-api-rpc');
  // }
})();

'''
'''--- scripts/config.js ---
const path = require('path');
const typescript = require('rollup-plugin-typescript2');
const replace = require('rollup-plugin-replace');
const resolve = require('rollup-plugin-node-resolve');
const commonjs = require('rollup-plugin-commonjs');
const json = require('rollup-plugin-json');

const formatNameMap = {
  'vue-near-api-js': 'NearApiJs',
  // 'near-api-rpc': 'NearApiRpc',
};

const pkgNameMap = {
  'vue-near-api-js': 'vue-near-api-js',
  // 'near-api-rpc': 'near-api-rpc',
};

const formatMap = {
  es: 'esm',
  umd: '',
};

function createConfig(pkg, format) {
  const tsPlugin = typescript({
    tsconfig: path.resolve(__dirname, '../tsconfig.json'),
    cacheRoot: path.resolve(__dirname, '../node_modules/.rts2_cache'),
    useTsconfigDeclarationDir: true,
    tsconfigOverride: {
      exclude: ['**/tests'],
    },
  });

  const version = require(path.resolve(__dirname, `../packages/${pkg}/package.json`)).version;

  const config = {
    input: {
      input: path.resolve(__dirname, `../packages/${pkg}/src/index.ts`),
      external: ['vue', 'near-api-js'],
      plugins: [
        tsPlugin,
        resolve({
          dedupe: ['fast-deep-equal/es6', 'fast-deep-equal', 'klona', 'klona/lite'],
        }),
        commonjs(),
        json(),
        replace({ __VERSION__: version }),
      ],
    },
    output: {
      banner: `/**
  * near-api v${version}
  * (c) ${new Date().getFullYear()} Yegor Loginov
  * @license MIT
  */`,
      format,
      name: format === 'umd' ? formatNameMap[pkg] : undefined,
      globals: {
        vue: 'Vue',
      },
    },
  };

  config.bundleName = `${pkgNameMap[pkg]}${formatMap[format] ? '.' + formatMap[format] : ''}.js`;

  // if (options.env) {
  //   config.input.plugins.unshift(
  //     replace({
  //       'process.env.NODE_ENV': JSON.stringify(options.env)
  //     })
  //   );
  // }

  return config;
}

module.exports = {
  formatNameMap,
  pkgNameMap,
  formatMap,
  createConfig,
};

'''
'''--- scripts/generate-dts.js ---
const ts = require('typescript');
const chalk = require('chalk');
const path = require('path');
const fs = require('fs-extra');
const { rollup } = require('rollup');
const { default: dts } = require('rollup-plugin-dts');
const tsconfig = require('../tsconfig.json');
const { pkgNameMap } = require('./config');

exports.generateDts = async function generateDts(pkg) {
  console.log(chalk.cyan(`Generating Declaration Files for ${pkg} ...`));
  const declarationDir = `../packages/${pkg}/dist/types`;

  const options = {
    ...tsconfig,
    declaration: true,
    declarationMap: false,
    emitDeclarationOnly: true,
    declarationDir,
  };

  const host = ts.createCompilerHost(options);
  const createdFiles = {};
  host.writeFile = (fileName, contents) => {
    createdFiles[fileName] = contents;
  };

  // Prepare and emit the d.ts files
  const program = ts.createProgram([path.resolve(__dirname, `../packages/${pkg}/src/index.ts`)], options, host);
  program.emit();
  for (const [file, contents] of Object.entries(createdFiles)) {
    fs.outputFileSync(path.resolve(__dirname, file), contents);
  }

  await bundleDts(declarationDir, pkg);
};

async function bundleDts(declarationDir, pkg) {
  let entry = path.join(__dirname, declarationDir, 'index.d.ts');
  // if it doesn't exist then probably was nested cause of relative imports
  if (!fs.existsSync(entry)) {
    entry = path.resolve(__dirname, declarationDir, pkg, 'src', 'index.d.ts');
  }

  // If we cannot find the 'index.d.ts', panic!
  if (!fs.existsSync(entry)) {
    throw new Error('Cannot find index.d.ts at' + entry);
  }

  // Generate .d.ts rollup
  const config = {
    input: entry,
    output: { file: `packages/${pkg}/dist/${pkgNameMap[pkg]}.d.ts`, format: 'es' },
    plugins: [dts()],
  };

  const bundle = await rollup(config);
  await bundle.write(config.output);
  await fs.remove(`packages/${pkg}/dist/types`);
  console.log(`${chalk.cyan('Bundled ' + pkg + ' Declaration Files...')}`);
}

'''
'''--- scripts/info.js ---
const fs = require('fs-extra');
const filesize = require('filesize');
const gzipSize = require('gzip-size');

function reportSize({ path, code }) {
  const { size } = fs.statSync(path);
  const gzipped = gzipSize.sync(code);

  return `| Size: ${filesize(size)} | Gzip: ${filesize(gzipped)}`;
}

module.exports = {
  reportSize,
};

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    "baseUrl": ".",
    "rootDir": ".",
    "moduleResolution": "node",
    "target": "es2017",
    "module": "esnext",
    "lib": ["esnext", "es2017", "dom"],
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,
    "noImplicitAny": true,
    "strict": true,
    "strictNullChecks": true,
    "strictBindCallApply": true,
    "strictFunctionTypes": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "typeRoots": ["node_modules/@types"],
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "resolveJsonModule": true,
    "paths": {    
      "@/*": ["packages/*/src"]
    }
  },
  "include": ["packages/*/src", "packages/*/tests"],
  "exclude": ["jest.config.js"]
}

'''