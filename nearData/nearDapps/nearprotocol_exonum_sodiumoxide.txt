*GitHub Repository "nearprotocol/exonum_sodiumoxide"*

'''--- .travis.yml ---
language: rust

rust:
  - stable

cache: cargo
sudo: required
dist: trusty

before_install:
- cargo-audit -V || cargo install cargo-audit --force
- sudo add-apt-repository -y ppa:elt/libsodium
- sudo apt-get -qq update
- cargo install --list

install:
- sudo apt-get -qq --yes install gcc g++ make libssl-dev libsodium-dev

script:
- cargo build
- cargo audit
- cargo test

notifications:
  slack:
    rooms:
      secure: EyQW22NjyDYiuWelsszt3cYgcZXHbEWiJMzYb7X5ovkAeX1Bm/FMGwaX8d9OGoebfY/NpAho8s1cX05vTxWT4N6sKsLACTcQI5te0fgiy8KVaL8ep1XpDi3JQQEDf/cVZkUlfDHE//gfDmY4boOQlejWXjmeLiYpV6rFW2yk+PDFDTS7J/GCTFxcdpqy+smdccUoJaJNpKH65fXaLSSPdZoWK2cnHb9RYEPIuwa9mCSlV+nfL0TSUUrDvcQu/dOkU92KFVHFSgzXIUm3u/UlN8MZPnrZ4DJ5uXqMzmCj2fSaP6625CvzNQBs/p93pIHC/XAL2MAUnZsiQtBQ7/cLEdQpYK8vXWilVuyZ6GFJ6KTQ7OXLD5Ka+KtkdcvGFMOgu0KfMVpaCvzT8yCOxv9G0Ld9XxZBQM5Ly+gpQPqEiov44zimHUfoaH6OlJI9dNiTnZCAeS7W9rpmuruG3ld23bru4YCgNXK3IfQ98tZESO4YCke36adnKuu1qiLWUOcS7svRojFYBiNJjCh54YZiM95aNMyJ1XYTo/SLWWIZ4RflfSWcc0XR2Qv9iNJjT5uACIeUtmjii492PLSz3NtLq/xoP6VCAbSb7yVbyC4BZuGE2scaduSce+1st8g5rDWFrVmNXBCVdz/au20+OOQR2JAiw1UPSNhwl/JS9GR/4Ck=

'''
'''--- Cargo.toml ---
[package]
authors = ["dnaq", "The Exonum Team <exonum@bitfury.com>"]
description = "Fast cryptographic library for Rust (bindings to libsodium)"
documentation = "https://docs.rs/exonum_sodiumoxide"
keywords = ["crypto", "NaCl", "libsodium"]
license = "MIT OR Apache-2.0"
name = "exonum_sodiumoxide"
readme = "README.md"
repository = "https://github.com/exonum/exonum_sodiumoxide"
version = "0.0.20"

[badges]
appveyor = { repository = "exonum/exonum_sodiumoxide" }
travis-ci = { repository = "exonum/exonum_sodiumoxide" }

[dependencies]
libc = "0.2.42"
exonum_libsodium-sys = { version = "0.0.20", path = "libsodium-sys" }
serde = { version="1.0.66", optional = true }

[dev-dependencies]
serde = "1"
serde_json = "1.0.21"
rustc-serialize = "0.3.24"
rmp-serde = "0.13.7"

[features]
std = []
default = ["serde", "std"]

'''
'''--- README.md ---
sodiumoxide
===========

[![Build Status](https://travis-ci.org/exonum/exonum_sodiumoxide.svg?branch=master)](https://travis-ci.org/exonum/exonum_sodiumoxide)
[![Build status](https://ci.appveyor.com/api/projects/status/v8fsl1hd6dq9bct1?svg=true)](https://ci.appveyor.com/project/DarkEld3r/exonum-sodiumoxide)

> [NaCl](http://nacl.cr.yp.to) (pronounced "salt") is a new easy-to-use high-speed software library for network communication, encryption, decryption, signatures, etc. NaCl's goal is to provide all of the core operations needed to build higher-level cryptographic tools.
> Of course, other libraries already exist for these core operations. NaCl advances the state of the art by improving security, by improving usability, and by improving speed.

> [Sodium](https://github.com/jedisct1/libsodium) is a portable, cross-compilable, installable, packageable fork of NaCl (based on the latest released upstream version nacl-20110221), with a compatible API.

This package aims to provide a type-safe and efficient Rust binding that's just
as easy to use.

Dependencies
------------

[Sodium](https://github.com/jedisct1/libsodium)

Building
--------
    cargo build

Testing
-------
    cargo test

Documentation
-------------
    cargo doc

Documentation will be generated in target/doc/...

Most documentation is taken from NaCl, with minor modification where the API
differs between the C and Rust versions.

Documentation for the latest build can be found at
[gh-pages](https://dnaq.github.io/sodiumoxide).

Optional features
-----------------

Several [optional features](http://doc.crates.io/manifest.html#usage-in-end-products) are available:

* `std` (default: **enabled**). When this feature is disabled,
  sodiumoxide builds using `#![no_std]`. Some functionality may be lost.
  Requires a nightly build of Rust.

* `serde` (default: **enabled**). Allows serialization and deserialization of
  keys, authentication tags, etc. using the
  [serde library](https://crates.io/crates/serde).

* `benchmarks` (default: **disabled**). Compile benchmark tests. Requires a
  nightly build of Rust.

Examples
--------
```rust
extern crate exonum_sodiumoxide;

exonum_sodiumoxide::init();
```

Join in
=======
File bugs in the issue tracker

Master git repository

    git clone https://github.com/exonum/exonum_sodiumoxide.git

License
-------

Licensed under either of

 * Apache License, Version 2.0, ([LICENSE-APACHE](LICENSE-APACHE) or http://www.apache.org/licenses/LICENSE-2.0)
 * MIT license ([LICENSE-MIT](LICENSE-MIT) or http://opensource.org/licenses/MIT)

at your option.

### Contribution

Unless you explicitly state otherwise, any contribution intentionally
submitted for inclusion in the work by you, as defined in the Apache-2.0
license, shall be dual licensed as above, without any additional terms or
conditions.

'''
'''--- appveyor.yml ---
os: Visual Studio 2015

cache:
  - '%USERPROFILE%\.cargo'
  - target

environment:
  matrix:
    - channel: stable
      target: x86_64-pc-windows-msvc
    - channel: beta
      target: x86_64-pc-windows-msvc
    - channel: nightly
      target: x86_64-pc-windows-msvc

matrix:
  allow_failures:
    - channel: nightly

install:
  - appveyor DownloadFile https://win.rustup.rs/ -FileName rustup-init.exe
  - rustup-init -yv --default-toolchain %channel% --default-host %target%
  - set PATH=%PATH%;%USERPROFILE%\.cargo\bin
  - rustc -vV
  - cargo -vV

build: false

test_script:
  - cargo build --verbose
  - cargo test --verbose

'''
'''--- libsodium-sys/Cargo.toml ---
[package]
authors = ["dnaq", "The Exonum Team <exonum@bitfury.com>"]
build = "build.rs"
description = "FFI binding to libsodium"
documentation = "https://dnaq.github.io/sodiumoxide"
keywords = ["libsodium", "NaCl", "crypto"]
license = "MIT OR Apache-2.0"
links = "sodium"
name = "exonum_libsodium-sys"
repository = "https://github.com/exonum/exonum_sodiumoxide.git"
version = "0.0.20"

[build-dependencies]
pkg-config = "0.3.11"
flate2 = "1.0.1"
libc = "0.2.42"
tar = "0.4.15"
zip = "0.4.0"
num_cpus = "1.8.0"
cc = { version = "1.0", features = ["parallel"] }

[dependencies]
libc = "0.2"

[lib]
name = "libsodium_sys"
path = "lib.rs"

'''
'''--- libsodium-sys/build.rs ---
extern crate num_cpus;
extern crate pkg_config;

const VERSION: &'static str = "1.0.16";
const MIN_VERSION: &'static str = "1.0.12";

#[cfg(not(windows))]
fn main() {
    use std::env;

    let mut should_build = false;

    let force_build = match env::var("SODIUM_BUILD").ok() {
        None => false,
        Some(ref x) if x == "0" => false,
        Some(_) => true,
    };

    if force_build {
        should_build = true;
    } else {
        if let Ok(lib_dir) = env::var("SODIUM_LIB_DIR") {
            println!("cargo:rustc-link-search=native={}", lib_dir);
            let mode = match env::var_os("SODIUM_STATIC") {
                Some(_) => "static",
                None => "dylib",
            };
            println!("cargo:rustc-link-lib={0}=sodium", mode);
            println!(
                "cargo:warning=Using unknown libsodium version. This crate is tested against \
                 {} and may not be fully compatible with other versions.",
                VERSION
            );
        } else if let Ok(lib_details) = pkg_config::Config::new()
            .atleast_version(MIN_VERSION)
            .probe("libsodium")
        {
            println!(" === found libsodium: {:#?}", lib_details);
            if lib_details.version != VERSION {
                println!(
                    "cargo:warning=Using libsodium version {}. This crate is tested against {} \
                     and may not be fully compatible with {}.",
                    lib_details.version, VERSION, lib_details.version
                );
            }
        } else {
            should_build = true;
        }
    }

    if should_build {
        use flate2::read::GzDecoder;
        use std::env;
        use std::fs::{self, File};
        use std::process::Command;
        use tar::Archive;

        // Download gz tarball
        let basename = "libsodium-".to_string() + VERSION;
        let gz_filename = basename.clone() + ".tar.gz";
        let url = "https://github.com/jedisct1/libsodium/releases/download/".to_string() + VERSION
            + "/" + &gz_filename;
        let mut install_dir = get_install_dir();
        let mut source_dir = env::var("OUT_DIR").unwrap() + "/source";
        // Avoid issues with paths containing spaces by falling back to using /tmp
        let target = env::var("TARGET").unwrap();
        if install_dir.contains(" ") {
            let fallback_path = "/tmp/".to_string() + &basename + "/" + &target;
            install_dir = fallback_path.clone() + "/installed";
            source_dir = fallback_path.clone() + "/source";
            println!(
                "cargo:warning=The path to the usual build directory contains spaces and hence \
                 can't be used to build libsodium.  Falling back to use {}.  If running `cargo \
                 clean`, ensure you also delete this fallback directory",
                fallback_path
            );
        }
        let gz_path = source_dir.clone() + "/" + &gz_filename;
        fs::create_dir_all(&install_dir).unwrap();
        fs::create_dir_all(&source_dir).unwrap();

        let mut curl_cmd = Command::new("curl");
        let curl_output = curl_cmd
            .arg(&url)
            .arg("-sSLvo")
            .arg(&gz_path)
            .output()
            .unwrap_or_else(|error| {
                panic!("Failed to run curl command: {}", error);
            });
        if !curl_output.status.success() {
            panic!(
                "\n{:?}\n{}\n{}\n",
                curl_cmd,
                String::from_utf8_lossy(&curl_output.stdout),
                String::from_utf8_lossy(&curl_output.stderr)
            );
        }

        // Unpack the tarball
        let gz_archive = File::open(&gz_path).unwrap();
        let gz_decoder = GzDecoder::new(gz_archive);
        let mut archive = Archive::new(gz_decoder);
        archive.unpack(&source_dir).unwrap();
        source_dir.push_str(&format!("/{}", basename));

        // Clean up
        let _ = fs::remove_file(gz_path);

        // Run `./configure`
        let build = cc::Build::new();
        let (cc, cflags) = if target.contains("i686") {
            (
                format!("{} -m32", build.get_compiler().path().display()),
                env::var("CFLAGS").unwrap_or(String::from(" -march=i686 -O3")),
            )
        } else {
            (
                format!("{}", build.get_compiler().path().display()),
                env::var("CFLAGS").unwrap_or(String::from(" -march=native -O3")),
            )
        };
        let prefix_arg = format!("--prefix={}", install_dir);
        let host = env::var("HOST").unwrap();
        let host_arg = format!("--host={}", target);
        let cross_compiling = target != host;
        let help = if cross_compiling {
            "***********************************************************\n\
             Possible missing dependencies.\n\
             See https://github.com/maidsafe/rust_sodium#cross-compiling\n\
             ***********************************************************\n\n"
        } else {
            ""
        };

        // Disable PIE for Ubuntu < 15.04 (see https://github.com/jedisct1/libsodium/issues/292)
        let get_disable_pie_arg = || {
            const DISABLE_PIE: &str = "--disable-pie";

            let mut lsb_release_cmd = Command::new("lsb_release");
            let lsb_release_output = lsb_release_cmd.arg("-irs").output();
            let lsb_release_output = match lsb_release_output {
                Ok(output) => output,
                Err(error) => {
                    println!("Failed to run 'lsb_release -irs': {}", error);
                    // Treat "Failed to execute the command" as "any other distribution".
                    return DISABLE_PIE;
                }
            };
            if !lsb_release_output.status.success() {
                panic!(
                    "\n{:?}\n{}\n{}\n",
                    lsb_release_cmd,
                    String::from_utf8_lossy(&lsb_release_output.stdout),
                    String::from_utf8_lossy(&lsb_release_output.stderr)
                );
            }
            let stdout = String::from_utf8_lossy(&lsb_release_output.stdout);

            let mut lines = stdout.split(|c: char| c.is_whitespace());
            let distro = lines.next().expect("Missing distributive name");
            let version = lines.next().expect("Missing distributive version");

            let mut lines = version.split('.');
            let major: u32 = lines
                .next()
                .expect("Missing major version")
                .parse()
                .expect("Major version is not a number");

            match distro {
                "Ubuntu" if major < 15 => DISABLE_PIE,
                // Exclude 16.04 LTS - see https://jira.bf.local/browse/ECR-846
                "Ubuntu" if version == "16.04" => DISABLE_PIE,
                "Ubuntu" => "",
                // Any other distribution.
                _ => DISABLE_PIE,
            }
        };
        let disable_pie_arg = get_disable_pie_arg();

        let mut configure_cmd = Command::new("./configure");
        let configure_output = configure_cmd
            .current_dir(&source_dir)
            .env("CC", &cc)
            .env("CFLAGS", &cflags)
            .arg(&prefix_arg)
            .arg(&host_arg)
            .arg("--enable-shared=no")
            .arg(disable_pie_arg)
            .output()
            .unwrap_or_else(|error| {
                panic!("Failed to run './configure': {}\n{}", error, help);
            });
        if !configure_output.status.success() {
            panic!(
                "\n{:?}\nCFLAGS={}\nCC={}\n{}\n{}\n{}\n",
                configure_cmd,
                cflags,
                cc,
                String::from_utf8_lossy(&configure_output.stdout),
                String::from_utf8_lossy(&configure_output.stderr),
                help
            );
        }

        // Run `make clean`
        let mut clean_cmd = Command::new("make");
        let clean_output = clean_cmd
            .current_dir(&source_dir)
            .arg("clean")
            .output()
            .unwrap_or_else(|error| {
                panic!("Failed to run 'make clean': {}\n{}", error, help);
            });
        if !clean_output.status.success() {
            panic!(
                "\n{:?}\n{}\n{}\n{}\n{}\n",
                clean_cmd,
                String::from_utf8_lossy(&configure_output.stdout),
                String::from_utf8_lossy(&clean_output.stdout),
                String::from_utf8_lossy(&clean_output.stderr),
                help
            );
        }

        // Run `make check`, or `make all` if we're cross-compiling
        let j_arg = format!("-j{}", num_cpus::get());
        let make_arg = if cross_compiling { "all" } else { "check" };
        let mut make_cmd = Command::new("make");
        let make_output = make_cmd
            .current_dir(&source_dir)
            .env("V", "1")
            .arg(make_arg)
            .arg(&j_arg)
            .output()
            .unwrap_or_else(|error| {
                panic!("Failed to run 'make {}': {}\n{}", make_arg, error, help);
            });
        if !make_output.status.success() {
            panic!(
                "\n{:?}\n{}\n{}\n{}\n{}\n{}",
                make_cmd,
                String::from_utf8_lossy(&configure_output.stdout),
                String::from_utf8_lossy(&clean_output.stdout),
                String::from_utf8_lossy(&make_output.stdout),
                String::from_utf8_lossy(&make_output.stderr),
                help
            );
        }

        // Run `make install`
        let mut install_cmd = Command::new("make");
        let install_output = install_cmd
            .current_dir(&source_dir)
            .arg("install")
            .output()
            .unwrap_or_else(|error| {
                panic!("Failed to run 'make install': {}", error);
            });
        if !install_output.status.success() {
            panic!(
                "\n{:?}\n{}\n{}\n{}\n{}\n{}\n",
                install_cmd,
                String::from_utf8_lossy(&configure_output.stdout),
                String::from_utf8_lossy(&clean_output.stdout),
                String::from_utf8_lossy(&make_output.stdout),
                String::from_utf8_lossy(&install_output.stdout),
                String::from_utf8_lossy(&install_output.stderr)
            );
        }

        println!("cargo:rustc-link-lib=static=sodium");
        println!("cargo:rustc-link-search=native={}/lib", install_dir);
        println!("cargo:include={}/include", install_dir);
    }
}

#[cfg(all(not(windows), not(feature = "use-installed-libsodium")))]
extern crate cc;
#[cfg(all(not(target_env = "msvc"), not(feature = "use-installed-libsodium")))]
extern crate flate2;
#[cfg(all(target_env = "msvc", not(feature = "use-installed-libsodium")))]
extern crate libc;
#[cfg(all(not(target_env = "msvc"), not(feature = "use-installed-libsodium")))]
extern crate tar;
#[cfg(all(target_env = "msvc", not(feature = "use-installed-libsodium")))]
extern crate zip;

#[cfg(not(feature = "use-installed-libsodium"))]
fn get_install_dir() -> String {
    use std::env;
    env::var("OUT_DIR").unwrap() + "/installed"
}

#[cfg(all(windows, not(feature = "use-installed-libsodium")))]
fn check_powershell_version() {
    let mut check_ps_version_cmd = ::std::process::Command::new("powershell");
    let check_ps_version_output = check_ps_version_cmd
        .arg("-Command")
        .arg("{If ($PSVersionTable.PSVersion.Major -lt 4) { exit 1 }}")
        .output()
        .unwrap_or_else(|error| {
            panic!("Failed to run powershell command: {}", error);
        });
    if !check_ps_version_output.status.success() {
        panic!(
            "\n{:?}\n{}\n{}\nYou must have Powershell v4.0 or greater installed.\n\n",
            check_ps_version_cmd,
            String::from_utf8_lossy(&check_ps_version_output.stdout),
            String::from_utf8_lossy(&check_ps_version_output.stderr)
        );
    }
}

#[cfg(all(windows, not(feature = "use-installed-libsodium")))]
fn download_compressed_file() -> String {
    use std::process::Command;

    let basename = "libsodium-".to_string() + VERSION;
    let zip_filename = if cfg!(target_env = "msvc") {
        basename.clone() + "-msvc.zip"
    } else {
        basename.clone() + "-mingw.tar.gz"
    };
    let url = "https://download.libsodium.org/libsodium/releases/".to_string() + &zip_filename;
    let zip_path = get_install_dir() + "/" + &zip_filename;
    let command = "([Net.ServicePointManager]::SecurityProtocol = 'Tls12') -and \
                   ((New-Object System.Net.WebClient).DownloadFile(\""
        .to_string() + &url + "\", \"" + &zip_path + "\"))";
    let mut download_cmd = Command::new("powershell");
    let download_output = download_cmd
        .arg("-Command")
        .arg(&command)
        .output()
        .unwrap_or_else(|error| {
            panic!("Failed to run powershell download command: {}", error);
        });
    if !download_output.status.success() {
        panic!(
            "\n{:?}\n{}\n{}\n",
            download_cmd,
            String::from_utf8_lossy(&download_output.stdout),
            String::from_utf8_lossy(&download_output.stderr)
        );
    }
    zip_path
}

#[cfg(all(windows, target_env = "msvc", not(feature = "use-installed-libsodium")))]
fn main() {
    use libc::S_IFDIR;
    use std::fs::{self, File};
    use std::io::{Read, Write};
    use std::path::Path;
    use zip::ZipArchive;

    check_powershell_version();

    // Download zip file
    let install_dir = get_install_dir();
    let lib_install_dir = Path::new(&install_dir).join("lib");
    fs::create_dir_all(&lib_install_dir).unwrap();
    let zip_path = download_compressed_file();

    // Unpack the zip file
    let zip_file = File::open(&zip_path).unwrap();
    let mut zip_archive = ZipArchive::new(zip_file).unwrap();

    // Extract just the appropriate version of libsodium.lib and headers to the install path.  For
    // now, only handle MSVC 2015.
    let arch_path = if cfg!(target_pointer_width = "32") {
        Path::new("Win32")
    } else if cfg!(target_pointer_width = "64") {
        Path::new("x64")
    } else {
        panic!("target_pointer_width not 32 or 64")
    };

    let unpacked_lib = arch_path.join("Release/v140/static/libsodium.lib");
    for i in 0..zip_archive.len() {
        let mut entry = zip_archive.by_index(i).unwrap();
        let entry_name = entry.name().to_string();
        let entry_path = Path::new(&entry_name);
        let opt_install_path = if entry_path.starts_with("include") {
            let is_dir = (entry.unix_mode().unwrap() & S_IFDIR as u32) != 0;
            if is_dir {
                let _ = fs::create_dir(&Path::new(&install_dir).join(entry_path));
                None
            } else {
                Some(Path::new(&install_dir).join(entry_path))
            }
        } else if entry_path == unpacked_lib {
            Some(lib_install_dir.join("libsodium.lib"))
        } else {
            None
        };
        if let Some(full_install_path) = opt_install_path {
            let mut buffer = Vec::with_capacity(entry.size() as usize);
            assert_eq!(entry.size(), entry.read_to_end(&mut buffer).unwrap() as u64);
            let mut file = File::create(&full_install_path).unwrap();
            file.write_all(&buffer).unwrap();
        }
    }

    // Clean up
    let _ = fs::remove_file(zip_path);

    println!("cargo:rustc-link-lib=static=libsodium");
    println!(
        "cargo:rustc-link-search=native={}",
        lib_install_dir.display()
    );
    println!("cargo:include={}/include", install_dir);
}

#[cfg(all(windows, not(target_env = "msvc"), not(feature = "use-installed-libsodium")))]
fn main() {
    use flate2::read::GzDecoder;
    use std::fs::{self, File};
    use std::path::Path;
    use tar::Archive;

    check_powershell_version();

    // Download gz tarball
    let install_dir = get_install_dir();
    let lib_install_dir = Path::new(&install_dir).join("lib");
    fs::create_dir_all(&lib_install_dir).unwrap();
    let gz_path = download_compressed_file();

    // Unpack the tarball
    let gz_archive = File::open(&gz_path).unwrap();
    let gz_decoder = GzDecoder::new(gz_archive).unwrap();
    let mut archive = Archive::new(gz_decoder);

    // Extract just the appropriate version of libsodium.a and headers to the install path
    let arch_path = if cfg!(target_pointer_width = "32") {
        Path::new("libsodium-win32")
    } else if cfg!(target_pointer_width = "64") {
        Path::new("libsodium-win64")
    } else {
        panic!("target_pointer_width not 32 or 64")
    };

    let unpacked_include = arch_path.join("include");
    let unpacked_lib = arch_path.join("lib\\libsodium.a");
    let entries = archive.entries().unwrap();
    for entry_result in entries {
        let mut entry = entry_result.unwrap();
        let entry_path = entry.path().unwrap().to_path_buf();
        let full_install_path = if entry_path.starts_with(&unpacked_include) {
            let include_file = entry_path.strip_prefix(arch_path).unwrap();
            Path::new(&install_dir).join(include_file)
        } else if entry_path == unpacked_lib {
            lib_install_dir.join("libsodium.a")
        } else {
            continue;
        };
        entry.unpack(full_install_path).unwrap();
    }

    // Clean up
    let _ = fs::remove_file(gz_path);

    println!("cargo:rustc-link-lib=static=sodium");
    println!(
        "cargo:rustc-link-search=native={}",
        lib_install_dir.display()
    );
    println!("cargo:include={}/include", install_dir);
}

'''
'''--- libsodium-sys/lib.rs ---
#![allow(non_upper_case_globals)]

extern crate libc;
use libc::{c_char, c_int, c_ulonglong, c_void, size_t};

include!("src/core.rs");

include!("src/crypto_aead_chacha20poly1305.rs");

include!("src/crypto_auth.rs");
include!("src/crypto_auth_hmacsha256.rs");
include!("src/crypto_auth_hmacsha512.rs");
include!("src/crypto_auth_hmacsha512256.rs");

include!("src/crypto_box.rs");
include!("src/crypto_box_curve25519xsalsa20poly1305.rs");

include!("src/crypto_core_hsalsa20.rs");
include!("src/crypto_core_salsa20.rs");
include!("src/crypto_core_salsa2012.rs");
include!("src/crypto_core_salsa208.rs");

include!("src/crypto_generichash.rs");
include!("src/crypto_generichash_blake2b.rs");

include!("src/crypto_hash.rs");
include!("src/crypto_hash_sha256.rs");
include!("src/crypto_hash_sha512.rs");

include!("src/crypto_onetimeauth.rs");
include!("src/crypto_onetimeauth_poly1305.rs");

include!("src/crypto_pwhash_scryptsalsa208sha256.rs");

include!("src/crypto_scalarmult.rs");
include!("src/crypto_scalarmult_curve25519.rs");

include!("src/crypto_secretbox.rs");
include!("src/crypto_secretbox_xsalsa20poly1305.rs");
include!("src/crypto_shorthash_siphash24.rs");
include!("src/crypto_sign_ed25519.rs");

include!("src/crypto_stream.rs");
include!("src/crypto_stream_chacha20.rs");
include!("src/crypto_stream_salsa20.rs");
include!("src/crypto_stream_salsa2012.rs");
include!("src/crypto_stream_salsa208.rs");
include!("src/crypto_stream_xsalsa20.rs");

include!("src/crypto_verify_16.rs");
include!("src/crypto_verify_32.rs");
include!("src/crypto_verify_64.rs");

include!("src/randombytes.rs");
include!("src/utils.rs");
include!("src/version.rs");

'''
'''--- libsodium-sys/src/core.rs ---
// core.h

extern {
    pub fn sodium_init() -> c_int;
}

'''
'''--- libsodium-sys/src/crypto_aead_chacha20poly1305.rs ---
// crypto_aead_chacha20poly1305.h

pub const crypto_aead_chacha20poly1305_KEYBYTES: usize = 32;
pub const crypto_aead_chacha20poly1305_NSECBYTES: usize = 0;
pub const crypto_aead_chacha20poly1305_NPUBBYTES: usize = 8;
pub const crypto_aead_chacha20poly1305_ABYTES: usize = 16;

pub const crypto_aead_chacha20poly1305_ietf_KEYBYTES: usize = 32;
pub const crypto_aead_chacha20poly1305_ietf_NSECBYTES: usize = 0;
pub const crypto_aead_chacha20poly1305_ietf_NPUBBYTES: usize = 12;
pub const crypto_aead_chacha20poly1305_ietf_ABYTES: usize = 16;

extern {
    pub fn crypto_aead_chacha20poly1305_keybytes() -> size_t;
    pub fn crypto_aead_chacha20poly1305_nsecbytes() -> size_t;
    pub fn crypto_aead_chacha20poly1305_npubbytes() -> size_t;
    pub fn crypto_aead_chacha20poly1305_abytes() -> size_t;

    pub fn crypto_aead_chacha20poly1305_ietf_keybytes() -> size_t;
    pub fn crypto_aead_chacha20poly1305_ietf_nsecbytes() -> size_t;
    pub fn crypto_aead_chacha20poly1305_ietf_npubbytes() -> size_t;
    pub fn crypto_aead_chacha20poly1305_ietf_abytes() -> size_t;

    pub fn crypto_aead_chacha20poly1305_encrypt(
        c: *mut u8,
        clen: *mut c_ulonglong,
        m: *const u8,
        mlen: c_ulonglong,
        ad: *const u8,
        adlen: c_ulonglong,
        nsec: *const [u8; crypto_aead_chacha20poly1305_NSECBYTES],
        npub: *const [u8; crypto_aead_chacha20poly1305_NPUBBYTES],
        k: *const [u8; crypto_aead_chacha20poly1305_KEYBYTES]) -> c_int;
    pub fn crypto_aead_chacha20poly1305_decrypt(
        m: *mut u8,
        mlen: *mut c_ulonglong,
        nsec: *mut [u8; crypto_aead_chacha20poly1305_NSECBYTES],
        c: *const u8,
        clen: c_ulonglong,
        ad: *const u8,
        adlen: c_ulonglong,
        npub: *const [u8; crypto_aead_chacha20poly1305_NPUBBYTES],
        k: *const [u8; crypto_aead_chacha20poly1305_KEYBYTES]) -> c_int;
    pub fn crypto_aead_chacha20poly1305_encrypt_detached(
        c: *mut u8,
        mac: *mut u8,
        maclen_p: *mut c_ulonglong,
        m: *const u8,
        mlen: c_ulonglong,
        ad: *const u8,
        adlen: c_ulonglong,
        nsec: *const [u8; crypto_aead_chacha20poly1305_NSECBYTES],
        npub: *const [u8; crypto_aead_chacha20poly1305_NPUBBYTES],
        k: *const [u8; crypto_aead_chacha20poly1305_KEYBYTES]) -> c_int;
    pub fn crypto_aead_chacha20poly1305_decrypt_detached(
        m: *mut u8,
        nsec: *mut [u8; crypto_aead_chacha20poly1305_NSECBYTES],
        c: *const u8,
        clen: c_ulonglong,
        mac: *const u8,
        ad: *const u8,
        adlen: c_ulonglong,
        npub: *const [u8; crypto_aead_chacha20poly1305_NPUBBYTES],
        k: *const [u8; crypto_aead_chacha20poly1305_KEYBYTES]) -> c_int;

    pub fn crypto_aead_chacha20poly1305_ietf_encrypt(
        c: *mut u8,
        clen: *mut c_ulonglong,
        m: *const u8,
        mlen: c_ulonglong,
        ad: *const u8,
        adlen: c_ulonglong,
        nsec: *const [u8; crypto_aead_chacha20poly1305_ietf_NSECBYTES],
        npub: *const [u8; crypto_aead_chacha20poly1305_ietf_NPUBBYTES],
        k: *const [u8; crypto_aead_chacha20poly1305_ietf_KEYBYTES]) -> c_int;
    pub fn crypto_aead_chacha20poly1305_ietf_decrypt(
        m: *mut u8,
        mlen: *mut c_ulonglong,
        nsec: *mut [u8; crypto_aead_chacha20poly1305_ietf_NSECBYTES],
        c: *const u8,
        clen: c_ulonglong,
        ad: *const u8,
        adlen: c_ulonglong,
        npub: *const [u8; crypto_aead_chacha20poly1305_ietf_NPUBBYTES],
        k: *const [u8; crypto_aead_chacha20poly1305_ietf_KEYBYTES]) -> c_int;
    pub fn crypto_aead_chacha20poly1305_ietf_encrypt_detached(
        c: *mut u8,
        mac: *mut u8,
        maclen_p: *mut c_ulonglong,
        m: *const u8,
        mlen: c_ulonglong,
        ad: *const u8,
        adlen: c_ulonglong,
        nsec: *const [u8; crypto_aead_chacha20poly1305_ietf_NSECBYTES],
        npub: *const [u8; crypto_aead_chacha20poly1305_ietf_NPUBBYTES],
        k: *const [u8; crypto_aead_chacha20poly1305_ietf_KEYBYTES]) -> c_int;
    pub fn crypto_aead_chacha20poly1305_ietf_decrypt_detached(
        m: *mut u8,
        nsec: *mut [u8; crypto_aead_chacha20poly1305_ietf_NSECBYTES],
        c: *const u8,
        clen: c_ulonglong,
        mac: *const u8,
        ad: *const u8,
        adlen: c_ulonglong,
        npub: *const [u8; crypto_aead_chacha20poly1305_ietf_NPUBBYTES],
        k: *const [u8; crypto_aead_chacha20poly1305_ietf_KEYBYTES]) -> c_int;
}

#[test]
fn test_crypto_aead_chacha20poly1305_keybytes() {
    assert!(unsafe { crypto_aead_chacha20poly1305_keybytes() as usize } ==
            crypto_aead_chacha20poly1305_KEYBYTES)
}
#[test]
fn test_crypto_aead_chacha20poly1305_nsecbytes() {
    assert!(unsafe { crypto_aead_chacha20poly1305_nsecbytes() as usize } ==
            crypto_aead_chacha20poly1305_NSECBYTES)
}
#[test]
fn test_crypto_aead_chacha20poly1305_npubbytes() {
    assert!(unsafe { crypto_aead_chacha20poly1305_npubbytes() as usize } ==
            crypto_aead_chacha20poly1305_NPUBBYTES)
}
#[test]
fn test_crypto_aead_chacha20poly1305_abytes() {
    assert!(unsafe { crypto_aead_chacha20poly1305_abytes() as usize } ==
            crypto_aead_chacha20poly1305_ABYTES)
}

#[test]
fn test_crypto_aead_chacha20poly1305_ietf_keybytes() {
    assert!(unsafe { crypto_aead_chacha20poly1305_ietf_keybytes() as usize } ==
            crypto_aead_chacha20poly1305_ietf_KEYBYTES)
}
#[test]
fn test_crypto_aead_chacha20poly1305_ietf_nsecbytes() {
    assert!(unsafe { crypto_aead_chacha20poly1305_ietf_nsecbytes() as usize } ==
            crypto_aead_chacha20poly1305_ietf_NSECBYTES)
}
#[test]
fn test_crypto_aead_chacha20poly1305_ietf_npubbytes() {
    assert!(unsafe { crypto_aead_chacha20poly1305_ietf_npubbytes() as usize } ==
            crypto_aead_chacha20poly1305_ietf_NPUBBYTES)
}
#[test]
fn test_crypto_aead_chacha20poly1305_ietf_abytes() {
    assert!(unsafe { crypto_aead_chacha20poly1305_ietf_abytes() as usize } ==
            crypto_aead_chacha20poly1305_ietf_ABYTES)
}
'''
'''--- libsodium-sys/src/crypto_auth.rs ---
// crypto_auth.h

pub const crypto_auth_BYTES: usize = crypto_auth_hmacsha512256_BYTES;
pub const crypto_auth_KEYBYTES: usize = crypto_auth_hmacsha512256_KEYBYTES;
pub const crypto_auth_PRIMITIVE: &str = "hmacsha512256";

extern {
    pub fn crypto_auth_bytes() -> size_t;
    pub fn crypto_auth_keybytes() -> size_t;
    pub fn crypto_auth_primitive() -> *const c_char;
    pub fn crypto_auth(a: *mut [u8; crypto_auth_BYTES],
                       m: *const u8,
                       mlen: c_ulonglong,
                       k: *const [u8; crypto_auth_KEYBYTES]) -> c_int;
    pub fn crypto_auth_verify(a: *const [u8; crypto_auth_BYTES],
                              m: *const u8,
                              mlen: c_ulonglong,
                              k: *const [u8; crypto_auth_KEYBYTES]) -> c_int;
}

#[test]
fn test_crypto_auth_bytes() {
    assert!(unsafe { crypto_auth_bytes() as usize } == crypto_auth_BYTES)
}
#[test]
fn test_crypto_auth_keybytes() {
    assert!(unsafe { crypto_auth_keybytes() as usize } ==
            crypto_auth_KEYBYTES)
}
#[test]
fn test_crypto_auth_primitive() {
    unsafe {
        let s = crypto_auth_primitive();
        let s = std::ffi::CStr::from_ptr(s).to_bytes();
        assert!(s == crypto_auth_PRIMITIVE.as_bytes());
    }
}

'''
'''--- libsodium-sys/src/crypto_auth_hmacsha256.rs ---
// crypto_auth_hmacsha256.h

#[repr(C)]
#[derive(Copy, Clone)]
pub struct crypto_auth_hmacsha256_state {
    ictx: crypto_hash_sha256_state,
    octx: crypto_hash_sha256_state,
}

pub const crypto_auth_hmacsha256_BYTES: usize = 32;
pub const crypto_auth_hmacsha256_KEYBYTES: usize = 32;

extern {
    pub fn crypto_auth_hmacsha256_bytes() -> size_t;
    pub fn crypto_auth_hmacsha256_keybytes() -> size_t;
    pub fn crypto_auth_hmacsha256(
        a: *mut [u8; crypto_auth_hmacsha256_BYTES],
        m: *const u8,
        mlen: c_ulonglong,
        k: *const [u8; crypto_auth_hmacsha256_KEYBYTES]) -> c_int;
    pub fn crypto_auth_hmacsha256_verify(
        a: *const [u8; crypto_auth_hmacsha256_BYTES],
        m: *const u8,
        mlen: c_ulonglong,
        k: *const [u8; crypto_auth_hmacsha256_KEYBYTES]) -> c_int;
    pub fn crypto_auth_hmacsha256_init(
        state: *mut crypto_auth_hmacsha256_state,
        key: *const u8,
        keylen: size_t) -> c_int;
    pub fn crypto_auth_hmacsha256_update(
        state: *mut crypto_auth_hmacsha256_state,
        m: *const u8,
        mlen: c_ulonglong) -> c_int;
    pub fn crypto_auth_hmacsha256_final(
        state: *mut crypto_auth_hmacsha256_state,
        a: *mut [u8; crypto_auth_hmacsha256_BYTES]) -> c_int;
}

#[test]
fn test_crypto_auth_hmacsha256_bytes() {
    assert!(unsafe { crypto_auth_hmacsha256_bytes() as usize } ==
            crypto_auth_hmacsha256_BYTES)
}
#[test]
fn test_crypto_auth_hmacsha256_keybytes() {
    assert!(unsafe { crypto_auth_hmacsha256_keybytes() as usize } ==
            crypto_auth_hmacsha256_KEYBYTES)
}

'''
'''--- libsodium-sys/src/crypto_auth_hmacsha512.rs ---
// crypto_auth_hmacsha512.h

#[repr(C)]
#[derive(Copy, Clone)]
pub struct crypto_auth_hmacsha512_state {
    ictx: crypto_hash_sha512_state,
    octx: crypto_hash_sha512_state,
}

pub const crypto_auth_hmacsha512_BYTES: usize = 64;
pub const crypto_auth_hmacsha512_KEYBYTES: usize = 32;

extern {
    pub fn crypto_auth_hmacsha512_bytes() -> size_t;
    pub fn crypto_auth_hmacsha512_keybytes() -> size_t;
    pub fn crypto_auth_hmacsha512(
        a: *mut [u8; crypto_auth_hmacsha512_BYTES],
        m: *const u8,
        mlen: c_ulonglong,
        k: *const [u8; crypto_auth_hmacsha512_KEYBYTES]) -> c_int;
    pub fn crypto_auth_hmacsha512_verify(
        a: *const [u8; crypto_auth_hmacsha512_BYTES],
        m: *const u8,
        mlen: c_ulonglong,
        k: *const [u8; crypto_auth_hmacsha512_KEYBYTES]) -> c_int;
    pub fn crypto_auth_hmacsha512_init(
        state: *mut crypto_auth_hmacsha512_state,
        key: *const u8,
        keylen: size_t) -> c_int;
    pub fn crypto_auth_hmacsha512_update(
        state: *mut crypto_auth_hmacsha512_state,
        m: *const u8,
        mlen: c_ulonglong) -> c_int;
    pub fn crypto_auth_hmacsha512_final(
        state: *mut crypto_auth_hmacsha512_state,
        a: *mut [u8; crypto_auth_hmacsha512_BYTES]) -> c_int;
}

#[test]
fn test_crypto_auth_hmacsha512_bytes() {
    assert!(unsafe { crypto_auth_hmacsha512_bytes() as usize } ==
            crypto_auth_hmacsha512_BYTES)
}
#[test]
fn test_crypto_auth_hmacsha512_keybytes() {
    assert!(unsafe { crypto_auth_hmacsha512_keybytes() as usize } ==
            crypto_auth_hmacsha512_KEYBYTES)
}

'''
'''--- libsodium-sys/src/crypto_auth_hmacsha512256.rs ---
// crypto_auth_hmacsha512256.h

#[allow(non_camel_case_types)]
pub type crypto_auth_hmacsha512256_state = crypto_auth_hmacsha512_state;

pub const crypto_auth_hmacsha512256_BYTES: usize = 32;
pub const crypto_auth_hmacsha512256_KEYBYTES: usize = 32;

extern {
    pub fn crypto_auth_hmacsha512256_bytes() -> size_t;
    pub fn crypto_auth_hmacsha512256_keybytes() -> size_t;
    pub fn crypto_auth_hmacsha512256(
        a: *mut [u8; crypto_auth_hmacsha512256_BYTES],
        m: *const u8,
        mlen: c_ulonglong,
        k: *const [u8; crypto_auth_hmacsha512256_KEYBYTES]) -> c_int;
    pub fn crypto_auth_hmacsha512256_verify(
        a: *const [u8; crypto_auth_hmacsha512256_BYTES],
        m: *const u8,
        mlen: c_ulonglong,
        k: *const [u8; crypto_auth_hmacsha512256_KEYBYTES]) -> c_int;
    pub fn crypto_auth_hmacsha512256_init(
        state: *mut crypto_auth_hmacsha512256_state,
        key: *const u8,
        keylen: size_t) -> c_int;
    pub fn crypto_auth_hmacsha512256_update(
        state: *mut crypto_auth_hmacsha512256_state,
        m: *const u8,
        mlen: c_ulonglong) -> c_int;
    pub fn crypto_auth_hmacsha512256_final(
        state: *mut crypto_auth_hmacsha512256_state,
        a: *mut [u8; crypto_auth_hmacsha512256_BYTES]) -> c_int;
}

#[test]
fn test_crypto_auth_hmacsha512256_bytes() {
    assert!(unsafe { crypto_auth_hmacsha512256_bytes() as usize } ==
            crypto_auth_hmacsha512256_BYTES)
}
#[test]
fn test_crypto_auth_hmacsha512256_keybytes() {
    assert!(unsafe { crypto_auth_hmacsha512256_keybytes() as usize } ==
            crypto_auth_hmacsha512256_KEYBYTES)
}

'''
'''--- libsodium-sys/src/crypto_box.rs ---
// crypto_box.h

pub const crypto_box_SEEDBYTES: usize = crypto_box_curve25519xsalsa20poly1305_SEEDBYTES;
pub const crypto_box_PUBLICKEYBYTES: usize = crypto_box_curve25519xsalsa20poly1305_PUBLICKEYBYTES;
pub const crypto_box_SECRETKEYBYTES: usize = crypto_box_curve25519xsalsa20poly1305_SECRETKEYBYTES;
pub const crypto_box_BEFORENMBYTES: usize = crypto_box_curve25519xsalsa20poly1305_BEFORENMBYTES;
pub const crypto_box_NONCEBYTES: usize = crypto_box_curve25519xsalsa20poly1305_NONCEBYTES;
pub const crypto_box_ZEROBYTES: usize = crypto_box_curve25519xsalsa20poly1305_ZEROBYTES;
pub const crypto_box_BOXZEROBYTES: usize = crypto_box_curve25519xsalsa20poly1305_BOXZEROBYTES;
pub const crypto_box_MACBYTES: usize = crypto_box_curve25519xsalsa20poly1305_MACBYTES;
pub const crypto_box_PRIMITIVE: &str = "curve25519xsalsa20poly1305";
pub const crypto_box_SEALBYTES: usize = (crypto_box_PUBLICKEYBYTES + crypto_box_MACBYTES);

extern {
    pub fn crypto_box_seedbytes() -> size_t;
    pub fn crypto_box_publickeybytes() -> size_t;
    pub fn crypto_box_secretkeybytes() -> size_t;
    pub fn crypto_box_beforenmbytes() -> size_t;
    pub fn crypto_box_noncebytes() -> size_t;
    pub fn crypto_box_zerobytes() -> size_t;
    pub fn crypto_box_boxzerobytes() -> size_t;
    pub fn crypto_box_macbytes() -> size_t;
    pub fn crypto_box_primitive() -> *const c_char;
    pub fn crypto_box_sealbytes() -> size_t;

    pub fn crypto_box_seed_keypair(
        pk: *mut [u8; crypto_box_PUBLICKEYBYTES],
        sk: *mut [u8; crypto_box_SECRETKEYBYTES],
        seed: *const [u8; crypto_box_SEEDBYTES])
        -> c_int;
    pub fn crypto_box_keypair(
        pk: *mut [u8; crypto_box_PUBLICKEYBYTES],
        sk: *mut [u8; crypto_box_SECRETKEYBYTES])
        -> c_int;
    pub fn crypto_box_beforenm(
        k: *mut [u8; crypto_box_BEFORENMBYTES],
        pk: *const [u8; crypto_box_PUBLICKEYBYTES],
        sk: *const [u8; crypto_box_SECRETKEYBYTES])
        -> c_int;
    pub fn crypto_box_afternm(
        c: *mut u8,
        m: *const u8,
        mlen: c_ulonglong,
        n: *const [u8; crypto_box_NONCEBYTES],
        k: *const [u8; crypto_box_BEFORENMBYTES])
        -> c_int;
    pub fn crypto_box_open_afternm(
        m: *mut u8,
        c: *const u8,
        clen: c_ulonglong,
        n: *const [u8; crypto_box_NONCEBYTES],
        k: *const [u8; crypto_box_BEFORENMBYTES])
        -> c_int;
    pub fn crypto_box(
        c: *mut u8,
        m: *const u8,
        mlen: c_ulonglong,
        n: *const [u8; crypto_box_NONCEBYTES],
        pk: *const [u8; crypto_box_PUBLICKEYBYTES],
        sk: *const [u8; crypto_box_SECRETKEYBYTES])
        -> c_int;
    pub fn crypto_box_open(
        m: *mut u8,
        c: *const u8,
        clen: c_ulonglong,
        n: *const [u8; crypto_box_NONCEBYTES],
        pk: *const [u8; crypto_box_PUBLICKEYBYTES],
        sk: *const [u8; crypto_box_SECRETKEYBYTES])
        -> c_int;
    pub fn crypto_box_easy(
        c: *mut u8,
        m: *const u8,
        mlen: c_ulonglong,
        n: *const [u8; crypto_box_NONCEBYTES],
        pk: *const [u8; crypto_box_PUBLICKEYBYTES],
        sk: *const [u8; crypto_box_SECRETKEYBYTES])
        -> c_int;
    pub fn crypto_box_open_easy(
        m: *mut u8,
        c: *const u8,
        clen: c_ulonglong,
        n: *const [u8; crypto_box_NONCEBYTES],
        pk: *const [u8; crypto_box_PUBLICKEYBYTES],
        sk: *const [u8; crypto_box_SECRETKEYBYTES])
        -> c_int;
    pub fn crypto_box_detached(
        c: *mut u8,
        mac: *mut [u8; crypto_box_MACBYTES],
        m: *const u8,
        mlen: c_ulonglong,
        n: *const [u8; crypto_box_NONCEBYTES],
        pk: *const [u8; crypto_box_PUBLICKEYBYTES],
        sk: *const [u8; crypto_box_SECRETKEYBYTES])
        -> c_int;
    pub fn crypto_box_open_detached(
        m: *mut u8,
        c: *const u8,
        mac: *const [u8; crypto_box_MACBYTES],
        clen: c_ulonglong,
        n: *const [u8; crypto_box_NONCEBYTES],
        pk: *const [u8; crypto_box_PUBLICKEYBYTES],
        sk: *const [u8; crypto_box_SECRETKEYBYTES])
        -> c_int;
    pub fn crypto_box_detached_afternm(
        c: *mut u8,
        mac: *mut [u8; crypto_box_MACBYTES],
        m: *const u8,
        mlen: c_ulonglong,
        n: *const [u8; crypto_box_NONCEBYTES],
        k: *const [u8; crypto_box_BEFORENMBYTES])
        -> c_int;
    pub fn crypto_box_open_detached_afternm(
        m: *mut u8,
        c: *const u8,
        mac: *const [u8; crypto_box_MACBYTES],
        clen: c_ulonglong,
        n: *const [u8; crypto_box_NONCEBYTES],
        k: *const [u8; crypto_box_BEFORENMBYTES])
        -> c_int;
    pub fn crypto_box_seal(
        c: *mut u8,
        m: *const u8,
        mlen: c_ulonglong,
        pk: *const [u8; crypto_box_PUBLICKEYBYTES])
        -> c_int;
    pub fn crypto_box_seal_open(
        m: *mut u8,
        c: *const u8,
        clen: c_ulonglong,
        pk: *const [u8; crypto_box_PUBLICKEYBYTES],
        sk: *const [u8; crypto_box_SECRETKEYBYTES])
        -> c_int;
    pub fn crypto_box_easy_afternm(
        c: *mut u8,
        m: *const u8,
        mlen: c_ulonglong,
        n: *const [u8; crypto_box_NONCEBYTES],
        k: *const [u8; crypto_box_BEFORENMBYTES])
        -> c_int;
    pub fn crypto_box_open_easy_afternm(
        m: *mut u8,
        c: *const u8,
        clen: c_ulonglong,
        n: *const [u8; crypto_box_NONCEBYTES],
        k: *const [u8; crypto_box_BEFORENMBYTES])
        -> c_int;
}

#[test]
fn test_crypto_box_seedbytes() {
    assert!(unsafe {
        crypto_box_seedbytes() as usize
    } == crypto_box_SEEDBYTES)
}
#[test]
fn test_crypto_box_publickeybytes() {
    assert!(unsafe {
        crypto_box_publickeybytes() as usize
    } == crypto_box_PUBLICKEYBYTES)
}
#[test]
fn test_crypto_box_secretkeybytes() {
    assert!(unsafe {
        crypto_box_secretkeybytes() as usize
    } == crypto_box_SECRETKEYBYTES)
}
#[test]
fn test_crypto_box_beforenmbytes() {
    assert!(unsafe {
        crypto_box_beforenmbytes() as usize
    } == crypto_box_BEFORENMBYTES)
}
#[test]
fn test_crypto_box_noncebytes() {
    assert!(unsafe {
        crypto_box_noncebytes() as usize
    } == crypto_box_NONCEBYTES)
}
#[test]
fn test_crypto_box_zerobytes() {
    assert!(unsafe {
        crypto_box_zerobytes() as usize
    } == crypto_box_ZEROBYTES)
}
#[test]
fn test_crypto_box_boxzerobytes() {
    assert!(unsafe {
        crypto_box_boxzerobytes() as usize
    } == crypto_box_BOXZEROBYTES)
}
#[test]
fn test_crypto_box_macbytes() {
    assert!(unsafe {
        crypto_box_macbytes() as usize
    } == crypto_box_MACBYTES)
}
#[test]
fn test_crypto_box_primitive() {
    unsafe {
        let s = crypto_box_primitive();
        let s = std::ffi::CStr::from_ptr(s).to_bytes();
        assert!(s == crypto_box_PRIMITIVE.as_bytes());
    }
}
#[test]
fn test_crypto_box_sealbytes() {
    assert!(unsafe {
        crypto_box_sealbytes() as usize

    } == crypto_box_SEALBYTES)
}

'''
'''--- libsodium-sys/src/crypto_box_curve25519xsalsa20poly1305.rs ---
// crypto_box_curve25519xsalsa20poly1305.h

pub const crypto_box_curve25519xsalsa20poly1305_SEEDBYTES: usize = 32;
pub const crypto_box_curve25519xsalsa20poly1305_PUBLICKEYBYTES: usize = 32;
pub const crypto_box_curve25519xsalsa20poly1305_SECRETKEYBYTES: usize = 32;
pub const crypto_box_curve25519xsalsa20poly1305_BEFORENMBYTES: usize = 32;
pub const crypto_box_curve25519xsalsa20poly1305_NONCEBYTES: usize = 24;
pub const crypto_box_curve25519xsalsa20poly1305_ZEROBYTES: usize = 32;
pub const crypto_box_curve25519xsalsa20poly1305_BOXZEROBYTES: usize = 16;
pub const crypto_box_curve25519xsalsa20poly1305_MACBYTES: usize =
    crypto_box_curve25519xsalsa20poly1305_ZEROBYTES -
    crypto_box_curve25519xsalsa20poly1305_BOXZEROBYTES;

extern {
    pub fn crypto_box_curve25519xsalsa20poly1305_keypair(
        pk: *mut [u8; crypto_box_curve25519xsalsa20poly1305_PUBLICKEYBYTES],
        sk: *mut [u8; crypto_box_curve25519xsalsa20poly1305_SECRETKEYBYTES])
        -> c_int;
    pub fn crypto_box_curve25519xsalsa20poly1305(
        c: *mut u8,
        m: *const u8,
        mlen: c_ulonglong,
        n: *const [u8; crypto_box_curve25519xsalsa20poly1305_NONCEBYTES],
        pk: *const [u8; crypto_box_curve25519xsalsa20poly1305_PUBLICKEYBYTES],
        sk: *const [u8; crypto_box_curve25519xsalsa20poly1305_SECRETKEYBYTES])
        -> c_int;
    pub fn crypto_box_curve25519xsalsa20poly1305_open(
        m: *mut u8,
        c: *const u8,
        clen: c_ulonglong,
        n: *const [u8; crypto_box_curve25519xsalsa20poly1305_NONCEBYTES],
        pk: *const [u8; crypto_box_curve25519xsalsa20poly1305_PUBLICKEYBYTES],
        sk: *const [u8; crypto_box_curve25519xsalsa20poly1305_SECRETKEYBYTES])
        -> c_int;
    pub fn crypto_box_curve25519xsalsa20poly1305_beforenm(
        k: *mut [u8; crypto_box_curve25519xsalsa20poly1305_BEFORENMBYTES],
        pk: *const [u8; crypto_box_curve25519xsalsa20poly1305_PUBLICKEYBYTES],
        sk: *const [u8; crypto_box_curve25519xsalsa20poly1305_SECRETKEYBYTES])
        -> c_int;
    pub fn crypto_box_curve25519xsalsa20poly1305_afternm(
        c: *mut u8,
        m: *const u8,
        mlen: c_ulonglong,
        n: *const [u8; crypto_box_curve25519xsalsa20poly1305_NONCEBYTES],
        k: *const [u8; crypto_box_curve25519xsalsa20poly1305_BEFORENMBYTES])
        -> c_int;
    pub fn crypto_box_curve25519xsalsa20poly1305_open_afternm(
        m: *mut u8,
        c: *const u8,
        clen: c_ulonglong,
        n: *const [u8; crypto_box_curve25519xsalsa20poly1305_NONCEBYTES],
        k: *const [u8; crypto_box_curve25519xsalsa20poly1305_BEFORENMBYTES])
        -> c_int;
    pub fn crypto_box_curve25519xsalsa20poly1305_seedbytes() -> size_t;
    pub fn crypto_box_curve25519xsalsa20poly1305_publickeybytes() -> size_t;
    pub fn crypto_box_curve25519xsalsa20poly1305_secretkeybytes() -> size_t;
    pub fn crypto_box_curve25519xsalsa20poly1305_beforenmbytes() -> size_t;
    pub fn crypto_box_curve25519xsalsa20poly1305_noncebytes() -> size_t;
    pub fn crypto_box_curve25519xsalsa20poly1305_zerobytes() -> size_t;
    pub fn crypto_box_curve25519xsalsa20poly1305_boxzerobytes() -> size_t;
    pub fn crypto_box_curve25519xsalsa20poly1305_macbytes() -> size_t;
}

#[test]
fn test_crypto_box_curve25519xsalsa20poly1305_seedbytes() {
    assert!(unsafe {
        crypto_box_curve25519xsalsa20poly1305_seedbytes() as usize
    } == crypto_box_curve25519xsalsa20poly1305_SEEDBYTES)
}
#[test]
fn test_crypto_box_curve25519xsalsa20poly1305_publickeybytes() {
    assert!(unsafe {
        crypto_box_curve25519xsalsa20poly1305_publickeybytes() as usize
    } == crypto_box_curve25519xsalsa20poly1305_PUBLICKEYBYTES)
}
#[test]
fn test_crypto_box_curve25519xsalsa20poly1305_secretkeybytes() {
    assert!(unsafe {
        crypto_box_curve25519xsalsa20poly1305_secretkeybytes() as usize
    } == crypto_box_curve25519xsalsa20poly1305_SECRETKEYBYTES)
}
#[test]
fn test_crypto_box_curve25519xsalsa20poly1305_beforenmbytes() {
    assert!(unsafe {
        crypto_box_curve25519xsalsa20poly1305_beforenmbytes() as usize
    } == crypto_box_curve25519xsalsa20poly1305_BEFORENMBYTES)
}
#[test]
fn test_crypto_box_curve25519xsalsa20poly1305_noncebytes() {
    assert!(unsafe {
        crypto_box_curve25519xsalsa20poly1305_noncebytes() as usize
    } == crypto_box_curve25519xsalsa20poly1305_NONCEBYTES)
}
#[test]
fn test_crypto_box_curve25519xsalsa20poly1305_zerobytes() {
    assert!(unsafe {
        crypto_box_curve25519xsalsa20poly1305_zerobytes() as usize
    } == crypto_box_curve25519xsalsa20poly1305_ZEROBYTES)
}
#[test]
fn test_crypto_box_curve25519xsalsa20poly1305_boxzerobytes() {
    assert!(unsafe {
        crypto_box_curve25519xsalsa20poly1305_boxzerobytes() as usize
    } == crypto_box_curve25519xsalsa20poly1305_BOXZEROBYTES)
}
#[test]
fn test_crypto_box_curve25519xsalsa20poly1305_macbytes() {
    assert!(unsafe {
        crypto_box_curve25519xsalsa20poly1305_macbytes() as usize
    } == crypto_box_curve25519xsalsa20poly1305_MACBYTES)
}

'''
'''--- libsodium-sys/src/crypto_core_hsalsa20.rs ---
// crypto_core_hsalsa20.h

pub const crypto_core_hsalsa20_OUTPUTBYTES: usize = 32;
pub const crypto_core_hsalsa20_INPUTBYTES: usize = 16;
pub const crypto_core_hsalsa20_KEYBYTES: usize = 32;
pub const crypto_core_hsalsa20_CONSTBYTES: usize = 16;

extern {
    pub fn crypto_core_hsalsa20_outputbytes() -> size_t;
    pub fn crypto_core_hsalsa20_inputbytes() -> size_t;
    pub fn crypto_core_hsalsa20_keybytes() -> size_t;
    pub fn crypto_core_hsalsa20_constbytes() -> size_t;

    pub fn crypto_core_hsalsa20(
        out: *mut [u8; crypto_core_hsalsa20_OUTPUTBYTES],
        in_: *const [u8; crypto_core_hsalsa20_INPUTBYTES],
        k: *const [u8; crypto_core_hsalsa20_KEYBYTES],
        c: *const [u8; crypto_core_hsalsa20_CONSTBYTES]) -> c_int;
}

#[test]
fn test_crypto_core_hsalsa20_outputbytes() {
    assert!(unsafe {
        crypto_core_hsalsa20_outputbytes() as usize
    } == crypto_core_hsalsa20_OUTPUTBYTES)
}
#[test]
fn test_crypto_core_hsalsa20_inputbytes() {
    assert!(unsafe {
        crypto_core_hsalsa20_inputbytes() as usize
    } == crypto_core_hsalsa20_INPUTBYTES)
}
#[test]
fn test_crypto_core_hsalsa20_keybytes() {
    assert!(unsafe {
        crypto_core_hsalsa20_keybytes() as usize
    } == crypto_core_hsalsa20_KEYBYTES)
}
#[test]
fn test_crypto_core_hsalsa20_constbytes() {
    assert!(unsafe {
        crypto_core_hsalsa20_constbytes() as usize
    } == crypto_core_hsalsa20_CONSTBYTES)
}

'''
'''--- libsodium-sys/src/crypto_core_salsa20.rs ---
// crypto_core_salsa20.h

pub const crypto_core_salsa20_OUTPUTBYTES: usize = 64;
pub const crypto_core_salsa20_INPUTBYTES: usize = 16;
pub const crypto_core_salsa20_KEYBYTES: usize = 32;
pub const crypto_core_salsa20_CONSTBYTES: usize = 16;

extern {
    pub fn crypto_core_salsa20_outputbytes() -> size_t;
    pub fn crypto_core_salsa20_inputbytes() -> size_t;
    pub fn crypto_core_salsa20_keybytes() -> size_t;
    pub fn crypto_core_salsa20_constbytes() -> size_t;

    pub fn crypto_core_salsa20(
        out: *mut [u8; crypto_core_salsa20_OUTPUTBYTES],
        in_: *const [u8; crypto_core_salsa20_INPUTBYTES],
        k: *const [u8; crypto_core_salsa20_KEYBYTES],
        c: *const [u8; crypto_core_salsa20_CONSTBYTES]) -> c_int;
}

#[test]
fn test_crypto_core_salsa20_outputbytes() {
    assert!(unsafe {
        crypto_core_salsa20_outputbytes() as usize
    } == crypto_core_salsa20_OUTPUTBYTES)
}

#[test]
fn test_crypto_core_salsa20_inputbytes() {
    assert!(unsafe {
        crypto_core_salsa20_inputbytes() as usize
    } == crypto_core_salsa20_INPUTBYTES)
}

#[test]
fn test_crypto_core_salsa20_keybytes() {
    assert!(unsafe {
        crypto_core_salsa20_keybytes() as usize
    } == crypto_core_salsa20_KEYBYTES)
}

#[test]
fn test_crypto_core_salsa20_constbytes() {
    assert!(unsafe {
        crypto_core_salsa20_constbytes() as usize
    } == crypto_core_salsa20_CONSTBYTES)
}

'''
'''--- libsodium-sys/src/crypto_core_salsa2012.rs ---
// crypto_core_salsa2012.h

pub const crypto_core_salsa2012_OUTPUTBYTES: usize = 64;
pub const crypto_core_salsa2012_INPUTBYTES: usize = 16;
pub const crypto_core_salsa2012_KEYBYTES: usize = 32;
pub const crypto_core_salsa2012_CONSTBYTES: usize = 16;

extern {
    pub fn crypto_core_salsa2012_outputbytes() -> size_t;
    pub fn crypto_core_salsa2012_inputbytes() -> size_t;
    pub fn crypto_core_salsa2012_keybytes() -> size_t;
    pub fn crypto_core_salsa2012_constbytes() -> size_t;

    pub fn crypto_core_salsa2012(
        out: *mut [u8; crypto_core_salsa2012_OUTPUTBYTES],
        in_: *const [u8; crypto_core_salsa2012_INPUTBYTES],
        k: *const [u8; crypto_core_salsa2012_KEYBYTES],
        c: *const [u8; crypto_core_salsa2012_CONSTBYTES]) -> c_int;
}

#[test]
fn test_crypto_core_salsa2012_outputbytes() {
    assert!(unsafe {
        crypto_core_salsa2012_outputbytes() as usize
    } == crypto_core_salsa2012_OUTPUTBYTES)
}

#[test]
fn test_crypto_core_salsa2012_inputbytes() {
    assert!(unsafe {
        crypto_core_salsa2012_inputbytes() as usize
    } == crypto_core_salsa2012_INPUTBYTES)
}

#[test]
fn test_crypto_core_salsa2012_keybytes() {
    assert!(unsafe {
        crypto_core_salsa2012_keybytes() as usize
    } == crypto_core_salsa2012_KEYBYTES)
}

#[test]
fn test_crypto_core_salsa2012_constbytes() {
    assert!(unsafe {
        crypto_core_salsa2012_constbytes() as usize
    } == crypto_core_salsa2012_CONSTBYTES)
}

'''
'''--- libsodium-sys/src/crypto_core_salsa208.rs ---
// crypto_core_salsa208.h

pub const crypto_core_salsa208_OUTPUTBYTES: usize = 64;
pub const crypto_core_salsa208_INPUTBYTES: usize = 16;
pub const crypto_core_salsa208_KEYBYTES: usize = 32;
pub const crypto_core_salsa208_CONSTBYTES: usize = 16;

extern {
    pub fn crypto_core_salsa208_outputbytes() -> size_t;
    pub fn crypto_core_salsa208_inputbytes() -> size_t;
    pub fn crypto_core_salsa208_keybytes() -> size_t;
    pub fn crypto_core_salsa208_constbytes() -> size_t;

    pub fn crypto_core_salsa208(
        out: *mut [u8; crypto_core_salsa208_OUTPUTBYTES],
        in_: *const [u8; crypto_core_salsa208_INPUTBYTES],
        k: *const [u8; crypto_core_salsa208_KEYBYTES],
        c: *const [u8; crypto_core_salsa208_CONSTBYTES]) -> c_int;
}

#[test]
fn test_crypto_core_salsa208_outputbytes() {
    assert!(unsafe {
        crypto_core_salsa208_outputbytes() as usize
    } == crypto_core_salsa208_OUTPUTBYTES)
}

#[test]
fn test_crypto_core_salsa208_inputbytes() {
    assert!(unsafe {
        crypto_core_salsa208_inputbytes() as usize
    } == crypto_core_salsa208_INPUTBYTES)
}

#[test]
fn test_crypto_core_salsa208_keybytes() {
    assert!(unsafe {
        crypto_core_salsa208_keybytes() as usize
    } == crypto_core_salsa208_KEYBYTES)
}

#[test]
fn test_crypto_core_salsa208_constbytes() {
    assert!(unsafe {
        crypto_core_salsa208_constbytes() as usize
    } == crypto_core_salsa208_CONSTBYTES)
}

'''
'''--- libsodium-sys/src/crypto_generichash.rs ---
// crypto_generichash.h

pub const crypto_generichash_BYTES_MIN: usize = crypto_generichash_blake2b_BYTES_MIN;
pub const crypto_generichash_BYTES_MAX: usize = crypto_generichash_blake2b_BYTES_MAX;
pub const crypto_generichash_BYTES: usize = crypto_generichash_blake2b_BYTES;
pub const crypto_generichash_KEYBYTES_MIN: usize = crypto_generichash_blake2b_KEYBYTES_MIN;
pub const crypto_generichash_KEYBYTES_MAX: usize = crypto_generichash_blake2b_KEYBYTES_MAX;
pub const crypto_generichash_KEYBYTES: usize = crypto_generichash_blake2b_KEYBYTES;
pub const crypto_generichash_PRIMITIVE: &str = "blake2b";

#[allow(non_camel_case_types)]
pub enum crypto_generichash_state { }

extern {
    pub fn crypto_generichash_bytes_min() -> size_t;
    pub fn crypto_generichash_bytes_max() -> size_t;
    pub fn crypto_generichash_bytes() -> size_t;
    pub fn crypto_generichash_keybytes_min() -> size_t;
    pub fn crypto_generichash_keybytes_max() -> size_t;
    pub fn crypto_generichash_keybytes() -> size_t;
    pub fn crypto_generichash_primitive() -> *const c_char;

    pub fn crypto_generichash(
        out: *mut u8,
        outlen: size_t,
        in_: *const u8,
        inlen: c_ulonglong,
        key: *const u8,
        keylen: size_t)
        -> c_int;

    pub fn crypto_generichash_init(
        state: *mut crypto_generichash_state,
        key: *const u8,
        keylen: size_t,
        outlen: size_t)
        -> c_int;

    pub fn crypto_generichash_update(
        state: *mut crypto_generichash_state,
        in_: *const u8,
        inlen: c_ulonglong)
        -> c_int;

    pub fn crypto_generichash_final(
        state: *mut crypto_generichash_state,
        out: *mut u8,
        outlen: size_t)
        -> c_int;

    pub fn crypto_generichash_statebytes() -> size_t;
}

#[test]
fn test_crypto_generichash_bytes_min() {
    assert_eq!(unsafe { crypto_generichash_bytes_min() as usize },
                        crypto_generichash_BYTES_MIN)
}

#[test]
fn test_crypto_generichash_bytes_max() {
    assert_eq!(unsafe { crypto_generichash_bytes_max() as usize },
                        crypto_generichash_BYTES_MAX)
}

#[test]
fn test_crypto_generichash_bytes() {
    assert_eq!(unsafe { crypto_generichash_bytes() as usize },
                        crypto_generichash_BYTES)
}

#[test]
fn test_crypto_generichash_keybytes_min() {
    assert_eq!(unsafe { crypto_generichash_keybytes_min() as usize },
                        crypto_generichash_KEYBYTES_MIN)
}

#[test]
fn test_crypto_generichash_keybytes_max() {
    assert_eq!(unsafe { crypto_generichash_keybytes_max() as usize },
                        crypto_generichash_KEYBYTES_MAX)
}

#[test]
fn test_crypto_generichash_keybytes() {
    assert_eq!(unsafe { crypto_generichash_keybytes() as usize },
                        crypto_generichash_KEYBYTES)
}
#[test]
fn test_crypto_generichash_primitive() {
    unsafe {
        let s = crypto_generichash_primitive();
        let s = std::ffi::CStr::from_ptr(s).to_bytes();
        assert_eq!(s, crypto_generichash_PRIMITIVE.as_bytes());
    }
}

#[test]
fn test_crypto_generichash_statebytes() {
    assert!(unsafe { crypto_generichash_statebytes() } > 0);
}

#[test]
fn test_crypto_generichash() {
    let mut out = [0u8; crypto_generichash_BYTES];
    let m = [0u8; 64];
    let key = [0u8; crypto_generichash_KEYBYTES];

    assert_eq!(unsafe {
        crypto_generichash(out.as_mut_ptr(), out.len(),
                           m.as_ptr(), m.len() as u64,
                           key.as_ptr(), key.len())
    }, 0);
}

#[cfg(test)]
use std::mem;

#[test]
fn test_crypto_generichash_multipart() {
    let mut out = [0u8; crypto_generichash_BYTES];
    let m = [0u8; 64];
    let key = [0u8; crypto_generichash_KEYBYTES];

    let mut st = vec![0u8; unsafe { crypto_generichash_statebytes() }];
    let pst = unsafe { mem::transmute::<*mut u8, *mut crypto_generichash_state>(st.as_mut_ptr()) };

    assert_eq!(unsafe {
        crypto_generichash_init(pst,
                                key.as_ptr(), key.len(),
                                out.len())
    }, 0);

    assert_eq!(unsafe {
        crypto_generichash_update(pst,
                                m.as_ptr(), m.len() as u64)
    }, 0);

    assert_eq!(unsafe {
        crypto_generichash_update(pst,
                                m.as_ptr(), m.len() as u64)
    }, 0);

    assert_eq!(unsafe {
        crypto_generichash_final(pst,
                                out.as_mut_ptr(), out.len())
    }, 0);
}

'''
'''--- libsodium-sys/src/crypto_generichash_blake2b.rs ---
// crypto_generichash_blake2b.h

pub const crypto_generichash_blake2b_BYTES_MIN: usize = 16;
pub const crypto_generichash_blake2b_BYTES_MAX: usize = 64;
pub const crypto_generichash_blake2b_BYTES: usize = 32;
pub const crypto_generichash_blake2b_KEYBYTES_MIN: usize = 16;
pub const crypto_generichash_blake2b_KEYBYTES_MAX: usize = 64;
pub const crypto_generichash_blake2b_KEYBYTES: usize = 32;
pub const crypto_generichash_blake2b_SALTBYTES: usize = 16;
pub const crypto_generichash_blake2b_PERSONALBYTES: usize = 16;

#[allow(non_camel_case_types)]
pub enum crypto_generichash_blake2b_state { }

extern {
    pub fn crypto_generichash_blake2b_bytes_min() -> size_t;
    pub fn crypto_generichash_blake2b_bytes_max() -> size_t;
    pub fn crypto_generichash_blake2b_bytes() -> size_t;
    pub fn crypto_generichash_blake2b_keybytes_min() -> size_t;
    pub fn crypto_generichash_blake2b_keybytes_max() -> size_t;
    pub fn crypto_generichash_blake2b_keybytes() -> size_t;
    pub fn crypto_generichash_blake2b_saltbytes() -> size_t;
    pub fn crypto_generichash_blake2b_personalbytes() -> size_t;

    pub fn crypto_generichash_blake2b(
        out: *mut u8,
        outlen: size_t,
        in_: *const u8,
        inlen: c_ulonglong,
        key: *const u8,
        keylen: size_t)
        -> c_int;

    pub fn crypto_generichash_blake2b_salt_personal(
        out: *mut u8,
        outlen: size_t,
        in_: *const u8,
        inlen: c_ulonglong,
        key: *const u8,
        keylen: size_t,
        salt: *const [u8; crypto_generichash_blake2b_SALTBYTES],
        personal: *const [u8; crypto_generichash_blake2b_PERSONALBYTES])
        -> c_int;

    pub fn crypto_generichash_blake2b_init(
        state: *mut crypto_generichash_blake2b_state,
        key: *const u8,
        keylen: size_t,
        outlen: size_t)
        -> c_int;

    pub fn crypto_generichash_blake2b_init_salt_personal(
        state: *mut crypto_generichash_blake2b_state,
        key: *const u8,
        keylen: size_t,
        outlen: size_t,
        salt: *const [u8; crypto_generichash_blake2b_SALTBYTES],
        personal: *const [u8; crypto_generichash_blake2b_PERSONALBYTES])
        -> c_int;

    pub fn crypto_generichash_blake2b_update(
        state: *mut crypto_generichash_blake2b_state,
        in_: *const u8,
        inlen: c_ulonglong)
        -> c_int;

    pub fn crypto_generichash_blake2b_final(
        state: *mut crypto_generichash_blake2b_state,
        out: *mut u8,
        outlen: size_t)
        -> c_int;
}

#[test]
fn test_crypto_generichash_blake2b_bytes_min() {
    assert_eq!(unsafe { crypto_generichash_blake2b_bytes_min() as usize },
                        crypto_generichash_blake2b_BYTES_MIN)
}

#[test]
fn test_crypto_generichash_blake2b_bytes_max() {
    assert_eq!(unsafe { crypto_generichash_blake2b_bytes_max() as usize },
                        crypto_generichash_blake2b_BYTES_MAX)
}

#[test]
fn test_crypto_generichash_blake2b_bytes() {
    assert_eq!(unsafe { crypto_generichash_blake2b_bytes() as usize },
                        crypto_generichash_blake2b_BYTES)
}

#[test]
fn test_crypto_generichash_blake2b_keybytes_min() {
    assert_eq!(unsafe { crypto_generichash_blake2b_keybytes_min() as usize },
                        crypto_generichash_blake2b_KEYBYTES_MIN)
}

#[test]
fn test_crypto_generichash_blake2b_keybytes_max() {
    assert_eq!(unsafe { crypto_generichash_blake2b_keybytes_max() as usize },
                        crypto_generichash_blake2b_KEYBYTES_MAX)
}

#[test]
fn test_crypto_generichash_blake2b_keybytes() {
    assert_eq!(unsafe { crypto_generichash_blake2b_keybytes() as usize },
                        crypto_generichash_blake2b_KEYBYTES)
}

#[test]
fn test_crypto_generichash_blake2b_saltbytes() {
    assert_eq!(unsafe { crypto_generichash_blake2b_saltbytes() as usize },
                        crypto_generichash_blake2b_SALTBYTES)
}

#[test]
fn test_crypto_generichash_blake2b_personalbytes() {
    assert_eq!(unsafe { crypto_generichash_blake2b_personalbytes() as usize },
                        crypto_generichash_blake2b_PERSONALBYTES)
}

#[test]
fn test_crypto_generichash_blake2b() {
    let mut out = [0u8; crypto_generichash_blake2b_BYTES];
    let m = [0u8; 64];
    let key = [0u8; crypto_generichash_blake2b_KEYBYTES];

    assert_eq!(unsafe {
        crypto_generichash_blake2b(out.as_mut_ptr(), out.len(),
                           m.as_ptr(), m.len() as u64,
                           key.as_ptr(), key.len())
    }, 0);
}

#[test]
fn test_crypto_generichash_blake2b_salt_personal() {
    let mut out = [0u8; crypto_generichash_blake2b_BYTES];
    let m = [0u8; 64];
    let key = [0u8; crypto_generichash_blake2b_KEYBYTES];
    let salt = [0u8; crypto_generichash_blake2b_SALTBYTES];
    let personal = [0u8; crypto_generichash_blake2b_PERSONALBYTES];

    assert_eq!(unsafe {
        crypto_generichash_blake2b_salt_personal(out.as_mut_ptr(), out.len(),
                           m.as_ptr(), m.len() as u64,
                           key.as_ptr(), key.len(),
                           &salt, &personal)
    }, 0);
}

'''
'''--- libsodium-sys/src/crypto_hash.rs ---
// crypto_hash.h

pub const crypto_hash_BYTES: usize = crypto_hash_sha512_BYTES;
pub const crypto_hash_PRIMITIVE: &str = "sha512";

extern {
    pub fn crypto_hash_bytes() -> size_t;
    pub fn crypto_hash(h: *mut [u8; crypto_hash_BYTES],
                       m: *const u8,
                       mlen: c_ulonglong) -> c_int;
    pub fn crypto_hash_primitive() -> *const c_char;
}

#[test]
fn test_crypto_hash_bytes() {
    assert!(unsafe { crypto_hash_bytes() as usize } == crypto_hash_BYTES)
}
#[test]
fn test_crypto_hash_primitive() {
    unsafe {
        let s = crypto_hash_primitive();
        let s = std::ffi::CStr::from_ptr(s).to_bytes();
        assert!(s == crypto_hash_PRIMITIVE.as_bytes());
    }
}

'''
'''--- libsodium-sys/src/crypto_hash_sha256.rs ---
// crypto_hash_sha256.h

#[repr(C)]
#[derive(Copy)]
pub struct crypto_hash_sha256_state {
    state: [u32; 8],
    count: [u32; 2],
    buf: [u8; 64],
}
impl Clone for crypto_hash_sha256_state { fn clone(&self) -> crypto_hash_sha256_state { *self } }
pub const crypto_hash_sha256_BYTES: usize =  32;

extern {
    pub fn crypto_hash_sha256_bytes() -> size_t;
    pub fn crypto_hash_sha256(h: *mut [u8; crypto_hash_sha256_BYTES],
                              m: *const u8,
                              mlen: c_ulonglong) -> c_int;
    pub fn crypto_hash_sha256_init(state: *mut crypto_hash_sha256_state) -> c_int;
    pub fn crypto_hash_sha256_update(state: *mut crypto_hash_sha256_state,
                                     m: *const u8,
                                     mlen: c_ulonglong) -> c_int;
    pub fn crypto_hash_sha256_final(state: *mut crypto_hash_sha256_state,
                                    h: *mut [u8; crypto_hash_sha256_BYTES]) -> c_int;
}

#[test]
fn test_crypto_hash_sha256_bytes() {
    assert!(unsafe { crypto_hash_sha256_bytes() as usize } ==
            crypto_hash_sha256_BYTES)
}

'''
'''--- libsodium-sys/src/crypto_hash_sha512.rs ---
// crypto_hash_sha512.h

#[repr(C)]
#[derive(Copy)]
pub struct crypto_hash_sha512_state {
    state: [u64; 8],
    count: [u64; 2],
    buf: [u8; 128],
}
impl Clone for crypto_hash_sha512_state { fn clone(&self) -> crypto_hash_sha512_state { *self } }
pub const crypto_hash_sha512_BYTES: usize = 64;

extern {
    pub fn crypto_hash_sha512_bytes() -> size_t;    
    pub fn crypto_hash_sha512(h: *mut [u8; crypto_hash_sha512_BYTES],
                              m: *const u8,
                              mlen: c_ulonglong) -> c_int;
    pub fn crypto_hash_sha512_init(state: *mut crypto_hash_sha512_state) -> c_int;
    pub fn crypto_hash_sha512_update(state: *mut crypto_hash_sha512_state,
                                     m: *const u8,
                                     mlen: c_ulonglong) -> c_int;
    pub fn crypto_hash_sha512_final(state: *mut crypto_hash_sha512_state,
                                    h: *mut [u8; crypto_hash_sha512_BYTES]) -> c_int;
}

#[test]
fn test_crypto_hash_sha512_bytes() {
    assert!(unsafe { crypto_hash_sha512_bytes() as usize } ==
            crypto_hash_sha512_BYTES)
}

'''
'''--- libsodium-sys/src/crypto_onetimeauth.rs ---
// crypto_onetimeauth.h

pub const crypto_onetimeauth_BYTES: usize =
    crypto_onetimeauth_poly1305_BYTES;
pub const crypto_onetimeauth_KEYBYTES: usize =
    crypto_onetimeauth_poly1305_KEYBYTES;
pub const crypto_onetimeauth_PRIMITIVE: &str =  "poly1305";

extern {
    pub fn crypto_onetimeauth_bytes() -> size_t;
    pub fn crypto_onetimeauth_keybytes() -> size_t;
    pub fn crypto_onetimeauth_primitive() -> *const c_char;
}

#[test]
fn test_crypto_onetimeauth_bytes() {
    assert!(unsafe { crypto_onetimeauth_bytes() as usize } ==
            crypto_onetimeauth_BYTES)
}
#[test]
fn test_crypto_onetimeauth_keybytes() {
    assert!(unsafe { crypto_onetimeauth_keybytes() as usize } ==
            crypto_onetimeauth_KEYBYTES)
}
#[test]
fn test_crypto_onetimeauth_primitive() {
    unsafe {
        let s = crypto_onetimeauth_primitive();
        let s = std::ffi::CStr::from_ptr(s).to_bytes();
        assert!(s == crypto_onetimeauth_PRIMITIVE.as_bytes());
    }
}

'''
'''--- libsodium-sys/src/crypto_onetimeauth_poly1305.rs ---
// crypto_onetimeauth_poly1305.h

pub const crypto_onetimeauth_poly1305_BYTES: usize = 16;
pub const crypto_onetimeauth_poly1305_KEYBYTES: usize = 32;

extern {
    pub fn crypto_onetimeauth_poly1305(
        a: *mut [u8; crypto_onetimeauth_poly1305_BYTES],
        m: *const u8,
        mlen: c_ulonglong,
        k: *const [u8; crypto_onetimeauth_poly1305_KEYBYTES]) -> c_int;
    pub fn crypto_onetimeauth_poly1305_verify(
        a: *const [u8; crypto_onetimeauth_poly1305_BYTES],
        m: *const u8,
        mlen: c_ulonglong,
        k: *const [u8; crypto_onetimeauth_poly1305_KEYBYTES]) -> c_int;
    pub fn crypto_onetimeauth_poly1305_bytes() -> size_t;
    pub fn crypto_onetimeauth_poly1305_keybytes() -> size_t;
}

#[test]
fn test_crypto_onetimeauth_poly1305_bytes() {
    assert!(unsafe { crypto_onetimeauth_poly1305_bytes() as usize } ==
            crypto_onetimeauth_poly1305_BYTES)
}
#[test]
fn test_crypto_onetimeauth_poly1305_keybytes() {
    assert!(unsafe { crypto_onetimeauth_poly1305_keybytes() as usize } ==
            crypto_onetimeauth_poly1305_KEYBYTES)
}

'''
'''--- libsodium-sys/src/crypto_pwhash_scryptsalsa208sha256.rs ---
// crypto_pwhash_scryptsalsa208sha256.h

pub const crypto_pwhash_scryptsalsa208sha256_SALTBYTES: usize = 32;
pub const crypto_pwhash_scryptsalsa208sha256_STRBYTES: usize = 102;
pub const crypto_pwhash_scryptsalsa208sha256_STRPREFIX: &str = "$7$";
pub const crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE: usize =
    524_288;
pub const crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE: usize =
    16_777_216;
pub const crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE: usize =
    33_554_432;
pub const crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE: usize =
    1_073_741_824;

extern {
    pub fn crypto_pwhash_scryptsalsa208sha256_saltbytes() -> size_t;
    pub fn crypto_pwhash_scryptsalsa208sha256_strbytes() -> size_t;
    pub fn crypto_pwhash_scryptsalsa208sha256_strprefix() -> *const c_char;
    pub fn crypto_pwhash_scryptsalsa208sha256_opslimit_interactive() ->
        size_t;
    pub fn crypto_pwhash_scryptsalsa208sha256_memlimit_interactive() ->
        size_t;
    pub fn crypto_pwhash_scryptsalsa208sha256_opslimit_sensitive() -> size_t;
    pub fn crypto_pwhash_scryptsalsa208sha256_memlimit_sensitive() -> size_t;
    pub fn crypto_pwhash_scryptsalsa208sha256(
        out: *mut u8,
        outlen: c_ulonglong,
        passwd: *const u8,
        passwdlen: c_ulonglong,
        salt: *const [u8; crypto_pwhash_scryptsalsa208sha256_SALTBYTES],
        opslimit: c_ulonglong,
        memlimit: size_t) -> c_int;
    pub fn crypto_pwhash_scryptsalsa208sha256_str(
        out: *mut [u8; crypto_pwhash_scryptsalsa208sha256_STRBYTES],
        passwd: *const u8,
        passwdlen: c_ulonglong,
        opslimit: c_ulonglong,
        memlimit: size_t) -> c_int;
    pub fn crypto_pwhash_scryptsalsa208sha256_str_verify(
        str_: *const [u8; crypto_pwhash_scryptsalsa208sha256_STRBYTES],
        passwd: *const u8,
        passwdlen: c_ulonglong) -> c_int;
    pub fn crypto_pwhash_scryptsalsa208sha256_ll(
        passwd: *const u8,
        passwdlen: size_t,
        salt: *const u8,
        saltlen: size_t,
        N: u64,
        r: u32,
        p: u32,
        buf: *mut u8,
        buflen: size_t) -> c_int;
}

#[test]
fn test_crypto_pwhash_scryptsalsa208sha256_saltbytes() {
    assert!(unsafe {
        crypto_pwhash_scryptsalsa208sha256_saltbytes() as usize
    } == crypto_pwhash_scryptsalsa208sha256_SALTBYTES)
}
#[test]
fn test_crypto_pwhash_scryptsalsa208sha256_strbytes() {
    assert!(unsafe {
        crypto_pwhash_scryptsalsa208sha256_strbytes() as usize
    } == crypto_pwhash_scryptsalsa208sha256_STRBYTES)
}
#[test]
fn test_crypto_pwhash_scryptsalsa208sha256_opslimit_interactive() {
    assert!(unsafe {
        crypto_pwhash_scryptsalsa208sha256_opslimit_interactive() as usize
    } == crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE)
}
#[test]
fn test_crypto_pwhash_scryptsalsa208sha256_memlimit_interactive() {
    assert!(unsafe {
        crypto_pwhash_scryptsalsa208sha256_memlimit_interactive() as usize
    } == crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE)
}
#[test]
fn test_crypto_pwhash_scryptsalsa208sha256_opslimit_sensitive() {
    assert!(unsafe {
        crypto_pwhash_scryptsalsa208sha256_opslimit_sensitive() as usize
    } == crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE)
}
#[test]
fn test_crypto_pwhash_scryptsalsa208sha256_memlimit_sensitive() {
    assert!(unsafe {
        crypto_pwhash_scryptsalsa208sha256_memlimit_sensitive() as usize
    } == crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE)
}
#[test]
fn test_crypto_pwhash_scryptsalsa208sha256_strprefix() {
    unsafe {
         let s = crypto_pwhash_scryptsalsa208sha256_strprefix();
         let s = std::ffi::CStr::from_ptr(s).to_bytes();
        assert!(s ==
                crypto_pwhash_scryptsalsa208sha256_STRPREFIX.as_bytes());
    }
}
#[test]
fn test_crypto_pwhash_scryptsalsa208sha256_str() {
    let password = "Correct Horse Battery Staple";
    let mut hashed_password =
        [0; crypto_pwhash_scryptsalsa208sha256_STRBYTES];
    let ret_hash = unsafe {
        crypto_pwhash_scryptsalsa208sha256_str(
            &mut hashed_password,
            password.as_ptr(),
            password.len() as c_ulonglong,
            crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE
                as c_ulonglong,
            crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE
                as size_t)
    };
    assert!(ret_hash == 0);
    let ret_verify = unsafe {
        crypto_pwhash_scryptsalsa208sha256_str_verify(
            &hashed_password,
            password.as_ptr(),
            password.len() as c_ulonglong)
    };
    assert!(ret_verify == 0);
}
#[test]
fn test_crypto_pwhash_scryptsalsa208sha256_ll_1() {
    // See https://www.tarsnap.com/scrypt/scrypt.pdf Page 16
    let password = "";
    let salt = "";
    let n = 16;
    let r = 1;
    let p = 1;
    let mut buf = [0u8; 64];
    let expected = [0x77, 0xd6, 0x57, 0x62, 0x38, 0x65, 0x7b, 0x20,
                    0x3b, 0x19, 0xca, 0x42, 0xc1, 0x8a, 0x04, 0x97,
                    0xf1, 0x6b, 0x48, 0x44, 0xe3, 0x07, 0x4a, 0xe8,
                    0xdf, 0xdf, 0xfa, 0x3f, 0xed, 0xe2, 0x14, 0x42,
                    0xfc, 0xd0, 0x06, 0x9d, 0xed, 0x09, 0x48, 0xf8,
                    0x32, 0x6a, 0x75, 0x3a, 0x0f, 0xc8, 0x1f, 0x17,
                    0xe8, 0xd3, 0xe0, 0xfb, 0x2e, 0x0d, 0x36, 0x28,
                    0xcf, 0x35, 0xe2, 0x0c, 0x38, 0xd1, 0x89, 0x06];
    let ret = unsafe {
        crypto_pwhash_scryptsalsa208sha256_ll(password.as_ptr(),
                                              password.len() as size_t,
                                              salt.as_ptr(),
                                              salt.len() as size_t,
                                              n,
                                              r,
                                              p,
                                              buf.as_mut_ptr(),
                                              buf.len() as size_t)
    };
    assert!(ret == 0);
    assert!(buf[0..] == expected[0..]);
}
#[test]
fn test_crypto_pwhash_scryptsalsa208sha256_ll_2() {
    // See https://www.tarsnap.com/scrypt/scrypt.pdf Page 16
    let password = "password";
    let salt = "NaCl";
    let n = 1024;
    let r = 8;
    let p = 16;
    let mut buf = [0u8; 64];
    let expected = [0xfd, 0xba, 0xbe, 0x1c, 0x9d, 0x34, 0x72, 0x00,
                    0x78, 0x56, 0xe7, 0x19, 0x0d, 0x01, 0xe9, 0xfe,
                    0x7c, 0x6a, 0xd7, 0xcb, 0xc8, 0x23, 0x78, 0x30,
                    0xe7, 0x73, 0x76, 0x63, 0x4b, 0x37, 0x31, 0x62,
                    0x2e, 0xaf, 0x30, 0xd9, 0x2e, 0x22, 0xa3, 0x88,
                    0x6f, 0xf1, 0x09, 0x27, 0x9d, 0x98, 0x30, 0xda,
                    0xc7, 0x27, 0xaf, 0xb9, 0x4a, 0x83, 0xee, 0x6d,
                    0x83, 0x60, 0xcb, 0xdf, 0xa2, 0xcc, 0x06, 0x40];
    let ret = unsafe {
        crypto_pwhash_scryptsalsa208sha256_ll(password.as_ptr(),
                                              password.len() as size_t,
                                              salt.as_ptr(),
                                              salt.len() as size_t,
                                              n,
                                              r,
                                              p,
                                              buf.as_mut_ptr(),
                                              buf.len() as size_t)
    };
    assert!(ret == 0);
    assert!(buf[0..] == expected[0..]);
}
#[test]
fn test_crypto_pwhash_scryptsalsa208sha256_ll_3() {
    // See https://www.tarsnap.com/scrypt/scrypt.pdf Page 16
    let password = "pleaseletmein";
    let salt = "SodiumChloride";
    let n = 16384;
    let r = 8;
    let p = 1;
    let mut buf = [0u8; 64];
    let expected = [0x70, 0x23, 0xbd, 0xcb, 0x3a, 0xfd, 0x73, 0x48,
                    0x46, 0x1c, 0x06, 0xcd, 0x81, 0xfd, 0x38, 0xeb,
                    0xfd, 0xa8, 0xfb, 0xba, 0x90, 0x4f, 0x8e, 0x3e,
                    0xa9, 0xb5, 0x43, 0xf6, 0x54, 0x5d, 0xa1, 0xf2,
                    0xd5, 0x43, 0x29, 0x55, 0x61, 0x3f, 0x0f, 0xcf,
                    0x62, 0xd4, 0x97, 0x05, 0x24, 0x2a, 0x9a, 0xf9,
                    0xe6, 0x1e, 0x85, 0xdc, 0x0d, 0x65, 0x1e, 0x40,
                    0xdf, 0xcf, 0x01, 0x7b, 0x45, 0x57, 0x58, 0x87];
    let ret = unsafe {
        crypto_pwhash_scryptsalsa208sha256_ll(password.as_ptr(),
                                              password.len() as size_t,
                                              salt.as_ptr(),
                                              salt.len() as size_t,
                                              n,
                                              r,
                                              p,
                                              buf.as_mut_ptr(),
                                              buf.len() as size_t)
    };
    assert!(ret == 0);
    assert!(buf[0..] == expected[0..]);
}
#[test]
fn test_crypto_pwhash_scryptsalsa208sha256_ll_4() {
    // See https://www.tarsnap.com/scrypt/scrypt.pdf Page 16
    let password = "pleaseletmein";
    let salt = "SodiumChloride";
    let n = 1048576;
    let r = 8;
    let p = 1;
    let mut buf = [0u8; 64];
    let expected = [0x21, 0x01, 0xcb, 0x9b, 0x6a, 0x51, 0x1a, 0xae,
                    0xad, 0xdb, 0xbe, 0x09, 0xcf, 0x70, 0xf8, 0x81,
                    0xec, 0x56, 0x8d, 0x57, 0x4a, 0x2f, 0xfd, 0x4d,
                    0xab, 0xe5, 0xee, 0x98, 0x20, 0xad, 0xaa, 0x47,
                    0x8e, 0x56, 0xfd, 0x8f, 0x4b, 0xa5, 0xd0, 0x9f,
                    0xfa, 0x1c, 0x6d, 0x92, 0x7c, 0x40, 0xf4, 0xc3,
                    0x37, 0x30, 0x40, 0x49, 0xe8, 0xa9, 0x52, 0xfb,
                    0xcb, 0xf4, 0x5c, 0x6f, 0xa7, 0x7a, 0x41, 0xa4];
    let ret = unsafe {
        crypto_pwhash_scryptsalsa208sha256_ll(password.as_ptr(),
                                              password.len() as size_t,
                                              salt.as_ptr(),
                                              salt.len() as size_t,
                                              n,
                                              r,
                                              p,
                                              buf.as_mut_ptr(),
                                              buf.len() as size_t)
    };
    assert!(ret == 0);
    assert!(buf[0..] == expected[0..]);
}

'''
'''--- libsodium-sys/src/crypto_scalarmult.rs ---
// crypto_scalarmult.h

pub const crypto_scalarmult_BYTES: usize = crypto_scalarmult_curve25519_BYTES;
pub const crypto_scalarmult_SCALARBYTES: usize = crypto_scalarmult_curve25519_SCALARBYTES;
pub const crypto_scalarmult_PRIMITIVE: &str = "curve25519";

extern {
    pub fn crypto_scalarmult_bytes() -> size_t;
    pub fn crypto_scalarmult_scalarbytes() -> size_t;
    pub fn crypto_scalarmult_primitive() -> *const c_char;
    pub fn crypto_scalarmult_base(
        q: *mut [u8; crypto_scalarmult_BYTES],
        n: *const [u8; crypto_scalarmult_SCALARBYTES]) -> c_int;
    pub fn crypto_scalarmult(
        q: *mut [u8; crypto_scalarmult_BYTES],
        n: *const [u8; crypto_scalarmult_SCALARBYTES],
        p: *const [u8; crypto_scalarmult_BYTES]) -> c_int;
}

#[test]
fn test_crypto_scalarmult_bytes() {
    assert_eq!(unsafe { crypto_scalarmult_bytes() as usize },
               crypto_scalarmult_BYTES);
}

#[test]
fn test_crypto_scalarmult_scalarbytes() {
    assert_eq!(unsafe { crypto_scalarmult_scalarbytes() as usize },
               crypto_scalarmult_SCALARBYTES);
}

#[test]
fn test_crypto_scalarmult_primitive() {
    unsafe {
        let s = crypto_scalarmult_primitive();
        let s = std::ffi::CStr::from_ptr(s).to_bytes();
        assert_eq!(s, crypto_scalarmult_PRIMITIVE.as_bytes());
    }
}

'''
'''--- libsodium-sys/src/crypto_scalarmult_curve25519.rs ---
// crypto_scalarmult_curve25519.h

pub const crypto_scalarmult_curve25519_BYTES: usize = 32;
pub const crypto_scalarmult_curve25519_SCALARBYTES: usize = 32;

extern {
    pub fn crypto_scalarmult_curve25519_bytes() -> size_t;
    pub fn crypto_scalarmult_curve25519_scalarbytes() -> size_t;
    pub fn crypto_scalarmult_curve25519_base(
        q: *mut [u8; crypto_scalarmult_curve25519_BYTES],
        n: *const [u8; crypto_scalarmult_curve25519_SCALARBYTES]) -> c_int;
    pub fn crypto_scalarmult_curve25519(
        q: *mut [u8; crypto_scalarmult_curve25519_BYTES],
        n: *const [u8; crypto_scalarmult_curve25519_SCALARBYTES],
        p: *const [u8; crypto_scalarmult_curve25519_BYTES]) -> c_int;
}

#[test]
fn test_crypto_scalarmult_curve25519_bytes() {
    assert_eq!(unsafe { crypto_scalarmult_curve25519_bytes() as usize },
               crypto_scalarmult_curve25519_BYTES);
}

#[test]
fn test_crypto_scalarmult_curve25519_scalarbytes() {
    assert_eq!(unsafe { crypto_scalarmult_curve25519_scalarbytes() as usize },
               crypto_scalarmult_curve25519_SCALARBYTES);
}

'''
'''--- libsodium-sys/src/crypto_secretbox.rs ---
pub const crypto_secretbox_KEYBYTES: usize = 32;
pub const crypto_secretbox_NONCEBYTES: usize = 24;
pub const crypto_secretbox_MACBYTES: usize = 16;
pub const crypto_secretbox_PRIMITIVE: &str = "xsalsa20poly1305";

extern {
    pub fn crypto_secretbox_easy(
        c: *mut u8,
        m: *const u8,
        mlen: c_ulonglong,
        n: *const [u8; crypto_secretbox_NONCEBYTES],
        k: *const [u8; crypto_secretbox_KEYBYTES]) -> c_int;
    pub fn crypto_secretbox_open_easy(
        m: *mut u8,
        c: *const u8,
        clen: c_ulonglong,
        n: *const [u8; crypto_secretbox_NONCEBYTES],
        k: *const [u8; crypto_secretbox_KEYBYTES]) -> c_int;
    pub fn crypto_secretbox_detached(
        c: *mut u8,
        mac: *mut [u8; crypto_secretbox_MACBYTES],
        m: *const u8,
        mlen: c_ulonglong,
        n: *const [u8; crypto_secretbox_NONCEBYTES],
        k: *const [u8; crypto_secretbox_KEYBYTES]) -> c_int;
    pub fn crypto_secretbox_open_detached(
        m: *mut u8,
        c: *const u8,
        mac: *const [u8; crypto_secretbox_MACBYTES],
        clen: c_ulonglong,
        n: *const [u8; crypto_secretbox_NONCEBYTES],
        k: *const [u8; crypto_secretbox_KEYBYTES]) -> c_int;
    pub fn crypto_secretbox_keybytes() -> size_t;
    pub fn crypto_secretbox_noncebytes() -> size_t;
    pub fn crypto_secretbox_macbytes() -> size_t;
    pub fn crypto_secretbox_primitive() -> *const c_char;
}

#[test]
fn test_crypto_secretbox_keybytes() {
    assert!(unsafe {
        crypto_secretbox_keybytes() as usize
    } == crypto_secretbox_KEYBYTES)
}

#[test]
fn test_crypto_secretbox_noncebytes() {
    assert!(unsafe {
        crypto_secretbox_noncebytes() as usize
    } == crypto_secretbox_NONCEBYTES)
}

#[test]
fn test_crypto_secretbox_macbytes() {
    assert!(unsafe {
        crypto_secretbox_macbytes() as usize
    } == crypto_secretbox_MACBYTES)
}

#[test]
fn test_crypto_secretbox_primitive() {
    unsafe {
        let s = crypto_secretbox_primitive();
        let s = std::ffi::CStr::from_ptr(s).to_bytes();
        assert!(s == crypto_secretbox_PRIMITIVE.as_bytes());
    }
}

'''
'''--- libsodium-sys/src/crypto_secretbox_xsalsa20poly1305.rs ---
// crypto_secretbox_xsalsa20poly1305.h

pub const crypto_secretbox_xsalsa20poly1305_KEYBYTES: usize = 32;
pub const crypto_secretbox_xsalsa20poly1305_NONCEBYTES: usize = 24;
pub const crypto_secretbox_xsalsa20poly1305_ZEROBYTES: usize = 32;
pub const crypto_secretbox_xsalsa20poly1305_BOXZEROBYTES: usize = 16;
pub const crypto_secretbox_xsalsa20poly1305_MACBYTES: usize =
    crypto_secretbox_xsalsa20poly1305_ZEROBYTES -
    crypto_secretbox_xsalsa20poly1305_BOXZEROBYTES;

extern {
    pub fn crypto_secretbox_xsalsa20poly1305(
        c: *mut u8,
        m: *const u8,
        mlen: c_ulonglong,
        n: *const [u8; crypto_secretbox_xsalsa20poly1305_NONCEBYTES],
        k: *const [u8; crypto_secretbox_xsalsa20poly1305_KEYBYTES]) -> c_int;
    pub fn crypto_secretbox_xsalsa20poly1305_open(
        m: *mut u8,
        c: *const u8,
        clen: c_ulonglong,
        n: *const [u8; crypto_secretbox_xsalsa20poly1305_NONCEBYTES],
        k: *const [u8; crypto_secretbox_xsalsa20poly1305_KEYBYTES]) -> c_int;
    pub fn crypto_secretbox_xsalsa20poly1305_keybytes() -> size_t;
    pub fn crypto_secretbox_xsalsa20poly1305_noncebytes() -> size_t;
    pub fn crypto_secretbox_xsalsa20poly1305_zerobytes() -> size_t;
    pub fn crypto_secretbox_xsalsa20poly1305_boxzerobytes() -> size_t;
    pub fn crypto_secretbox_xsalsa20poly1305_macbytes() -> size_t;
}

#[test]
fn test_crypto_secretbox_xsalsa20poly1305_keybytes() {
    assert!(unsafe {
        crypto_secretbox_xsalsa20poly1305_keybytes() as usize
    } == crypto_secretbox_xsalsa20poly1305_KEYBYTES)
}
#[test]
fn test_crypto_secretbox_xsalsa20poly1305_noncebytes() {
    assert!(unsafe {
        crypto_secretbox_xsalsa20poly1305_noncebytes() as usize
    } == crypto_secretbox_xsalsa20poly1305_NONCEBYTES)
}
#[test]
fn test_crypto_secretbox_xsalsa20poly1305_zerobytes() {
    assert!(unsafe {
        crypto_secretbox_xsalsa20poly1305_zerobytes() as usize
    } == crypto_secretbox_xsalsa20poly1305_ZEROBYTES)
}
#[test]
fn test_crypto_secretbox_xsalsa20poly1305_boxzerobytes() {
    assert!(unsafe {
        crypto_secretbox_xsalsa20poly1305_boxzerobytes() as usize
    } == crypto_secretbox_xsalsa20poly1305_BOXZEROBYTES)
}
#[test]
fn test_crypto_secretbox_xsalsa20poly1305_macbytes() {
    assert!(unsafe {
        crypto_secretbox_xsalsa20poly1305_macbytes() as usize
    } == crypto_secretbox_xsalsa20poly1305_MACBYTES)
}

'''
'''--- libsodium-sys/src/crypto_shorthash_siphash24.rs ---
// crypto_shorthash_siphash24.h

pub const crypto_shorthash_siphash24_BYTES: usize = 8;
pub const crypto_shorthash_siphash24_KEYBYTES: usize = 16;

extern {
    pub fn crypto_shorthash_siphash24(
        h: *mut [u8; crypto_shorthash_siphash24_BYTES],
        m: *const u8,
        mlen: c_ulonglong,
        k: *const [u8; crypto_shorthash_siphash24_KEYBYTES]) -> c_int;
    pub fn crypto_shorthash_siphash24_bytes() -> size_t;
    pub fn crypto_shorthash_siphash24_keybytes() -> size_t;
}

#[test]
fn test_crypto_shorthash_siphash24_bytes() {
    assert!(unsafe {
        crypto_shorthash_siphash24_bytes() as usize
    } == crypto_shorthash_siphash24_BYTES)
}
#[test]
fn test_crypto_shorthash_siphash24_keybytes() {
    assert!(unsafe {
        crypto_shorthash_siphash24_keybytes() as usize
    } == crypto_shorthash_siphash24_KEYBYTES)
}

'''
'''--- libsodium-sys/src/crypto_sign_ed25519.rs ---
// crypto_sign_ed25519.h
pub const crypto_sign_ed25519_BYTES: usize = 64;
pub const crypto_sign_ed25519_SEEDBYTES: usize = 32;
pub const crypto_sign_ed25519_PUBLICKEYBYTES: usize = 32;
pub const crypto_sign_ed25519_SECRETKEYBYTES: usize = 64;

#[repr(C)]
#[derive(Copy)]
pub struct crypto_sign_ed25519ph_state {
    hs: crypto_hash_sha512_state,
}
impl Clone for crypto_sign_ed25519ph_state { fn clone(&self) -> crypto_sign_ed25519ph_state { *self } }

extern {
    pub fn crypto_sign_ed25519_keypair(
        pk: *mut [u8; crypto_sign_ed25519_PUBLICKEYBYTES],
        sk: *mut [u8; crypto_sign_ed25519_SECRETKEYBYTES]) -> c_int;
    pub fn crypto_sign_ed25519_seed_keypair(
        pk: *mut [u8; crypto_sign_ed25519_PUBLICKEYBYTES],
        sk: *mut [u8; crypto_sign_ed25519_SECRETKEYBYTES],
        seed: *const [u8; crypto_sign_ed25519_SEEDBYTES]) -> c_int;
    pub fn crypto_sign_ed25519(
        sm: *mut u8,
        smlen: *mut c_ulonglong,
        m: *const u8,
        mlen: c_ulonglong,
        sk: *const [u8; crypto_sign_ed25519_SECRETKEYBYTES]) -> c_int;
    pub fn crypto_sign_ed25519_open(
        m: *mut u8,
        mlen: *mut c_ulonglong,
        sm: *const u8,
        smlen: c_ulonglong,
        pk: *const [u8; crypto_sign_ed25519_PUBLICKEYBYTES]) -> c_int;
    pub fn crypto_sign_ed25519_detached(
        sig: *mut [u8; crypto_sign_ed25519_BYTES],
        siglen: *mut c_ulonglong,
        m: *const u8,
        mlen: c_ulonglong,
        sk: *const [u8; crypto_sign_ed25519_SECRETKEYBYTES]) -> c_int;
    pub fn crypto_sign_ed25519_verify_detached(
        sig: *const [u8; crypto_sign_ed25519_BYTES],
        m: *const u8,
        mlen: c_ulonglong,
        pk: *const [u8; crypto_sign_ed25519_PUBLICKEYBYTES]) -> c_int;
    pub fn crypto_sign_ed25519_bytes() -> size_t;
    pub fn crypto_sign_ed25519_seedbytes() -> size_t;
    pub fn crypto_sign_ed25519_publickeybytes() -> size_t;
    pub fn crypto_sign_ed25519_secretkeybytes() -> size_t;

    pub fn crypto_sign_ed25519ph_init(state: *mut crypto_sign_ed25519ph_state) -> c_int;
    pub fn crypto_sign_ed25519ph_update(
        state: *mut crypto_sign_ed25519ph_state,
        m: *const u8,
        mlen: c_ulonglong) -> c_int;
    pub fn crypto_sign_ed25519ph_final_create(state: *mut crypto_sign_ed25519ph_state,
        sig: *const u8,
        siglen: *mut c_ulonglong,
        sk: *const [u8; crypto_sign_ed25519_SECRETKEYBYTES]) -> c_int;
    pub fn crypto_sign_ed25519ph_final_verify(state: *mut crypto_sign_ed25519ph_state,
        sig: *const u8,
        pk: *const [u8; crypto_sign_ed25519_PUBLICKEYBYTES]) -> c_int;

    pub fn crypto_sign_ed25519_pk_to_curve25519(curve25519_sk: *mut [u8; crypto_scalarmult_curve25519_BYTES],
        ed25519_sk: *const [u8; crypto_scalarmult_curve25519_BYTES]);

    pub fn crypto_sign_ed25519_sk_to_curve25519(curve25519_sk: *mut [u8; crypto_scalarmult_curve25519_BYTES],
        ed25519_sk: *const [u8; crypto_scalarmult_curve25519_BYTES]);
}

#[test]
fn test_crypto_sign_ed25519_bytes() {
    assert!(unsafe {
        crypto_sign_ed25519_bytes() as usize
    } == crypto_sign_ed25519_BYTES)
}
#[test]
fn test_crypto_sign_ed25519_seedbytes() {
    assert!(unsafe {
        crypto_sign_ed25519_seedbytes() as usize
    } == crypto_sign_ed25519_SEEDBYTES)
}
#[test]
fn test_crypto_sign_ed25519_publickeybytes() {
    assert!(unsafe {
        crypto_sign_ed25519_publickeybytes() as usize
    } == crypto_sign_ed25519_PUBLICKEYBYTES)
}
#[test]
fn test_crypto_sign_ed25519_secretkeybytes() {
    assert!(unsafe {
        crypto_sign_ed25519_secretkeybytes() as usize
    } == crypto_sign_ed25519_SECRETKEYBYTES)
}

'''
'''--- libsodium-sys/src/crypto_stream.rs ---
// crypto_stream.h

pub const crypto_stream_KEYBYTES: usize = crypto_stream_xsalsa20_KEYBYTES;
pub const crypto_stream_NONCEBYTES: usize =
    crypto_stream_xsalsa20_NONCEBYTES;
pub const crypto_stream_PRIMITIVE: &str = "xsalsa20";

extern {
    pub fn crypto_stream_keybytes() -> size_t;
    pub fn crypto_stream_noncebytes() -> size_t;
    pub fn crypto_stream_primitive() -> *const c_char;
}

#[test]
fn test_crypto_stream_keybytes() {
    assert!(unsafe { crypto_stream_keybytes() as usize } ==
            crypto_stream_KEYBYTES)
}
#[test]
fn test_crypto_stream_noncebytes() {
    assert!(unsafe { crypto_stream_noncebytes() as usize } ==
            crypto_stream_NONCEBYTES)
}
#[test]
fn test_crypto_stream_primitive() {
    unsafe {
        let s = crypto_stream_primitive();
        let s = std::ffi::CStr::from_ptr(s).to_bytes();
        assert!(s == crypto_stream_PRIMITIVE.as_bytes());
    }
}

'''
'''--- libsodium-sys/src/crypto_stream_chacha20.rs ---
// crypto_stream_chacha20.h

pub const crypto_stream_chacha20_KEYBYTES: usize = 32;
pub const crypto_stream_chacha20_NONCEBYTES: usize = 8;

extern {
    pub fn crypto_stream_chacha20(
        c: *mut u8,
        clen: c_ulonglong,
        n: *const [u8; crypto_stream_chacha20_NONCEBYTES],
        k: *const [u8; crypto_stream_chacha20_KEYBYTES]) -> c_int;
    pub fn crypto_stream_chacha20_xor(
        c: *mut u8,
        m: *const u8,
        mlen: c_ulonglong,
        n: *const [u8; crypto_stream_chacha20_NONCEBYTES],
        k: *const [u8; crypto_stream_chacha20_KEYBYTES]) -> c_int;
    pub fn crypto_stream_chacha20_keybytes() -> size_t;
    pub fn crypto_stream_chacha20_noncebytes() -> size_t;
}

#[test]
fn test_crypto_stream_chacha20_keybytes() {
    assert!(unsafe { crypto_stream_chacha20_keybytes() as usize } ==
            crypto_stream_chacha20_KEYBYTES)
}
#[test]
fn test_crypto_stream_chacha20_noncebytes() {
    assert!(unsafe { crypto_stream_chacha20_noncebytes() as usize } ==
            crypto_stream_chacha20_NONCEBYTES)
}

'''
'''--- libsodium-sys/src/crypto_stream_salsa20.rs ---
// crypto_stream_salsa20.h

pub const crypto_stream_salsa20_KEYBYTES: usize = 32;
pub const crypto_stream_salsa20_NONCEBYTES: usize = 8;

extern {
    pub fn crypto_stream_salsa20(
        c: *mut u8,
        clen: c_ulonglong,
        n: *const [u8; crypto_stream_salsa20_NONCEBYTES],
        k: *const [u8; crypto_stream_salsa20_KEYBYTES]) -> c_int;
    pub fn crypto_stream_salsa20_xor(
        c: *mut u8,
        m: *const u8,
        mlen: c_ulonglong,
        n: *const [u8; crypto_stream_salsa20_NONCEBYTES],
        k: *const [u8; crypto_stream_salsa20_KEYBYTES]) -> c_int;
    pub fn crypto_stream_salsa20_keybytes() -> size_t;
    pub fn crypto_stream_salsa20_noncebytes() -> size_t;
}

#[test]
fn test_crypto_stream_salsa20_keybytes() {
    assert!(unsafe { crypto_stream_salsa20_keybytes() as usize } ==
            crypto_stream_salsa20_KEYBYTES)
}
#[test]
fn test_crypto_stream_salsa20_noncebytes() {
    assert!(unsafe { crypto_stream_salsa20_noncebytes() as usize } ==
            crypto_stream_salsa20_NONCEBYTES)
}

'''
'''--- libsodium-sys/src/crypto_stream_salsa2012.rs ---
// crypto_stream_salsa2012.h

pub const crypto_stream_salsa2012_KEYBYTES: usize = 32;
pub const crypto_stream_salsa2012_NONCEBYTES: usize = 8;

extern {
    pub fn crypto_stream_salsa2012(
        c: *mut u8,
        clen: c_ulonglong,
        n: *const [u8; crypto_stream_salsa2012_NONCEBYTES],
        k: *const [u8; crypto_stream_salsa2012_KEYBYTES]) -> c_int;
    pub fn crypto_stream_salsa2012_xor(
        c: *mut u8,
        m: *const u8,
        mlen: c_ulonglong,
        n: *const [u8; crypto_stream_salsa2012_NONCEBYTES],
        k: *const [u8; crypto_stream_salsa2012_KEYBYTES]) -> c_int;
    pub fn crypto_stream_salsa2012_keybytes() -> size_t;
    pub fn crypto_stream_salsa2012_noncebytes() -> size_t;
}

#[test]
fn test_crypto_stream_salsa2012_keybytes() {
    assert!(unsafe { crypto_stream_salsa2012_keybytes() as usize } ==
            crypto_stream_salsa2012_KEYBYTES)
}
#[test]
fn test_crypto_stream_salsa2012_noncebytes() {
    assert!(unsafe { crypto_stream_salsa2012_noncebytes() as usize } ==
            crypto_stream_salsa2012_NONCEBYTES)
}

'''
'''--- libsodium-sys/src/crypto_stream_salsa208.rs ---
// crypto_stream_salsa208.h

pub const crypto_stream_salsa208_KEYBYTES: usize = 32;
pub const crypto_stream_salsa208_NONCEBYTES: usize = 8;

extern {
    pub fn crypto_stream_salsa208(
        c: *mut u8,
        clen: c_ulonglong,
        n: *const [u8; crypto_stream_salsa208_NONCEBYTES],
        k: *const [u8; crypto_stream_salsa208_KEYBYTES]) -> c_int;
    pub fn crypto_stream_salsa208_xor(
        c: *mut u8,
        m: *const u8,
        mlen: c_ulonglong,
        n: *const [u8; crypto_stream_salsa208_NONCEBYTES],
        k: *const [u8; crypto_stream_salsa208_KEYBYTES]) -> c_int;
    pub fn crypto_stream_salsa208_keybytes() -> size_t;
    pub fn crypto_stream_salsa208_noncebytes() -> size_t;
}

#[test]
fn test_crypto_stream_salsa208_keybytes() {
    assert!(unsafe { crypto_stream_salsa208_keybytes() as usize } ==
            crypto_stream_salsa208_KEYBYTES)
}
#[test]
fn test_crypto_stream_salsa208_noncebytes() {
    assert!(unsafe { crypto_stream_salsa208_noncebytes() as usize } ==
            crypto_stream_salsa208_NONCEBYTES)
}

'''
'''--- libsodium-sys/src/crypto_stream_xsalsa20.rs ---
// crypto_stream_xsalsa20.h

pub const crypto_stream_xsalsa20_KEYBYTES: usize = 32;
pub const crypto_stream_xsalsa20_NONCEBYTES: usize = 24;

extern {
    pub fn crypto_stream_xsalsa20(
        c: *mut u8,
        clen: c_ulonglong,
        n: *const [u8; crypto_stream_xsalsa20_NONCEBYTES],
        k: *const [u8; crypto_stream_xsalsa20_KEYBYTES]) -> c_int;
    pub fn crypto_stream_xsalsa20_xor(
        c: *mut u8,
        m: *const u8,
        mlen: c_ulonglong,
        n: *const [u8; crypto_stream_xsalsa20_NONCEBYTES],
        k: *const [u8; crypto_stream_xsalsa20_KEYBYTES]) -> c_int;
    pub fn crypto_stream_xsalsa20_keybytes() -> size_t;
    pub fn crypto_stream_xsalsa20_noncebytes() -> size_t;
}

#[test]
fn test_crypto_stream_xsalsa20_keybytes() {
    assert!(unsafe { crypto_stream_xsalsa20_keybytes() as usize } ==
            crypto_stream_xsalsa20_KEYBYTES)
}
#[test]
fn test_crypto_stream_xsalsa20_noncebytes() {
    assert!(unsafe { crypto_stream_xsalsa20_noncebytes() as usize } ==
            crypto_stream_xsalsa20_NONCEBYTES)
}

'''
'''--- libsodium-sys/src/crypto_verify_16.rs ---
// crypto_verify_16.h

pub const crypto_verify_16_BYTES: usize = 16;

extern {
    pub fn crypto_verify_16_bytes() -> size_t;
    pub fn crypto_verify_16(
        x: *const [u8; crypto_verify_16_BYTES],
        y: *const [u8; crypto_verify_16_BYTES])
        -> c_int;
}

#[test]
fn test_crypto_verify_16_bytes() {
   assert_eq!(unsafe { crypto_verify_16_bytes() as usize },
                       crypto_verify_16_BYTES);
}

'''
'''--- libsodium-sys/src/crypto_verify_32.rs ---
// crypto_verify_32.h

pub const crypto_verify_32_BYTES: usize = 32;

extern {
    pub fn crypto_verify_32_bytes() -> size_t;
    pub fn crypto_verify_32(
        x: *const [u8; crypto_verify_32_BYTES],
        y: *const [u8; crypto_verify_32_BYTES]) -> c_int;
}

#[test]
fn test_crypto_verify_32_bytes() {
   assert_eq!(unsafe { crypto_verify_32_bytes() as usize },
                       crypto_verify_32_BYTES);
}

'''
'''--- libsodium-sys/src/crypto_verify_64.rs ---
// crypto_verify_64.h

pub const crypto_verify_64_BYTES: usize = 64;

extern {
    pub fn crypto_verify_64_bytes() -> size_t;
    pub fn crypto_verify_64(
        x: *const [u8; crypto_verify_64_BYTES],
        y: *const [u8; crypto_verify_64_BYTES]) -> c_int;
}

#[test]
fn test_crypto_verify_64_bytes() {
   assert_eq!(unsafe { crypto_verify_64_bytes() as usize },
                       crypto_verify_64_BYTES);
}

'''
'''--- libsodium-sys/src/randombytes.rs ---
// randombytes.h

extern {
    pub fn randombytes_buf(buf: *mut u8,
                           size: size_t);
}

'''
'''--- libsodium-sys/src/utils.rs ---
// utils.h

extern {
    pub fn sodium_memzero(pnt: *mut u8, len: size_t);
    pub fn sodium_memcmp(b1_: *const u8, b2_: *const u8, len: size_t) -> c_int;
    pub fn sodium_increment(n: *mut u8, len: size_t);

    pub fn sodium_mlock(addr: *const c_void, len: size_t) -> c_int;
    pub fn sodium_munlock(addr: *const c_void, len: size_t) -> c_int;

    pub fn sodium_malloc(len: size_t) -> *mut c_void;
    pub fn sodium_allocarray(count: size_t, size: size_t) -> *mut c_void;
    pub fn sodium_free(ptr: *mut c_void);

    pub fn sodium_mprotect_noaccess(ptr: *const c_void) -> c_int;
    pub fn sodium_mprotect_readonly(ptr: *const c_void) -> c_int;
    pub fn sodium_mprotect_readwrite(ptr: *const c_void) -> c_int;
}

'''
'''--- libsodium-sys/src/version.rs ---
// version.h

extern {
    pub fn sodium_version_string() -> *const c_char;
    pub fn sodium_library_version_major() -> c_int;
    pub fn sodium_library_version_minor() -> c_int;
}

#[test]
fn test_sodium_library_version_major() {
    assert!(unsafe { sodium_library_version_major() } > 0)
}

#[test]
fn test_sodium_library_version_minor() {
    assert!(unsafe { sodium_library_version_minor() } >= 0)
}

'''
'''--- src/crypto/aead/aead_macros.rs ---
macro_rules! aead_module (($seal_name:ident,
                           $open_name:ident,
                           $seal_detached_name:ident,
                           $open_detached_name:ident,
                           $keybytes:expr,
                           $noncebytes:expr,
                           $tagbytes:expr) => (

#[cfg(not(feature = "std"))] use prelude::*;
use libc::c_ulonglong;
use randombytes::randombytes_into;
use std::ptr;

/// Number of bytes in a `Key`.
pub const KEYBYTES: usize = $keybytes;

/// Number of bytes in a `Nonce`.
pub const NONCEBYTES: usize = $noncebytes;

/// Number of bytes in an authentication `Tag`.
pub const TAGBYTES: usize = $tagbytes;

new_type! {
    /// `Key` for symmetric authenticated encryption with additional data.
    ///
    /// When a `Key` goes out of scope its contents will
    /// be zeroed out
    secret Key(KEYBYTES);
}

new_type! {
    /// `Nonce` for symmetric authenticated encryption with additional data.
    nonce Nonce(NONCEBYTES);
}

new_type! {
    /// Authentication `Tag` for symmetric authenticated encryption with additional data in
    /// detached mode.
    public Tag(TAGBYTES);
}

/// `gen_key()` randomly generates a secret key
///
/// THREAD SAFETY: `gen_key()` is thread-safe provided that you have
/// called `sodiumoxide::init()` once before using any other function
/// from sodiumoxide.
pub fn gen_key() -> Key {
    let mut k = Key([0u8; KEYBYTES]);
    randombytes_into(&mut k.0);
    k
}

/// `gen_nonce()` randomly generates a nonce
///
/// THREAD SAFETY: `gen_key()` is thread-safe provided that you have
/// called `sodiumoxide::init()` once before using any other function
/// from sodiumoxide.
pub fn gen_nonce() -> Nonce {
    let mut n = Nonce([0u8; NONCEBYTES]);
    randombytes_into(&mut n.0);
    n
}

/// `seal()` encrypts and authenticates a message `m` together with optional plaintext data `ad`
/// using a secret key `k` and a nonce `n`. It returns a ciphertext `c`.
pub fn seal(m: &[u8], ad: Option<&[u8]>, n: &Nonce, k: &Key) -> Vec<u8> {
    let (ad_p, ad_len) = ad.map(|ad| (ad.as_ptr(), ad.len() as c_ulonglong)).unwrap_or((0 as *const _, 0));
    let mut c = Vec::with_capacity(m.len() + TAGBYTES);
    let mut clen = c.len() as c_ulonglong;

    unsafe {
        $seal_name(
            c.as_mut_ptr(),
            &mut clen,
            m.as_ptr(),
            m.len() as c_ulonglong,
            ad_p,
            ad_len,
            ptr::null_mut(),
            &n.0,
            &k.0
        );
        c.set_len(clen as usize);
    }
    c
}

/// `seal_detached()` encrypts and authenticates a message `m` together with optional plaintext data `ad`
/// using a secret key `k` and a nonce `n`.
/// `m` is encrypted in place, so after this function returns it will contain the ciphertext.
/// The detached authentication tag is returned by value.
pub fn seal_detached(m: &mut [u8], ad: Option<&[u8]>, n: &Nonce, k: &Key) -> Tag {
    let (ad_p, ad_len) = ad.map(|ad| (ad.as_ptr(), ad.len() as c_ulonglong)).unwrap_or((ptr::null(), 0));
    let mut tag = Tag([0u8; TAGBYTES]);
    let mut maclen = TAGBYTES as c_ulonglong;
    unsafe {
        $seal_detached_name(
            m.as_mut_ptr(),
            tag.0.as_mut_ptr(),
            &mut maclen,
            m.as_ptr(),
            m.len() as c_ulonglong,
            ad_p,
            ad_len,
            ptr::null_mut(),
            &n.0,
            &k.0
        );
    }
    tag
}

/// `open()` verifies and decrypts a ciphertext `c` together with optional plaintext data `ad`
/// using a secret key `k` and a nonce `n`.
/// It returns a plaintext `Ok(m)`.
/// If the ciphertext fails verification, `open()` returns `Err(())`.
pub fn open(c: &[u8], ad: Option<&[u8]>, n: &Nonce, k: &Key) -> Result<Vec<u8>, ()> {
    if c.len() < TAGBYTES {
        return Err(());
    }
    let (ad_p, ad_len) = ad.map(|ad| (ad.as_ptr(), ad.len() as c_ulonglong)).unwrap_or((ptr::null(), 0));
    let mut m = Vec::with_capacity(c.len() - TAGBYTES);
    let mut mlen = m.len() as c_ulonglong;

    unsafe {
        let ret =
            $open_name(
                m.as_mut_ptr(),
                &mut mlen,
                ptr::null_mut(),
                c.as_ptr(),
                c.len() as c_ulonglong,
                ad_p,
                ad_len,
                &n.0,
                &k.0
            );
        if ret != 0 {
            return Err(());
        }
        m.set_len(mlen as usize);
    }
    Ok(m)
}
/// `open_detached()` verifies and decrypts a ciphertext `c` toghether with optional plaintext data `ad`
/// and and authentication tag `tag`, using a secret key `k` and a nonce `n`.
/// `c` is decrypted in place, so if this function is successful it will contain the plaintext.
/// If the ciphertext fails verification, `open_detached()` returns `Err(())`,
/// and the ciphertext is not modified.
pub fn open_detached(c: &mut [u8], ad: Option<&[u8]>, t: &Tag, n: &Nonce, k: &Key) -> Result<(), ()> {
    let (ad_p, ad_len) = ad.map(|ad| (ad.as_ptr(), ad.len() as c_ulonglong)).unwrap_or((ptr::null(), 0));
    let ret = unsafe {
        $open_detached_name(
            c.as_mut_ptr(),
            ptr::null_mut(),
            c.as_ptr(),
            c.len() as c_ulonglong,
            t.0.as_ptr(),
            ad_p,
            ad_len,
            &n.0,
            &k.0
        )
    };
    if ret == 0 {
        Ok(())
    } else {
        Err(())
    }
}

#[cfg(test)]
mod test_m {
    use super::*;

    #[test]
    fn test_seal_open() {
        use randombytes::randombytes;
        for i in 0..256usize {
            let k = gen_key();
            let n = gen_nonce();
            let ad = randombytes(i);
            let m = randombytes(i);
            let c = seal(&m, Some(&ad), &n, &k);
            let m2 = open(&c, Some(&ad), &n, &k).unwrap();
            assert_eq!(m, m2);
        }
    }

    #[test]
    fn test_seal_open_tamper() {
        use randombytes::randombytes;
        for i in 0..32usize {
            let k = gen_key();
            let n = gen_nonce();
            let mut ad = randombytes(i);
            let m = randombytes(i);
            let mut c = seal(&m, Some(&ad), &n, &k);
            for j in 0..c.len() {
                c[j] ^= 0x20;
                let m2 = open(&c, Some(&ad), &n, &k);
                c[j] ^= 0x20;
                assert!(m2.is_err());
            }
            for j in 0..ad.len() {
                ad[j] ^= 0x20;
                let m2 = open(&c, Some(&ad), &n, &k);
                ad[j] ^= 0x20;
                assert!(m2.is_err());
            }
        }
    }

    #[test]
    fn test_seal_open_detached() {
        use randombytes::randombytes;
        for i in 0..256usize {
            let k = gen_key();
            let n = gen_nonce();
            let ad = randombytes(i);
            let mut m = randombytes(i);
            let m2 = m.clone();
            let t = seal_detached(&mut m, Some(&ad), &n, &k);
            open_detached(&mut m, Some(&ad), &t, &n, &k).unwrap();
            assert_eq!(m, m2);
        }
    }

    #[test]
    fn test_seal_open_detached_tamper() {
        use randombytes::randombytes;
        for i in 0..32usize {
            let k = gen_key();
            let n = gen_nonce();
            let mut ad = randombytes(i);
            let mut m = randombytes(i);
            let mut t = seal_detached(&mut m, Some(&ad), &n, &k);
            for j in 0..m.len() {
                m[j] ^= 0x20;
                let r = open_detached(&mut m, Some(&ad), &t, &n, &k);
                m[j] ^= 0x20;
                assert!(r.is_err());
            }
            for j in 0..ad.len() {
                ad[j] ^= 0x20;
                let r = open_detached(&mut m, Some(&ad), &t, &n, &k);
                ad[j] ^= 0x20;
                assert!(r.is_err());
            }
            for j in 0..t.0.len() {
                t.0[j] ^= 0x20;
                let r = open_detached(&mut m, Some(&ad), &t, &n, &k);
                t.0[j] ^= 0x20;
                assert!(r.is_err());
            }
        }
    }

    #[test]
    fn test_seal_open_detached_same() {
        use randombytes::randombytes;
        for i in 0..256usize {
            let k = gen_key();
            let n = gen_nonce();
            let ad = randombytes(i);
            let mut m = randombytes(i);

            let c = seal(&m, Some(&ad), &n, &k);
            let t = seal_detached(&mut m, Some(&ad), &n, &k);

            assert_eq!(&c[0..c.len()-TAGBYTES], &m[..]);
            assert_eq!(&c[c.len()-TAGBYTES..], &t.0[..]);

            let m2 = open(&c, Some(&ad), &n, &k).unwrap();
            open_detached(&mut m, Some(&ad), &t, &n, &k).unwrap();

            assert_eq!(m2, m);
        }
    }
}

));

'''
'''--- src/crypto/aead/chacha20poly1305.rs ---
//! The original ChaCha20-Poly1305 construction can safely encrypt a pratically
//! unlimited number of messages with the same key, without any practical limit
//! to the size of a message (up to ~ 2^64 bytes).
use ffi::{crypto_aead_chacha20poly1305_ABYTES, crypto_aead_chacha20poly1305_KEYBYTES,
          crypto_aead_chacha20poly1305_NPUBBYTES, crypto_aead_chacha20poly1305_decrypt,
          crypto_aead_chacha20poly1305_decrypt_detached, crypto_aead_chacha20poly1305_encrypt,
          crypto_aead_chacha20poly1305_encrypt_detached};
aead_module!(
    crypto_aead_chacha20poly1305_encrypt,
    crypto_aead_chacha20poly1305_decrypt,
    crypto_aead_chacha20poly1305_encrypt_detached,
    crypto_aead_chacha20poly1305_decrypt_detached,
    crypto_aead_chacha20poly1305_KEYBYTES,
    crypto_aead_chacha20poly1305_NPUBBYTES,
    crypto_aead_chacha20poly1305_ABYTES
);

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_vector_1() {
        // Test from https://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-04#section-7
        let m = &[0x86, 0xd0, 0x99, 0x74, 0x84, 0x0b, 0xde, 0xd2, 0xa5, 0xca];
        let k = Key([
            0x42, 0x90, 0xbc, 0xb1, 0x54, 0x17, 0x35, 0x31, 0xf3, 0x14, 0xaf, 0x57, 0xf3, 0xbe,
            0x3b, 0x50, 0x06, 0xda, 0x37, 0x1e, 0xce, 0x27, 0x2a, 0xfa, 0x1b, 0x5d, 0xbd, 0xd1,
            0x10, 0x0a, 0x10, 0x07,
        ]);
        let n = Nonce([0xcd, 0x7c, 0xf6, 0x7b, 0xe3, 0x9c, 0x79, 0x4a]);
        let ad = &[0x87, 0xe2, 0x29, 0xd4, 0x50, 0x08, 0x45, 0xa0, 0x79, 0xc0];

        let c_expected = &[
            0xe3, 0xe4, 0x46, 0xf7, 0xed, 0xe9, 0xa1, 0x9b, 0x62, 0xa4, 0x67, 0x7d, 0xab, 0xf4,
            0xe3, 0xd2, 0x4b, 0x87, 0x6b, 0xb2, 0x84, 0x75, 0x38, 0x96, 0xe1, 0xd6,
        ];

        let c = seal(m, Some(ad), &n, &k);
        assert_eq!(&c[..], c_expected);
    }
}

'''
'''--- src/crypto/aead/chacha20poly1305_ietf.rs ---
//! The IETF variant of the ChaCha20-Poly1305 construction can safely encrypt a
//! practically unlimited number of messages, but individual messages cannot
//! exceed 64*(2^32)-64 bytes (approximatively 256 GB).
use ffi::{crypto_aead_chacha20poly1305_ietf_ABYTES, crypto_aead_chacha20poly1305_ietf_KEYBYTES,
          crypto_aead_chacha20poly1305_ietf_NPUBBYTES, crypto_aead_chacha20poly1305_ietf_decrypt,
          crypto_aead_chacha20poly1305_ietf_decrypt_detached,
          crypto_aead_chacha20poly1305_ietf_encrypt,
          crypto_aead_chacha20poly1305_ietf_encrypt_detached};
aead_module!(
    crypto_aead_chacha20poly1305_ietf_encrypt,
    crypto_aead_chacha20poly1305_ietf_decrypt,
    crypto_aead_chacha20poly1305_ietf_encrypt_detached,
    crypto_aead_chacha20poly1305_ietf_decrypt_detached,
    crypto_aead_chacha20poly1305_ietf_KEYBYTES,
    crypto_aead_chacha20poly1305_ietf_NPUBBYTES,
    crypto_aead_chacha20poly1305_ietf_ABYTES
);

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_vector_1() {
        // Test vector from https://tools.ietf.org/html/rfc7539#section-2.8.1
        let m = &[
            0x4c, 0x61, 0x64, 0x69, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x47, 0x65, 0x6e,
            0x74, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20,
            0x63, 0x6c, 0x61, 0x73, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x27, 0x39, 0x39, 0x3a, 0x20,
            0x49, 0x66, 0x20, 0x49, 0x20, 0x63, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6f, 0x66, 0x66,
            0x65, 0x72, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x6f, 0x6e,
            0x65, 0x20, 0x74, 0x69, 0x70, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20,
            0x66, 0x75, 0x74, 0x75, 0x72, 0x65, 0x2c, 0x20, 0x73, 0x75, 0x6e, 0x73, 0x63, 0x72,
            0x65, 0x65, 0x6e, 0x20, 0x77, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x69,
            0x74, 0x2e,
        ];
        let ad = &[
            0x50, 0x51, 0x52, 0x53, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
        ];
        let k = Key([
            0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d,
            0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b,
            0x9c, 0x9d, 0x9e, 0x9f,
        ]);
        let n = Nonce([
            0x07, 0x00, 0x00, 0x00, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
        ]);

        let c_expected = &[
            0xd3, 0x1a, 0x8d, 0x34, 0x64, 0x8e, 0x60, 0xdb, 0x7b, 0x86, 0xaf, 0xbc, 0x53, 0xef,
            0x7e, 0xc2, 0xa4, 0xad, 0xed, 0x51, 0x29, 0x6e, 0x08, 0xfe, 0xa9, 0xe2, 0xb5, 0xa7,
            0x36, 0xee, 0x62, 0xd6, 0x3d, 0xbe, 0xa4, 0x5e, 0x8c, 0xa9, 0x67, 0x12, 0x82, 0xfa,
            0xfb, 0x69, 0xda, 0x92, 0x72, 0x8b, 0x1a, 0x71, 0xde, 0x0a, 0x9e, 0x06, 0x0b, 0x29,
            0x05, 0xd6, 0xa5, 0xb6, 0x7e, 0xcd, 0x3b, 0x36, 0x92, 0xdd, 0xbd, 0x7f, 0x2d, 0x77,
            0x8b, 0x8c, 0x98, 0x03, 0xae, 0xe3, 0x28, 0x09, 0x1b, 0x58, 0xfa, 0xb3, 0x24, 0xe4,
            0xfa, 0xd6, 0x75, 0x94, 0x55, 0x85, 0x80, 0x8b, 0x48, 0x31, 0xd7, 0xbc, 0x3f, 0xf4,
            0xde, 0xf0, 0x8e, 0x4b, 0x7a, 0x9d, 0xe5, 0x76, 0xd2, 0x65, 0x86, 0xce, 0xc6, 0x4b,
            0x61, 0x16, 0x1a, 0xe1, 0x0b, 0x59, 0x4f, 0x09, 0xe2, 0x6a, 0x7e, 0x90, 0x2e, 0xcb,
            0xd0, 0x60, 0x06, 0x91,
        ];
        let c = seal(m, Some(ad), &n, &k);
        assert_eq!(&c[..], &c_expected[..]);
    }
}

'''
'''--- src/crypto/aead/mod.rs ---
//! Authenticated Encryption with Additional Data
//! This operation:
//!
//! - Encrypts a message with a key and a nonce to keep it confidential
//! - Computes an authentication tag. This tag is used to make sure that the message,
//!   as well as optional, non-confidential (non-encrypted) data, haven't been tampered with.
//!
//! # Selected primitive
//! `seal()`, `seal_detached()`, `open()` and `open_detached()` are currently
//! an implementation of `chacha20poly1305_ietf`, i.e. the IETF construction defined in
//! https://tools.ietf.org/html/rfc7539.
//!
//! # Example (combined mode)
//! ```
//! use exonum_sodiumoxide::crypto::aead;
//!
//! let k = aead::gen_key();
//! let n = aead::gen_nonce();
//! let m = b"Some plaintext";
//! let ad = b"Some additional data";
//!
//! let c = aead::seal(m, Some(ad), &n, &k);
//! let m2 = aead::open(&c, Some(ad), &n, &k).unwrap();
//!
//! assert_eq!(&m[..], &m2[..]);
//!```
//!
//! # Example (detached mode)
//! ```
//! use exonum_sodiumoxide::crypto::aead;
//!
//! let k = aead::gen_key();
//! let n = aead::gen_nonce();
//! let mut m = [0x41, 0x42, 0x43, 0x44];
//! let m2 = m.clone();
//! let ad = b"Some additional data";
//!
//! let t = aead::seal_detached(&mut m, Some(ad), &n, &k);
//! aead::open_detached(&mut m, Some(ad), &t, &n, &k).unwrap();
//!
//! assert_eq!(m, m2);
//! ```

pub use self::chacha20poly1305_ietf::*;
#[macro_use]
mod aead_macros;
pub mod chacha20poly1305;
pub mod chacha20poly1305_ietf;

'''
'''--- src/crypto/auth/auth_macros.rs ---
#[allow(unused_macros)]
macro_rules! auth_module (($auth_name:ident,
                           $verify_name:ident,
                           $keybytes:expr,
                           $tagbytes:expr) => (

use libc::c_ulonglong;
use randombytes::randombytes_into;

/// Number of bytes in a `Key`.
pub const KEYBYTES: usize = $keybytes;

/// Number of bytes in a `Tag`.
pub const TAGBYTES: usize = $tagbytes;

new_type! {
    /// Authentication `Key`
    ///
    /// When a `Key` goes out of scope its contents
    /// will be zeroed out
    secret Key(KEYBYTES);
}

new_type! {
    /// Authentication `Tag`
    ///
    /// The tag implements the traits `PartialEq` and `Eq` using constant-time
    /// comparison functions. See `sodiumoxide::utils::memcmp`
    public Tag(TAGBYTES);
}

/// `gen_key()` randomly generates a key for authentication
///
/// THREAD SAFETY: `gen_key()` is thread-safe provided that you have
/// called `sodiumoxide::init()` once before using any other function
/// from sodiumoxide.
pub fn gen_key() -> Key {
    let mut k = [0; KEYBYTES];
    randombytes_into(&mut k);
    Key(k)
}

/// `authenticate()` authenticates a message `m` using a secret key `k`.
/// The function returns an authenticator tag.
pub fn authenticate(m: &[u8],
                    &Key(ref k): &Key) -> Tag {
    unsafe {
        let mut tag = [0; TAGBYTES];
        $auth_name(&mut tag,
                   m.as_ptr(),
                   m.len() as c_ulonglong,
                   k);
        Tag(tag)
    }
}

/// `verify()` returns `true` if `tag` is a correct authenticator of message `m`
/// under a secret key `k`. Otherwise it returns false.
pub fn verify(&Tag(ref tag): &Tag, m: &[u8],
              &Key(ref k): &Key) -> bool {
    unsafe {
        $verify_name(tag,
                     m.as_ptr(),
                     m.len() as c_ulonglong,
                     k) == 0
    }
}

#[cfg(test)]
mod test_m {
    use super::*;

    #[test]
    fn test_auth_verify() {
        use randombytes::randombytes;
        for i in 0..256usize {
            let k = gen_key();
            let m = randombytes(i);
            let tag = authenticate(&m, &k);
            assert!(verify(&tag, &m, &k));
        }
    }

    #[test]
    fn test_auth_verify_tamper() {
        use randombytes::randombytes;
        for i in 0..32usize {
            let k = gen_key();
            let mut m = randombytes(i);
            let Tag(mut tagbuf) = authenticate(&mut m, &k);
            for j in 0..m.len() {
                m[j] ^= 0x20;
                assert!(!verify(&Tag(tagbuf), &mut m, &k));
                m[j] ^= 0x20;
            }
            for j in 0..tagbuf.len() {
                tagbuf[j] ^= 0x20;
                assert!(!verify(&Tag(tagbuf), &mut m, &k));
                tagbuf[j] ^= 0x20;
            }
        }
    }

    #[cfg(feature = "serde")]
    #[test]
    fn test_serialisation() {
        use randombytes::randombytes;
        use test_utils::round_trip;
        for i in 0..256usize {
            let k = gen_key();
            let m = randombytes(i);
            let tag = authenticate(&m, &k);
            round_trip(k);
            round_trip(tag);
        }
    }
}

#[cfg(feature = "benchmarks")]
#[cfg(test)]
mod bench_m {
    extern crate test;
    use randombytes::randombytes;
    use super::*;

    const BENCH_SIZES: [usize; 14] = [0, 1, 2, 4, 8, 16, 32, 64,
                                      128, 256, 512, 1024, 2048, 4096];

    #[bench]
    fn bench_auth(b: &mut test::Bencher) {
        let k = gen_key();
        let ms: Vec<Vec<u8>> = BENCH_SIZES.iter().map(|s| {
            randombytes(*s)
        }).collect();
        b.iter(|| {
            for m in ms.iter() {
                authenticate(&m, &k);
            }
        });
    }

    #[bench]
    fn bench_verify(b: &mut test::Bencher) {
        let k = gen_key();
        let ms: Vec<Vec<u8>> = BENCH_SIZES.iter().map(|s| {
            randombytes(*s)
        }).collect();
        let tags: Vec<Tag> = ms.iter().map(|m| {
            authenticate(&m, &k)
        }).collect();
        b.iter(|| {
            for (m, t) in ms.iter().zip(tags.iter()) {
                verify(t, &m, &k);
            }
        });
    }
}

));

/// Macro for defining streaming authenticator tag computation types and functions.
///
/// Parameters:
/// $state_name - The authenticator state type.
///               SAFETY NOTE: This needs to be a type that does not define a `Drop`
///               implementation, otherwise undefined behaviour will occur.
/// $init_name - A function `f(s: *mut $state_name, k: *u8, klen: size_t)` that initializes
///              a state with a key.
/// $update_name - A function `f(s: *mut $state_name, m: *u8, mlen: size_t)` that updates
///                a state with a message chunk.
/// $final_name - A function `f(s: *mut $state_name, t: *u8)` that computes an authenticator                    tag of length $tagbytes from a $state_name.
/// $tagbytes   - The number of bytes in an authenticator tag.
#[allow(unused_macros)]
macro_rules! auth_state (($state_name:ident,
                          $init_name:ident,
                          $update_name:ident,
                          $final_name:ident,
                          $tagbytes:expr) => (

use std::mem;
use ffi;

/// Authentication `State`
///
/// State for multi-part (streaming) authenticator tag (HMAC) computation.
///
/// When a `State` goes out of scope its contents will be zeroed out.
///
/// NOTE: the streaming interface takes variable length keys, as opposed to the
/// simple interface which takes a fixed length key. The streaming interface also does not
/// define its own `Key` type, instead using slices for its `init()` method.
/// The caller of the functions is responsible for zeroing out the key after it's been used
/// (in contrast to the simple interface which defines a `Drop` implementation for `Key`).
///
/// NOTE: these functions are specific to `libsodium` and do not exist in `NaCl`.

#[must_use]
pub struct State($state_name);

impl Drop for State {
    fn drop(&mut self) {
        let &mut State(ref mut s) = self;
        unsafe {
            let sp: *mut $state_name = s;
            ffi::sodium_memzero(sp as *mut u8, mem::size_of_val(s));
        }
    }
}

impl State {
    /// `init()` initializes an authentication structure using a secret key 'k'.
    pub fn init(k: &[u8]) -> State {
        unsafe {
            let mut s = mem::uninitialized();
            $init_name(&mut s, k.as_ptr(), k.len());
            State(s)
        }
    }

    /// `update()` can be called more than once in order to compute the authenticator
    /// from sequential chunks of the message.
    pub fn update(&mut self, in_: &[u8]) {
        let &mut State(ref mut state) = self;
        unsafe {
            $update_name(state, in_.as_ptr(), in_.len() as c_ulonglong);
        }
    }

    /// `finalize()` finalizes the authenticator computation and returns a `Tag`.
    pub fn finalize(&mut self) -> Tag {
        unsafe {
            let &mut State(ref mut state) = self;
            let mut tag = [0; $tagbytes as usize];
            $final_name(state, &mut tag);
            Tag(tag)
        }
    }
}

#[cfg(test)]
mod test_s {
    use super::*;

    #[test]
    fn test_auth_eq_auth_state() {
        use randombytes::randombytes;
        for i in 0..256usize {
            let k = gen_key();
            let m = randombytes(i);
            let tag = authenticate(&m, &k);
            let mut state = State::init(&k[..]);
            state.update(&m);
            let tag2 = state.finalize();
            assert_eq!(tag, tag2);
        }
    }

    #[test]
    fn test_auth_eq_auth_state_chunked() {
        use randombytes::randombytes;
        for i in 0..256usize {
            let k = gen_key();
            let m = randombytes(i);
            let tag = authenticate(&m, &k);
            let mut state = State::init(&k[..]);
            for c in m.chunks(1) {
                state.update(c);
            }
            let tag2 = state.finalize();
            assert_eq!(tag, tag2);
        }
    }
}
));

'''
'''--- src/crypto/auth/hmacsha256.rs ---
//! `HMAC-SHA-256` `HMAC-SHA-256` is conjectured to meet the standard notion of
//! unforgeability.
use ffi::{crypto_auth_hmacsha256, crypto_auth_hmacsha256_BYTES, crypto_auth_hmacsha256_KEYBYTES,
          crypto_auth_hmacsha256_final, crypto_auth_hmacsha256_init, crypto_auth_hmacsha256_state,
          crypto_auth_hmacsha256_update, crypto_auth_hmacsha256_verify};

auth_module!(
    crypto_auth_hmacsha256,
    crypto_auth_hmacsha256_verify,
    crypto_auth_hmacsha256_KEYBYTES,
    crypto_auth_hmacsha256_BYTES
);

auth_state!(
    crypto_auth_hmacsha256_state,
    crypto_auth_hmacsha256_init,
    crypto_auth_hmacsha256_update,
    crypto_auth_hmacsha256_final,
    crypto_auth_hmacsha256_BYTES
);

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_vector_1() {
        // corresponding to tests/auth2.c from NaCl
        let key = Key([
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
            0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c,
            0x1d, 0x1e, 0x1f, 0x20,
        ]);
        let c = [
            0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
            0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
            0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
            0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
        ];
        let a_expected = Tag([
            0x37, 0x2e, 0xfc, 0xf9, 0xb4, 0x0b, 0x35, 0xc2, 0x11, 0x5b, 0x13, 0x46, 0x90, 0x3d,
            0x2e, 0xf4, 0x2f, 0xce, 0xd4, 0x6f, 0x08, 0x46, 0xe7, 0x25, 0x7b, 0xb1, 0x56, 0xd3,
            0xd7, 0xb3, 0x0d, 0x3f,
        ]);
        let a = authenticate(&c, &key);
        assert!(a == a_expected);
    }

    #[test]
    fn test_vector_state_1() {
        // corresponding to tests/auth2.c from NaCl
        let key = [
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
            0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c,
            0x1d, 0x1e, 0x1f, 0x20,
        ];
        let c = [
            0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
            0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
            0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
            0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
        ];
        let a_expected = Tag([
            0x37, 0x2e, 0xfc, 0xf9, 0xb4, 0x0b, 0x35, 0xc2, 0x11, 0x5b, 0x13, 0x46, 0x90, 0x3d,
            0x2e, 0xf4, 0x2f, 0xce, 0xd4, 0x6f, 0x08, 0x46, 0xe7, 0x25, 0x7b, 0xb1, 0x56, 0xd3,
            0xd7, 0xb3, 0x0d, 0x3f,
        ]);
        let mut state = State::init(&key);
        state.update(&c);
        let a = state.finalize();
        assert!(a == a_expected);
    }
}

'''
'''--- src/crypto/auth/hmacsha512.rs ---
//! `HMAC-SHA-512` `HMAC-SHA-512` is conjectured to meet the standard notion of
//! unforgeability.
use ffi::{crypto_auth_hmacsha512, crypto_auth_hmacsha512_BYTES, crypto_auth_hmacsha512_KEYBYTES,
          crypto_auth_hmacsha512_final, crypto_auth_hmacsha512_init, crypto_auth_hmacsha512_state,
          crypto_auth_hmacsha512_update, crypto_auth_hmacsha512_verify};

auth_module!(
    crypto_auth_hmacsha512,
    crypto_auth_hmacsha512_verify,
    crypto_auth_hmacsha512_KEYBYTES,
    crypto_auth_hmacsha512_BYTES
);

auth_state!(
    crypto_auth_hmacsha512_state,
    crypto_auth_hmacsha512_init,
    crypto_auth_hmacsha512_update,
    crypto_auth_hmacsha512_final,
    crypto_auth_hmacsha512_BYTES
);

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_vector_1() {
        // corresponding to tests/auth.c from NaCl
        // "Test Case 2" from RFC 4231
        let key = Key([
            0x4a, 0x65, 0x66, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ]);
        let c = [
            0x77, 0x68, 0x61, 0x74, 0x20, 0x64, 0x6f, 0x20, 0x79, 0x61, 0x20, 0x77, 0x61, 0x6e,
            0x74, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x6e, 0x6f, 0x74, 0x68, 0x69, 0x6e, 0x67, 0x3f,
        ];

        let a_expected = [
            0x16, 0x4b, 0x7a, 0x7b, 0xfc, 0xf8, 0x19, 0xe2, 0xe3, 0x95, 0xfb, 0xe7, 0x3b, 0x56,
            0xe0, 0xa3, 0x87, 0xbd, 0x64, 0x22, 0x2e, 0x83, 0x1f, 0xd6, 0x10, 0x27, 0x0c, 0xd7,
            0xea, 0x25, 0x05, 0x54, 0x97, 0x58, 0xbf, 0x75, 0xc0, 0x5a, 0x99, 0x4a, 0x6d, 0x03,
            0x4f, 0x65, 0xf8, 0xf0, 0xe6, 0xfd, 0xca, 0xea, 0xb1, 0xa3, 0x4d, 0x4a, 0x6b, 0x4b,
            0x63, 0x6e, 0x07, 0x0a, 0x38, 0xbc, 0xe7, 0x37,
        ];

        let Tag(a) = authenticate(&c, &key);
        assert!(a[..] == a_expected[..]);
    }

    #[test]
    fn test_vector_state_1() {
        // corresponding to tests/auth.c from NaCl
        // "Test Case 2" from RFC 4231
        let key = [
            0x4a, 0x65, 0x66, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ];
        let c = [
            0x77, 0x68, 0x61, 0x74, 0x20, 0x64, 0x6f, 0x20, 0x79, 0x61, 0x20, 0x77, 0x61, 0x6e,
            0x74, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x6e, 0x6f, 0x74, 0x68, 0x69, 0x6e, 0x67, 0x3f,
        ];

        let a_expected = [
            0x16, 0x4b, 0x7a, 0x7b, 0xfc, 0xf8, 0x19, 0xe2, 0xe3, 0x95, 0xfb, 0xe7, 0x3b, 0x56,
            0xe0, 0xa3, 0x87, 0xbd, 0x64, 0x22, 0x2e, 0x83, 0x1f, 0xd6, 0x10, 0x27, 0x0c, 0xd7,
            0xea, 0x25, 0x05, 0x54, 0x97, 0x58, 0xbf, 0x75, 0xc0, 0x5a, 0x99, 0x4a, 0x6d, 0x03,
            0x4f, 0x65, 0xf8, 0xf0, 0xe6, 0xfd, 0xca, 0xea, 0xb1, 0xa3, 0x4d, 0x4a, 0x6b, 0x4b,
            0x63, 0x6e, 0x07, 0x0a, 0x38, 0xbc, 0xe7, 0x37,
        ];

        let mut state = State::init(&key);
        state.update(&c);
        let Tag(a) = state.finalize();
        assert!(a[..] == a_expected[..]);
    }
}

'''
'''--- src/crypto/auth/hmacsha512256.rs ---
//! `HMAC-SHA-512-256`, i.e., the first 256 bits of
//! `HMAC-SHA-512`.  `HMAC-SHA-512-256` is conjectured to meet the standard notion
//! of unforgeability.
use ffi::{crypto_auth_hmacsha512256, crypto_auth_hmacsha512256_BYTES,
          crypto_auth_hmacsha512256_KEYBYTES, crypto_auth_hmacsha512256_final,
          crypto_auth_hmacsha512256_init, crypto_auth_hmacsha512256_state,
          crypto_auth_hmacsha512256_update, crypto_auth_hmacsha512256_verify};

auth_module!(
    crypto_auth_hmacsha512256,
    crypto_auth_hmacsha512256_verify,
    crypto_auth_hmacsha512256_KEYBYTES,
    crypto_auth_hmacsha512256_BYTES
);

auth_state!(
    crypto_auth_hmacsha512256_state,
    crypto_auth_hmacsha512256_init,
    crypto_auth_hmacsha512256_update,
    crypto_auth_hmacsha512256_final,
    crypto_auth_hmacsha512256_BYTES
);

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_vector_1() {
        // corresponding to tests/auth.c from NaCl
        // "Test Case 2" from RFC 4231
        let key = Key([
            74, 101, 102, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0,
        ]);
        let c = [
            0x77, 0x68, 0x61, 0x74, 0x20, 0x64, 0x6f, 0x20, 0x79, 0x61, 0x20, 0x77, 0x61, 0x6e,
            0x74, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x6e, 0x6f, 0x74, 0x68, 0x69, 0x6e, 0x67, 0x3f,
        ];

        let a_expected = [
            0x16, 0x4b, 0x7a, 0x7b, 0xfc, 0xf8, 0x19, 0xe2, 0xe3, 0x95, 0xfb, 0xe7, 0x3b, 0x56,
            0xe0, 0xa3, 0x87, 0xbd, 0x64, 0x22, 0x2e, 0x83, 0x1f, 0xd6, 0x10, 0x27, 0x0c, 0xd7,
            0xea, 0x25, 0x05, 0x54,
        ];

        let Tag(a) = authenticate(&c, &key);
        assert!(a == a_expected);
    }

    #[test]
    fn test_vector_state_1() {
        // corresponding to tests/auth.c from NaCl
        // "Test Case 2" from RFC 4231
        let key = [
            74, 101, 102, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0,
        ];
        let c = [
            0x77, 0x68, 0x61, 0x74, 0x20, 0x64, 0x6f, 0x20, 0x79, 0x61, 0x20, 0x77, 0x61, 0x6e,
            0x74, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x6e, 0x6f, 0x74, 0x68, 0x69, 0x6e, 0x67, 0x3f,
        ];

        let a_expected = [
            0x16, 0x4b, 0x7a, 0x7b, 0xfc, 0xf8, 0x19, 0xe2, 0xe3, 0x95, 0xfb, 0xe7, 0x3b, 0x56,
            0xe0, 0xa3, 0x87, 0xbd, 0x64, 0x22, 0x2e, 0x83, 0x1f, 0xd6, 0x10, 0x27, 0x0c, 0xd7,
            0xea, 0x25, 0x05, 0x54,
        ];

        let mut state = State::init(&key);
        state.update(&c);
        let Tag(a) = state.finalize();
        assert!(a == a_expected);
    }
}

'''
'''--- src/crypto/auth/mod.rs ---
//! Secret-key authentication
//!
//! # Security model
//! The `authenticate()` function, viewed as a function of the
//! message for a uniform random key, is designed to meet the standard
//! notion of unforgeability. This means that an attacker cannot find
//! authenticators for any messages not authenticated by the sender, even if
//! the attacker has adaptively influenced the messages authenticated by the
//! sender. For a formal definition see, e.g., Section 2.4 of Bellare,
//! Kilian, and Rogaway, "The security of the cipher block chaining message
//! authentication code," Journal of Computer and System Sciences 61 (2000),
//! 362399; http://www-cse.ucsd.edu/~mihir/papers/cbc.html.
//!
//! NaCl does not make any promises regarding "strong" unforgeability;
//! perhaps one valid authenticator can be converted into another valid
//! authenticator for the same message. NaCl also does not make any promises
//! regarding "truncated unforgeability."
//!
//! # Selected primitive
//! `authenticate()` is currently an implementation of
//! `HMAC-SHA-512-256`, i.e., the first 256 bits of `HMAC-SHA-512`.
//! `HMAC-SHA-512-256` is conjectured to meet the standard notion of
//! unforgeability.
//!
//! # Alternate primitives
//! NaCl supports the following secret-key authentication functions:
//!
//! ------------------------------------------------------------
//! |crypto_auth              |primitive        |BYTES|KEYBYTES|
//! |-------------------------|-----------------|-----|--------|
//! |crypto_auth_hmacsha256   |HMAC_SHA-256     |32   |32      |
//! |crypto_auth_hmacsha512256|HMAC_SHA-512-256 |32   |32      |
//! |crypto_auth_hmacsha512   |HMAC_SHA-512     |64   |32      |
//! ------------------------------------------------------------
//!
//! # Example (simple interface)
//! ```
//! use exonum_sodiumoxide::crypto::auth;
//!
//! let key = auth::gen_key();
//! let data_to_authenticate = b"some data";
//! let tag = auth::authenticate(data_to_authenticate, &key);
//! assert!(auth::verify(&tag, data_to_authenticate, &key));
//! ```
//!
//! # Example (streaming interface)
//! ```
//! use exonum_sodiumoxide::crypto::auth;
//! use exonum_sodiumoxide::randombytes;
//!
//! let key = randombytes::randombytes(123);
//!
//! let data_part_1 = b"some data";
//! let data_part_2 = b"some other data";
//! let mut state = auth::State::init(&key);
//! state.update(data_part_1);
//! state.update(data_part_2);
//! let tag1 = state.finalize();
//!
//! let data_2_part_1 = b"some datasome ";
//! let data_2_part_2 = b"other data";
//! let mut state = auth::State::init(&key);
//! state.update(data_2_part_1);
//! state.update(data_2_part_2);
//! let tag2 = state.finalize();
//! assert_eq!(tag1, tag2);
//! ```
pub use self::hmacsha512256::*;
#[macro_use]
mod auth_macros;
pub mod hmacsha256;
pub mod hmacsha512;
pub mod hmacsha512256;

'''
'''--- src/crypto/box_/curve25519xsalsa20poly1305.rs ---
//! `crypto_box_curve25519xsalsa20poly1305` , a particular
//! combination of Curve25519, Salsa20, and Poly1305 specified in
//! [Cryptography in NaCl](http://nacl.cr.yp.to/valid.html).
//!
//! This function is conjectured to meet the standard notions of privacy and
//! third-party unforgeability.
use ffi;
#[cfg(not(feature = "std"))]
use prelude::*;
use randombytes::randombytes_into;

/// Number of bytes in a `PublicKey`.
pub const PUBLICKEYBYTES: usize = ffi::crypto_box_curve25519xsalsa20poly1305_PUBLICKEYBYTES;

/// Number of bytes in a `SecretKey`.
pub const SECRETKEYBYTES: usize = ffi::crypto_box_curve25519xsalsa20poly1305_SECRETKEYBYTES;

/// Number of bytes in a `Nonce`.
pub const NONCEBYTES: usize = ffi::crypto_box_curve25519xsalsa20poly1305_NONCEBYTES;

/// Number of bytes in a `PrecomputedKey`.
pub const PRECOMPUTEDKEYBYTES: usize = ffi::crypto_box_curve25519xsalsa20poly1305_BEFORENMBYTES;

/// Number of bytes in the authenticator tag of an encrypted message
/// i.e. the number of bytes by which the ciphertext is larger than the
/// plaintext.
pub const MACBYTES: usize = ffi::crypto_box_curve25519xsalsa20poly1305_MACBYTES;

new_type! {
    /// `SecretKey` for asymmetric authenticated encryption
    ///
    /// When a `SecretKey` goes out of scope its contents
    /// will be zeroed out
    secret SecretKey(SECRETKEYBYTES);
}

new_type! {
    /// `PublicKey` for asymmetric authenticated encryption
    public PublicKey(PUBLICKEYBYTES);
}

new_type! {
    /// Authentication `Tag` for the detached encryption mode
    ///
    /// In the combined mode, the tag occupies the first MACBYTES bytes of the ciphertext.
    public Tag(MACBYTES);
}

new_type! {
    /// `Nonce` for asymmetric authenticated encryption
    nonce Nonce(NONCEBYTES);
}

/// `gen_keypair()` randomly generates a secret key and a corresponding public key.
///
/// THREAD SAFETY: `gen_keypair()` is thread-safe provided that you have
/// called `sodiumoxide::init()` once before using any other function
/// from sodiumoxide.
pub fn gen_keypair() -> (PublicKey, SecretKey) {
    unsafe {
        let mut pk = [0u8; PUBLICKEYBYTES];
        let mut sk = [0u8; SECRETKEYBYTES];
        ffi::crypto_box_curve25519xsalsa20poly1305_keypair(&mut pk, &mut sk);
        (PublicKey(pk), SecretKey(sk))
    }
}

/// `gen_nonce()` randomly generates a nonce
///
/// THREAD SAFETY: `gen_nonce()` is thread-safe provided that you have
/// called `sodiumoxide::init()` once before using any other function
/// from sodiumoxide.
pub fn gen_nonce() -> Nonce {
    let mut n = [0; NONCEBYTES];
    randombytes_into(&mut n);
    Nonce(n)
}

/// `seal()` encrypts and authenticates a message `m` using the senders secret key `sk`,
/// the receivers public key `pk` and a nonce `n`. It returns a ciphertext `c`.
pub fn seal(
    m: &[u8],
    &Nonce(ref n): &Nonce,
    &PublicKey(ref pk): &PublicKey,
    &SecretKey(ref sk): &SecretKey,
) -> Vec<u8> {
    let clen = m.len() + MACBYTES;
    let mut c = Vec::with_capacity(clen);
    unsafe {
        c.set_len(clen);
        ffi::crypto_box_easy(c.as_mut_ptr(), m.as_ptr(), m.len() as u64, n, pk, sk);
    }
    c
}

/// `seal_detached()` encrypts and authenticates a message `m` using the senders secret key `sk`,
/// the receivers public key `pk` and a nonce `n`. `m` is encrypted in place, so after this
/// function returns it will contain the ciphertext. The detached authentication tag is returned by
/// value.
pub fn seal_detached(
    m: &mut [u8],
    &Nonce(ref n): &Nonce,
    &PublicKey(ref pk): &PublicKey,
    &SecretKey(ref sk): &SecretKey,
) -> Tag {
    let mut tag = [0; MACBYTES];
    unsafe {
        ffi::crypto_box_detached(
            m.as_mut_ptr(),
            &mut tag,
            m.as_ptr(),
            m.len() as u64,
            n,
            pk,
            sk,
        );
    };
    Tag(tag)
}

/// `open()` verifies and decrypts a ciphertext `c` using the receiver's secret key `sk`,
/// the senders public key `pk`, and a nonce `n`. It returns a plaintext `Ok(m)`.
/// If the ciphertext fails verification, `open()` returns `Err(())`.
pub fn open(
    c: &[u8],
    &Nonce(ref n): &Nonce,
    &PublicKey(ref pk): &PublicKey,
    &SecretKey(ref sk): &SecretKey,
) -> Result<Vec<u8>, ()> {
    if c.len() < MACBYTES {
        return Err(());
    }
    let mlen = c.len() - MACBYTES;
    let mut m = Vec::with_capacity(mlen);
    let ret = unsafe {
        m.set_len(mlen);
        ffi::crypto_box_open_easy(m.as_mut_ptr(), c.as_ptr(), c.len() as u64, n, pk, sk)
    };
    if ret == 0 {
        Ok(m)
    } else {
        Err(())
    }
}

/// `open_detached()` verifies and decrypts a ciphertext `c` using the receiver's secret key `sk`,
/// the senders public key `pk`, and a nonce `n`. `c` is decrypted in place, so if this function is
/// successful it will contain the plaintext. If the ciphertext fails verification,
/// `open_detached()` returns `Err(())`, and the ciphertext is not modified.
pub fn open_detached(
    c: &mut [u8],
    mac: &Tag,
    &Nonce(ref n): &Nonce,
    &PublicKey(ref pk): &PublicKey,
    &SecretKey(ref sk): &SecretKey,
) -> Result<(), ()> {
    let ret = unsafe {
        ffi::crypto_box_open_detached(
            c.as_mut_ptr(),
            c.as_ptr(),
            &mac.0,
            c.len() as u64,
            n,
            pk,
            sk,
        )
    };
    if ret == 0 {
        Ok(())
    } else {
        Err(())
    }
}

new_type! {
    /// Applications that send several messages to the same receiver can gain speed by
    /// splitting `seal()` into two steps, `precompute()` and `seal_precomputed()`.
    /// Similarly, applications that receive several messages from the same sender can gain
    /// speed by splitting `open()` into two steps, `precompute()` and `open_precomputed()`.
    ///
    /// When a `PrecomputedKey` goes out of scope its contents will be zeroed out
    secret PrecomputedKey(PRECOMPUTEDKEYBYTES);
}

/// `precompute()` computes an intermediate key that can be used by `seal_precomputed()`
/// and `open_precomputed()`
pub fn precompute(
    &PublicKey(ref pk): &PublicKey,
    &SecretKey(ref sk): &SecretKey,
) -> PrecomputedKey {
    let mut k = [0u8; PRECOMPUTEDKEYBYTES];
    unsafe {
        ffi::crypto_box_curve25519xsalsa20poly1305_beforenm(&mut k, pk, sk);
    }
    PrecomputedKey(k)
}

/// `seal_precomputed()` encrypts and authenticates a message `m` using a precomputed key `k`,
/// and a nonce `n`. It returns a ciphertext `c`.
pub fn seal_precomputed(
    m: &[u8],
    &Nonce(ref n): &Nonce,
    &PrecomputedKey(ref k): &PrecomputedKey,
) -> Vec<u8> {
    let clen = m.len() + MACBYTES;
    let mut c = Vec::with_capacity(clen);
    unsafe {
        c.set_len(clen);
        ffi::crypto_box_easy_afternm(c.as_mut_ptr(), m.as_ptr(), m.len() as u64, n, k);
    }
    c
}

/// `seal_detached_precomputed()` encrypts and authenticates a message `m` using a precomputed key
/// `k` and a nonce `n`. `m` is encrypted in place, so after this function returns it will contain
/// the ciphertext. The detached authentication tag is returned by value.
pub fn seal_detached_precomputed(
    m: &mut [u8],
    &Nonce(ref n): &Nonce,
    &PrecomputedKey(ref k): &PrecomputedKey,
) -> Tag {
    let mut tag = [0; MACBYTES];
    unsafe {
        ffi::crypto_box_detached_afternm(
            m.as_mut_ptr(),
            &mut tag,
            m.as_ptr(),
            m.len() as u64,
            n,
            k,
        );
    };
    Tag(tag)
}

/// `open_precomputed()` verifies and decrypts a ciphertext `c` using a precomputed
/// key `k` and a nonce `n`. It returns a plaintext `Ok(m)`.
/// If the ciphertext fails verification, `open_precomputed()` returns `Err(())`.
pub fn open_precomputed(
    c: &[u8],
    &Nonce(ref n): &Nonce,
    &PrecomputedKey(ref k): &PrecomputedKey,
) -> Result<Vec<u8>, ()> {
    if c.len() < MACBYTES {
        return Err(());
    }
    let mlen = c.len() - MACBYTES;
    let mut m = Vec::with_capacity(mlen);
    let ret = unsafe {
        m.set_len(mlen);
        ffi::crypto_box_open_easy_afternm(m.as_mut_ptr(), c.as_ptr(), c.len() as u64, n, k)
    };
    if ret == 0 {
        Ok(m)
    } else {
        Err(())
    }
}

/// `open_detached_precomputed()` verifies and decrypts a ciphertext `c` using a precomputed key
/// `k` and a nonce `n`. `c` is decrypted in place, so if this function is successful it will
/// contain the plaintext. If the ciphertext fails verification, `open_detached()` returns
/// `Err(())`, and the ciphertext is not modified.
pub fn open_detached_precomputed(
    c: &mut [u8],
    mac: &Tag,
    &Nonce(ref n): &Nonce,
    &PrecomputedKey(ref k): &PrecomputedKey,
) -> Result<(), ()> {
    let ret = unsafe {
        ffi::crypto_box_open_detached_afternm(
            c.as_mut_ptr(),
            c.as_ptr(),
            &mac.0,
            c.len() as u64,
            n,
            k,
        )
    };
    if ret == 0 {
        Ok(())
    } else {
        Err(())
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_seal_open() {
        use randombytes::randombytes;
        for i in 0..256usize {
            let (pk1, sk1) = gen_keypair();
            let (pk2, sk2) = gen_keypair();
            let m = randombytes(i);
            let n = gen_nonce();
            let c = seal(&m, &n, &pk1, &sk2);
            let opened = open(&c, &n, &pk2, &sk1);
            assert!(Ok(m) == opened);
        }
    }

    #[test]
    fn test_seal_open_precomputed() {
        use randombytes::randombytes;
        for i in 0..256usize {
            let (pk1, sk1) = gen_keypair();
            let (pk2, sk2) = gen_keypair();
            let k1 = precompute(&pk1, &sk2);
            let PrecomputedKey(k1buf) = k1;
            let k2 = precompute(&pk2, &sk1);
            let PrecomputedKey(k2buf) = k2;
            assert!(k1buf == k2buf);
            let m = randombytes(i);
            let n = gen_nonce();
            let c = seal_precomputed(&m, &n, &k1);
            let opened = open_precomputed(&c, &n, &k2);
            assert!(Ok(m) == opened);
        }
    }

    #[test]
    fn test_seal_open_tamper() {
        use randombytes::randombytes;
        for i in 0..32usize {
            let (pk1, sk1) = gen_keypair();
            let (pk2, sk2) = gen_keypair();
            let m = randombytes(i);
            let n = gen_nonce();
            let mut c = seal(&m, &n, &pk1, &sk2);
            for j in 0..c.len() {
                c[j] ^= 0x20;
                assert!(Err(()) == open(&mut c, &n, &pk2, &sk1));
                c[j] ^= 0x20;
            }
        }
    }

    #[test]
    fn test_seal_open_precomputed_tamper() {
        use randombytes::randombytes;
        for i in 0..32usize {
            let (pk1, sk1) = gen_keypair();
            let (pk2, sk2) = gen_keypair();
            let k1 = precompute(&pk1, &sk2);
            let k2 = precompute(&pk2, &sk1);
            let m = randombytes(i);
            let n = gen_nonce();
            let mut c = seal_precomputed(&m, &n, &k1);
            for j in 0..c.len() {
                c[j] ^= 0x20;
                assert!(Err(()) == open_precomputed(&mut c, &n, &k2));
                c[j] ^= 0x20;
            }
        }
    }

    #[test]
    fn test_seal_open_detached() {
        use randombytes::randombytes;
        for i in 0..256usize {
            let (pk1, sk1) = gen_keypair();
            let (pk2, sk2) = gen_keypair();
            let m = randombytes(i);
            let n = gen_nonce();
            let mut buf = m.clone();
            let tag = seal_detached(&mut buf, &n, &pk1, &sk2);
            open_detached(&mut buf, &tag, &n, &pk2, &sk1).unwrap();
            assert_eq!(m, buf);
        }
    }

    #[test]
    fn test_seal_combined_then_open_detached() {
        use randombytes::randombytes;
        for i in 0..256usize {
            let (pk1, sk1) = gen_keypair();
            let (pk2, sk2) = gen_keypair();
            let m = randombytes(i);
            let n = gen_nonce();
            let mut c = seal(&m, &n, &pk1, &sk2);
            let tag = Tag::from_slice(&c[..MACBYTES]).unwrap();
            let buf = &mut c[MACBYTES..];
            open_detached(buf, &tag, &n, &pk2, &sk1).unwrap();
            assert_eq!(buf, &*m);
        }
    }

    #[test]
    fn test_seal_detached_then_open_combined() {
        use randombytes::randombytes;
        for i in 0..256usize {
            let (pk1, sk1) = gen_keypair();
            let (pk2, sk2) = gen_keypair();
            let m = randombytes(i);
            let n = gen_nonce();
            let mut buf = vec![0; MACBYTES];
            buf.extend_from_slice(&m);
            let tag = seal_detached(&mut buf[MACBYTES..], &n, &pk1, &sk2);
            buf[..MACBYTES].copy_from_slice(&tag.0[..]);
            let opened = open(&buf, &n, &pk2, &sk1);
            assert_eq!(Ok(m), opened);
        }
    }

    #[test]
    fn test_seal_open_detached_tamper() {
        use randombytes::randombytes;
        for i in 0..32usize {
            let (pk1, sk1) = gen_keypair();
            let (pk2, sk2) = gen_keypair();
            let mut m = randombytes(i);
            let n = gen_nonce();
            let mut tag = seal_detached(&mut m, &n, &pk1, &sk2);
            for j in 0..m.len() {
                m[j] ^= 0x20;
                assert_eq!(Err(()), open_detached(&mut m, &tag, &n, &pk2, &sk1));
                m[j] ^= 0x20;
            }
            for j in 0..tag.0.len() {
                tag.0[j] ^= 0x20;
                assert_eq!(Err(()), open_detached(&mut m, &tag, &n, &pk2, &sk1));
                tag.0[j] ^= 0x20;
            }
        }
    }

    #[test]
    fn test_open_detached_failure_does_not_modify() {
        let mut buf = b"hello world".to_vec();
        let (pk1, sk1) = gen_keypair();
        let (pk2, sk2) = gen_keypair();
        let n = gen_nonce();
        let tag = seal_detached(&mut buf, &n, &pk1, &sk2);
        // Flip the last bit in the ciphertext, to break authentication.
        *buf.last_mut().unwrap() ^= 1;
        // Make a copy that we can compare against after the failure below.
        let copy = buf.clone();
        // Now try to open the message. This will fail.
        let failure = open_detached(&mut buf, &tag, &n, &pk2, &sk1);
        assert!(failure.is_err());
        // Make sure the input hasn't been touched.
        assert_eq!(
            buf, copy,
            "input should not be modified if authentication fails"
        );
    }

    #[test]
    fn test_seal_open_detached_precomputed() {
        use randombytes::randombytes;
        for i in 0..256usize {
            let (pk1, sk1) = gen_keypair();
            let (pk2, sk2) = gen_keypair();
            let k1 = precompute(&pk1, &sk2);
            let k2 = precompute(&pk2, &sk1);
            let m = randombytes(i);
            let n = gen_nonce();
            let mut buf = m.clone();
            let tag = seal_detached_precomputed(&mut buf, &n, &k1);
            open_detached_precomputed(&mut buf, &tag, &n, &k2).unwrap();
            assert_eq!(m, buf);
        }
    }

    #[test]
    fn test_seal_combined_then_open_detached_precomputed() {
        use randombytes::randombytes;
        for i in 0..256usize {
            let (pk1, sk1) = gen_keypair();
            let (pk2, sk2) = gen_keypair();
            let k1 = precompute(&pk1, &sk2);
            let k2 = precompute(&pk2, &sk1);
            let m = randombytes(i);
            let n = gen_nonce();
            let mut c = seal_precomputed(&m, &n, &k1);
            let tag = Tag::from_slice(&c[..MACBYTES]).unwrap();
            let buf = &mut c[MACBYTES..];
            open_detached_precomputed(buf, &tag, &n, &k2).unwrap();
            assert_eq!(buf, &*m);
        }
    }

    #[test]
    fn test_seal_detached_precomputed_then_open_combined() {
        use randombytes::randombytes;
        for i in 0..256usize {
            let (pk1, sk1) = gen_keypair();
            let (pk2, sk2) = gen_keypair();
            let k1 = precompute(&pk1, &sk2);
            let k2 = precompute(&pk2, &sk1);
            let m = randombytes(i);
            let n = gen_nonce();
            let mut buf = vec![0; MACBYTES];
            buf.extend_from_slice(&m);
            let tag = seal_detached_precomputed(&mut buf[MACBYTES..], &n, &k1);
            buf[..MACBYTES].copy_from_slice(&tag.0[..]);
            let opened = open_precomputed(&buf, &n, &k2);
            assert_eq!(Ok(m), opened);
        }
    }

    #[test]
    fn test_seal_open_detached_precomputed_tamper() {
        use randombytes::randombytes;
        for i in 0..32usize {
            let (pk1, sk1) = gen_keypair();
            let (pk2, sk2) = gen_keypair();
            let k1 = precompute(&pk1, &sk2);
            let k2 = precompute(&pk2, &sk1);
            let mut m = randombytes(i);
            let n = gen_nonce();
            let mut tag = seal_detached_precomputed(&mut m, &n, &k1);
            for j in 0..m.len() {
                m[j] ^= 0x20;
                assert_eq!(Err(()), open_detached_precomputed(&mut m, &tag, &n, &k2));
                m[j] ^= 0x20;
            }
            for j in 0..tag.0.len() {
                tag.0[j] ^= 0x20;
                assert_eq!(Err(()), open_detached_precomputed(&mut m, &tag, &n, &k2));
                tag.0[j] ^= 0x20;
            }
        }
    }

    #[test]
    fn test_open_detached_precomputed_failure_does_not_modify() {
        let mut buf = b"hello world".to_vec();
        let (pk1, sk1) = gen_keypair();
        let (pk2, sk2) = gen_keypair();
        let k1 = precompute(&pk1, &sk2);
        let k2 = precompute(&pk2, &sk1);
        let n = gen_nonce();
        let tag = seal_detached_precomputed(&mut buf, &n, &k1);
        // Flip the last bit in the ciphertext, to break authentication.
        *buf.last_mut().unwrap() ^= 1;
        // Make a copy that we can compare against after the failure below.
        let copy = buf.clone();
        // Now try to open the message. This will fail.
        let failure = open_detached_precomputed(&mut buf, &tag, &n, &k2);
        assert!(failure.is_err());
        // Make sure the input hasn't been touched.
        assert_eq!(
            buf, copy,
            "input should not be modified if authentication fails"
        );
    }

    #[test]
    fn test_vector_1() {
        // corresponding to tests/box.c and tests/box3.cpp from NaCl
        let alicesk = SecretKey([
            0x77, 0x07, 0x6d, 0x0a, 0x73, 0x18, 0xa5, 0x7d, 0x3c, 0x16, 0xc1, 0x72, 0x51, 0xb2,
            0x66, 0x45, 0xdf, 0x4c, 0x2f, 0x87, 0xeb, 0xc0, 0x99, 0x2a, 0xb1, 0x77, 0xfb, 0xa5,
            0x1d, 0xb9, 0x2c, 0x2a,
        ]);
        let bobpk = PublicKey([
            0xde, 0x9e, 0xdb, 0x7d, 0x7b, 0x7d, 0xc1, 0xb4, 0xd3, 0x5b, 0x61, 0xc2, 0xec, 0xe4,
            0x35, 0x37, 0x3f, 0x83, 0x43, 0xc8, 0x5b, 0x78, 0x67, 0x4d, 0xad, 0xfc, 0x7e, 0x14,
            0x6f, 0x88, 0x2b, 0x4f,
        ]);
        let nonce = Nonce([
            0x69, 0x69, 0x6e, 0xe9, 0x55, 0xb6, 0x2b, 0x73, 0xcd, 0x62, 0xbd, 0xa8, 0x75, 0xfc,
            0x73, 0xd6, 0x82, 0x19, 0xe0, 0x03, 0x6b, 0x7a, 0x0b, 0x37,
        ]);
        let m = [
            0xbe, 0x07, 0x5f, 0xc5, 0x3c, 0x81, 0xf2, 0xd5, 0xcf, 0x14, 0x13, 0x16, 0xeb, 0xeb,
            0x0c, 0x7b, 0x52, 0x28, 0xc5, 0x2a, 0x4c, 0x62, 0xcb, 0xd4, 0x4b, 0x66, 0x84, 0x9b,
            0x64, 0x24, 0x4f, 0xfc, 0xe5, 0xec, 0xba, 0xaf, 0x33, 0xbd, 0x75, 0x1a, 0x1a, 0xc7,
            0x28, 0xd4, 0x5e, 0x6c, 0x61, 0x29, 0x6c, 0xdc, 0x3c, 0x01, 0x23, 0x35, 0x61, 0xf4,
            0x1d, 0xb6, 0x6c, 0xce, 0x31, 0x4a, 0xdb, 0x31, 0x0e, 0x3b, 0xe8, 0x25, 0x0c, 0x46,
            0xf0, 0x6d, 0xce, 0xea, 0x3a, 0x7f, 0xa1, 0x34, 0x80, 0x57, 0xe2, 0xf6, 0x55, 0x6a,
            0xd6, 0xb1, 0x31, 0x8a, 0x02, 0x4a, 0x83, 0x8f, 0x21, 0xaf, 0x1f, 0xde, 0x04, 0x89,
            0x77, 0xeb, 0x48, 0xf5, 0x9f, 0xfd, 0x49, 0x24, 0xca, 0x1c, 0x60, 0x90, 0x2e, 0x52,
            0xf0, 0xa0, 0x89, 0xbc, 0x76, 0x89, 0x70, 0x40, 0xe0, 0x82, 0xf9, 0x37, 0x76, 0x38,
            0x48, 0x64, 0x5e, 0x07, 0x05,
        ];
        let c = seal(&m, &nonce, &bobpk, &alicesk);
        let pk = precompute(&bobpk, &alicesk);
        let cpre = seal_precomputed(&m, &nonce, &pk);
        let cexp = vec![
            0xf3, 0xff, 0xc7, 0x70, 0x3f, 0x94, 0x00, 0xe5, 0x2a, 0x7d, 0xfb, 0x4b, 0x3d, 0x33,
            0x05, 0xd9, 0x8e, 0x99, 0x3b, 0x9f, 0x48, 0x68, 0x12, 0x73, 0xc2, 0x96, 0x50, 0xba,
            0x32, 0xfc, 0x76, 0xce, 0x48, 0x33, 0x2e, 0xa7, 0x16, 0x4d, 0x96, 0xa4, 0x47, 0x6f,
            0xb8, 0xc5, 0x31, 0xa1, 0x18, 0x6a, 0xc0, 0xdf, 0xc1, 0x7c, 0x98, 0xdc, 0xe8, 0x7b,
            0x4d, 0xa7, 0xf0, 0x11, 0xec, 0x48, 0xc9, 0x72, 0x71, 0xd2, 0xc2, 0x0f, 0x9b, 0x92,
            0x8f, 0xe2, 0x27, 0x0d, 0x6f, 0xb8, 0x63, 0xd5, 0x17, 0x38, 0xb4, 0x8e, 0xee, 0xe3,
            0x14, 0xa7, 0xcc, 0x8a, 0xb9, 0x32, 0x16, 0x45, 0x48, 0xe5, 0x26, 0xae, 0x90, 0x22,
            0x43, 0x68, 0x51, 0x7a, 0xcf, 0xea, 0xbd, 0x6b, 0xb3, 0x73, 0x2b, 0xc0, 0xe9, 0xda,
            0x99, 0x83, 0x2b, 0x61, 0xca, 0x01, 0xb6, 0xde, 0x56, 0x24, 0x4a, 0x9e, 0x88, 0xd5,
            0xf9, 0xb3, 0x79, 0x73, 0xf6, 0x22, 0xa4, 0x3d, 0x14, 0xa6, 0x59, 0x9b, 0x1f, 0x65,
            0x4c, 0xb4, 0x5a, 0x74, 0xe3, 0x55, 0xa5,
        ];
        assert!(c == cexp);
        assert!(cpre == cexp);
    }

    #[test]
    fn test_vector_2() {
        // corresponding to tests/box2.c and tests/box4.cpp from NaCl
        let bobsk = SecretKey([
            0x5d, 0xab, 0x08, 0x7e, 0x62, 0x4a, 0x8a, 0x4b, 0x79, 0xe1, 0x7f, 0x8b, 0x83, 0x80,
            0x0e, 0xe6, 0x6f, 0x3b, 0xb1, 0x29, 0x26, 0x18, 0xb6, 0xfd, 0x1c, 0x2f, 0x8b, 0x27,
            0xff, 0x88, 0xe0, 0xeb,
        ]);
        let alicepk = PublicKey([
            0x85, 0x20, 0xf0, 0x09, 0x89, 0x30, 0xa7, 0x54, 0x74, 0x8b, 0x7d, 0xdc, 0xb4, 0x3e,
            0xf7, 0x5a, 0x0d, 0xbf, 0x3a, 0x0d, 0x26, 0x38, 0x1a, 0xf4, 0xeb, 0xa4, 0xa9, 0x8e,
            0xaa, 0x9b, 0x4e, 0x6a,
        ]);
        let nonce = Nonce([
            0x69, 0x69, 0x6e, 0xe9, 0x55, 0xb6, 0x2b, 0x73, 0xcd, 0x62, 0xbd, 0xa8, 0x75, 0xfc,
            0x73, 0xd6, 0x82, 0x19, 0xe0, 0x03, 0x6b, 0x7a, 0x0b, 0x37,
        ]);
        let c = [
            0xf3, 0xff, 0xc7, 0x70, 0x3f, 0x94, 0x00, 0xe5, 0x2a, 0x7d, 0xfb, 0x4b, 0x3d, 0x33,
            0x05, 0xd9, 0x8e, 0x99, 0x3b, 0x9f, 0x48, 0x68, 0x12, 0x73, 0xc2, 0x96, 0x50, 0xba,
            0x32, 0xfc, 0x76, 0xce, 0x48, 0x33, 0x2e, 0xa7, 0x16, 0x4d, 0x96, 0xa4, 0x47, 0x6f,
            0xb8, 0xc5, 0x31, 0xa1, 0x18, 0x6a, 0xc0, 0xdf, 0xc1, 0x7c, 0x98, 0xdc, 0xe8, 0x7b,
            0x4d, 0xa7, 0xf0, 0x11, 0xec, 0x48, 0xc9, 0x72, 0x71, 0xd2, 0xc2, 0x0f, 0x9b, 0x92,
            0x8f, 0xe2, 0x27, 0x0d, 0x6f, 0xb8, 0x63, 0xd5, 0x17, 0x38, 0xb4, 0x8e, 0xee, 0xe3,
            0x14, 0xa7, 0xcc, 0x8a, 0xb9, 0x32, 0x16, 0x45, 0x48, 0xe5, 0x26, 0xae, 0x90, 0x22,
            0x43, 0x68, 0x51, 0x7a, 0xcf, 0xea, 0xbd, 0x6b, 0xb3, 0x73, 0x2b, 0xc0, 0xe9, 0xda,
            0x99, 0x83, 0x2b, 0x61, 0xca, 0x01, 0xb6, 0xde, 0x56, 0x24, 0x4a, 0x9e, 0x88, 0xd5,
            0xf9, 0xb3, 0x79, 0x73, 0xf6, 0x22, 0xa4, 0x3d, 0x14, 0xa6, 0x59, 0x9b, 0x1f, 0x65,
            0x4c, 0xb4, 0x5a, 0x74, 0xe3, 0x55, 0xa5,
        ];
        let mexp = Ok(vec![
            0xbe, 0x07, 0x5f, 0xc5, 0x3c, 0x81, 0xf2, 0xd5, 0xcf, 0x14, 0x13, 0x16, 0xeb, 0xeb,
            0x0c, 0x7b, 0x52, 0x28, 0xc5, 0x2a, 0x4c, 0x62, 0xcb, 0xd4, 0x4b, 0x66, 0x84, 0x9b,
            0x64, 0x24, 0x4f, 0xfc, 0xe5, 0xec, 0xba, 0xaf, 0x33, 0xbd, 0x75, 0x1a, 0x1a, 0xc7,
            0x28, 0xd4, 0x5e, 0x6c, 0x61, 0x29, 0x6c, 0xdc, 0x3c, 0x01, 0x23, 0x35, 0x61, 0xf4,
            0x1d, 0xb6, 0x6c, 0xce, 0x31, 0x4a, 0xdb, 0x31, 0x0e, 0x3b, 0xe8, 0x25, 0x0c, 0x46,
            0xf0, 0x6d, 0xce, 0xea, 0x3a, 0x7f, 0xa1, 0x34, 0x80, 0x57, 0xe2, 0xf6, 0x55, 0x6a,
            0xd6, 0xb1, 0x31, 0x8a, 0x02, 0x4a, 0x83, 0x8f, 0x21, 0xaf, 0x1f, 0xde, 0x04, 0x89,
            0x77, 0xeb, 0x48, 0xf5, 0x9f, 0xfd, 0x49, 0x24, 0xca, 0x1c, 0x60, 0x90, 0x2e, 0x52,
            0xf0, 0xa0, 0x89, 0xbc, 0x76, 0x89, 0x70, 0x40, 0xe0, 0x82, 0xf9, 0x37, 0x76, 0x38,
            0x48, 0x64, 0x5e, 0x07, 0x05,
        ]);
        let m = open(&c, &nonce, &alicepk, &bobsk);
        let pk = precompute(&alicepk, &bobsk);
        let m_pre = open_precomputed(&c, &nonce, &pk);
        assert!(m == mexp);
        assert!(m_pre == mexp);
    }

    #[cfg(feature = "serde")]
    #[test]
    fn test_serialisation() {
        use test_utils::round_trip;
        for _ in 0..256usize {
            let (pk, sk) = gen_keypair();
            let n = gen_nonce();
            round_trip(pk);
            round_trip(sk);
            round_trip(n);
        }
    }
}

#[cfg(feature = "benchmarks")]
#[cfg(test)]
mod bench {
    extern crate test;
    use super::*;
    use randombytes::randombytes;

    const BENCH_SIZES: [usize; 14] = [0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096];

    #[bench]
    fn bench_seal_open(b: &mut test::Bencher) {
        let (pk, sk) = gen_keypair();
        let n = gen_nonce();
        let ms: Vec<Vec<u8>> = BENCH_SIZES.iter().map(|s| randombytes(*s)).collect();
        b.iter(|| {
            for m in ms.iter() {
                open(&seal(m, &n, &pk, &sk), &n, &pk, &sk).unwrap();
            }
        });
    }

    #[bench]
    fn bench_precompute(b: &mut test::Bencher) {
        let (pk, sk) = gen_keypair();
        b.iter(|| {
            // we do this benchmark as many times as the other benchmarks so
            // that we can compare the times
            for _ in BENCH_SIZES.iter() {
                precompute(&pk, &sk);
                precompute(&pk, &sk);
            }
        });
    }
}

'''
'''--- src/crypto/box_/mod.rs ---
//! Public-key authenticated encryption
//!
//! # Security model
//! The `seal()` function is designed to meet the standard notions of privacy and
//! third-party unforgeability for a public-key authenticated-encryption scheme
//! using nonces. For formal definitions see, e.g., Jee Hea An, "Authenticated
//! encryption in the public-key setting: security notions and analyses,"
//! http://eprint.iacr.org/2001/079.
//!
//! Distinct messages between the same {sender, receiver} set are required
//! to have distinct nonces. For example, the lexicographically smaller
//! public key can use nonce 1 for its first message to the other key, nonce
//! 3 for its second message, nonce 5 for its third message, etc., while the
//! lexicographically larger public key uses nonce 2 for its first message
//! to the other key, nonce 4 for its second message, nonce 6 for its third
//! message, etc. Nonces are long enough that randomly generated nonces have
//! negligible risk of collision.
//!
//! There is no harm in having the same nonce for different messages if the
//! {sender, receiver} sets are different. This is true even if the sets
//! overlap. For example, a sender can use the same nonce for two different
//! messages if the messages are sent to two different public keys.
//!
//! The `seal()` function is not meant to provide non-repudiation. On the
//! contrary: the `seal()` function guarantees repudiability. A receiver
//! can freely modify a boxed message, and therefore cannot convince third
//! parties that this particular message came from the sender. The sender
//! and receiver are nevertheless protected against forgeries by other
//! parties. In the terminology of
//! http://groups.google.com/group/sci.crypt/msg/ec5c18b23b11d82c,
//! crypto_box uses "public-key authenticators" rather than "public-key
//! signatures."
//!
//! Users who want public verifiability (or receiver-assisted public
//! verifiability) should instead use signatures (or signcryption).
//! Signature support is a high priority for NaCl; a signature API will be
//! described in subsequent NaCl documentation.
//!
//! # Selected primitive
//! `seal()` is `crypto_box_curve25519xsalsa20poly1305` , a particular
//! combination of Curve25519, Salsa20, and Poly1305 specified in
//! [Cryptography in NaCl](http://nacl.cr.yp.to/valid.html).
//!
//! This function is conjectured to meet the standard notions of privacy and
//! third-party unforgeability.
//!
//! # Example (simple interface)
//! ```
//! use exonum_sodiumoxide::crypto::box_;
//!
//! let (ourpk, oursk) = box_::gen_keypair();
//! // normally theirpk is sent by the other party
//! let (theirpk, theirsk) = box_::gen_keypair();
//! let nonce = box_::gen_nonce();
//! let plaintext = b"some data";
//! let ciphertext = box_::seal(plaintext, &nonce, &theirpk, &oursk);
//! let their_plaintext = box_::open(&ciphertext, &nonce, &ourpk, &theirsk).unwrap();
//! assert!(plaintext == &their_plaintext[..]);
//! ```
//! # Example (precomputation interface)
//! ```
//! use exonum_sodiumoxide::crypto::box_;
//!
//! let (ourpk, oursk) = box_::gen_keypair();
//! let (theirpk, theirsk) = box_::gen_keypair();
//! let our_precomputed_key = box_::precompute(&theirpk, &oursk);
//! let nonce = box_::gen_nonce();
//! let plaintext = b"plaintext";
//! let ciphertext = box_::seal_precomputed(plaintext, &nonce, &our_precomputed_key);
//! // this will be identical to our_precomputed_key
//! let their_precomputed_key = box_::precompute(&ourpk, &theirsk);
//! let their_plaintext = box_::open_precomputed(&ciphertext, &nonce,
//!                                              &their_precomputed_key).unwrap();
//! assert!(plaintext == &their_plaintext[..]);
//! ```
pub use self::curve25519xsalsa20poly1305::*;
pub mod curve25519xsalsa20poly1305;

'''
'''--- src/crypto/hash/hash_macros.rs ---
macro_rules! hash_module (($hash_name:ident,
                           $hashbytes:expr,
                           $blockbytes:expr,
                           $state_name:ident,
                           $init_name:ident,
                           $update_name:ident,
                           $final_name:ident) => (

use libc::c_ulonglong;
use std::mem;
use std::fmt;

/// Number of bytes in a `Digest`.
pub const DIGESTBYTES: usize = $hashbytes;

/// Block size of the hash function.
pub const BLOCKBYTES: usize = $blockbytes;

new_type! {
    /// Digest-structure
    public Digest(DIGESTBYTES);
}

/// `hash` hashes a message `m`. It returns a hash `h`.
pub fn hash(m: &[u8]) -> Digest {
    unsafe {
        let mut h = [0; DIGESTBYTES];
        $hash_name(&mut h, m.as_ptr(), m.len() as c_ulonglong);
        Digest(h)
    }
}

// Streaming hashing.
// Mostly follows the streaming HMAC interface and implementation.

// `Clone` may be used to speed up, e.g., hashing many messages that
// have a common prefix. It also makes `finalize` moving `State` less
// inconvenient.

/// State for multi-part (streaming) computation of hash digest.
#[derive(Clone)]
pub struct State($state_name);

impl State {
    /// `init()` initialize a streaming hashing state.
    pub fn init() -> State {
        unsafe {
            let mut s = mem::uninitialized();
            $init_name(&mut s);
            State(s)
        }
    }

    /// `update()` can be called more than once in order to compute the digest
    /// from sequential chunks of the message.
    pub fn update(&mut self, in_: &[u8]) {
        unsafe {
            $update_name(&mut self.0, in_.as_ptr(), in_.len() as c_ulonglong);
        }
    }

    /// `finalize()` finalizes the hashing computation and returns a `Digest`.

    // Moves self becuase libsodium says the state should not be used
    // anymore after final().
    pub fn finalize(mut self) -> Digest {
        unsafe {
            let mut digest = [0; $hashbytes as usize];
            $final_name(&mut self.0, &mut digest);
            Digest(digest)
        }
    }
}

// Impl Default becuase `State` does have a sensible default: State::init()
impl Default for State {
    fn default() -> State {
        State::init()
    }
}

impl fmt::Debug for State {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "hash_sha256 state")
    }
}

#[cfg(feature = "default")]
#[cfg(test)]
mod test_encode {
    use super::*;
    use test_utils::round_trip;

    #[test]
    fn test_serialisation() {
        use randombytes::randombytes;
        for i in 0..32usize {
            let m = randombytes(i);
            let d = hash(&m[..]);
            round_trip(d);
        }
    }
}

#[cfg(feature = "benchmarks")]
#[cfg(test)]
mod bench_m {
    extern crate test;
    use randombytes::randombytes;
    use super::*;

    const BENCH_SIZES: [usize; 14] = [0, 1, 2, 4, 8, 16, 32, 64,
                                      128, 256, 512, 1024, 2048, 4096];

    #[bench]
    fn bench_hash(b: &mut test::Bencher) {
        let ms: Vec<Vec<u8>> = BENCH_SIZES.iter().map(|s| {
            randombytes(*s)
        }).collect();
        b.iter(|| {
            for m in ms.iter() {
                hash(&m);
            }
        });
    }
}

));

'''
'''--- src/crypto/hash/mod.rs ---
//! Hashing
//!
//! # Security model
//! The `hash()` function is designed to be usable as a strong
//! component of DSA, RSA-PSS, key derivation, hash-based
//! message-authentication codes, hash-based ciphers, and various other
//! common applications.  "Strong" means that the security of these
//! applications, when instantiated with `hash()`, is the same
//! as the security of the applications against generic attacks. In
//! particular, the `hash()` function is designed to make
//! finding collisions difficult.
//!
//! # Selected primitive
//! `hash()` is currently an implementation of `SHA-512`.
//!
//! There has been considerable degradation of public confidence in the
//! security conjectures for many hash functions, including `SHA-512`.
//! However, for the moment, there do not appear to be alternatives that
//! inspire satisfactory levels of confidence. One can hope that NIST's
//! SHA-3 competition will improve the situation.
//!
//! # Alternate primitives
//! NaCl supports the following hash functions:
//!
//! ------------------------------------
//! |crypto_hash       |primitive|BYTES|
//! |------------------|---------|-----|
//! |crypto_hash_sha256|SHA-256  |32   |
//! |crypto_hash_sha512|SHA-512  |64   |
//! ------------------------------------
//!
//! # Example
//! ```
//! use exonum_sodiumoxide::crypto::hash;
//!
//! let data_to_hash = b"some data";
//! let digest = hash::hash(data_to_hash);
//! ```
pub use self::sha512::*;
#[macro_use]
mod hash_macros;
pub mod sha256;
pub mod sha512;

'''
'''--- src/crypto/hash/sha256.rs ---
//! `SHA-256`.
//!
//! There has been considerable degradation of public confidence in the
//! security conjectures for many hash functions, including `SHA-256`.
//! However, for the moment, there do not appear to be alternatives that
//! inspire satisfactory levels of confidence. One can hope that NIST's
//! SHA-3 competition will improve the situation.
use ffi::{crypto_hash_sha256, crypto_hash_sha256_BYTES, crypto_hash_sha256_final,
          crypto_hash_sha256_init, crypto_hash_sha256_state, crypto_hash_sha256_update};

hash_module!(
    crypto_hash_sha256,
    crypto_hash_sha256_BYTES,
    64,
    crypto_hash_sha256_state,
    crypto_hash_sha256_init,
    crypto_hash_sha256_update,
    crypto_hash_sha256_final
);

#[cfg(test)]
mod test {
    use super::*;

    fn streaming_hash(msg: &[u8]) -> Digest {
        let mut s = State::init();
        s.update(msg);
        s.finalize()
    }

    fn streaming_hash_chunks(chunks: Vec<&[u8]>) -> Digest {
        let mut s = State::init();
        for msg in chunks {
            s.update(msg);
        }
        s.finalize()
    }

    #[test]
    fn test_vector_1() {
        // hash of empty string
        let x = [];
        let h_expected = [
            0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14, 0x9a, 0xfb, 0xf4, 0xc8, 0x99, 0x6f,
            0xb9, 0x24, 0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b, 0x93, 0x4c, 0xa4, 0x95, 0x99, 0x1b,
            0x78, 0x52, 0xb8, 0x55,
        ];
        let Digest(h) = hash(&x);
        let Digest(h1) = streaming_hash(&x);
        let Digest(h2) = streaming_hash_chunks(vec![&[], &[]]);
        assert!(h == h_expected);
        assert!(h1 == h_expected);
        assert!(h2 == h_expected);
    }

    #[test]
    fn test_vector_2() {
        // The quick brown fox jumps over the lazy dog
        let x = [
            0x54, 0x68, 0x65, 0x20, 0x71, 0x75, 0x69, 0x63, 0x6b, 0x20, 0x62, 0x72, 0x6f, 0x77,
            0x6e, 0x20, 0x66, 0x6f, 0x78, 0x20, 0x6a, 0x75, 0x6d, 0x70, 0x73, 0x20, 0x6f, 0x76,
            0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6c, 0x61, 0x7a, 0x79, 0x20, 0x64, 0x6f,
            0x67,
        ];
        let h_expected = [
            0xd7, 0xa8, 0xfb, 0xb3, 0x07, 0xd7, 0x80, 0x94, 0x69, 0xca, 0x9a, 0xbc, 0xb0, 0x08,
            0x2e, 0x4f, 0x8d, 0x56, 0x51, 0xe4, 0x6d, 0x3c, 0xdb, 0x76, 0x2d, 0x02, 0xd0, 0xbf,
            0x37, 0xc9, 0xe5, 0x92,
        ];
        let Digest(h) = hash(&x);
        let Digest(h1) = streaming_hash(&x);
        let chunks = x.split_at(x.len() / 2);
        let Digest(h2) = streaming_hash_chunks(vec![chunks.0, chunks.1]);
        assert!(h == h_expected);
        assert!(h1 == h_expected);
        assert!(h2 == h_expected);
    }

    fn test_nist_vector(filename: &str) {
        use rustc_serialize::hex::FromHex;
        use std::fs::File;
        use std::io::{BufRead, BufReader};

        let mut r = BufReader::new(File::open(filename).unwrap());
        let mut line = String::new();
        loop {
            line.clear();
            r.read_line(&mut line).unwrap();
            if line.len() == 0 {
                break;
            }
            let starts_with_len = line.starts_with("Len = ");
            if starts_with_len {
                let len: usize = line[6..].trim().parse().unwrap();
                line.clear();
                r.read_line(&mut line).unwrap();
                let rawmsg = line[6..].from_hex().unwrap();
                let msg = &rawmsg[..len / 8];
                line.clear();
                r.read_line(&mut line).unwrap();
                let md = line[5..].from_hex().unwrap();
                let Digest(digest) = hash(msg);
                let Digest(digest1) = streaming_hash(msg);
                assert!(&digest[..] == &md[..]);
                assert!(&digest1[..] == &md[..]);
            }
        }
    }

    fn test_hash_for_file(file: &str) -> Digest {
        use std::fs::File;
        use std::io::{BufReader, Read};

        let mut r = BufReader::new(File::open(file).unwrap());
        let mut s = State::init();
        let mut buf = [0; 512];
        while let Ok(len) = r.read(&mut buf) {
            if len <= 0 {
                break;
            }
            s.update(&buf[..len]);
        }
        s.finalize()
    }

    #[test]
    fn test_vectors_nist_short() {
        test_nist_vector("testvectors/SHA256ShortMsg.rsp");
    }

    #[test]
    fn test_vectors_nist_long() {
        test_nist_vector("testvectors/SHA256LongMsg.rsp");
    }

    #[test]
    fn test_streaming_hashing() {
        use rustc_serialize::hex::FromHex;

        let Digest(hash_short) = test_hash_for_file("testvectors/SHA256ShortMsg.rsp");
        let Digest(hash_long) = test_hash_for_file("testvectors/SHA256LongMsg.rsp");
        let real_short = "aaf8115ef18263c52a7d2478d72b37dea30b25a1f7d0497136fbf7950715c587"
            .from_hex()
            .unwrap(); // short file
        let real_long = "b1f63358201511b72aa8e21234df37cf3287e95337dc2adb3d219968bedfa6a2"
            .from_hex()
            .unwrap(); // long file

        assert_eq!(&hash_short[..], &real_short[..]);
        assert_eq!(&hash_long[..], &real_long[..]);
    }
}

'''
'''--- src/crypto/hash/sha512.rs ---
//! `SHA-512`.
//!
//! There has been considerable degradation of public confidence in the
//! security conjectures for many hash functions, including `SHA-512`.
//! However, for the moment, there do not appear to be alternatives that
//! inspire satisfactory levels of confidence. One can hope that NIST's
//! SHA-3 competition will improve the situation.
use ffi::{crypto_hash_sha512, crypto_hash_sha512_BYTES, crypto_hash_sha512_final,
          crypto_hash_sha512_init, crypto_hash_sha512_state, crypto_hash_sha512_update};

hash_module!(
    crypto_hash_sha512,
    crypto_hash_sha512_BYTES,
    128,
    crypto_hash_sha512_state,
    crypto_hash_sha512_init,
    crypto_hash_sha512_update,
    crypto_hash_sha512_final
);

#[cfg(test)]
mod test {
    use super::*;

    fn streaming_hash(msg: &[u8]) -> Digest {
        let mut s = State::init();
        s.update(msg);
        s.finalize()
    }

    fn streaming_hash_chunks(chunks: Vec<&[u8]>) -> Digest {
        let mut s = State::init();
        for msg in chunks {
            s.update(msg);
        }
        s.finalize()
    }

    #[test]
    fn test_vector_1() {
        // corresponding to tests/hash.c, tests/hash2.cpp,
        // tests/hash3.c and tests/hash4.cpp from NaCl
        let x = [0x74, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x67, 0xa];
        let h_expected = [
            0x24, 0xf9, 0x50, 0xaa, 0xc7, 0xb9, 0xea, 0x9b, 0x3c, 0xb7, 0x28, 0x22, 0x8a, 0x0c,
            0x82, 0xb6, 0x7c, 0x39, 0xe9, 0x6b, 0x4b, 0x34, 0x47, 0x98, 0x87, 0x0d, 0x5d, 0xae,
            0xe9, 0x3e, 0x3a, 0xe5, 0x93, 0x1b, 0xaa, 0xe8, 0xc7, 0xca, 0xcf, 0xea, 0x4b, 0x62,
            0x94, 0x52, 0xc3, 0x80, 0x26, 0xa8, 0x1d, 0x13, 0x8b, 0xc7, 0xaa, 0xd1, 0xaf, 0x3e,
            0xf7, 0xbf, 0xd5, 0xec, 0x64, 0x6d, 0x6c, 0x28,
        ];
        let Digest(h) = hash(&x);
        let Digest(h1) = streaming_hash(&x);
        let chunks = x.split_at(x.len() / 2);
        let Digest(h2) = streaming_hash_chunks(vec![chunks.0, chunks.1]);
        assert!(&h[..] == &h_expected[..]);
        assert!(&h1[..] == &h_expected[..]);
        assert!(&h2[..] == &h_expected[..]);
    }

    fn test_nist_vector(filename: &str) {
        use rustc_serialize::hex::FromHex;
        use std::fs::File;
        use std::io::{BufRead, BufReader};

        let mut r = BufReader::new(File::open(filename).unwrap());
        let mut line = String::new();
        loop {
            line.clear();
            r.read_line(&mut line).unwrap();
            if line.len() == 0 {
                break;
            }
            let starts_with_len = line.starts_with("Len = ");
            if starts_with_len {
                let len: usize = line[6..].trim().parse().unwrap();
                line.clear();
                r.read_line(&mut line).unwrap();
                let rawmsg = line[6..].from_hex().unwrap();
                let msg = &rawmsg[..len / 8];
                line.clear();
                r.read_line(&mut line).unwrap();
                let md = line[5..].from_hex().unwrap();
                let Digest(digest) = hash(msg);
                let Digest(digest1) = streaming_hash(msg);
                assert!(&digest[..] == &md[..]);
                assert!(&digest1[..] == &md[..]);
            }
        }
    }

    fn test_hash_for_file(file: &str) -> Digest {
        use std::fs::File;
        use std::io::{BufReader, Read};

        let mut r = BufReader::new(File::open(file).unwrap());
        let mut s = State::init();
        loop {
            let mut buf = [0; 512];
            let len = r.read(&mut buf).unwrap();
            if len <= 0 {
                break;
            }
            s.update(&buf[..len]);
        }
        s.finalize()
    }

    #[test]
    fn test_vectors_nist_short() {
        test_nist_vector("testvectors/SHA512ShortMsg.rsp");
    }

    #[test]
    fn test_vectors_nist_long() {
        test_nist_vector("testvectors/SHA512LongMsg.rsp");
    }

    #[test]
    fn test_streaming_hashing() {
        use rustc_serialize::hex::FromHex;

        let Digest(hash_short) = test_hash_for_file("testvectors/SHA512ShortMsg.rsp");
        let Digest(hash_long) = test_hash_for_file("testvectors/SHA512LongMsg.rsp");
        let real_short = "13e65c6c9e0515d88aaa40c341b5d748b0a3376e0d3748049f1103ae7ce82ca48a85ae68cf34e8389e022a4c431b5654778787343f485c1aef9f48a1960ae389".from_hex().unwrap(); // short file
        let real_long  = "a86c0eb9e404ffbafa2e3eab986ce0a6bcebe2087ae9b4caa003a77f0abe37145ecdf005b7354e6ded925ffc1fa47275c6e841d388d2d0c7fe215b7360c3df88".from_hex().unwrap(); // long file
        assert_eq!(&hash_short[..], &real_short[..]);
        assert_eq!(&hash_long[..], &real_long[..]);
    }
}

'''
'''--- src/crypto/onetimeauth/mod.rs ---
//! Secret-key One-time authentication
//!
//! # Security model
//! The `authenticate()` function, viewed as a function
//! of the message for a uniform random key, is designed to meet the
//! standard notion of unforgeability after a single message. After the
//! sender authenticates one message, an attacker cannot find authenticators
//! for any other messages.
//!
//! The sender must not use `authenticate()` to authenticate more than one message
//! under the same key. Authenticators for two messages under the same key should
//! be expected to reveal enough information to allow forgeries of authenticators
//! on other messages.
//!
//! # Selected primitive
//! `authenticate()` is `crypto_onetimeauth_poly1305`, an authenticator specified
//! in [Cryptography in NaCl](http://nacl.cr.yp.to/valid.html), Section 9. This
//! authenticator is proven to meet the standard notion of unforgeability after a
//! single message.
//!
//! # Example
//! ```
//! use exonum_sodiumoxide::crypto::onetimeauth;
//!
//! let key = onetimeauth::gen_key();
//! let data_to_authenticate = b"some data";
//! let tag = onetimeauth::authenticate(data_to_authenticate, &key);
//! assert!(onetimeauth::verify(&tag, data_to_authenticate, &key));
//! ```
pub use self::poly1305::*;
#[path = "../auth/auth_macros.rs"]
#[macro_use]
mod auth_macros;
pub mod poly1305;

'''
'''--- src/crypto/onetimeauth/poly1305.rs ---
//! `crypto_onetimeauth_poly1305`, an authenticator specified
//! in [Cryptography in NaCl](http://nacl.cr.yp.to/valid.html), Section 9. This
//! authenticator is proven to meet the standard notion of unforgeability after a
//! single message.
use ffi::{crypto_onetimeauth_poly1305, crypto_onetimeauth_poly1305_BYTES,
          crypto_onetimeauth_poly1305_KEYBYTES, crypto_onetimeauth_poly1305_verify};

auth_module!(
    crypto_onetimeauth_poly1305,
    crypto_onetimeauth_poly1305_verify,
    crypto_onetimeauth_poly1305_KEYBYTES,
    crypto_onetimeauth_poly1305_BYTES
);

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_vector_1() {
        // corresponding to tests/onetimeauth.c, tests/onetimeauth2.c,
        // tests/onetimeauth5.cpp and tests/onetimeauth6.cpp from NaCl
        let key = Key([
            0xee, 0xa6, 0xa7, 0x25, 0x1c, 0x1e, 0x72, 0x91, 0x6d, 0x11, 0xc2, 0xcb, 0x21, 0x4d,
            0x3c, 0x25, 0x25, 0x39, 0x12, 0x1d, 0x8e, 0x23, 0x4e, 0x65, 0x2d, 0x65, 0x1f, 0xa4,
            0xc8, 0xcf, 0xf8, 0x80,
        ]);

        let c = [
            0x8e, 0x99, 0x3b, 0x9f, 0x48, 0x68, 0x12, 0x73, 0xc2, 0x96, 0x50, 0xba, 0x32, 0xfc,
            0x76, 0xce, 0x48, 0x33, 0x2e, 0xa7, 0x16, 0x4d, 0x96, 0xa4, 0x47, 0x6f, 0xb8, 0xc5,
            0x31, 0xa1, 0x18, 0x6a, 0xc0, 0xdf, 0xc1, 0x7c, 0x98, 0xdc, 0xe8, 0x7b, 0x4d, 0xa7,
            0xf0, 0x11, 0xec, 0x48, 0xc9, 0x72, 0x71, 0xd2, 0xc2, 0x0f, 0x9b, 0x92, 0x8f, 0xe2,
            0x27, 0x0d, 0x6f, 0xb8, 0x63, 0xd5, 0x17, 0x38, 0xb4, 0x8e, 0xee, 0xe3, 0x14, 0xa7,
            0xcc, 0x8a, 0xb9, 0x32, 0x16, 0x45, 0x48, 0xe5, 0x26, 0xae, 0x90, 0x22, 0x43, 0x68,
            0x51, 0x7a, 0xcf, 0xea, 0xbd, 0x6b, 0xb3, 0x73, 0x2b, 0xc0, 0xe9, 0xda, 0x99, 0x83,
            0x2b, 0x61, 0xca, 0x01, 0xb6, 0xde, 0x56, 0x24, 0x4a, 0x9e, 0x88, 0xd5, 0xf9, 0xb3,
            0x79, 0x73, 0xf6, 0x22, 0xa4, 0x3d, 0x14, 0xa6, 0x59, 0x9b, 0x1f, 0x65, 0x4c, 0xb4,
            0x5a, 0x74, 0xe3, 0x55, 0xa5,
        ];

        let a_expected = Tag([
            0xf3, 0xff, 0xc7, 0x70, 0x3f, 0x94, 0x00, 0xe5, 0x2a, 0x7d, 0xfb, 0x4b, 0x3d, 0x33,
            0x05, 0xd9,
        ]);
        let a = authenticate(&c, &key);
        assert!(a == a_expected);
        assert!(verify(&a, &c, &key));
    }
}

'''
'''--- src/crypto/pwhash/mod.rs ---
//! Password Hashing
//!
//! Secret keys used to encrypt or sign confidential data have to be chosen from
//! a very large keyspace. However, passwords are usually short, human-generated
//! strings, making dictionary attacks practical.
//!
//! The pwhash operation derives a secret key of any size from a password and a
//! salt.
//!
//! - The generated key has the size defined by the application, no matter what
//!   the password length is.
//! - The same password hashed with same parameters will
//!   always produce the same key.
//! - The same password hashed with different salts
//!   will produce different keys.
//! - The function deriving a key from a password
//!   and a salt is CPU intensive and intentionally requires a fair amount of
//!   memory. Therefore, it mitigates brute-force attacks by requiring a
//!   significant effort to verify each password.
//!
//! Common use cases:
//!
//! - Protecting an on-disk secret key with a password,
//! - Password storage, or rather: storing what it takes to verify a password
//!   without having to store the actual password.
//!
//! # Example (key derivation)
//! ```
//! use exonum_sodiumoxide::crypto::secretbox;
//! use exonum_sodiumoxide::crypto::pwhash;
//!
//! let passwd = b"Correct Horse Battery Staple";
//! let salt = pwhash::gen_salt();
//! let mut k = secretbox::Key([0; secretbox::KEYBYTES]);
//! {
//!     let secretbox::Key(ref mut kb) = k;
//!     pwhash::derive_key(kb, passwd, &salt,
//!                        pwhash::OPSLIMIT_INTERACTIVE,
//!                        pwhash::MEMLIMIT_INTERACTIVE).unwrap();
//! }
//! ```
//!
//! # Example (password hashing)
//! ```
//! use exonum_sodiumoxide::crypto::pwhash;
//! let passwd = b"Correct Horse Battery Staple";
//! let pwh = pwhash::pwhash(passwd,
//!                          pwhash::OPSLIMIT_INTERACTIVE,
//!                          pwhash::MEMLIMIT_INTERACTIVE).unwrap();
//! let pwh_bytes = &pwh[..];
//! //store pwh_bytes somewhere
//! ```
//!
//! # Example (password verification)
//! ```
//! use exonum_sodiumoxide::crypto::pwhash;
//!
//! let passwd = b"Correct Horse Battery Staple";
//! // in reality we want to load the password hash from somewhere
//! // and we might want to create a `HashedPassword` from it using
//! // `HashedPassword::from_slice(pwhash_bytes).unwrap()`
//! let pwh = pwhash::pwhash(passwd,
//!                          pwhash::OPSLIMIT_INTERACTIVE,
//!                          pwhash::MEMLIMIT_INTERACTIVE).unwrap();
//! assert!(pwhash::pwhash_verify(&pwh, passwd));
//! ```
pub use self::scryptsalsa208sha256::*;
pub mod scryptsalsa208sha256;

'''
'''--- src/crypto/pwhash/scryptsalsa208sha256.rs ---
//! `crypto_pwhash_scryptsalsa208sha256`, a particular combination of Scrypt, Salsa20/8
//! and SHA-256
use ffi;
use libc::c_ulonglong;
use randombytes::randombytes_into;

/// Number of bytes in a `Salt`.
pub const SALTBYTES: usize = ffi::crypto_pwhash_scryptsalsa208sha256_SALTBYTES;

/// Number of bytes in a `HashedPassword`.
pub const HASHEDPASSWORDBYTES: usize = ffi::crypto_pwhash_scryptsalsa208sha256_STRBYTES;

/// All `HashedPasswords` start with this string.
pub const STRPREFIX: &str = ffi::crypto_pwhash_scryptsalsa208sha256_STRPREFIX;

/// Safe base line for `OpsLimit` for interactive password hashing.
pub const OPSLIMIT_INTERACTIVE: OpsLimit =
    OpsLimit(ffi::crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE);

/// Safe base line for `MemLimit` for interactive password hashing.
pub const MEMLIMIT_INTERACTIVE: MemLimit =
    MemLimit(ffi::crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE);

/// `OpsLimit` for highly sensitive data.
pub const OPSLIMIT_SENSITIVE: OpsLimit =
    OpsLimit(ffi::crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE);

/// `MemLimit` for highly sensitive data.
pub const MEMLIMIT_SENSITIVE: MemLimit =
    MemLimit(ffi::crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE);

/// `OpsLimit` represents the maximum number of computations to perform when
/// using the functions in this module.
///
/// A high `OpsLimit` will make the functions
/// require more CPU cycles
#[derive(Copy, Clone)]
pub struct OpsLimit(pub usize);

/// `MemLimit` represents the maximum amount of RAM that the functions in this
/// module will use, in bytes.
///
/// It is highly recommended to allow the functions to use
/// at least 16 megabytes.
#[derive(Copy, Clone)]
pub struct MemLimit(pub usize);

new_type! {
    /// `Salt` used for password hashing
    public Salt(SALTBYTES);
}

new_type! {
    /// `HashedPassword`is a password verifier generated from a password
    ///
    /// A `HashedPassword` is zero-terminated, includes only ASCII characters and can
    /// be conveniently stored into SQL databases and other data stores. No
    /// additional information has to be stored in order to verify the password.
    public HashedPassword(HASHEDPASSWORDBYTES);
}

/// `gen_salt()` randombly generates a new `Salt` for key derivation
///
/// THREAD SAFETY: `gen_salt()` is thread-safe provided that you have called
/// `sodiumoxide::init()` once before using any other function from sodiumoxide.
pub fn gen_salt() -> Salt {
    let mut salt = Salt([0; SALTBYTES]);
    {
        let Salt(ref mut sb) = salt;
        randombytes_into(sb);
    }
    salt
}

/// The `derive_key()` function derives a key from a password and a `Salt`
///
/// The computed key is stored into key.
///
/// `opslimit` represents a maximum amount of computations to perform. Raising
/// this number will make the function require more CPU cycles to compute a key.
///
/// `memlimit` is the maximum amount of RAM that the function will use, in
/// bytes. It is highly recommended to allow the function to use at least 16
/// megabytes.
///
/// For interactive, online operations, `OPSLIMIT_INTERACTIVE` and
/// `MEMLIMIT_INTERACTIVE` provide a safe base line for these two
/// parameters. However, using higher values may improve security.
///
/// For highly sensitive data, `OPSLIMIT_SENSITIVE` and `MEMLIMIT_SENSITIVE` can
/// be used as an alternative. But with these parameters, deriving a key takes
/// more than 10 seconds on a 2.8 Ghz Core i7 CPU and requires up to 1 gigabyte
/// of dedicated RAM.
///
/// The salt should be unpredictable. `gen_salt()` is the easiest way to create a `Salt`.
///
/// Keep in mind that in order to produce the same key from the same password,
/// the same salt, and the same values for opslimit and memlimit have to be
/// used.
///
/// The function returns `Ok(key)` on success and `Err(())` if the computation didn't
/// complete, usually because the operating system refused to allocate the
/// amount of requested memory.
pub fn derive_key<'a>(
    key: &'a mut [u8],
    passwd: &[u8],
    &Salt(ref sb): &Salt,
    OpsLimit(opslimit): OpsLimit,
    MemLimit(memlimit): MemLimit,
) -> Result<&'a [u8], ()> {
    if unsafe {
        ffi::crypto_pwhash_scryptsalsa208sha256(
            key.as_mut_ptr(),
            key.len() as c_ulonglong,
            passwd.as_ptr(),
            passwd.len() as c_ulonglong,
            sb,
            opslimit as c_ulonglong,
            memlimit,
        )
    } == 0
    {
        Ok(key)
    } else {
        Err(())
    }
}

/// The `pwhash()` returns a `HashedPassword` which
/// includes:
///
/// - the result of a memory-hard, CPU-intensive hash function applied to the password
///   `passwd`
/// - the automatically generated salt used for the
///   previous computation
/// - the other parameters required to verify the password: opslimit and memlimit
///
/// `OPSLIMIT_INTERACTIVE` and `MEMLIMIT_INTERACTIVE` are safe baseline
/// values to use for `opslimit` and `memlimit`.
///
/// The function returns `Ok(hashed_password)` on success and `Err(())` if it didn't complete
/// successfully
pub fn pwhash(
    passwd: &[u8],
    OpsLimit(opslimit): OpsLimit,
    MemLimit(memlimit): MemLimit,
) -> Result<HashedPassword, ()> {
    let mut out = HashedPassword([0; HASHEDPASSWORDBYTES]);
    if unsafe {
        let HashedPassword(ref mut str_) = out;
        ffi::crypto_pwhash_scryptsalsa208sha256_str(
            str_,
            passwd.as_ptr(),
            passwd.len() as c_ulonglong,
            opslimit as c_ulonglong,
            memlimit,
        )
    } == 0
    {
        Ok(out)
    } else {
        Err(())
    }
}

/// `pwhash_verify()` verifies that the password `str_` is a valid password
/// verification string (as generated by `pwhash()`) for `passwd`
///
/// It returns `true` if the verification succeeds, and `false` on error.
pub fn pwhash_verify(&HashedPassword(ref str_): &HashedPassword, passwd: &[u8]) -> bool {
    unsafe {
        ffi::crypto_pwhash_scryptsalsa208sha256_str_verify(
            str_,
            passwd.as_ptr(),
            passwd.len() as c_ulonglong,
        ) == 0
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_derive_key() {
        let mut kb = [0u8; 32];
        let salt = Salt([
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
            24, 25, 26, 27, 28, 29, 30, 31,
        ]);
        let pw = b"Correct Horse Battery Staple";
        // test vector generated by using libsodium
        let key_expected = [
            0xf1, 0xbb, 0xb8, 0x7c, 0x43, 0x36, 0x5b, 0x03, 0x3b, 0x9a, 0xe8, 0x3e, 0x05, 0xef,
            0xad, 0x25, 0xdb, 0x8d, 0x83, 0xb8, 0x3d, 0xb1, 0xde, 0xe3, 0x6b, 0xdb, 0xf5, 0x4d,
            0xcd, 0x3a, 0x1a, 0x11,
        ];
        let key = derive_key(
            &mut kb,
            pw,
            &salt,
            OPSLIMIT_INTERACTIVE,
            MEMLIMIT_INTERACTIVE,
        ).unwrap();
        assert_eq!(key, key_expected);
    }

    #[test]
    fn test_pwhash_verify() {
        use randombytes::randombytes;
        for i in 0..32usize {
            let pw = randombytes(i);
            let pwh = pwhash(&pw, OPSLIMIT_INTERACTIVE, MEMLIMIT_INTERACTIVE).unwrap();
            assert!(pwhash_verify(&pwh, &pw));
        }
    }

    #[test]
    fn test_pwhash_verify_tamper() {
        use randombytes::randombytes;
        for i in 0..16usize {
            let mut pw = randombytes(i);
            let pwh = pwhash(&pw, OPSLIMIT_INTERACTIVE, MEMLIMIT_INTERACTIVE).unwrap();
            for j in 0..pw.len() {
                pw[j] ^= 0x20;
                assert!(!pwhash_verify(&pwh, &pw));
                pw[j] ^= 0x20;
            }
        }
    }

    #[cfg(feature = "serde")]
    #[test]
    fn test_serialisation() {
        use randombytes::randombytes;
        use test_utils::round_trip;
        for i in 0..32usize {
            let pw = randombytes(i);
            let pwh = pwhash(&pw, OPSLIMIT_INTERACTIVE, MEMLIMIT_INTERACTIVE).unwrap();
            let salt = gen_salt();
            round_trip(pwh);
            round_trip(salt);
        }
    }
}

'''
'''--- src/crypto/scalarmult/curve25519.rs ---
//! `crypto_scalarmult_curve25519` specified in
//! [Cryptography in NaCl](http://nacl.cr.yp.to/valid.html), Sections 2, 3, and 4.
//! This function is conjectured to be strong. For background see Bernstein,
//! "Curve25519: new Diffie-Hellman speed records," Lecture Notes in Computer
//! Science 3958 (2006), 207228, http://cr.yp.to/papers.html#curve25519.
use ffi;

/// Number of bytes in a `GroupElement`.
pub const GROUPELEMENTBYTES: usize = ffi::crypto_scalarmult_curve25519_BYTES;

/// Number of bytes in a `Scalar`.
pub const SCALARBYTES: usize = ffi::crypto_scalarmult_curve25519_SCALARBYTES;

new_type! {
    /// `Scalar` value (integer in byte representation)
    secret Scalar(SCALARBYTES);
}

new_type! {
    /// `GroupElement`
    secret GroupElement(GROUPELEMENTBYTES);
}

/// `scalarmult()` multiplies a group element `p`
/// by an integer `n`. It returns the resulting group element
/// `Ok(q)`.
/// If the the `GroupElement` is all zero, `scalarmult()` returns `Err(())` since
/// the resulting `GroupElement` would be all zero, no matter the `Scalar`.
pub fn scalarmult(
    &Scalar(ref n): &Scalar,
    &GroupElement(ref p): &GroupElement,
) -> Result<GroupElement, ()> {
    let mut q = [0; GROUPELEMENTBYTES];
    unsafe {
        if ffi::crypto_scalarmult_curve25519(&mut q, n, p) != 0 {
            Err(())
        } else {
            Ok(GroupElement(q))
        }
    }
}

/// `scalarmult_base()` computes the scalar product of a standard
/// group element and an integer `n`. It returns the resulting
/// group element `q`/
pub fn scalarmult_base(&Scalar(ref n): &Scalar) -> GroupElement {
    let mut q = [0; GROUPELEMENTBYTES];
    unsafe {
        ffi::crypto_scalarmult_curve25519_base(&mut q, n);
    }
    GroupElement(q)
}

#[cfg(test)]
mod test {
    use super::*;
    use randombytes::randombytes_into;

    #[test]
    fn test_vector_1() {
        // corresponding to tests/scalarmult.c and tests/scalarmult3.cpp from NaCl
        let alicesk = Scalar([
            0x77, 0x07, 0x6d, 0x0a, 0x73, 0x18, 0xa5, 0x7d, 0x3c, 0x16, 0xc1, 0x72, 0x51, 0xb2,
            0x66, 0x45, 0xdf, 0x4c, 0x2f, 0x87, 0xeb, 0xc0, 0x99, 0x2a, 0xb1, 0x77, 0xfb, 0xa5,
            0x1d, 0xb9, 0x2c, 0x2a,
        ]);
        let alicepk_expected = [
            0x85, 0x20, 0xf0, 0x09, 0x89, 0x30, 0xa7, 0x54, 0x74, 0x8b, 0x7d, 0xdc, 0xb4, 0x3e,
            0xf7, 0x5a, 0x0d, 0xbf, 0x3a, 0x0d, 0x26, 0x38, 0x1a, 0xf4, 0xeb, 0xa4, 0xa9, 0x8e,
            0xaa, 0x9b, 0x4e, 0x6a,
        ];
        let GroupElement(alicepk) = scalarmult_base(&alicesk);
        assert!(alicepk == alicepk_expected);
    }

    #[test]
    fn test_vector_2() {
        // corresponding to tests/scalarmult2.c and tests/scalarmult4.cpp from NaCl
        let bobsk = Scalar([
            0x5d, 0xab, 0x08, 0x7e, 0x62, 0x4a, 0x8a, 0x4b, 0x79, 0xe1, 0x7f, 0x8b, 0x83, 0x80,
            0x0e, 0xe6, 0x6f, 0x3b, 0xb1, 0x29, 0x26, 0x18, 0xb6, 0xfd, 0x1c, 0x2f, 0x8b, 0x27,
            0xff, 0x88, 0xe0, 0xeb,
        ]);
        let bobpk_expected = [
            0xde, 0x9e, 0xdb, 0x7d, 0x7b, 0x7d, 0xc1, 0xb4, 0xd3, 0x5b, 0x61, 0xc2, 0xec, 0xe4,
            0x35, 0x37, 0x3f, 0x83, 0x43, 0xc8, 0x5b, 0x78, 0x67, 0x4d, 0xad, 0xfc, 0x7e, 0x14,
            0x6f, 0x88, 0x2b, 0x4f,
        ];
        let GroupElement(bobpk) = scalarmult_base(&bobsk);
        assert!(bobpk == bobpk_expected);
    }

    #[test]
    fn test_vector_3() {
        // corresponding to tests/scalarmult5.c and tests/scalarmult7.cpp from NaCl
        let alicesk = Scalar([
            0x77, 0x07, 0x6d, 0x0a, 0x73, 0x18, 0xa5, 0x7d, 0x3c, 0x16, 0xc1, 0x72, 0x51, 0xb2,
            0x66, 0x45, 0xdf, 0x4c, 0x2f, 0x87, 0xeb, 0xc0, 0x99, 0x2a, 0xb1, 0x77, 0xfb, 0xa5,
            0x1d, 0xb9, 0x2c, 0x2a,
        ]);
        let bobpk = GroupElement([
            0xde, 0x9e, 0xdb, 0x7d, 0x7b, 0x7d, 0xc1, 0xb4, 0xd3, 0x5b, 0x61, 0xc2, 0xec, 0xe4,
            0x35, 0x37, 0x3f, 0x83, 0x43, 0xc8, 0x5b, 0x78, 0x67, 0x4d, 0xad, 0xfc, 0x7e, 0x14,
            0x6f, 0x88, 0x2b, 0x4f,
        ]);
        let k_expected = [
            0x4a, 0x5d, 0x9d, 0x5b, 0xa4, 0xce, 0x2d, 0xe1, 0x72, 0x8e, 0x3b, 0xf4, 0x80, 0x35,
            0x0f, 0x25, 0xe0, 0x7e, 0x21, 0xc9, 0x47, 0xd1, 0x9e, 0x33, 0x76, 0xf0, 0x9b, 0x3c,
            0x1e, 0x16, 0x17, 0x42,
        ];
        let GroupElement(k) = scalarmult(&alicesk, &bobpk).unwrap();
        assert!(k == k_expected);
    }

    #[test]
    fn test_vector_4() {
        // corresponding to tests/scalarmult6.c from NaCl
        let bobsk = Scalar([
            0x5d, 0xab, 0x08, 0x7e, 0x62, 0x4a, 0x8a, 0x4b, 0x79, 0xe1, 0x7f, 0x8b, 0x83, 0x80,
            0x0e, 0xe6, 0x6f, 0x3b, 0xb1, 0x29, 0x26, 0x18, 0xb6, 0xfd, 0x1c, 0x2f, 0x8b, 0x27,
            0xff, 0x88, 0xe0, 0xeb,
        ]);
        let alicepk = GroupElement([
            0x85, 0x20, 0xf0, 0x09, 0x89, 0x30, 0xa7, 0x54, 0x74, 0x8b, 0x7d, 0xdc, 0xb4, 0x3e,
            0xf7, 0x5a, 0x0d, 0xbf, 0x3a, 0x0d, 0x26, 0x38, 0x1a, 0xf4, 0xeb, 0xa4, 0xa9, 0x8e,
            0xaa, 0x9b, 0x4e, 0x6a,
        ]);
        let k_expected = [
            0x4a, 0x5d, 0x9d, 0x5b, 0xa4, 0xce, 0x2d, 0xe1, 0x72, 0x8e, 0x3b, 0xf4, 0x80, 0x35,
            0x0f, 0x25, 0xe0, 0x7e, 0x21, 0xc9, 0x47, 0xd1, 0x9e, 0x33, 0x76, 0xf0, 0x9b, 0x3c,
            0x1e, 0x16, 0x17, 0x42,
        ];
        let GroupElement(k) = scalarmult(&bobsk, &alicepk).unwrap();
        assert!(k == k_expected);
    }

    #[test]
    #[should_panic]
    fn test_all_zero() {
        let mut sk = [0; SCALARBYTES];
        randombytes_into(&mut sk);
        let sk = Scalar(sk);
        let pk = GroupElement([0; GROUPELEMENTBYTES]);
        let _ = scalarmult(&sk, &pk).unwrap();
    }
}

#[cfg(feature = "benchmarks")]
#[cfg(test)]
mod bench {
    extern crate test;
    use super::*;
    use randombytes::randombytes_into;

    #[bench]
    fn bench_scalarmult(b: &mut test::Bencher) {
        let mut gbs = [0u8; GROUPELEMENTBYTES];
        let mut sbs = [0u8; SCALARBYTES];
        randombytes_into(&mut gbs);
        randombytes_into(&mut sbs);
        let g = GroupElement(gbs);
        let s = Scalar(sbs);
        b.iter(|| {
            scalarmult(&s, &g);
        });
    }

    #[bench]
    fn bench_scalarmult_base(b: &mut test::Bencher) {
        let mut sbs = [0u8; SCALARBYTES];
        randombytes_into(&mut sbs);
        let s = Scalar(sbs);
        b.iter(|| {
            scalarmult_base(&s);
        });
    }
}

'''
'''--- src/crypto/scalarmult/mod.rs ---
//! Scalar multiplication
//!
//! # Representation of group elements
//! The correspondence between strings and group elements depends on the primitive
//! implemented by `scalarmult()`. The correspondence is not necessarily
//! injective in either direction, but it is compatible with scalar multiplication
//! in the group. The correspondence does not necessarily include all group
//! elements, but it does include all strings; i.e., every string represents at
//! least one group element.
//!
//! # Representation of integers
//! The correspondence between strings and integers also depends on the primitive
//! implemented by `scalarmult()`. Every string represents at least one integer.
//!
//! # Security model
//! `scalarmult` is designed to be strong as a component of various well-known
//! "hashed DiffieHellman" applications. In particular, it is designed to make the
//! "computational DiffieHellman" problem (CDH) difficult with respect to the
//! standard base.
//!
//! `scalarmult` is also designed to make CDH difficult with respect to other
//! nontrivial bases. In particular, if a represented group element has small
//! order, then it is annihilated by all represented scalars. This feature allows
//! protocols to avoid validating membership in the subgroup generated by the
//! standard base.
//!
//! NaCl does not make any promises regarding the "decisional DiffieHellman"
//! problem (DDH), the "static DiffieHellman" problem (SDH), etc. Users are
//! responsible for hashing group elements.
//!
//! # Selected primitive
//! `scalarmult` is the function `crypto_scalarmult_curve25519` specified in
//! [Cryptography in NaCl](http://nacl.cr.yp.to/valid.html), Sections 2, 3, and 4.
//! This function is conjectured to be strong. For background see Bernstein,
//! "Curve25519: new Diffie-Hellman speed records," Lecture Notes in Computer
//! Science 3958 (2006), 207228, http://cr.yp.to/papers.html#curve25519.
pub use self::curve25519::*;
pub mod curve25519;

'''
'''--- src/crypto/sealedbox/curve25519blake2bxsalsa20poly1305.rs ---
//! A particular combination of Curve25519, Blake2B, Salsa20 and Poly1305.
use ffi;
#[cfg(not(feature = "std"))]
use prelude::*;

use libc::c_ulonglong;

use super::super::box_::curve25519xsalsa20poly1305 as box_;

/// Number of additional bytes in a ciphertext compared to the corresponding
/// plaintext.
const SEALBYTES: usize = ffi::crypto_box_SEALBYTES;

/// The `seal()` function encrypts a message `m` for a recipient whose public key
/// is `pk`. It returns the ciphertext whose length is `SEALBYTES + m.len()`.
///
/// The function creates a new key pair for each message, and attaches the public
/// key to the ciphertext. The secret key is overwritten and is not accessible
/// after this function returns.
pub fn seal(m: &[u8], &box_::PublicKey(ref pk): &box_::PublicKey) -> Vec<u8> {
    let mut c = vec![0u8; m.len() + SEALBYTES];
    unsafe {
        ffi::crypto_box_seal(c.as_mut_ptr(), m.as_ptr(), m.len() as c_ulonglong, pk);
    }
    c
}

/// The `open()` function decrypts the ciphertext `c` using the key pair `(pk, sk)`
/// and returns the decrypted message.
///
/// Key pairs are compatible with other
/// `crypto::box_::curve25519xsalsa20poly1305` operations and can be created
/// using `crypto::box::gen_keypair()`.
///
/// This function doesn't require passing the public key of the sender, as the
/// ciphertext already includes this information.
///
/// If decryption fails it returns `Err(())`.
pub fn open(
    c: &[u8],
    &box_::PublicKey(ref pk): &box_::PublicKey,
    &box_::SecretKey(ref sk): &box_::SecretKey,
) -> Result<Vec<u8>, ()> {
    if c.len() < SEALBYTES {
        return Err(());
    }
    let mut m = vec![0u8; c.len() - SEALBYTES];
    let ret = unsafe {
        ffi::crypto_box_seal_open(m.as_mut_ptr(), c.as_ptr(), c.len() as c_ulonglong, pk, sk)
    };
    if ret == 0 {
        Ok(m)
    } else {
        Err(())
    }
}

#[cfg(test)]
mod test {
    use super::super::super::box_::curve25519xsalsa20poly1305 as box_;
    use super::*;

    #[test]
    fn test_seal_open() {
        use randombytes::randombytes;
        for i in 0..256usize {
            let (pk, sk) = box_::gen_keypair();
            let m = randombytes(i);
            let c = seal(&m, &pk);
            let opened = open(&c, &pk, &sk);
            assert!(Ok(m) == opened);
        }
    }

    #[test]
    fn test_seal_open_tamper() {
        use randombytes::randombytes;
        for i in 0..32usize {
            let (pk, sk) = box_::gen_keypair();
            let m = randombytes(i);
            let mut c = seal(&m, &pk);
            for j in 0..c.len() {
                c[j] ^= 0x20;
                assert!(Err(()) == open(&mut c, &pk, &sk));
                c[j] ^= 0x20;
            }
        }
    }
}

'''
'''--- src/crypto/sealedbox/mod.rs ---
//! Sealed Boxes
//!
//! # Purpose
//! Sealed boxes are designed to anonymously send messages to a recipient given
//! its public key.
//!
//! Only the recipient can decrypt these messages, using its private key. While
//! the recipient can verify the integrity of the message, it cannot verify the
//! identity of the sender.
//!
//! A message is encrypted using an ephemeral key pair, whose secret part is
//! destroyed right after the encryption process.
//!
//! Without knowing the secret key used for a given message, the sender cannot
//! decrypt its own message later. And without additional data, a message
//! cannot be correlated with the identity of its sender.
//!
//! # Algorithm Details
//! Sealed boxes leverage the `crypto_box` construction (X25519, XSalsa20-Poly1305).
//!
//! The format of a sealed box is
//!
//! ```c
//! ephemeral_pk || box(m, recipient_pk, ephemeral_sk,
//!                     nonce=blake2b(ephemeral_pk, recipient_pk))
//! ```
//!
pub use self::curve25519blake2bxsalsa20poly1305::*;
pub mod curve25519blake2bxsalsa20poly1305;

'''
'''--- src/crypto/secretbox/mod.rs ---
//! Secret-key authenticated encryption
//!
//! # Security model
//! The `seal()` function is designed to meet the standard notions of privacy and
//! authenticity for a secret-key authenticated-encryption scheme using nonces. For
//! formal definitions see, e.g., Bellare and Namprempre, "Authenticated
//! encryption: relations among notions and analysis of the generic composition
//! paradigm," Lecture Notes in Computer Science 1976 (2000), 531545,
//! http://www-cse.ucsd.edu/~mihir/papers/oem.html.
//!
//! Note that the length is not hidden. Note also that it is the caller's
//! responsibility to ensure the uniqueness of noncesfor example, by using
//! nonce 1 for the first message, nonce 2 for the second message, etc.
//! Nonces are long enough that randomly generated nonces have negligible
//! risk of collision.
//!
//! # Selected primitive
//! `seal()` is `crypto_secretbox_xsalsa20poly1305`, a particular
//! combination of Salsa20 and Poly1305 specified in
//! [Cryptography in NaCl](http://nacl.cr.yp.to/valid.html).
//!
//! This function is conjectured to meet the standard notions of privacy and
//! authenticity.
//!
//! # Example
//! ```
//! use exonum_sodiumoxide::crypto::secretbox;
//! let key = secretbox::gen_key();
//! let nonce = secretbox::gen_nonce();
//! let plaintext = b"some data";
//! let ciphertext = secretbox::seal(plaintext, &nonce, &key);
//! let their_plaintext = secretbox::open(&ciphertext, &nonce, &key).unwrap();
//! assert!(plaintext == &their_plaintext[..]);
//! ```
pub use self::xsalsa20poly1305::*;
pub mod xsalsa20poly1305;

'''
'''--- src/crypto/secretbox/xsalsa20poly1305.rs ---
//! `crypto_secretbox_xsalsa20poly1305`, a particular
//! combination of Salsa20 and Poly1305 specified in
//! [Cryptography in NaCl](http://nacl.cr.yp.to/valid.html).
//!
//! This function is conjectured to meet the standard notions of privacy and
//! authenticity.
use ffi;
#[cfg(not(feature = "std"))]
use prelude::*;
use randombytes::randombytes_into;

/// Number of bytes in `Key`.
pub const KEYBYTES: usize = ffi::crypto_secretbox_xsalsa20poly1305_KEYBYTES;

/// Number of bytes in a `Nonce`.
pub const NONCEBYTES: usize = ffi::crypto_secretbox_xsalsa20poly1305_NONCEBYTES;

new_type! {
    /// `Key` for symmetric authenticated encryption
    ///
    /// When a `Key` goes out of scope its contents
    /// will be zeroed out
    secret Key(KEYBYTES);
}

new_type! {
    /// Authentication `Tag` for the detached encryption mode
    ///
    /// In the combined mode, the tag occupies the first MACBYTES bytes of the ciphertext.
    public Tag(MACBYTES);
}

new_type! {
    /// `Nonce` for symmetric authenticated encryption
    nonce Nonce(NONCEBYTES);
}

/// Number of bytes in the authenticator tag of an encrypted message
/// i.e. the number of bytes by which the ciphertext is larger than the
/// plaintext.
pub const MACBYTES: usize = ffi::crypto_secretbox_xsalsa20poly1305_MACBYTES;

/// `gen_key()` randomly generates a secret key
///
/// THREAD SAFETY: `gen_key()` is thread-safe provided that you have
/// called `sodiumoxide::init()` once before using any other function
/// from sodiumoxide.
pub fn gen_key() -> Key {
    let mut key = [0; KEYBYTES];
    randombytes_into(&mut key);
    Key(key)
}

/// `gen_nonce()` randomly generates a nonce
///
/// THREAD SAFETY: `gen_key()` is thread-safe provided that you have
/// called `sodiumoxide::init()` once before using any other function
/// from sodiumoxide.
pub fn gen_nonce() -> Nonce {
    let mut nonce = [0; NONCEBYTES];
    randombytes_into(&mut nonce);
    Nonce(nonce)
}

/// `seal()` encrypts and authenticates a message `m` using a secret key `k` and a
/// nonce `n`.  It returns a ciphertext `c`.
pub fn seal(m: &[u8], &Nonce(ref n): &Nonce, &Key(ref k): &Key) -> Vec<u8> {
    let clen = m.len() + MACBYTES;
    let mut c = Vec::with_capacity(clen);
    unsafe {
        c.set_len(clen);
        ffi::crypto_secretbox_easy(c.as_mut_ptr(), m.as_ptr(), m.len() as u64, n, k);
    }
    c
}

/// `seal_detached()` encrypts and authenticates a message `m` using a secret key `k` and a nonce
/// `n`.  `m` is encrypted in place, so after this function returns it will contain the ciphertext.
/// The detached authentication tag is returned by value.
pub fn seal_detached(m: &mut [u8], &Nonce(ref n): &Nonce, &Key(ref k): &Key) -> Tag {
    let mut tag = [0; MACBYTES];
    unsafe {
        ffi::crypto_secretbox_detached(m.as_mut_ptr(), &mut tag, m.as_ptr(), m.len() as u64, n, k);
    };
    Tag(tag)
}

/// `open()` verifies and decrypts a ciphertext `c` using a secret key `k` and a nonce `n`.
/// It returns a plaintext `Ok(m)`.
/// If the ciphertext fails verification, `open()` returns `Err(())`.
pub fn open(c: &[u8], &Nonce(ref n): &Nonce, &Key(ref k): &Key) -> Result<Vec<u8>, ()> {
    if c.len() < MACBYTES {
        return Err(());
    }
    let mlen = c.len() - MACBYTES;
    let mut m = Vec::with_capacity(mlen);
    let ret = unsafe {
        m.set_len(mlen);
        ffi::crypto_secretbox_open_easy(m.as_mut_ptr(), c.as_ptr(), c.len() as u64, n, k)
    };
    if ret == 0 {
        Ok(m)
    } else {
        Err(())
    }
}

/// `open_detached()` verifies and decrypts a ciphertext `c` and and authentication tag `tag`,
/// using a secret key `k` and a nonce `n`. `c` is decrypted in place, so if this function is
/// successful it will contain the plaintext. If the ciphertext fails verification,
/// `open_detached()` returns `Err(())`, and the ciphertext is not modified.
pub fn open_detached(
    c: &mut [u8],
    tag: &Tag,
    &Nonce(ref n): &Nonce,
    &Key(ref k): &Key,
) -> Result<(), ()> {
    let ret = unsafe {
        ffi::crypto_secretbox_open_detached(
            c.as_mut_ptr(),
            c.as_ptr(),
            &tag.0,
            c.len() as u64,
            n,
            k,
        )
    };
    if ret == 0 {
        Ok(())
    } else {
        Err(())
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_seal_open() {
        use randombytes::randombytes;
        for i in 0..256usize {
            let k = gen_key();
            let m = randombytes(i);
            let n = gen_nonce();
            let c = seal(&m, &n, &k);
            let opened = open(&c, &n, &k);
            assert_eq!(Ok(m), opened);
        }
    }

    #[test]
    fn test_seal_open_tamper() {
        use randombytes::randombytes;
        for i in 0..32usize {
            let k = gen_key();
            let m = randombytes(i);
            let n = gen_nonce();
            let mut c = seal(&m, &n, &k);
            for i in 0..c.len() {
                c[i] ^= 0x20;
                // Test the combined mode.
                assert_eq!(Err(()), open(&mut c, &n, &k));
                // Test the detached mode.
                let tag = Tag::from_slice(&c[..MACBYTES]).unwrap();
                assert_eq!(Err(()), open_detached(&mut c[MACBYTES..], &tag, &n, &k));
                c[i] ^= 0x20;
            }
        }
    }

    #[test]
    fn test_seal_open_detached() {
        use randombytes::randombytes;
        for i in 0..256usize {
            let k = gen_key();
            let m = randombytes(i);
            let n = gen_nonce();
            let mut buf = m.clone();
            let tag = seal_detached(&mut buf, &n, &k);
            open_detached(&mut buf, &tag, &n, &k).unwrap();
            assert_eq!(m, buf);
        }
    }

    #[test]
    fn test_seal_combined_then_open_detached() {
        use randombytes::randombytes;
        for i in 0..256usize {
            let k = gen_key();
            let m = randombytes(i);
            let n = gen_nonce();
            let mut c = seal(&m, &n, &k);
            let tag = Tag::from_slice(&c[..MACBYTES]).unwrap();
            let buf = &mut c[MACBYTES..];
            open_detached(buf, &tag, &n, &k).unwrap();
            assert_eq!(buf, &*m);
        }
    }

    #[test]
    fn test_seal_detached_then_open_combined() {
        use randombytes::randombytes;
        for i in 0..256usize {
            let k = gen_key();
            let m = randombytes(i);
            let n = gen_nonce();
            let mut buf = vec![0; MACBYTES];
            buf.extend_from_slice(&m);
            let tag = seal_detached(&mut buf[MACBYTES..], &n, &k);
            buf[..MACBYTES].copy_from_slice(&tag.0[..]);
            let opened = open(&buf, &n, &k);
            assert_eq!(Ok(m), opened);
        }
    }

    #[test]
    fn test_seal_open_detached_tamper() {
        use randombytes::randombytes;
        for i in 0..32usize {
            let k = gen_key();
            let mut m = randombytes(i);
            let n = gen_nonce();
            let mut tag = seal_detached(&mut m, &n, &k);
            for j in 0..m.len() {
                m[j] ^= 0x20;
                assert_eq!(Err(()), open_detached(&mut m, &tag, &n, &k));
                m[j] ^= 0x20;
            }
            for j in 0..tag.0.len() {
                tag.0[j] ^= 0x20;
                assert_eq!(Err(()), open_detached(&mut m, &tag, &n, &k));
                tag.0[j] ^= 0x20;
            }
        }
    }

    #[test]
    fn test_open_detached_failure_does_not_modify() {
        let mut buf = b"hello world".to_vec();
        let k = gen_key();
        let n = gen_nonce();
        let tag = seal_detached(&mut buf, &n, &k);
        // Flip the last bit in the ciphertext, to break authentication.
        *buf.last_mut().unwrap() ^= 1;
        // Make a copy that we can compare against after the failure below.
        let copy = buf.clone();
        // Now try to open the message. This will fail.
        let failure = open_detached(&mut buf, &tag, &n, &k);
        assert!(failure.is_err());
        // Make sure the input hasn't been touched.
        assert_eq!(
            buf, copy,
            "input should not be modified if authentication fails"
        );
    }

    #[test]
    fn test_vector_1() {
        let firstkey = Key([
            0x1b, 0x27, 0x55, 0x64, 0x73, 0xe9, 0x85, 0xd4, 0x62, 0xcd, 0x51, 0x19, 0x7a, 0x9a,
            0x46, 0xc7, 0x60, 0x09, 0x54, 0x9e, 0xac, 0x64, 0x74, 0xf2, 0x06, 0xc4, 0xee, 0x08,
            0x44, 0xf6, 0x83, 0x89,
        ]);
        let nonce = Nonce([
            0x69, 0x69, 0x6e, 0xe9, 0x55, 0xb6, 0x2b, 0x73, 0xcd, 0x62, 0xbd, 0xa8, 0x75, 0xfc,
            0x73, 0xd6, 0x82, 0x19, 0xe0, 0x03, 0x6b, 0x7a, 0x0b, 0x37,
        ]);
        let m = vec![
            0xbe, 0x07, 0x5f, 0xc5, 0x3c, 0x81, 0xf2, 0xd5, 0xcf, 0x14, 0x13, 0x16, 0xeb, 0xeb,
            0x0c, 0x7b, 0x52, 0x28, 0xc5, 0x2a, 0x4c, 0x62, 0xcb, 0xd4, 0x4b, 0x66, 0x84, 0x9b,
            0x64, 0x24, 0x4f, 0xfc, 0xe5, 0xec, 0xba, 0xaf, 0x33, 0xbd, 0x75, 0x1a, 0x1a, 0xc7,
            0x28, 0xd4, 0x5e, 0x6c, 0x61, 0x29, 0x6c, 0xdc, 0x3c, 0x01, 0x23, 0x35, 0x61, 0xf4,
            0x1d, 0xb6, 0x6c, 0xce, 0x31, 0x4a, 0xdb, 0x31, 0x0e, 0x3b, 0xe8, 0x25, 0x0c, 0x46,
            0xf0, 0x6d, 0xce, 0xea, 0x3a, 0x7f, 0xa1, 0x34, 0x80, 0x57, 0xe2, 0xf6, 0x55, 0x6a,
            0xd6, 0xb1, 0x31, 0x8a, 0x02, 0x4a, 0x83, 0x8f, 0x21, 0xaf, 0x1f, 0xde, 0x04, 0x89,
            0x77, 0xeb, 0x48, 0xf5, 0x9f, 0xfd, 0x49, 0x24, 0xca, 0x1c, 0x60, 0x90, 0x2e, 0x52,
            0xf0, 0xa0, 0x89, 0xbc, 0x76, 0x89, 0x70, 0x40, 0xe0, 0x82, 0xf9, 0x37, 0x76, 0x38,
            0x48, 0x64, 0x5e, 0x07, 0x05,
        ];

        let c_expected = vec![
            0xf3, 0xff, 0xc7, 0x70, 0x3f, 0x94, 0x00, 0xe5, 0x2a, 0x7d, 0xfb, 0x4b, 0x3d, 0x33,
            0x05, 0xd9, 0x8e, 0x99, 0x3b, 0x9f, 0x48, 0x68, 0x12, 0x73, 0xc2, 0x96, 0x50, 0xba,
            0x32, 0xfc, 0x76, 0xce, 0x48, 0x33, 0x2e, 0xa7, 0x16, 0x4d, 0x96, 0xa4, 0x47, 0x6f,
            0xb8, 0xc5, 0x31, 0xa1, 0x18, 0x6a, 0xc0, 0xdf, 0xc1, 0x7c, 0x98, 0xdc, 0xe8, 0x7b,
            0x4d, 0xa7, 0xf0, 0x11, 0xec, 0x48, 0xc9, 0x72, 0x71, 0xd2, 0xc2, 0x0f, 0x9b, 0x92,
            0x8f, 0xe2, 0x27, 0x0d, 0x6f, 0xb8, 0x63, 0xd5, 0x17, 0x38, 0xb4, 0x8e, 0xee, 0xe3,
            0x14, 0xa7, 0xcc, 0x8a, 0xb9, 0x32, 0x16, 0x45, 0x48, 0xe5, 0x26, 0xae, 0x90, 0x22,
            0x43, 0x68, 0x51, 0x7a, 0xcf, 0xea, 0xbd, 0x6b, 0xb3, 0x73, 0x2b, 0xc0, 0xe9, 0xda,
            0x99, 0x83, 0x2b, 0x61, 0xca, 0x01, 0xb6, 0xde, 0x56, 0x24, 0x4a, 0x9e, 0x88, 0xd5,
            0xf9, 0xb3, 0x79, 0x73, 0xf6, 0x22, 0xa4, 0x3d, 0x14, 0xa6, 0x59, 0x9b, 0x1f, 0x65,
            0x4c, 0xb4, 0x5a, 0x74, 0xe3, 0x55, 0xa5,
        ];
        let c = seal(&m, &nonce, &firstkey);
        assert!(c == c_expected);
        let m2 = open(&c, &nonce, &firstkey);
        assert!(Ok(m) == m2);
    }

    #[cfg(feature = "serde")]
    #[test]
    fn test_serialisation() {
        use test_utils::round_trip;
        for _ in 0..256usize {
            let k = gen_key();
            let n = gen_nonce();
            round_trip(k);
            round_trip(n);
        }
    }
}

#[cfg(feature = "benchmarks")]
#[cfg(test)]
mod bench {
    extern crate test;
    use super::*;
    use randombytes::randombytes;

    const BENCH_SIZES: [usize; 14] = [0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096];

    #[bench]
    fn bench_seal_open(b: &mut test::Bencher) {
        let k = gen_key();
        let n = gen_nonce();
        let ms: Vec<Vec<u8>> = BENCH_SIZES.iter().map(|s| randombytes(*s)).collect();
        b.iter(|| {
            for m in ms.iter() {
                open(&seal(&m, &n, &k), &n, &k).unwrap();
            }
        });
    }
}

'''
'''--- src/crypto/shorthash/mod.rs ---
//! A lot of applications and programming language implementations have been
//! recently found to be vulnerable to denial-of-service attacks when a hash
//! function with weak security guarantees, like Murmurhash 3, was used to
//! construct a hash table.
//!
//! In order to address this, Sodium provides the `shorthash()` function.
//! This very fast hash functions outputs short, but unpredictable
//! (without knowing the secret key) values suitable for picking a list in
//! a hash table for a given key.
//!
//! # Selected primitive
//! `shorthash()` is currently an implementation of `SipHash-2-4` as specified in
//! [SipHash: a fast short-input PRF](https://131002.net/siphash/)
//!
//! # Example
//! ```
//! use exonum_sodiumoxide::crypto::shorthash;
//!
//! let key = shorthash::gen_key();
//! let data_to_hash = b"some data";
//! let digest = shorthash::shorthash(data_to_hash, &key);
//! ```
pub use self::siphash24::*;
pub mod siphash24;

'''
'''--- src/crypto/shorthash/siphash24.rs ---
//! `SipHash-2-4`
use ffi;
use libc::c_ulonglong;
use randombytes::randombytes_into;

/// Number of bytes in a `Digest`.
pub const DIGESTBYTES: usize = ffi::crypto_shorthash_siphash24_BYTES;

/// Number of bytes in a `Key`.
pub const KEYBYTES: usize = ffi::crypto_shorthash_siphash24_KEYBYTES;

new_type! {
    /// `Digest` structure
    public Digest(DIGESTBYTES);
}

new_type! {
    /// `Key`
    ///
    /// When a `Key` goes out of scope its contents will be zeroed out.
    secret Key(KEYBYTES);
}

/// `gen_key()` randomly generates a key for shorthash
///
/// THREAD SAFETY: `gen_key()` is thread-safe provided that you have
/// called `sodiumoxide::init()` once before using any other function
/// from sodiumoxide.
pub fn gen_key() -> Key {
    let mut k = [0; KEYBYTES];
    randombytes_into(&mut k);
    Key(k)
}

/// `shorthash` hashes a message `m` under a key `k`. It
/// returns a hash `h`.
pub fn shorthash(m: &[u8], &Key(ref k): &Key) -> Digest {
    unsafe {
        let mut h = [0; DIGESTBYTES];
        ffi::crypto_shorthash_siphash24(&mut h, m.as_ptr(), m.len() as c_ulonglong, k);
        Digest(h)
    }
}

#[cfg(test)]
mod test {
    use super::*;
    #[cfg(not(feature = "std"))]
    use prelude::*;

    #[test]
    fn test_vectors() {
        let maxlen = 64;
        let mut m = Vec::with_capacity(64);
        for i in 0usize..64 {
            m.push(i as u8);
        }
        let h_expecteds = [
            [0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72],
            [0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74],
            [0x5a, 0x4f, 0xa9, 0xd9, 0x09, 0x80, 0x6c, 0x0d],
            [0x2d, 0x7e, 0xfb, 0xd7, 0x96, 0x66, 0x67, 0x85],
            [0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf],
            [0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18],
            [0xce, 0xe3, 0xfe, 0x58, 0x6e, 0x46, 0xc9, 0xcb],
            [0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab],
            [0x62, 0x24, 0x93, 0x9a, 0x79, 0xf5, 0xf5, 0x93],
            [0xb0, 0xe4, 0xa9, 0x0b, 0xdf, 0x82, 0x00, 0x9e],
            [0xf3, 0xb9, 0xdd, 0x94, 0xc5, 0xbb, 0x5d, 0x7a],
            [0xa7, 0xad, 0x6b, 0x22, 0x46, 0x2f, 0xb3, 0xf4],
            [0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75],
            [0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14],
            [0xee, 0xf2, 0x7a, 0x8e, 0x90, 0xca, 0x23, 0xf7],
            [0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1],
            [0xdb, 0x9b, 0xc2, 0x57, 0x7f, 0xcc, 0x2a, 0x3f],
            [0x94, 0x47, 0xbe, 0x2c, 0xf5, 0xe9, 0x9a, 0x69],
            [0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b],
            [0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb],
            [0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe],
            [0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0],
            [0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93],
            [0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8],
            [0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8],
            [0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc],
            [0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17],
            [0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f],
            [0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde],
            [0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6],
            [0x28, 0xef, 0x49, 0x5c, 0x53, 0xa3, 0x87, 0xad],
            [0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32],
            [0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71],
            [0xe3, 0x78, 0x59, 0xf9, 0x46, 0x23, 0xf3, 0xa7],
            [0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12],
            [0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15],
            [0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31],
            [0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02],
            [0x4d, 0x0c, 0xf4, 0x9e, 0xe5, 0xd4, 0xdc, 0xca],
            [0x5c, 0x73, 0x33, 0x6a, 0x76, 0xd8, 0xbf, 0x9a],
            [0xd0, 0xa7, 0x04, 0x53, 0x6b, 0xa9, 0x3e, 0x0e],
            [0x92, 0x59, 0x58, 0xfc, 0xd6, 0x42, 0x0c, 0xad],
            [0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18],
            [0x95, 0x2b, 0x79, 0xf3, 0xbc, 0x0a, 0xa6, 0xd4],
            [0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9],
            [0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9],
            [0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb],
            [0xeb, 0x75, 0x09, 0x5c, 0xcd, 0x98, 0x6c, 0xd0],
            [0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6],
            [0x96, 0xaf, 0xad, 0xfc, 0x2c, 0xe6, 0x66, 0xc7],
            [0x72, 0xfe, 0x52, 0x97, 0x5a, 0x43, 0x64, 0xee],
            [0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1],
            [0xb2, 0x74, 0xcb, 0x8e, 0xbf, 0x87, 0x87, 0x0a],
            [0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81],
            [0xea, 0xec, 0xb2, 0xa3, 0x0b, 0x22, 0xa8, 0x7f],
            [0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24],
            [0xbd, 0x83, 0x8d, 0x3a, 0xaf, 0xbf, 0x8d, 0xb7],
            [0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea],
            [0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60],
            [0x93, 0x2b, 0x28, 0x46, 0xe4, 0xd7, 0x06, 0x66],
            [0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c],
            [0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f],
            [0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5],
            [0x72, 0x45, 0x06, 0xeb, 0x4c, 0x32, 0x8a, 0x95],
        ];
        let k = Key([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);
        for i in 0usize..maxlen {
            let Digest(h) = shorthash(&m[..i], &k);
            assert!(h == h_expecteds[i]);
        }
    }

    #[cfg(feature = "serde")]
    #[test]
    fn test_serialisation() {
        use randombytes::randombytes;
        use test_utils::round_trip;
        for i in 0..64usize {
            let k = gen_key();
            let m = randombytes(i);
            let d = shorthash(&m[..], &k);
            round_trip(k);
            round_trip(d);
        }
    }
}

#[cfg(feature = "benchmarks")]
#[cfg(test)]
mod bench {
    extern crate test;
    use super::*;
    use randombytes::randombytes;

    const BENCH_SIZES: [usize; 14] = [0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096];

    #[bench]
    fn bench_shorthash(b: &mut test::Bencher) {
        let k = gen_key();
        let ms: Vec<Vec<u8>> = BENCH_SIZES.iter().map(|s| randombytes(*s)).collect();
        b.iter(|| {
            for m in ms.iter() {
                shorthash(m, &k);
            }
        });
    }
}

'''
'''--- src/crypto/sign/ed25519.rs ---
//! `ed25519`, a signature scheme specified in
//! [Ed25519](http://ed25519.cr.yp.to/). This function is conjectured to meet the
//! standard notion of unforgeability for a public-key signature scheme under
//! chosen-message attacks.
use ffi;
use libc::c_ulonglong;
#[cfg(not(feature = "std"))]
use prelude::*;
use std::fmt;
use std::iter::repeat;
use std::mem;

/// Number of bytes in a `Seed`.
pub const SEEDBYTES: usize = ffi::crypto_sign_ed25519_SEEDBYTES;

/// Number of bytes in a `SecretKey`.
pub const SECRETKEYBYTES: usize = ffi::crypto_sign_ed25519_SECRETKEYBYTES;

/// Number of bytes in a `PublicKey`.
pub const PUBLICKEYBYTES: usize = ffi::crypto_sign_ed25519_PUBLICKEYBYTES;

/// Number of bytes in a `Signature`.
pub const SIGNATUREBYTES: usize = ffi::crypto_sign_ed25519_BYTES;

/// Number of bytes in a Curve25519 key.
pub const SCALARMULTBYTES: usize = ffi::crypto_scalarmult_curve25519_BYTES;

new_type! {
    /// `Seed` that can be used for keypair generation
    ///
    /// The `Seed` is used by `keypair_from_seed()` to generate
    /// a secret and public signature key.
    ///
    /// When a `Seed` goes out of scope its contents
    /// will be zeroed out
    secret Seed(SEEDBYTES);
}

new_type! {
    /// `SecretKey` for signatures
    ///
    /// When a `SecretKey` goes out of scope its contents
    /// will be zeroed out
    secret SecretKey(SECRETKEYBYTES);
}

new_type! {
    /// `PublicKey` for signatures
    public PublicKey(PUBLICKEYBYTES);
}

new_type! {
    /// Detached signature
    public Signature(SIGNATUREBYTES);
}

/// `gen_keypair()` randomly generates a secret key and a corresponding public
/// key.
///
/// THREAD SAFETY: `gen_keypair()` is thread-safe provided that you have
/// called `sodiumoxide::init()` once before using any other function
/// from sodiumoxide.
pub fn gen_keypair() -> (PublicKey, SecretKey) {
    unsafe {
        let mut pk = [0u8; PUBLICKEYBYTES];
        let mut sk = [0u8; SECRETKEYBYTES];
        ffi::crypto_sign_ed25519_keypair(&mut pk, &mut sk);
        (PublicKey(pk), SecretKey(sk))
    }
}

/// `keypair_from_seed()` computes a secret key and a corresponding public key
/// from a `Seed`.
pub fn keypair_from_seed(&Seed(ref seed): &Seed) -> (PublicKey, SecretKey) {
    unsafe {
        let mut pk = [0u8; PUBLICKEYBYTES];
        let mut sk = [0u8; SECRETKEYBYTES];
        ffi::crypto_sign_ed25519_seed_keypair(&mut pk, &mut sk, seed);
        (PublicKey(pk), SecretKey(sk))
    }
}

/// `sign()` signs a message `m` using the signer's secret key `sk`.
/// `sign()` returns the resulting signed message `sm`.
pub fn sign(m: &[u8], &SecretKey(ref sk): &SecretKey) -> Vec<u8> {
    unsafe {
        let mut sm: Vec<u8> = repeat(0u8).take(m.len() + SIGNATUREBYTES).collect();
        let mut smlen = 0;
        ffi::crypto_sign_ed25519(
            sm.as_mut_ptr(),
            &mut smlen,
            m.as_ptr(),
            m.len() as c_ulonglong,
            sk,
        );
        sm.truncate(smlen as usize);
        sm
    }
}

/// `verify()` verifies the signature in `sm` using the signer's public key `pk`.
/// `verify()` returns the message `Ok(m)`.
/// If the signature fails verification, `verify()` returns `Err(())`.
pub fn verify(sm: &[u8], &PublicKey(ref pk): &PublicKey) -> Result<Vec<u8>, ()> {
    unsafe {
        let mut m: Vec<u8> = repeat(0u8).take(sm.len()).collect();
        let mut mlen = 0;
        if ffi::crypto_sign_ed25519_open(
            m.as_mut_ptr(),
            &mut mlen,
            sm.as_ptr(),
            sm.len() as c_ulonglong,
            pk,
        ) == 0
        {
            m.truncate(mlen as usize);
            Ok(m)
        } else {
            Err(())
        }
    }
}

/// `sign_detached()` signs a message `m` using the signer's secret key `sk`.
/// `sign_detached()` returns the resulting signature `sig`.
pub fn sign_detached(m: &[u8], &SecretKey(ref sk): &SecretKey) -> Signature {
    unsafe {
        let mut sig = [0u8; SIGNATUREBYTES];
        let mut siglen: c_ulonglong = 0;
        ffi::crypto_sign_ed25519_detached(
            &mut sig,
            &mut siglen,
            m.as_ptr(),
            m.len() as c_ulonglong,
            sk,
        );
        assert_eq!(siglen, SIGNATUREBYTES as c_ulonglong);
        Signature(sig)
    }
}

/// `verify_detached()` verifies the signature in `sig` against the message `m`
/// and the signer's public key `pk`.
/// `verify_detached()` returns true if the signature is valid, false otherwise.
pub fn verify_detached(
    &Signature(ref sig): &Signature,
    m: &[u8],
    &PublicKey(ref pk): &PublicKey,
) -> bool {
    unsafe {
        0 == ffi::crypto_sign_ed25519_verify_detached(sig, m.as_ptr(), m.len() as c_ulonglong, pk)
    }
}

/// Convert Ed25519 public key to Curve25519 public key.
pub fn convert_ed_pk_to_curve25519(pk: &[u8; SCALARMULTBYTES]) -> [u8; SCALARMULTBYTES] {
    let mut curve_pk = [0; SCALARMULTBYTES];
    unsafe { ffi::crypto_sign_ed25519_pk_to_curve25519(&mut curve_pk, pk) }
    curve_pk
}

/// Convert Ed25519 secret key to Curve25519 secret key.
pub fn convert_ed_sk_to_curve25519(sk: &[u8; SCALARMULTBYTES]) -> [u8; SCALARMULTBYTES] {
    let mut curve_sk = [0; SCALARMULTBYTES];
    unsafe { ffi::crypto_sign_ed25519_sk_to_curve25519(&mut curve_sk, sk) }
    curve_sk
}

/// Converts Ed25519 keypair to Curve25519 keypair.
pub fn convert_ed_keypair_to_curve25519(pk: PublicKey, sk: SecretKey) -> (PublicKey, SecretKey) {
    let pk = convert_ed_pk_to_curve25519(&pk.0);

    let mut secret_key = [0; SCALARMULTBYTES];
    secret_key.clone_from_slice(&sk[..SCALARMULTBYTES]);
    let sk = convert_ed_sk_to_curve25519(&secret_key);

    let mut secret_key = [0; SECRETKEYBYTES];
    secret_key.clone_from_slice(&[sk, pk].concat());

    (PublicKey(pk), SecretKey(secret_key))
}

/// State for multi-part (streaming) computation of signature.
#[derive(Clone)]
pub struct State(ffi::crypto_sign_ed25519ph_state);

impl State {
    /// `init()` initialize a streaming signing state.
    pub fn init() -> State {
        unsafe {
            let mut s = mem::uninitialized();
            ffi::crypto_sign_ed25519ph_init(&mut s);
            State(s)
        }
    }

    /// `update()` can be called more than once in order to compute the digest
    /// from sequential chunks of the message.
    pub fn update(&mut self, m: &[u8]) {
        unsafe {
            ffi::crypto_sign_ed25519ph_update(&mut self.0, m.as_ptr(), m.len() as c_ulonglong);
        }
    }

    /// `finalize()` finalizes the hashing computation and returns a `Signature`.
    // Moves self becuase libsodium says the state should not be used
    // anymore after final().
    pub fn finalize(&mut self, &SecretKey(ref sk): &SecretKey) -> Signature {
        unsafe {
            let sig = [0u8; SIGNATUREBYTES];
            let mut siglen: c_ulonglong = 0;

            ffi::crypto_sign_ed25519ph_final_create(&mut self.0, sig.as_ptr(), &mut siglen, sk);
            assert_eq!(siglen, SIGNATUREBYTES as c_ulonglong);
            Signature(sig)
        }
    }

    /// `veriry` verifies the signature in `sm` using the signer's public key `pk`.
    pub fn verify(
        &mut self,
        &Signature(ref sig): &Signature,
        &PublicKey(ref pk): &PublicKey,
    ) -> bool {
        unsafe { 0 == ffi::crypto_sign_ed25519ph_final_verify(&mut self.0, sig.as_ptr(), pk) }
    }
}

impl fmt::Debug for State {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "ed25519 state")
    }
}

// Impl Default becuase `State` does have a sensible default: State::init()
impl Default for State {
    fn default() -> State {
        State::init()
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_streaming_sign() {
        use randombytes::randombytes;
        for i in 0..256usize {
            let (pk, sk) = gen_keypair();
            let m = randombytes(i);
            let mut creation_state = State::init();
            creation_state.update(&m);
            let sig = creation_state.finalize(&sk);
            let mut validator_state = State::init();
            validator_state.update(&m);
            assert!(validator_state.verify(&sig, &pk));
        }
    }

    #[test]
    fn test_chunks_sign() {
        use randombytes::randombytes;
        let (pk, sk) = gen_keypair();
        let mut creation_state = State::init();
        let mut validator_state = State::init();
        for i in 0..64usize {
            let chunk = randombytes(i);
            creation_state.update(&chunk);
            validator_state.update(&chunk);
        }
        let sig = creation_state.finalize(&sk);
        assert!(validator_state.verify(&sig, &pk));
    }

    #[test]
    fn test_sign_verify() {
        use randombytes::randombytes;
        for i in 0..256usize {
            let (pk, sk) = gen_keypair();
            let m = randombytes(i);
            let sm = sign(&m, &sk);
            let m2 = verify(&sm, &pk);
            assert!(Ok(m) == m2);
        }
    }

    #[test]
    fn test_sign_verify_tamper() {
        use randombytes::randombytes;
        for i in 0..32usize {
            let (pk, sk) = gen_keypair();
            let m = randombytes(i);
            let mut sm = sign(&m, &sk);
            for j in 0..sm.len() {
                sm[j] ^= 0x20;
                assert!(Err(()) == verify(&mut sm, &pk));
                sm[j] ^= 0x20;
            }
        }
    }

    #[test]
    fn test_sign_verify_detached() {
        use randombytes::randombytes;
        for i in 0..256usize {
            let (pk, sk) = gen_keypair();
            let m = randombytes(i);
            let sig = sign_detached(&m, &sk);
            assert!(verify_detached(&sig, &m, &pk));
        }
    }

    #[test]
    fn test_sign_verify_detached_tamper() {
        use randombytes::randombytes;
        for i in 0..32usize {
            let (pk, sk) = gen_keypair();
            let m = randombytes(i);
            let Signature(mut sig) = sign_detached(&m, &sk);
            for j in 0..SIGNATUREBYTES {
                sig[j] ^= 0x20;
                assert!(!verify_detached(&Signature(sig), &m, &pk));
                sig[j] ^= 0x20;
            }
        }
    }

    #[test]
    fn test_sign_verify_seed() {
        use randombytes::{randombytes, randombytes_into};
        for i in 0..256usize {
            let mut seedbuf = [0; 32];
            randombytes_into(&mut seedbuf);
            let seed = Seed(seedbuf);
            let (pk, sk) = keypair_from_seed(&seed);
            let m = randombytes(i);
            let sm = sign(&m, &sk);
            let m2 = verify(&sm, &pk);
            assert!(Ok(m) == m2);
        }
    }

    #[test]
    fn test_sign_verify_tamper_seed() {
        use randombytes::{randombytes, randombytes_into};
        for i in 0..32usize {
            let mut seedbuf = [0; 32];
            randombytes_into(&mut seedbuf);
            let seed = Seed(seedbuf);
            let (pk, sk) = keypair_from_seed(&seed);
            let m = randombytes(i);
            let mut sm = sign(&m, &sk);
            for j in 0..sm.len() {
                sm[j] ^= 0x20;
                assert!(Err(()) == verify(&mut sm, &pk));
                sm[j] ^= 0x20;
            }
        }
    }

    #[test]
    fn test_vectors() {
        // test vectors from the Python implementation
        // from the [Ed25519 Homepage](http://ed25519.cr.yp.to/software.html)
        use rustc_serialize::hex::{FromHex, ToHex};
        use std::fs::File;
        use std::io::{BufRead, BufReader};

        let r = BufReader::new(File::open("testvectors/ed25519.input").unwrap());
        for mline in r.lines() {
            let line = mline.unwrap();
            let mut x = line.split(':');
            let x0 = x.next().unwrap();
            let x1 = x.next().unwrap();
            let x2 = x.next().unwrap();
            let x3 = x.next().unwrap();
            let seed_bytes = x0[..64].from_hex().unwrap();
            assert!(seed_bytes.len() == SEEDBYTES);
            let mut seedbuf = [0u8; SEEDBYTES];
            for (s, b) in seedbuf.iter_mut().zip(seed_bytes.iter()) {
                *s = *b
            }
            let seed = Seed(seedbuf);
            let (pk, sk) = keypair_from_seed(&seed);
            let m = x2.from_hex().unwrap();
            let sm = sign(&m, &sk);
            verify(&sm, &pk).unwrap();
            assert!(x1 == pk[..].to_hex());
            assert!(x3 == sm.to_hex());
        }
    }

    #[test]
    fn test_vectors_detached() {
        // test vectors from the Python implementation
        // from the [Ed25519 Homepage](http://ed25519.cr.yp.to/software.html)
        use rustc_serialize::hex::{FromHex, ToHex};
        use std::fs::File;
        use std::io::{BufRead, BufReader};

        let r = BufReader::new(File::open("testvectors/ed25519.input").unwrap());
        for mline in r.lines() {
            let line = mline.unwrap();
            let mut x = line.split(':');
            let x0 = x.next().unwrap();
            let x1 = x.next().unwrap();
            let x2 = x.next().unwrap();
            let x3 = x.next().unwrap();
            let seed_bytes = x0[..64].from_hex().unwrap();
            assert!(seed_bytes.len() == SEEDBYTES);
            let mut seedbuf = [0u8; SEEDBYTES];
            for (s, b) in seedbuf.iter_mut().zip(seed_bytes.iter()) {
                *s = *b
            }
            let seed = Seed(seedbuf);
            let (pk, sk) = keypair_from_seed(&seed);
            let m = x2.from_hex().unwrap();
            let sig = sign_detached(&m, &sk);
            assert!(verify_detached(&sig, &m, &pk));
            assert!(x1 == pk[..].to_hex());
            let sm = sig[..].to_hex() + x2; // x2 is m hex encoded
            assert!(x3 == sm);
        }
    }

    #[cfg(feature = "serde")]
    #[test]
    fn test_serialisation() {
        use randombytes::randombytes;
        use test_utils::round_trip;
        for i in 0..256usize {
            let (pk, sk) = gen_keypair();
            let m = randombytes(i);
            let sig = sign_detached(&m, &sk);
            round_trip(pk);
            round_trip(sk);
            round_trip(sig);
        }
    }

    #[test]
    fn test_crypto_sign_ed25519_to_curve25519() {
        use crypto::scalarmult::curve25519::{scalarmult_base, GroupElement, Scalar};

        let (pk, sk) = gen_keypair();
        let (PublicKey(ref pk), SecretKey(ref sk)) = convert_ed_keypair_to_curve25519(pk, sk);

        let secret_key = Scalar::from_slice(&sk[..SCALARMULTBYTES]).unwrap();
        let GroupElement(public_key) = scalarmult_base(&secret_key);

        assert_eq!(pk, &public_key);
    }
}

#[cfg(feature = "benchmarks")]
#[cfg(test)]
mod bench {
    extern crate test;
    use super::*;
    use randombytes::randombytes;

    const BENCH_SIZES: [usize; 14] = [0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096];

    #[bench]
    fn bench_sign(b: &mut test::Bencher) {
        let (_, sk) = gen_keypair();
        let ms: Vec<Vec<u8>> = BENCH_SIZES.iter().map(|s| randombytes(*s)).collect();
        b.iter(|| {
            for m in ms.iter() {
                sign(m, &sk);
            }
        });
    }

    #[bench]
    fn bench_verify(b: &mut test::Bencher) {
        let (pk, sk) = gen_keypair();
        let sms: Vec<Vec<u8>> = BENCH_SIZES
            .iter()
            .map(|s| {
                let m = randombytes(*s);
                sign(&m, &sk)
            })
            .collect();
        b.iter(|| {
            for sm in sms.iter() {
                verify(sm, &pk);
            }
        });
    }
}

'''
'''--- src/crypto/sign/mod.rs ---
//! Public-key signatures
//!
//! # Security model
//! The `sign()` function is designed to meet the standard
//! notion of unforgeability for a public-key signature scheme under
//! chosen-message attacks.
//!
//! # Selected primitive
//! `crypto::sign::sign` is `ed25519`, a signature scheme specified in
//! [Ed25519](http://ed25519.cr.yp.to/). This function is conjectured to meet the
//! standard notion of unforgeability for a public-key signature scheme under
//! chosen-message attacks.
//!
//! # Alternate primitives
//!
//! --------------------------------------------------------------------------------
//! |crypto_sign                         | PUBLICKEYBYTES | SECRETKEYBYTES | BYTES |
//! |------------------------------------|----------------|----------------|-------|
//! |crypto_sign_ed25519                 | 32             | 64             | 64    |
//! |crypto_sign_edwards25519sha512batch | 32             | 64             | 64    |
//! --------------------------------------------------------------------------------
//!
//! crypto_sign_edwards25519sha512batch is a prototype. It has been replaced with
//! Ed25519 and is only kept here for compatibility reasons.
//!
//! # Example
//! ```
//! use exonum_sodiumoxide::crypto::sign;
//! let (pk, sk) = sign::gen_keypair();
//! let data_to_sign = b"some data";
//! let signed_data = sign::sign(data_to_sign, &sk);
//! let verified_data = sign::verify(&signed_data, &pk).unwrap();
//! assert!(data_to_sign == &verified_data[..]);
//! ```
//!
//! # Example (detached signatures)
//! ```
//! use exonum_sodiumoxide::crypto::sign;
//! let (pk, sk) = sign::gen_keypair();
//! let data_to_sign = b"some data";
//! let signature = sign::sign_detached(data_to_sign, &sk);
//! assert!(sign::verify_detached(&signature, data_to_sign, &pk));
//! ```
pub use self::ed25519::*;
pub mod ed25519;

'''
'''--- src/crypto/stream/chacha20.rs ---
//! `crypto_stream_chacha20` (Chacha20)
use ffi::{crypto_stream_chacha20, crypto_stream_chacha20_KEYBYTES,
          crypto_stream_chacha20_NONCEBYTES, crypto_stream_chacha20_xor};

stream_module!(
    crypto_stream_chacha20,
    crypto_stream_chacha20_xor,
    crypto_stream_chacha20_KEYBYTES,
    crypto_stream_chacha20_NONCEBYTES
);

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_vector_1() {
        // the fifth test from https://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-04#section-7
        let key = Key([
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
            0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,
            0x1c, 0x1d, 0x1e, 0x1f,
        ]);
        let nonce = Nonce([0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07]);
        let expected = [
            0xf7, 0x98, 0xa1, 0x89, 0xf1, 0x95, 0xe6, 0x69, 0x82, 0x10, 0x5f, 0xfb, 0x64, 0x0b,
            0xb7, 0x75, 0x7f, 0x57, 0x9d, 0xa3, 0x16, 0x02, 0xfc, 0x93, 0xec, 0x01, 0xac, 0x56,
            0xf8, 0x5a, 0xc3, 0xc1, 0x34, 0xa4, 0x54, 0x7b, 0x73, 0x3b, 0x46, 0x41, 0x30, 0x42,
            0xc9, 0x44, 0x00, 0x49, 0x17, 0x69, 0x05, 0xd3, 0xbe, 0x59, 0xea, 0x1c, 0x53, 0xf1,
            0x59, 0x16, 0x15, 0x5c, 0x2b, 0xe8, 0x24, 0x1a, 0x38, 0x00, 0x8b, 0x9a, 0x26, 0xbc,
            0x35, 0x94, 0x1e, 0x24, 0x44, 0x17, 0x7c, 0x8a, 0xde, 0x66, 0x89, 0xde, 0x95, 0x26,
            0x49, 0x86, 0xd9, 0x58, 0x89, 0xfb, 0x60, 0xe8, 0x46, 0x29, 0xc9, 0xbd, 0x9a, 0x5a,
            0xcb, 0x1c, 0xc1, 0x18, 0xbe, 0x56, 0x3e, 0xb9, 0xb3, 0xa4, 0xa4, 0x72, 0xf8, 0x2e,
            0x09, 0xa7, 0xe7, 0x78, 0x49, 0x2b, 0x56, 0x2e, 0xf7, 0x13, 0x0e, 0x88, 0xdf, 0xe0,
            0x31, 0xc7, 0x9d, 0xb9, 0xd4, 0xf7, 0xc7, 0xa8, 0x99, 0x15, 0x1b, 0x9a, 0x47, 0x50,
            0x32, 0xb6, 0x3f, 0xc3, 0x85, 0x24, 0x5f, 0xe0, 0x54, 0xe3, 0xdd, 0x5a, 0x97, 0xa5,
            0xf5, 0x76, 0xfe, 0x06, 0x40, 0x25, 0xd3, 0xce, 0x04, 0x2c, 0x56, 0x6a, 0xb2, 0xc5,
            0x07, 0xb1, 0x38, 0xdb, 0x85, 0x3e, 0x3d, 0x69, 0x59, 0x66, 0x09, 0x96, 0x54, 0x6c,
            0xc9, 0xc4, 0xa6, 0xea, 0xfd, 0xc7, 0x77, 0xc0, 0x40, 0xd7, 0x0e, 0xaf, 0x46, 0xf7,
            0x6d, 0xad, 0x39, 0x79, 0xe5, 0xc5, 0x36, 0x0c, 0x33, 0x17, 0x16, 0x6a, 0x1c, 0x89,
            0x4c, 0x94, 0xa3, 0x71, 0x87, 0x6a, 0x94, 0xdf, 0x76, 0x28, 0xfe, 0x4e, 0xaa, 0xf2,
            0xcc, 0xb2, 0x7d, 0x5a, 0xaa, 0xe0, 0xad, 0x7a, 0xd0, 0xf9, 0xd4, 0xb6, 0xad, 0x3b,
            0x54, 0x09, 0x87, 0x46, 0xd4, 0x52, 0x4d, 0x38, 0x40, 0x7a, 0x6d, 0xeb, 0x3a, 0xb7,
            0x8f, 0xab, 0x78, 0xc9,
        ];
        let output = stream(expected.len(), &nonce, &key);
        assert!(output[..] == expected[..]);
    }
}

'''
'''--- src/crypto/stream/mod.rs ---
//! Secret-key encryption
//!
//! # Security Model
//! The `stream()` function, viewed as a function of the nonce for a
//! uniform random key, is designed to meet the standard notion of
//! unpredictability ("PRF"). For a formal definition see, e.g., Section 2.3
//! of Bellare, Kilian, and Rogaway, "The security of the cipher block
//! chaining message authentication code," Journal of Computer and System
//! Sciences 61 (2000), 362399;
//! http://www-cse.ucsd.edu/~mihir/papers/cbc.html.
//!
//! This means that an attacker cannot distinguish this function from a
//! uniform random function. Consequently, if a series of messages is
//! encrypted by `stream_xor()` with a different nonce for each message,
//! the ciphertexts are indistinguishable from uniform random strings of the
//! same length.
//!
//! Note that the length is not hidden. Note also that it is the caller's
//! responsibility to ensure the uniqueness of noncesfor example, by using
//! nonce 1 for the first message, nonce 2 for the second message, etc.
//! Nonces are long enough that randomly generated nonces have negligible
//! risk of collision.
//!
//! NaCl does not make any promises regarding the resistance of `stream()` to
//! "related-key attacks." It is the caller's responsibility to use proper
//! key-derivation functions.
//!
//! # Selected primitive
//! `stream()` is `crypto_stream_xsalsa20`, a particular cipher specified in
//! [Cryptography in NaCl](http://nacl.cr.yp.to/valid.html), Section 7.
//! This cipher is conjectured to meet the standard notion of
//! unpredictability.
//!
//! # Alternate primitives
//! NaCl supports the following secret-key encryption functions:
//!
//! ------------------------------------------------------------
//! |crypto_stream           |primitive   |KEYBYTES |NONCEBYTES|
//! |------------------------|------------|---------|----------|
//! |crypto_stream_chacha20  |Chacha20/20 |32       |8         |
//! |crypto_stream_salsa208  |Salsa20/8   |32       |8         |
//! |crypto_stream_salsa2012 |Salsa20/12  |32       |8         |
//! |crypto_stream_salsa20   |Salsa20/20  |32       |8         |
//! |crypto_stream_xsalsa20  |XSalsa20/20 |32       |24        |
//! ------------------------------------------------------------
//!
//! Beware that several of these primitives have 8-byte nonces. For those
//! primitives it is no longer true that randomly generated nonces have negligible
//! risk of collision. Callers who are unable to count 1, 2, 3..., and who insist
//! on using these primitives, are advised to use a randomly derived key for each
//! message.
//!
//! # Example (keystream generation)
//! ```
//! use exonum_sodiumoxide::crypto::stream;
//!
//! let key = stream::gen_key();
//! let nonce = stream::gen_nonce();
//! let keystream = stream::stream(128, &nonce, &key); // generate 128 bytes of keystream
//! ```
//!
//! # Example (encryption)
//! ```
//! use exonum_sodiumoxide::crypto::stream;
//!
//! let key = stream::gen_key();
//! let nonce = stream::gen_nonce();
//! let plaintext = b"some data";
//! let ciphertext = stream::stream_xor(plaintext, &nonce, &key);
//! let their_plaintext = stream::stream_xor(&ciphertext, &nonce, &key);
//! assert_eq!(plaintext, &their_plaintext[..]);
//! ```
//!
//! # Example (in place encryption)
//! ```
//! use exonum_sodiumoxide::crypto::stream;
//!
//! let key = stream::gen_key();
//! let nonce = stream::gen_nonce();
//! let plaintext = &mut [0, 1, 2, 3];
//! // encrypt the plaintext
//! stream::stream_xor_inplace(plaintext, &nonce, &key);
//! // decrypt the plaintext
//! stream::stream_xor_inplace(plaintext, &nonce, &key);
//! assert_eq!(plaintext, &mut [0, 1, 2, 3]);
//! ```
pub use self::xsalsa20::*;
#[macro_use]
mod stream_macros;
pub mod chacha20;
pub mod salsa20;
pub mod salsa2012;
pub mod salsa208;
pub mod xsalsa20;

'''
'''--- src/crypto/stream/salsa20.rs ---
//! `crypto_stream_salsa20` (Salsa20/20), a particular cipher specified in
//! [Cryptography in NaCl](http://nacl.cr.yp.to/valid.html), Section 7.  This
//! cipher is conjectured to meet the standard notion of unpredictability.
use ffi::{crypto_stream_salsa20, crypto_stream_salsa20_KEYBYTES, crypto_stream_salsa20_NONCEBYTES,
          crypto_stream_salsa20_xor};

stream_module!(
    crypto_stream_salsa20,
    crypto_stream_salsa20_xor,
    crypto_stream_salsa20_KEYBYTES,
    crypto_stream_salsa20_NONCEBYTES
);

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_vector_1() {
        // corresponding to tests/stream2.c and tests/stream6.cpp from NaCl
        use crypto::hash::sha256::{hash, Digest};
        let secondkey = Key([
            0xdc, 0x90, 0x8d, 0xda, 0x0b, 0x93, 0x44, 0xa9, 0x53, 0x62, 0x9b, 0x73, 0x38, 0x20,
            0x77, 0x88, 0x80, 0xf3, 0xce, 0xb4, 0x21, 0xbb, 0x61, 0xb9, 0x1c, 0xbd, 0x4c, 0x3e,
            0x66, 0x25, 0x6c, 0xe4,
        ]);
        let noncesuffix = Nonce([0x82, 0x19, 0xe0, 0x03, 0x6b, 0x7a, 0x0b, 0x37]);
        let output = stream(4194304, &noncesuffix, &secondkey);
        let digest_expected = [
            0x66, 0x2b, 0x9d, 0x0e, 0x34, 0x63, 0x02, 0x91, 0x56, 0x06, 0x9b, 0x12, 0xf9, 0x18,
            0x69, 0x1a, 0x98, 0xf7, 0xdf, 0xb2, 0xca, 0x03, 0x93, 0xc9, 0x6b, 0xbf, 0xc6, 0xb1,
            0xfb, 0xd6, 0x30, 0xa2,
        ];
        let Digest(digest) = hash(&output);
        assert!(digest == digest_expected);
    }
}

'''
'''--- src/crypto/stream/salsa2012.rs ---
//! `crypto_stream_salsa2012` (Salsa20/12), a particular cipher specified in
//! [Cryptography in NaCl](http://nacl.cr.yp.to/valid.html), Section 7.  This
//! cipher is conjectured to meet the standard notion of unpredictability.
use ffi::{crypto_stream_salsa2012, crypto_stream_salsa2012_KEYBYTES,
          crypto_stream_salsa2012_NONCEBYTES, crypto_stream_salsa2012_xor};

stream_module!(
    crypto_stream_salsa2012,
    crypto_stream_salsa2012_xor,
    crypto_stream_salsa2012_KEYBYTES,
    crypto_stream_salsa2012_NONCEBYTES
);

'''
'''--- src/crypto/stream/salsa208.rs ---
//! `crypto_stream_salsa208` (Salsa20/8), a particular cipher specified in
//! [Cryptography in NaCl](http://nacl.cr.yp.to/valid.html), Section 7.  This
//! cipher is conjectured to meet the standard notion of unpredictability.
use ffi::{crypto_stream_salsa208, crypto_stream_salsa208_KEYBYTES,
          crypto_stream_salsa208_NONCEBYTES, crypto_stream_salsa208_xor};

stream_module!(
    crypto_stream_salsa208,
    crypto_stream_salsa208_xor,
    crypto_stream_salsa208_KEYBYTES,
    crypto_stream_salsa208_NONCEBYTES
);

'''
'''--- src/crypto/stream/stream_macros.rs ---
macro_rules! stream_module (($stream_name:ident,
                             $xor_name:ident,
                             $keybytes:expr,
                             $noncebytes:expr) => (

#[cfg(not(feature = "std"))] use prelude::*;
use libc::c_ulonglong;
use std::iter::repeat;
use randombytes::randombytes_into;

/// Number of bytes in a `Key`.
pub const KEYBYTES: usize = $keybytes;

/// Number of bytes in a `Nonce`.
pub const NONCEBYTES: usize = $noncebytes;

new_type! {
    /// `Key` for symmetric encryption
    ///
    /// When a `Key` goes out of scope its contents
    /// will be zeroed out
    secret Key(KEYBYTES);
}

new_type! {
    /// `Nonce` for symmetric encryption
    nonce Nonce(NONCEBYTES);
}

/// `gen_key()` randomly generates a key for symmetric encryption
///
/// THREAD SAFETY: `gen_key()` is thread-safe provided that you have
/// called `sodiumoxide::init()` once before using any other function
/// from sodiumoxide.
pub fn gen_key() -> Key {
    let mut key = [0; KEYBYTES];
    randombytes_into(&mut key);
    Key(key)
}

/// `gen_nonce()` randomly generates a nonce for symmetric encryption
///
/// THREAD SAFETY: `gen_nonce()` is thread-safe provided that you have
/// called `sodiumoxide::init()` once before using any other function
/// from sodiumoxide.
///
/// NOTE: When using primitives with short nonces (e.g. salsa20, salsa208, salsa2012)
/// do not use random nonces since the probability of nonce-collision is not negligible
pub fn gen_nonce() -> Nonce {
    let mut nonce = [0; NONCEBYTES];
    randombytes_into(&mut nonce);
    Nonce(nonce)
}

/// `stream()` produces a `len`-byte stream `c` as a function of a
/// secret key `k` and a nonce `n`.
pub fn stream(len: usize,
              &Nonce(ref n): &Nonce,
              &Key(ref k): &Key) -> Vec<u8> {
    unsafe {
        let mut c: Vec<u8> = repeat(0u8).take(len).collect();
        $stream_name(c.as_mut_ptr(),
                     c.len() as c_ulonglong,
                     n,
                     k);
        c
    }
}

/// `stream_xor()` encrypts a message `m` using a secret key `k` and a nonce `n`.
/// The `stream_xor()` function returns the ciphertext `c`.
///
/// `stream_xor()` guarantees that the ciphertext has the same length as the plaintext,
/// and is the plaintext xor the output of `stream()`.
/// Consequently `stream_xor()` can also be used to decrypt.
pub fn stream_xor(m: &[u8],
                  &Nonce(ref n): &Nonce,
                  &Key(ref k): &Key) -> Vec<u8> {
    unsafe {
        let mut c: Vec<u8> = repeat(0u8).take(m.len()).collect();
        $xor_name(c.as_mut_ptr(),
                  m.as_ptr(),
                  m.len() as c_ulonglong,
                  n,
                  k);
        c
    }
}

/// `stream_xor_inplace` encrypts a message `m` using a secret key `k` and a nonce `n`.
/// The `stream_xor_inplace()` function encrypts the message in place.
///
/// `stream_xor_inplace()` guarantees that the ciphertext has the same length as
/// the plaintext, and is the plaintext xor the output of `stream_inplace()`.
/// Consequently `stream_xor_inplace()` can also be used to decrypt.
pub fn stream_xor_inplace(m: &mut [u8],
                          &Nonce(ref n): &Nonce,
                          &Key(ref k): &Key) {
    unsafe {
        $xor_name(m.as_mut_ptr(),
                  m.as_ptr(),
                  m.len() as c_ulonglong,
                  n,
                  k);
    }
}

#[cfg(test)]
mod test_m {
    use super::*;

    #[test]
    fn test_encrypt_decrypt() {
        use randombytes::randombytes;
        for i in 0..1024usize {
            let k = gen_key();
            let n = gen_nonce();
            let m = randombytes(i);
            let c = stream_xor(&m, &n, &k);
            let m2 = stream_xor(&c, &n, &k);
            assert!(m == m2);
        }
    }

    #[test]
    fn test_stream_xor() {
        use randombytes::randombytes;
        for i in 0..1024usize {
            let k = gen_key();
            let n = gen_nonce();
            let m = randombytes(i);
            let mut c = m.clone();
            let s = stream(c.len(), &n, &k);
            for (e, v) in c.iter_mut().zip(s.iter()) {
                *e ^= *v;
            }
            let c2 = stream_xor(&m, &n, &k);
            assert!(c == c2);
        }
    }

    #[test]
    fn test_stream_xor_inplace() {
        use randombytes::randombytes;
        for i in 0..1024usize {
            let k = gen_key();
            let n = gen_nonce();
            let mut m = randombytes(i);
            let mut c = m.clone();
            let s = stream(c.len(), &n, &k);
            for (e, v) in c.iter_mut().zip(s.iter()) {
                *e ^= *v;
            }
            stream_xor_inplace(&mut m, &n, &k);
            assert!(c == m);
        }
    }

    #[cfg(feature = "serde")]
    #[test]
    fn test_serialisation() {
        use test_utils::round_trip;
        for _ in 0..1024usize {
            let k = gen_key();
            let n = gen_nonce();
            round_trip(k);
            round_trip(n);
        }
    }
}

#[cfg(feature = "benchmarks")]
#[cfg(test)]
mod bench_m {
    extern crate test;
    use super::*;

    const BENCH_SIZES: [usize; 14] = [0, 1, 2, 4, 8, 16, 32, 64,
                                      128, 256, 512, 1024, 2048, 4096];

    #[bench]
    fn bench_stream(b: &mut test::Bencher) {
        let k = gen_key();
        let n = gen_nonce();
        b.iter(|| {
            for size in BENCH_SIZES.iter() {
                stream(*size, &n, &k);
            }
        });
    }
}

));

'''
'''--- src/crypto/stream/xsalsa20.rs ---
//! `crypto_stream_xsalsa20`, a particular cipher specified in
//! [Cryptography in NaCl](http://nacl.cr.yp.to/valid.html), Section 7.
//! This cipher is conjectured to meet the standard notion of
//! unpredictability.
use ffi::{crypto_stream_xsalsa20, crypto_stream_xsalsa20_KEYBYTES,
          crypto_stream_xsalsa20_NONCEBYTES, crypto_stream_xsalsa20_xor};

stream_module!(
    crypto_stream_xsalsa20,
    crypto_stream_xsalsa20_xor,
    crypto_stream_xsalsa20_KEYBYTES,
    crypto_stream_xsalsa20_NONCEBYTES
);

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_vector_1() {
        // corresponding to tests/stream.c and tests/stream5.cpp from NaCl
        use crypto::hash::sha256::{hash, Digest};
        let firstkey = Key([
            0x1b, 0x27, 0x55, 0x64, 0x73, 0xe9, 0x85, 0xd4, 0x62, 0xcd, 0x51, 0x19, 0x7a, 0x9a,
            0x46, 0xc7, 0x60, 0x09, 0x54, 0x9e, 0xac, 0x64, 0x74, 0xf2, 0x06, 0xc4, 0xee, 0x08,
            0x44, 0xf6, 0x83, 0x89,
        ]);
        let nonce = Nonce([
            0x69, 0x69, 0x6e, 0xe9, 0x55, 0xb6, 0x2b, 0x73, 0xcd, 0x62, 0xbd, 0xa8, 0x75, 0xfc,
            0x73, 0xd6, 0x82, 0x19, 0xe0, 0x03, 0x6b, 0x7a, 0x0b, 0x37,
        ]);
        let output = stream(4194304, &nonce, &firstkey);
        let digest_expected = [
            0x66, 0x2b, 0x9d, 0x0e, 0x34, 0x63, 0x02, 0x91, 0x56, 0x06, 0x9b, 0x12, 0xf9, 0x18,
            0x69, 0x1a, 0x98, 0xf7, 0xdf, 0xb2, 0xca, 0x03, 0x93, 0xc9, 0x6b, 0xbf, 0xc6, 0xb1,
            0xfb, 0xd6, 0x30, 0xa2,
        ];
        let Digest(digest) = hash(&output);
        assert!(digest == digest_expected);
    }

    #[test]
    fn test_vector_2() {
        // corresponding to tests/stream3.c and tests/stream7.cpp from NaCl
        let firstkey = Key([
            0x1b, 0x27, 0x55, 0x64, 0x73, 0xe9, 0x85, 0xd4, 0x62, 0xcd, 0x51, 0x19, 0x7a, 0x9a,
            0x46, 0xc7, 0x60, 0x09, 0x54, 0x9e, 0xac, 0x64, 0x74, 0xf2, 0x06, 0xc4, 0xee, 0x08,
            0x44, 0xf6, 0x83, 0x89,
        ]);
        let nonce = Nonce([
            0x69, 0x69, 0x6e, 0xe9, 0x55, 0xb6, 0x2b, 0x73, 0xcd, 0x62, 0xbd, 0xa8, 0x75, 0xfc,
            0x73, 0xd6, 0x82, 0x19, 0xe0, 0x03, 0x6b, 0x7a, 0x0b, 0x37,
        ]);
        let rs = stream(32, &nonce, &firstkey);
        let rs_expected = vec![
            0xee, 0xa6, 0xa7, 0x25, 0x1c, 0x1e, 0x72, 0x91, 0x6d, 0x11, 0xc2, 0xcb, 0x21, 0x4d,
            0x3c, 0x25, 0x25, 0x39, 0x12, 0x1d, 0x8e, 0x23, 0x4e, 0x65, 0x2d, 0x65, 0x1f, 0xa4,
            0xc8, 0xcf, 0xf8, 0x80,
        ];
        assert!(rs == rs_expected);
    }

    #[test]
    fn test_vector_3() {
        // corresponding to tests/stream4.c and tests/stream8.cpp from NaCl
        let firstkey = Key([
            0x1b, 0x27, 0x55, 0x64, 0x73, 0xe9, 0x85, 0xd4, 0x62, 0xcd, 0x51, 0x19, 0x7a, 0x9a,
            0x46, 0xc7, 0x60, 0x09, 0x54, 0x9e, 0xac, 0x64, 0x74, 0xf2, 0x06, 0xc4, 0xee, 0x08,
            0x44, 0xf6, 0x83, 0x89,
        ]);
        let nonce = Nonce([
            0x69, 0x69, 0x6e, 0xe9, 0x55, 0xb6, 0x2b, 0x73, 0xcd, 0x62, 0xbd, 0xa8, 0x75, 0xfc,
            0x73, 0xd6, 0x82, 0x19, 0xe0, 0x03, 0x6b, 0x7a, 0x0b, 0x37,
        ]);
        let m = &[
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0xbe, 0x07, 0x5f, 0xc5, 0x3c, 0x81, 0xf2, 0xd5, 0xcf, 0x14, 0x13, 0x16, 0xeb,
            0xeb, 0x0c, 0x7b, 0x52, 0x28, 0xc5, 0x2a, 0x4c, 0x62, 0xcb, 0xd4, 0x4b, 0x66, 0x84,
            0x9b, 0x64, 0x24, 0x4f, 0xfc, 0xe5, 0xec, 0xba, 0xaf, 0x33, 0xbd, 0x75, 0x1a, 0x1a,
            0xc7, 0x28, 0xd4, 0x5e, 0x6c, 0x61, 0x29, 0x6c, 0xdc, 0x3c, 0x01, 0x23, 0x35, 0x61,
            0xf4, 0x1d, 0xb6, 0x6c, 0xce, 0x31, 0x4a, 0xdb, 0x31, 0x0e, 0x3b, 0xe8, 0x25, 0x0c,
            0x46, 0xf0, 0x6d, 0xce, 0xea, 0x3a, 0x7f, 0xa1, 0x34, 0x80, 0x57, 0xe2, 0xf6, 0x55,
            0x6a, 0xd6, 0xb1, 0x31, 0x8a, 0x02, 0x4a, 0x83, 0x8f, 0x21, 0xaf, 0x1f, 0xde, 0x04,
            0x89, 0x77, 0xeb, 0x48, 0xf5, 0x9f, 0xfd, 0x49, 0x24, 0xca, 0x1c, 0x60, 0x90, 0x2e,
            0x52, 0xf0, 0xa0, 0x89, 0xbc, 0x76, 0x89, 0x70, 0x40, 0xe0, 0x82, 0xf9, 0x37, 0x76,
            0x38, 0x48, 0x64, 0x5e, 0x07, 0x05,
        ];

        let c = stream_xor(m, &nonce, &firstkey);
        let c_expected = [
            0x8e, 0x99, 0x3b, 0x9f, 0x48, 0x68, 0x12, 0x73, 0xc2, 0x96, 0x50, 0xba, 0x32, 0xfc,
            0x76, 0xce, 0x48, 0x33, 0x2e, 0xa7, 0x16, 0x4d, 0x96, 0xa4, 0x47, 0x6f, 0xb8, 0xc5,
            0x31, 0xa1, 0x18, 0x6a, 0xc0, 0xdf, 0xc1, 0x7c, 0x98, 0xdc, 0xe8, 0x7b, 0x4d, 0xa7,
            0xf0, 0x11, 0xec, 0x48, 0xc9, 0x72, 0x71, 0xd2, 0xc2, 0x0f, 0x9b, 0x92, 0x8f, 0xe2,
            0x27, 0x0d, 0x6f, 0xb8, 0x63, 0xd5, 0x17, 0x38, 0xb4, 0x8e, 0xee, 0xe3, 0x14, 0xa7,
            0xcc, 0x8a, 0xb9, 0x32, 0x16, 0x45, 0x48, 0xe5, 0x26, 0xae, 0x90, 0x22, 0x43, 0x68,
            0x51, 0x7a, 0xcf, 0xea, 0xbd, 0x6b, 0xb3, 0x73, 0x2b, 0xc0, 0xe9, 0xda, 0x99, 0x83,
            0x2b, 0x61, 0xca, 0x01, 0xb6, 0xde, 0x56, 0x24, 0x4a, 0x9e, 0x88, 0xd5, 0xf9, 0xb3,
            0x79, 0x73, 0xf6, 0x22, 0xa4, 0x3d, 0x14, 0xa6, 0x59, 0x9b, 0x1f, 0x65, 0x4c, 0xb4,
            0x5a, 0x74, 0xe3, 0x55, 0xa5,
        ];
        assert!(&c[32..] == &c_expected[..]);
    }
}

'''
'''--- src/crypto/verify.rs ---
//! Constant-time comparison of fixed-size vecs
use ffi;

/// `verify_16()` returns `true` if `x[0]`, `x[1]`, ..., `x[15]` are the
/// same as `y[0]`, `y[1]`, ..., `y[15]`. Otherwise it returns `false`.
///
/// This function is safe to use for secrets `x[0]`, `x[1]`, ..., `x[15]`,
/// `y[0]`, `y[1]`, ..., `y[15]`. The time taken by `verify_16` is independent
/// of the contents of `x[0]`, `x[1]`, ..., `x[15]`, `y[0]`, `y[1]`, ..., `y[15]`.
/// In contrast, the standard C comparison function `memcmp(x,y,16)` takes time
/// that depends on the longest matching prefix of `x` and `y`, often allowing easy
/// timing attacks.
pub fn verify_16(x: &[u8; 16], y: &[u8; 16]) -> bool {
    unsafe { ffi::crypto_verify_16(x, y) == 0 }
}

/// `verify_32()` returns true if `x[0]`, `x[1]`, ..., `x[31]` are the
/// same as `y[0]`, `y[1]`, ..., `y[31]`. Otherwise it returns `false`.
///
/// This function is safe to use for secrets `x[0]`, `x[1]`, ..., `x[31]`,
/// `y[0]`, `y[1]`, ..., `y[31]`. The time taken by `verify_32` is independent
/// of the contents of `x[0]`, `x[1]`, ..., `x[31]`, `y[0]`, `y[1]`, ..., `y[31]`.
/// In contrast, the standard C comparison function `memcmp(x,y,32)` takes time
/// that depends on the longest matching prefix of `x` and `y`, often allowing easy
/// timing attacks.
pub fn verify_32(x: &[u8; 32], y: &[u8; 32]) -> bool {
    unsafe { ffi::crypto_verify_32(x, y) == 0 }
}

/// `verify_64()` returns true if `x[0]`, `x[1]`, ..., `x[63]` are the
/// same as `y[0]`, `y[1]`, ..., `y[63]`. Otherwise it returns `false`.
///
/// This function is safe to use for secrets `x[0]`, `x[1]`, ..., `x[63]`,
/// `y[0]`, `y[1]`, ..., `y[63]`. The time taken by `verify_64` is independent
/// of the contents of `x[0]`, `x[1]`, ..., `x[63]`, `y[0]`, `y[1]`, ..., `y[63]`.
/// In contrast, the standard C comparison function `memcmp(x,y,64)` takes time
/// that depends on the longest matching prefix of `x` and `y`, often allowing easy
/// timing attacks.
pub fn verify_64(x: &[u8; 64], y: &[u8; 64]) -> bool {
    unsafe { ffi::crypto_verify_64(x, y) == 0 }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_verify_16() {
        use randombytes::randombytes_into;

        for _ in 0usize..256 {
            let mut x = [0; 16];
            let mut y = [0; 16];
            assert!(verify_16(&x, &y));
            randombytes_into(&mut x);
            randombytes_into(&mut y);
            if x == y {
                assert!(verify_16(&x, &y))
            } else {
                assert!(!verify_16(&x, &y))
            }
        }
    }

    #[test]
    fn test_verify_32() {
        use randombytes::randombytes_into;

        for _ in 0usize..256 {
            let mut x = [0; 32];
            let mut y = [0; 32];
            assert!(verify_32(&x, &y));
            randombytes_into(&mut x);
            randombytes_into(&mut y);
            if x == y {
                assert!(verify_32(&x, &y))
            } else {
                assert!(!verify_32(&x, &y))
            }
        }
    }

    #[test]
    fn test_verify_64() {
        use randombytes::randombytes_into;

        for _ in 0usize..256 {
            let mut x = [0; 64];
            let mut y = [0; 64];
            assert!(verify_64(&x, &y));
            randombytes_into(&mut x);
            randombytes_into(&mut y);
            if x[..] == y[..] {
                assert!(verify_64(&x, &y))
            } else {
                assert!(!verify_64(&x, &y))
            }
        }
    }
}

'''
'''--- src/lib.rs ---
//! Rust bindings to the [sodium library](https://github.com/jedisct1/libsodium).
//!
//! Sodium is a portable implementation of Dan Bernsteins [NaCl: Networking and
//! Cryptography library](http://nacl.cr.yp.to)
//!
//! For most users, if you want public-key (asymmetric) cryptography you should use
//! the functions in `crypto::box_` for encryption/decryption.
//!
//! If you want secret-key (symmetric) cryptography you should be using the
//! functions in `crypto::secretbox` for encryption/decryption.
//!
//! For public-key signatures you should use the functions in `crypto::sign` for
//! signature creation and verification.
//!
//! Unless you know what you're doing you most certainly don't want to use the
//! functions in `crypto::scalarmult`, `crypto::stream`, `crypto::auth` and
//! `crypto::onetimeauth`.
//!
//! ## Thread Safety
//! All functions in this library are thread-safe provided that the `init()`
//! function has been called during program execution.
//!
//! If `init()` hasn't been called then all functions except the random-number
//! generation functions and the key-generation functions are thread-safe.
//!
//! # Public-key cryptography
//!  `crypto::box_`
//!
//!  `crypto::sign`
//!
//! # Sealed boxes
//!  `crypto::sealedox`
//!
//! # Secret-key cryptography
//!  `crypto::secretbox`
//!
//!  `crypto::stream`
//!
//!  `crypto::auth`
//!
//!  `crypto::onetimeauth`
//!
//! # Low-level functions
//!  `crypto::hash`
//!
//!  `crypto::verify`
//!
//!  `crypto::shorthash`
#![crate_name = "exonum_sodiumoxide"]
#![crate_type = "lib"]
#![warn(missing_docs)]
#![warn(non_upper_case_globals)]
#![warn(non_camel_case_types)]
#![warn(unused_qualifications)]
#![cfg_attr(not(feature = "std"), no_std)]
#![cfg_attr(not(feature = "std"), feature(alloc))]
#![cfg_attr(not(feature = "std"), feature(collections))]

#[cfg(not(feature = "std"))]
extern crate alloc;
extern crate libc;
extern crate libsodium_sys as ffi;
#[cfg(test)]
extern crate rustc_serialize;
#[cfg(any(test, feature = "serde"))]
extern crate serde;
#[cfg(not(feature = "std"))]
#[macro_use]
extern crate collections;
#[cfg(all(test, not(feature = "std")))]
extern crate std;

#[cfg(all(not(test), not(feature = "std")))]
mod std {
    pub use core::{cmp, fmt, hash, iter, mem, ops, slice, str};
}

#[cfg(not(feature = "std"))]
mod prelude {
    pub use collections::{String, Vec};
}

/// `init()` initializes the sodium library and chooses faster versions of
/// the primitives if possible. `init()` also makes the random number generation
/// functions (`gen_key`, `gen_keypair`, `gen_nonce`, `randombytes`, `randombytes_into`)
/// thread-safe
///
/// `init()` returns `false` if initialization failed.
pub fn init() -> bool {
    unsafe { ffi::sodium_init() != -1 }
}

#[macro_use]
mod newtype_macros;
pub mod randombytes;
pub mod utils;
pub mod version;

#[cfg(test)]
mod test_utils;

/// Cryptographic functions
pub mod crypto {
    pub mod aead;
    pub mod auth;
    pub mod box_;
    pub mod hash;
    pub mod onetimeauth;
    pub mod pwhash;
    pub mod scalarmult;
    pub mod sealedbox;
    pub mod secretbox;
    pub mod shorthash;
    pub mod sign;
    pub mod stream;
    pub mod verify;
}

'''
'''--- src/newtype_macros.rs ---
macro_rules! newtype_clone (($newtype:ident) => (
        impl Clone for $newtype {
            fn clone(&self) -> $newtype {
                let &$newtype(v) = self;
                $newtype(v)
            }
        }

        ));

macro_rules! newtype_from_slice (($newtype:ident, $len:expr) => (
    /// `from_slice()` creates an object from a byte slice
    ///
    /// This function will fail and return `None` if the length of
    /// the byte-slice isn't equal to the length of the object
    pub fn from_slice(bs: &[u8]) -> Option<$newtype> {
        if bs.len() != $len {
            return None;
        }
        let mut n = $newtype([0; $len]);
        {
            let $newtype(ref mut b) = n;
            for (bi, &bsi) in b.iter_mut().zip(bs.iter()) {
                *bi = bsi
            }
        }
        Some(n)
    }
    ));

macro_rules! newtype_traits (($newtype:ident, $len:expr) => (
    impl ::std::cmp::PartialEq for $newtype {
        fn eq(&self, &$newtype(ref other): &$newtype) -> bool {
            use utils::memcmp;
            let &$newtype(ref this) = self;
            memcmp(this, other)
        }
    }
    impl ::std::cmp::Eq for $newtype {}

    #[cfg(feature = "serde")]
    impl ::serde::Serialize for $newtype {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where S: ::serde::Serializer
        {
            serializer.serialize_bytes(&self[..])
        }
    }

    #[cfg(feature = "serde")]
    impl<'de> ::serde::Deserialize<'de> for $newtype {
        fn deserialize<D>(deserializer: D) -> Result<$newtype, D::Error>
            where D: ::serde::Deserializer<'de>
        {
            struct NewtypeVisitor;
            impl<'de> ::serde::de::Visitor<'de> for NewtypeVisitor {
                type Value = $newtype;
                fn expecting(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(formatter, stringify!($newtype))
                }
                fn visit_seq<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>
                    where V: ::serde::de::SeqAccess<'de>
                {
                    let mut res = $newtype([0; $len]);
                    {
                        let $newtype(ref mut arr) = res;
                        for r in arr.iter_mut() {
                            if let Some(value) = try!(visitor.next_element()) {
                                *r = value;
                            }
                        }
                    }
                    Ok(res)
                }
                fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>
                    where E: ::serde::de::Error
                {
                    $newtype::from_slice(v).ok_or(::serde::de::Error::invalid_length(v.len(), &self))
                }
            }
            deserializer.deserialize_bytes(NewtypeVisitor)
        }
    }

    /// Allows a user to access the byte contents of an object as a slice.
    ///
    /// WARNING: it might be tempting to do comparisons on objects
    /// by using `x[a..b] == y[a..b]`. This will open up for timing attacks
    /// when comparing for example authenticator tags. Because of this only
    /// use the comparison functions exposed by the sodiumoxide API.
    impl ::std::ops::Index<::std::ops::Range<usize>> for $newtype {
        type Output = [u8];
        fn index(&self, _index: ::std::ops::Range<usize>) -> &[u8] {
            let &$newtype(ref b) = self;
            b.index(_index)
        }
    }
    /// Allows a user to access the byte contents of an object as a slice.
    ///
    /// WARNING: it might be tempting to do comparisons on objects
    /// by using `x[..b] == y[..b]`. This will open up for timing attacks
    /// when comparing for example authenticator tags. Because of this only
    /// use the comparison functions exposed by the sodiumoxide API.
    impl ::std::ops::Index<::std::ops::RangeTo<usize>> for $newtype {
        type Output = [u8];
        fn index(&self, _index: ::std::ops::RangeTo<usize>) -> &[u8] {
            let &$newtype(ref b) = self;
            b.index(_index)
        }
    }
    /// Allows a user to access the byte contents of an object as a slice.
    ///
    /// WARNING: it might be tempting to do comparisons on objects
    /// by using `x[a..] == y[a..]`. This will open up for timing attacks
    /// when comparing for example authenticator tags. Because of this only
    /// use the comparison functions exposed by the sodiumoxide API.
    impl ::std::ops::Index<::std::ops::RangeFrom<usize>> for $newtype {
        type Output = [u8];
        fn index(&self, _index: ::std::ops::RangeFrom<usize>) -> &[u8] {
            let &$newtype(ref b) = self;
            b.index(_index)
        }
    }
    /// Allows a user to access the byte contents of an object as a slice.
    ///
    /// WARNING: it might be tempting to do comparisons on objects
    /// by using `x[] == y[]`. This will open up for timing attacks
    /// when comparing for example authenticator tags. Because of this only
    /// use the comparison functions exposed by the sodiumoxide API.
    impl ::std::ops::Index<::std::ops::RangeFull> for $newtype {
        type Output = [u8];
        fn index(&self, _index: ::std::ops::RangeFull) -> &[u8] {
            let &$newtype(ref b) = self;
            b.index(_index)
        }
    }
    ));

macro_rules! public_newtype_traits (($newtype:ident) => (
    impl AsRef<[u8]> for $newtype {
        #[inline]
        fn as_ref(&self) -> &[u8] {
            &self[..]
        }
    }
    impl ::std::cmp::PartialOrd for $newtype {
        #[inline]
        fn partial_cmp(&self,
                       other: &$newtype) -> Option<::std::cmp::Ordering> {
            ::std::cmp::PartialOrd::partial_cmp(self.as_ref(), other.as_ref())
        }
        #[inline]
        fn lt(&self, other: &$newtype) -> bool {
            ::std::cmp::PartialOrd::lt(self.as_ref(), other.as_ref())
        }
        #[inline]
        fn le(&self, other: &$newtype) -> bool {
            ::std::cmp::PartialOrd::le(self.as_ref(), other.as_ref())
        }
        #[inline]
        fn ge(&self, other: &$newtype) -> bool {
            ::std::cmp::PartialOrd::ge(self.as_ref(), other.as_ref())
        }
        #[inline]
        fn gt(&self, other: &$newtype) -> bool {
            ::std::cmp::PartialOrd::gt(self.as_ref(), other.as_ref())
        }
    }
    impl ::std::cmp::Ord for $newtype {
        #[inline]
        fn cmp(&self, other: &$newtype) -> ::std::cmp::Ordering {
            ::std::cmp::Ord::cmp(self.as_ref(), other.as_ref())
        }
    }
    impl ::std::hash::Hash for $newtype {
        fn hash<H: ::std::hash::Hasher>(&self, state: &mut H) {
            ::std::hash::Hash::hash(self.as_ref(), state)
        }
    }
    ));

/// Macro used for generating newtypes of byte-arrays
///
/// Usage:
/// Generating secret datatypes, e.g. keys
///
/// ```
/// new_type! {
///     /// This is some documentation for our type
///     secret Key(KEYBYTES);
/// }
/// ```
///
/// Generating public datatypes, e.g. public keys
///
/// ```
/// new_type! {
///     /// This is some documentation for our type
///     public PublicKey(PUBLICKEYBYTES);
/// }
///
/// ```
///
/// Generating nonce types
///
/// ```
/// new_type! {
///     /// This is some documentation for our type
///     nonce Nonce(NONCEBYTES);
/// }
/// ```
macro_rules! new_type {
    ( $(#[$meta:meta])*
      secret $name:ident($bytes:expr);
      ) => (
        $(#[$meta])*
        #[must_use]
        pub struct $name(pub [u8; $bytes]);
        newtype_clone!($name);
        newtype_traits!($name, $bytes);
        impl $name {
            newtype_from_slice!($name, $bytes);
        }
        impl Drop for $name {
            fn drop(&mut self) {
                use utils::memzero;
                let &mut $name(ref mut v) = self;
                memzero(v);
            }
        }
        impl ::std::fmt::Debug for $name {
            fn fmt(&self,
                   formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                // Hide secrets from debug output.
                write!(formatter, "{}(****)", stringify!($name))
            }
        }
        );
    ( $(#[$meta:meta])*
      public $name:ident($bytes:expr);
      ) => (
        $(#[$meta])*
        #[derive(Copy)]
        #[must_use]
        pub struct $name(pub [u8; $bytes]);
        newtype_clone!($name);
        newtype_traits!($name, $bytes);
        public_newtype_traits!($name);
        impl $name {
            newtype_from_slice!($name, $bytes);
        }
        impl ::std::fmt::Debug for $name {
            fn fmt(&self,
                   formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(formatter, "{}({:?})", stringify!($name), &self[..])
            }
        }
        );
    ( $(#[$meta:meta])*
      nonce $name:ident($bytes:expr);
      ) => (
        $(#[$meta])*
        #[derive(Copy)]
        #[must_use]
        pub struct $name(pub [u8; $bytes]);
        newtype_clone!($name);
        newtype_traits!($name, $bytes);
        public_newtype_traits!($name);
        impl $name {
            newtype_from_slice!($name, $bytes);

            /// `increment_le()` treats the nonce as an unsigned little-endian number and
            /// returns an incremented version of it.
            ///
            /// WARNING: this method does not check for arithmetic overflow. It is the callers
            /// responsibility to ensure that any given nonce value is only used once.
            /// If the caller does not do that the cryptographic primitives in sodiumoxide
            /// will not uphold any security guarantees (i.e. they will break)
            pub fn increment_le(&self) -> $name {
                let mut res = *self;
                res.increment_le_inplace();
                res
            }

            /// `increment_le_inplace()` treats the nonce as an unsigned little-endian number
            /// and increments it.
            ///
            /// WARNING: this method does not check for arithmetic overflow. It is the callers
            /// responsibility to ensure that any given nonce value is only used once.
            /// If the caller does not do that the cryptographic primitives in sodiumoxide
            /// will not uphold any security guarantees.
            pub fn increment_le_inplace(&mut self) {
                use utils::increment_le;
                let &mut $name(ref mut r) = self;
                increment_le(r);
            }

        }
        impl ::std::fmt::Debug for $name {
            fn fmt(&self,
                   formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                write!(formatter, "{}({:?})", stringify!($name), &self[..])
            }
        }
        );
}

'''
'''--- src/randombytes.rs ---
//! Cryptographic random number generation.
use ffi;
#[cfg(not(feature = "std"))]
use prelude::*;
use std::iter::repeat;

/// `randombytes()` randomly generates size bytes of data.
///
/// THREAD SAFETY: `randombytes()` is thread-safe provided that you have
/// called `sodiumoxide::init()` once before using any other function
/// from sodiumoxide.
pub fn randombytes(size: usize) -> Vec<u8> {
    unsafe {
        let mut buf: Vec<u8> = repeat(0u8).take(size).collect();
        let pbuf = buf.as_mut_ptr();
        ffi::randombytes_buf(pbuf, size);
        buf
    }
}

/// `randombytes_into()` fills a buffer `buf` with random data.
///
/// THREAD SAFETY: `randombytes_into()` is thread-safe provided that you have
/// called `sodiumoxide::init()` once before using any other function
/// from sodiumoxide.
pub fn randombytes_into(buf: &mut [u8]) {
    unsafe {
        ffi::randombytes_buf(buf.as_mut_ptr(), buf.len());
    }
}

'''
'''--- src/test_utils.rs ---
#![cfg(all(test, feature = "serde"))]
extern crate core;
extern crate rmp_serde;
extern crate serde_json;
#[cfg(not(feature = "std"))]
use prelude::*;
use serde::de::DeserializeOwned;
use serde::{Deserialize, Serialize};

// Encodes then decodes `value` using JSON
pub fn round_trip<T>(value: T)
where
    T: Serialize + DeserializeOwned + Eq + core::fmt::Debug,
{
    let encoded_value = serde_json::to_string(&value).unwrap();
    let decoded_value = serde_json::from_str(&encoded_value).unwrap();
    assert_eq!(value, decoded_value);

    let mut buf = Vec::new();
    value
        .serialize(&mut rmp_serde::Serializer::new(&mut buf))
        .unwrap();
    let mut de = rmp_serde::Deserializer::new(&buf[..]);
    let decoded_value = Deserialize::deserialize(&mut de).unwrap();
    assert_eq!(value, decoded_value);
}

'''
'''--- src/utils.rs ---
//! Libsodium utility functions
use ffi;

/// `memzero()` tries to effectively zero out the data in `x` even if
/// optimizations are being applied to the code.
pub fn memzero(x: &mut [u8]) {
    unsafe {
        ffi::sodium_memzero(x.as_mut_ptr(), x.len());
    }
}

/// `memcmp()` returns true if `x[0]`, `x[1]`, ..., `x[len-1]` are the
/// same as `y[0]`, `y[1]`, ..., `y[len-1]`. Otherwise it returns `false`.
///
/// This function is safe to use for secrets `x[0]`, `x[1]`, ..., `x[len-1]`,
/// `y[0]`, `y[1]`, ..., `y[len-1]`. The time taken by `memcmp` is independent
/// of the contents of `x[0]`, `x[1]`, ..., `x[len-1]`, `y[0]`, `y[1]`, ..., `y[len-1]`.
/// In contrast, the standard C comparison function `memcmp(x,y,len)` takes time
/// that depends on the longest matching prefix of `x` and `y`, often allowing easy
/// timing attacks.
pub fn memcmp(x: &[u8], y: &[u8]) -> bool {
    if x.len() != y.len() {
        return false;
    }
    unsafe { ffi::sodium_memcmp(x.as_ptr(), y.as_ptr(), x.len()) == 0 }
}

/// `increment_le()` treats `x` as an unsigned little-endian number and increments it.
///
/// WARNING: this method does not check for arithmetic overflow. When used for incrementing
/// nonces it is the callers responsibility to ensure that any given nonce value
/// is only used once.
/// If the caller does not do that the cryptographic primitives in sodiumoxide
/// will not uphold any security guarantees (i.e. they will break)
pub fn increment_le(x: &mut [u8]) {
    unsafe {
        ffi::sodium_increment(x.as_mut_ptr(), x.len());
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_memcmp() {
        use randombytes::randombytes;

        for i in 0usize..256 {
            let x = randombytes(i);
            assert!(memcmp(&x, &x));
            let mut y = x.clone();
            assert!(memcmp(&x, &y));
            y.push(0);
            assert!(!memcmp(&x, &y));
            assert!(!memcmp(&y, &x));

            y = randombytes(i);
            if x == y {
                assert!(memcmp(&x, &y))
            } else {
                assert!(!memcmp(&x, &y))
            }
        }
    }

    #[test]
    fn test_increment_le_zero() {
        for i in 1usize..256 {
            let mut x = vec![0u8; i];
            increment_le(&mut x);
            assert!(!x.iter().all(|x| *x == 0));
            let mut y = vec![0u8; i];
            y[0] += 1;
            assert_eq!(x, y);
        }
    }

    #[test]
    fn test_increment_le_vectors() {
        let mut x = [255, 2, 3, 4, 5];
        let y = [0, 3, 3, 4, 5];
        increment_le(&mut x);
        assert!(!x.iter().all(|x| *x == 0));
        assert_eq!(x, y);
        let mut x = [255, 255, 3, 4, 5];
        let y = [0, 0, 4, 4, 5];
        increment_le(&mut x);
        assert!(!x.iter().all(|x| *x == 0));
        assert_eq!(x, y);
        let mut x = [255, 255, 255, 4, 5];
        let y = [0, 0, 0, 5, 5];
        increment_le(&mut x);
        assert!(!x.iter().all(|x| *x == 0));
        assert_eq!(x, y);
        let mut x = [255, 255, 255, 255, 5];
        let y = [0, 0, 0, 0, 6];
        increment_le(&mut x);
        assert!(!x.iter().all(|x| *x == 0));
        assert_eq!(x, y);
        let mut x = [255, 255, 255, 255, 255];
        let y = [0, 0, 0, 0, 0];
        increment_le(&mut x);
        assert!(x.iter().all(|x| *x == 0));
        assert_eq!(x, y);
    }

    #[test]
    fn test_increment_le_overflow() {
        for i in 1usize..256 {
            let mut x = vec![255u8; i];
            increment_le(&mut x);
            assert!(x.iter().all(|xi| *xi == 0));
        }
    }
}

'''
'''--- src/version.rs ---
//! Libsodium version functions
use ffi;
use libc;
use std::slice;
use std::str;

/// `version_string()` returns the version string from libsodium.
pub fn version_string() -> &'static str {
    // Use libc directly because CStr isn't available with #![no_std] :(
    let version = unsafe {
        let version_ptr = ffi::sodium_version_string();
        let version_len = libc::strlen(version_ptr);
        slice::from_raw_parts(version_ptr as *const u8, version_len as usize)
    };
    str::from_utf8(version).unwrap()
}

/// `version_major()` returns the major version from libsodium.
pub fn version_major() -> usize {
    unsafe { ffi::sodium_library_version_major() as usize }
}

/// `version_minor()` returns the minor version from libsodium.
pub fn version_minor() -> usize {
    unsafe { ffi::sodium_library_version_minor() as usize }
}

#[cfg(test)]
mod test {
    #[test]
    fn test_version_string() {
        use version::version_string;
        assert!(!version_string().is_empty());
    }
}

'''