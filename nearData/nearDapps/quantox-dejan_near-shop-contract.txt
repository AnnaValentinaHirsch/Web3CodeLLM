*GitHub Repository "quantox-dejan/near-shop-contract"*

'''--- docs/wallet.txt ---
dejan1.testnet passphrase
=========================
ugly foster void topple lecture outdoor present dilemma gown tackle plug assault

dejan-cust.testnet passphrase
=============================
acoustic clown hunt smoke amused chicken picture skill simple vibrant body brain
'''
'''--- src/.gitpod.yml ---
tasks:
  - init: npm dev
    command: npm run dev
ports:
  - port: 1234
    onOpen: open-browser

'''
'''--- src/.idea/modules.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ProjectModuleManager">
    <modules>
      <module fileurl="file://$PROJECT_DIR$/.idea/src.iml" filepath="$PROJECT_DIR$/.idea/src.iml" />
    </modules>
  </component>
</project>
'''
'''--- src/.idea/vcs.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="VcsDirectoryMappings">
    <mapping directory="$PROJECT_DIR$/.." vcs="Git" />
  </component>
</project>
'''
'''--- src/README.md ---
near-blank-project
==================

This app was initialized with [create-near-app]

Quick Start
===========

If you haven't installed dependencies during setup:

    npm run deps-install

Build and deploy your contract to TestNet with a temporary dev account:

    npm run deploy

Test your contract:

    npm test

If you have a frontend, run `npm start`. This will run a dev server.

Exploring The Code
==================

1. The smart-contract code lives in the `/contract` folder. See the README there for
   more info. In blockchain apps the smart contract is the "backend" of your app.
2. The frontend code lives in the `/frontend` folder. `/frontend/index.html` is a great
   place to start exploring. Note that it loads in `/frontend/index.js`,
   this is your entrypoint to learn how the frontend connects to the NEAR blockchain.
3. Test your contract: `npm test`, this will run the tests in `integration-tests` directory.

Deploy
======

Every smart contract in NEAR has its [own associated account][NEAR accounts]. 
When you run `npm run deploy`, your smart contract gets deployed to the live NEAR TestNet with a temporary dev account.
When you're ready to make it permanent, here's how:

Step 0: Install near-cli (optional)
-------------------------------------

[near-cli] is a command line interface (CLI) for interacting with the NEAR blockchain. It was installed to the local `node_modules` folder when you ran `npm install`, but for best ergonomics you may want to install it globally:

    npm install --global near-cli

Or, if you'd rather use the locally-installed version, you can prefix all `near` commands with `npx`

Ensure that it's installed with `near --version` (or `npx near --version`)

Step 1: Create an account for the contract
------------------------------------------

Each account on NEAR can have at most one contract deployed to it. If you've already created an account such as `your-name.testnet`, you can deploy your contract to `near-blank-project.your-name.testnet`. Assuming you've already created an account on [NEAR Wallet], here's how to create `near-blank-project.your-name.testnet`:

1. Authorize NEAR CLI, following the commands it gives you:

      near login

2. Create a subaccount (replace `YOUR-NAME` below with your actual account name):

      near create-account near-blank-project.YOUR-NAME.testnet --masterAccount YOUR-NAME.testnet

Step 2: deploy the contract
---------------------------

Use the CLI to deploy the contract to TestNet with your account ID.
Replace `PATH_TO_WASM_FILE` with the `wasm` that was generated in `contract` build directory.

    near deploy --accountId near-blank-project.YOUR-NAME.testnet --wasmFile PATH_TO_WASM_FILE

Step 3: set contract name in your frontend code
-----------------------------------------------

Modify the line in `src/config.js` that sets the account name of the contract. Set it to the account id you used above.

    const CONTRACT_NAME = process.env.CONTRACT_NAME || 'near-blank-project.YOUR-NAME.testnet'

Troubleshooting
===============

On Windows, if you're seeing an error containing `EPERM` it may be related to spaces in your path. Please see [this issue](https://github.com/zkat/npx/issues/209) for more details.

  [create-near-app]: https://github.com/near/create-near-app
  [Node.js]: https://nodejs.org/en/download/package-manager/
  [jest]: https://jestjs.io/
  [NEAR accounts]: https://docs.near.org/concepts/basics/account
  [NEAR Wallet]: https://wallet.testnet.near.org/
  [near-cli]: https://github.com/near/near-cli
  [gh-pages]: https://github.com/tschaub/gh-pages

'''
'''--- src/contract/.env ---
﻿DATABASE_URL=postgres://nnofxmat:DilOhCg-8V2miaoqQ9IhrtDGecJoajvf@tyke.db.elephantsql.com/nnofxmat

'''
'''--- src/contract/Cargo.toml ---
[package]
name = "shop"
version = "0.1.0"
authors = ["Dejan Janjusevic <dejan.janjusevic@quantox.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
uint = { version = "0.9.3", default-features = false }
serde = "1.0.143"
fastrand = "1.1.0"
diesel = { version = "1.4.8", features = ["postgres"] }
dotenv = "0.15.0"
chrono = "0.4"

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []

'''
'''--- src/contract/README.md ---
Hello NEAR!
=================================

A [smart contract] written in [Rust] for an app initialized with [create-near-app]

Quick Start
===========

Before you compile this code, you will need to install Rust with [correct target]

Exploring The Code
==================

1. The main smart contract code lives in `src/lib.rs`.
2. There are two functions to the smart contract: `get_greeting` and `set_greeting`.
3. Tests: You can run smart contract tests with the `cargo test`.

  [smart contract]: https://docs.near.org/develop/welcome
  [Rust]: https://www.rust-lang.org/
  [create-near-app]: https://github.com/near/create-near-app
  [correct target]: https://docs.near.org/develop/prerequisites#rust-and-wasm
  [cargo]: https://doc.rust-lang.org/book/ch01-03-hello-cargo.html

'''
'''--- src/contract/diesel.toml ---
# For documentation on how to configure this file,
# see diesel.rs/guides/configuring-diesel-cli

[print_schema]
file = "src/schema.rs"

'''
'''--- src/contract/migrations/2022-08-22-143738_create_initial_tables/down.sql ---
-- This file should undo anything in `up.sql`
drop index ix_favoriteShops_user;
drop table favoriteShops;

drop index ix_favoriteProducts_user;
drop table favoriteProducts;

drop index ix_wishlist_user;
drop table wishlist;

drop index ix_purchases_user;
drop table purchases;
'''
'''--- src/contract/migrations/2022-08-22-143738_create_initial_tables/up.sql ---
-- Your SQL goes here
create table purchases (
    id varchar(250) primary key,
    userid varchar(250) not null,
    product varchar(250) not null,
    shop varchar(250) not null,
    timestamp timestamp not null
);

create index ix_purchases_user on purchases (
    userid,
    timestamp desc
);

create table wishlist (
    id varchar(250) primary key,
    userid varchar(250) not null,
    product varchar(250) not null,
    timestamp timestamp not null
);

create index ix_wishlist_user on wishlist (
    userid
);

create table favoriteProducts (
    id varchar(250) primary key,
    userid varchar(250) not null,
    product varchar(250) not null,
    timestamp timestamp not null
);

create index ix_favoriteProducts_user on favoriteProducts (
    userid
);

create table favoriteShops (
    id varchar(250) primary key,
    userid varchar(250) not null,
    shop varchar(250) not null,
    timestamp timestamp not null
);

create index ix_favoriteShops_user on favoriteShops (
    userid
);

'''
'''--- src/contract/neardev/dev-account.env ---
CONTRACT_NAME=dev-1660227117650-76259097572673
'''
'''--- src/contract/src/contract/mod.rs ---
mod near_shop;

use crate::contract::near_shop::NearShopContract;
use crate::dto::coupon::CouponDto;
use crate::dto::product::ProductDto;
use crate::dto::return_value::ReturnValue;
use crate::dto::user_shop::UserShopDto;
use crate::model::coupon::Coupon;
use crate::model::product::Product;
use crate::model::storage_keys::StorageKeys;
use crate::model::user_shop::UserShop;
use crate::utils::vector_utils::VectorUtils;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedMap;
use near_sdk::json_types::U128;
use near_sdk::{env, near_bindgen, AccountId, Balance, PanicOnDefault, Promise};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct NearShop {
    /// The lazy map of user shops.
    /// We don't need to read the entire map of existing user shops when adding a new one.
    /// Each time the state is loaded, using the standard Map would cause all entries
    /// in the data structure to be read eagerly from storage and deserialized.
    /// This would come at a large cost for any non-trivial amount of data,
    /// so to minimize the amount of gas used the SDK UnorderedMap is used.
    user_shops: UnorderedMap<AccountId, UserShop>,
}

#[near_bindgen]
impl NearShopContract for NearShop {
    #[init]
    fn initialize() -> Self {
        if !env::state_read::<Self>().is_none() {
            env::panic_str("Already initialized");
        }

        Self {
            user_shops: UnorderedMap::new(StorageKeys::UserShops),
        }
    }

    fn return_custom_object(&self) -> ReturnValue<String> {
        ReturnValue {
            result: String::from("Works!"),
            success: true,
        }
    }

    fn get_my_user_shop(&self, user_account_id: String) -> Option<UserShopDto> {
        let user_shop = self
            .user_shops
            .get(&AccountId::new_unchecked(user_account_id));
        match user_shop {
            Some(result) => Some(UserShopDto {
                id: result.id,
                name: result.name,
            }),
            None => None,
        }
    }

    fn list_my_user_shop_products(&self, user_account_id: String) -> Vec<ProductDto> {
        let user_shop_maybe = self
            .user_shops
            .get(&AccountId::new_unchecked(user_account_id));

        match user_shop_maybe {
            Some(user_shop) => {
                let mut return_value = Vec::new();
                for product in user_shop.products.to_vec().iter() {
                    return_value.push(ProductDto::new(
                        String::from(&product.id),
                        String::from(&product.name),
                        product.price,
                        product.quantity_on_stock,
                    ));
                }

                return return_value;
            }
            None => {
                env::panic_str("You don't have a user shop");
            }
        }
    }

    fn list_all_user_shops(&self) -> Vec<UserShopDto> {
        let keys = self.user_shops.keys_as_vector();
        let mut return_value = Vec::new();
        for key in keys.iter() {
            let user_shop_maybe = self.user_shops.get(&key);
            if let Some(user_shop) = user_shop_maybe {
                return_value.push(UserShopDto::new(user_shop.id, user_shop.name));
            }
        }

        return_value
    }

    fn get_user_shop(&self, user_shop_id: String) -> Option<UserShopDto> {
        let user_shops = self.user_shops.values_as_vector().to_vec();
        let found_user_shop = user_shops.iter().find(|&x| x.id == user_shop_id);
        if let Some(user_shop) = found_user_shop {
            return Some(UserShopDto::new(
                String::from(&user_shop.id),
                String::from(&user_shop.name),
            ));
        }

        None
    }

    fn list_user_shop_products(&self, user_shop_id: String) -> Vec<ProductDto> {
        let user_shops = self.user_shops.values_as_vector().to_vec();
        let found_user_shop = user_shops.iter().find(|&x| x.id == user_shop_id);
        let mut return_value = Vec::new();
        if let Some(user_shop) = found_user_shop {
            for product in user_shop.products.to_vec().iter() {
                return_value.push(ProductDto::new(
                    String::from(&product.id),
                    String::from(&product.name),
                    product.price,
                    product.quantity_on_stock,
                ));
            }
        }

        return_value
    }

    fn get_user_shop_product(
        &self,
        user_shop_id: String,
        product_id: String,
    ) -> Option<ProductDto> {
        let user_shops = self.user_shops.values_as_vector().to_vec();
        let found_user_shop = user_shops.iter().find(|&x| x.id == user_shop_id);
        if let None = found_user_shop {
            return None;
        }

        let user_shop = found_user_shop.unwrap();
        let products = user_shop.products.to_vec();
        let found_product = products.iter().find(|x| x.id == product_id);

        if let None = found_product {
            return None;
        }

        let product = found_product.unwrap();
        Some(ProductDto::new(
            String::from(&product.id),
            String::from(&product.name),
            product.price,
            product.quantity_on_stock,
        ))
    }

    fn list_my_user_shop_coupons(&self, user_account_id: String) -> Vec<CouponDto> {
        let user_shop_maybe = self
            .user_shops
            .get(&AccountId::new_unchecked(user_account_id));
        if let None = user_shop_maybe {
            env::panic_str("You don't have a shop");
        }

        let user_shop = user_shop_maybe.unwrap();
        let mut return_value = Vec::new();
        for coupon in user_shop.coupons.iter() {
            let dto = CouponDto::new(
                String::from(&coupon.id),
                String::from(&coupon.code),
                coupon.discount_percentage,
                coupon.applies_to_all_products,
                self.convert_products(&user_shop, &coupon.applies_to_products),
                coupon.applies_to_all_users,
                coupon.applies_to_user.clone(),
                coupon.is_one_time,
                coupon.times_used,
            );

            return_value.push(dto);
        }

        return_value
    }

    fn get_product_cost_using_coupon(
        &self,
        user_shop_id: String,
        product_id: String,
        quantity: i32,
        coupon_code: String,
    ) -> U128 {
        let user_shops = self.user_shops.values_as_vector().to_vec();
        let found_user_shop = user_shops.iter().find(|x| x.id == user_shop_id);
        if let None = found_user_shop {
            env::panic_str("The requested user shop doesn't exist");
        }

        let user_shop = found_user_shop.unwrap();
        let products = user_shop.products.to_vec();
        let found_product = products.iter().find(|x| x.id == product_id);

        if let None = found_product {
            env::panic_str("The requested product doesn't exist");
        }

        let product = found_product.unwrap();
        let mut expected_amount: u128 = product.price * quantity as u128;
        let _ = self.update_expected_amount(
            &mut expected_amount,
            &coupon_code,
            &product_id,
            &user_shop_id,
        );

        U128(expected_amount)
    }

    fn add_user_shop(&mut self, name: String) {
        let existing_user_shop = self.user_shops.get(&env::predecessor_account_id());
        if !existing_user_shop.is_none() {
            env::panic_str("You already have a shop");
        }

        self.user_shops
            .insert(&env::predecessor_account_id(), &UserShop::new(name));
    }

    fn add_product(&mut self, name: String, price: U128, quantity: i32) {
        let mut user_shop = self
            .user_shops
            .get(&env::predecessor_account_id())
            .expect("You need to register your shop before adding products to sell");
        let products = &mut user_shop.products;
        let new_product = Product::new(name, price.into(), quantity);
        products.push(&new_product);
        self.user_shops
            .insert(&env::predecessor_account_id(), &user_shop);
    }

    fn update_product_quantity(&mut self, product_id: String, quantity: i32) {
        let mut user_shop = self
            .user_shops
            .get(&env::predecessor_account_id())
            .expect("You need to register your shop before adding products to sell");
        let products = &mut user_shop.products;
        let idx = products
            .to_vec()
            .iter()
            .position(|x| x.id == product_id)
            .expect("The requested product does not exist");

        let mut product = products.to_vec()[idx].clone();
        product.quantity_on_stock = quantity;
        products.replace(idx.try_into().unwrap(), &product);
    }

    fn add_default_coupon(&mut self, code: String, discount_percentage: f32) {
        let mut user_shop = self
            .user_shops
            .get(&env::predecessor_account_id())
            .expect("You need to register your shop before adding coupons");
        let coupons = &mut user_shop.coupons;
        coupons.push(&Coupon::new(code, discount_percentage));
        self.user_shops
            .insert(&env::predecessor_account_id(), &user_shop);
    }

    fn add_specific_coupon(
        &mut self,
        code: String,
        discount_percentage: f32,
        applies_to_products: &Vec<String>,
        applies_to_user: Option<AccountId>,
        is_one_time: bool,
    ) {
        let mut user_shop = self
            .user_shops
            .get(&env::predecessor_account_id())
            .expect("You need to register your shop before adding coupons");
        let coupons = &mut user_shop.coupons;
        coupons.push(&Coupon::specific_new(
            code,
            discount_percentage,
            applies_to_products,
            applies_to_user,
            is_one_time,
        ));

        self.user_shops
            .insert(&env::predecessor_account_id(), &user_shop);
    }

    #[payable]
    fn buy_product(
        &mut self,
        user_shop_id: String,
        product_id: String,
        quantity: i32,
        using_coupon_code: Option<String>,
    ) -> Promise {
        if quantity <= 0 {
            env::panic_str("The quantity must be higher than zero");
        }

        let mut user_shops = self.user_shops.values_as_vector().to_vec();
        let found_user_shop_idx = user_shops.iter().position(|x| x.id == user_shop_id);
        if let None = found_user_shop_idx {
            env::panic_str("The requested user shop doesn't exist");
        }

        let user_shop = user_shops.get_mut(found_user_shop_idx.unwrap()).unwrap();
        let coupons = &mut user_shop.coupons;
        let products = user_shop.products.to_vec();
        let found_product = products.iter().find(|x| x.id == product_id);

        if let None = found_product {
            env::panic_str("The requested product doesn't exist");
        }

        let product = found_product.unwrap();
        if product.quantity_on_stock < quantity {
            env::panic_str("The requested product quantity is not available on stock");
        }

        let mut expected_amount: u128 = product.price * quantity as u128;
        let mut coupon_maybe = None;
        if let Some(coupon_code) = using_coupon_code {
            coupon_maybe = self.update_expected_amount(
                &mut expected_amount,
                &coupon_code,
                &product_id,
                &user_shop_id,
            );
        }

        let _test = Balance::from(expected_amount);
        if env::attached_deposit() != expected_amount {
            env::panic_str("The payment amount is not correct: should be {}");
        }

        if let Some((mut coupon, idx)) = coupon_maybe {
            coupon.times_used += 1;
            coupons.replace(idx.try_into().unwrap(), &coupon);
        }

        self.update_product_quantity(product_id, product.quantity_on_stock - quantity);
        self.user_shops
            .insert(&user_shop.owner_account_id, &user_shop);

        Promise::new(user_shop.owner_account_id.clone()).transfer(env::attached_deposit())
    }
}

impl NearShop {
    fn convert_products(&self, user_shop: &UserShop, products: &Vec<String>) -> Vec<ProductDto> {
        let products_vector = user_shop.products.to_vec();
        let products = products_vector.intersect_with_ids(
            |x: &Product| String::from(&x.id),
            products,
            |left, right| left == right,
        );

        let mut return_value = Vec::new();
        for product in products {
            return_value.push(ProductDto::new(
                String::from(&product.id),
                String::from(&product.name),
                product.price,
                product.quantity_on_stock,
            ));
        }

        return_value
    }

    fn update_expected_amount(
        &self,
        expected_amount: &mut u128,
        coupon_code: &String,
        product_id: &String,
        user_shop_id: &String,
    ) -> Option<(Coupon, usize)> {
        let user_shops = self.user_shops.values_as_vector().to_vec();
        let found_user_shop = user_shops
            .iter()
            .find(|x| x.id == String::from(user_shop_id));
        if let None = found_user_shop {
            return None;
        }

        let user_shop = found_user_shop.unwrap();
        let coupon_maybe = user_shop
            .coupons
            .iter()
            .position(|x| x.code == *coupon_code);
        if let None = coupon_maybe {
            return None;
        }

        let idx = coupon_maybe.unwrap();
        let coupon = &user_shop.coupons.to_vec()[idx];
        if coupon.times_used > 0 && coupon.is_one_time {
            return None;
        }

        if !coupon.applies_to_all_users
            && *coupon.applies_to_user.as_ref().unwrap() != env::predecessor_account_id()
        {
            return None;
        }

        if !coupon.applies_to_all_products && !coupon.applies_to_products.contains(product_id) {
            return None;
        }

        *expected_amount = *expected_amount
            - (*expected_amount * (coupon.discount_percentage as u128)) / (100 as u128);
        Some(((*coupon).clone(), idx))
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use super::*;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{testing_env, VMContext};

    fn get_context(is_view: bool) -> (VMContext, String) {
        let signer_account_id = "bob.near";
        (
            VMContextBuilder::new()
                .signer_account_id(signer_account_id.parse().unwrap())
                .is_view(is_view)
                .build(),
            signer_account_id.to_string(),
        )
    }

    #[test]
    fn get_my_user_shop_returns_after_adding_a_shop() {
        let context = get_context(false);
        testing_env!(context.0);

        let mut contract = NearShop::initialize();
        contract.add_user_shop("Test Shop".to_string());
        let user_shop = contract.get_my_user_shop(String::from(context.1));
        assert!(!user_shop.is_none());
        assert_eq!("Test Shop".to_string(), user_shop.unwrap().name);
    }

    #[test]
    #[should_panic(expected = "You already have a shop")]
    fn add_user_shop_adds_only_one_per_user() {
        let context = get_context(false);
        testing_env!(context.0);

        let mut contract = NearShop::initialize();
        let user_shop = contract.get_my_user_shop(String::from(context.1));
        assert!(user_shop.is_none());
        contract.add_user_shop("Test Shop".to_string());
        contract.add_user_shop("Should never add this one".to_string());
    }

    #[test]
    fn user_shop_can_be_found_by_id() {
        let context = get_context(false);
        testing_env!(context.0);

        let mut contract = NearShop::initialize();
        contract.add_user_shop("Test Shop".to_string());
        let user_shop = contract.get_my_user_shop(String::from(context.1)).unwrap();
        let user_shops = contract.user_shops.values_as_vector().to_vec();
        let _found_user_shop = user_shops
            .iter()
            .find(|&x| x.id == user_shop.id)
            .expect("User shop should be returned");
    }

    #[test]
    #[should_panic(expected = "You need to register your shop before adding products to sell")]
    fn should_not_add_a_product_if_no_shop() {
        let context = get_context(false);
        testing_env!(context.0);

        let mut contract = NearShop::initialize();
        contract.add_product("Should not add this product".to_string(), U128(0), 0);
    }

    #[test]
    #[should_panic(expected = "You need to register your shop before adding coupons")]
    fn should_not_add_a_default_coupon_if_no_shop() {
        let context = get_context(false);
        testing_env!(context.0);

        let mut contract = NearShop::initialize();
        contract.add_default_coupon("Should not add this coupon".to_string(), 100.00);
    }

    #[test]
    #[should_panic(expected = "You need to register your shop before adding coupons")]
    fn should_not_add_a_specific_coupon_if_no_shop() {
        let context = get_context(false);
        testing_env!(context.0);

        let mut contract = NearShop::initialize();
        contract.add_specific_coupon(
            "Should not add this coupon".to_string(),
            100.00,
            &vec![],
            None,
            true,
        );
    }

    #[test]
    fn should_add_a_product_to_registered_shop() {
        let context = get_context(false);
        testing_env!(context.0);

        let mut contract = NearShop::initialize();
        contract.add_user_shop("Test Shop".to_string());
        contract.add_product("Test Product".to_string(), U128(1337), 0);
        let user_shop = contract.get_my_user_shop(String::from(context.1)).unwrap();
        let products = contract.list_user_shop_products(user_shop.id);
        assert_eq!(1, products.len());
        let test_product = products.get(0).unwrap();
        assert_eq!("Test Product".to_string(), test_product.name);
        assert_eq!(U128(1337), test_product.price);

        // Bug?
        // The quantity above is set to 0 and here the received quantity_on_stock is -1.
        // If we set the quantity above to 1, then it will be -2.
        // If we set the quantity to an unsigned integer u16 and the value to 0, then it will be 65535.
        assert_eq!(-1, !test_product.quantity_on_stock);
    }

    #[test]
    fn should_update_a_product_quantity() {
        let context = get_context(false);
        testing_env!(context.0);

        let mut contract = NearShop::initialize();
        contract.add_user_shop("Test Shop".to_string());
        contract.add_product("Test Product".to_string(), U128(1337), 0);
        let user_shop = contract.get_my_user_shop(String::from(context.1)).unwrap();
        let products = contract.list_user_shop_products(String::from(&user_shop.id));
        let test_product = products.get(0).unwrap();
        assert_eq!("Test Product".to_string(), test_product.name);
        assert_eq!(U128(1337), test_product.price);
        contract.update_product_quantity(String::from(&test_product.id), 1000);
        let updated_product = contract
            .get_user_shop_product(String::from(&user_shop.id), String::from(&test_product.id))
            .unwrap();
        assert_eq!(1000, updated_product.quantity_on_stock);
    }

    #[test]
    fn should_add_a_default_coupon_to_registered_shop() {
        let context = get_context(false);
        testing_env!(context.0);

        let mut contract = NearShop::initialize();
        contract.add_user_shop("Test Shop".to_string());
        contract.add_default_coupon("Test Coupon".to_string(), 13.37);
        let coupons = contract.list_my_user_shop_coupons(String::from(context.1));
        assert_eq!(1, coupons.len());
        let test_coupon = coupons.get(0).unwrap();
        assert_eq!("Test Coupon".to_string(), test_coupon.code);
        assert_eq!(13.37, test_coupon.discount_percentage);
    }

    #[test]
    fn should_add_a_one_time_specific_coupon_to_registered_shop() {
        let context = get_context(false);
        testing_env!(context.0);

        let mut contract = NearShop::initialize();
        contract.add_user_shop("Test Shop".to_string());
        contract.add_specific_coupon("Test Coupon".to_string(), 13.37, &vec![], None, true);
        let coupons = contract.list_my_user_shop_coupons(String::from(context.1));

        assert_eq!(1, coupons.len());
        let test_coupon = coupons.get(0).unwrap();
        assert_eq!("Test Coupon".to_string(), test_coupon.code);
        assert_eq!(13.37, test_coupon.discount_percentage);
        assert_eq!(true, test_coupon.applies_to_all_products);
        assert_eq!(true, test_coupon.applies_to_all_users);
        assert_eq!(true, test_coupon.is_one_time);
    }

    #[test]
    fn should_add_a_reusable_coupon_which_applies_to_one_user() {
        let context = get_context(false);
        testing_env!(context.0);

        let mut contract = NearShop::initialize();
        contract.add_user_shop("Test Shop".to_string());
        contract.add_specific_coupon(
            "Test Coupon".to_string(),
            13.37,
            &vec![],
            Some(env::signer_account_id()),
            false,
        );

        let coupons = contract.list_my_user_shop_coupons(String::from(context.1));
        assert_eq!(1, coupons.len());
        let test_coupon = coupons.get(0).unwrap();
        assert_eq!("Test Coupon".to_string(), test_coupon.code);
        assert_eq!(13.37, test_coupon.discount_percentage);
        assert_eq!(true, test_coupon.applies_to_all_products);
        assert_eq!(false, test_coupon.applies_to_all_users);
        assert_eq!(Some(env::signer_account_id()), test_coupon.applies_to_user);
        assert_eq!(false, test_coupon.is_one_time);
    }

    #[test]
    fn should_return_correct_cost_with_coupon() {
        let context = get_context(false);
        testing_env!(context.0);

        let mut contract = NearShop::initialize();
        contract.add_user_shop("Test Shop".to_string());
        contract.add_default_coupon("Test Coupon".to_string(), 50.00);
        contract.add_product("Test Product".to_string(), U128(10_000_000_000), 0);

        let user_shop = contract.get_my_user_shop(String::from(context.1)).unwrap();
        let products = contract.list_user_shop_products(String::from(&user_shop.id));
        let product = products.get(0).unwrap();

        let cost = contract.get_product_cost_using_coupon(
            String::from(&user_shop.id),
            String::from(&product.id),
            1,
            "Test Coupon".to_string(),
        );
        assert_eq!(U128(5_000_000_000), cost);
    }
}

'''
'''--- src/contract/src/contract/near_shop.rs ---
use crate::dto::product::ProductDto;
use crate::dto::user_shop::UserShopDto;
use crate::dto::{coupon::CouponDto, return_value::ReturnValue};
use near_sdk::{json_types::U128, AccountId, Promise};

pub trait NearShopContract {
    // Init
    fn initialize() -> Self;

    // Read methods
    fn return_custom_object(&self) -> ReturnValue<String>;
    fn get_my_user_shop(&self, user_account_id: String) -> Option<UserShopDto>;
    fn list_my_user_shop_products(&self, user_account_id: String) -> Vec<ProductDto>;
    fn list_all_user_shops(&self) -> Vec<UserShopDto>;
    fn get_user_shop(&self, user_shop_id: String) -> Option<UserShopDto>;
    fn list_user_shop_products(&self, user_shop_id: String) -> Vec<ProductDto>;
    fn get_user_shop_product(&self, user_shop_id: String, product_id: String)
        -> Option<ProductDto>;
    fn list_my_user_shop_coupons(&self, user_account_id: String) -> Vec<CouponDto>;
    fn get_product_cost_using_coupon(
        &self,
        user_shop_id: String,
        product_id: String,
        quantity: i32,
        coupon_code: String,
    ) -> U128;

    // Write methods
    fn add_user_shop(&mut self, name: String);
    fn add_product(&mut self, name: String, price: U128, quantity: i32);
    fn update_product_quantity(&mut self, product_id: String, quantity: i32);
    fn add_default_coupon(&mut self, code: String, discount_percentage: f32);
    fn add_specific_coupon(
        &mut self,
        code: String,
        discount_percentage: f32,
        applies_to_products: &Vec<String>,
        applies_to_user: Option<AccountId>,
        is_one_time: bool,
    );
    fn buy_product(
        &mut self,
        user_shop_id: String,
        product_id: String,
        quantity: i32,
        using_coupon_code: Option<String>,
    ) -> Promise;
}

'''
'''--- src/contract/src/dto/coupon.rs ---
use crate::dto::product::ProductDto;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::AccountId;

#[derive(Default, Deserialize, Serialize)]
pub struct CouponDto {
    pub id: String,
    pub code: String,
    pub discount_percentage: f32,
    pub applies_to_all_products: bool,
    pub applies_to_products: Vec<ProductDto>,
    pub applies_to_all_users: bool,
    pub applies_to_user: Option<AccountId>,
    pub is_one_time: bool,
    pub times_used: u32,
}

impl CouponDto {
    pub fn new(
        id: String,
        code: String,
        discount_percentage: f32,
        applies_to_all_products: bool,
        applies_to_products: Vec<ProductDto>,
        applies_to_all_users: bool,
        applies_to_user: Option<AccountId>,
        is_one_time: bool,
        times_used: u32,
    ) -> Self {
        Self {
            id,
            code,
            discount_percentage,
            applies_to_all_products,
            applies_to_products,
            applies_to_all_users,
            applies_to_user,
            is_one_time,
            times_used,
        }
    }
}

'''
'''--- src/contract/src/dto/mod.rs ---
pub mod coupon;
pub mod product;
pub mod return_value;
pub mod user_shop;

'''
'''--- src/contract/src/dto/product.rs ---
use near_sdk::{
    json_types::U128,
    serde::{Deserialize, Serialize},
};

#[derive(Deserialize, Serialize, Debug)]
pub struct ProductDto {
    pub id: String,
    pub name: String,
    pub price: U128,
    pub quantity_on_stock: i32,
}

impl ProductDto {
    pub fn new(id: String, name: String, price: u128, quantity_on_stock: i32) -> Self {
        Self {
            id,
            name,
            price: U128(price),
            quantity_on_stock,
        }
    }
}

'''
'''--- src/contract/src/dto/return_value.rs ---
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Default)]
pub struct ReturnValue<T>
where
    T: Default,
{
    pub result: T,
    pub success: bool,
}

'''
'''--- src/contract/src/dto/user_shop.rs ---
use near_sdk::serde::{Deserialize, Serialize};

#[derive(Deserialize, Serialize, Default)]
pub struct UserShopDto {
    pub id: String,
    pub name: String,
}

impl UserShopDto {
    pub fn new(id: String, name: String) -> Self {
        Self { id, name }
    }
}

'''
'''--- src/contract/src/lib.rs ---
mod contract;
pub mod dto;
mod model;
pub mod non_blockchain_model;
mod utils;

'''
'''--- src/contract/src/model/coupon.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{AccountId, PanicOnDefault};

use crate::utils::random_utils;

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault, Debug, Clone)]
pub struct Coupon {
    pub id: String,
    pub code: String,
    pub discount_percentage: f32,
    pub applies_to_all_products: bool,
    pub applies_to_products: Vec<String>,
    pub applies_to_all_users: bool,
    pub applies_to_user: Option<AccountId>,
    pub is_one_time: bool,
    pub times_used: u32,
}

impl Coupon {
    pub fn new(code: String, discount_percentage: f32) -> Self {
        Self {
            id: random_utils::get_random(),
            code,
            discount_percentage,
            applies_to_all_products: true,
            applies_to_products: vec![],
            applies_to_all_users: true,
            applies_to_user: None,
            is_one_time: false,
            times_used: 0,
        }
    }

    pub fn specific_new(
        code: String,
        discount_percentage: f32,
        applies_to_products: &Vec<String>,
        applies_to_user: Option<AccountId>,
        is_one_time: bool,
    ) -> Self {
        Self {
            id: random_utils::get_random(),
            code,
            discount_percentage,
            applies_to_all_products: applies_to_products.is_empty(),
            applies_to_products: applies_to_products.to_vec(),
            applies_to_all_users: applies_to_user.is_none(),
            applies_to_user,
            is_one_time,
            times_used: 0,
        }
    }
}

'''
'''--- src/contract/src/model/mod.rs ---
pub mod storage_keys;
pub mod coupon;
pub mod product;
pub mod user_shop;
'''
'''--- src/contract/src/model/product.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

use crate::utils::random_utils;

#[derive(Default, BorshDeserialize, BorshSerialize, Clone, PartialEq, Debug)]
pub struct Product {
    pub id: String,
    pub name: String,
    pub price: u128,
    pub quantity_on_stock: i32,
}

impl Product {
    pub fn new(name: String, price: u128, quantity_on_stock: i32) -> Self {
        Self {
            id: random_utils::get_random(),
            name,
            price,
            quantity_on_stock,
        }
    }
}

'''
'''--- src/contract/src/model/storage_keys.rs ---
use near_sdk::borsh::{self, BorshSerialize};
use near_sdk::BorshStorageKey;

#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKeys {
    UserShops,
    Products  { user_shop: Vec<u8> },
    Coupons { user_shop: Vec<u8> }
}
'''
'''--- src/contract/src/model/user_shop.rs ---
use crate::utils::random_utils;

use super::coupon::Coupon;
use super::product::Product;
use super::storage_keys::StorageKeys;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::Vector;
use near_sdk::{env, AccountId};

#[derive(BorshDeserialize, BorshSerialize, Debug)]
pub struct UserShop {
    pub id: String,
    pub name: String,
    pub owner_account_id: AccountId,
    pub products: Vector<Product>,
    pub coupons: Vector<Coupon>,
}

impl UserShop {
    pub fn new(name: String) -> Self {
        let id = random_utils::get_random();
        Self {
            id: String::from(&id),
            name,
            owner_account_id: env::predecessor_account_id(),
            products: Vector::new(StorageKeys::Products {
                user_shop: env::sha256(id.as_bytes()),
            }),
            coupons: Vector::new(StorageKeys::Coupons {
                user_shop: env::sha256(id.as_bytes()),
            }),
        }
    }
}

'''
'''--- src/contract/src/non_blockchain_model/favorite_product.rs ---
use chrono::NaiveDateTime;
use diesel::Queryable;

use crate::utils::random_utils;

#[derive(Queryable)]
pub struct FavoriteProduct {
    pub id: String,
    pub userid: String,
    pub product: String,
    pub timestamp: NaiveDateTime,
}

impl FavoriteProduct {
    pub fn new(user_id: &String, product_id: &String) -> Self {
        Self {
            id: random_utils::get_random(),
            userid: String::from(user_id),
            product: String::from(product_id),
            timestamp: chrono::offset::Utc::now().naive_utc(),
        }
    }
}

'''
'''--- src/contract/src/non_blockchain_model/favorite_shop.rs ---
use chrono::NaiveDateTime;
use diesel::Queryable;

use crate::utils::random_utils;

#[derive(Queryable)]
pub struct FavoriteShop {
    pub id: String,
    pub userid: String,
    pub shop: String,
    pub timestamp: NaiveDateTime,
}

impl FavoriteShop {
    pub fn new(user_id: &String, shop_id: &String) -> Self {
        Self {
            id: random_utils::get_random(),
            userid: String::from(user_id),
            shop: String::from(shop_id),
            timestamp: chrono::offset::Utc::now().naive_utc(),
        }
    }
}

'''
'''--- src/contract/src/non_blockchain_model/mod.rs ---
pub mod favorite_product;
pub mod favorite_shop;
pub mod purchase;
pub mod wishlisted_product;

'''
'''--- src/contract/src/non_blockchain_model/purchase.rs ---
use chrono::NaiveDateTime;
use diesel::Queryable;

use crate::utils::random_utils;

#[derive(Queryable)]
pub struct Purchase {
    pub id: String,
    pub userid: String,
    pub product: String,
    pub shop: String,
    pub timestamp: NaiveDateTime,
}

impl Purchase {
    pub fn new(user_id: String, product_id: String, shop_id: String) -> Self {
        Self {
            id: random_utils::get_random(),
            userid: String::from(user_id),
            product: String::from(product_id),
            shop: String::from(shop_id),
            timestamp: chrono::offset::Utc::now().naive_utc(),
        }
    }
}

'''
'''--- src/contract/src/non_blockchain_model/wishlisted_product.rs ---
use chrono::NaiveDateTime;
use diesel::Queryable;

use crate::utils::random_utils;

#[derive(Queryable)]
pub struct WishlistedProduct {
    pub id: String,
    pub userid: String,
    pub product: String,
    pub timestamp: NaiveDateTime,
}

impl WishlistedProduct {
    pub fn new(user_id: &String, product_id: &String) -> Self {
        Self {
            id: random_utils::get_random(),
            userid: String::from(user_id),
            product: String::from(product_id),
            timestamp: chrono::offset::Utc::now().naive_utc(),
        }
    }
}

'''
'''--- src/contract/src/schema.rs ---
table! {
    favoriteproducts (id) {
        id -> Varchar,
        userid -> Varchar,
        product -> Varchar,
        timestamp -> Timestamp,
    }
}

table! {
    favoriteshops (id) {
        id -> Varchar,
        userid -> Varchar,
        shop -> Varchar,
        timestamp -> Timestamp,
    }
}

table! {
    purchases (id) {
        id -> Varchar,
        userid -> Varchar,
        product -> Varchar,
        shop -> Varchar,
        timestamp -> Timestamp,
    }
}

table! {
    wishlist (id) {
        id -> Varchar,
        userid -> Varchar,
        product -> Varchar,
        timestamp -> Timestamp,
    }
}

allow_tables_to_appear_in_same_query!(
    favoriteproducts,
    favoriteshops,
    purchases,
    wishlist,
);

'''
'''--- src/contract/src/utils/mod.rs ---
pub mod random_utils;
pub mod vector_utils;

'''
'''--- src/contract/src/utils/random_utils.rs ---
#[cfg(target_family = "wasm")]
use near_sdk::env;

#[cfg(target_family = "wasm")]
pub fn get_random() -> String {
    let letters_array = [
        "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R",
        "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j",
        "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1",
        "2", "3", "4", "5", "6", "7", "8", "9",
    ];
    let random_array = env::random_seed_array();
    let mut return_value = String::new();
    for number in random_array {
        return_value += letters_array[(number % 62) as usize];
    }

    return_value
}

#[cfg(not(target_family = "wasm"))]
pub fn get_random() -> String {
    let letters_array = [
        "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R",
        "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j",
        "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1",
        "2", "3", "4", "5", "6", "7", "8", "9",
    ];

    let mut return_value = String::new();
    for _ in letters_array {
        return_value += letters_array[(fastrand::usize(..letters_array.len())) as usize];
    }

    return_value
}

'''
'''--- src/contract/src/utils/vector_utils.rs ---
pub trait VectorUtils<T>
where
    T: Clone,
{
    fn intersect_with_ids<F1: Fn(&T) -> String, F2: Fn(&String, &String) -> bool>(
        &self,
        id_selector: F1,
        ids: &Vec<String>,
        validator: F2,
    ) -> Self;
}

impl<T> VectorUtils<T> for Vec<T>
where
    T: Clone,
{
    fn intersect_with_ids<F1: Fn(&T) -> String, F2: Fn(&String, &String) -> bool>(
        &self,
        id_selector: F1,
        ids: &Vec<String>,
        validator: F2,
    ) -> Self {
        let mut out: Self = vec![];
        let length = ids.len();
        for item in self.iter() {
            for i in 0..length {
                let source_id = id_selector(item);
                if validator(&source_id, &ids[i]) {
                    out.push(item.clone());
                    break;
                }
            }
        }

        out
    }
}

mod tests {
    #[test]
    fn intersect_with_ids_returns_correctly() {
        let product1 = crate::model::product::Product::new("Product1".to_string(), 0, 0);
        let product2 = crate::model::product::Product::new("Product2".to_string(), 0, 0);
        let product3 = crate::model::product::Product::new("Product2".to_string(), 0, 0);
        let products = vec![product1.clone(), product2.clone(), product3.clone()];

        let ids = vec![String::from(&product2.id), String::from(&product1.id)];
        let intersection = crate::utils::vector_utils::VectorUtils::intersect_with_ids(
            &products,
            |x| String::from(&x.id),
            &ids,
            |left, right| left == right,
        );
        assert_eq!(2, intersection.len());
    }
}

'''
'''--- src/integration-tests/Cargo.toml ---
[package]
name = "integration-tests"
version = "1.0.0"
publish = false
edition = "2018"

[dev-dependencies]
anyhow = "1.0"
borsh = "0.9"
maplit = "1.0"
near-units = "0.2.0"
# arbitrary_precision enabled for u128 types that workspaces requires for Balance types
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
tokio = { version = "1.18.1", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3.11", features = ["env-filter"] }
workspaces = "0.3.1"
pkg-config = "0.3.1"
shop = { path = "../contract"}
near-sdk = "4.0.0"

[[example]]
name = "integration-tests"
path = "src/tests.rs"

'''
'''--- src/integration-tests/src/tests.rs ---
use anyhow::Error;
use near_sdk::json_types::U128;
use near_units::parse_near;
use serde_json::json;
use shop::dto::product::ProductDto;
use shop::dto::user_shop::UserShopDto;
use std::{env, fs};
use workspaces::prelude::*;
use workspaces::{network::Sandbox, Account, Contract, Worker};

const WASM_FILEPATH: &str = "../contract/target/wasm32-unknown-unknown/release/shop.wasm";

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let wasm_arg = WASM_FILEPATH;
    let wasm_filepath = fs::canonicalize(env::current_dir()?.join(wasm_arg))?;

    let worker = workspaces::sandbox().await?;
    let wasm = std::fs::read(wasm_filepath)?;
    let contract = worker.dev_deploy(&wasm).await?;

    // create accounts
    let account = worker.dev_create_account().await?;
    let alice = account
        .create_subaccount(&worker, "alice")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;

    test_created_shop_with_two_products(&alice, &contract, &worker).await?;
    Ok(())
}

async fn test_created_shop_with_two_products(
    user: &Account,
    contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    // Initialize the contract
    user.call(&worker, contract.id(), "initialize")
        .transact()
        .await?;

    // Get the user shop
    let mut user_shop: Result<UserShopDto, Error> = user
        .call(&worker, contract.id(), "get_my_user_shop")
        .args_json(json!({ "user_account_id": user.id()}))?
        .transact()
        .await?
        .json();

    // If it doesn't exist, create one
    if user_shop.is_err() {
        user.call(&worker, contract.id(), "add_user_shop")
            .args_json(json!({ "name": "Alice"}))?
            .transact()
            .await?;

        user_shop = user
            .call(&worker, contract.id(), "get_my_user_shop")
            .args_json(json!({ "user_account_id": user.id()}))?
            .transact()
            .await?
            .json::<UserShopDto>();
    }

    let unwrapped_user_shop = user_shop?;

    // Assert the shop is created successfully
    assert_eq!("Alice", unwrapped_user_shop.name);

    // Create two products
    user.call(&worker, contract.id(), "add_product")
        .args_json(json!({ "name": "Product 1", "price": U128(100000), "quantity": 10}))?
        .transact()
        .await?;

    user.call(&worker, contract.id(), "add_product")
        .args_json(json!({ "name": "Product 2", "price": U128(200000), "quantity": 5}))?
        .transact()
        .await?;

    let products: Vec<ProductDto> = user
        .call(&worker, contract.id(), "list_user_shop_products")
        .args_json(json!({ "user_shop_id": unwrapped_user_shop.id}))?
        .transact()
        .await?
        .json()?;

    assert_eq!(2, products.len());

    let product1 = &products[0];
    let product2 = &products[1];

    assert_eq!("Product 1".to_string(), product1.name);
    assert_eq!("Product 2".to_string(), product2.name);

    assert_eq!(U128(100000), product1.price);
    assert_eq!(U128(200000), product2.price);

    assert_eq!(10, product1.quantity_on_stock);
    assert_eq!(5, product2.quantity_on_stock);
    println!("      Passed ✅ Created two products");
    Ok(())
}

'''
'''--- src/neardev/dev-account.env ---
CONTRACT_NAME=dev-1660917977704-82001760711942
'''
'''--- src/package.json ---
{
  "name": "test-near-shop",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "deploy": "npm run build:contract && cd contract && near dev-deploy --wasmFile ./target/wasm32-unknown-unknown/release/shop.wasm",
    "build": "npm run build:contract",
    "build:contract": "cd contract && rustup target add wasm32-unknown-unknown && cargo build --all --target wasm32-unknown-unknown --release",
    "test": "npm run test:unit && npm run test:integration",
    "test:unit": "cd contract && cargo test",
    "test:integration": "npm run build:contract && cd integration-tests && cargo run --example integration-tests \"../contract/target/wasm32-unknown-unknown/release/shop.wasm\"",
    "deps-install": "npm install"
  },
  "devDependencies": {
    "near-cli": "^3.3.0"
  },
  "dependencies": {}
}
'''