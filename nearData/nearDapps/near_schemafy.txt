*GitHub Repository "near/schemafy"*

'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- .travis.yml ---
language: rust
sudo: false
rust:
- nightly
- beta
- stable
script:
- cargo run --bin generate-tests --features="generate-tests"
- cargo test --all
env:
  global:
  - RUST_BACKTRACE=1

'''
'''--- Cargo.toml ---
[package]
name = "near-schemafy"
version = "0.7.0" # VERSION_TAG
authors = ["Markus Westerlind <marwes91@gmail.com>", "Near Inc <hello@nearprotocol.com>"]
edition = "2018"

description = "Generates serializeable Rust types from a json schema"
license = "MIT"
keywords = ["json-schema", "code-generation"]
repository = "https://github.com/near/schemafy"
documentation = "https://docs.rs/near-schemafy"

[lib]
proc-macro = true

[[bin]]
name = "generate-tests"
path = "src/generate_tests.rs"
required-features = ["generate-tests"]

[[bin]]
name = "near-schemafy"
path = "src/main.rs"
required-features = ["tool"]

[workspace]

[dependencies]
anyhow = { version = "1", optional = true }
schemafy_core = { version = "0.7.0", path = "schemafy_core", package = "near_schemafy_core" } # VERSION_TAG
schemafy_lib = { version = "0.7.0", path = "schemafy_lib", package = "near_schemafy_lib" }   # VERSION_TAG
serde = "1.0"
serde_json = "1.0"
serde_derive = "1.0"
serde_repr = "0.1.7"
structopt = { version = "0.3", optional = true }
syn = "1.0"
tempfile = { version = "3", optional = true }

Inflector = "0.11"

[build-dependencies]
schemafy_core = { version = "0.7.0", path = "schemafy_core", package = "near_schemafy_core" } # VERSION_TAG
schemafy_lib = { version = "0.7.0", path = "schemafy_lib", package = "near_schemafy_lib" }   # VERSION_TAG

[features]
internal-regenerate = []
generate-tests = []
tool = ["anyhow", "structopt", "tempfile"]

'''
'''--- README.md ---
# schemafy

[![Build Status](https://travis-ci.org/Marwes/schemafy.svg?branch=master)](https://travis-ci.org/Marwes/schemafy)
[![Docs](https://docs.rs/schemafy/badge.svg)](https://docs.rs/schemafy)

This is a Rust crate which can take a [JSON schema (draft 4)](http://json-schema.org/) and generate Rust types which are serializable with [serde](https://serde.rs/). No checking such as `min_value` are done but instead only the structure of the schema is followed as closely as possible.

As a schema could be arbitrarily complex this crate makes no guarantee that it can generate good types or even any types at all for a given schema but the crate does manage to bootstrap itself which is kind of cool.

## Example

Generated types for VS Codes [debug server protocol][]: <https://docs.rs/debugserver-types>

[debug server protocol]:https://code.visualstudio.com/docs/extensions/example-debuggers

## Development

The types generated by the JSON schema specification can be regenerated with `cargo build --features internal-regenerate` if changes have been made in the library itself. Rustfmt is required so that `src/schema.rs` is readable.

'''
'''--- build.rs ---
fn main() {
    if cfg!(feature = "internal-regenerate") {
        let schema_path = "schemafy_lib/src/schema.json";
        schemafy_lib::Generator::builder()
            .with_root_name_str("Schema")
            .with_input_file(schema_path)
            .build()
            .generate_to_file("schemafy_lib/src/schema.rs")
            .unwrap();
    }
}

'''
'''--- publish.sh ---
#!/bin/sh

(./version.sh $@ &&
    (cd schemafy_core && cargo publish) &&
    sleep 25 &&
    (cd schemafy_lib && cargo publish) &&
    sleep 25 &&
    cargo publish)

'''
'''--- schemafy_core/Cargo.toml ---
[package]
name = "near_schemafy_core"
version = "0.7.0" # VERSION_TAG
authors = ["Markus Westerlind <marwes91@gmail.com>", "Near Inc <hello@nearprotocol.com>"]
edition = "2018"

description = "Generates serializeable Rust types from a json schema"
license = "MIT"

repository = "https://github.com/near/schemafy"
documentation = "https://docs.rs/schemafy-near"

[dependencies]
serde = { version = "1", features = ["derive"] }
serde_json = "1"

'''
'''--- schemafy_core/src/lib.rs ---
pub mod one_or_many;

'''
'''--- schemafy_core/src/one_or_many.rs ---
pub type OneOrMany<T> = Vec<T>;

pub fn deserialize<'de, T, D>(deserializer: D) -> Result<Vec<T>, D::Error>
where
    T: serde::Deserialize<'de>,
    D: serde::Deserializer<'de>,
{
    use std::fmt;
    use std::marker::PhantomData;

    use serde::de::value::{MapAccessDeserializer, SeqAccessDeserializer};
    use serde::de::{self, Deserialize, IntoDeserializer};

    struct OneOrManyDeserializer<T>(PhantomData<T>);
    impl<'de2, T> serde::de::Visitor<'de2> for OneOrManyDeserializer<T>
    where
        T: Deserialize<'de2>,
    {
        type Value = Vec<T>;

        fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
            formatter.write_str("one or many")
        }

        fn visit_i64<E>(self, value: i64) -> Result<Vec<T>, E>
        where
            E: de::Error,
        {
            Deserialize::deserialize(value.into_deserializer()).map(|v| vec![v])
        }

        fn visit_u64<E>(self, value: u64) -> Result<Vec<T>, E>
        where
            E: de::Error,
        {
            Deserialize::deserialize(value.into_deserializer()).map(|v| vec![v])
        }

        fn visit_str<E>(self, value: &str) -> Result<Vec<T>, E>
        where
            E: de::Error,
        {
            Deserialize::deserialize(value.into_deserializer()).map(|v| vec![v])
        }

        fn visit_string<E>(self, value: String) -> Result<Vec<T>, E>
        where
            E: de::Error,
        {
            Deserialize::deserialize(value.into_deserializer()).map(|v| vec![v])
        }

        fn visit_map<V>(self, visitor: V) -> Result<Self::Value, V::Error>
        where
            V: serde::de::MapAccess<'de2>,
        {
            Deserialize::deserialize(MapAccessDeserializer::new(visitor)).map(|v| vec![v])
        }

        fn visit_seq<V>(self, visitor: V) -> Result<Self::Value, V::Error>
        where
            V: serde::de::SeqAccess<'de2>,
        {
            Deserialize::deserialize(SeqAccessDeserializer::new(visitor))
        }
    }
    deserializer.deserialize_any(OneOrManyDeserializer(PhantomData::<T>))
}

pub fn serialize<T, S>(value: &[T], serializer: S) -> Result<S::Ok, S::Error>
where
    T: serde::Serialize,
    S: serde::Serializer,
{
    use serde::Serialize;
    if value.len() == 1 {
        value[0].serialize(serializer)
    } else {
        value.serialize(serializer)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use serde::{Deserialize, Serialize};
    use serde_json::from_str;

    #[derive(PartialEq, Debug, Deserialize, Serialize)]
    struct OneOrMany<T>(
        #[serde(serialize_with = "serialize", deserialize_with = "deserialize")] Vec<T>,
    )
    where
        T: for<'de2> Deserialize<'de2> + Serialize;

    #[test]
    fn deserialize_one_int() {
        assert_eq!(from_str::<OneOrMany<i32>>("1").unwrap(), OneOrMany(vec![1]));
    }

    #[test]
    fn deserialize_many_int() {
        assert_eq!(
            from_str::<OneOrMany<i32>>("[1, 2, 3]").unwrap(),
            OneOrMany(vec![1, 2, 3])
        );
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    struct Test {
        x: i32,
        y: Option<String>,
    }

    #[test]
    fn deserialize_one_struct() {
        assert_eq!(
            from_str::<OneOrMany<Test>>(r#"{ "x" : 10, "y" : "test" }"#).unwrap(),
            OneOrMany(vec![Test {
                x: 10,
                y: Some("test".to_string()),
            },])
        );
    }

    #[test]
    fn deserialize_one_struct_missing_field() {
        assert_eq!(
            from_str::<OneOrMany<Test>>(r#"{ "x" : 10 }"#).unwrap(),
            OneOrMany(vec![Test { x: 10, y: None }])
        );
    }

    #[test]
    fn deserialize_many_struct() {
        assert_eq!(
            from_str::<OneOrMany<Test>>(r#"[{ "x" : 10 }, { "x" : 0, "y" : "a" }]"#).unwrap(),
            OneOrMany(vec![
                Test { x: 10, y: None },
                Test {
                    x: 0,
                    y: Some("a".to_string()),
                },
            ])
        );
    }
}

'''
'''--- schemafy_lib/Cargo.toml ---
[package]
name = "near_schemafy_lib"
version = "0.7.0" # VERSION_TAG
authors = ["Markus Westerlind <marwes91@gmail.com>", "MATILLAT Quentin <qmatillat@gmail.com>", "Near Inc <hello@nearprotocol.com>"]
edition = "2018"

description = "Generates serializeable Rust types from a json schema"
license = "MIT"

repository = "https://github.com/near/schemafy"
documentation = "https://docs.rs/schemafy-near"

[dependencies]
proc-macro2 = "1.0"
quote = "1.0"
schemafy_core = { version = "0.7.0", path = "../schemafy_core", package = "near_schemafy_core" } # VERSION_TAG
serde = "1.0"
serde_json = "1.0"
serde_derive = "1.0"
syn = "1.0"
uriparse = "0.6"

Inflector = "0.11"

'''
'''--- schemafy_lib/src/generator.rs ---
use crate::{Expander, Schema};
use std::{
    io,
    path::{Path, PathBuf},
};

#[derive(Debug, PartialEq)]
pub enum Input<'a> {
    /// The JSON Schema file to read
    File(&'a Path),
    /// The JSON string to interpret, mutually exclusive with `input_file`
    Json(&'a str),
}

/// A configurable builder for generating Rust types from a JSON
/// schema.
///
/// The default options are usually fine. In that case, you can use
/// the [`generate()`](fn.generate.html) convenience method instead.
#[derive(Debug, PartialEq)]
#[must_use]
pub struct Generator<'a, 'b> {
    /// The name of the root type defined by the schema. If the schema
    /// does not define a root type (some schemas are simply a
    /// collection of definitions) then simply pass `None`.
    pub root_name: Option<String>,
    /// The module path to this crate. Some generated code may make
    /// use of types defined in this crate. Unless you have
    /// re-exported this crate or imported it under a different name,
    /// the default should be fine.
    pub schemafy_path: &'a str,
    /// The input to interpret as JSON Schema
    pub input: Input<'b>,
}

impl<'a, 'b> Generator<'a, 'b> {
    /// Get a builder for the Generator
    pub fn builder() -> GeneratorBuilder<'a, 'b> {
        GeneratorBuilder::default()
    }

    pub fn generate_with_schema(&self) -> (proc_macro2::TokenStream, Schema) {
        let schema = match self.input {
            Input::File(input_file) => {
                let input_file = if input_file.is_relative() {
                    let crate_root = get_crate_root().unwrap();
                    crate_root.join(input_file)
                } else {
                    PathBuf::from(input_file)
                };

                let json = std::fs::read_to_string(&input_file).unwrap_or_else(|err| {
                    panic!("Unable to read `{}`: {}", input_file.to_string_lossy(), err)
                });
                serde_json::from_str(&json)
                    .unwrap_or_else(|err| panic!("Cannot parse input as JSON: {}", err))
            }
            Input::Json(input_json) => serde_json::from_str(input_json)
                .unwrap_or_else(|err| panic!("Cannot parse input as JSON: {}", err)),
        };

        let mut expander = Expander::new(self.root_name.as_deref(), self.schemafy_path, &schema);
        let token_stream = expander.expand(&schema);
        (token_stream, schema)
    }

    pub fn generate(&self) -> proc_macro2::TokenStream {
        self.generate_with_schema().0
    }

    pub fn generate_to_file<P: ?Sized + AsRef<Path>>(&self, output_file: &'b P) -> io::Result<()> {
        use std::process::Command;
        let tokens = self.generate();
        let out = tokens.to_string();
        std::fs::write(output_file, &out)?;
        Command::new("rustfmt")
            .arg(output_file.as_ref().as_os_str())
            .output()?;
        Ok(())
    }
}

#[derive(Debug, PartialEq)]
#[must_use]
pub struct GeneratorBuilder<'a, 'b> {
    inner: Generator<'a, 'b>,
}

impl<'a, 'b> Default for GeneratorBuilder<'a, 'b> {
    fn default() -> Self {
        Self {
            inner: Generator {
                root_name: None,
                schemafy_path: "::schemafy_core::",
                input: Input::File(Path::new("schema.json")),
            },
        }
    }
}

impl<'a, 'b> GeneratorBuilder<'a, 'b> {
    pub fn with_root_name(mut self, root_name: Option<String>) -> Self {
        self.inner.root_name = root_name;
        self
    }
    pub fn with_root_name_str(mut self, root_name: &str) -> Self {
        self.inner.root_name = Some(root_name.to_string());
        self
    }
    pub fn with_input_file<P: ?Sized + AsRef<Path>>(mut self, input_file: &'b P) -> Self {
        self.inner.input = Input::File(input_file.as_ref());
        self
    }
    pub fn with_input_json(mut self, input_json: &'b str) -> Self {
        self.inner.input = Input::Json(input_json);
        self
    }
    pub fn with_schemafy_path(mut self, schemafy_path: &'a str) -> Self {
        self.inner.schemafy_path = schemafy_path;
        self
    }
    pub fn build(self) -> Generator<'a, 'b> {
        self.inner
    }
}

fn get_crate_root() -> std::io::Result<PathBuf> {
    if let Ok(path) = std::env::var("CARGO_MANIFEST_DIR") {
        return Ok(PathBuf::from(path));
    }

    let current_dir = std::env::current_dir()?;

    for p in current_dir.ancestors() {
        if std::fs::read_dir(p)?
            .into_iter()
            .filter_map(Result::ok)
            .any(|p| p.file_name().eq("Cargo.toml"))
        {
            return Ok(PathBuf::from(p));
        }
    }

    Ok(current_dir)
}

'''
'''--- schemafy_lib/src/lib.rs ---
// This would be nice once it stabilizes:
// https://github.com/rust-lang/rust/issues/44732
// #![feature(external_doc)]
// #![doc(include = "../README.md")]

//! This is a Rust crate which can take a [json schema (draft
//! 4)](http://json-schema.org/) and generate Rust types which are
//! serializable with [serde](https://serde.rs/). No checking such as
//! `min_value` are done but instead only the structure of the schema
//! is followed as closely as possible.
//!
//! As a schema could be arbitrarily complex this crate makes no
//! guarantee that it can generate good types or even any types at all
//! for a given schema but the crate does manage to bootstrap itself
//! which is kind of cool.
//!
//! ## Example
//!
//! Generated types for VS Codes [debug server protocol][]: <https://docs.rs/debugserver-types>
//!
//! [debug server protocol]:https://code.visualstudio.com/docs/extensions/example-debuggers
//!
//! ## Usage
//!
//! Rust code is generated by providing a [`Schema`](./struct.Schema.html) struct (which can be deserialized from JSON).
//!
//! A proc macro is available in [`schemafy`](https://docs.rs/schemafy) crate
//!
//! ```rust
//! extern crate serde;
//! extern crate schemafy_core;
//! extern crate serde_json;
//!
//! use serde::{Serialize, Deserialize};
//! use schemafy_lib::Expander;
//!
//! let json = std::fs::read_to_string("src/schema.json").expect("Read schema JSON file");
//!
//! let schema = serde_json::from_str(&json).unwrap();
//! let mut expander = Expander::new(
//!     Some("Schema"),
//!     "::schemafy_core::",
//!     &schema,
//! );
//!
//! let code = expander.expand(&schema);
//! ```

#[macro_use]
extern crate serde_derive;

#[macro_use]
extern crate quote;

pub mod generator;

/// Types from the JSON Schema meta-schema (draft 4).
///
/// This module is itself generated from a JSON schema.
mod schema;

use std::{borrow::Cow, convert::TryFrom};

use inflector::Inflector;

use serde_json::Value;

use uriparse::{Fragment, URI};

pub use schema::{Schema, SimpleTypes};

pub use generator::{Generator, GeneratorBuilder};

use proc_macro2::{Span, TokenStream};

fn replace_invalid_identifier_chars(s: &str) -> String {
    s.strip_prefix('$')
        .unwrap_or(s)
        .replace(|c: char| !c.is_alphanumeric() && c != '_', "_")
}

fn replace_numeric_start(s: &str) -> String {
    if s.chars().next().map(|c| c.is_numeric()).unwrap_or(false) {
        format!("_{}", s)
    } else {
        s.to_string()
    }
}

fn remove_excess_underscores(s: &str) -> String {
    let mut result = String::new();
    let mut char_iter = s.chars().peekable();

    while let Some(c) = char_iter.next() {
        let next_c = char_iter.peek();
        if c != '_' || !matches!(next_c, Some('_')) {
            result.push(c);
        }
    }

    result
}

pub fn str_to_ident(s: &str) -> syn::Ident {
    if s.is_empty() {
        return syn::Ident::new("empty_", Span::call_site());
    }

    if s.chars().all(|c| c == '_') {
        return syn::Ident::new("underscore_", Span::call_site());
    }

    let s = replace_invalid_identifier_chars(s);
    let s = replace_numeric_start(&s);
    let s = remove_excess_underscores(&s);

    if s.is_empty() {
        return syn::Ident::new("invalid_", Span::call_site());
    }

    let keywords = [
        "as", "break", "const", "continue", "crate", "else", "enum", "extern", "false", "fn",
        "for", "if", "impl", "in", "let", "loop", "match", "mod", "move", "mut", "pub", "ref",
        "return", "self", "static", "struct", "super", "trait", "true", "type", "unsafe", "use",
        "where", "while", "abstract", "become", "box", "do", "final", "macro", "override", "priv",
        "typeof", "unsized", "virtual", "yield", "async", "await", "try",
    ];
    if keywords.iter().any(|&keyword| keyword == s) {
        return syn::Ident::new(&format!("{}_", s), Span::call_site());
    }

    syn::Ident::new(&s, Span::call_site())
}

fn rename_keyword(prefix: &str, s: &str) -> Option<TokenStream> {
    let n = str_to_ident(s);

    if n == s {
        return None;
    }

    if prefix.is_empty() {
        Some(quote! {
            #[serde(rename = #s)]
            #n
        })
    } else {
        let prefix = syn::Ident::new(prefix, Span::call_site());
        Some(quote! {
            #[serde(rename = #s)]
            #prefix #n
        })
    }
}

fn field(s: &str) -> TokenStream {
    if let Some(t) = rename_keyword("pub", s) {
        return t;
    }
    let snake = s.to_snake_case();
    if snake == s && !snake.contains(|c: char| c == '$' || c == '#') {
        let field = syn::Ident::new(s, Span::call_site());
        return quote!( pub #field );
    }

    let field = if snake.is_empty() {
        syn::Ident::new("underscore", Span::call_site())
    } else {
        str_to_ident(&snake)
    };

    quote! {
        #[serde(rename = #s)]
        pub #field
    }
}

fn merge_option<T, F>(mut result: &mut Option<T>, r: &Option<T>, f: F)
where
    F: FnOnce(&mut T, &T),
    T: Clone,
{
    *result = match (&mut result, r) {
        (&mut &mut Some(ref mut result), &Some(ref r)) => return f(result, r),
        (&mut &mut None, &Some(ref r)) => Some(r.clone()),
        _ => return,
    };
}

fn merge_all_of(result: &mut Schema, r: &Schema) {
    use std::collections::btree_map::Entry;

    for (k, v) in &r.properties {
        match result.properties.entry(k.clone()) {
            Entry::Vacant(entry) => {
                entry.insert(v.clone());
            }
            Entry::Occupied(mut entry) => merge_all_of(entry.get_mut(), v),
        }
    }

    if let Some(ref ref_) = r.ref_ {
        result.ref_ = Some(ref_.clone());
    }

    if let Some(ref description) = r.description {
        result.description = Some(description.clone());
    }

    merge_option(&mut result.required, &r.required, |required, r_required| {
        required.extend(r_required.iter().cloned());
    });

    result.type_.retain(|e| r.type_.contains(e));
}

const LINE_LENGTH: usize = 100;
const INDENT_LENGTH: usize = 4;

fn make_doc_comment(mut comment: &str, remaining_line: usize) -> TokenStream {
    let mut out_comment = String::new();
    out_comment.push_str("/// ");
    let mut length = 4;
    while let Some(word) = comment.split(char::is_whitespace).next() {
        if comment.is_empty() {
            break;
        }
        comment = &comment[word.len()..];
        if length + word.len() >= remaining_line {
            out_comment.push_str("\n/// ");
            length = 4;
        }
        out_comment.push_str(word);
        length += word.len();
        let mut n = comment.chars();
        match n.next() {
            Some('\n') => {
                out_comment.push('\n');
                out_comment.push_str("/// ");
                length = 4;
            }
            Some(_) => {
                out_comment.push(' ');
                length += 1;
            }
            None => (),
        }
        comment = n.as_str();
    }
    if out_comment.ends_with(' ') {
        out_comment.pop();
    }
    out_comment.push('\n');
    out_comment.parse().unwrap()
}

struct FieldExpander<'a, 'r: 'a> {
    default: bool,
    expander: &'a mut Expander<'r>,
}

impl<'a, 'r> FieldExpander<'a, 'r> {
    fn expand_fields(&mut self, type_name: &str, schema: &Schema) -> Vec<TokenStream> {
        let schema = self.expander.schema(schema);
        schema
            .properties
            .iter()
            .map(|(field_name, value)| {
                self.expander.current_field.clone_from(field_name);
                let key = field(field_name);
                let required = schema
                    .required
                    .iter()
                    .flat_map(|a| a.iter())
                    .any(|req| req == field_name);
                let field_type = self.expander.expand_type(type_name, required, value);
                if !field_type.typ.starts_with("Option<") {
                    self.default = false;
                }
                let typ = field_type.typ.parse::<TokenStream>().unwrap();

                let default = if field_type.default {
                    Some(quote! { #[serde(default)] })
                } else {
                    None
                };
                let attributes = if field_type.attributes.is_empty() {
                    None
                } else {
                    let attributes = field_type
                        .attributes
                        .iter()
                        .map(|attr| attr.parse::<TokenStream>().unwrap());
                    Some(quote! {
                        #[serde( #(#attributes),* )]
                    })
                };
                let comment = value
                    .description
                    .as_ref()
                    .map(|comment| make_doc_comment(comment, LINE_LENGTH - INDENT_LENGTH));
                quote! {
                    #comment
                    #default
                    #attributes
                    #key : #typ
                }
            })
            .collect()
    }
}

pub struct Expander<'r> {
    root_name: Option<&'r str>,
    schemafy_path: &'r str,
    root: &'r Schema,
    current_type: String,
    current_field: String,
    types: Vec<(String, TokenStream)>,
}

pub struct FieldType {
    pub typ: String,
    pub attributes: Vec<String>,
    pub default: bool,
}

impl<S> From<S> for FieldType
where
    S: Into<String>,
{
    fn from(s: S) -> FieldType {
        FieldType {
            typ: s.into(),
            attributes: Vec::new(),
            default: false,
        }
    }
}

impl<'r> Expander<'r> {
    pub fn new(
        root_name: Option<&'r str>,
        schemafy_path: &'r str,
        root: &'r Schema,
    ) -> Expander<'r> {
        Expander {
            root_name,
            root,
            schemafy_path,
            current_field: "".into(),
            current_type: "".into(),
            types: Vec::new(),
        }
    }

    fn type_ref(&self, s: &str) -> String {
        // ref is supposed to be be a valid URI, however we should better have a fallback plan
        let fragment = URI::try_from(s)
            .map(|uri| uri.fragment().map(Fragment::to_owned))
            .ok()
            .flatten()
            .or({
                let s = s.strip_prefix('#').unwrap_or(s);
                Fragment::try_from(s).ok()
            })
            .map(|fragment| fragment.to_string())
            .unwrap_or_else(|| s.to_owned());

        let ref_ = if fragment.is_empty() {
            self.root_name.expect("No root name specified for schema")
        } else {
            fragment.split('/').last().expect("Component")
        };

        let ref_ = ref_.to_pascal_case();
        let ref_ = replace_invalid_identifier_chars(&ref_);
        replace_numeric_start(&ref_)
    }

    fn schema(&self, schema: &'r Schema) -> Cow<'r, Schema> {
        let schema = match schema.ref_ {
            Some(ref ref_) => self.schema_ref(ref_),
            None => schema,
        };
        match schema.all_of {
            Some(ref all_of) if !all_of.is_empty() => {
                all_of
                    .iter()
                    .skip(1)
                    .fold(self.schema(&all_of[0]).clone(), |mut result, def| {
                        merge_all_of(result.to_mut(), &self.schema(def));
                        result
                    })
            }
            _ => Cow::Borrowed(schema),
        }
    }

    fn schema_ref(&self, s: &str) -> &'r Schema {
        s.split('/').fold(self.root, |schema, comp| {
            if comp.ends_with('#') {
                self.root
            } else if comp == "definitions" {
                schema
            } else {
                schema
                    .definitions
                    .get(comp)
                    .unwrap_or_else(|| panic!("Expected definition: `{}` {}", s, comp))
            }
        })
    }

    fn expand_type(&mut self, type_name: &str, required: bool, typ: &Schema) -> FieldType {
        let saved_type = self.current_type.clone();
        let mut result = self.expand_type_from_schema(typ);
        self.current_type = saved_type;
        if type_name.to_pascal_case() == result.typ.to_pascal_case() {
            result.typ = format!("Box<{}>", result.typ)
        }
        if !required {
            if !result.default {
                result.typ = format!("Option<{}>", result.typ);
            }
            if result.typ.starts_with("Option<") {
                result
                    .attributes
                    .push("skip_serializing_if=\"Option::is_none\"".into());
            }
        }
        result
    }

    pub fn expand_type_from_schema(&mut self, typ: &Schema) -> FieldType {
        if let Some(ref ref_) = typ.ref_ {
            self.type_ref(ref_).into()
        } else if typ.any_of.as_ref().map_or(false, |a| a.len() >= 2) {
            let any_of = typ.any_of.as_ref().unwrap();
            let simple = self.schema(&any_of[0]);
            let array = self.schema(&any_of[1]);
            if !array.type_.is_empty() {
                if let SimpleTypes::Array = array.type_[0] {
                    if simple == self.schema(&array.items[0]) {
                        return FieldType {
                            typ: format!("Vec<{}>", self.expand_type_from_schema(&any_of[0]).typ),
                            attributes: vec![format!(
                                r#"with="{}one_or_many""#,
                                self.schemafy_path
                            )],
                            default: true,
                        };
                    }
                }
            }
            "serde_json::Value".into()
        } else if typ.one_of.as_ref().map_or(false, |a| a.len() >= 2) {
            let schemas = typ.one_of.as_ref().unwrap();
            let (type_name, type_def) = self.expand_one_of(schemas);
            self.types.push((type_name.clone(), type_def));
            type_name.into()
        } else if typ.type_.len() == 2 {
            if typ.type_[0] == SimpleTypes::Null || typ.type_[1] == SimpleTypes::Null {
                let mut ty = typ.clone();
                ty.type_.retain(|x| *x != SimpleTypes::Null);

                FieldType {
                    typ: format!("Option<{}>", self.expand_type_from_schema(&ty).typ),
                    attributes: vec![],
                    default: true,
                }
            } else {
                "serde_json::Value".into()
            }
        } else if typ.type_.len() == 1 {
            match typ.type_[0] {
                SimpleTypes::String => {
                    if typ.enum_.as_ref().map_or(false, |e| e.is_empty()) {
                        "serde_json::Value".into()
                    } else {
                        "String".into()
                    }
                }
                SimpleTypes::Integer => "i64".into(),
                SimpleTypes::Boolean => "bool".into(),
                SimpleTypes::Number => "f64".into(),
                // Handle objects defined inline
                SimpleTypes::Object
                    if !typ.properties.is_empty()
                        || typ.additional_properties == Some(Value::Bool(false)) =>
                {
                    let name = format!(
                        "{}{}",
                        self.current_type.to_pascal_case(),
                        self.current_field.to_pascal_case()
                    );
                    let tokens = self.expand_schema(&name, typ);
                    self.types.push((name.clone(), tokens));
                    name.into()
                }
                SimpleTypes::Object => {
                    let prop = match typ.additional_properties {
                        Some(ref props) if props.is_object() => {
                            let prop = serde_json::from_value(props.clone()).unwrap();
                            self.expand_type_from_schema(&prop).typ
                        }
                        _ => "serde_json::Value".into(),
                    };
                    let result = format!("::std::collections::BTreeMap<String, {}>", prop);
                    FieldType {
                        typ: result,
                        attributes: Vec::new(),
                        default: typ.default == Some(Value::Object(Default::default())),
                    }
                }
                SimpleTypes::Array => {
                    let item_type = typ.items.get(0).map_or("serde_json::Value".into(), |item| {
                        self.current_type = format!("{}Item", self.current_type);
                        self.expand_type_from_schema(item).typ
                    });
                    format!("Vec<{}>", item_type).into()
                }
                _ => "serde_json::Value".into(),
            }
        } else {
            "serde_json::Value".into()
        }
    }

    fn expand_one_of(&mut self, schemas: &[Schema]) -> (String, TokenStream) {
        let current_field = if self.current_field.is_empty() {
            "".to_owned()
        } else {
            str_to_ident(&self.current_field)
                .to_string()
                .to_pascal_case()
        };
        let saved_type = format!("{}{}", self.current_type, current_field);
        if schemas.is_empty() {
            return (saved_type, TokenStream::new());
        }
        let (variant_names, variant_types): (Vec<_>, Vec<_>) = schemas
            .iter()
            .enumerate()
            .map(|(i, schema)| {
                let name = schema.id.clone().unwrap_or_else(|| format!("Variant{}", i));
                if let Some(ref_) = &schema.ref_ {
                    let type_ = self.type_ref(ref_);
                    (format_ident!("{}", &name), format_ident!("{}", &type_))
                } else {
                    let type_name = format!("{}{}", saved_type, &name);
                    let field_type = self.expand_schema(&type_name, schema);
                    self.types.push((type_name.clone(), field_type));
                    (format_ident!("{}", &name), format_ident!("{}", &type_name))
                }
            })
            .unzip();
        let type_name_ident = syn::Ident::new(&saved_type, Span::call_site());
        let type_def = quote! {
            #[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
            #[serde(untagged)]
            pub enum #type_name_ident {
                #(#variant_names(#variant_types)),*
            }
        };
        (saved_type, type_def)
    }

    fn expand_definitions(&mut self, schema: &Schema) {
        for (name, def) in &schema.definitions {
            let type_decl = self.expand_schema(name, def);
            let definition_tokens = match def.description {
                Some(ref comment) => {
                    let t = make_doc_comment(comment, LINE_LENGTH);
                    quote! {
                        #t
                        #type_decl
                    }
                }
                None => type_decl,
            };
            self.types.push((name.to_string(), definition_tokens));
        }
    }

    fn expand_schema(&mut self, original_name: &str, schema: &Schema) -> TokenStream {
        self.expand_definitions(schema);

        let pascal_case_name = replace_invalid_identifier_chars(&original_name.to_pascal_case());
        self.current_type.clone_from(&pascal_case_name);
        let (fields, default) = {
            let mut field_expander = FieldExpander {
                default: true,
                expander: self,
            };
            let fields = field_expander.expand_fields(original_name, schema);
            (fields, field_expander.default)
        };
        let name = syn::Ident::new(&pascal_case_name, Span::call_site());
        let is_struct =
            !fields.is_empty() || schema.additional_properties == Some(Value::Bool(false));
        let serde_rename = if name == original_name {
            None
        } else {
            Some(quote! {
                #[serde(rename = #original_name)]
            })
        };
        let is_enum = schema.enum_.as_ref().map_or(false, |e| !e.is_empty());
        let type_decl = if is_struct {
            let serde_deny_unknown = if schema.additional_properties == Some(Value::Bool(false))
                && schema.pattern_properties.is_empty()
            {
                Some(quote! { #[serde(deny_unknown_fields)] })
            } else {
                None
            };
            if default {
                quote! {
                    #[derive(Clone, PartialEq, Debug, Default, Deserialize, Serialize)]
                    #serde_rename
                    #serde_deny_unknown
                    pub struct #name {
                        #(#fields),*
                    }
                }
            } else {
                quote! {
                    #[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
                    #serde_rename
                    #serde_deny_unknown
                    pub struct #name {
                        #(#fields),*
                    }
                }
            }
        } else if is_enum {
            let mut optional = false;
            let mut repr_i64 = false;
            let variants = if schema.enum_names.as_ref().map_or(false, |e| !e.is_empty()) {
                let values = schema.enum_.as_ref().map_or(&[][..], |v| v);
                let names = schema.enum_names.as_ref().map_or(&[][..], |v| v);
                if names.len() != values.len() {
                    panic!(
                        "enumNames(length {}) and enum(length {}) have different length",
                        names.len(),
                        values.len()
                    )
                }
                names
                    .iter()
                    .enumerate()
                    .map(|(idx, name)| (&values[idx], name))
                    .flat_map(|(value, name)| {
                        let pascal_case_variant = name.to_pascal_case();
                        let variant_name =
                            rename_keyword("", &pascal_case_variant).unwrap_or_else(|| {
                                let v = syn::Ident::new(&pascal_case_variant, Span::call_site());
                                quote!(#v)
                            });
                        match value {
                            Value::String(ref s) => Some(quote! {
                                #[serde(rename = #s)]
                                #variant_name
                            }),
                            Value::Number(ref n) => {
                                repr_i64 = true;
                                let num = syn::LitInt::new(&n.to_string(), Span::call_site());
                                Some(quote! {
                                    #variant_name = #num
                                })
                            }
                            Value::Null => {
                                optional = true;
                                None
                            }
                            _ => panic!("Expected string,bool or number for enum got `{}`", value),
                        }
                    })
                    .collect::<Vec<_>>()
            } else {
                schema
                    .enum_
                    .as_ref()
                    .map_or(&[][..], |v| v)
                    .iter()
                    .flat_map(|v| match *v {
                        Value::String(ref v) => {
                            let pascal_case_variant = v.to_pascal_case();
                            let variant_name = rename_keyword("", &pascal_case_variant)
                                .unwrap_or_else(|| {
                                    let v =
                                        syn::Ident::new(&pascal_case_variant, Span::call_site());
                                    quote!(#v)
                                });
                            Some(if pascal_case_variant == *v {
                                variant_name
                            } else {
                                quote! {
                                    #[serde(rename = #v)]
                                    #variant_name
                                }
                            })
                        }
                        Value::Null => {
                            optional = true;
                            None
                        }
                        _ => panic!("Expected string for enum got `{}`", v),
                    })
                    .collect::<Vec<_>>()
            };
            if optional {
                let enum_name = syn::Ident::new(&format!("{}_", name), Span::call_site());
                if repr_i64 {
                    quote! {
                        pub type #name = Option<#enum_name>;
                        #[derive(Clone, PartialEq, Debug, Serialize_repr, Deserialize_repr)]
                        #serde_rename
                        #[repr(i64)]
                        pub enum #enum_name {
                            #(#variants),*
                        }
                    }
                } else {
                    quote! {
                        pub type #name = Option<#enum_name>;
                        #[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
                        #serde_rename
                        pub enum #enum_name {
                            #(#variants),*
                        }
                    }
                }
            } else if repr_i64 {
                quote! {
                    #[derive(Clone, PartialEq, Debug, Serialize_repr, Deserialize_repr)]
                    #serde_rename
                    #[repr(i64)]
                    pub enum #name {
                        #(#variants),*
                    }
                }
            } else {
                quote! {
                    #[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
                    #serde_rename
                    pub enum #name {
                        #(#variants),*
                    }
                }
            }
        } else {
            let typ = self
                .expand_type("", true, schema)
                .typ
                .parse::<TokenStream>()
                .unwrap();
            // Skip self-referential types, e.g. `struct Schema = Schema`
            if name == typ.to_string() {
                return TokenStream::new();
            }
            return quote! {
                pub type #name = #typ;
            };
        };
        type_decl
    }

    pub fn expand(&mut self, schema: &Schema) -> TokenStream {
        match self.root_name {
            Some(name) => {
                let schema = self.expand_schema(name, schema);
                self.types.push((name.to_string(), schema));
            }
            None => self.expand_definitions(schema),
        }

        let types = self.types.iter().map(|t| &t.1);

        quote! {
            #( #types )*
        }
    }

    pub fn expand_root(&mut self) -> TokenStream {
        self.expand(self.root)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_expander_type_ref() {
        let json = std::fs::read_to_string("src/schema.json").expect("Read schema JSON file");
        let schema = serde_json::from_str(&json).unwrap_or_else(|err| panic!("{}", err));
        let expander = Expander::new(Some("SchemaName"), "::schemafy_core::", &schema);

        assert_eq!(expander.type_ref("normalField"), "NormalField");
        assert_eq!(expander.type_ref("#"), "SchemaName");
        assert_eq!(expander.type_ref(""), "SchemaName");
        assert_eq!(expander.type_ref("1"), "_1");
        assert_eq!(
            expander.type_ref("http://example.com/schema.json#"),
            "SchemaName"
        );
        assert_eq!(
            expander.type_ref("http://example.com/normalField#withFragment"),
            "WithFragment"
        );
        assert_eq!(
            expander.type_ref("http://example.com/normalField#withFragment/and/path"),
            "Path"
        );
        assert_eq!(
            expander.type_ref("http://example.com/normalField?with&params#andFragment/and/path"),
            "Path"
        );
        assert_eq!(expander.type_ref("#/only/Fragment"), "Fragment");

        // Invalid cases, just to verify the behavior
        assert_eq!(expander.type_ref("ref"), "Ref");
        assert_eq!(expander.type_ref("_"), "");
        assert_eq!(expander.type_ref("thieves' tools"), "ThievesTools");
        assert_eq!(
            expander.type_ref("http://example.com/normalField?with&params=1"),
            "NormalFieldWithParams1"
        );
    }

    #[test]
    fn embedded_type_names() {
        use std::collections::HashSet;

        let json = std::fs::read_to_string("tests/multiple-property-types.json")
            .expect("Read schema JSON file");
        let schema = serde_json::from_str(&json).unwrap();
        let mut expander = Expander::new(Some("Root"), "UNUSED", &schema);
        expander.expand(&schema);

        // check that the type names for embedded objects only include their
        // ancestors' type names, and not names from unrelated fields
        let types = expander
            .types
            .iter()
            .map(|v| v.0.as_str())
            .collect::<HashSet<&str>>();
        assert!(types.contains("RootItemAC"));
        assert!(types.contains("RootKM"));
        assert!(types.contains("RootTV"));
    }
}

'''
'''--- schemafy_lib/src/schema.json ---
{
    "id": "http://json-schema.org/draft-04/schema#",
    "$schema": "http://json-schema.org/draft-04/schema#",
    "description": "Core schema meta-schema",
    "definitions": {
        "schemaArray": {
            "type": "array",
            "minItems": 1,
            "items": { "$ref": "#" }
        },
        "positiveInteger": {
            "type": "integer",
            "minimum": 0
        },
        "positiveIntegerDefault0": {
            "allOf": [ { "$ref": "#/definitions/positiveInteger" }, { "default": 0 } ]
        },
        "simpleTypes": {
            "enum": [ "array", "boolean", "integer", "null", "number", "object", "string" ]
        },
        "stringArray": {
            "type": "array",
            "items": { "type": "string" },
            "minItems": 1,
            "uniqueItems": true
        }
    },
    "type": "object",
    "properties": {
        "$ref": {
            "type": "string"
        },
        "id": {
            "type": "string",
            "format": "uri"
        },
        "$schema": {
            "type": "string",
            "format": "uri"
        },
        "title": {
            "type": "string"
        },
        "description": {
            "type": "string"
        },
        "default": {},
        "multipleOf": {
            "type": "number",
            "minimum": 0,
            "exclusiveMinimum": true
        },
        "maximum": {
            "type": "number"
        },
        "exclusiveMaximum": {
            "type": "boolean",
            "default": false
        },
        "minimum": {
            "type": "number"
        },
        "exclusiveMinimum": {
            "type": "boolean",
            "default": false
        },
        "maxLength": { "$ref": "#/definitions/positiveInteger" },
        "minLength": { "$ref": "#/definitions/positiveIntegerDefault0" },
        "pattern": {
            "type": "string",
            "format": "regex"
        },
        "additionalItems": {
            "anyOf": [
                { "type": "boolean" },
                { "$ref": "#" }
            ],
            "default": {}
        },
        "items": {
            "anyOf": [
                { "$ref": "#" },
                { "$ref": "#/definitions/schemaArray" }
            ],
            "default": {}
        },
        "maxItems": { "$ref": "#/definitions/positiveInteger" },
        "minItems": { "$ref": "#/definitions/positiveIntegerDefault0" },
        "uniqueItems": {
            "type": "boolean",
            "default": false
        },
        "maxProperties": { "$ref": "#/definitions/positiveInteger" },
        "minProperties": { "$ref": "#/definitions/positiveIntegerDefault0" },
        "required": { "$ref": "#/definitions/stringArray" },
        "additionalProperties": {
            "anyOf": [
                { "type": "boolean" },
                { "$ref": "#" }
            ],
            "default": {}
        },
        "definitions": {
            "type": "object",
            "additionalProperties": { "$ref": "#" },
            "default": {}
        },
        "properties": {
            "type": "object",
            "additionalProperties": { "$ref": "#" },
            "default": {}
        },
        "patternProperties": {
            "type": "object",
            "additionalProperties": { "$ref": "#" },
            "default": {}
        },
        "dependencies": {
            "type": "object",
            "additionalProperties": {
                "anyOf": [
                    { "$ref": "#" },
                    { "$ref": "#/definitions/stringArray" }
                ]
            }
        },
        "enum": {
            "type": "array",
            "minItems": 1,
            "uniqueItems": true
        },
        "enumNames": { "$ref": "#/definitions/stringArray" },
        "type": {
            "anyOf": [
                { "$ref": "#/definitions/simpleTypes" },
                {
                    "type": "array",
                    "items": { "$ref": "#/definitions/simpleTypes" },
                    "minItems": 1,
                    "uniqueItems": true
                }
            ]
        },
        "format": { "type": "string" },
        "allOf": { "$ref": "#/definitions/schemaArray" },
        "anyOf": { "$ref": "#/definitions/schemaArray" },
        "oneOf": { "$ref": "#/definitions/schemaArray" },
        "not": { "$ref": "#" }
    },
    "dependencies": {
        "exclusiveMaximum": [ "maximum" ],
        "exclusiveMinimum": [ "minimum" ]
    },
    "default": {}
}

'''
'''--- schemafy_lib/src/schema.rs ---
pub type PositiveInteger = i64;
pub type PositiveIntegerDefault0 = serde_json::Value;
pub type SchemaArray = Vec<Schema>;
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
#[serde(rename = "simpleTypes")]
pub enum SimpleTypes {
    #[serde(rename = "array")]
    Array,
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "integer")]
    Integer,
    #[serde(rename = "null")]
    Null,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "object")]
    Object,
    #[serde(rename = "string")]
    String,
}
pub type StringArray = Vec<String>;
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
pub struct Schema {
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "$ref")]
    pub ref_: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "$schema")]
    pub schema: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "additionalItems")]
    pub additional_items: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "additionalProperties")]
    pub additional_properties: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "allOf")]
    pub all_of: Option<SchemaArray>,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "anyOf")]
    pub any_of: Option<SchemaArray>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default: Option<serde_json::Value>,
    #[serde(default)]
    pub definitions: ::std::collections::BTreeMap<String, Schema>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dependencies: Option<::std::collections::BTreeMap<String, serde_json::Value>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "enum")]
    pub enum_: Option<Vec<serde_json::Value>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "enumNames")]
    pub enum_names: Option<StringArray>,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "exclusiveMaximum")]
    pub exclusive_maximum: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "exclusiveMinimum")]
    pub exclusive_minimum: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub format: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(default)]
    #[serde(with = "::schemafy_core::one_or_many")]
    pub items: Vec<Schema>,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "maxItems")]
    pub max_items: Option<PositiveInteger>,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "maxLength")]
    pub max_length: Option<PositiveInteger>,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "maxProperties")]
    pub max_properties: Option<PositiveInteger>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub maximum: Option<f64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "minItems")]
    pub min_items: Option<PositiveIntegerDefault0>,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "minLength")]
    pub min_length: Option<PositiveIntegerDefault0>,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "minProperties")]
    pub min_properties: Option<PositiveIntegerDefault0>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub minimum: Option<f64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "multipleOf")]
    pub multiple_of: Option<f64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub not: Option<Box<Schema>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "oneOf")]
    pub one_of: Option<SchemaArray>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
    #[serde(default)]
    #[serde(rename = "patternProperties")]
    pub pattern_properties: ::std::collections::BTreeMap<String, Schema>,
    #[serde(default)]
    pub properties: ::std::collections::BTreeMap<String, Schema>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub required: Option<StringArray>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    #[serde(default)]
    #[serde(with = "::schemafy_core::one_or_many")]
    #[serde(rename = "type")]
    pub type_: Vec<SimpleTypes>,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "uniqueItems")]
    pub unique_items: Option<bool>,
}

'''
'''--- schemafy_lib/tests/multiple-property-types.json ---
{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "multiple-property-types",
  "type": "object",
  "properties": {
    "A": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "B": {
            "type": "integer"
          },
          "C": {
            "type": "object",
            "properties": {
              "D": {
                "type": "string"
              }
            }
          }
        }
      }
    },
    "K": {
      "type": "object",
      "properties": {
        "L": {
          "type": "array",
          "items": {
            "type": "integer"
          }
        },
        "M": {
          "type": "object",
          "properties": {
            "N": {
              "type": "string"
            }
          }
        }
      }
    },
    "T": {
      "type": "object",
      "properties": {
        "U": {
          "type": "array",
          "items": {
            "type": "integer"
          }
        },
        "V": {
          "type": "object",
          "properties": {
            "W": {
              "type": "string"
            }
          }
        }
      }
    }
  }
}

'''
'''--- schemafy_lib/tests/test.rs ---
use schemafy_lib::Expander;

#[test]
fn schema() {
    let json = std::fs::read_to_string("src/schema.json").expect("Read schema JSON file");

    let schema = serde_json::from_str(&json).unwrap_or_else(|err| panic!("{}", err));
    let mut expander = Expander::new(Some("Schema"), "UNUSED", &schema);

    expander.expand(&schema);
}

#[test]
fn test_str_to_ident() {
    use proc_macro2::Span;
    use schemafy_lib::str_to_ident;
    use syn::Ident;

    assert_eq!(
        str_to_ident("normalField"),
        Ident::new("normalField", Span::call_site())
    );

    assert_eq!(str_to_ident("ref"), Ident::new("ref_", Span::call_site()));

    assert_eq!(str_to_ident(""), Ident::new("empty_", Span::call_site()));
    assert_eq!(
        str_to_ident("_"),
        Ident::new("underscore_", Span::call_site())
    );
    assert_eq!(
        str_to_ident("__"),
        Ident::new("underscore_", Span::call_site())
    );

    assert_eq!(str_to_ident("_7_"), Ident::new("_7_", Span::call_site()));
    assert_eq!(
        str_to_ident("thieves' tools"),
        // only one underscore
        Ident::new("thieves_tools", Span::call_site())
    );
}

'''
'''--- src/generate_tests.rs ---
//! Generate test cases from the JSON Schema Test Suite.

use inflector::Inflector;
use serde::{Deserialize, Serialize};
use std::{error::Error, ffi::OsStr, fs, path::PathBuf, process::Command};

// Each test has a description, schema, and a list of tests. Each of
// those tests has a description, some data, and a `valid` field which
// indicates whether that data should validate against the schema.
schemafy::schemafy!(
    root: TestSchema
    "tests/JSON-Schema-Test-Suite/test-schema.json"
);

fn main() -> Result<(), Box<dyn Error>> {
    let test_suite_dir = PathBuf::from("tests/test_suite");
    let schemas_dir = test_suite_dir.join("schemas");
    if test_suite_dir.exists() {
        fs::remove_dir_all("tests/test_suite")?;
    }
    fs::create_dir(&test_suite_dir)?;
    fs::create_dir(&schemas_dir)?;

    let mut test_modules = vec![];
    let mut blacklist_count = 0;

    for path in fs::read_dir("tests/JSON-Schema-Test-Suite/tests/draft4")?
        .map(|entry| entry.unwrap().path())
        .filter(|path| path.extension() == Some(OsStr::new("json")))
    {
        let buffer = fs::read_to_string(&path)?;
        let test_schema: TestSchema = serde_json::from_str(&buffer)?;
        println!("{} ==> {} tests", path.display(), test_schema.len());

        let module_name = path.file_stem().unwrap().to_str().unwrap().to_snake_case();

        let mut test_file: String = format!(
            r#"//! Automatically generated from {}
"#,
            path.display()
        );

        let mut is_module_empty = true;

        for (i, test_group) in test_schema.iter().enumerate() {
            if is_blacklisted(&module_name, i) {
                blacklist_count += 1;
                println!(" !! skipping test group: {}", test_group.description);
                continue;
            }

            is_module_empty = false;

            let schema_name = format!("{}_{}.json", module_name, i);
            let schema = serde_json::to_string(&test_group.schema)?;
            fs::write(schemas_dir.join(&schema_name), schema)?;

            let schema = schemafy_lib::Generator::builder()
                .with_root_name_str("Schema")
                .with_input_file(&schemas_dir.join(schema_name))
                .build()
                .generate();

            test_file.push_str(&format!(
                r#"
mod _{}_{} {{
    #[allow(unused_imports)]
    use serde::{{Deserialize, Serialize}};

    {}
"#,
                i,
                test_group.description.to_snake_case(),
                &schema.to_string()
            ));
            for test in &test_group.tests {
                let test_name = {
                    // Prefix the name with an underscore if it starts
                    // with a number.
                    let root = test.description.to_snake_case();
                    let prefix = if root.chars().next().unwrap().is_numeric() {
                        "_"
                    } else {
                        ""
                    };
                    format!("{}{}", prefix, root)
                };

                // For the positive test cases, unwrapping the result
                // gives better error messages than simply asserting
                // on .is_ok(). For the negative test cases, a simple
                // assert is the best we can do.
                let assertion = if test.valid {
                    "let _: Schema = serde_json::from_str(data).unwrap();"
                } else {
                    "assert!(serde_json::from_str::<Schema>(data).is_err());"
                };

                test_file.push_str(&format!(
                    r##"
    #[test]
    fn r#{}() {{
        let data = r#"{}"#;
        {}
    }}
"##,
                    test_name, test.data, assertion
                ));
            }
            test_file.push_str("}\n");
        }

        if is_module_empty {
            continue;
        }

        let test_path = test_suite_dir.join(format!("{}.rs", module_name));

        fs::write(&test_path, test_file)?;
        Command::new("rustfmt").arg(test_path).output()?;
        test_modules.push(module_name);
    }

    // Generate a root module that declares all the above files.
    let mut tests: String = r#"//! Automatically generated
"#
    .into();
    for module in &test_modules {
        tests.push_str(&format!("mod r#{};\n", module));
    }
    fs::write(test_suite_dir.join("mod.rs"), tests)?;

    if blacklist_count > 0 {
        println!("\nSkipped {} test schemas\n", blacklist_count);
    }

    Ok(())
}

/// To allow for gradual progress, this function determines whether a
/// test should be skipped.
fn is_blacklisted(test_group: &str, index: usize) -> bool {
    let blacklisted_indices: &[usize] = match test_group {
        "additional_items" => &[0, 2],
        "additional_properties" => &[0, 1, 2, 3, 5],
        "all_of" => &[1, 2, 5, 6],
        "any_of" => &[0, 1, 2, 4],
        "definitions" => &[0, 1],
        "dependencies" => &[0, 1, 2, 3],
        "enum" => &[0, 1, 3, 4, 5, 6, 7],
        "items" => &[0, 1, 2],
        "max_items" => &[0],
        "max_length" => &[0],
        "max_properties" => &[0],
        "maximum" => &[0, 1, 2],
        "min_items" => &[0],
        "min_length" => &[0],
        "min_properties" => &[0],
        "minimum" => &[0, 1, 2, 3],
        "multiple_of" => &[0, 1, 2],
        "not" => &[0, 1, 2, 3],
        "one_of" => &[0, 1, 2, 3, 4],
        "pattern" => &[0],
        "pattern_properties" => &[0, 1, 2],
        "properties" => &[0, 1, 2],
        "ref" => &[0, 1, 2, 3, 6, 8, 9, 10, 11, 12],
        "ref_remote" => &[0, 1, 2, 3, 4, 5, 6],
        "required" => &[0, 2],
        "type" => &[6, 7, 9, 10],
        "unique_items" => &[0, 1, 2],

        _ => &[],
    };

    blacklisted_indices.contains(&index)
}

'''
'''--- src/lib.rs ---
// This would be nice once it stabilizes:
// https://github.com/rust-lang/rust/issues/44732
// #![feature(external_doc)]
// #![doc(include = "../README.md")]

//! This is a Rust crate which can take a [json schema (draft
//! 4)](http://json-schema.org/) and generate Rust types which are
//! serializable with [serde](https://serde.rs/). No checking such as
//! `min_value` are done but instead only the structure of the schema
//! is followed as closely as possible.
//!
//! As a schema could be arbitrarily complex this crate makes no
//! guarantee that it can generate good types or even any types at all
//! for a given schema but the crate does manage to bootstrap itself
//! which is kind of cool.
//!
//! ## Example
//!
//! Generated types for VS Codes [debug server protocol][]: <https://docs.rs/debugserver-types>
//!
//! [debug server protocol]:https://code.visualstudio.com/docs/extensions/example-debuggers
//!
//! ## Usage
//!
//! Rust types can be generated by passing a path to a JSON schema to the [`schemafy!`]
//! procedural macro.
//!
//! ```rust
//! extern crate serde;
//! extern crate schemafy_core;
//! extern crate serde_json;
//!
//! use serde::{Serialize, Deserialize};
//!
//! schemafy::schemafy!(
//!     "tests/nested.json"
//! );
//!
//! schemafy::schemafy!(
//!     root: Schema // Optional name for the root type (if one exists)
//!     "schemafy_lib/src/schema.json"
//! );
//!
//!
//! fn main() -> Result<(), Box<dyn std::error::Error>> {
//!     let nested: Defnested = serde_json::from_str(r#"{ "append": "abc" }"#)?;
//!     assert_eq!(nested.append, Some("abc".to_string()));
//!     Ok(())
//! }
//! ```

/// Generate Rust types from a JSON schema.
///
/// If the `root` parameter is supplied, then a type will be
/// generated from the root of the schema.
///
/// ```rust
/// extern crate serde;
/// extern crate schemafy_core;
/// extern crate serde_json;
///
/// use serde::{Serialize, Deserialize};
///
/// schemafy::schemafy!(
///     root: MyRoot // Optional name for the root type (if one exists)
///     "tests/nested.json"
/// );
///
/// fn main() -> Result<(), Box<dyn std::error::Error>> {
///     let nested: Defnested = serde_json::from_str(r#"{ "append": "abc" }"#)?;
///     assert_eq!(nested.append, Some("abc".to_string()));
///     Ok(())
/// }
/// ```
#[proc_macro]
pub fn schemafy(tokens: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let def = syn::parse_macro_input!(tokens as Def);
    let root_name = def.root;
    let input_file = def.input_file.value();
    schemafy_lib::Generator::builder()
        .with_root_name(root_name)
        .with_input_file(&input_file)
        .build()
        .generate()
        .into()
}

struct Def {
    root: Option<String>,
    input_file: syn::LitStr,
}

impl syn::parse::Parse for Def {
    fn parse(input: syn::parse::ParseStream<'_>) -> syn::Result<Self> {
        let root = if input.peek(syn::Ident) {
            let root_ident: syn::Ident = input.parse()?;
            if root_ident != "root" {
                return Err(syn::Error::new(root_ident.span(), "Expected `root`"));
            }
            input.parse::<syn::Token![:]>()?;
            Some(input.parse::<syn::Ident>()?.to_string())
        } else {
            None
        };
        Ok(Def {
            root,
            input_file: input.parse()?,
        })
    }
}

'''
'''--- src/main.rs ---
use std::io::copy;
use std::path::Path;
use std::process::{Command, Stdio};

use anyhow::{anyhow, bail, Context, Result};
use schemafy_lib::Generator;
use structopt::StructOpt;
use tempfile::NamedTempFile;

/// Generate Rust structs from a JSON schema
#[derive(Debug, StructOpt)]
struct Opts {
    /// Name for the root structure
    #[structopt(short, long, value_name = "NAME", default_value = "Schema")]
    root: String,
    /// Output file [default: stdout]
    #[structopt(short, long, value_name = "PATH")]
    output: Option<String>,
    /// JSON schema file
    schema_path: String,
}

pub fn main() -> Result<()> {
    let opts = Opts::from_args();

    // generate the Rust code
    let mut generated_file = NamedTempFile::new()?;
    Generator::builder()
        .with_root_name_str(&opts.root)
        .with_input_file(&opts.schema_path)
        .build()
        .generate_to_file(
            &generated_file
                .path()
                .to_str()
                .ok_or_else(|| anyhow!("converting output path"))?,
        )?;

    // run it through rustfmt and write it out
    let (output_file, output_path) = NamedTempFile::new_in(
        opts.output
            .as_ref()
            .map(|p| Path::new(p).parent())
            .flatten()
            .unwrap_or(&std::env::temp_dir()),
    )
    .context("creating temporary output file")?
    .into_parts();
    let mut formatter = Command::new("rustfmt")
        .args(&["--edition", "2018"])
        .stdin(Stdio::piped())
        .stdout(
            opts.output
                .as_ref()
                .and(Some(output_file.into()))
                .unwrap_or(Stdio::inherit()),
        )
        .spawn()
        .context("running rustfmt")?;
    copy(
        generated_file.as_file_mut(),
        formatter.stdin.as_mut().expect("stdin"),
    )?;
    let result = formatter.wait()?;
    if !result.success() {
        bail!("rustfmt failed");
    }
    if let Some(path) = &opts.output {
        output_path.persist(path)?;
    }

    Ok(())
}

'''
'''--- test.sh ---
#!/bin/sh
cargo build --features internal-regenerate

cargo run --bin generate-tests --features="generate-tests"
cargo fmt --all
cargo test --all 

'''
'''--- tests/any-properties.json ---
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "any-properties",
    "type": "object",
    "additionalProperties": true
}

'''
'''--- tests/array-type.json ---
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "array-type",
    "type": "object",
    "properties": {
        "required": {
            "type": "array",
            "items": { "type": "integer" }
        },
        "optional": {
            "type": "array",
            "items": { "type": "integer" }
        }
    },
    "required": [
        "required"
    ]
}

'''
'''--- tests/debugserver-schema.json ---
{
	"$schema": "http://json-schema.org/draft-04/schema#",
	"title": "VS Code Debug Protocol",
	"description": "A json schema for the VS Code Debug Protocol",
	"type": "object",

	"definitions": {

		"ProtocolMessage": {
			"type": "object",
			"description": "Base class of requests, responses, and events.",
			"properties": {
				"seq": {
					"type": "integer",
					"description": "Sequence number."
				},
				"type": {
					"type": "string",
					"description": "One of 'request', 'response', or 'event'.",
					"_enum": [ "request", "response", "event" ]
				}
			},
			"required": [ "seq", "type" ]
		},

		"Request": {
			"allOf": [ { "$ref": "#/definitions/ProtocolMessage" }, {
				"type": "object",
				"description": "A client or server-initiated request.",
				"properties": {
					"type": {
						"type": "string",
						"enum": [ "request" ]
					},
					"command": {
						"type": "string",
						"description": "The command to execute."
					},
					"arguments": {
						"type": [ "array", "boolean", "integer", "null", "number" , "object", "string" ],
						"description": "Object containing arguments for the command."
					}
				},
				"required": [ "type", "command" ]
			}]
		},

		"Event": {
			"allOf": [ { "$ref": "#/definitions/ProtocolMessage" }, {
				"type": "object",
				"description": "Server-initiated event.",
				"properties": {
					"type": {
						"type": "string",
						"enum": [ "event" ]
					},
					"event": {
						"type": "string",
						"description": "Type of event."
					},
					"body": {
						"type": [ "array", "boolean", "integer", "null", "number" , "object", "string" ],
						"description": "Event-specific information."
					}
				},
				"required": [ "type", "event" ]
			}]
		},

		"Response": {
			"allOf": [ { "$ref": "#/definitions/ProtocolMessage" }, {
				"type": "object",
				"description": "Response to a request.",
				"properties": {
					"type": {
						"type": "string",
						"enum": [ "response" ]
					},
					"request_seq": {
						"type": "integer",
						"description": "Sequence number of the corresponding request."
					},
					"success": {
						"type": "boolean",
						"description": "Outcome of the request."
					},
					"command": {
						"type": "string",
						"description": "The command requested."
					},
					"message": {
						"type": "string",
						"description": "Contains error message if success == false."
					},
					"body": {
						"type": [ "array", "boolean", "integer", "null", "number" , "object", "string" ],
						"description": "Contains request result if success is true and optional error details if success is false."
					}
				},
				"required": [ "type", "request_seq", "success", "command" ]
			}]
		},

		"InitializedEvent": {
			"allOf": [ { "$ref": "#/definitions/Event" }, {
				"type": "object",
				"description": "Event message for 'initialized' event type.\nThis event indicates that the debug adapter is ready to accept configuration requests (e.g. SetBreakpointsRequest, SetExceptionBreakpointsRequest).\nA debug adapter is expected to send this event when it is ready to accept configuration requests (but not before the InitializeRequest has finished).\nThe sequence of events/requests is as follows:\n- adapters sends InitializedEvent (after the InitializeRequest has returned)\n- frontend sends zero or more SetBreakpointsRequest\n- frontend sends one SetFunctionBreakpointsRequest\n- frontend sends a SetExceptionBreakpointsRequest if one or more exceptionBreakpointFilters have been defined (or if supportsConfigurationDoneRequest is not defined or false)\n- frontend sends other future configuration requests\n- frontend sends one ConfigurationDoneRequest to indicate the end of the configuration",
				"properties": {
					"event": {
						"type": "string",
						"enum": [ "initialized" ]
					}
				},
				"required": [ "event" ]
			}]
		},

		"StoppedEvent": {
			"allOf": [ { "$ref": "#/definitions/Event" }, {
				"type": "object",
				"description": "Event message for 'stopped' event type.\nThe event indicates that the execution of the debuggee has stopped due to some condition.\nThis can be caused by a break point previously set, a stepping action has completed, by executing a debugger statement etc.",
				"properties": {
					"event": {
						"type": "string",
						"enum": [ "stopped" ]
					},
					"body": {
						"type": "object",
						"properties": {
							"reason": {
								"type": "string",
								"description": "The reason for the event (such as: 'step', 'breakpoint', 'exception', 'pause'). This string is shown in the UI.",
								"_enum": [ "step", "breakpoint", "exception", "pause" ]
							},
							"threadId": {
								"type": "integer",
								"description": "The thread which was stopped."
							},
							"text": {
								"type": "string",
								"description": "Additional information. E.g. if reason is 'exception', text contains the exception name. This string is shown in the UI."
							},
							"allThreadsStopped": {
								"type": "boolean",
								"description": "If allThreadsStopped is true, a debug adapter can announce that all threads have stopped.\n*  The client should use this information to enable that all threads can be expanded to access their stacktraces.\n*  If the attribute is missing or false, only the thread with the given threadId can be expanded."
							}
						},
						"required": [ "reason" ]
					}
				},
				"required": [ "event", "body" ]
			}]
		},

		"ContinuedEvent": {
			"allOf": [ { "$ref": "#/definitions/Event" }, {
				"type": "object",
				"description": "Event message for 'continued' event type.\nThe event indicates that the execution of the debuggee has continued.\nPlease note: a debug adapter is not expected to send this event in response to a request that implies that execution continues, e.g. 'launch' or 'continue'.\nIt is only necessary to send a ContinuedEvent if there was no previous request that implied this.",
				"properties": {
					"event": {
						"type": "string",
						"enum": [ "continued" ]
					},
					"body": {
						"type": "object",
						"properties": {
							"threadId": {
								"type": "integer",
								"description": "The thread which was continued."
							},
							"allThreadsContinued": {
								"type": "boolean",
								"description": "If allThreadsContinued is true, a debug adapter can announce that all threads have continued."
							}
						},
						"required": [ "threadId" ]
					}
				},
				"required": [ "event", "body" ]
			}]
		},

		"ExitedEvent": {
			"allOf": [ { "$ref": "#/definitions/Event" }, {
				"type": "object",
				"description": "Event message for 'exited' event type.\nThe event indicates that the debuggee has exited.",
				"properties": {
					"event": {
						"type": "string",
						"enum": [ "exited" ]
					},
					"body": {
						"type": "object",
						"properties": {
							"exitCode": {
								"type": "integer",
								"description": "The exit code returned from the debuggee."
							}
						},
						"required": [ "exitCode" ]
					}
				},
				"required": [ "event", "body" ]
			}]
		},

		"TerminatedEvent": {
			"allOf": [ { "$ref": "#/definitions/Event" }, {
				"type": "object",
				"description": "Event message for 'terminated' event types.\nThe event indicates that debugging of the debuggee has terminated.",
				"properties": {
					"event": {
						"type": "string",
						"enum": [ "terminated" ]
					},
					"body": {
						"type": "object",
						"properties": {
							"restart": {
								"type": "boolean",
								"description": "A debug adapter may set 'restart' to true to request that the front end restarts the session."
							}
						}
					}
				},
				"required": [ "event" ]
			}]
		},

		"ThreadEvent": {
			"allOf": [ { "$ref": "#/definitions/Event" }, {
				"type": "object",
				"description": "Event message for 'thread' event type.\nThe event indicates that a thread has started or exited.",
				"properties": {
					"event": {
						"type": "string",
						"enum": [ "thread" ]
					},
					"body": {
						"type": "object",
						"properties": {
							"reason": {
								"type": "string",
								"description": "The reason for the event (such as: 'started', 'exited').",
								"_enum": [ "started", "exited" ]
							},
							"threadId": {
								"type": "integer",
								"description": "The identifier of the thread."
							}
						},
						"required": ["reason", "threadId"]
					}
				},
				"required": [ "event", "body" ]
			}]
		},

		"OutputEvent": {
			"allOf": [ { "$ref": "#/definitions/Event" }, {
				"type": "object",
				"description": "Event message for 'output' event type.\nThe event indicates that the target has produced output.",
				"properties": {
					"event": {
						"type": "string",
						"enum": [ "output" ]
					},
					"body": {
						"type": "object",
						"properties": {
							"category": {
								"type": "string",
								"description": "The category of output (such as: 'console', 'stdout', 'stderr', 'telemetry'). If not specified, 'console' is assumed.",
								"_enum": [ "console", "stdout", "stderr", "telemetry" ]
							},
							"output": {
								"type": "string",
								"description": "The output to report."
							},
							"data": {
								"type": [ "array", "boolean", "integer", "null", "number" , "object", "string" ],
								"description": "Optional data to report. For the 'telemetry' category the data will be sent to telemetry, for the other categories the data is shown in JSON format."
							}
						},
						"required": ["output"]
					}
				},
				"required": [ "event", "body" ]
			}]
		},

		"BreakpointEvent": {
			"allOf": [ { "$ref": "#/definitions/Event" }, {
				"type": "object",
				"description": "Event message for 'breakpoint' event type.\nThe event indicates that some information about a breakpoint has changed.",
				"properties": {
					"event": {
						"type": "string",
						"enum": [ "breakpoint" ]
					},
					"body": {
						"type": "object",
						"properties": {
							"reason": {
								"type": "string",
								"description": "The reason for the event (such as: 'changed', 'new').",
								"_enum": [ "changed", "new" ]
							},
							"breakpoint": {
								"$ref": "#/definitions/Breakpoint",
								"description": "The breakpoint."
							}
						},
						"required": [ "reason", "breakpoint" ]
					}
				},
				"required": [ "event", "body" ]
			}]
		},

		"ModuleEvent": {
			"allOf": [ { "$ref": "#/definitions/Event" }, {
				"type": "object",
				"description": "Event message for 'module' event type.\nThe event indicates that some information about a module has changed.",
				"properties": {
					"event": {
						"type": "string",
						"enum": [ "module" ]
					},
					"body": {
						"type": "object",
						"properties": {
							"reason": {
								"type": "string",
								"description": "The reason for the event.",
								"enum": [ "new", "changed", "removed" ]
							},
							"module": {
								"$ref": "#/definitions/Module",
								"description": "The new, changed, or removed module. In case of 'removed' only the module id is used."
							}
						},
						"required": [ "reason", "module" ]
					}
				},
				"required": [ "event", "body" ]
			}]
		},

		"RunInTerminalRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "runInTerminal request; value of command field is 'runInTerminal'.\nWith this request a debug adapter can run a command in a terminal.",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "runInTerminal" ]
					},
					"arguments": {
						"$ref": "#/definitions/RunInTerminalRequestArguments"
					}
				},
				"required": [ "command", "arguments" ]
			}]
		},
		"RunInTerminalRequestArguments": {
			"type": "object",
			"description": "Arguments for 'runInTerminal' request.",
			"properties": {
				"kind": {
					"type": "string",
					"enum": [ "integrated", "external" ],
					"description": "What kind of terminal to launch."
				},
				"title": {
					"type": "string",
					"description": "Optional title of the terminal."
				},
				"cwd": {
					"type": "string",
					"description": "Working directory of the command."
				},
				"args": {
					"type": "array",
					"items": {
						"type": "string"
					},
					"description": "List of arguments. The first argument is the command to run."
				},
				"env": {
					"type": "object",
					"description": "Environment key-value pairs that are added to the default environment.",
					"additionalProperties": {
						"type": "string",
						"description": "Values must be strings."
					}
				}
			},
			"required": [ "args", "cwd" ]
		},
		"RunInTerminalResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to Initialize request.",
				"properties": {
					"body": {
						"type": "object",
						"properties": {
							"processId": {
								"type": "number",
								"description": "The process ID."
							}
						}
					}
				},
				"required": [ "body" ]
			}]
		},

		"ErrorResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "On error that is whenever 'success' is false, the body can provide more details.",
				"properties": {
					"body": {
						"type": "object",
						"properties": {
							"error": {
								"$ref": "#/definitions/Message",
								"description": "An optional, structured error message."
							}
						}
					}
				},
				"required": [ "body" ]
			}]
		},

		"InitializeRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "Initialize request; value of command field is 'initialize'.",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "initialize" ]
					},
					"arguments": {
						"$ref": "#/definitions/InitializeRequestArguments"
					}
				},
				"required": [ "command", "arguments" ]
			}]
		},
		"InitializeRequestArguments": {
			"type": "object",
			"description": "Arguments for 'initialize' request.",
			"properties": {
				"adapterID": {
					"type": "string",
					"description": "The ID of the debugger adapter. Used to select or verify debugger adapter."
				},
				"linesStartAt1": {
					"type": "boolean",
					"description": "If true all line numbers are 1-based (default)."
				},
				"columnsStartAt1": {
					"type": "boolean",
					"description": "If true all column numbers are 1-based (default)."
				},
				"pathFormat": {
					"type": "string",
					"_enum": [ "path", "uri" ],
					"description": "Determines in what format paths are specified. Possible values are 'path' or 'uri'. The default is 'path', which is the native format."
				},
				"supportsVariableType": {
					"type": "boolean",
					"description": "Client supports the optional type attribute for variables."
				},
				"supportsVariablePaging": {
					"type": "boolean",
					"description": "Client supports the paging of variables."
				},
				"supportsRunInTerminalRequest": {
					"type": "boolean",
					"description": "Client supports the runInTerminal request."
				}
			},
			"required": [ "adapterID" ]
		},
		"InitializeResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'initialize' request.",
				"properties": {
					"body": {
						"$ref": "#/definitions/Capabilities",
						"description": "The capabilities of this debug adapter."
					}
				}
			}]
		},

		"ConfigurationDoneRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "ConfigurationDone request; value of command field is 'configurationDone'.\nThe client of the debug protocol must send this request at the end of the sequence of configuration requests (which was started by the InitializedEvent).",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "configurationDone" ]
					},
					"arguments": {
						"$ref": "#/definitions/ConfigurationDoneArguments"
					}
				},
				"required": [ "command" ]
			}]
		},
		"ConfigurationDoneArguments": {
			"type": "object",
			"description": "Arguments for 'configurationDone' request.\nThe configurationDone request has no standardized attributes."
		},
		"ConfigurationDoneResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'configurationDone' request. This is just an acknowledgement, so no body field is required."
			}]
		},

		"LaunchRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "Launch request; value of command field is 'launch'.",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "launch" ]
					},
					"arguments": {
						"$ref": "#/definitions/LaunchRequestArguments"
					}
				},
				"required": [ "command", "arguments"  ]
			}]
		},
		"LaunchRequestArguments": {
			"type": "object",
			"description": "Arguments for 'launch' request.",
			"properties": {
				"noDebug": {
					"type": "boolean",
					"description": "If noDebug is true the launch request should launch the program without enabling debugging."
				}
			}
		},
		"LaunchResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'launch' request. This is just an acknowledgement, so no body field is required."
			}]
		},

		"AttachRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "Attach request; value of command field is 'attach'.",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "attach" ]
					},
					"arguments": {
						"$ref": "#/definitions/AttachRequestArguments"
					}
				},
				"required": [ "command", "arguments" ]
			}]
		},
		"AttachRequestArguments": {
			"type": "object",
			"description": "Arguments for 'attach' request.\nThe attach request has no standardized attributes."
		},
		"AttachResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'attach' request. This is just an acknowledgement, so no body field is required."
			}]
		},

		"DisconnectRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "Disconnect request; value of command field is 'disconnect'.",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "disconnect" ]
					},
					"arguments": {
						"$ref": "#/definitions/DisconnectArguments"
					}
				},
				"required": [ "command" ]
			}]
		},
		"DisconnectArguments": {
			"type": "object",
			"description": "Arguments for 'disconnect' request.\nThe disconnect request has no standardized attributes."
		},
		"DisconnectResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'disconnect' request. This is just an acknowledgement, so no body field is required."
			}]
		},

		"SetBreakpointsRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "SetBreakpoints request; value of command field is 'setBreakpoints'.\nSets multiple breakpoints for a single source and clears all previous breakpoints in that source.\nTo clear all breakpoint for a source, specify an empty array.\nWhen a breakpoint is hit, a StoppedEvent (event type 'breakpoint') is generated.",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "setBreakpoints" ]
					},
					"arguments": {
						"$ref": "#/definitions/SetBreakpointsArguments"
					}
				},
				"required": [ "command", "arguments"  ]
			}]
		},
		"SetBreakpointsArguments": {
			"type": "object",
			"description": "Arguments for 'setBreakpoints' request.",
			"properties": {
				"source": {
					"$ref": "#/definitions/Source",
					"description": "The source location of the breakpoints; either source.path or source.reference must be specified."
				},
				"breakpoints": {
					"type": "array",
					"items": {
						"$ref": "#/definitions/SourceBreakpoint"
					},
					"description": "The code locations of the breakpoints."
				},
				"lines": {
					"type": "array",
					"items": {
						"type": "integer"
					},
					"description": "Deprecated: The code locations of the breakpoints."
				},
				"sourceModified": {
					"type": "boolean",
					"description": "A value of true indicates that the underlying source has been modified which results in new breakpoint locations."
				}
			},
			"required": [ "source" ]
		},
		"SetBreakpointsResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'setBreakpoints' request.\nReturned is information about each breakpoint created by this request.\nThis includes the actual code location and whether the breakpoint could be verified.\nThe breakpoints returned are in the same order as the elements of the 'breakpoints'\n(or the deprecated 'lines') in the SetBreakpointsArguments.",
				"properties": {
					"body": {
						"type": "object",
						"properties": {
							"breakpoints": {
								"type": "array",
								"items": {
									"$ref": "#/definitions/Breakpoint"
								},
								"description": "Information about the breakpoints. The array elements are in the same order as the elements of the 'breakpoints' (or the deprecated 'lines') in the SetBreakpointsArguments."
							}
						},
						"required": [ "breakpoints" ]
					}
				},
				"required": [ "body" ]
			}]
		},

		"SetFunctionBreakpointsRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "SetFunctionBreakpoints request; value of command field is 'setFunctionBreakpoints'.\nSets multiple function breakpoints and clears all previous function breakpoints.\nTo clear all function breakpoint, specify an empty array.\nWhen a function breakpoint is hit, a StoppedEvent (event type 'function breakpoint') is generated.",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "setFunctionBreakpoints" ]
					},
					"arguments": {
						"$ref": "#/definitions/SetFunctionBreakpointsArguments"
					}
				},
				"required": [ "command", "arguments"  ]
			}]
		},
		"SetFunctionBreakpointsArguments": {
			"type": "object",
			"description": "Arguments for 'setFunctionBreakpoints' request.",
			"properties": {
				"breakpoints": {
					"type": "array",
					"items": {
						"$ref": "#/definitions/FunctionBreakpoint"
					},
					"description": "The function names of the breakpoints."
				}
			},
			"required": [ "breakpoints" ]
		},
		"SetFunctionBreakpointsResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'setFunctionBreakpoints' request.\nReturned is information about each breakpoint created by this request.",
				"properties": {
					"body": {
						"type": "object",
						"properties": {
							"breakpoints": {
								"type": "array",
								"items": {
									"$ref": "#/definitions/Breakpoint"
								},
								"description": "Information about the breakpoints. The array elements correspond to the elements of the 'breakpoints' array."
							}
						},
						"required": [ "breakpoints" ]
					}
				},
				"required": [ "body" ]
			}]
		},

		"SetExceptionBreakpointsRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "SetExceptionBreakpoints request; value of command field is 'setExceptionBreakpoints'.\nEnable that the debuggee stops on exceptions with a StoppedEvent (event type 'exception').",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "setExceptionBreakpoints" ]
					},
					"arguments": {
						"$ref": "#/definitions/SetExceptionBreakpointsArguments"
					}
				},
				"required": [ "command", "arguments"  ]
			}]
		},
		"SetExceptionBreakpointsArguments": {
			"type": "object",
			"description": "Arguments for 'setExceptionBreakpoints' request.",
			"properties": {
				"filters": {
					"type": "array",
					"items": {
						"type": "string"
					},
					"description": "Names of enabled exception breakpoints."
				}
			},
			"required": [ "filters" ]
		},
		"SetExceptionBreakpointsResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'setExceptionBreakpoints' request. This is just an acknowledgement, so no body field is required."
			}]
		},

		"ContinueRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "Continue request; value of command field is 'continue'.\nThe request starts the debuggee to run again.",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "continue" ]
					},
					"arguments": {
						"$ref": "#/definitions/ContinueArguments"
					}
				},
				"required": [ "command", "arguments"  ]
			}]
		},
		"ContinueArguments": {
			"type": "object",
			"description": "Arguments for 'continue' request.",
			"properties": {
				"threadId": {
					"type": "integer",
					"description": "Continue execution for the specified thread (if possible). If the backend cannot continue on a single thread but will continue on all threads, it should set the allThreadsContinued attribute in the response to true."
				}
			},
			"required": [ "threadId" ]
		},
		"ContinueResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'continue' request.",
				"properties": {
					"body": {
						"type": "object",
						"properties": {
							"allThreadsContinued": {
								"type": "boolean",
								"description": "If true, the continue request has ignored the specified thread and continued all threads instead. If this attribute is missing a value of 'true' is assumed for backward compatibility."
							}
						}
					}
				},
				"required": [ "body" ]
			}]
		},

		"NextRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "Next request; value of command field is 'next'.\nThe request starts the debuggee to run again for one step.\nThe debug adapter first sends the NextResponse and then a StoppedEvent (event type 'step') after the step has completed.",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "next" ]
					},
					"arguments": {
						"$ref": "#/definitions/NextArguments"
					}
				},
				"required": [ "command", "arguments"  ]
			}]
		},
		"NextArguments": {
			"type": "object",
			"description": "Arguments for 'next' request.",
			"properties": {
				"threadId": {
					"type": "integer",
					"description": "Continue execution for this thread."
				}
			},
			"required": [ "threadId" ]
		},
		"NextResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'next' request. This is just an acknowledgement, so no body field is required."
			}]
		},

		"StepInRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "StepIn request; value of command field is 'stepIn'.\nThe request starts the debuggee to step into a function/method if possible.\nIf it cannot step into a target, 'stepIn' behaves like 'next'.\nThe debug adapter first sends the StepInResponse and then a StoppedEvent (event type 'step') after the step has completed.\nIf there are multiple function/method calls (or other targets) on the source line,\nthe optional argument 'targetId' can be used to control into which target the 'stepIn' should occur.\nThe list of possible targets for a given source line can be retrieved via the 'stepInTargets' request.",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "stepIn" ]
					},
					"arguments": {
						"$ref": "#/definitions/StepInArguments"
					}
				},
				"required": [ "command", "arguments"  ]
			}]
		},
		"StepInArguments": {
			"type": "object",
			"description": "Arguments for 'stepIn' request.",
			"properties": {
				"threadId": {
					"type": "integer",
					"description": "Continue execution for this thread."
				},
				"targetId": {
					"type": "integer",
					"description": "Optional id of the target to step into."
				}
			},
			"required": [ "threadId" ]
		},
		"StepInResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'stepIn' request. This is just an acknowledgement, so no body field is required."
			}]
		},

		"StepOutRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "StepOut request; value of command field is 'stepOut'.\nThe request starts the debuggee to run again for one step.\nThe debug adapter first sends the StepOutResponse and then a StoppedEvent (event type 'step') after the step has completed.",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "stepOut" ]
					},
					"arguments": {
						"$ref": "#/definitions/StepOutArguments"
					}
				},
				"required": [ "command", "arguments"  ]
			}]
		},
		"StepOutArguments": {
			"type": "object",
			"description": "Arguments for 'stepOut' request.",
			"properties": {
				"threadId": {
					"type": "integer",
					"description": "Continue execution for this thread."
				}
			},
			"required": [ "threadId" ]
		},
		"StepOutResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'stepOut' request. This is just an acknowledgement, so no body field is required."
			}]
		},

		"StepBackRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "StepBack request; value of command field is 'stepBack'.\nThe request starts the debuggee to run one step backwards.\nThe debug adapter first sends the StepBackResponse and then a StoppedEvent (event type 'step') after the step has completed.",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "stepBack" ]
					},
					"arguments": {
						"$ref": "#/definitions/StepBackArguments"
					}
				},
				"required": [ "command", "arguments"  ]
			}]
		},
		"StepBackArguments": {
			"type": "object",
			"description": "Arguments for 'stepBack' request.",
			"properties": {
				"threadId": {
					"type": "integer",
					"description": "Continue execution for this thread."
				}
			},
			"required": [ "threadId" ]
		},
		"StepBackResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'stepBack' request. This is just an acknowledgement, so no body field is required."
			}]
		},

		"RestartFrameRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "RestartFrame request; value of command field is 'restartFrame'.\nThe request restarts execution of the specified stackframe.\nThe debug adapter first sends the RestartFrameResponse and then a StoppedEvent (event type 'restart') after the restart has completed.",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "restartFrame" ]
					},
					"arguments": {
						"$ref": "#/definitions/RestartFrameArguments"
					}
				},
				"required": [ "command", "arguments"  ]
			}]
		},
		"RestartFrameArguments": {
			"type": "object",
			"description": "Arguments for 'restartFrame' request.",
			"properties": {
				"frameId": {
					"type": "integer",
					"description": "Restart this stackframe."
				}
			},
			"required": [ "frameId" ]
		},
		"RestartFrameResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'restartFrame' request. This is just an acknowledgement, so no body field is required."
			}]
		},

		"GotoRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "Goto request; value of command field is 'goto'.\nThe request sets the location where the debuggee will continue to run.\nThis makes it possible to skip the execution of code or to executed code again.\nThe code between the current location and the goto target is not executed but skipped.\nThe debug adapter first sends the GotoResponse and then a StoppedEvent (event type 'goto').",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "goto" ]
					},
					"arguments": {
						"$ref": "#/definitions/GotoArguments"
					}
				},
				"required": [ "command", "arguments"  ]
			}]
		},
		"GotoArguments": {
			"type": "object",
			"description": "Arguments for 'goto' request.",
			"properties": {
				"threadId": {
					"type": "integer",
					"description": "Set the goto target for this thread."
				},
				"targetId": {
					"type": "integer",
					"description": "The location where the debuggee will continue to run."
				}
			},
			"required": [ "threadId", "targetId" ]
		},
		"GotoResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'goto' request. This is just an acknowledgement, so no body field is required."
			}]
		},

		"PauseRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "Pause request; value of command field is 'pause'.\nThe request suspenses the debuggee.\nThe debug adapter first sends the PauseResponse and then a StoppedEvent (event type 'pause') after the thread has been paused successfully.",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "pause" ]
					},
					"arguments": {
						"$ref": "#/definitions/PauseArguments"
					}
				},
				"required": [ "command", "arguments"  ]
			}]
		},
		"PauseArguments": {
			"type": "object",
			"description": "Arguments for 'pause' request.",
			"properties": {
				"threadId": {
					"type": "integer",
					"description": "Pause execution for this thread."
				}
			},
			"required": [ "threadId" ]
		},
		"PauseResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'pause' request. This is just an acknowledgement, so no body field is required."
			}]
		},

		"StackTraceRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "StackTrace request; value of command field is 'stackTrace'. The request returns a stacktrace from the current execution state.",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "stackTrace" ]
					},
					"arguments": {
						"$ref": "#/definitions/StackTraceArguments"
					}
				},
				"required": [ "command", "arguments"  ]
			}]
		},
		"StackTraceArguments": {
			"type": "object",
			"description": "Arguments for 'stackTrace' request.",
			"properties": {
				"threadId": {
					"type": "integer",
					"description": "Retrieve the stacktrace for this thread."
				},
				"startFrame": {
					"type": "integer",
					"description": "The index of the first frame to return; if omitted frames start at 0."
				},
				"levels": {
					"type": "integer",
					"description": "The maximum number of frames to return. If levels is not specified or 0, all frames are returned."
				}
			},
			"required": [ "threadId" ]
		},
		"StackTraceResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'stackTrace' request.",
				"properties": {
					"body": {
						"type": "object",
						"properties": {
							"stackFrames": {
								"type": "array",
								"items": {
									"$ref": "#/definitions/StackFrame"
								},
								"description": "The frames of the stackframe. If the array has length zero, there are no stackframes available.\nThis means that there is no location information available."
							},
							"totalFrames": {
								"type": "integer",
								"description": "The total number of frames available."
							}
						},
						"required": [ "stackFrames" ]
					}
				},
				"required": [ "body" ]
			}]
		},

		"ScopesRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "Scopes request; value of command field is 'scopes'.\nThe request returns the variable scopes for a given stackframe ID.",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "scopes" ]
					},
					"arguments": {
						"$ref": "#/definitions/ScopesArguments"
					}
				},
				"required": [ "command", "arguments"  ]
			}]
		},
		"ScopesArguments": {
			"type": "object",
			"description": "Arguments for 'scopes' request.",
			"properties": {
				"frameId": {
					"type": "integer",
					"description": "Retrieve the scopes for this stackframe."
				}
			},
			"required": [ "frameId" ]
		},
		"ScopesResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'scopes' request.",
				"properties": {
					"body": {
						"type": "object",
						"properties": {
							"scopes": {
								"type": "array",
								"items": {
									"$ref": "#/definitions/Scope"
								},
								"description": "The scopes of the stackframe. If the array has length zero, there are no scopes available."
							}
						},
						"required": [ "scopes" ]
					}
				},
				"required": [ "body" ]
			}]
		},

		"VariablesRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "Variables request; value of command field is 'variables'.\nRetrieves all child variables for the given variable reference.\nAn optional filter can be used to limit the fetched children to either named or indexed children.",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "variables" ]
					},
					"arguments": {
						"$ref": "#/definitions/VariablesArguments"
					}
				},
				"required": [ "command", "arguments"  ]
			}]
		},
		"VariablesArguments": {
			"type": "object",
			"description": "Arguments for 'variables' request.",
			"properties": {
				"variablesReference": {
					"type": "integer",
					"description": "The Variable reference."
				},
				"filter": {
					"type": "string",
					"enum": [ "indexed", "named" ],
					"description": "Optional filter to limit the child variables to either named or indexed. If ommited, both types are fetched."
				},
				"start": {
					"type": "integer",
					"description": "The index of the first variable to return; if omitted children start at 0."
				},
				"count": {
					"type": "integer",
					"description": "The number of variables to return. If count is missing or 0, all variables are returned."
				}
			},
			"required": [ "variablesReference" ]
		},
		"VariablesResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'variables' request.",
				"properties": {
					"body": {
						"type": "object",
						"properties": {
							"variables": {
								"type": "array",
								"items": {
									"$ref": "#/definitions/Variable"
								},
								"description": "All (or a range) of variables for the given variable reference."
							}
						},
						"required": [ "variables" ]
					}
				},
				"required": [ "body" ]
			}]
		},

		"SetVariableRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "setVariable request; value of command field is 'setVariable'.\nSet the variable with the given name in the variable container to a new value.",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "setVariable" ]
					},
					"arguments": {
						"$ref": "#/definitions/SetVariableArguments"
					}
				},
				"required": [ "command", "arguments"  ]
			}]
		},
		"SetVariableArguments": {
			"type": "object",
			"description": "Arguments for 'setVariable' request.",
			"properties": {
				"variablesReference": {
					"type": "integer",
					"description": "The reference of the variable container."
				},
				"name": {
					"type": "string",
					"description": "The name of the variable."
				},
				"value": {
					"type": "string",
					"description": "The value of the variable."
				}
			},
			"required": [ "variablesReference", "name", "value" ]
		},
		"SetVariableResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'setVariable' request.",
				"properties": {
					"body": {
						"type": "object",
						"properties": {
							"value": {
								"type": "string",
								"description": "The new value of the variable."
							},
							"type": {
								"type": "string",
								"description": "The type of the new value. Typically shown in the UI when hovering over the value."
							},
							"variablesReference": {
								"type": "number",
								"description": "If variablesReference is > 0, the new value is structured and its children can be retrieved by passing variablesReference to the VariablesRequest."
							},
							"namedVariables": {
								"type": "number",
								"description": "The number of named child variables.\nThe client can use this optional information to present the variables in a paged UI and fetch them in chunks."
							},
							"indexedVariables": {
								"type": "number",
								"description": "The number of indexed child variables.\nThe client can use this optional information to present the variables in a paged UI and fetch them in chunks."
							}
						},
						"required": [ "value" ]
					}
				},
				"required": [ "body" ]
			}]
		},

		"SourceRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "Source request; value of command field is 'source'.\nThe request retrieves the source code for a given source reference.",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "source" ]
					},
					"arguments": {
						"$ref": "#/definitions/SourceArguments"
					}
				},
				"required": [ "command", "arguments"  ]
			}]
		},
		"SourceArguments": {
			"type": "object",
			"description": "Arguments for 'source' request.",
			"properties": {
				"sourceReference": {
					"type": "integer",
					"description": "The reference to the source. This is the value received in Source.reference."
				}
			},
			"required": [ "sourceReference" ]
		},
		"SourceResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'source' request.",
				"properties": {
					"body": {
						"type": "object",
						"properties": {
							"content": {
								"type": "string",
								"description": "Content of the source reference."
							},
							"mimeType": {
								"type": "string",
								"description": "Optional content type (mime type) of the source."
							}
						},
						"required": [ "content" ]
					}
				},
				"required": [ "body" ]
			}]
		},

		"ThreadsRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "Thread request; value of command field is 'threads'.\nThe request retrieves a list of all threads.",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "threads" ]
					}
				},
				"required": [ "command" ]
			}]
		},
		"ThreadsResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'threads' request.",
				"properties": {
					"body": {
						"type": "object",
						"properties": {
							"threads": {
								"type": "array",
								"items": {
									"$ref": "#/definitions/Thread"
								},
								"description": "All threads."
							}
						},
						"required": [ "threads" ]
					}
				},
				"required": [ "body" ]
			}]
		},

		"ModulesRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "Modules can be retrieved from the debug adapter with the ModulesRequest which can either return all modules or a range of modules to support paging.",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "modules" ]
					},
					"arguments": {
						"$ref": "#/definitions/ModulesArguments"
					}
				},
				"required": [ "command", "arguments"  ]
			}]
		},
		"ModulesArguments": {
			"type": "object",
			"description": "Arguments for 'modules' request.",
			"properties": {
				"startModule": {
					"type": "integer",
					"description": "The index of the first module to return; if omitted modules start at 0."
				},
				"moduleCount": {
					"type": "integer",
					"description": "The number of modules to return. If moduleCount is not specified or 0, all modules are returned."
				}
			}
		},
		"ModulesResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'modules' request.",
				"properties": {
					"body": {
						"type": "object",
						"properties": {
							"modules": {
								"type": "array",
								"items": {
									"$ref": "#/definitions/Module"
								},
								"description": "All modules or range of modules."
							},
							"totalModules": {
								"type": "integer",
								"description": "The total number of modules available."
							}
						},
						"required": [ "modules" ]
					}
				},
				"required": [ "body" ]
			}]
		},

		"EvaluateRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "Evaluate request; value of command field is 'evaluate'.\nEvaluates the given expression in the context of the top most stack frame.\nThe expression has access to any variables and arguments that are in scope.",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "evaluate" ]
					},
					"arguments": {
						"$ref": "#/definitions/EvaluateArguments"
					}
				},
				"required": [ "command", "arguments"  ]
			}]
		},
		"EvaluateArguments": {
			"type": "object",
			"description": "Arguments for 'evaluate' request.",
			"properties": {
				"expression": {
					"type": "string",
					"description": "The expression to evaluate."
				},
				"frameId": {
					"type": "integer",
					"description": "Evaluate the expression in the scope of this stack frame. If not specified, the expression is evaluated in the global scope."
				},
				"context": {
					"type": "string",
					"_enum": [ "watch", "repl", "hover" ],
					"description": "The context in which the evaluate request is run. Possible values are 'watch' if evaluate is run in a watch, 'repl' if run from the REPL console, or 'hover' if run from a data hover."
				}
			},
			"required": [ "expression" ]
		},
		"EvaluateResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'evaluate' request.",
				"properties": {
					"body": {
						"type": "object",
						"properties": {
							"result": {
								"type": "string",
								"description": "The result of the evaluate request."
							},
							"type": {
								"type": "string",
								"description": "The optional type of the evaluate result."
							},
							"variablesReference": {
								"type": "number",
								"description": "If variablesReference is > 0, the evaluate result is structured and its children can be retrieved by passing variablesReference to the VariablesRequest."
							},
							"namedVariables": {
								"type": "number",
								"description": "The number of named child variables.\nThe client can use this optional information to present the variables in a paged UI and fetch them in chunks."
							},
							"indexedVariables": {
								"type": "number",
								"description": "The number of indexed child variables.\nThe client can use this optional information to present the variables in a paged UI and fetch them in chunks."
							}
						},
						"required": [ "result", "variablesReference" ]
					}
				},
				"required": [ "body" ]
			}]
		},

		"StepInTargetsRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "StepInTargets request; value of command field is 'stepInTargets'.\nThis request retrieves the possible stepIn targets for the specified stack frame.\nThese targets can be used in the 'stepIn' request.\nThe StepInTargets may only be called if the 'supportsStepInTargetsRequest' capability exists and is true.",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "stepInTargets" ]
					},
					"arguments": {
						"$ref": "#/definitions/StepInTargetsArguments"
					}
				},
				"required": [ "command", "arguments"  ]
			}]
		},
		"StepInTargetsArguments": {
			"type": "object",
			"description": "Arguments for 'stepInTargets' request.",
			"properties": {
				"frameId": {
					"type": "integer",
					"description": "The stack frame for which to retrieve the possible stepIn targets."
				}
			},
			"required": [ "frameId" ]
		},
		"StepInTargetsResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'stepInTargets' request.",
				"properties": {
					"body": {
						"type": "object",
						"properties": {
							"targets": {
								"type": "array",
								"items": {
									"$ref": "#/definitions/StepInTarget"
								},
								"description": "The possible stepIn targets of the specified source location."
							}
						},
						"required": [ "targets" ]
					}
				},
				"required": [ "body" ]
			}]
		},

		"GotoTargetsRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "GotoTargets request; value of command field is 'gotoTargets'.\nThis request retrieves the possible goto targets for the specified source location.\nThese targets can be used in the 'goto' request.\nThe GotoTargets request may only be called if the 'supportsGotoTargetsRequest' capability exists and is true.",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "gotoTargets" ]
					},
					"arguments": {
						"$ref": "#/definitions/GotoTargetsArguments"
					}
				},
				"required": [ "command", "arguments"  ]
			}]
		},
		"GotoTargetsArguments": {
			"type": "object",
			"description": "Arguments for 'gotoTargets' request.",
			"properties": {
				"source": {
					"$ref": "#/definitions/Source",
					"description": "The source location for which the goto targets are determined."
				},
				"line": {
					"type": "integer",
					"description": "The line location for which the goto targets are determined."
				},
				"column": {
					"type": "integer",
					"description": "An optional column location for which the goto targets are determined."
				}
			},
			"required": [ "source", "line" ]
		},
		"GotoTargetsResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'gotoTargets' request.",
				"properties": {
					"body": {
						"type": "object",
						"properties": {
							"targets": {
								"type": "array",
								"items": {
									"$ref": "#/definitions/GotoTarget"
								},
								"description": "The possible goto targets of the specified location."
							}
						},
						"required": [ "targets" ]
					}
				},
				"required": [ "body" ]
			}]
		},

		"CompletionsRequest": {
			"allOf": [ { "$ref": "#/definitions/Request" }, {
				"type": "object",
				"description": "CompletionsRequest request; value of command field is 'completions'.\nReturns a list of possible completions for a given caret position and text.\nThe CompletionsRequest may only be called if the 'supportsCompletionsRequest' capability exists and is true.",
				"properties": {
					"command": {
						"type": "string",
						"enum": [ "completions" ]
					},
					"arguments": {
						"$ref": "#/definitions/CompletionsArguments"
					}
				},
				"required": [ "command", "arguments"  ]
			}]
		},
		"CompletionsArguments": {
			"type": "object",
			"description": "Arguments for 'completions' request.",
			"properties": {
				"frameId": {
					"type": "integer",
					"description": "Returns completions in the scope of this stack frame. If not specified, the completions are returned for the global scope."
				},
				"text": {
					"type": "string",
					"description": "One or more source lines. Typically this is the text a user has typed into the debug console before he asked for completion."
				},
				"column": {
					"type": "integer",
					"description": "The character position for which to determine the completion proposals."
				},
				"line": {
					"type": "integer",
					"description": "An optional line for which to determine the completion proposals. If missing the first line of the text is assumed."
				}
			},
			"required": [ "text", "column" ]
		},
		"CompletionsResponse": {
			"allOf": [ { "$ref": "#/definitions/Response" }, {
				"type": "object",
				"description": "Response to 'completions' request.",
				"properties": {
					"body": {
						"type": "object",
						"properties": {
							"targets": {
								"type": "array",
								"items": {
									"$ref": "#/definitions/CompletionItem"
								},
								"description": "The possible completions for ."
							}
						},
						"required": [ "targets" ]
					}
				},
				"required": [ "body" ]
			}]
		},

		"Capabilities": {
			"type": "object",
			"description": "Information about the capabilities of a debug adapter.",
			"properties": {
				"supportsConfigurationDoneRequest": {
					"type": "boolean",
					"description": "The debug adapter supports the configurationDoneRequest."
				},
				"supportsFunctionBreakpoints": {
					"type": "boolean",
					"description": "The debug adapter supports function breakpoints."
				},
				"supportsConditionalBreakpoints": {
					"type": "boolean",
					"description": "The debug adapter supports conditional breakpoints."
				},
				"supportsHitConditionalBreakpoints": {
					"type": "boolean",
					"description": "The debug adapter supports breakpoints that break execution after a specified number of hits."
				},
				"supportsEvaluateForHovers": {
					"type": "boolean",
					"description": "The debug adapter supports a (side effect free) evaluate request for data hovers."
				},
				"exceptionBreakpointFilters": {
					"type": "array",
					"items": {
						"$ref": "#/definitions/ExceptionBreakpointsFilter"
					},
					"description": "Available filters for the setExceptionBreakpoints request."
				},
				"supportsStepBack": {
					"type": "boolean",
					"description": "The debug adapter supports stepping back."
				},
				"supportsSetVariable": {
					"type": "boolean",
					"description": "The debug adapter supports setting a variable to a value."
				},
				"supportsRestartFrame": {
					"type": "boolean",
					"description": "The debug adapter supports restarting a frame."
				},
				"supportsGotoTargetsRequest": {
					"type": "boolean",
					"description": "The debug adapter supports the gotoTargetsRequest."
				},
				"supportsStepInTargetsRequest": {
					"type": "boolean",
					"description": "The debug adapter supports the stepInTargetsRequest."
				},
				"supportsCompletionsRequest": {
					"type": "boolean",
					"description": "The debug adapter supports the completionsRequest."
				},
				"supportsModulesRequest": {
					"type": "boolean",
					"description": "The debug adapter supports the modules request."
				},
				"additionalModuleColumns": {
					"type": "array",
					"items": {
						"$ref": "#/definitions/ColumnDescriptor"
					},
					"description": "The set of additional module information exposed by the debug adapter."
				},
				"supportedChecksumAlgorithms": {
					"type": "array",
					"items": {
						"$ref": "#/definitions/ChecksumAlgorithm"
					},
					"description": "Checksum algorithms supported by the debug adapter."
				}
			}
		},

		"ExceptionBreakpointsFilter": {
			"type": "object",
			"description": "An ExceptionBreakpointsFilter is shown in the UI as an option for configuring how exceptions are dealt with.",
			"properties": {
				"filter": {
					"type": "string",
					"description": "The internal ID of the filter. This value is passed to the setExceptionBreakpoints request."
				},
				"label": {
					"type": "string",
					"description": "The name of the filter. This will be shown in the UI."
				},
				"default": {
					"type": "boolean",
					"description": "Initial value of the filter. If not specified a value 'false' is assumed."
				}
			},
			"required": [ "filter", "label" ]
		},

		"Message": {
			"type": "object",
			"description": "A structured message object. Used to return errors from requests.",
			"properties": {
				"id": {
					"type": "integer",
					"description": "Unique identifier for the message."
				},
				"format": {
					"type": "string",
					"description": "A format string for the message. Embedded variables have the form '{name}'.\nIf variable name starts with an underscore character, the variable does not contain user data (PII) and can be safely used for telemetry purposes."
				},
				"variables": {
					"type": "object",
					"description": "An object used as a dictionary for looking up the variables in the format string.",
					"additionalProperties": {
						"type": "string",
						"description": "Values must be strings."
					}
				},
				"sendTelemetry": {
					"type": "boolean",
					"description": "If true send to telemetry."
				},
				"showUser": {
					"type": "boolean",
					"description": "If true show user."
				},
				"url": {
					"type": "string",
					"description": "An optional url where additional information about this message can be found."
				},
				"urlLabel": {
					"type": "string",
					"description": "An optional label that is presented to the user as the UI for opening the url."
				}
			},
			"required": [ "id", "format" ]
		},

		"Module": {
			"type": "object",
			"description": "A Module object represents a row in the modules view.\nTwo attributes are mandatory: an id identifies a module in the modules view and is used in a ModuleEvent for identifying a module for adding, updating or deleting.\nThe name is used to minimally render the module in the UI.\n\nAdditional attributes can be added to the module. They will show up in the module View if they have a corresponding ColumnDescriptor.\n\nTo avoid an unnecessary proliferation of additional attributes with similar semantics but different names\nwe recommend to re-use attributes from the 'recommended' list below first, and only introduce new attributes if nothing appropriate could be found.",
			"properties": {
				"id": {
					"type": ["integer", "string"],
					"description": "Unique identifier for the module."
				},
				"name": {
					"type": "string",
					"description": "A name of the module."
				},
				"path": {
					"type": "string",
					"description": "optional but recommended attributes.\nalways try to use these first before introducing additional attributes.\n\nLogical full path to the module. The exact definition is implementation defined, but usually this would be a full path to the on-disk file for the module."
				},
				"isOptimized": {
					"type": "boolean",
					"description": "True if the module is optimized."
				},
				"isUserCode": {
					"type": "boolean",
					"description": "True if the module is considered 'user code' by a debugger that supports 'Just My Code'."
				},
				"version": {
					"type": "string",
					"description": "Version of Module."
				},
				"symbolStatus": {
					"type": "string",
					"description": "User understandable description of if symbols were found for the module (ex: 'Symbols Loaded', 'Symbols not found', etc."
				},
				"symbolFilePath": {
					"type": "string",
					"description": "Logical full path to the symbol file. The exact definition is implementation defined."
				},
				"dateTimeStamp": {
					"type": "string",
					"description": "Module created or modified."
				},
				"addressRange": {
					"type": "string",
					"description": "Address range covered by this module."
				}
			},
			"required": [ "id", "name" ]
		},

		"ColumnDescriptor": {
			"type": "object",
			"description": "A ColumnDescriptor specifies what module attribute to show in a column of the ModulesView, how to format it, and what the column's label should be.\nIt is only used if the underlying UI actually supports this level of customization.",
			"properties": {
				"attributeName": {
					"type": "string",
					"description": "Name of the attribute rendered in this column."
				},
				"label": {
					"type": "string",
					"description": "Header UI label of column."
				},
				"format": {
					"type": "string",
					"description": "Format to use for the rendered values in this column. TBD how the format strings looks like."
				},
				"type": {
					"type": "string",
					"enum": [ "string", "number", "boolean", "unixTimestampUTC" ],
					"description": "Datatype of values in this column.  Defaults to 'string' if not specified."
				},
				"width": {
					"type": "integer",
					"description": "Width of this column in characters (hint only)."
				}
			},
			"required": [ "attributeName", "label"]
		},

		"ModulesViewDescriptor": {
			"type": "object",
			"description": "The ModulesViewDescriptor is the container for all declarative configuration options of a ModuleView.\nFor now it only specifies the columns to be shown in the modules view.",
			"properties": {
				"columns": {
					"type": "array",
					"items": {
						"$ref": "#/definitions/ColumnDescriptor"
					}
				}
			},
			"required": [ "columns" ]
		},

		"Thread": {
			"type": "object",
			"description": "A Thread",
			"properties": {
				"id": {
					"type": "integer",
					"description": "Unique identifier for the thread."
				},
				"name": {
					"type": "string",
					"description": "A name of the thread."
				}
			},
			"required": [ "id", "name" ]
		},

		"Source": {
			"type": "object",
			"description": "A Source is a descriptor for source code. It is returned from the debug adapter as part of a StackFrame and it is used by clients when specifying breakpoints.",
			"properties": {
				"name": {
					"type": "string",
					"description": "The short name of the source. Every source returned from the debug adapter has a name. When specifying a source to the debug adapter this name is optional."
				},
				"path": {
					"type": "string",
					"description": "The long (absolute) path of the source. It is not guaranteed that the source exists at this location."
				},
				"sourceReference": {
					"type": "number",
					"description": "If sourceReference > 0 the contents of the source can be retrieved through the SourceRequest. A sourceReference is only valid for a session, so it must not be used to persist a source."
				},
				"origin": {
					"type": "string",
					"description": "The (optional) origin of this source: possible values 'internal module', 'inlined content from source map', etc."
				},
				"adapterData": {
					"type": [ "array", "boolean", "integer", "null", "number", "object", "string" ],
					"description": "Optional data that a debug adapter might want to loop through the client. The client should leave the data intact and persist it across sessions. The client should not interpret the data."
				},
				"checksums": {
					"type": "array",
					"items": {
						"$ref": "#/definitions/Checksum"
					},
					"description": "The checksums associated with this file."
				}
			}
		},

		"StackFrame": {
			"type": "object",
			"description": "A Stackframe contains the source location.",
			"properties": {
				"id": {
					"type": "integer",
					"description": "An identifier for the stack frame. It must be unique across all threads. This id can be used to retrieve the scopes of the frame with the 'scopesRequest' or to restart the execution of a stackframe."
				},
				"name": {
					"type": "string",
					"description": "The name of the stack frame, typically a method name."
				},
				"source": {
					"$ref": "#/definitions/Source",
					"description": "The optional source of the frame."
				},
				"line": {
					"type": "integer",
					"description": "The line within the file of the frame. If source is null or doesn't exist, line is 0 and must be ignored."
				},
				"column": {
					"type": "integer",
					"description": "The column within the line. If source is null or doesn't exist, column is 0 and must be ignored."
				},
				"endLine": {
					"type": "integer",
					"description": "An optional end line of the range covered by the stack frame."
				},
				"endColumn": {
					"type": "integer",
					"description": "An optional end column of the range covered by the stack frame."
				},
				"moduleId": {
					"type": ["integer", "string"],
					"description": "The module associated with this frame, if any."
				}
			},
			"required": [ "id", "name", "line", "column" ]
		},

		"Scope": {
			"type": "object",
			"description": "A Scope is a named container for variables. Optionally a scope can map to a source or a range within a source.",
			"properties": {
				"name": {
					"type": "string",
					"description": "Name of the scope such as 'Arguments', 'Locals'."
				},
				"variablesReference": {
					"type": "integer",
					"description": "The variables of this scope can be retrieved by passing the value of variablesReference to the VariablesRequest."
				},
				"namedVariables": {
					"type": "integer",
					"description": "The number of named variables in this scope.\nThe client can use this optional information to present the variables in a paged UI and fetch them in chunks."
				},
				"indexedVariables": {
					"type": "integer",
					"description": "The number of indexed variables in this scope.\nThe client can use this optional information to present the variables in a paged UI and fetch them in chunks."
				},
				"expensive": {
					"type": "boolean",
					"description": "If true, the number of variables in this scope is large or expensive to retrieve."
				},
				"source": {
					"$ref": "#/definitions/Source",
					"description": "Optional source for this scope."
				},
				"line": {
					"type": "integer",
					"description": "Optional start line of the range covered by this scope."
				},
				"column": {
					"type": "integer",
					"description": "Optional start column of the range covered by this scope."
				},
				"endLine": {
					"type": "integer",
					"description": "Optional end line of the range covered by this scope."
				},
				"endColumn": {
					"type": "integer",
					"description": "Optional end column of the range covered by this scope."
				}
			},
			"required": [ "name", "variablesReference", "expensive" ]
		},

		"Variable": {
			"type": "object",
			"description": "A Variable is a name/value pair.\nOptionally a variable can have a 'type' that is shown if space permits or when hovering over the variable's name.\nAn optional 'kind' is used to render additional properties of the variable, e.g. different icons can be used to indicate that a variable is public or private.\nIf the value is structured (has children), a handle is provided to retrieve the children with the VariablesRequest.\nIf the number of named or indexed children is large, the numbers should be returned via the optional 'namedVariables' and 'indexedVariables' attributes.\nThe client can use this optional information to present the children in a paged UI and fetch them in chunks.",
			"properties": {
				"name": {
					"type": "string",
					"description": "The variable's name."
				},
				"value": {
					"type": "string",
					"description": "The variable's value. For structured objects this can be a multi line text, e.g. for a function the body of a function."
				},
				"type": {
					"type": "string",
					"description": "The type of the variable's value. Typically shown in the UI when hovering over the value."
				},
				"kind": {
					"type": "string",
					"description": "Properties of a variable that can be used to determine how to render the variable in the UI. Format of the string value: TBD."
				},
				"evaluateName": {
					"type": "string",
					"description": "Optional evaluatable name of this variable which can be passed to the 'EvaluateRequest' to fetch the variable's value."
				},
				"variablesReference": {
					"type": "integer",
					"description": "If variablesReference is > 0, the variable is structured and its children can be retrieved by passing variablesReference to the VariablesRequest."
				},
				"namedVariables": {
					"type": "integer",
					"description": "The number of named child variables.\nThe client can use this optional information to present the children in a paged UI and fetch them in chunks."
				},
				"indexedVariables": {
					"type": "integer",
					"description": "The number of indexed child variables.\nThe client can use this optional information to present the children in a paged UI and fetch them in chunks."
				}
			},
			"required": [ "name", "value", "variablesReference" ]
		},

		"SourceBreakpoint": {
			"type": "object",
			"description": "Properties of a breakpoint passed to the setBreakpoints request.",
			"properties": {
				"line": {
					"type": "integer",
					"description": "The source line of the breakpoint."
				},
				"column": {
					"type": "integer",
					"description": "An optional source column of the breakpoint."
				},
				"condition": {
					"type": "string",
					"description": "An optional expression for conditional breakpoints."
				},
				"hitCondition": {
					"type": "string",
					"description": "An optional expression that controls how many hits of the breakpoint are ignored. The backend is expected to interpret the expression as needed."
				}
			},
			"required": [ "line" ]
		},

		"FunctionBreakpoint": {
			"type": "object",
			"description": "Properties of a breakpoint passed to the setFunctionBreakpoints request.",
			"properties": {
				"name": {
					"type": "string",
					"description": "The name of the function."
				},
				"condition": {
					"type": "string",
					"description": "An optional expression for conditional breakpoints."
				},
				"hitCondition": {
					"type": "string",
					"description": "An optional expression that controls how many hits of the breakpoint are ignored. The backend is expected to interpret the expression as needed."
				}
			},
			"required": [ "name" ]
		},

		"Breakpoint": {
			"type": "object",
			"description": "Information about a Breakpoint created in setBreakpoints or setFunctionBreakpoints.",
			"properties": {
				"id": {
					"type": "integer",
					"description": "An optional unique identifier for the breakpoint."
				},
				"verified": {
					"type": "boolean",
					"description": "If true breakpoint could be set (but not necessarily at the desired location)."
				},
				"message": {
					"type": "string",
					"description": "An optional message about the state of the breakpoint. This is shown to the user and can be used to explain why a breakpoint could not be verified."
				},
				"source": {
					"$ref": "#/definitions/Source",
					"description": "The source where the breakpoint is located."
				},
				"line": {
					"type": "integer",
					"description": "The start line of the actual range covered by the breakpoint."
				},
				"column": {
					"type": "integer",
					"description": "An optional start column of the actual range covered by the breakpoint."
				},
				"endLine": {
					"type": "integer",
					"description": "An optional end line of the actual range covered by the breakpoint."
				},
				"endColumn": {
					"type": "integer",
					"description": "An optional end column of the actual range covered by the breakpoint. If no end line is given, then the end column is assumed to be in the start line."
				}
			},
			"required": [ "verified" ]
		},

		"StepInTarget": {
			"type": "object",
			"description": "A StepInTarget can be used in the 'stepIn' request and determines into which single target the stepIn request should step.",
			"properties": {
				"id": {
					"type": "integer",
					"description": "Unique identifier for a stepIn target."
				},
				"label": {
					"type": "string",
					"description": "The name of the stepIn target (shown in the UI)."
				}
			},
			"required": [ "id", "label" ]
		},

		"GotoTarget": {
			"type": "object",
			"description": "A GotoTarget describes a code location that can be used as a target in the 'goto' request.\nThe possible goto targets can be determined via the 'gotoTargets' request.",
			"properties": {
				"id": {
					"type": "integer",
					"description": "Unique identifier for a goto target. This is used in the goto request."
				},
				"label": {
					"type": "string",
					"description": "The name of the goto target (shown in the UI)."
				},
				"line": {
					"type": "integer",
					"description": "The line of the goto target."
				},
				"column": {
					"type": "integer",
					"description": "An optional column of the goto target."
				},
				"endLine": {
					"type": "integer",
					"description": "An optional end line of the range covered by the goto target."
				},
				"endColumn": {
					"type": "integer",
					"description": "An optional end column of the range covered by the goto target."
				}
			},
			"required": [ "id", "label", "line" ]
		},

		"CompletionItem": {
			"type": "object",
			"description": "CompletionItems are the suggestions returned from the CompletionsRequest.",
			"properties": {
				"label": {
					"type": "string",
					"description": "The label of this completion item. By default this is also the text that is inserted when selecting this completion."
				},
				"text": {
					"type": "string",
					"description": "If text is not falsy then it is inserted instead of the label."
				},
				"type": {
					"$ref": "#/definitions/CompletionItemType",
					"description": "The item's type. Typically the client uses this information to render the item in the UI with an icon."
				},
				"start": {
					"type": "integer",
					"description": "When a completion is selected it replaces 'length' characters starting at 'start' in the text passed to the CompletionsRequest.\nIf missing the frontend will try to determine these values heuristically."
				},
				"length": {
					"type": "integer"
				}
			},
			"required": [ "label" ]
		},

		"CompletionItemType": {
			"type": "string",
			"description": "Some predefined types for the CompletionItem. Please note that not all clients have specific icons for all of them.",
			"enum": [ "method", "function", "constructor", "field", "variable", "class", "interface", "module", "property", "unit", "value", "enum", "keyword", "snippet", "text", "color", "file", "reference", "customcolor" ]
		},

		"ChecksumAlgorithm": {
			"type": "string",
			"description": "Names of checksum algorithms that may be supported by a debug adapter.",
			"enum": [ "MD5", "SHA1", "SHA256", "SHA1Normalized", "SHA256Normalized", "timestamp" ]
		},

		"Checksum": {
			"type": "object",
			"description": "The checksum of an item calculated by the specified algorithm.",
			"properties": {
				"algorithm": {
					"$ref": "#/definitions/ChecksumAlgorithm",
					"description": "The algorithm used to calculate this checksum."
				},
				"checksum": {
					"type": "string",
					"description": "Value of the checksum."
				}
			},
			"required": [ "algorithm", "checksum" ]
		}
	}
}

'''
'''--- tests/empty-struct.json ---
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "empty-struct",
    "type": "object",
    "additionalProperties": false
}

'''
'''--- tests/enum-names-int.json ---
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "enum-names",
    "type": "object",
    "enum": [1, 2],
    "enumNames": ["a", "b"]
}

'''
'''--- tests/enum-names-str.json ---
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "enum-names",
    "type": "object",
    "enum": ["1", "2"],
    "enumNames": ["a", "b"]
}

'''
'''--- tests/json_schema_test_suite.rs ---
//! Import the generated test suite modules.
//!
//! The tests can be generated by running the following:
//!
//! ```bash
//! $ cargo run --bin generate-tests
//! ```

mod test_suite;

'''
'''--- tests/nested.json ---
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "nestedtest",
    "type": "object",
    "properties": {},
    "required": [
        "top"
    ],
    "definitions": {
        "top": {
            "type": "object",
            "properties": {
                "basic": {
                    "type": "string"
                },
                "nested": {
                    "$ref": "#/definitions/top/definitions/defnested"
                }
            },
            "definitions": {
                "defnested": {
                    "type": "object",
                    "properties": {
                        "append": {
                            "type": "string"
                        }
                    }
                }
            }
        }
    }
}

'''
'''--- tests/one-of-types.json ---
{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "one-of-types",
  "type": "object",
  "oneOf": [
    {
      "properties": {
        "bar": {
          "type": "integer"
        }
      },
      "required": [
        "bar"
      ]
    },
    {
      "properties": {
        "foo": {
          "type": "string"
        }
      },
      "required": [
        "foo"
      ]
    }
  ]
}

'''
'''--- tests/option-type.json ---
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "option-type",
    "type": "object",
    "properties": {
        "optional": { "type": "string" },
        "optional-multi": { "type": ["integer", "null"] },
        "required": { "type": "string" },
        "required-multi": { "type": ["integer", "null"] }
    },
    "required": [
        "required",
        "required-multi"
    ]
}

'''
'''--- tests/pattern-properties.json ---
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "pattern-properties",
    "type": "object",
    "additionalProperties": false,
    "patternProperties": {
        "foo": {
            "type": "object",
            "additionalProperties": true
        }
    }
}

'''
'''--- tests/recursive_types.json ---
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "recursive_types",
    "type": "object",
    "properties": {},
    "required": [
        "test_a"
    ],
    "definitions": {
        "test_a": {
            "properties": {
                "arr": {
                    "type": "array",
                    "$ref": "#/definitions/test_a"
                },
                "ref": {
                    "$ref": "#/definitions/test_a"
                }
            }
        }
    }
}

'''
'''--- tests/root-array.json ---
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "title": "root-array",
    "type": "array",
    "items": {
        "type": "object",
        "properties": {
            "value": { "type": "integer" }
        },
        "additionalProperties": false
    }
}

'''
'''--- tests/support/schema-test.rs ---
extern crate schema;
extern crate serde_json;

fn main() {
    let s = include_str!("../../src/schema.json");
    let _: schema::Schema = serde_json::from_str(s).unwrap();
}

'''
'''--- tests/test.rs ---
use serde_derive::{Deserialize, Serialize};
use serde_repr::{Deserialize_repr, Serialize_repr};

schemafy::schemafy!(
    root: Schema
    "schemafy_lib/src/schema.json"
);

fn schema_exists(schema: Option<&Schema>) {
    if let Some(schema) = schema {
        let _ = &schema.type_;
    }
}

fn types_exists(_: Option<(&SimpleTypes, PositiveInteger)>) {}

#[test]
fn test() {
    schema_exists(None);
    types_exists(None);
}

schemafy::schemafy!("tests/debugserver-schema.json");

#[test]
fn debugserver_types() {
    let request: Option<SourceRequest> = None;
    if let Some(r) = request {
        let _: &SourceArguments = &r.arguments;
    }
}

schemafy::schemafy!("tests/nested.json");

#[test]
fn nested() {
    let _: Option<Defnested> = None;
}

schemafy::schemafy!("tests/vega/vega.json");

schemafy::schemafy!(
    root: OptionType
    "tests/option-type.json"
);

#[test]
fn option_type() {
    let o: Option<OptionType> = None;
    if let Some(o) = o {
        let _: Option<String> = o.optional;
        let _: Option<i64> = o.optional_multi;
        let _: String = o.required;
        let _: Option<i64> = o.required_multi;
    }
    // FIXME: this fails
    //serde_json::from_str::<OptionType>(r#"{"required": ""}"#).unwrap_err();
    serde_json::from_str::<OptionType>(r#"{"required-multi": 5}"#).unwrap_err();
    serde_json::from_str::<OptionType>(r#"{"required": "", "required-multi": 5}"#).unwrap();
    assert_eq!(
        serde_json::to_string(&OptionType {
            optional: None,
            optional_multi: None,
            required: "".into(),
            required_multi: None,
        })
        .unwrap(),
        r#"{"required":"","required-multi":null}"#
    );
}

schemafy::schemafy!(
    root: ArrayType
    "tests/array-type.json"
);

#[test]
fn array_type() {
    let o: Option<ArrayType> = None;
    if let Some(o) = o {
        let _: Vec<i64> = o.required;
        let _: Option<Vec<i64>> = o.optional;
    }
    serde_json::from_str::<ArrayType>("{}").unwrap_err();
    serde_json::from_str::<ArrayType>(r#"{"required": []}"#).unwrap();
    assert_eq!(
        serde_json::to_string(&ArrayType {
            required: Vec::new(),
            optional: None,
        })
        .unwrap(),
        r#"{"required":[]}"#
    );
}

schemafy::schemafy!(
    root: EmptyStruct
    "tests/empty-struct.json"
);

#[test]
fn empty_struct() {
    let EmptyStruct {} = EmptyStruct {};
}

schemafy::schemafy!(
    root: AnyProperties
    "tests/any-properties.json"
);

#[test]
fn any_properties() {
    let _: ::std::collections::BTreeMap<String, serde_json::Value> = AnyProperties::default();
}

schemafy::schemafy!(
    root: RootArray
    "tests/root-array.json"
);

#[test]
fn root_array() {
    let a = RootArray::default();
    let _: Option<&RootArrayItem> = a.get(0);
}

schemafy::schemafy!(
    root: EnumNamesInt
    "tests/enum-names-int.json"
);

#[test]
fn enum_names_int() {
    assert_eq!(serde_json::to_string(&EnumNamesInt::A).unwrap(), "1");
    assert_eq!(serde_json::to_string(&EnumNamesInt::B).unwrap(), "2");
}

schemafy::schemafy!(
    root: EnumNamesStr
    "tests/enum-names-str.json"
);

#[test]
fn enum_names_str() {
    assert_eq!(serde_json::to_string(&EnumNamesStr::A).unwrap(), "\"1\"");
    assert_eq!(serde_json::to_string(&EnumNamesStr::B).unwrap(), "\"2\"");
}

schemafy::schemafy!(
    root: RecursiveTypes
    "tests/recursive_types.json"
);

#[allow(dead_code)]
fn recursive_types_exist(_: RecursiveTypes) {}

schemafy::schemafy!(
    root: OneOfSchema
    "tests/one-of-types.json"
);

#[test]
fn one_of_parsing() {
    let t1: OneOfSchema = serde_json::from_str(r#"{"bar":2}"#).unwrap();
    assert_eq!(t1, OneOfSchema::Variant0(OneOfSchemaVariant0 { bar: 2 }));

    let t2: OneOfSchema = serde_json::from_str(r#"{"foo":"baz"}"#).unwrap();
    assert_eq!(
        t2,
        OneOfSchema::Variant1(OneOfSchemaVariant1 {
            foo: "baz".to_string()
        })
    );

    // This should return an error, but serde still parses it
    let t3: OneOfSchema = serde_json::from_str(r#"{"bar": 2, "foo":"baz"}"#).unwrap();
    assert_eq!(t3, OneOfSchema::Variant0(OneOfSchemaVariant0 { bar: 2 }));

    assert!(serde_json::from_str::<OneOfSchema>(r#"{"foo":3}"#).is_err());
}

schemafy::schemafy!(
    root: PatternProperties
    "tests/pattern-properties.json"
);

#[test]
fn unknown_fields() {
    // empty struct with additionalProperties: false
    serde_json::from_str::<EmptyStruct>(r#"{"zzz": 5}"#).unwrap_err();
    // non-empty struct with additionalProperties: false
    serde_json::from_str::<RootArrayItem>(r#"{"zzz": 5}"#).unwrap_err();
    // empty struct with additionalProperties: true
    serde_json::from_str::<AnyProperties>(r#"{"zzz": 5}"#).unwrap();
    // empty struct with additionalProperties: false and patternProperties
    // non-empty
    serde_json::from_str::<PatternProperties>(r#"{"zzz": 5}"#).unwrap();
    // non-empty struct with additionalProperties unspecified
    serde_json::from_str::<ArrayType>(r#"{"required": [], "zzz": 5}"#).unwrap();
}

'''
'''--- tests/vega/vega.json ---
{
  "$ref": "#/definitions/TopLevelExtendedSpec",
  "$schema": "http://json-schema.org/draft-04/schema#",
  "definitions": {
    "Aggregate": {
      "$ref": "#/definitions/AggregateOp"
    },
    "AggregateOp": {
      "enum": [
        "argmax",
        "argmin",
        "average",
        "count",
        "distinct",
        "max",
        "mean",
        "median",
        "min",
        "missing",
        "q1",
        "q3",
        "ci0",
        "ci1",
        "stdev",
        "stdevp",
        "sum",
        "valid",
        "values",
        "variance",
        "variancep"
      ],
      "type": "string"
    },
    "AggregateTransform": {
      "additionalProperties": false,
      "properties": {
        "aggregate": {
          "description": "Array of objects that define fields to aggregate.",
          "items": {
            "$ref": "#/definitions/AggregatedFieldDef"
          },
          "type": "array"
        },
        "groupby": {
          "description": "The data fields to group by. If not specified, a single group containing all data objects will be used.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "aggregate"
      ],
      "type": "object"
    },
    "AggregatedFieldDef": {
      "additionalProperties": false,
      "properties": {
        "as": {
          "description": "The output field names to use for each aggregated field.",
          "type": "string"
        },
        "field": {
          "description": "The data field for which to compute aggregate function.",
          "type": "string"
        },
        "op": {
          "$ref": "#/definitions/AggregateOp",
          "description": "The aggregation operations to apply to the fields, such as sum, average or count.\nSee the [full list of supported aggregation operations](https://vega.github.io/vega-lite/docs/aggregate.html#ops)\nfor more information."
        }
      },
      "required": [
        "op",
        "field",
        "as"
      ],
      "type": "object"
    },
    "Anchor": {
      "enum": [
        "start",
        "middle",
        "end"
      ],
      "type": "string"
    },
    "AnyMark": {
      "anyOf": [
        {
          "$ref": "#/definitions/Mark"
        },
        {
          "$ref": "#/definitions/MarkDef"
        }
      ]
    },
    "AutoSizeParams": {
      "additionalProperties": false,
      "properties": {
        "contains": {
          "description": "Determines how size calculation should be performed, one of `\"content\"` or `\"padding\"`. The default setting (`\"content\"`) inteprets the width and height settings as the data rectangle (plotting) dimensions, to which padding is then added. In contrast, the `\"padding\"` setting includes the padding within the view size calculations, such that the width and height settings indicate the **total** intended size of the view.\n\n__Default value__: `\"content\"`",
          "enum": [
            "content",
            "padding"
          ],
          "type": "string"
        },
        "resize": {
          "description": "A boolean flag indicating if autosize layout should be re-calculated on every view update.\n\n__Default value__: `false`",
          "type": "boolean"
        },
        "type": {
          "$ref": "#/definitions/AutosizeType",
          "description": "The sizing format type. One of `\"pad\"`, `\"fit\"` or `\"none\"`. See the [autosize type](https://vega.github.io/vega-lite/docs/size.html#autosize) documentation for descriptions of each.\n\n__Default value__: `\"pad\"`"
        }
      },
      "type": "object"
    },
    "AutosizeType": {
      "enum": [
        "pad",
        "fit",
        "none"
      ],
      "type": "string"
    },
    "Axis": {
      "additionalProperties": false,
      "properties": {
        "domain": {
          "description": "A boolean flag indicating if the domain (the axis baseline) should be included as part of the axis.\n\n__Default value:__ `true`",
          "type": "boolean"
        },
        "format": {
          "description": "The formatting pattern for labels. This is D3's [number format pattern](https://github.com/d3/d3-format#locale_format) for quantitative fields and D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format) for time field.\n\nSee the [format documentation](format.html) for more information.\n\n__Default value:__  derived from [numberFormat](config.html#format) config for quantitative fields and from [timeFormat](config.html#format) config for temporal fields.",
          "type": "string"
        },
        "grid": {
          "description": "A boolean flag indicating if grid lines should be included as part of the axis\n\n__Default value:__ `true` for [continuous scales](scale.html#continuous) that are not binned; otherwise, `false`.",
          "type": "boolean"
        },
        "labelAngle": {
          "description": "The rotation angle of the axis labels.\n\n__Default value:__ `-90` for nominal and ordinal fields; `0` otherwise.",
          "maximum": 360,
          "minimum": -360,
          "type": "number"
        },
        "labelBound": {
          "description": "Indicates if labels should be hidden if they exceed the axis range. If `false `(the default) no bounds overlap analysis is performed. If `true`, labels will be hidden if they exceed the axis range by more than 1 pixel. If this property is a number, it specifies the pixel tolerance: the maximum amount by which a label bounding box may exceed the axis range.\n\n__Default value:__ `false`.",
          "type": [
            "boolean",
            "number"
          ]
        },
        "labelFlush": {
          "description": "Indicates if the first and last axis labels should be aligned flush with the scale range. Flush alignment for a horizontal axis will left-align the first label and right-align the last label. For vertical axes, bottom and top text baselines are applied instead. If this property is a number, it also indicates the number of pixels by which to offset the first and last labels; for example, a value of 2 will flush-align the first and last labels and also push them 2 pixels outward from the center of the axis. The additional adjustment can sometimes help the labels better visually group with corresponding axis ticks.\n\n__Default value:__ `true` for axis of a continuous x-scale. Otherwise, `false`.",
          "type": [
            "boolean",
            "number"
          ]
        },
        "labelOverlap": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "enum": [
                "parity"
              ],
              "type": "string"
            },
            {
              "enum": [
                "greedy"
              ],
              "type": "string"
            }
          ],
          "description": "The strategy to use for resolving overlap of axis labels. If `false` (the default), no overlap reduction is attempted. If set to `true` or `\"parity\"`, a strategy of removing every other label is used (this works well for standard linear axes). If set to `\"greedy\"`, a linear scan of the labels is performed, removing any labels that overlaps with the last visible label (this often works better for log-scaled axes).\n\n__Default value:__ `true` for non-nominal fields with non-log scales; `\"greedy\"` for log scales; otherwise `false`."
        },
        "labelPadding": {
          "description": "The padding, in pixels, between axis and text labels.",
          "type": "number"
        },
        "labels": {
          "description": "A boolean flag indicating if labels should be included as part of the axis.\n\n__Default value:__  `true`.",
          "type": "boolean"
        },
        "maxExtent": {
          "description": "The maximum extent in pixels that axis ticks and labels should use. This determines a maximum offset value for axis titles.\n\n__Default value:__ `undefined`.",
          "type": "number"
        },
        "minExtent": {
          "description": "The minimum extent in pixels that axis ticks and labels should use. This determines a minimum offset value for axis titles.\n\n__Default value:__ `30` for y-axis; `undefined` for x-axis.",
          "type": "number"
        },
        "offset": {
          "description": "The offset, in pixels, by which to displace the axis from the edge of the enclosing group or data rectangle.\n\n__Default value:__ derived from the [axis config](config.html#facet-scale-config)'s `offset` (`0` by default)",
          "type": "number"
        },
        "orient": {
          "$ref": "#/definitions/AxisOrient",
          "description": "The orientation of the axis. One of `\"top\"`, `\"bottom\"`, `\"left\"` or `\"right\"`. The orientation can be used to further specialize the axis type (e.g., a y axis oriented for the right edge of the chart).\n\n__Default value:__ `\"bottom\"` for x-axes and `\"left\"` for y-axes."
        },
        "position": {
          "description": "The anchor position of the axis in pixels. For x-axis with top or bottom orientation, this sets the axis group x coordinate. For y-axis with left or right orientation, this sets the axis group y coordinate.\n\n__Default value__: `0`",
          "type": "number"
        },
        "tickCount": {
          "description": "A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are \"nice\" (multiples of 2, 5, 10) and lie within the underlying scale's range.",
          "type": "number"
        },
        "tickSize": {
          "description": "The size in pixels of axis ticks.",
          "minimum": 0,
          "type": "number"
        },
        "ticks": {
          "description": "Boolean value that determines whether the axis should include ticks.",
          "type": "boolean"
        },
        "title": {
          "description": "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`).  If the field has an aggregate function, the function is displayed as a part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function will be denoted in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`).  Otherwise, the title is simply the field name.\n\n__Note__: You can customize the default field title format by providing the [`fieldTitle` property in the [config](config.html) or [`fieldTitle` function via the `compile` function's options](compile.html#field-title).",
          "type": [
            "string",
            "null"
          ]
        },
        "titleMaxLength": {
          "description": "Max length for axis title if the title is automatically generated from the field's description.",
          "type": "number"
        },
        "titlePadding": {
          "description": "The padding, in pixels, between title and axis.",
          "type": "number"
        },
        "values": {
          "anyOf": [
            {
              "items": {
                "type": "number"
              },
              "type": "array"
            },
            {
              "items": {
                "$ref": "#/definitions/DateTime"
              },
              "type": "array"
            }
          ],
          "description": "Explicitly set the visible axis tick values."
        },
        "zindex": {
          "description": "A non-positive integer indicating z-index of the axis.\nIf zindex is 0, axes should be drawn behind all chart elements.\nTo put them in front, use `\"zindex = 1\"`.\n\n__Default value:__ `1` (in front of the marks) for actual axis and `0` (behind the marks) for grids.",
          "minimum": 0,
          "type": "number"
        }
      },
      "type": "object"
    },
    "AxisConfig": {
      "additionalProperties": false,
      "properties": {
        "bandPosition": {
          "description": "An interpolation fraction indicating where, for `band` scales, axis ticks should be positioned. A value of `0` places ticks at the left edge of their bands. A value of `0.5` places ticks in the middle of their bands.",
          "type": "number"
        },
        "domain": {
          "description": "A boolean flag indicating if the domain (the axis baseline) should be included as part of the axis.\n\n__Default value:__ `true`",
          "type": "boolean"
        },
        "domainColor": {
          "description": "Color of axis domain line.\n\n__Default value:__  (none, using Vega default).",
          "type": "string"
        },
        "domainWidth": {
          "description": "Stroke width of axis domain line\n\n__Default value:__  (none, using Vega default).",
          "type": "number"
        },
        "grid": {
          "description": "A boolean flag indicating if grid lines should be included as part of the axis\n\n__Default value:__ `true` for [continuous scales](scale.html#continuous) that are not binned; otherwise, `false`.",
          "type": "boolean"
        },
        "gridColor": {
          "description": "Color of gridlines.",
          "type": "string"
        },
        "gridDash": {
          "description": "The offset (in pixels) into which to begin drawing with the grid dash array.",
          "items": {
            "type": "number"
          },
          "type": "array"
        },
        "gridOpacity": {
          "description": "The stroke opacity of grid (value between [0,1])\n\n__Default value:__ (`1` by default)",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "gridWidth": {
          "description": "The grid width, in pixels.",
          "minimum": 0,
          "type": "number"
        },
        "labelAngle": {
          "description": "The rotation angle of the axis labels.\n\n__Default value:__ `-90` for nominal and ordinal fields; `0` otherwise.",
          "maximum": 360,
          "minimum": -360,
          "type": "number"
        },
        "labelBound": {
          "description": "Indicates if labels should be hidden if they exceed the axis range. If `false `(the default) no bounds overlap analysis is performed. If `true`, labels will be hidden if they exceed the axis range by more than 1 pixel. If this property is a number, it specifies the pixel tolerance: the maximum amount by which a label bounding box may exceed the axis range.\n\n__Default value:__ `false`.",
          "type": [
            "boolean",
            "number"
          ]
        },
        "labelColor": {
          "description": "The color of the tick label, can be in hex color code or regular color name.",
          "type": "string"
        },
        "labelFlush": {
          "description": "Indicates if the first and last axis labels should be aligned flush with the scale range. Flush alignment for a horizontal axis will left-align the first label and right-align the last label. For vertical axes, bottom and top text baselines are applied instead. If this property is a number, it also indicates the number of pixels by which to offset the first and last labels; for example, a value of 2 will flush-align the first and last labels and also push them 2 pixels outward from the center of the axis. The additional adjustment can sometimes help the labels better visually group with corresponding axis ticks.\n\n__Default value:__ `true` for axis of a continuous x-scale. Otherwise, `false`.",
          "type": [
            "boolean",
            "number"
          ]
        },
        "labelFont": {
          "description": "The font of the tick label.",
          "type": "string"
        },
        "labelFontSize": {
          "description": "The font size of the label, in pixels.",
          "minimum": 0,
          "type": "number"
        },
        "labelLimit": {
          "description": "Maximum allowed pixel width of axis tick labels.",
          "type": "number"
        },
        "labelOverlap": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "enum": [
                "parity"
              ],
              "type": "string"
            },
            {
              "enum": [
                "greedy"
              ],
              "type": "string"
            }
          ],
          "description": "The strategy to use for resolving overlap of axis labels. If `false` (the default), no overlap reduction is attempted. If set to `true` or `\"parity\"`, a strategy of removing every other label is used (this works well for standard linear axes). If set to `\"greedy\"`, a linear scan of the labels is performed, removing any labels that overlaps with the last visible label (this often works better for log-scaled axes).\n\n__Default value:__ `true` for non-nominal fields with non-log scales; `\"greedy\"` for log scales; otherwise `false`."
        },
        "labelPadding": {
          "description": "The padding, in pixels, between axis and text labels.",
          "type": "number"
        },
        "labels": {
          "description": "A boolean flag indicating if labels should be included as part of the axis.\n\n__Default value:__  `true`.",
          "type": "boolean"
        },
        "maxExtent": {
          "description": "The maximum extent in pixels that axis ticks and labels should use. This determines a maximum offset value for axis titles.\n\n__Default value:__ `undefined`.",
          "type": "number"
        },
        "minExtent": {
          "description": "The minimum extent in pixels that axis ticks and labels should use. This determines a minimum offset value for axis titles.\n\n__Default value:__ `30` for y-axis; `undefined` for x-axis.",
          "type": "number"
        },
        "shortTimeLabels": {
          "description": "Whether month names and weekday names should be abbreviated.\n\n__Default value:__  `false`",
          "type": "boolean"
        },
        "tickColor": {
          "description": "The color of the axis's tick.",
          "type": "string"
        },
        "tickRound": {
          "description": "Boolean flag indicating if pixel position values should be rounded to the nearest integer.",
          "type": "boolean"
        },
        "tickSize": {
          "description": "The size in pixels of axis ticks.",
          "minimum": 0,
          "type": "number"
        },
        "tickWidth": {
          "description": "The width, in pixels, of ticks.",
          "minimum": 0,
          "type": "number"
        },
        "ticks": {
          "description": "Boolean value that determines whether the axis should include ticks.",
          "type": "boolean"
        },
        "titleAlign": {
          "description": "Horizontal text alignment of axis titles.",
          "type": "string"
        },
        "titleAngle": {
          "description": "Angle in degrees of axis titles.",
          "type": "number"
        },
        "titleBaseline": {
          "description": "Vertical text baseline for axis titles.",
          "type": "string"
        },
        "titleColor": {
          "description": "Color of the title, can be in hex color code or regular color name.",
          "type": "string"
        },
        "titleFont": {
          "description": "Font of the title. (e.g., `\"Helvetica Neue\"`).",
          "type": "string"
        },
        "titleFontSize": {
          "description": "Font size of the title.",
          "minimum": 0,
          "type": "number"
        },
        "titleFontWeight": {
          "description": "Font weight of the title. (e.g., `\"bold\"`).",
          "type": [
            "string",
            "number"
          ]
        },
        "titleLimit": {
          "description": "Maximum allowed pixel width of axis titles.",
          "type": "number"
        },
        "titleMaxLength": {
          "description": "Max length for axis title if the title is automatically generated from the field's description.",
          "type": "number"
        },
        "titlePadding": {
          "description": "The padding, in pixels, between title and axis.",
          "type": "number"
        },
        "titleX": {
          "description": "X-coordinate of the axis title relative to the axis group.",
          "type": "number"
        },
        "titleY": {
          "description": "Y-coordinate of the axis title relative to the axis group.",
          "type": "number"
        }
      },
      "type": "object"
    },
    "AxisOrient": {
      "enum": [
        "top",
        "right",
        "left",
        "bottom"
      ],
      "type": "string"
    },
    "AxisResolveMap": {
      "additionalProperties": false,
      "properties": {
        "x": {
          "$ref": "#/definitions/ResolveMode"
        },
        "y": {
          "$ref": "#/definitions/ResolveMode"
        }
      },
      "type": "object"
    },
    "BarConfig": {
      "additionalProperties": false,
      "properties": {
        "align": {
          "$ref": "#/definitions/HorizontalAlign",
          "description": "The horizontal alignment of the text. One of `\"left\"`, `\"right\"`, `\"center\"`."
        },
        "angle": {
          "description": "The rotation angle of the text, in degrees.",
          "maximum": 360,
          "minimum": 0,
          "type": "number"
        },
        "baseline": {
          "$ref": "#/definitions/VerticalAlign",
          "description": "The vertical alignment of the text. One of `\"top\"`, `\"middle\"`, `\"bottom\"`.\n\n__Default value:__ `\"middle\"`"
        },
        "binSpacing": {
          "description": "Offset between bar for binned field.  Ideal value for this is either 0 (Preferred by statisticians) or 1 (Vega-Lite Default, D3 example style).\n\n__Default value:__ `1`",
          "minimum": 0,
          "type": "number"
        },
        "color": {
          "description": "Default color.  Note that `fill` and `stroke` have higher precedence than `color` and will override `color`.\n\n__Default value:__ <span style=\"color: #4682b4;\">&#9632;</span> `\"#4682b4\"`\n\n__Note:__ This property cannot be used in a [style config](mark.html#style-config).",
          "type": "string"
        },
        "continuousBandSize": {
          "description": "The default size of the bars on continuous scales.\n\n__Default value:__ `5`",
          "minimum": 0,
          "type": "number"
        },
        "cursor": {
          "description": "The mouse cursor used over the mark. Any valid [CSS cursor type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.",
          "enum": [
            "auto",
            "default",
            "none",
            "context-menu",
            "help",
            "pointer",
            "progress",
            "wait",
            "cell",
            "crosshair",
            "text",
            "vertical-text",
            "alias",
            "copy",
            "move",
            "no-drop",
            "not-allowed",
            "e-resize",
            "n-resize",
            "ne-resize",
            "nw-resize",
            "s-resize",
            "se-resize",
            "sw-resize",
            "w-resize",
            "ew-resize",
            "ns-resize",
            "nesw-resize",
            "nwse-resize",
            "col-resize",
            "row-resize",
            "all-scroll",
            "zoom-in",
            "zoom-out",
            "grab",
            "grabbing"
          ],
          "type": "string"
        },
        "discreteBandSize": {
          "description": "The size of the bars.  If unspecified, the default size is  `bandSize-1`,\nwhich provides 1 pixel offset between bars.",
          "minimum": 0,
          "type": "number"
        },
        "dx": {
          "description": "The horizontal offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.",
          "type": "number"
        },
        "dy": {
          "description": "The vertical offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.",
          "type": "number"
        },
        "fill": {
          "description": "Default Fill Color.  This has higher precedence than config.color\n\n__Default value:__ (None)",
          "type": "string"
        },
        "fillOpacity": {
          "description": "The fill opacity (value between [0,1]).\n\n__Default value:__ `1`",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "filled": {
          "description": "Whether the mark's color should be used as fill color instead of stroke color.\n\n__Default value:__ `true` for all marks except `point` and `false` for `point`.\n\n__Applicable for:__ `bar`, `point`, `circle`, `square`, and `area` marks.\n\n__Note:__ This property cannot be used in a [style config](mark.html#style-config).",
          "type": "boolean"
        },
        "font": {
          "description": "The typeface to set the text in (e.g., `\"Helvetica Neue\"`).",
          "type": "string"
        },
        "fontSize": {
          "description": "The font size, in pixels.",
          "minimum": 0,
          "type": "number"
        },
        "fontStyle": {
          "$ref": "#/definitions/FontStyle",
          "description": "The font style (e.g., `\"italic\"`)."
        },
        "fontWeight": {
          "anyOf": [
            {
              "$ref": "#/definitions/FontWeight"
            },
            {
              "$ref": "#/definitions/FontWeightNumber"
            }
          ],
          "description": "The font weight (e.g., `\"bold\"`)."
        },
        "href": {
          "description": "A URL to load upon mouse click. If defined, the mark acts as a hyperlink.",
          "format": "uri",
          "type": "string"
        },
        "interpolate": {
          "$ref": "#/definitions/Interpolate",
          "description": "The line interpolation method to use for line and area marks. One of the following:\n- `\"linear\"`: piecewise linear segments, as in a polyline.\n- `\"linear-closed\"`: close the linear segments to form a polygon.\n- `\"step\"`: alternate between horizontal and vertical segments, as in a step function.\n- `\"step-before\"`: alternate between vertical and horizontal segments, as in a step function.\n- `\"step-after\"`: alternate between horizontal and vertical segments, as in a step function.\n- `\"basis\"`: a B-spline, with control point duplication on the ends.\n- `\"basis-open\"`: an open B-spline; may not intersect the start or end.\n- `\"basis-closed\"`: a closed B-spline, as in a loop.\n- `\"cardinal\"`: a Cardinal spline, with control point duplication on the ends.\n- `\"cardinal-open\"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.\n- `\"cardinal-closed\"`: a closed Cardinal spline, as in a loop.\n- `\"bundle\"`: equivalent to basis, except the tension parameter is used to straighten the spline.\n- `\"monotone\"`: cubic interpolation that preserves monotonicity in y."
        },
        "limit": {
          "description": "The maximum length of the text mark in pixels (default 0, indicating no limit). The text value will be automatically truncated if the rendered size exceeds the limit.",
          "type": "number"
        },
        "opacity": {
          "description": "The overall opacity (value between [0,1]).\n\n__Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "orient": {
          "$ref": "#/definitions/Orient",
          "description": "The orientation of a non-stacked bar, tick, area, and line charts.\nThe value is either horizontal (default) or vertical.\n- For bar, rule and tick, this determines whether the size of the bar and tick\nshould be applied to x or y dimension.\n- For area, this property determines the orient property of the Vega output.\n- For line, this property determines the sort order of the points in the line\nif `config.sortLineBy` is not specified.\nFor stacked charts, this is always determined by the orientation of the stack;\ntherefore explicitly specified value will be ignored."
        },
        "radius": {
          "description": "Polar coordinate radial offset, in pixels, of the text label from the origin determined by the `x` and `y` properties.",
          "minimum": 0,
          "type": "number"
        },
        "shape": {
          "description": "The default symbol shape to use. One of: `\"circle\"` (default), `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`, or `\"triangle-down\"`, or a custom SVG path.\n\n__Default value:__ `\"circle\"`",
          "type": "string"
        },
        "size": {
          "description": "The pixel area each the point/circle/square.\nFor example: in the case of circles, the radius is determined in part by the square root of the size value.\n\n__Default value:__ `30`",
          "minimum": 0,
          "type": "number"
        },
        "stroke": {
          "description": "Default Stroke Color.  This has higher precedence than config.color\n\n__Default value:__ (None)",
          "type": "string"
        },
        "strokeDash": {
          "description": "An array of alternating stroke, space lengths for creating dashed or dotted lines.",
          "items": {
            "type": "number"
          },
          "type": "array"
        },
        "strokeDashOffset": {
          "description": "The offset (in pixels) into which to begin drawing with the stroke dash array.",
          "type": "number"
        },
        "strokeOpacity": {
          "description": "The stroke opacity (value between [0,1]).\n\n__Default value:__ `1`",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "strokeWidth": {
          "description": "The stroke width, in pixels.",
          "minimum": 0,
          "type": "number"
        },
        "tension": {
          "description": "Depending on the interpolation type, sets the tension parameter (for line and area marks).",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "text": {
          "description": "Placeholder text if the `text` channel is not specified",
          "type": "string"
        },
        "theta": {
          "description": "Polar coordinate angle, in radians, of the text label from the origin determined by the `x` and `y` properties. Values for `theta` follow the same convention of `arc` mark `startAngle` and `endAngle` properties: angles are measured in radians, with `0` indicating \"north\".",
          "type": "number"
        }
      },
      "type": "object"
    },
    "BasicType": {
      "enum": [
        "quantitative",
        "ordinal",
        "temporal",
        "nominal"
      ],
      "type": "string"
    },
    "BinParams": {
      "additionalProperties": false,
      "description": "Binning properties or boolean flag for determining whether to bin data or not.",
      "properties": {
        "base": {
          "description": "The number base to use for automatic bin determination (default is base 10).\n\n__Default value:__ `10`",
          "type": "number"
        },
        "divide": {
          "description": "Scale factors indicating allowable subdivisions. The default value is [5, 2], which indicates that for base 10 numbers (the default base), the method may consider dividing bin sizes by 5 and/or 2. For example, for an initial step size of 10, the method can check if bin sizes of 2 (= 10/5), 5 (= 10/2), or 1 (= 10/(5*2)) might also satisfy the given constraints.\n\n__Default value:__ `[5, 2]`",
          "items": {
            "type": "number"
          },
          "minItems": 1,
          "type": "array"
        },
        "extent": {
          "description": "A two-element (`[min, max]`) array indicating the range of desired bin values.",
          "items": {
            "type": "number"
          },
          "maxItems": 2,
          "minItems": 2,
          "type": "array"
        },
        "maxbins": {
          "description": "Maximum number of bins.\n\n__Default value:__ `6` for `row`, `column` and `shape` channels; `10` for other channels",
          "minimum": 2,
          "type": "number"
        },
        "minstep": {
          "description": "A minimum allowable step size (particularly useful for integer values).",
          "type": "number"
        },
        "nice": {
          "description": "If true (the default), attempts to make the bin boundaries use human-friendly boundaries, such as multiples of ten.",
          "type": "boolean"
        },
        "step": {
          "description": "An exact step size to use between bins.\n\n__Note:__ If provided, options such as maxbins will be ignored.",
          "type": "number"
        },
        "steps": {
          "description": "An array of allowable step sizes to choose from.",
          "items": {
            "type": "number"
          },
          "minItems": 1,
          "type": "array"
        }
      },
      "type": "object"
    },
    "BinTransform": {
      "additionalProperties": false,
      "properties": {
        "as": {
          "description": "The output fields at which to write the start and end bin values.",
          "type": "string"
        },
        "bin": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/BinParams"
            }
          ],
          "description": "An object indicating bin properties, or simply `true` for using default bin parameters."
        },
        "field": {
          "description": "The data field to bin.",
          "type": "string"
        }
      },
      "required": [
        "bin",
        "field",
        "as"
      ],
      "type": "object"
    },
    "BrushConfig": {
      "additionalProperties": false,
      "properties": {
        "fill": {
          "description": "The fill color of the interval mark.\n\n__Default value:__ `#333333`",
          "type": "string"
        },
        "fillOpacity": {
          "description": "The fill opacity of the interval mark (a value between 0 and 1).\n\n__Default value:__ `0.125`",
          "type": "number"
        },
        "stroke": {
          "description": "The stroke color of the interval mark.\n\n__Default value:__ `#ffffff`",
          "type": "string"
        },
        "strokeDash": {
          "description": "An array of alternating stroke and space lengths,\nfor creating dashed or dotted lines.",
          "items": {
            "type": "number"
          },
          "type": "array"
        },
        "strokeDashOffset": {
          "description": "The offset (in pixels) with which to begin drawing the stroke dash array.",
          "type": "number"
        },
        "strokeOpacity": {
          "description": "The stroke opacity of the interval mark (a value between 0 and 1).",
          "type": "number"
        },
        "strokeWidth": {
          "description": "The stroke width of the interval mark.",
          "type": "number"
        }
      },
      "type": "object"
    },
    "CalculateTransform": {
      "additionalProperties": false,
      "properties": {
        "as": {
          "description": "The field for storing the computed formula value.",
          "type": "string"
        },
        "calculate": {
          "description": "A [expression](types.html#expression) string. Use the variable `datum` to refer to the current data object.",
          "type": "string"
        }
      },
      "required": [
        "calculate",
        "as"
      ],
      "type": "object"
    },
    "CompositeUnitSpec": {
      "$ref": "#/definitions/CompositeUnitSpecAlias",
      "description": "Unit spec that can have a composite mark."
    },
    "Conditional<FieldDef>": {
      "anyOf": [
        {
          "$ref": "#/definitions/ConditionalPredicate<FieldDef>"
        },
        {
          "$ref": "#/definitions/ConditionalSelection<FieldDef>"
        }
      ]
    },
    "Conditional<MarkPropFieldDef>": {
      "anyOf": [
        {
          "$ref": "#/definitions/ConditionalPredicate<MarkPropFieldDef>"
        },
        {
          "$ref": "#/definitions/ConditionalSelection<MarkPropFieldDef>"
        }
      ]
    },
    "Conditional<TextFieldDef>": {
      "anyOf": [
        {
          "$ref": "#/definitions/ConditionalPredicate<TextFieldDef>"
        },
        {
          "$ref": "#/definitions/ConditionalSelection<TextFieldDef>"
        }
      ]
    },
    "Conditional<ValueDef>": {
      "anyOf": [
        {
          "$ref": "#/definitions/ConditionalPredicate<ValueDef>"
        },
        {
          "$ref": "#/definitions/ConditionalSelection<ValueDef>"
        }
      ]
    },
    "ConditionalPredicate<FieldDef>": {
      "additionalProperties": false,
      "properties": {
        "aggregate": {
          "$ref": "#/definitions/Aggregate",
          "description": "Aggregation function for the field\n(e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).\n\n__Default value:__ `undefined` (None)"
        },
        "bin": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/BinParams"
            }
          ],
          "description": "A flag for binning a `quantitative` field, or [an object defining binning parameters](bin.html#params).\nIf `true`, default [binning parameters](bin.html) will be applied.\n\n__Default value:__ `false`"
        },
        "field": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/RepeatRef"
            }
          ],
          "description": "__Required.__ A string defining the name of the field from which to pull a data value\nor an object defining iterated values from the [`repeat`](repeat.html) operator.\n\n__Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`).\nIf field names contain dots or brackets but are not nested, you can use `\\\\` to escape dots and brackets (e.g., `\"a\\\\.b\"` and `\"a\\\\[0\\\\]\"`).\nSee more details about escaping in the [field documentation](field.html).\n\n__Note:__ `field` is not required if `aggregate` is `count`."
        },
        "test": {
          "$ref": "#/definitions/LogicalOperand<Predicate>"
        },
        "timeUnit": {
          "$ref": "#/definitions/TimeUnit",
          "description": "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.\nor [a temporal field that gets casted as ordinal](type.html#cast).\n\n__Default value:__ `undefined` (None)"
        },
        "type": {
          "$ref": "#/definitions/Type",
          "description": "The encoded field's type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`).\nIt can also be a geo type (`\"latitude\"`, `\"longitude\"`, and `\"geojson\"`) when a [geographic projection](projection.html) is applied."
        }
      },
      "required": [
        "test",
        "type"
      ],
      "type": "object"
    },
    "ConditionalPredicate<MarkPropFieldDef>": {
      "additionalProperties": false,
      "properties": {
        "aggregate": {
          "$ref": "#/definitions/Aggregate",
          "description": "Aggregation function for the field\n(e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).\n\n__Default value:__ `undefined` (None)"
        },
        "bin": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/BinParams"
            }
          ],
          "description": "A flag for binning a `quantitative` field, or [an object defining binning parameters](bin.html#params).\nIf `true`, default [binning parameters](bin.html) will be applied.\n\n__Default value:__ `false`"
        },
        "field": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/RepeatRef"
            }
          ],
          "description": "__Required.__ A string defining the name of the field from which to pull a data value\nor an object defining iterated values from the [`repeat`](repeat.html) operator.\n\n__Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`).\nIf field names contain dots or brackets but are not nested, you can use `\\\\` to escape dots and brackets (e.g., `\"a\\\\.b\"` and `\"a\\\\[0\\\\]\"`).\nSee more details about escaping in the [field documentation](field.html).\n\n__Note:__ `field` is not required if `aggregate` is `count`."
        },
        "legend": {
          "anyOf": [
            {
              "$ref": "#/definitions/Legend"
            },
            {
              "type": "null"
            }
          ],
          "description": "An object defining properties of the legend.\nIf `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](legend.html) are applied."
        },
        "scale": {
          "$ref": "#/definitions/Scale",
          "description": "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\n__Default value:__ If undefined, default [scale properties](scale.html) are applied."
        },
        "sort": {
          "anyOf": [
            {
              "$ref": "#/definitions/SortOrder"
            },
            {
              "$ref": "#/definitions/SortField"
            },
            {
              "type": "null"
            }
          ],
          "description": "Sort order for the encoded field.\nSupported `sort` values include `\"ascending\"`, `\"descending\"` and `null` (no sorting).\nFor fields with discrete domains, `sort` can also be a [sort field definition object](sort.html#sort-field).\n\n__Default value:__ `\"ascending\"`"
        },
        "test": {
          "$ref": "#/definitions/LogicalOperand<Predicate>"
        },
        "timeUnit": {
          "$ref": "#/definitions/TimeUnit",
          "description": "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.\nor [a temporal field that gets casted as ordinal](type.html#cast).\n\n__Default value:__ `undefined` (None)"
        },
        "type": {
          "$ref": "#/definitions/Type",
          "description": "The encoded field's type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`).\nIt can also be a geo type (`\"latitude\"`, `\"longitude\"`, and `\"geojson\"`) when a [geographic projection](projection.html) is applied."
        }
      },
      "required": [
        "test",
        "type"
      ],
      "type": "object"
    },
    "ConditionalPredicate<TextFieldDef>": {
      "additionalProperties": false,
      "properties": {
        "aggregate": {
          "$ref": "#/definitions/Aggregate",
          "description": "Aggregation function for the field\n(e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).\n\n__Default value:__ `undefined` (None)"
        },
        "bin": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/BinParams"
            }
          ],
          "description": "A flag for binning a `quantitative` field, or [an object defining binning parameters](bin.html#params).\nIf `true`, default [binning parameters](bin.html) will be applied.\n\n__Default value:__ `false`"
        },
        "field": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/RepeatRef"
            }
          ],
          "description": "__Required.__ A string defining the name of the field from which to pull a data value\nor an object defining iterated values from the [`repeat`](repeat.html) operator.\n\n__Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`).\nIf field names contain dots or brackets but are not nested, you can use `\\\\` to escape dots and brackets (e.g., `\"a\\\\.b\"` and `\"a\\\\[0\\\\]\"`).\nSee more details about escaping in the [field documentation](field.html).\n\n__Note:__ `field` is not required if `aggregate` is `count`."
        },
        "format": {
          "description": "The [formatting pattern](format.html) for a text field. If not defined, this will be determined automatically.",
          "type": "string"
        },
        "test": {
          "$ref": "#/definitions/LogicalOperand<Predicate>"
        },
        "timeUnit": {
          "$ref": "#/definitions/TimeUnit",
          "description": "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.\nor [a temporal field that gets casted as ordinal](type.html#cast).\n\n__Default value:__ `undefined` (None)"
        },
        "type": {
          "$ref": "#/definitions/Type",
          "description": "The encoded field's type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`).\nIt can also be a geo type (`\"latitude\"`, `\"longitude\"`, and `\"geojson\"`) when a [geographic projection](projection.html) is applied."
        }
      },
      "required": [
        "test",
        "type"
      ],
      "type": "object"
    },
    "ConditionalPredicate<ValueDef>": {
      "additionalProperties": false,
      "properties": {
        "test": {
          "$ref": "#/definitions/LogicalOperand<Predicate>"
        },
        "value": {
          "description": "A constant value in visual domain (e.g., `\"red\"` / \"#0099ff\" for color, values between `0` to `1` for opacity).",
          "type": [
            "number",
            "string",
            "boolean"
          ]
        }
      },
      "required": [
        "test",
        "value"
      ],
      "type": "object"
    },
    "ConditionalSelection<FieldDef>": {
      "additionalProperties": false,
      "properties": {
        "aggregate": {
          "$ref": "#/definitions/Aggregate",
          "description": "Aggregation function for the field\n(e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).\n\n__Default value:__ `undefined` (None)"
        },
        "bin": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/BinParams"
            }
          ],
          "description": "A flag for binning a `quantitative` field, or [an object defining binning parameters](bin.html#params).\nIf `true`, default [binning parameters](bin.html) will be applied.\n\n__Default value:__ `false`"
        },
        "field": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/RepeatRef"
            }
          ],
          "description": "__Required.__ A string defining the name of the field from which to pull a data value\nor an object defining iterated values from the [`repeat`](repeat.html) operator.\n\n__Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`).\nIf field names contain dots or brackets but are not nested, you can use `\\\\` to escape dots and brackets (e.g., `\"a\\\\.b\"` and `\"a\\\\[0\\\\]\"`).\nSee more details about escaping in the [field documentation](field.html).\n\n__Note:__ `field` is not required if `aggregate` is `count`."
        },
        "selection": {
          "$ref": "#/definitions/SelectionOperand",
          "description": "A [selection name](selection.html), or a series of [composed selections](selection.html#compose)."
        },
        "timeUnit": {
          "$ref": "#/definitions/TimeUnit",
          "description": "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.\nor [a temporal field that gets casted as ordinal](type.html#cast).\n\n__Default value:__ `undefined` (None)"
        },
        "type": {
          "$ref": "#/definitions/Type",
          "description": "The encoded field's type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`).\nIt can also be a geo type (`\"latitude\"`, `\"longitude\"`, and `\"geojson\"`) when a [geographic projection](projection.html) is applied."
        }
      },
      "required": [
        "selection",
        "type"
      ],
      "type": "object"
    },
    "ConditionalSelection<MarkPropFieldDef>": {
      "additionalProperties": false,
      "properties": {
        "aggregate": {
          "$ref": "#/definitions/Aggregate",
          "description": "Aggregation function for the field\n(e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).\n\n__Default value:__ `undefined` (None)"
        },
        "bin": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/BinParams"
            }
          ],
          "description": "A flag for binning a `quantitative` field, or [an object defining binning parameters](bin.html#params).\nIf `true`, default [binning parameters](bin.html) will be applied.\n\n__Default value:__ `false`"
        },
        "field": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/RepeatRef"
            }
          ],
          "description": "__Required.__ A string defining the name of the field from which to pull a data value\nor an object defining iterated values from the [`repeat`](repeat.html) operator.\n\n__Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`).\nIf field names contain dots or brackets but are not nested, you can use `\\\\` to escape dots and brackets (e.g., `\"a\\\\.b\"` and `\"a\\\\[0\\\\]\"`).\nSee more details about escaping in the [field documentation](field.html).\n\n__Note:__ `field` is not required if `aggregate` is `count`."
        },
        "legend": {
          "anyOf": [
            {
              "$ref": "#/definitions/Legend"
            },
            {
              "type": "null"
            }
          ],
          "description": "An object defining properties of the legend.\nIf `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](legend.html) are applied."
        },
        "scale": {
          "$ref": "#/definitions/Scale",
          "description": "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\n__Default value:__ If undefined, default [scale properties](scale.html) are applied."
        },
        "selection": {
          "$ref": "#/definitions/SelectionOperand",
          "description": "A [selection name](selection.html), or a series of [composed selections](selection.html#compose)."
        },
        "sort": {
          "anyOf": [
            {
              "$ref": "#/definitions/SortOrder"
            },
            {
              "$ref": "#/definitions/SortField"
            },
            {
              "type": "null"
            }
          ],
          "description": "Sort order for the encoded field.\nSupported `sort` values include `\"ascending\"`, `\"descending\"` and `null` (no sorting).\nFor fields with discrete domains, `sort` can also be a [sort field definition object](sort.html#sort-field).\n\n__Default value:__ `\"ascending\"`"
        },
        "timeUnit": {
          "$ref": "#/definitions/TimeUnit",
          "description": "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.\nor [a temporal field that gets casted as ordinal](type.html#cast).\n\n__Default value:__ `undefined` (None)"
        },
        "type": {
          "$ref": "#/definitions/Type",
          "description": "The encoded field's type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`).\nIt can also be a geo type (`\"latitude\"`, `\"longitude\"`, and `\"geojson\"`) when a [geographic projection](projection.html) is applied."
        }
      },
      "required": [
        "selection",
        "type"
      ],
      "type": "object"
    },
    "ConditionalSelection<TextFieldDef>": {
      "additionalProperties": false,
      "properties": {
        "aggregate": {
          "$ref": "#/definitions/Aggregate",
          "description": "Aggregation function for the field\n(e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).\n\n__Default value:__ `undefined` (None)"
        },
        "bin": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/BinParams"
            }
          ],
          "description": "A flag for binning a `quantitative` field, or [an object defining binning parameters](bin.html#params).\nIf `true`, default [binning parameters](bin.html) will be applied.\n\n__Default value:__ `false`"
        },
        "field": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/RepeatRef"
            }
          ],
          "description": "__Required.__ A string defining the name of the field from which to pull a data value\nor an object defining iterated values from the [`repeat`](repeat.html) operator.\n\n__Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`).\nIf field names contain dots or brackets but are not nested, you can use `\\\\` to escape dots and brackets (e.g., `\"a\\\\.b\"` and `\"a\\\\[0\\\\]\"`).\nSee more details about escaping in the [field documentation](field.html).\n\n__Note:__ `field` is not required if `aggregate` is `count`."
        },
        "format": {
          "description": "The [formatting pattern](format.html) for a text field. If not defined, this will be determined automatically.",
          "type": "string"
        },
        "selection": {
          "$ref": "#/definitions/SelectionOperand",
          "description": "A [selection name](selection.html), or a series of [composed selections](selection.html#compose)."
        },
        "timeUnit": {
          "$ref": "#/definitions/TimeUnit",
          "description": "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.\nor [a temporal field that gets casted as ordinal](type.html#cast).\n\n__Default value:__ `undefined` (None)"
        },
        "type": {
          "$ref": "#/definitions/Type",
          "description": "The encoded field's type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`).\nIt can also be a geo type (`\"latitude\"`, `\"longitude\"`, and `\"geojson\"`) when a [geographic projection](projection.html) is applied."
        }
      },
      "required": [
        "selection",
        "type"
      ],
      "type": "object"
    },
    "ConditionalSelection<ValueDef>": {
      "additionalProperties": false,
      "properties": {
        "selection": {
          "$ref": "#/definitions/SelectionOperand",
          "description": "A [selection name](selection.html), or a series of [composed selections](selection.html#compose)."
        },
        "value": {
          "description": "A constant value in visual domain (e.g., `\"red\"` / \"#0099ff\" for color, values between `0` to `1` for opacity).",
          "type": [
            "number",
            "string",
            "boolean"
          ]
        }
      },
      "required": [
        "selection",
        "value"
      ],
      "type": "object"
    },
    "Config": {
      "additionalProperties": false,
      "properties": {
        "area": {
          "$ref": "#/definitions/MarkConfig",
          "description": "Area-Specific Config "
        },
        "autosize": {
          "anyOf": [
            {
              "$ref": "#/definitions/AutosizeType"
            },
            {
              "$ref": "#/definitions/AutoSizeParams"
            }
          ],
          "description": "Sets how the visualization size should be determined. If a string, should be one of `\"pad\"`, `\"fit\"` or `\"none\"`.\nObject values can additionally specify parameters for content sizing and automatic resizing.\n`\"fit\"` is only supported for single and layered views that don't use `rangeStep`.\n\n__Default value__: `pad`"
        },
        "axis": {
          "$ref": "#/definitions/AxisConfig",
          "description": "Axis configuration, which determines default properties for all `x` and `y` [axes](axis.html). For a full list of axis configuration options, please see the [corresponding section of the axis documentation](axis.html#config)."
        },
        "axisBand": {
          "$ref": "#/definitions/VgAxisConfig",
          "description": "Specific axis config for axes with \"band\" scales."
        },
        "axisBottom": {
          "$ref": "#/definitions/VgAxisConfig",
          "description": "Specific axis config for x-axis along the bottom edge of the chart."
        },
        "axisLeft": {
          "$ref": "#/definitions/VgAxisConfig",
          "description": "Specific axis config for y-axis along the left edge of the chart."
        },
        "axisRight": {
          "$ref": "#/definitions/VgAxisConfig",
          "description": "Specific axis config for y-axis along the right edge of the chart."
        },
        "axisTop": {
          "$ref": "#/definitions/VgAxisConfig",
          "description": "Specific axis config for x-axis along the top edge of the chart."
        },
        "axisX": {
          "$ref": "#/definitions/VgAxisConfig",
          "description": "X-axis specific config."
        },
        "axisY": {
          "$ref": "#/definitions/VgAxisConfig",
          "description": "Y-axis specific config."
        },
        "background": {
          "description": "CSS color property to use as the background of visualization.\n\n__Default value:__ none (transparent)",
          "type": "string"
        },
        "bar": {
          "$ref": "#/definitions/BarConfig",
          "description": "Bar-Specific Config "
        },
        "circle": {
          "$ref": "#/definitions/MarkConfig",
          "description": "Circle-Specific Config "
        },
        "countTitle": {
          "description": "Default axis and legend title for count fields.\n\n__Default value:__ `'Number of Records'`.",
          "type": "string"
        },
        "fieldTitle": {
          "description": "Defines how Vega-Lite generates title for fields.  There are three possible styles:\n- `\"verbal\"` (Default) - displays function in a verbal style (e.g., \"Sum of field\", \"Year-month of date\", \"field (binned)\").\n- `\"function\"` - displays function using parentheses and capitalized texts (e.g., \"SUM(field)\", \"YEARMONTH(date)\", \"BIN(field)\").\n- `\"plain\"` - displays only the field name without functions (e.g., \"field\", \"date\", \"field\").",
          "enum": [
            "verbal",
            "functional",
            "plain"
          ],
          "type": "string"
        },
        "geoshape": {
          "$ref": "#/definitions/MarkConfig",
          "description": "Geoshape-Specific Config "
        },
        "invalidValues": {
          "description": "Defines how Vega-Lite should handle invalid values (`null` and `NaN`).\n- If set to `\"filter\"` (default), all data items with null values are filtered.\n- If `null`, all data items are included. In this case, invalid values will be interpreted as zeroes.",
          "enum": [
            "filter",
            null
          ],
          "type": [
            "string",
            "null"
          ]
        },
        "legend": {
          "$ref": "#/definitions/LegendConfig",
          "description": "Legend configuration, which determines default properties for all [legends](legend.html). For a full list of legend configuration options, please see the [corresponding section of in the legend documentation](legend.html#config)."
        },
        "line": {
          "$ref": "#/definitions/MarkConfig",
          "description": "Line-Specific Config "
        },
        "mark": {
          "$ref": "#/definitions/MarkConfig",
          "description": "Mark Config "
        },
        "numberFormat": {
          "description": "D3 Number format for axis labels and text tables. For example \"s\" for SI units. Use [D3's number format pattern](https://github.com/d3/d3-format#locale_format).",
          "type": "string"
        },
        "padding": {
          "$ref": "#/definitions/Padding",
          "description": "The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle.  If a number, specifies padding for all sides.\nIf an object, the value should have the format `{\"left\": 5, \"top\": 5, \"right\": 5, \"bottom\": 5}` to specify padding for each side of the visualization.\n\n__Default value__: `5`"
        },
        "point": {
          "$ref": "#/definitions/MarkConfig",
          "description": "Point-Specific Config "
        },
        "projection": {
          "$ref": "#/definitions/ProjectionConfig",
          "description": "Projection configuration, which determines default properties for all [projections](projection.html). For a full list of projection configuration options, please see the [corresponding section of the projection documentation](projection.html#config)."
        },
        "range": {
          "$ref": "#/definitions/RangeConfig",
          "description": "An object hash that defines default range arrays or schemes for using with scales.\nFor a full list of scale range configuration options, please see the [corresponding section of the scale documentation](scale.html#config)."
        },
        "rect": {
          "$ref": "#/definitions/MarkConfig",
          "description": "Rect-Specific Config "
        },
        "rule": {
          "$ref": "#/definitions/MarkConfig",
          "description": "Rule-Specific Config "
        },
        "scale": {
          "$ref": "#/definitions/ScaleConfig",
          "description": "Scale configuration determines default properties for all [scales](scale.html). For a full list of scale configuration options, please see the [corresponding section of the scale documentation](scale.html#config)."
        },
        "selection": {
          "$ref": "#/definitions/SelectionConfig",
          "description": "An object hash for defining default properties for each type of selections. "
        },
        "square": {
          "$ref": "#/definitions/MarkConfig",
          "description": "Square-Specific Config "
        },
        "stack": {
          "$ref": "#/definitions/StackOffset",
          "description": "Default stack offset for stackable mark. "
        },
        "style": {
          "$ref": "#/definitions/StyleConfigIndex",
          "description": "An object hash that defines key-value mappings to determine default properties for marks with a given [style](mark.html#mark-def).  The keys represent styles names; the value are valid [mark configuration objects](mark.html#config).  "
        },
        "text": {
          "$ref": "#/definitions/TextConfig",
          "description": "Text-Specific Config "
        },
        "tick": {
          "$ref": "#/definitions/TickConfig",
          "description": "Tick-Specific Config "
        },
        "timeFormat": {
          "description": "Default datetime format for axis and legend labels. The format can be set directly on each axis and legend. Use [D3's time format pattern](https://github.com/d3/d3-time-format#locale_format).\n\n__Default value:__ `'%b %d, %Y'`.",
          "type": "string"
        },
        "title": {
          "$ref": "#/definitions/VgTitleConfig",
          "description": "Title configuration, which determines default properties for all [titles](title.html). For a full list of title configuration options, please see the [corresponding section of the title documentation](title.html#config)."
        },
        "view": {
          "$ref": "#/definitions/ViewConfig",
          "description": "Default properties for [single view plots](spec.html#single). "
        }
      },
      "type": "object"
    },
    "CsvDataFormat": {
      "additionalProperties": false,
      "properties": {
        "parse": {
          "anyOf": [
            {
              "enum": [
                "auto"
              ],
              "type": "string"
            },
            {
              "type": "object"
            }
          ],
          "description": "If set to auto (the default), perform automatic type inference to determine the desired data types.\nAlternatively, a parsing directive object can be provided for explicit data types. Each property of the object corresponds to a field name, and the value to the desired data type (one of `\"number\"`, `\"boolean\"` or `\"date\"`).\nFor example, `\"parse\": {\"modified_on\": \"date\"}` parses the `modified_on` field in each input record a Date value.\n\nFor `\"date\"`, we parse data based using Javascript's [`Date.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse).\nFor Specific date formats can be provided (e.g., `{foo: 'date:\"%m%d%Y\"'}`), using the [d3-time-format syntax](https://github.com/d3/d3-time-format#locale_format). UTC date format parsing is supported similarly (e.g., `{foo: 'utc:\"%m%d%Y\"'}`). See more about [UTC time](timeunit.html#utc)"
        },
        "type": {
          "description": "Type of input data: `\"json\"`, `\"csv\"`, `\"tsv\"`.\nThe default format type is determined by the extension of the file URL.\nIf no extension is detected, `\"json\"` will be used by default.",
          "enum": [
            "csv",
            "tsv"
          ],
          "type": "string"
        }
      },
      "type": "object"
    },
    "Data": {
      "anyOf": [
        {
          "$ref": "#/definitions/UrlData"
        },
        {
          "$ref": "#/definitions/InlineData"
        },
        {
          "$ref": "#/definitions/NamedData"
        }
      ]
    },
    "DataFormat": {
      "anyOf": [
        {
          "$ref": "#/definitions/CsvDataFormat"
        },
        {
          "$ref": "#/definitions/JsonDataFormat"
        },
        {
          "$ref": "#/definitions/TopoDataFormat"
        }
      ]
    },
    "DateTime": {
      "additionalProperties": false,
      "description": "Object for defining datetime in Vega-Lite Filter.\nIf both month and quarter are provided, month has higher precedence.\n`day` cannot be combined with other date.\nWe accept string for month and day names.",
      "properties": {
        "date": {
          "description": "Integer value representing the date from 1-31.",
          "maximum": 31,
          "minimum": 1,
          "type": "number"
        },
        "day": {
          "anyOf": [
            {
              "$ref": "#/definitions/Day"
            },
            {
              "type": "string"
            }
          ],
          "description": "Value representing the day of a week.  This can be one of: (1) integer value -- `1` represents Monday; (2) case-insensitive day name (e.g., `\"Monday\"`);  (3) case-insensitive, 3-character short day name (e.g., `\"Mon\"`).   <br/> **Warning:** A DateTime definition object with `day`** should not be combined with `year`, `quarter`, `month`, or `date`."
        },
        "hours": {
          "description": "Integer value representing the hour of a day from 0-23.",
          "maximum": 23,
          "minimum": 0,
          "type": "number"
        },
        "milliseconds": {
          "description": "Integer value representing the millisecond segment of time.",
          "maximum": 999,
          "minimum": 0,
          "type": "number"
        },
        "minutes": {
          "description": "Integer value representing the minute segment of time from 0-59.",
          "maximum": 59,
          "minimum": 0,
          "type": "number"
        },
        "month": {
          "anyOf": [
            {
              "$ref": "#/definitions/Month"
            },
            {
              "type": "string"
            }
          ],
          "description": "One of: (1) integer value representing the month from `1`-`12`. `1` represents January;  (2) case-insensitive month name (e.g., `\"January\"`);  (3) case-insensitive, 3-character short month name (e.g., `\"Jan\"`). "
        },
        "quarter": {
          "description": "Integer value representing the quarter of the year (from 1-4).",
          "maximum": 4,
          "minimum": 1,
          "type": "number"
        },
        "seconds": {
          "description": "Integer value representing the second segment (0-59) of a time value",
          "maximum": 59,
          "minimum": 0,
          "type": "number"
        },
        "utc": {
          "description": "A boolean flag indicating if date time is in utc time. If false, the date time is in local time",
          "type": "boolean"
        },
        "year": {
          "description": "Integer value representing the year.",
          "type": "number"
        }
      },
      "type": "object"
    },
    "Day": {
      "maximum": 7,
      "minimum": 1,
      "type": "number"
    },
    "Encoding": {
      "additionalProperties": false,
      "properties": {
        "color": {
          "anyOf": [
            {
              "$ref": "#/definitions/MarkPropFieldDefWithCondition"
            },
            {
              "$ref": "#/definitions/MarkPropValueDefWithCondition"
            }
          ],
          "description": "Color of the marks  either fill or stroke color based on mark type.\nBy default, `color` represents fill color for `\"area\"`, `\"bar\"`, `\"tick\"`,\n`\"text\"`, `\"circle\"`, and `\"square\"` / stroke color for `\"line\"` and `\"point\"`.\n\n__Default value:__ If undefined, the default color depends on [mark config](config.html#mark)'s `color` property.\n\n_Note:_ See the scale documentation for more information about customizing [color scheme](scale.html#scheme)."
        },
        "detail": {
          "anyOf": [
            {
              "$ref": "#/definitions/FieldDef"
            },
            {
              "items": {
                "$ref": "#/definitions/FieldDef"
              },
              "type": "array"
            }
          ],
          "description": "Additional levels of detail for grouping data in aggregate views and\nin line and area marks without mapping data to a specific visual channel."
        },
        "href": {
          "anyOf": [
            {
              "$ref": "#/definitions/FieldDefWithCondition"
            },
            {
              "$ref": "#/definitions/ValueDefWithCondition"
            }
          ],
          "description": "A URL to load upon mouse click."
        },
        "opacity": {
          "anyOf": [
            {
              "$ref": "#/definitions/MarkPropFieldDefWithCondition"
            },
            {
              "$ref": "#/definitions/MarkPropValueDefWithCondition"
            }
          ],
          "description": "Opacity of the marks  either can be a value or a range.\n\n__Default value:__ If undefined, the default opacity depends on [mark config](config.html#mark)'s `opacity` property."
        },
        "order": {
          "anyOf": [
            {
              "$ref": "#/definitions/OrderFieldDef"
            },
            {
              "items": {
                "$ref": "#/definitions/OrderFieldDef"
              },
              "type": "array"
            }
          ],
          "description": "Stack order for stacked marks or order of data points in line marks for connected scatter plots.\n\n__Note__: In aggregate plots, `order` field should be `aggregate`d to avoid creating additional aggregation grouping."
        },
        "shape": {
          "anyOf": [
            {
              "$ref": "#/definitions/MarkPropFieldDefWithCondition"
            },
            {
              "$ref": "#/definitions/MarkPropValueDefWithCondition"
            }
          ],
          "description": "For `point` marks the supported values are\n`\"circle\"` (default), `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`,\nor `\"triangle-down\"`, or else a custom SVG path string.\nFor `geoshape` marks it should be a field definition of the geojson data\n\n__Default value:__ If undefined, the default shape depends on [mark config](config.html#point-config)'s `shape` property."
        },
        "size": {
          "anyOf": [
            {
              "$ref": "#/definitions/MarkPropFieldDefWithCondition"
            },
            {
              "$ref": "#/definitions/MarkPropValueDefWithCondition"
            }
          ],
          "description": "Size of the mark.\n- For `\"point\"`, `\"square\"` and `\"circle\"`,  the symbol size, or pixel area of the mark.\n- For `\"bar\"` and `\"tick\"`  the bar and tick's size.\n- For `\"text\"`  the text's font size.\n- Size is currently unsupported for `\"line\"`, `\"area\"`, and `\"rect\"`."
        },
        "text": {
          "anyOf": [
            {
              "$ref": "#/definitions/TextFieldDefWithCondition"
            },
            {
              "$ref": "#/definitions/TextValueDefWithCondition"
            }
          ],
          "description": "Text of the `text` mark."
        },
        "tooltip": {
          "anyOf": [
            {
              "$ref": "#/definitions/TextFieldDefWithCondition"
            },
            {
              "$ref": "#/definitions/TextValueDefWithCondition"
            }
          ],
          "description": "The tooltip text to show upon mouse hover."
        },
        "x": {
          "anyOf": [
            {
              "$ref": "#/definitions/PositionFieldDef"
            },
            {
              "$ref": "#/definitions/ValueDef"
            }
          ],
          "description": "X coordinates of the marks, or width of horizontal `\"bar\"` and `\"area\"`."
        },
        "x2": {
          "anyOf": [
            {
              "$ref": "#/definitions/FieldDef"
            },
            {
              "$ref": "#/definitions/ValueDef"
            }
          ],
          "description": "X2 coordinates for ranged  `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`."
        },
        "y": {
          "anyOf": [
            {
              "$ref": "#/definitions/PositionFieldDef"
            },
            {
              "$ref": "#/definitions/ValueDef"
            }
          ],
          "description": "Y coordinates of the marks, or height of vertical `\"bar\"` and `\"area\"`."
        },
        "y2": {
          "anyOf": [
            {
              "$ref": "#/definitions/FieldDef"
            },
            {
              "$ref": "#/definitions/ValueDef"
            }
          ],
          "description": "Y2 coordinates for ranged  `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`."
        }
      },
      "type": "object"
    },
    "EncodingWithFacet": {
      "additionalProperties": false,
      "properties": {
        "color": {
          "anyOf": [
            {
              "$ref": "#/definitions/MarkPropFieldDefWithCondition"
            },
            {
              "$ref": "#/definitions/MarkPropValueDefWithCondition"
            }
          ],
          "description": "Color of the marks  either fill or stroke color based on mark type.\nBy default, `color` represents fill color for `\"area\"`, `\"bar\"`, `\"tick\"`,\n`\"text\"`, `\"circle\"`, and `\"square\"` / stroke color for `\"line\"` and `\"point\"`.\n\n__Default value:__ If undefined, the default color depends on [mark config](config.html#mark)'s `color` property.\n\n_Note:_ See the scale documentation for more information about customizing [color scheme](scale.html#scheme)."
        },
        "column": {
          "$ref": "#/definitions/FacetFieldDef",
          "description": "Horizontal facets for trellis plots."
        },
        "detail": {
          "anyOf": [
            {
              "$ref": "#/definitions/FieldDef"
            },
            {
              "items": {
                "$ref": "#/definitions/FieldDef"
              },
              "type": "array"
            }
          ],
          "description": "Additional levels of detail for grouping data in aggregate views and\nin line and area marks without mapping data to a specific visual channel."
        },
        "href": {
          "anyOf": [
            {
              "$ref": "#/definitions/FieldDefWithCondition"
            },
            {
              "$ref": "#/definitions/ValueDefWithCondition"
            }
          ],
          "description": "A URL to load upon mouse click."
        },
        "opacity": {
          "anyOf": [
            {
              "$ref": "#/definitions/MarkPropFieldDefWithCondition"
            },
            {
              "$ref": "#/definitions/MarkPropValueDefWithCondition"
            }
          ],
          "description": "Opacity of the marks  either can be a value or a range.\n\n__Default value:__ If undefined, the default opacity depends on [mark config](config.html#mark)'s `opacity` property."
        },
        "order": {
          "anyOf": [
            {
              "$ref": "#/definitions/OrderFieldDef"
            },
            {
              "items": {
                "$ref": "#/definitions/OrderFieldDef"
              },
              "type": "array"
            }
          ],
          "description": "Stack order for stacked marks or order of data points in line marks for connected scatter plots.\n\n__Note__: In aggregate plots, `order` field should be `aggregate`d to avoid creating additional aggregation grouping."
        },
        "row": {
          "$ref": "#/definitions/FacetFieldDef",
          "description": "Vertical facets for trellis plots."
        },
        "shape": {
          "anyOf": [
            {
              "$ref": "#/definitions/MarkPropFieldDefWithCondition"
            },
            {
              "$ref": "#/definitions/MarkPropValueDefWithCondition"
            }
          ],
          "description": "For `point` marks the supported values are\n`\"circle\"` (default), `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`,\nor `\"triangle-down\"`, or else a custom SVG path string.\nFor `geoshape` marks it should be a field definition of the geojson data\n\n__Default value:__ If undefined, the default shape depends on [mark config](config.html#point-config)'s `shape` property."
        },
        "size": {
          "anyOf": [
            {
              "$ref": "#/definitions/MarkPropFieldDefWithCondition"
            },
            {
              "$ref": "#/definitions/MarkPropValueDefWithCondition"
            }
          ],
          "description": "Size of the mark.\n- For `\"point\"`, `\"square\"` and `\"circle\"`,  the symbol size, or pixel area of the mark.\n- For `\"bar\"` and `\"tick\"`  the bar and tick's size.\n- For `\"text\"`  the text's font size.\n- Size is currently unsupported for `\"line\"`, `\"area\"`, and `\"rect\"`."
        },
        "text": {
          "anyOf": [
            {
              "$ref": "#/definitions/TextFieldDefWithCondition"
            },
            {
              "$ref": "#/definitions/TextValueDefWithCondition"
            }
          ],
          "description": "Text of the `text` mark."
        },
        "tooltip": {
          "anyOf": [
            {
              "$ref": "#/definitions/TextFieldDefWithCondition"
            },
            {
              "$ref": "#/definitions/TextValueDefWithCondition"
            }
          ],
          "description": "The tooltip text to show upon mouse hover."
        },
        "x": {
          "anyOf": [
            {
              "$ref": "#/definitions/PositionFieldDef"
            },
            {
              "$ref": "#/definitions/ValueDef"
            }
          ],
          "description": "X coordinates of the marks, or width of horizontal `\"bar\"` and `\"area\"`."
        },
        "x2": {
          "anyOf": [
            {
              "$ref": "#/definitions/FieldDef"
            },
            {
              "$ref": "#/definitions/ValueDef"
            }
          ],
          "description": "X2 coordinates for ranged  `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`."
        },
        "y": {
          "anyOf": [
            {
              "$ref": "#/definitions/PositionFieldDef"
            },
            {
              "$ref": "#/definitions/ValueDef"
            }
          ],
          "description": "Y coordinates of the marks, or height of vertical `\"bar\"` and `\"area\"`."
        },
        "y2": {
          "anyOf": [
            {
              "$ref": "#/definitions/FieldDef"
            },
            {
              "$ref": "#/definitions/ValueDef"
            }
          ],
          "description": "Y2 coordinates for ranged  `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`."
        }
      },
      "type": "object"
    },
    "FacetFieldDef": {
      "additionalProperties": false,
      "properties": {
        "aggregate": {
          "$ref": "#/definitions/Aggregate",
          "description": "Aggregation function for the field\n(e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).\n\n__Default value:__ `undefined` (None)"
        },
        "bin": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/BinParams"
            }
          ],
          "description": "A flag for binning a `quantitative` field, or [an object defining binning parameters](bin.html#params).\nIf `true`, default [binning parameters](bin.html) will be applied.\n\n__Default value:__ `false`"
        },
        "field": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/RepeatRef"
            }
          ],
          "description": "__Required.__ A string defining the name of the field from which to pull a data value\nor an object defining iterated values from the [`repeat`](repeat.html) operator.\n\n__Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`).\nIf field names contain dots or brackets but are not nested, you can use `\\\\` to escape dots and brackets (e.g., `\"a\\\\.b\"` and `\"a\\\\[0\\\\]\"`).\nSee more details about escaping in the [field documentation](field.html).\n\n__Note:__ `field` is not required if `aggregate` is `count`."
        },
        "header": {
          "$ref": "#/definitions/Header",
          "description": "An object defining properties of a facet's header."
        },
        "sort": {
          "$ref": "#/definitions/SortOrder",
          "description": "Sort order for a facet field.\nThis can be `\"ascending\"`, `\"descending\"`."
        },
        "timeUnit": {
          "$ref": "#/definitions/TimeUnit",
          "description": "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.\nor [a temporal field that gets casted as ordinal](type.html#cast).\n\n__Default value:__ `undefined` (None)"
        },
        "type": {
          "$ref": "#/definitions/Type",
          "description": "The encoded field's type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`).\nIt can also be a geo type (`\"latitude\"`, `\"longitude\"`, and `\"geojson\"`) when a [geographic projection](projection.html) is applied."
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    "FacetMapping": {
      "additionalProperties": false,
      "properties": {
        "column": {
          "$ref": "#/definitions/FacetFieldDef",
          "description": "Horizontal facets for trellis plots."
        },
        "row": {
          "$ref": "#/definitions/FacetFieldDef",
          "description": "Vertical facets for trellis plots."
        }
      },
      "type": "object"
    },
    "FieldDef": {
      "additionalProperties": false,
      "description": "Definition object for a data field, its type and transformation of an encoding channel.",
      "properties": {
        "aggregate": {
          "$ref": "#/definitions/Aggregate",
          "description": "Aggregation function for the field\n(e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).\n\n__Default value:__ `undefined` (None)"
        },
        "bin": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/BinParams"
            }
          ],
          "description": "A flag for binning a `quantitative` field, or [an object defining binning parameters](bin.html#params).\nIf `true`, default [binning parameters](bin.html) will be applied.\n\n__Default value:__ `false`"
        },
        "field": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/RepeatRef"
            }
          ],
          "description": "__Required.__ A string defining the name of the field from which to pull a data value\nor an object defining iterated values from the [`repeat`](repeat.html) operator.\n\n__Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`).\nIf field names contain dots or brackets but are not nested, you can use `\\\\` to escape dots and brackets (e.g., `\"a\\\\.b\"` and `\"a\\\\[0\\\\]\"`).\nSee more details about escaping in the [field documentation](field.html).\n\n__Note:__ `field` is not required if `aggregate` is `count`."
        },
        "timeUnit": {
          "$ref": "#/definitions/TimeUnit",
          "description": "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.\nor [a temporal field that gets casted as ordinal](type.html#cast).\n\n__Default value:__ `undefined` (None)"
        },
        "type": {
          "$ref": "#/definitions/Type",
          "description": "The encoded field's type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`).\nIt can also be a geo type (`\"latitude\"`, `\"longitude\"`, and `\"geojson\"`) when a [geographic projection](projection.html) is applied."
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    "FieldDefWithCondition": {
      "additionalProperties": false,
      "description": "A FieldDef with Condition<ValueDef>\n{\n   condition: {value: ...},\n   field: ...,\n   ...\n}",
      "properties": {
        "aggregate": {
          "$ref": "#/definitions/Aggregate",
          "description": "Aggregation function for the field\n(e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).\n\n__Default value:__ `undefined` (None)"
        },
        "bin": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/BinParams"
            }
          ],
          "description": "A flag for binning a `quantitative` field, or [an object defining binning parameters](bin.html#params).\nIf `true`, default [binning parameters](bin.html) will be applied.\n\n__Default value:__ `false`"
        },
        "condition": {
          "anyOf": [
            {
              "$ref": "#/definitions/Conditional<ValueDef>"
            },
            {
              "items": {
                "$ref": "#/definitions/Conditional<ValueDef>"
              },
              "type": "array"
            }
          ],
          "description": "One or more value definition(s) with a selection predicate.\n\n__Note:__ A field definition's `condition` property can only contain [value definitions](encoding.html#value-def)\nsince Vega-Lite only allows at mosty  one encoded field per encoding channel."
        },
        "field": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/RepeatRef"
            }
          ],
          "description": "__Required.__ A string defining the name of the field from which to pull a data value\nor an object defining iterated values from the [`repeat`](repeat.html) operator.\n\n__Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`).\nIf field names contain dots or brackets but are not nested, you can use `\\\\` to escape dots and brackets (e.g., `\"a\\\\.b\"` and `\"a\\\\[0\\\\]\"`).\nSee more details about escaping in the [field documentation](field.html).\n\n__Note:__ `field` is not required if `aggregate` is `count`."
        },
        "timeUnit": {
          "$ref": "#/definitions/TimeUnit",
          "description": "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.\nor [a temporal field that gets casted as ordinal](type.html#cast).\n\n__Default value:__ `undefined` (None)"
        },
        "type": {
          "$ref": "#/definitions/Type",
          "description": "The encoded field's type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`).\nIt can also be a geo type (`\"latitude\"`, `\"longitude\"`, and `\"geojson\"`) when a [geographic projection](projection.html) is applied."
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    "MarkPropFieldDefWithCondition": {
      "additionalProperties": false,
      "description": "A FieldDef with Condition<ValueDef>\n{\n   condition: {value: ...},\n   field: ...,\n   ...\n}",
      "properties": {
        "aggregate": {
          "$ref": "#/definitions/Aggregate",
          "description": "Aggregation function for the field\n(e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).\n\n__Default value:__ `undefined` (None)"
        },
        "bin": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/BinParams"
            }
          ],
          "description": "A flag for binning a `quantitative` field, or [an object defining binning parameters](bin.html#params).\nIf `true`, default [binning parameters](bin.html) will be applied.\n\n__Default value:__ `false`"
        },
        "condition": {
          "anyOf": [
            {
              "$ref": "#/definitions/Conditional<ValueDef>"
            },
            {
              "items": {
                "$ref": "#/definitions/Conditional<ValueDef>"
              },
              "type": "array"
            }
          ],
          "description": "One or more value definition(s) with a selection predicate.\n\n__Note:__ A field definition's `condition` property can only contain [value definitions](encoding.html#value-def)\nsince Vega-Lite only allows at mosty  one encoded field per encoding channel."
        },
        "field": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/RepeatRef"
            }
          ],
          "description": "__Required.__ A string defining the name of the field from which to pull a data value\nor an object defining iterated values from the [`repeat`](repeat.html) operator.\n\n__Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`).\nIf field names contain dots or brackets but are not nested, you can use `\\\\` to escape dots and brackets (e.g., `\"a\\\\.b\"` and `\"a\\\\[0\\\\]\"`).\nSee more details about escaping in the [field documentation](field.html).\n\n__Note:__ `field` is not required if `aggregate` is `count`."
        },
        "legend": {
          "anyOf": [
            {
              "$ref": "#/definitions/Legend"
            },
            {
              "type": "null"
            }
          ],
          "description": "An object defining properties of the legend.\nIf `null`, the legend for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [legend properties](legend.html) are applied."
        },
        "scale": {
          "$ref": "#/definitions/Scale",
          "description": "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\n__Default value:__ If undefined, default [scale properties](scale.html) are applied."
        },
        "sort": {
          "anyOf": [
            {
              "$ref": "#/definitions/SortOrder"
            },
            {
              "$ref": "#/definitions/SortField"
            },
            {
              "type": "null"
            }
          ],
          "description": "Sort order for the encoded field.\nSupported `sort` values include `\"ascending\"`, `\"descending\"` and `null` (no sorting).\nFor fields with discrete domains, `sort` can also be a [sort field definition object](sort.html#sort-field).\n\n__Default value:__ `\"ascending\"`"
        },
        "timeUnit": {
          "$ref": "#/definitions/TimeUnit",
          "description": "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.\nor [a temporal field that gets casted as ordinal](type.html#cast).\n\n__Default value:__ `undefined` (None)"
        },
        "type": {
          "$ref": "#/definitions/Type",
          "description": "The encoded field's type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`).\nIt can also be a geo type (`\"latitude\"`, `\"longitude\"`, and `\"geojson\"`) when a [geographic projection](projection.html) is applied."
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    "TextFieldDefWithCondition": {
      "additionalProperties": false,
      "description": "A FieldDef with Condition<ValueDef>\n{\n   condition: {value: ...},\n   field: ...,\n   ...\n}",
      "properties": {
        "aggregate": {
          "$ref": "#/definitions/Aggregate",
          "description": "Aggregation function for the field\n(e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).\n\n__Default value:__ `undefined` (None)"
        },
        "bin": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/BinParams"
            }
          ],
          "description": "A flag for binning a `quantitative` field, or [an object defining binning parameters](bin.html#params).\nIf `true`, default [binning parameters](bin.html) will be applied.\n\n__Default value:__ `false`"
        },
        "condition": {
          "anyOf": [
            {
              "$ref": "#/definitions/Conditional<ValueDef>"
            },
            {
              "items": {
                "$ref": "#/definitions/Conditional<ValueDef>"
              },
              "type": "array"
            }
          ],
          "description": "One or more value definition(s) with a selection predicate.\n\n__Note:__ A field definition's `condition` property can only contain [value definitions](encoding.html#value-def)\nsince Vega-Lite only allows at mosty  one encoded field per encoding channel."
        },
        "field": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/RepeatRef"
            }
          ],
          "description": "__Required.__ A string defining the name of the field from which to pull a data value\nor an object defining iterated values from the [`repeat`](repeat.html) operator.\n\n__Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`).\nIf field names contain dots or brackets but are not nested, you can use `\\\\` to escape dots and brackets (e.g., `\"a\\\\.b\"` and `\"a\\\\[0\\\\]\"`).\nSee more details about escaping in the [field documentation](field.html).\n\n__Note:__ `field` is not required if `aggregate` is `count`."
        },
        "format": {
          "description": "The [formatting pattern](format.html) for a text field. If not defined, this will be determined automatically.",
          "type": "string"
        },
        "timeUnit": {
          "$ref": "#/definitions/TimeUnit",
          "description": "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.\nor [a temporal field that gets casted as ordinal](type.html#cast).\n\n__Default value:__ `undefined` (None)"
        },
        "type": {
          "$ref": "#/definitions/Type",
          "description": "The encoded field's type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`).\nIt can also be a geo type (`\"latitude\"`, `\"longitude\"`, and `\"geojson\"`) when a [geographic projection](projection.html) is applied."
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    "FieldEqualPredicate": {
      "additionalProperties": false,
      "properties": {
        "equal": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "number"
            },
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/DateTime"
            }
          ],
          "description": "The value that the field should be equal to."
        },
        "field": {
          "description": "Field to be filtered.",
          "type": "string"
        },
        "timeUnit": {
          "$ref": "#/definitions/TimeUnit",
          "description": "Time unit for the field to be filtered."
        }
      },
      "required": [
        "field",
        "equal"
      ],
      "type": "object"
    },
    "FieldOneOfPredicate": {
      "additionalProperties": false,
      "properties": {
        "field": {
          "description": "Field to be filtered",
          "type": "string"
        },
        "oneOf": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "items": {
                "type": "number"
              },
              "type": "array"
            },
            {
              "items": {
                "type": "boolean"
              },
              "type": "array"
            },
            {
              "items": {
                "$ref": "#/definitions/DateTime"
              },
              "type": "array"
            }
          ],
          "description": "A set of values that the `field`'s value should be a member of,\nfor a data item included in the filtered data."
        },
        "timeUnit": {
          "$ref": "#/definitions/TimeUnit",
          "description": "time unit for the field to be filtered."
        }
      },
      "required": [
        "field",
        "oneOf"
      ],
      "type": "object"
    },
    "FieldRangePredicate": {
      "additionalProperties": false,
      "properties": {
        "field": {
          "description": "Field to be filtered",
          "type": "string"
        },
        "range": {
          "description": "An array of inclusive minimum and maximum values\nfor a field value of a data item to be included in the filtered data.",
          "items": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "$ref": "#/definitions/DateTime"
              }
            ]
          },
          "maxItems": 2,
          "minItems": 2,
          "type": "array"
        },
        "timeUnit": {
          "$ref": "#/definitions/TimeUnit",
          "description": "time unit for the field to be filtered."
        }
      },
      "required": [
        "field",
        "range"
      ],
      "type": "object"
    },
    "FilterTransform": {
      "additionalProperties": false,
      "properties": {
        "filter": {
          "$ref": "#/definitions/LogicalOperand<Predicate>",
          "description": "The `filter` property must be one of the predicate definitions:\n(1) an [expression](types.html#expression) string,\nwhere `datum` can be used to refer to the current data object;\n(2) one of the field predicates: [equal predicate](filter.html#equal-predicate);\n[range precidate](filter.html#range-predicate), [one-of predicate](filter.html#one-of-predicate);\n(3) a [selection predicate](filter.html#selection-predicate);\nor (4) a logical operand that combines (1), (2), or (3)."
        }
      },
      "required": [
        "filter"
      ],
      "type": "object"
    },
    "FontStyle": {
      "enum": [
        "normal",
        "italic"
      ],
      "type": "string"
    },
    "FontWeight": {
      "enum": [
        "normal",
        "bold"
      ],
      "type": "string"
    },
    "FontWeightNumber": {
      "maximum": 900,
      "minimum": 100,
      "type": "number"
    },
    "FacetSpec": {
      "additionalProperties": false,
      "properties": {
        "data": {
          "$ref": "#/definitions/Data",
          "description": "An object describing the data source"
        },
        "description": {
          "description": "Description of this mark for commenting purpose.",
          "type": "string"
        },
        "facet": {
          "$ref": "#/definitions/FacetMapping",
          "description": "An object that describes mappings between `row` and `column` channels and their field definitions."
        },
        "name": {
          "description": "Name of the visualization for later reference.",
          "type": "string"
        },
        "resolve": {
          "$ref": "#/definitions/Resolve",
          "description": "Scale, axis, and legend resolutions for facets."
        },
        "spec": {
          "anyOf": [
            {
              "$ref": "#/definitions/LayerSpec"
            },
            {
              "$ref": "#/definitions/CompositeUnitSpec"
            }
          ],
          "description": "A specification of the view that gets faceted."
        },
        "title": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/TitleParams"
            }
          ],
          "description": "Title for the plot."
        },
        "transform": {
          "description": "An array of data transformations such as filter and new field calculation.",
          "items": {
            "$ref": "#/definitions/Transform"
          },
          "type": "array"
        }
      },
      "required": [
        "facet",
        "spec"
      ],
      "type": "object"
    },
    "HConcatSpec": {
      "additionalProperties": false,
      "properties": {
        "data": {
          "$ref": "#/definitions/Data",
          "description": "An object describing the data source"
        },
        "description": {
          "description": "Description of this mark for commenting purpose.",
          "type": "string"
        },
        "hconcat": {
          "description": "A list of views that should be concatenated and put into a row.",
          "items": {
            "$ref": "#/definitions/Spec"
          },
          "type": "array"
        },
        "name": {
          "description": "Name of the visualization for later reference.",
          "type": "string"
        },
        "resolve": {
          "$ref": "#/definitions/Resolve",
          "description": "Scale, axis, and legend resolutions for horizontally concatenated charts."
        },
        "title": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/TitleParams"
            }
          ],
          "description": "Title for the plot."
        },
        "transform": {
          "description": "An array of data transformations such as filter and new field calculation.",
          "items": {
            "$ref": "#/definitions/Transform"
          },
          "type": "array"
        }
      },
      "required": [
        "hconcat"
      ],
      "type": "object"
    },
    "LayerSpec": {
      "additionalProperties": false,
      "properties": {
        "data": {
          "$ref": "#/definitions/Data",
          "description": "An object describing the data source"
        },
        "description": {
          "description": "Description of this mark for commenting purpose.",
          "type": "string"
        },
        "height": {
          "description": "The height of a visualization.\n\n__Default value:__\n- If a view's [`autosize`](size.html#autosize) type is `\"fit\"` or its y-channel has a [continuous scale](scale.html#continuous), the height will be the value of [`config.view.height`](spec.html#config).\n- For y-axis with a band or point scale: if [`rangeStep`](scale.html#band) is a numeric value or unspecified, the height is [determined by the range step, paddings, and the cardinality of the field mapped to y-channel](scale.html#band). Otherwise, if the `rangeStep` is `null`, the height will be the value of [`config.view.height`](spec.html#config).\n- If no field is mapped to `y` channel, the `height` will be the value of `rangeStep`.\n\n__Note__: For plots with [`row` and `column` channels](encoding.html#facet), this represents the height of a single view.\n\n__See also:__ The documentation for [width and height](size.html) contains more examples.",
          "type": "number"
        },
        "layer": {
          "description": "Layer or single view specifications to be layered.\n\n__Note__: Specifications inside `layer` cannot use `row` and `column` channels as layering facet specifications is not allowed.",
          "items": {
            "anyOf": [
              {
                "$ref": "#/definitions/LayerSpec"
              },
              {
                "$ref": "#/definitions/CompositeUnitSpec"
              }
            ]
          },
          "type": "array"
        },
        "name": {
          "description": "Name of the visualization for later reference.",
          "type": "string"
        },
        "resolve": {
          "$ref": "#/definitions/Resolve",
          "description": "Scale, axis, and legend resolutions for layers."
        },
        "title": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/TitleParams"
            }
          ],
          "description": "Title for the plot."
        },
        "transform": {
          "description": "An array of data transformations such as filter and new field calculation.",
          "items": {
            "$ref": "#/definitions/Transform"
          },
          "type": "array"
        },
        "width": {
          "description": "The width of a visualization.\n\n__Default value:__ This will be determined by the following rules:\n\n- If a view's [`autosize`](size.html#autosize) type is `\"fit\"` or its x-channel has a [continuous scale](scale.html#continuous), the width will be the value of [`config.view.width`](spec.html#config).\n- For x-axis with a band or point scale: if [`rangeStep`](scale.html#band) is a numeric value or unspecified, the width is [determined by the range step, paddings, and the cardinality of the field mapped to x-channel](scale.html#band).   Otherwise, if the `rangeStep` is `null`, the width will be the value of [`config.view.width`](spec.html#config).\n- If no field is mapped to `x` channel, the `width` will be the value of [`config.scale.textXRangeStep`](size.html#default-width-and-height) for `text` mark and the value of `rangeStep` for other marks.\n\n__Note:__ For plots with [`row` and `column` channels](encoding.html#facet), this represents the width of a single view.\n\n__See also:__ The documentation for [width and height](size.html) contains more examples.",
          "type": "number"
        }
      },
      "required": [
        "layer"
      ],
      "type": "object"
    },
    "RepeatSpec": {
      "additionalProperties": false,
      "properties": {
        "data": {
          "$ref": "#/definitions/Data",
          "description": "An object describing the data source"
        },
        "description": {
          "description": "Description of this mark for commenting purpose.",
          "type": "string"
        },
        "name": {
          "description": "Name of the visualization for later reference.",
          "type": "string"
        },
        "repeat": {
          "$ref": "#/definitions/Repeat",
          "description": "An object that describes what fields should be repeated into views that are laid out as a `row` or `column`."
        },
        "resolve": {
          "$ref": "#/definitions/Resolve",
          "description": "Scale and legend resolutions for repeated charts."
        },
        "spec": {
          "$ref": "#/definitions/Spec"
        },
        "title": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/TitleParams"
            }
          ],
          "description": "Title for the plot."
        },
        "transform": {
          "description": "An array of data transformations such as filter and new field calculation.",
          "items": {
            "$ref": "#/definitions/Transform"
          },
          "type": "array"
        }
      },
      "required": [
        "repeat",
        "spec"
      ],
      "type": "object"
    },
    "Spec": {
      "anyOf": [
        {
          "$ref": "#/definitions/CompositeUnitSpec"
        },
        {
          "$ref": "#/definitions/LayerSpec"
        },
        {
          "$ref": "#/definitions/FacetSpec"
        },
        {
          "$ref": "#/definitions/RepeatSpec"
        },
        {
          "$ref": "#/definitions/VConcatSpec"
        },
        {
          "$ref": "#/definitions/HConcatSpec"
        }
      ]
    },
    "CompositeUnitSpecAlias": {
      "additionalProperties": false,
      "properties": {
        "data": {
          "$ref": "#/definitions/Data",
          "description": "An object describing the data source"
        },
        "description": {
          "description": "Description of this mark for commenting purpose.",
          "type": "string"
        },
        "encoding": {
          "$ref": "#/definitions/Encoding",
          "description": "A key-value mapping between encoding channels and definition of fields."
        },
        "height": {
          "description": "The height of a visualization.\n\n__Default value:__\n- If a view's [`autosize`](size.html#autosize) type is `\"fit\"` or its y-channel has a [continuous scale](scale.html#continuous), the height will be the value of [`config.view.height`](spec.html#config).\n- For y-axis with a band or point scale: if [`rangeStep`](scale.html#band) is a numeric value or unspecified, the height is [determined by the range step, paddings, and the cardinality of the field mapped to y-channel](scale.html#band). Otherwise, if the `rangeStep` is `null`, the height will be the value of [`config.view.height`](spec.html#config).\n- If no field is mapped to `y` channel, the `height` will be the value of `rangeStep`.\n\n__Note__: For plots with [`row` and `column` channels](encoding.html#facet), this represents the height of a single view.\n\n__See also:__ The documentation for [width and height](size.html) contains more examples.",
          "type": "number"
        },
        "mark": {
          "$ref": "#/definitions/AnyMark",
          "description": "A string describing the mark type (one of `\"bar\"`, `\"circle\"`, `\"square\"`, `\"tick\"`, `\"line\"`,\n* `\"area\"`, `\"point\"`, `\"rule\"`, `\"geoshape\"`, and `\"text\"`) or a [mark definition object](mark.html#mark-def)."
        },
        "name": {
          "description": "Name of the visualization for later reference.",
          "type": "string"
        },
        "projection": {
          "$ref": "#/definitions/Projection",
          "description": "An object defining properties of geographic projection.\n\nWorks with `\"geoshape\"` marks and `\"point\"` or `\"line\"` marks that have a channel (one or more of `\"X\"`, `\"X2\"`, `\"Y\"`, `\"Y2\"`) with type `\"latitude\"`, or `\"longitude\"`."
        },
        "selection": {
          "additionalProperties": {
            "$ref": "#/definitions/SelectionDef"
          },
          "description": "A key-value mapping between selection names and definitions.",
          "type": "object"
        },
        "title": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/TitleParams"
            }
          ],
          "description": "Title for the plot."
        },
        "transform": {
          "description": "An array of data transformations such as filter and new field calculation.",
          "items": {
            "$ref": "#/definitions/Transform"
          },
          "type": "array"
        },
        "width": {
          "description": "The width of a visualization.\n\n__Default value:__ This will be determined by the following rules:\n\n- If a view's [`autosize`](size.html#autosize) type is `\"fit\"` or its x-channel has a [continuous scale](scale.html#continuous), the width will be the value of [`config.view.width`](spec.html#config).\n- For x-axis with a band or point scale: if [`rangeStep`](scale.html#band) is a numeric value or unspecified, the width is [determined by the range step, paddings, and the cardinality of the field mapped to x-channel](scale.html#band).   Otherwise, if the `rangeStep` is `null`, the width will be the value of [`config.view.width`](spec.html#config).\n- If no field is mapped to `x` channel, the `width` will be the value of [`config.scale.textXRangeStep`](size.html#default-width-and-height) for `text` mark and the value of `rangeStep` for other marks.\n\n__Note:__ For plots with [`row` and `column` channels](encoding.html#facet), this represents the width of a single view.\n\n__See also:__ The documentation for [width and height](size.html) contains more examples.",
          "type": "number"
        }
      },
      "required": [
        "mark",
        "encoding"
      ],
      "type": "object"
    },
    "FacetedCompositeUnitSpecAlias": {
      "additionalProperties": false,
      "properties": {
        "data": {
          "$ref": "#/definitions/Data",
          "description": "An object describing the data source"
        },
        "description": {
          "description": "Description of this mark for commenting purpose.",
          "type": "string"
        },
        "encoding": {
          "$ref": "#/definitions/EncodingWithFacet",
          "description": "A key-value mapping between encoding channels and definition of fields."
        },
        "height": {
          "description": "The height of a visualization.\n\n__Default value:__\n- If a view's [`autosize`](size.html#autosize) type is `\"fit\"` or its y-channel has a [continuous scale](scale.html#continuous), the height will be the value of [`config.view.height`](spec.html#config).\n- For y-axis with a band or point scale: if [`rangeStep`](scale.html#band) is a numeric value or unspecified, the height is [determined by the range step, paddings, and the cardinality of the field mapped to y-channel](scale.html#band). Otherwise, if the `rangeStep` is `null`, the height will be the value of [`config.view.height`](spec.html#config).\n- If no field is mapped to `y` channel, the `height` will be the value of `rangeStep`.\n\n__Note__: For plots with [`row` and `column` channels](encoding.html#facet), this represents the height of a single view.\n\n__See also:__ The documentation for [width and height](size.html) contains more examples.",
          "type": "number"
        },
        "mark": {
          "$ref": "#/definitions/AnyMark",
          "description": "A string describing the mark type (one of `\"bar\"`, `\"circle\"`, `\"square\"`, `\"tick\"`, `\"line\"`,\n* `\"area\"`, `\"point\"`, `\"rule\"`, `\"geoshape\"`, and `\"text\"`) or a [mark definition object](mark.html#mark-def)."
        },
        "name": {
          "description": "Name of the visualization for later reference.",
          "type": "string"
        },
        "projection": {
          "$ref": "#/definitions/Projection",
          "description": "An object defining properties of geographic projection.\n\nWorks with `\"geoshape\"` marks and `\"point\"` or `\"line\"` marks that have a channel (one or more of `\"X\"`, `\"X2\"`, `\"Y\"`, `\"Y2\"`) with type `\"latitude\"`, or `\"longitude\"`."
        },
        "selection": {
          "additionalProperties": {
            "$ref": "#/definitions/SelectionDef"
          },
          "description": "A key-value mapping between selection names and definitions.",
          "type": "object"
        },
        "title": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/TitleParams"
            }
          ],
          "description": "Title for the plot."
        },
        "transform": {
          "description": "An array of data transformations such as filter and new field calculation.",
          "items": {
            "$ref": "#/definitions/Transform"
          },
          "type": "array"
        },
        "width": {
          "description": "The width of a visualization.\n\n__Default value:__ This will be determined by the following rules:\n\n- If a view's [`autosize`](size.html#autosize) type is `\"fit\"` or its x-channel has a [continuous scale](scale.html#continuous), the width will be the value of [`config.view.width`](spec.html#config).\n- For x-axis with a band or point scale: if [`rangeStep`](scale.html#band) is a numeric value or unspecified, the width is [determined by the range step, paddings, and the cardinality of the field mapped to x-channel](scale.html#band).   Otherwise, if the `rangeStep` is `null`, the width will be the value of [`config.view.width`](spec.html#config).\n- If no field is mapped to `x` channel, the `width` will be the value of [`config.scale.textXRangeStep`](size.html#default-width-and-height) for `text` mark and the value of `rangeStep` for other marks.\n\n__Note:__ For plots with [`row` and `column` channels](encoding.html#facet), this represents the width of a single view.\n\n__See also:__ The documentation for [width and height](size.html) contains more examples.",
          "type": "number"
        }
      },
      "required": [
        "mark",
        "encoding"
      ],
      "type": "object"
    },
    "VConcatSpec": {
      "additionalProperties": false,
      "properties": {
        "data": {
          "$ref": "#/definitions/Data",
          "description": "An object describing the data source"
        },
        "description": {
          "description": "Description of this mark for commenting purpose.",
          "type": "string"
        },
        "name": {
          "description": "Name of the visualization for later reference.",
          "type": "string"
        },
        "resolve": {
          "$ref": "#/definitions/Resolve",
          "description": "Scale, axis, and legend resolutions for vertically concatenated charts."
        },
        "title": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/TitleParams"
            }
          ],
          "description": "Title for the plot."
        },
        "transform": {
          "description": "An array of data transformations such as filter and new field calculation.",
          "items": {
            "$ref": "#/definitions/Transform"
          },
          "type": "array"
        },
        "vconcat": {
          "description": "A list of views that should be concatenated and put into a column.",
          "items": {
            "$ref": "#/definitions/Spec"
          },
          "type": "array"
        }
      },
      "required": [
        "vconcat"
      ],
      "type": "object"
    },
    "GeoType": {
      "enum": [
        "latitude",
        "longitude",
        "geojson"
      ],
      "type": "string"
    },
    "Header": {
      "additionalProperties": false,
      "description": "Headers of row / column channels for faceted plots.",
      "properties": {
        "format": {
          "description": "The formatting pattern for labels. This is D3's [number format pattern](https://github.com/d3/d3-format#locale_format) for quantitative fields and D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format) for time field.\n\nSee the [format documentation](format.html) for more information.\n\n__Default value:__  derived from [numberFormat](config.html#format) config for quantitative fields and from [timeFormat](config.html#format) config for temporal fields.",
          "type": "string"
        },
        "labelAngle": {
          "description": "The rotation angle of the header labels.\n\n__Default value:__ `0`.",
          "maximum": 360,
          "minimum": -360,
          "type": "number"
        },
        "title": {
          "description": "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`).  If the field has an aggregate function, the function is displayed as a part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function will be denoted in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`).  Otherwise, the title is simply the field name.\n\n__Note__: You can customize the default field title format by providing the [`fieldTitle` property in the [config](config.html) or [`fieldTitle` function via the `compile` function's options](compile.html#field-title).",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "type": "object"
    },
    "HorizontalAlign": {
      "enum": [
        "left",
        "right",
        "center"
      ],
      "type": "string"
    },
    "InlineData": {
      "additionalProperties": false,
      "properties": {
        "format": {
          "$ref": "#/definitions/DataFormat",
          "description": "An object that specifies the format for parsing the data values."
        },
        "values": {
          "anyOf": [
            {
              "items": {
                "type": "number"
              },
              "type": "array"
            },
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "items": {
                "type": "boolean"
              },
              "type": "array"
            },
            {
              "items": {
                "type": "object"
              },
              "type": "array"
            },
            {
              "type": "string"
            },
            {
              "type": "object"
            }
          ],
          "description": "The full data set, included inline. This can be an array of objects or primitive values or a string.\nArrays of primitive values are ingested as objects with a `data` property. Strings are parsed according to the specified format type."
        }
      },
      "required": [
        "values"
      ],
      "type": "object"
    },
    "Interpolate": {
      "enum": [
        "linear",
        "linear-closed",
        "step",
        "step-before",
        "step-after",
        "basis",
        "basis-open",
        "basis-closed",
        "cardinal",
        "cardinal-open",
        "cardinal-closed",
        "bundle",
        "monotone"
      ],
      "type": "string"
    },
    "InterpolateParams": {
      "additionalProperties": false,
      "properties": {
        "gamma": {
          "type": "number"
        },
        "type": {
          "enum": [
            "rgb",
            "cubehelix",
            "cubehelix-long"
          ],
          "type": "string"
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    "IntervalSelection": {
      "additionalProperties": false,
      "properties": {
        "bind": {
          "description": "Establishes a two-way binding between the interval selection and the scales\nused within the same view. This allows a user to interactively pan and\nzoom the view.",
          "enum": [
            "scales"
          ],
          "type": "string"
        },
        "empty": {
          "description": "By default, all data values are considered to lie within an empty selection.\nWhen set to `none`, empty selections contain no data values.",
          "enum": [
            "all",
            "none"
          ],
          "type": "string"
        },
        "encodings": {
          "description": "An array of encoding channels. The corresponding data field values\nmust match for a data tuple to fall within the selection.",
          "items": {
            "$ref": "#/definitions/SingleDefChannel"
          },
          "type": "array"
        },
        "fields": {
          "description": "An array of field names whose values must match for a data tuple to\nfall within the selection.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "mark": {
          "$ref": "#/definitions/BrushConfig",
          "description": "An interval selection also adds a rectangle mark to depict the\nextents of the interval. The `mark` property can be used to customize the\nappearance of the mark."
        },
        "on": {
          "$ref": "#/definitions/VgEventStream",
          "description": "A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection.\nFor interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters)."
        },
        "resolve": {
          "$ref": "#/definitions/SelectionResolution",
          "description": "With layered and multi-view displays, a strategy that determines how\nselections' data queries are resolved when applied in a filter transform,\nconditional encoding rule, or scale domain."
        },
        "translate": {
          "description": "When truthy, allows a user to interactively move an interval selection\nback-and-forth. Can be `true`, `false` (to disable panning), or a\n[Vega event stream definition](https://vega.github.io/vega/docs/event-streams/)\nwhich must include a start and end event to trigger continuous panning.\n\n__Default value:__ `true`, which corresponds to\n`[mousedown, window:mouseup] > window:mousemove!` which corresponds to\nclicks and dragging within an interval selection to reposition it.",
          "type": [
            "string",
            "boolean"
          ]
        },
        "type": {
          "enum": [
            "interval"
          ],
          "type": "string"
        },
        "zoom": {
          "description": "When truthy, allows a user to interactively resize an interval selection.\nCan be `true`, `false` (to disable zooming), or a [Vega event stream\ndefinition](https://vega.github.io/vega/docs/event-streams/). Currently,\nonly `wheel` events are supported.\n\n\n__Default value:__ `true`, which corresponds to `wheel!`.",
          "type": [
            "string",
            "boolean"
          ]
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    "IntervalSelectionConfig": {
      "additionalProperties": false,
      "properties": {
        "bind": {
          "description": "Establishes a two-way binding between the interval selection and the scales\nused within the same view. This allows a user to interactively pan and\nzoom the view.",
          "enum": [
            "scales"
          ],
          "type": "string"
        },
        "empty": {
          "description": "By default, all data values are considered to lie within an empty selection.\nWhen set to `none`, empty selections contain no data values.",
          "enum": [
            "all",
            "none"
          ],
          "type": "string"
        },
        "encodings": {
          "description": "An array of encoding channels. The corresponding data field values\nmust match for a data tuple to fall within the selection.",
          "items": {
            "$ref": "#/definitions/SingleDefChannel"
          },
          "type": "array"
        },
        "fields": {
          "description": "An array of field names whose values must match for a data tuple to\nfall within the selection.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "mark": {
          "$ref": "#/definitions/BrushConfig",
          "description": "An interval selection also adds a rectangle mark to depict the\nextents of the interval. The `mark` property can be used to customize the\nappearance of the mark."
        },
        "on": {
          "$ref": "#/definitions/VgEventStream",
          "description": "A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection.\nFor interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters)."
        },
        "resolve": {
          "$ref": "#/definitions/SelectionResolution",
          "description": "With layered and multi-view displays, a strategy that determines how\nselections' data queries are resolved when applied in a filter transform,\nconditional encoding rule, or scale domain."
        },
        "translate": {
          "description": "When truthy, allows a user to interactively move an interval selection\nback-and-forth. Can be `true`, `false` (to disable panning), or a\n[Vega event stream definition](https://vega.github.io/vega/docs/event-streams/)\nwhich must include a start and end event to trigger continuous panning.\n\n__Default value:__ `true`, which corresponds to\n`[mousedown, window:mouseup] > window:mousemove!` which corresponds to\nclicks and dragging within an interval selection to reposition it.",
          "type": [
            "string",
            "boolean"
          ]
        },
        "zoom": {
          "description": "When truthy, allows a user to interactively resize an interval selection.\nCan be `true`, `false` (to disable zooming), or a [Vega event stream\ndefinition](https://vega.github.io/vega/docs/event-streams/). Currently,\nonly `wheel` events are supported.\n\n\n__Default value:__ `true`, which corresponds to `wheel!`.",
          "type": [
            "string",
            "boolean"
          ]
        }
      },
      "type": "object"
    },
    "JsonDataFormat": {
      "additionalProperties": false,
      "properties": {
        "parse": {
          "anyOf": [
            {
              "enum": [
                "auto"
              ],
              "type": "string"
            },
            {
              "type": "object"
            }
          ],
          "description": "If set to auto (the default), perform automatic type inference to determine the desired data types.\nAlternatively, a parsing directive object can be provided for explicit data types. Each property of the object corresponds to a field name, and the value to the desired data type (one of `\"number\"`, `\"boolean\"` or `\"date\"`).\nFor example, `\"parse\": {\"modified_on\": \"date\"}` parses the `modified_on` field in each input record a Date value.\n\nFor `\"date\"`, we parse data based using Javascript's [`Date.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse).\nFor Specific date formats can be provided (e.g., `{foo: 'date:\"%m%d%Y\"'}`), using the [d3-time-format syntax](https://github.com/d3/d3-time-format#locale_format). UTC date format parsing is supported similarly (e.g., `{foo: 'utc:\"%m%d%Y\"'}`). See more about [UTC time](timeunit.html#utc)"
        },
        "property": {
          "description": "The JSON property containing the desired data.\nThis parameter can be used when the loaded JSON file may have surrounding structure or meta-data.\nFor example `\"property\": \"values.features\"` is equivalent to retrieving `json.values.features`\nfrom the loaded JSON object.",
          "type": "string"
        },
        "type": {
          "description": "Type of input data: `\"json\"`, `\"csv\"`, `\"tsv\"`.\nThe default format type is determined by the extension of the file URL.\nIf no extension is detected, `\"json\"` will be used by default.",
          "enum": [
            "json"
          ],
          "type": "string"
        }
      },
      "type": "object"
    },
    "Legend": {
      "additionalProperties": false,
      "description": "Properties of a legend or boolean flag for determining whether to show it.",
      "properties": {
        "entryPadding": {
          "description": "Padding (in pixels) between legend entries in a symbol legend.",
          "type": "number"
        },
        "format": {
          "description": "The formatting pattern for labels. This is D3's [number format pattern](https://github.com/d3/d3-format#locale_format) for quantitative fields and D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format) for time field.\n\nSee the [format documentation](format.html) for more information.\n\n__Default value:__  derived from [numberFormat](config.html#format) config for quantitative fields and from [timeFormat](config.html#format) config for temporal fields.",
          "type": "string"
        },
        "offset": {
          "description": "The offset, in pixels, by which to displace the legend from the edge of the enclosing group or data rectangle.\n\n__Default value:__  `0`",
          "type": "number"
        },
        "orient": {
          "$ref": "#/definitions/LegendOrient",
          "description": "The orientation of the legend, which determines how the legend is positioned within the scene. One of \"left\", \"right\", \"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\", \"none\".\n\n__Default value:__ `\"right\"`"
        },
        "padding": {
          "description": "The padding, in pixels, between the legend and axis.",
          "type": "number"
        },
        "tickCount": {
          "description": "The desired number of tick values for quantitative legends.",
          "type": "number"
        },
        "title": {
          "description": "A title for the field. If `null`, the title will be removed.\n\n__Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`).  If the field has an aggregate function, the function is displayed as a part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function will be denoted in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`).  Otherwise, the title is simply the field name.\n\n__Note__: You can customize the default field title format by providing the [`fieldTitle` property in the [config](config.html) or [`fieldTitle` function via the `compile` function's options](compile.html#field-title).",
          "type": [
            "string",
            "null"
          ]
        },
        "type": {
          "description": "The type of the legend. Use `\"symbol\"` to create a discrete legend and `\"gradient\"` for a continuous color gradient.\n\n__Default value:__ `\"gradient\"` for non-binned quantitative fields and temporal fields; `\"symbol\"` otherwise.",
          "enum": [
            "symbol",
            "gradient"
          ],
          "type": "string"
        },
        "values": {
          "anyOf": [
            {
              "items": {
                "type": "number"
              },
              "type": "array"
            },
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "items": {
                "$ref": "#/definitions/DateTime"
              },
              "type": "array"
            }
          ],
          "description": "Explicitly set the visible legend values."
        },
        "zindex": {
          "description": "A non-positive integer indicating z-index of the legend.\nIf zindex is 0, legend should be drawn behind all chart elements.\nTo put them in front, use zindex = 1.",
          "minimum": 0,
          "type": "number"
        }
      },
      "type": "object"
    },
    "LegendConfig": {
      "additionalProperties": false,
      "properties": {
        "cornerRadius": {
          "description": "Corner radius for the full legend.",
          "type": "number"
        },
        "entryPadding": {
          "description": "Padding (in pixels) between legend entries in a symbol legend.",
          "type": "number"
        },
        "fillColor": {
          "description": "Background fill color for the full legend.",
          "type": "string"
        },
        "gradientHeight": {
          "description": "The height of the gradient, in pixels.",
          "minimum": 0,
          "type": "number"
        },
        "gradientLabelBaseline": {
          "description": "Text baseline for color ramp gradient labels.",
          "type": "string"
        },
        "gradientLabelLimit": {
          "description": "The maximum allowed length in pixels of color ramp gradient labels.",
          "type": "number"
        },
        "gradientLabelOffset": {
          "description": "Vertical offset in pixels for color ramp gradient labels.",
          "type": "number"
        },
        "gradientStrokeColor": {
          "description": "The color of the gradient stroke, can be in hex color code or regular color name.",
          "type": "string"
        },
        "gradientStrokeWidth": {
          "description": "The width of the gradient stroke, in pixels.",
          "minimum": 0,
          "type": "number"
        },
        "gradientWidth": {
          "description": "The width of the gradient, in pixels.",
          "minimum": 0,
          "type": "number"
        },
        "labelAlign": {
          "description": "The alignment of the legend label, can be left, middle or right.",
          "type": "string"
        },
        "labelBaseline": {
          "description": "The position of the baseline of legend label, can be top, middle or bottom.",
          "type": "string"
        },
        "labelColor": {
          "description": "The color of the legend label, can be in hex color code or regular color name.",
          "type": "string"
        },
        "labelFont": {
          "description": "The font of the legend label.",
          "type": "string"
        },
        "labelFontSize": {
          "description": "The font size of legend label.\n\n__Default value:__ `10`.",
          "minimum": 0,
          "type": "number"
        },
        "labelLimit": {
          "description": "Maximum allowed pixel width of axis tick labels.",
          "type": "number"
        },
        "labelOffset": {
          "description": "The offset of the legend label.",
          "minimum": 0,
          "type": "number"
        },
        "offset": {
          "description": "The offset, in pixels, by which to displace the legend from the edge of the enclosing group or data rectangle.\n\n__Default value:__  `0`",
          "type": "number"
        },
        "orient": {
          "$ref": "#/definitions/LegendOrient",
          "description": "The orientation of the legend, which determines how the legend is positioned within the scene. One of \"left\", \"right\", \"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\", \"none\".\n\n__Default value:__ `\"right\"`"
        },
        "padding": {
          "description": "The padding, in pixels, between the legend and axis.",
          "type": "number"
        },
        "shortTimeLabels": {
          "description": "Whether month names and weekday names should be abbreviated.\n\n__Default value:__  `false`",
          "type": "boolean"
        },
        "strokeColor": {
          "description": "Border stroke color for the full legend.",
          "type": "string"
        },
        "strokeDash": {
          "description": "Border stroke dash pattern for the full legend.",
          "items": {
            "type": "number"
          },
          "type": "array"
        },
        "strokeWidth": {
          "description": "Border stroke width for the full legend.",
          "type": "number"
        },
        "symbolColor": {
          "description": "The color of the legend symbol,",
          "type": "string"
        },
        "symbolSize": {
          "description": "The size of the legend symbol, in pixels.",
          "minimum": 0,
          "type": "number"
        },
        "symbolStrokeWidth": {
          "description": "The width of the symbol's stroke.",
          "minimum": 0,
          "type": "number"
        },
        "symbolType": {
          "description": "Default shape type (such as \"circle\") for legend symbols.",
          "type": "string"
        },
        "titleAlign": {
          "description": "Horizontal text alignment for legend titles.",
          "type": "string"
        },
        "titleBaseline": {
          "description": "Vertical text baseline for legend titles.",
          "type": "string"
        },
        "titleColor": {
          "description": "The color of the legend title, can be in hex color code or regular color name.",
          "type": "string"
        },
        "titleFont": {
          "description": "The font of the legend title.",
          "type": "string"
        },
        "titleFontSize": {
          "description": "The font size of the legend title.",
          "type": "number"
        },
        "titleFontWeight": {
          "description": "The font weight of the legend title.",
          "type": [
            "string",
            "number"
          ]
        },
        "titleLimit": {
          "description": "Maximum allowed pixel width of axis titles.",
          "type": "number"
        },
        "titlePadding": {
          "description": "The padding, in pixels, between title and legend.",
          "type": "number"
        }
      },
      "type": "object"
    },
    "LegendOrient": {
      "enum": [
        "left",
        "right",
        "top-left",
        "top-right",
        "bottom-left",
        "bottom-right",
        "none"
      ],
      "type": "string"
    },
    "LegendResolveMap": {
      "additionalProperties": false,
      "properties": {
        "color": {
          "$ref": "#/definitions/ResolveMode"
        },
        "opacity": {
          "$ref": "#/definitions/ResolveMode"
        },
        "shape": {
          "$ref": "#/definitions/ResolveMode"
        },
        "size": {
          "$ref": "#/definitions/ResolveMode"
        }
      },
      "type": "object"
    },
    "LocalMultiTimeUnit": {
      "enum": [
        "yearquarter",
        "yearquartermonth",
        "yearmonth",
        "yearmonthdate",
        "yearmonthdatehours",
        "yearmonthdatehoursminutes",
        "yearmonthdatehoursminutesseconds",
        "quartermonth",
        "monthdate",
        "hoursminutes",
        "hoursminutesseconds",
        "minutesseconds",
        "secondsmilliseconds"
      ],
      "type": "string"
    },
    "LocalSingleTimeUnit": {
      "enum": [
        "year",
        "quarter",
        "month",
        "day",
        "date",
        "hours",
        "minutes",
        "seconds",
        "milliseconds"
      ],
      "type": "string"
    },
    "LogicalAnd<Predicate>": {
      "additionalProperties": false,
      "properties": {
        "and": {
          "items": {
            "$ref": "#/definitions/LogicalOperand<Predicate>"
          },
          "type": "array"
        }
      },
      "required": [
        "and"
      ],
      "type": "object"
    },
    "SelectionAnd": {
      "additionalProperties": false,
      "properties": {
        "and": {
          "items": {
            "$ref": "#/definitions/SelectionOperand"
          },
          "type": "array"
        }
      },
      "required": [
        "and"
      ],
      "type": "object"
    },
    "LogicalNot<Predicate>": {
      "additionalProperties": false,
      "properties": {
        "not": {
          "$ref": "#/definitions/LogicalOperand<Predicate>"
        }
      },
      "required": [
        "not"
      ],
      "type": "object"
    },
    "SelectionNot": {
      "additionalProperties": false,
      "properties": {
        "not": {
          "$ref": "#/definitions/SelectionOperand"
        }
      },
      "required": [
        "not"
      ],
      "type": "object"
    },
    "LogicalOperand<Predicate>": {
      "anyOf": [
        {
          "$ref": "#/definitions/LogicalNot<Predicate>"
        },
        {
          "$ref": "#/definitions/LogicalAnd<Predicate>"
        },
        {
          "$ref": "#/definitions/LogicalOr<Predicate>"
        },
        {
          "$ref": "#/definitions/Predicate"
        }
      ]
    },
    "SelectionOperand": {
      "anyOf": [
        {
          "$ref": "#/definitions/SelectionNot"
        },
        {
          "$ref": "#/definitions/SelectionAnd"
        },
        {
          "$ref": "#/definitions/SelectionOr"
        },
        {
          "type": "string"
        }
      ]
    },
    "LogicalOr<Predicate>": {
      "additionalProperties": false,
      "properties": {
        "or": {
          "items": {
            "$ref": "#/definitions/LogicalOperand<Predicate>"
          },
          "type": "array"
        }
      },
      "required": [
        "or"
      ],
      "type": "object"
    },
    "SelectionOr": {
      "additionalProperties": false,
      "properties": {
        "or": {
          "items": {
            "$ref": "#/definitions/SelectionOperand"
          },
          "type": "array"
        }
      },
      "required": [
        "or"
      ],
      "type": "object"
    },
    "LookupData": {
      "additionalProperties": false,
      "properties": {
        "data": {
          "$ref": "#/definitions/Data",
          "description": "Secondary data source to lookup in."
        },
        "fields": {
          "description": "Fields in foreign data to lookup.\nIf not specificied, the entire object is queried.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "key": {
          "description": "Key in data to lookup.",
          "type": "string"
        }
      },
      "required": [
        "data",
        "key"
      ],
      "type": "object"
    },
    "LookupTransform": {
      "additionalProperties": false,
      "properties": {
        "as": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            }
          ],
          "description": "The field or fields for storing the computed formula value.\nIf `from.fields` is specified, the transform will use the same names for `as`.\nIf `from.fields` is not specified, `as` has to be a string and we put the whole object into the data under the specified name."
        },
        "default": {
          "description": "The default value to use if lookup fails.\n\n__Default value:__ `null`",
          "type": "string"
        },
        "from": {
          "$ref": "#/definitions/LookupData",
          "description": "Secondary data reference."
        },
        "lookup": {
          "description": "Key in primary data source.",
          "type": "string"
        }
      },
      "required": [
        "lookup",
        "from"
      ],
      "type": "object"
    },
    "Mark": {
      "description": "All types of primitive marks.",
      "enum": [
        "area",
        "bar",
        "line",
        "point",
        "text",
        "tick",
        "rect",
        "rule",
        "circle",
        "square",
        "geoshape"
      ],
      "type": "string"
    },
    "MarkConfig": {
      "additionalProperties": false,
      "properties": {
        "align": {
          "$ref": "#/definitions/HorizontalAlign",
          "description": "The horizontal alignment of the text. One of `\"left\"`, `\"right\"`, `\"center\"`."
        },
        "angle": {
          "description": "The rotation angle of the text, in degrees.",
          "maximum": 360,
          "minimum": 0,
          "type": "number"
        },
        "baseline": {
          "$ref": "#/definitions/VerticalAlign",
          "description": "The vertical alignment of the text. One of `\"top\"`, `\"middle\"`, `\"bottom\"`.\n\n__Default value:__ `\"middle\"`"
        },
        "color": {
          "description": "Default color.  Note that `fill` and `stroke` have higher precedence than `color` and will override `color`.\n\n__Default value:__ <span style=\"color: #4682b4;\">&#9632;</span> `\"#4682b4\"`\n\n__Note:__ This property cannot be used in a [style config](mark.html#style-config).",
          "type": "string"
        },
        "cursor": {
          "description": "The mouse cursor used over the mark. Any valid [CSS cursor type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.",
          "enum": [
            "auto",
            "default",
            "none",
            "context-menu",
            "help",
            "pointer",
            "progress",
            "wait",
            "cell",
            "crosshair",
            "text",
            "vertical-text",
            "alias",
            "copy",
            "move",
            "no-drop",
            "not-allowed",
            "e-resize",
            "n-resize",
            "ne-resize",
            "nw-resize",
            "s-resize",
            "se-resize",
            "sw-resize",
            "w-resize",
            "ew-resize",
            "ns-resize",
            "nesw-resize",
            "nwse-resize",
            "col-resize",
            "row-resize",
            "all-scroll",
            "zoom-in",
            "zoom-out",
            "grab",
            "grabbing"
          ],
          "type": "string"
        },
        "dx": {
          "description": "The horizontal offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.",
          "type": "number"
        },
        "dy": {
          "description": "The vertical offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.",
          "type": "number"
        },
        "fill": {
          "description": "Default Fill Color.  This has higher precedence than config.color\n\n__Default value:__ (None)",
          "type": "string"
        },
        "fillOpacity": {
          "description": "The fill opacity (value between [0,1]).\n\n__Default value:__ `1`",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "filled": {
          "description": "Whether the mark's color should be used as fill color instead of stroke color.\n\n__Default value:__ `true` for all marks except `point` and `false` for `point`.\n\n__Applicable for:__ `bar`, `point`, `circle`, `square`, and `area` marks.\n\n__Note:__ This property cannot be used in a [style config](mark.html#style-config).",
          "type": "boolean"
        },
        "font": {
          "description": "The typeface to set the text in (e.g., `\"Helvetica Neue\"`).",
          "type": "string"
        },
        "fontSize": {
          "description": "The font size, in pixels.",
          "minimum": 0,
          "type": "number"
        },
        "fontStyle": {
          "$ref": "#/definitions/FontStyle",
          "description": "The font style (e.g., `\"italic\"`)."
        },
        "fontWeight": {
          "anyOf": [
            {
              "$ref": "#/definitions/FontWeight"
            },
            {
              "$ref": "#/definitions/FontWeightNumber"
            }
          ],
          "description": "The font weight (e.g., `\"bold\"`)."
        },
        "href": {
          "description": "A URL to load upon mouse click. If defined, the mark acts as a hyperlink.",
          "format": "uri",
          "type": "string"
        },
        "interpolate": {
          "$ref": "#/definitions/Interpolate",
          "description": "The line interpolation method to use for line and area marks. One of the following:\n- `\"linear\"`: piecewise linear segments, as in a polyline.\n- `\"linear-closed\"`: close the linear segments to form a polygon.\n- `\"step\"`: alternate between horizontal and vertical segments, as in a step function.\n- `\"step-before\"`: alternate between vertical and horizontal segments, as in a step function.\n- `\"step-after\"`: alternate between horizontal and vertical segments, as in a step function.\n- `\"basis\"`: a B-spline, with control point duplication on the ends.\n- `\"basis-open\"`: an open B-spline; may not intersect the start or end.\n- `\"basis-closed\"`: a closed B-spline, as in a loop.\n- `\"cardinal\"`: a Cardinal spline, with control point duplication on the ends.\n- `\"cardinal-open\"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.\n- `\"cardinal-closed\"`: a closed Cardinal spline, as in a loop.\n- `\"bundle\"`: equivalent to basis, except the tension parameter is used to straighten the spline.\n- `\"monotone\"`: cubic interpolation that preserves monotonicity in y."
        },
        "limit": {
          "description": "The maximum length of the text mark in pixels (default 0, indicating no limit). The text value will be automatically truncated if the rendered size exceeds the limit.",
          "type": "number"
        },
        "opacity": {
          "description": "The overall opacity (value between [0,1]).\n\n__Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "orient": {
          "$ref": "#/definitions/Orient",
          "description": "The orientation of a non-stacked bar, tick, area, and line charts.\nThe value is either horizontal (default) or vertical.\n- For bar, rule and tick, this determines whether the size of the bar and tick\nshould be applied to x or y dimension.\n- For area, this property determines the orient property of the Vega output.\n- For line, this property determines the sort order of the points in the line\nif `config.sortLineBy` is not specified.\nFor stacked charts, this is always determined by the orientation of the stack;\ntherefore explicitly specified value will be ignored."
        },
        "radius": {
          "description": "Polar coordinate radial offset, in pixels, of the text label from the origin determined by the `x` and `y` properties.",
          "minimum": 0,
          "type": "number"
        },
        "shape": {
          "description": "The default symbol shape to use. One of: `\"circle\"` (default), `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`, or `\"triangle-down\"`, or a custom SVG path.\n\n__Default value:__ `\"circle\"`",
          "type": "string"
        },
        "size": {
          "description": "The pixel area each the point/circle/square.\nFor example: in the case of circles, the radius is determined in part by the square root of the size value.\n\n__Default value:__ `30`",
          "minimum": 0,
          "type": "number"
        },
        "stroke": {
          "description": "Default Stroke Color.  This has higher precedence than config.color\n\n__Default value:__ (None)",
          "type": "string"
        },
        "strokeDash": {
          "description": "An array of alternating stroke, space lengths for creating dashed or dotted lines.",
          "items": {
            "type": "number"
          },
          "type": "array"
        },
        "strokeDashOffset": {
          "description": "The offset (in pixels) into which to begin drawing with the stroke dash array.",
          "type": "number"
        },
        "strokeOpacity": {
          "description": "The stroke opacity (value between [0,1]).\n\n__Default value:__ `1`",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "strokeWidth": {
          "description": "The stroke width, in pixels.",
          "minimum": 0,
          "type": "number"
        },
        "tension": {
          "description": "Depending on the interpolation type, sets the tension parameter (for line and area marks).",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "text": {
          "description": "Placeholder text if the `text` channel is not specified",
          "type": "string"
        },
        "theta": {
          "description": "Polar coordinate angle, in radians, of the text label from the origin determined by the `x` and `y` properties. Values for `theta` follow the same convention of `arc` mark `startAngle` and `endAngle` properties: angles are measured in radians, with `0` indicating \"north\".",
          "type": "number"
        }
      },
      "type": "object"
    },
    "MarkDef": {
      "additionalProperties": false,
      "properties": {
        "align": {
          "$ref": "#/definitions/HorizontalAlign",
          "description": "The horizontal alignment of the text. One of `\"left\"`, `\"right\"`, `\"center\"`."
        },
        "angle": {
          "description": "The rotation angle of the text, in degrees.",
          "maximum": 360,
          "minimum": 0,
          "type": "number"
        },
        "baseline": {
          "$ref": "#/definitions/VerticalAlign",
          "description": "The vertical alignment of the text. One of `\"top\"`, `\"middle\"`, `\"bottom\"`.\n\n__Default value:__ `\"middle\"`"
        },
        "clip": {
          "description": "Whether a mark be clipped to the enclosing groups width and height.",
          "type": "boolean"
        },
        "color": {
          "description": "Default color.  Note that `fill` and `stroke` have higher precedence than `color` and will override `color`.\n\n__Default value:__ <span style=\"color: #4682b4;\">&#9632;</span> `\"#4682b4\"`\n\n__Note:__ This property cannot be used in a [style config](mark.html#style-config).",
          "type": "string"
        },
        "cursor": {
          "description": "The mouse cursor used over the mark. Any valid [CSS cursor type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.",
          "enum": [
            "auto",
            "default",
            "none",
            "context-menu",
            "help",
            "pointer",
            "progress",
            "wait",
            "cell",
            "crosshair",
            "text",
            "vertical-text",
            "alias",
            "copy",
            "move",
            "no-drop",
            "not-allowed",
            "e-resize",
            "n-resize",
            "ne-resize",
            "nw-resize",
            "s-resize",
            "se-resize",
            "sw-resize",
            "w-resize",
            "ew-resize",
            "ns-resize",
            "nesw-resize",
            "nwse-resize",
            "col-resize",
            "row-resize",
            "all-scroll",
            "zoom-in",
            "zoom-out",
            "grab",
            "grabbing"
          ],
          "type": "string"
        },
        "dx": {
          "description": "The horizontal offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.",
          "type": "number"
        },
        "dy": {
          "description": "The vertical offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.",
          "type": "number"
        },
        "fill": {
          "description": "Default Fill Color.  This has higher precedence than config.color\n\n__Default value:__ (None)",
          "type": "string"
        },
        "fillOpacity": {
          "description": "The fill opacity (value between [0,1]).\n\n__Default value:__ `1`",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "filled": {
          "description": "Whether the mark's color should be used as fill color instead of stroke color.\n\n__Default value:__ `true` for all marks except `point` and `false` for `point`.\n\n__Applicable for:__ `bar`, `point`, `circle`, `square`, and `area` marks.\n\n__Note:__ This property cannot be used in a [style config](mark.html#style-config).",
          "type": "boolean"
        },
        "font": {
          "description": "The typeface to set the text in (e.g., `\"Helvetica Neue\"`).",
          "type": "string"
        },
        "fontSize": {
          "description": "The font size, in pixels.",
          "minimum": 0,
          "type": "number"
        },
        "fontStyle": {
          "$ref": "#/definitions/FontStyle",
          "description": "The font style (e.g., `\"italic\"`)."
        },
        "fontWeight": {
          "anyOf": [
            {
              "$ref": "#/definitions/FontWeight"
            },
            {
              "$ref": "#/definitions/FontWeightNumber"
            }
          ],
          "description": "The font weight (e.g., `\"bold\"`)."
        },
        "href": {
          "description": "A URL to load upon mouse click. If defined, the mark acts as a hyperlink.",
          "format": "uri",
          "type": "string"
        },
        "interpolate": {
          "$ref": "#/definitions/Interpolate",
          "description": "The line interpolation method to use for line and area marks. One of the following:\n- `\"linear\"`: piecewise linear segments, as in a polyline.\n- `\"linear-closed\"`: close the linear segments to form a polygon.\n- `\"step\"`: alternate between horizontal and vertical segments, as in a step function.\n- `\"step-before\"`: alternate between vertical and horizontal segments, as in a step function.\n- `\"step-after\"`: alternate between horizontal and vertical segments, as in a step function.\n- `\"basis\"`: a B-spline, with control point duplication on the ends.\n- `\"basis-open\"`: an open B-spline; may not intersect the start or end.\n- `\"basis-closed\"`: a closed B-spline, as in a loop.\n- `\"cardinal\"`: a Cardinal spline, with control point duplication on the ends.\n- `\"cardinal-open\"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.\n- `\"cardinal-closed\"`: a closed Cardinal spline, as in a loop.\n- `\"bundle\"`: equivalent to basis, except the tension parameter is used to straighten the spline.\n- `\"monotone\"`: cubic interpolation that preserves monotonicity in y."
        },
        "limit": {
          "description": "The maximum length of the text mark in pixels (default 0, indicating no limit). The text value will be automatically truncated if the rendered size exceeds the limit.",
          "type": "number"
        },
        "opacity": {
          "description": "The overall opacity (value between [0,1]).\n\n__Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "orient": {
          "$ref": "#/definitions/Orient",
          "description": "The orientation of a non-stacked bar, tick, area, and line charts.\nThe value is either horizontal (default) or vertical.\n- For bar, rule and tick, this determines whether the size of the bar and tick\nshould be applied to x or y dimension.\n- For area, this property determines the orient property of the Vega output.\n- For line, this property determines the sort order of the points in the line\nif `config.sortLineBy` is not specified.\nFor stacked charts, this is always determined by the orientation of the stack;\ntherefore explicitly specified value will be ignored."
        },
        "radius": {
          "description": "Polar coordinate radial offset, in pixels, of the text label from the origin determined by the `x` and `y` properties.",
          "minimum": 0,
          "type": "number"
        },
        "shape": {
          "description": "The default symbol shape to use. One of: `\"circle\"` (default), `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`, or `\"triangle-down\"`, or a custom SVG path.\n\n__Default value:__ `\"circle\"`",
          "type": "string"
        },
        "size": {
          "description": "The pixel area each the point/circle/square.\nFor example: in the case of circles, the radius is determined in part by the square root of the size value.\n\n__Default value:__ `30`",
          "minimum": 0,
          "type": "number"
        },
        "stroke": {
          "description": "Default Stroke Color.  This has higher precedence than config.color\n\n__Default value:__ (None)",
          "type": "string"
        },
        "strokeDash": {
          "description": "An array of alternating stroke, space lengths for creating dashed or dotted lines.",
          "items": {
            "type": "number"
          },
          "type": "array"
        },
        "strokeDashOffset": {
          "description": "The offset (in pixels) into which to begin drawing with the stroke dash array.",
          "type": "number"
        },
        "strokeOpacity": {
          "description": "The stroke opacity (value between [0,1]).\n\n__Default value:__ `1`",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "strokeWidth": {
          "description": "The stroke width, in pixels.",
          "minimum": 0,
          "type": "number"
        },
        "style": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            }
          ],
          "description": "A string or array of strings indicating the name of custom styles to apply to the mark. A style is a named collection of mark property defaults defined within the [style configuration](mark.html#style-config). If style is an array, later styles will override earlier styles. Any [mark properties](encoding.html#mark-prop) explicitly defined within the `encoding` will override a style default.\n\n__Default value:__ The mark's name.  For example, a bar mark will have style `\"bar\"` by default.\n__Note:__ Any specified style will augment the default style. For example, a bar mark with `\"style\": \"foo\"` will receive from `config.style.bar` and `config.style.foo` (the specified style `\"foo\"` has higher precedence)."
        },
        "tension": {
          "description": "Depending on the interpolation type, sets the tension parameter (for line and area marks).",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "text": {
          "description": "Placeholder text if the `text` channel is not specified",
          "type": "string"
        },
        "theta": {
          "description": "Polar coordinate angle, in radians, of the text label from the origin determined by the `x` and `y` properties. Values for `theta` follow the same convention of `arc` mark `startAngle` and `endAngle` properties: angles are measured in radians, with `0` indicating \"north\".",
          "type": "number"
        },
        "type": {
          "$ref": "#/definitions/Mark",
          "description": "The mark type.\nOne of `\"bar\"`, `\"circle\"`, `\"square\"`, `\"tick\"`, `\"line\"`,\n`\"area\"`, `\"point\"`, `\"geoshape\"`, `\"rule\"`, and `\"text\"`."
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    "Month": {
      "maximum": 12,
      "minimum": 1,
      "type": "number"
    },
    "MultiSelection": {
      "additionalProperties": false,
      "properties": {
        "empty": {
          "description": "By default, all data values are considered to lie within an empty selection.\nWhen set to `none`, empty selections contain no data values.",
          "enum": [
            "all",
            "none"
          ],
          "type": "string"
        },
        "encodings": {
          "description": "An array of encoding channels. The corresponding data field values\nmust match for a data tuple to fall within the selection.",
          "items": {
            "$ref": "#/definitions/SingleDefChannel"
          },
          "type": "array"
        },
        "fields": {
          "description": "An array of field names whose values must match for a data tuple to\nfall within the selection.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "nearest": {
          "description": "When true, an invisible voronoi diagram is computed to accelerate discrete\nselection. The data value _nearest_ the mouse cursor is added to the selection.\n\nSee the [nearest transform](nearest.html) documentation for more information.",
          "type": "boolean"
        },
        "on": {
          "$ref": "#/definitions/VgEventStream",
          "description": "A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection.\nFor interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters)."
        },
        "resolve": {
          "$ref": "#/definitions/SelectionResolution",
          "description": "With layered and multi-view displays, a strategy that determines how\nselections' data queries are resolved when applied in a filter transform,\nconditional encoding rule, or scale domain."
        },
        "toggle": {
          "description": "Controls whether data values should be toggled or only ever inserted into\nmulti selections. Can be `true`, `false` (for insertion only), or a\n[Vega expression](https://vega.github.io/vega/docs/expressions/).\n\n__Default value:__ `true`, which corresponds to `event.shiftKey` (i.e.,\ndata values are toggled when a user interacts with the shift-key pressed).\n\nSee the [toggle transform](toggle.html) documentation for more information.",
          "type": [
            "string",
            "boolean"
          ]
        },
        "type": {
          "enum": [
            "multi"
          ],
          "type": "string"
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    "MultiSelectionConfig": {
      "additionalProperties": false,
      "properties": {
        "empty": {
          "description": "By default, all data values are considered to lie within an empty selection.\nWhen set to `none`, empty selections contain no data values.",
          "enum": [
            "all",
            "none"
          ],
          "type": "string"
        },
        "encodings": {
          "description": "An array of encoding channels. The corresponding data field values\nmust match for a data tuple to fall within the selection.",
          "items": {
            "$ref": "#/definitions/SingleDefChannel"
          },
          "type": "array"
        },
        "fields": {
          "description": "An array of field names whose values must match for a data tuple to\nfall within the selection.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "nearest": {
          "description": "When true, an invisible voronoi diagram is computed to accelerate discrete\nselection. The data value _nearest_ the mouse cursor is added to the selection.\n\nSee the [nearest transform](nearest.html) documentation for more information.",
          "type": "boolean"
        },
        "on": {
          "$ref": "#/definitions/VgEventStream",
          "description": "A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection.\nFor interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters)."
        },
        "resolve": {
          "$ref": "#/definitions/SelectionResolution",
          "description": "With layered and multi-view displays, a strategy that determines how\nselections' data queries are resolved when applied in a filter transform,\nconditional encoding rule, or scale domain."
        },
        "toggle": {
          "description": "Controls whether data values should be toggled or only ever inserted into\nmulti selections. Can be `true`, `false` (for insertion only), or a\n[Vega expression](https://vega.github.io/vega/docs/expressions/).\n\n__Default value:__ `true`, which corresponds to `event.shiftKey` (i.e.,\ndata values are toggled when a user interacts with the shift-key pressed).\n\nSee the [toggle transform](toggle.html) documentation for more information.",
          "type": [
            "string",
            "boolean"
          ]
        }
      },
      "type": "object"
    },
    "MultiTimeUnit": {
      "anyOf": [
        {
          "$ref": "#/definitions/LocalMultiTimeUnit"
        },
        {
          "$ref": "#/definitions/UtcMultiTimeUnit"
        }
      ]
    },
    "NamedData": {
      "additionalProperties": false,
      "properties": {
        "format": {
          "$ref": "#/definitions/DataFormat",
          "description": "An object that specifies the format for parsing the data."
        },
        "name": {
          "description": "Provide a placeholder name and bind data at runtime.",
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "NiceTime": {
      "enum": [
        "second",
        "minute",
        "hour",
        "day",
        "week",
        "month",
        "year"
      ],
      "type": "string"
    },
    "OrderFieldDef": {
      "additionalProperties": false,
      "properties": {
        "aggregate": {
          "$ref": "#/definitions/Aggregate",
          "description": "Aggregation function for the field\n(e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).\n\n__Default value:__ `undefined` (None)"
        },
        "bin": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/BinParams"
            }
          ],
          "description": "A flag for binning a `quantitative` field, or [an object defining binning parameters](bin.html#params).\nIf `true`, default [binning parameters](bin.html) will be applied.\n\n__Default value:__ `false`"
        },
        "field": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/RepeatRef"
            }
          ],
          "description": "__Required.__ A string defining the name of the field from which to pull a data value\nor an object defining iterated values from the [`repeat`](repeat.html) operator.\n\n__Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`).\nIf field names contain dots or brackets but are not nested, you can use `\\\\` to escape dots and brackets (e.g., `\"a\\\\.b\"` and `\"a\\\\[0\\\\]\"`).\nSee more details about escaping in the [field documentation](field.html).\n\n__Note:__ `field` is not required if `aggregate` is `count`."
        },
        "sort": {
          "$ref": "#/definitions/SortOrder",
          "description": "The sort order. One of `\"ascending\"` (default) or `\"descending\"`."
        },
        "timeUnit": {
          "$ref": "#/definitions/TimeUnit",
          "description": "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.\nor [a temporal field that gets casted as ordinal](type.html#cast).\n\n__Default value:__ `undefined` (None)"
        },
        "type": {
          "$ref": "#/definitions/Type",
          "description": "The encoded field's type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`).\nIt can also be a geo type (`\"latitude\"`, `\"longitude\"`, and `\"geojson\"`) when a [geographic projection](projection.html) is applied."
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    "Orient": {
      "enum": [
        "horizontal",
        "vertical"
      ],
      "type": "string"
    },
    "Padding": {
      "anyOf": [
        {
          "type": "number"
        },
        {
          "additionalProperties": false,
          "properties": {
            "bottom": {
              "type": "number"
            },
            "left": {
              "type": "number"
            },
            "right": {
              "type": "number"
            },
            "top": {
              "type": "number"
            }
          },
          "type": "object"
        }
      ],
      "minimum": 0
    },
    "PositionFieldDef": {
      "additionalProperties": false,
      "properties": {
        "aggregate": {
          "$ref": "#/definitions/Aggregate",
          "description": "Aggregation function for the field\n(e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).\n\n__Default value:__ `undefined` (None)"
        },
        "axis": {
          "anyOf": [
            {
              "$ref": "#/definitions/Axis"
            },
            {
              "type": "null"
            }
          ],
          "description": "An object defining properties of axis's gridlines, ticks and labels.\nIf `null`, the axis for the encoding channel will be removed.\n\n__Default value:__ If undefined, default [axis properties](axis.html) are applied."
        },
        "bin": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/BinParams"
            }
          ],
          "description": "A flag for binning a `quantitative` field, or [an object defining binning parameters](bin.html#params).\nIf `true`, default [binning parameters](bin.html) will be applied.\n\n__Default value:__ `false`"
        },
        "field": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/RepeatRef"
            }
          ],
          "description": "__Required.__ A string defining the name of the field from which to pull a data value\nor an object defining iterated values from the [`repeat`](repeat.html) operator.\n\n__Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`).\nIf field names contain dots or brackets but are not nested, you can use `\\\\` to escape dots and brackets (e.g., `\"a\\\\.b\"` and `\"a\\\\[0\\\\]\"`).\nSee more details about escaping in the [field documentation](field.html).\n\n__Note:__ `field` is not required if `aggregate` is `count`."
        },
        "scale": {
          "$ref": "#/definitions/Scale",
          "description": "An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n\n__Default value:__ If undefined, default [scale properties](scale.html) are applied."
        },
        "sort": {
          "anyOf": [
            {
              "$ref": "#/definitions/SortOrder"
            },
            {
              "$ref": "#/definitions/SortField"
            },
            {
              "type": "null"
            }
          ],
          "description": "Sort order for the encoded field.\nSupported `sort` values include `\"ascending\"`, `\"descending\"` and `null` (no sorting).\nFor fields with discrete domains, `sort` can also be a [sort field definition object](sort.html#sort-field).\n\n__Default value:__ `\"ascending\"`"
        },
        "stack": {
          "anyOf": [
            {
              "$ref": "#/definitions/StackOffset"
            },
            {
              "type": "null"
            }
          ],
          "description": "Type of stacking offset if the field should be stacked.\n`stack` is only applicable for `x` and `y` channels with continuous domains.\nFor example, `stack` of `y` can be used to customize stacking for a vertical bar chart.\n\n`stack` can be one of the following values:\n- `\"zero\"`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](stack.html#bar) and [area](stack.html#area) chart).\n- `\"normalize\"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](stack.html#normalized). <br/>\n-`\"center\"` - stacking with center baseline (for [streamgraph](stack.html#streamgraph)).\n- `null` - No-stacking. This will produce layered [bar](stack.html#layered-bar-chart) and area chart.\n\n__Default value:__ `zero` for plots with all of the following conditions are true:\n(1) the mark is `bar` or `area`;\n(2) the stacked measure channel (x or y) has a linear scale;\n(3) At least one of non-position channels mapped to an unaggregated field that is different from x and y.  Otherwise, `null` by default."
        },
        "timeUnit": {
          "$ref": "#/definitions/TimeUnit",
          "description": "Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.\nor [a temporal field that gets casted as ordinal](type.html#cast).\n\n__Default value:__ `undefined` (None)"
        },
        "type": {
          "$ref": "#/definitions/Type",
          "description": "The encoded field's type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`).\nIt can also be a geo type (`\"latitude\"`, `\"longitude\"`, and `\"geojson\"`) when a [geographic projection](projection.html) is applied."
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    "Predicate": {
      "anyOf": [
        {
          "$ref": "#/definitions/FieldEqualPredicate"
        },
        {
          "$ref": "#/definitions/FieldRangePredicate"
        },
        {
          "$ref": "#/definitions/FieldOneOfPredicate"
        },
        {
          "$ref": "#/definitions/SelectionPredicate"
        },
        {
          "type": "string"
        }
      ]
    },
    "Projection": {
      "additionalProperties": false,
      "properties": {
        "center": {
          "description": "Sets the projections center to the specified center, a two-element array of longitude and latitude in degrees.\n\n__Default value:__ `[0, 0]`",
          "items": {
            "type": "number"
          },
          "type": "array"
        },
        "clipAngle": {
          "description": "Sets the projections clipping circle radius to the specified angle in degrees. If `null`, switches to [antimeridian](http://bl.ocks.org/mbostock/3788999) cutting rather than small-circle clipping.",
          "type": "number"
        },
        "clipExtent": {
          "description": "Sets the projections viewport clip extent to the specified bounds in pixels. The extent bounds are specified as an array `[[x0, y0], [x1, y1]]`, where `x0` is the left-side of the viewport, `y0` is the top, `x1` is the right and `y1` is the bottom. If `null`, no viewport clipping is performed.",
          "items": {
            "items": {
              "type": "number"
            },
            "type": "array"
          },
          "type": "array"
        },
        "coefficient": {
          "type": "number"
        },
        "distance": {
          "type": "number"
        },
        "fraction": {
          "type": "number"
        },
        "lobes": {
          "type": "number"
        },
        "parallel": {
          "type": "number"
        },
        "precision": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Sets the threshold for the projections [adaptive resampling](http://bl.ocks.org/mbostock/3795544) to the specified value in pixels. This value corresponds to the [DouglasPeucker distance](http://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm). If precision is not specified, returns the projections current resampling precision which defaults to `0.5  0.70710`.",
          "properties": {
            "length": {
              "description": "Returns the length of a String object. ",
              "type": "number"
            }
          },
          "required": [
            "length"
          ],
          "type": "object"
        },
        "radius": {
          "type": "number"
        },
        "ratio": {
          "type": "number"
        },
        "rotate": {
          "description": "Sets the projections three-axis rotation to the specified angles, which must be a two- or three-element array of numbers [`lambda`, `phi`, `gamma`] specifying the rotation angles in degrees about each spherical axis. (These correspond to yaw, pitch and roll.)\n\n__Default value:__ `[0, 0, 0]`",
          "items": {
            "type": "number"
          },
          "type": "array"
        },
        "spacing": {
          "type": "number"
        },
        "tilt": {
          "type": "number"
        },
        "type": {
          "$ref": "#/definitions/ProjectionType",
          "description": "The cartographic projection to use. This value is case-insensitive, for example `\"albers\"` and `\"Albers\"` indicate the same projection type. You can find all valid projection types [in the documentation](https://vega.github.io/vega-lite/docs/projection.html#projection-types).\n\n__Default value:__ `mercator`"
        }
      },
      "type": "object"
    },
    "ProjectionConfig": {
      "additionalProperties": false,
      "description": "Any property of Projection can be in config",
      "properties": {
        "center": {
          "description": "Sets the projections center to the specified center, a two-element array of longitude and latitude in degrees.\n\n__Default value:__ `[0, 0]`",
          "items": {
            "type": "number"
          },
          "type": "array"
        },
        "clipAngle": {
          "description": "Sets the projections clipping circle radius to the specified angle in degrees. If `null`, switches to [antimeridian](http://bl.ocks.org/mbostock/3788999) cutting rather than small-circle clipping.",
          "type": "number"
        },
        "clipExtent": {
          "description": "Sets the projections viewport clip extent to the specified bounds in pixels. The extent bounds are specified as an array `[[x0, y0], [x1, y1]]`, where `x0` is the left-side of the viewport, `y0` is the top, `x1` is the right and `y1` is the bottom. If `null`, no viewport clipping is performed.",
          "items": {
            "items": {
              "type": "number"
            },
            "type": "array"
          },
          "type": "array"
        },
        "coefficient": {
          "type": "number"
        },
        "distance": {
          "type": "number"
        },
        "fraction": {
          "type": "number"
        },
        "lobes": {
          "type": "number"
        },
        "parallel": {
          "type": "number"
        },
        "precision": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Sets the threshold for the projections [adaptive resampling](http://bl.ocks.org/mbostock/3795544) to the specified value in pixels. This value corresponds to the [DouglasPeucker distance](http://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm). If precision is not specified, returns the projections current resampling precision which defaults to `0.5  0.70710`.",
          "properties": {
            "length": {
              "description": "Returns the length of a String object. ",
              "type": "number"
            }
          },
          "required": [
            "length"
          ],
          "type": "object"
        },
        "radius": {
          "type": "number"
        },
        "ratio": {
          "type": "number"
        },
        "rotate": {
          "description": "Sets the projections three-axis rotation to the specified angles, which must be a two- or three-element array of numbers [`lambda`, `phi`, `gamma`] specifying the rotation angles in degrees about each spherical axis. (These correspond to yaw, pitch and roll.)\n\n__Default value:__ `[0, 0, 0]`",
          "items": {
            "type": "number"
          },
          "type": "array"
        },
        "spacing": {
          "type": "number"
        },
        "tilt": {
          "type": "number"
        },
        "type": {
          "$ref": "#/definitions/ProjectionType",
          "description": "The cartographic projection to use. This value is case-insensitive, for example `\"albers\"` and `\"Albers\"` indicate the same projection type. You can find all valid projection types [in the documentation](https://vega.github.io/vega-lite/docs/projection.html#projection-types).\n\n__Default value:__ `mercator`"
        }
      },
      "type": "object"
    },
    "ProjectionType": {
      "$ref": "#/definitions/VgProjectionType"
    },
    "RangeConfig": {
      "additionalProperties": {
        "$ref": "#/definitions/RangeConfigValue"
      },
      "properties": {
        "category": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "$ref": "#/definitions/VgScheme"
            }
          ],
          "description": "Default range for _nominal_ (categorical) fields."
        },
        "diverging": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "$ref": "#/definitions/VgScheme"
            }
          ],
          "description": "Default range for diverging _quantitative_ fields."
        },
        "heatmap": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "$ref": "#/definitions/VgScheme"
            }
          ],
          "description": "Default range for _quantitative_ heatmaps."
        },
        "ordinal": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "$ref": "#/definitions/VgScheme"
            }
          ],
          "description": "Default range for _ordinal_ fields."
        },
        "ramp": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "$ref": "#/definitions/VgScheme"
            }
          ],
          "description": "Default range for _quantitative_ and _temporal_ fields."
        },
        "symbol": {
          "description": "Default range palette for the `shape` channel.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "RangeConfigValue": {
      "anyOf": [
        {
          "items": {
            "type": [
              "number",
              "string"
            ]
          },
          "type": "array"
        },
        {
          "$ref": "#/definitions/VgScheme"
        },
        {
          "additionalProperties": false,
          "properties": {
            "step": {
              "type": "number"
            }
          },
          "required": [
            "step"
          ],
          "type": "object"
        }
      ]
    },
    "Repeat": {
      "additionalProperties": false,
      "properties": {
        "column": {
          "description": "Horizontal repeated views.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "row": {
          "description": "Vertical repeated views.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "RepeatRef": {
      "additionalProperties": false,
      "description": "Reference to a repeated value.",
      "properties": {
        "repeat": {
          "enum": [
            "row",
            "column"
          ],
          "type": "string"
        }
      },
      "required": [
        "repeat"
      ],
      "type": "object"
    },
    "Resolve": {
      "additionalProperties": false,
      "description": "Defines how scales, axes, and legends from different specs should be combined. Resolve is a mapping from `scale`, `axis`, and `legend` to a mapping from channels to resolutions.",
      "properties": {
        "axis": {
          "$ref": "#/definitions/AxisResolveMap"
        },
        "legend": {
          "$ref": "#/definitions/LegendResolveMap"
        },
        "scale": {
          "$ref": "#/definitions/ScaleResolveMap"
        }
      },
      "type": "object"
    },
    "ResolveMode": {
      "enum": [
        "independent",
        "shared"
      ],
      "type": "string"
    },
    "Scale": {
      "additionalProperties": false,
      "properties": {
        "base": {
          "description": "The logarithm base of the `log` scale (default `10`).",
          "type": "number"
        },
        "clamp": {
          "description": "If `true`, values that exceed the data domain are clamped to either the minimum or maximum range value\n\n__Default value:__ derived from the [scale config](config.html#scale-config)'s `clamp` (`true` by default).",
          "type": "boolean"
        },
        "domain": {
          "anyOf": [
            {
              "items": {
                "type": "number"
              },
              "type": "array"
            },
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "items": {
                "type": "boolean"
              },
              "type": "array"
            },
            {
              "items": {
                "$ref": "#/definitions/DateTime"
              },
              "type": "array"
            },
            {
              "enum": [
                "unaggregated"
              ],
              "type": "string"
            },
            {
              "$ref": "#/definitions/SelectionDomain"
            }
          ],
          "description": "Customized domain values.\n\nFor _quantitative_ fields, `domain` can take the form of a two-element array with minimum and maximum values.  [Piecewise scales](scale.html#piecewise) can be created by providing a `domain` with more than two entries.\nIf the input field is aggregated, `domain` can also be a string value `\"unaggregated\"`, indicating that the domain should include the raw data values prior to the aggregation.\n\nFor _temporal_ fields, `domain` can be a two-element array minimum and maximum values, in the form of either timestamps or the [DateTime definition objects](types.html#datetime).\n\nFor _ordinal_ and _nominal_ fields, `domain` can be an array that lists valid input values.\n\nThe `selection` property can be used to [interactively determine](selection.html#scale-domains) the scale domain."
        },
        "exponent": {
          "description": "The exponent of the `pow` scale.",
          "type": "number"
        },
        "interpolate": {
          "anyOf": [
            {
              "$ref": "#/definitions/Interpolate"
            },
            {
              "$ref": "#/definitions/InterpolateParams"
            }
          ],
          "description": "The interpolation method for range values. By default, a general interpolator for numbers, dates, strings and colors (in RGB space) is used. For color ranges, this property allows interpolation in alternative color spaces. Legal values include `rgb`, `hsl`, `hsl-long`, `lab`, `hcl`, `hcl-long`, `cubehelix` and `cubehelix-long` ('-long' variants use longer paths in polar coordinate spaces). If object-valued, this property accepts an object with a string-valued _type_ property and an optional numeric _gamma_ property applicable to rgb and cubehelix interpolators. For more, see the [d3-interpolate documentation](https://github.com/d3/d3-interpolate).\n\n__Note:__ Sequential scales do not support `interpolate` as they have a fixed interpolator.  Since Vega-Lite uses sequential scales for quantitative fields by default, you have to set the scale `type` to other quantitative scale type such as `\"linear\"` to customize `interpolate`."
        },
        "nice": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "type": "number"
            },
            {
              "$ref": "#/definitions/NiceTime"
            },
            {
              "additionalProperties": false,
              "properties": {
                "interval": {
                  "type": "string"
                },
                "step": {
                  "type": "number"
                }
              },
              "required": [
                "interval",
                "step"
              ],
              "type": "object"
            }
          ],
          "description": "Extending the domain so that it starts and ends on nice round values. This method typically modifies the scales domain, and may only extend the bounds to the nearest round value. Nicing is useful if the domain is computed from data and may be irregular. For example, for a domain of _[0.201479, 0.996679]_, a nice domain might be _[0.2, 1.0]_.\n\nFor quantitative scales such as linear, `nice` can be either a boolean flag or a number. If `nice` is a number, it will represent a desired tick count. This allows greater control over the step size used to extend the bounds, guaranteeing that the returned ticks will exactly cover the domain.\n\nFor temporal fields with time and utc scales, the `nice` value can be a string indicating the desired time interval. Legal values are `\"millisecond\"`, `\"second\"`, `\"minute\"`, `\"hour\"`, `\"day\"`, `\"week\"`, `\"month\"`, and `\"year\"`. Alternatively, `time` and `utc` scales can accept an object-valued interval specifier of the form `{\"interval\": \"month\", \"step\": 3}`, which includes a desired number of interval steps. Here, the domain would snap to quarter (Jan, Apr, Jul, Oct) boundaries.\n\n__Default value:__ `true` for unbinned _quantitative_ fields; `false` otherwise."
        },
        "padding": {
          "description": "For _[continuous](scale.html#continuous)_ scales, expands the scale domain to accommodate the specified number of pixels on each of the scale range. The scale range must represent pixels for this parameter to function as intended. Padding adjustment is performed prior to all other adjustments, including the effects of the zero, nice, domainMin, and domainMax properties.\n\nFor _[band](scale.html#band)_ scales, shortcut for setting `paddingInner` and `paddingOuter` to the same value.\n\nFor _[point](scale.html#point)_ scales, alias for `paddingOuter`.\n\n__Default value:__ For _continuous_ scales, derived from the [scale config](scale.html#config)'s `continuousPadding`.\nFor _band and point_ scales, see `paddingInner` and `paddingOuter`.",
          "minimum": 0,
          "type": "number"
        },
        "paddingInner": {
          "description": "The inner padding (spacing) within each band step of band scales, as a fraction of the step size. This value must lie in the range [0,1].\n\nFor point scale, this property is invalid as point scales do not have internal band widths (only step sizes between bands).\n\n__Default value:__ derived from the [scale config](scale.html#config)'s `bandPaddingInner`.",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "paddingOuter": {
          "description": "The outer padding (spacing) at the ends of the range of band and point scales,\nas a fraction of the step size. This value must lie in the range [0,1].\n\n__Default value:__ derived from the [scale config](scale.html#config)'s `bandPaddingOuter` for band scales and `pointPadding` for point scales.",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "range": {
          "anyOf": [
            {
              "items": {
                "type": "number"
              },
              "type": "array"
            },
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "string"
            }
          ],
          "description": "The range of the scale. One of:\n\n- A string indicating a [pre-defined named scale range](scale.html#range-config) (e.g., example, `\"symbol\"`, or `\"diverging\"`).\n\n- For [continuous scales](scale.html#continuous), two-element array indicating  minimum and maximum values, or an array with more than two entries for specifying a [piecewise scale](scale.html#piecewise).\n\n- For [discrete](scale.html#discrete) and [discretizing](scale.html#discretizing) scales, an array of desired output values.\n\n__Notes:__\n\n1) For [sequential](scale.html#sequential), [ordinal](scale.html#ordinal), and discretizing color scales, you can also specify a color [`scheme`](scale.html#scheme) instead of `range`.\n\n2) Any directly specified `range` for `x` and `y` channels will be ignored. Range can be customized via the view's corresponding [size](size.html) (`width` and `height`) or via [range steps and paddings properties](#range-step) for [band](#band) and [point](#point) scales."
        },
        "rangeStep": {
          "description": "The distance between the starts of adjacent bands or points in [band](scale.html#band) and [point](scale.html#point) scales.\n\nIf `rangeStep` is `null` or if the view contains the scale's corresponding [size](size.html) (`width` for `x` scales and `height` for `y` scales), `rangeStep` will be automatically determined to fit the size of the view.\n\n__Default value:__  derived the [scale config](config.html#scale-config)'s `textXRangeStep` (`90` by default) for x-scales of `text` marks and `rangeStep` (`21` by default) for x-scales of other marks and y-scales.\n\n__Warning__: If `rangeStep` is `null` and the cardinality of the scale's domain is higher than `width` or `height`, the rangeStep might become less than one pixel and the mark might not appear correctly.",
          "minimum": 0,
          "type": [
            "number",
            "null"
          ]
        },
        "round": {
          "description": "If `true`, rounds numeric output values to integers. This can be helpful for snapping to the pixel grid.\n\n__Default value:__ `false`.",
          "type": "boolean"
        },
        "scheme": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/SchemeParams"
            }
          ],
          "description": "A string indicating a color [scheme](scale.html#scheme) name (e.g., `\"category10\"` or `\"viridis\"`) or a [scheme parameter object](scale.html#scheme-params).\n\nDiscrete color schemes may be used with [discrete](scale.html#discrete) or [discretizing](scale.html#discretizing) scales. Continuous color schemes are intended for use with [sequential](scales.html#sequential) scales.\n\nFor the full list of supported scheme, please refer to the [Vega Scheme](https://vega.github.io/vega/docs/schemes/#reference) reference."
        },
        "type": {
          "$ref": "#/definitions/ScaleType",
          "description": "The type of scale.  Vega-Lite supports the following categories of scale types:\n\n1) [**Continuous Scales**](scale.html#continuous) -- mapping continuous domains to continuous output ranges ([`\"linear\"`](scale.html#linear), [`\"pow\"`](scale.html#pow), [`\"sqrt\"`](scale.html#sqrt), [`\"log\"`](scale.html#log), [`\"time\"`](scale.html#time), [`\"utc\"`](scale.html#utc), [`\"sequential\"`](scale.html#sequential)).\n\n2) [**Discrete Scales**](scale.html#discrete) -- mapping discrete domains to discrete ([`\"ordinal\"`](scale.html#ordinal)) or continuous ([`\"band\"`](scale.html#band) and [`\"point\"`](scale.html#point)) output ranges.\n\n3) [**Discretizing Scales**](scale.html#discretizing) -- mapping continuous domains to discrete output ranges ([`\"bin-linear\"`](scale.html#bin-linear) and [`\"bin-ordinal\"`](scale.html#bin-ordinal)).\n\n__Default value:__ please see the [scale type table](scale.html#type)."
        },
        "zero": {
          "description": "If `true`, ensures that a zero baseline value is included in the scale domain.\n\n__Default value:__ `true` for x and y channels if the quantitative field is not binned and no custom `domain` is provided; `false` otherwise.\n\n__Note:__ Log, time, and utc scales do not support `zero`.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ScaleConfig": {
      "additionalProperties": false,
      "properties": {
        "bandPaddingInner": {
          "description": "Default inner padding for `x` and `y` band-ordinal scales.\n\n__Default value:__ `0.1`",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "bandPaddingOuter": {
          "description": "Default outer padding for `x` and `y` band-ordinal scales.\nIf not specified, by default, band scale's paddingOuter is paddingInner/2.",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "clamp": {
          "description": "If true, values that exceed the data domain are clamped to either the minimum or maximum range value",
          "type": "boolean"
        },
        "continuousPadding": {
          "description": "Default padding for continuous scales.\n\n__Default:__ `5` for continuous x-scale of a vertical bar and continuous y-scale of a horizontal bar.; `0` otherwise.",
          "minimum": 0,
          "type": "number"
        },
        "maxBandSize": {
          "description": "The default max value for mapping quantitative fields to bar's size/bandSize.\n\nIf undefined (default), we will use the scale's `rangeStep` - 1.",
          "minimum": 0,
          "type": "number"
        },
        "maxFontSize": {
          "description": "The default max value for mapping quantitative fields to text's size/fontSize.\n\n__Default value:__ `40`",
          "minimum": 0,
          "type": "number"
        },
        "maxOpacity": {
          "description": "Default max opacity for mapping a field to opacity.\n\n__Default value:__ `0.8`",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "maxSize": {
          "description": "Default max value for point size scale.",
          "minimum": 0,
          "type": "number"
        },
        "maxStrokeWidth": {
          "description": "Default max strokeWidth for strokeWidth  (or rule/line's size) scale.\n\n__Default value:__ `4`",
          "minimum": 0,
          "type": "number"
        },
        "minBandSize": {
          "description": "The default min value for mapping quantitative fields to bar and tick's size/bandSize scale with zero=false.\n\n__Default value:__ `2`",
          "minimum": 0,
          "type": "number"
        },
        "minFontSize": {
          "description": "The default min value for mapping quantitative fields to tick's size/fontSize scale with zero=false\n\n__Default value:__ `8`",
          "minimum": 0,
          "type": "number"
        },
        "minOpacity": {
          "description": "Default minimum opacity for mapping a field to opacity.\n\n__Default value:__ `0.3`",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "minSize": {
          "description": "Default minimum value for point size scale with zero=false.\n\n__Default value:__ `9`",
          "minimum": 0,
          "type": "number"
        },
        "minStrokeWidth": {
          "description": "Default minimum strokeWidth for strokeWidth (or rule/line's size) scale with zero=false.\n\n__Default value:__ `1`",
          "minimum": 0,
          "type": "number"
        },
        "pointPadding": {
          "description": "Default outer padding for `x` and `y` point-ordinal scales.\n\n__Default value:__ `0.5`",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "rangeStep": {
          "description": "Default range step for band and point scales of (1) the `y` channel\nand (2) the `x` channel when the mark is not `text`.\n\n__Default value:__ `21`",
          "minimum": 0,
          "type": [
            "number",
            "null"
          ]
        },
        "round": {
          "description": "If true, rounds numeric output values to integers.\nThis can be helpful for snapping to the pixel grid.\n(Only available for `x`, `y`, and `size` scales.)",
          "type": "boolean"
        },
        "textXRangeStep": {
          "description": "Default range step for `x` band and point scales of text marks.\n\n__Default value:__ `90`",
          "minimum": 0,
          "type": "number"
        },
        "useUnaggregatedDomain": {
          "description": "Use the source data range before aggregation as scale domain instead of aggregated data for aggregate axis.\n\nThis is equivalent to setting `domain` to `\"unaggregate\"` for aggregated _quantitative_ fields by default.\n\nThis property only works with aggregate functions that produce values within the raw data domain (`\"mean\"`, `\"average\"`, `\"median\"`, `\"q1\"`, `\"q3\"`, `\"min\"`, `\"max\"`). For other aggregations that produce values outside of the raw data domain (e.g. `\"count\"`, `\"sum\"`), this property is ignored.\n\n__Default value:__ `false`",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ScaleResolveMap": {
      "additionalProperties": false,
      "properties": {
        "color": {
          "$ref": "#/definitions/ResolveMode"
        },
        "opacity": {
          "$ref": "#/definitions/ResolveMode"
        },
        "shape": {
          "$ref": "#/definitions/ResolveMode"
        },
        "size": {
          "$ref": "#/definitions/ResolveMode"
        },
        "x": {
          "$ref": "#/definitions/ResolveMode"
        },
        "y": {
          "$ref": "#/definitions/ResolveMode"
        }
      },
      "type": "object"
    },
    "ScaleType": {
      "enum": [
        "linear",
        "bin-linear",
        "log",
        "pow",
        "sqrt",
        "time",
        "utc",
        "sequential",
        "ordinal",
        "bin-ordinal",
        "point",
        "band"
      ],
      "type": "string"
    },
    "SchemeParams": {
      "additionalProperties": false,
      "properties": {
        "extent": {
          "description": "For sequential and diverging schemes only, determines the extent of the color range to use. For example `[0.2, 1]` will rescale the color scheme such that color values in the range _[0, 0.2)_ are excluded from the scheme.",
          "items": {
            "type": "number"
          },
          "type": "array"
        },
        "name": {
          "description": "A color scheme name for sequential/ordinal scales (e.g., `\"category10\"` or `\"viridis\"`).\n\nFor the full list of supported scheme, please refer to the [Vega Scheme](https://vega.github.io/vega/docs/schemes/#reference) reference.",
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "SelectionConfig": {
      "additionalProperties": false,
      "properties": {
        "interval": {
          "$ref": "#/definitions/IntervalSelectionConfig",
          "description": "The default definition for an [`interval`](selection.html#type) selection. All properties and transformations\nfor an interval selection definition (except `type`) may be specified here.\n\nFor instance, setting `interval` to `{\"translate\": false}` disables the ability to move\ninterval selections by default."
        },
        "multi": {
          "$ref": "#/definitions/MultiSelectionConfig",
          "description": "The default definition for a [`multi`](selection.html#type) selection. All properties and transformations\nfor a multi selection definition (except `type`) may be specified here.\n\nFor instance, setting `multi` to `{\"toggle\": \"event.altKey\"}` adds additional values to\nmulti selections when clicking with the alt-key pressed by default."
        },
        "single": {
          "$ref": "#/definitions/SingleSelectionConfig",
          "description": "The default definition for a [`single`](selection.html#type) selection. All properties and transformations\n  for a single selection definition (except `type`) may be specified here.\n\nFor instance, setting `single` to `{\"on\": \"dblclick\"}` populates single selections on double-click by default."
        }
      },
      "type": "object"
    },
    "SelectionDef": {
      "anyOf": [
        {
          "$ref": "#/definitions/SingleSelection"
        },
        {
          "$ref": "#/definitions/MultiSelection"
        },
        {
          "$ref": "#/definitions/IntervalSelection"
        }
      ]
    },
    "SelectionDomain": {
      "anyOf": [
        {
          "additionalProperties": false,
          "properties": {
            "field": {
              "description": "The field name to extract selected values for, when a selection is [projected](project.html)\nover multiple fields or encodings.",
              "type": "string"
            },
            "selection": {
              "description": "The name of a selection.",
              "type": "string"
            }
          },
          "required": [
            "selection"
          ],
          "type": "object"
        },
        {
          "additionalProperties": false,
          "properties": {
            "encoding": {
              "description": "The encoding channel to extract selected values for, when a selection is [projected](project.html)\nover multiple fields or encodings.",
              "type": "string"
            },
            "selection": {
              "description": "The name of a selection.",
              "type": "string"
            }
          },
          "required": [
            "selection"
          ],
          "type": "object"
        }
      ]
    },
    "SelectionPredicate": {
      "additionalProperties": false,
      "properties": {
        "selection": {
          "$ref": "#/definitions/SelectionOperand",
          "description": "Filter using a selection name."
        }
      },
      "required": [
        "selection"
      ],
      "type": "object"
    },
    "SelectionResolution": {
      "enum": [
        "global",
        "union",
        "intersect"
      ],
      "type": "string"
    },
    "SingleDefChannel": {
      "enum": [
        "x",
        "y",
        "x2",
        "y2",
        "row",
        "column",
        "size",
        "shape",
        "color",
        "opacity",
        "text",
        "tooltip",
        "href"
      ],
      "type": "string"
    },
    "SingleSelection": {
      "additionalProperties": false,
      "properties": {
        "bind": {
          "anyOf": [
            {
              "$ref": "#/definitions/VgBinding"
            },
            {
              "additionalProperties": {
                "$ref": "#/definitions/VgBinding"
              },
              "type": "object"
            }
          ],
          "description": "Establish a two-way binding between a single selection and input elements\n(also known as dynamic query widgets). A binding takes the form of\nVega's [input element binding definition](https://vega.github.io/vega/docs/signals/#bind)\nor can be a mapping between projected field/encodings and binding definitions.\n\nSee the [bind transform](bind.html) documentation for more information."
        },
        "empty": {
          "description": "By default, all data values are considered to lie within an empty selection.\nWhen set to `none`, empty selections contain no data values.",
          "enum": [
            "all",
            "none"
          ],
          "type": "string"
        },
        "encodings": {
          "description": "An array of encoding channels. The corresponding data field values\nmust match for a data tuple to fall within the selection.",
          "items": {
            "$ref": "#/definitions/SingleDefChannel"
          },
          "type": "array"
        },
        "fields": {
          "description": "An array of field names whose values must match for a data tuple to\nfall within the selection.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "nearest": {
          "description": "When true, an invisible voronoi diagram is computed to accelerate discrete\nselection. The data value _nearest_ the mouse cursor is added to the selection.\n\nSee the [nearest transform](nearest.html) documentation for more information.",
          "type": "boolean"
        },
        "on": {
          "$ref": "#/definitions/VgEventStream",
          "description": "A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection.\nFor interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters)."
        },
        "resolve": {
          "$ref": "#/definitions/SelectionResolution",
          "description": "With layered and multi-view displays, a strategy that determines how\nselections' data queries are resolved when applied in a filter transform,\nconditional encoding rule, or scale domain."
        },
        "type": {
          "enum": [
            "single"
          ],
          "type": "string"
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    "SingleSelectionConfig": {
      "additionalProperties": false,
      "properties": {
        "bind": {
          "anyOf": [
            {
              "$ref": "#/definitions/VgBinding"
            },
            {
              "additionalProperties": {
                "$ref": "#/definitions/VgBinding"
              },
              "type": "object"
            }
          ],
          "description": "Establish a two-way binding between a single selection and input elements\n(also known as dynamic query widgets). A binding takes the form of\nVega's [input element binding definition](https://vega.github.io/vega/docs/signals/#bind)\nor can be a mapping between projected field/encodings and binding definitions.\n\nSee the [bind transform](bind.html) documentation for more information."
        },
        "empty": {
          "description": "By default, all data values are considered to lie within an empty selection.\nWhen set to `none`, empty selections contain no data values.",
          "enum": [
            "all",
            "none"
          ],
          "type": "string"
        },
        "encodings": {
          "description": "An array of encoding channels. The corresponding data field values\nmust match for a data tuple to fall within the selection.",
          "items": {
            "$ref": "#/definitions/SingleDefChannel"
          },
          "type": "array"
        },
        "fields": {
          "description": "An array of field names whose values must match for a data tuple to\nfall within the selection.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "nearest": {
          "description": "When true, an invisible voronoi diagram is computed to accelerate discrete\nselection. The data value _nearest_ the mouse cursor is added to the selection.\n\nSee the [nearest transform](nearest.html) documentation for more information.",
          "type": "boolean"
        },
        "on": {
          "$ref": "#/definitions/VgEventStream",
          "description": "A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection.\nFor interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters)."
        },
        "resolve": {
          "$ref": "#/definitions/SelectionResolution",
          "description": "With layered and multi-view displays, a strategy that determines how\nselections' data queries are resolved when applied in a filter transform,\nconditional encoding rule, or scale domain."
        }
      },
      "type": "object"
    },
    "SingleTimeUnit": {
      "anyOf": [
        {
          "$ref": "#/definitions/LocalSingleTimeUnit"
        },
        {
          "$ref": "#/definitions/UtcSingleTimeUnit"
        }
      ]
    },
    "SortField": {
      "additionalProperties": false,
      "properties": {
        "field": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/RepeatRef"
            }
          ],
          "description": "The data [field](field.html) to sort by.\n\n__Default value:__ If unspecified, defaults to the field specified in the outer data reference."
        },
        "op": {
          "$ref": "#/definitions/AggregateOp",
          "description": "An [aggregate operation](aggregate.html#ops) to perform on the field prior to sorting (e.g., `\"count\"`, `\"mean\"` and `\"median\"`).\nThis property is required in cases where the sort field and the data reference field do not match.\nThe input data objects will be aggregated, grouped by the encoded data field.\n\nFor a full list of operations, please see the documentation for [aggregate](aggregate.html#ops)."
        },
        "order": {
          "$ref": "#/definitions/SortOrder",
          "description": "The sort order. One of `\"ascending\"` (default) or `\"descending\"`."
        }
      },
      "required": [
        "op"
      ],
      "type": "object"
    },
    "SortOrder": {
      "enum": [
        "ascending",
        "descending",
        null
      ],
      "type": [
        "string",
        "null"
      ]
    },
    "StackOffset": {
      "enum": [
        "zero",
        "center",
        "normalize"
      ],
      "type": "string"
    },
    "StyleConfigIndex": {
      "additionalProperties": {
        "$ref": "#/definitions/VgMarkConfig"
      },
      "type": "object"
    },
    "TextConfig": {
      "additionalProperties": false,
      "properties": {
        "align": {
          "$ref": "#/definitions/HorizontalAlign",
          "description": "The horizontal alignment of the text. One of `\"left\"`, `\"right\"`, `\"center\"`."
        },
        "angle": {
          "description": "The rotation angle of the text, in degrees.",
          "maximum": 360,
          "minimum": 0,
          "type": "number"
        },
        "baseline": {
          "$ref": "#/definitions/VerticalAlign",
          "description": "The vertical alignment of the text. One of `\"top\"`, `\"middle\"`, `\"bottom\"`.\n\n__Default value:__ `\"middle\"`"
        },
        "color": {
          "description": "Default color.  Note that `fill` and `stroke` have higher precedence than `color` and will override `color`.\n\n__Default value:__ <span style=\"color: #4682b4;\">&#9632;</span> `\"#4682b4\"`\n\n__Note:__ This property cannot be used in a [style config](mark.html#style-config).",
          "type": "string"
        },
        "cursor": {
          "description": "The mouse cursor used over the mark. Any valid [CSS cursor type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.",
          "enum": [
            "auto",
            "default",
            "none",
            "context-menu",
            "help",
            "pointer",
            "progress",
            "wait",
            "cell",
            "crosshair",
            "text",
            "vertical-text",
            "alias",
            "copy",
            "move",
            "no-drop",
            "not-allowed",
            "e-resize",
            "n-resize",
            "ne-resize",
            "nw-resize",
            "s-resize",
            "se-resize",
            "sw-resize",
            "w-resize",
            "ew-resize",
            "ns-resize",
            "nesw-resize",
            "nwse-resize",
            "col-resize",
            "row-resize",
            "all-scroll",
            "zoom-in",
            "zoom-out",
            "grab",
            "grabbing"
          ],
          "type": "string"
        },
        "dx": {
          "description": "The horizontal offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.",
          "type": "number"
        },
        "dy": {
          "description": "The vertical offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.",
          "type": "number"
        },
        "fill": {
          "description": "Default Fill Color.  This has higher precedence than config.color\n\n__Default value:__ (None)",
          "type": "string"
        },
        "fillOpacity": {
          "description": "The fill opacity (value between [0,1]).\n\n__Default value:__ `1`",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "filled": {
          "description": "Whether the mark's color should be used as fill color instead of stroke color.\n\n__Default value:__ `true` for all marks except `point` and `false` for `point`.\n\n__Applicable for:__ `bar`, `point`, `circle`, `square`, and `area` marks.\n\n__Note:__ This property cannot be used in a [style config](mark.html#style-config).",
          "type": "boolean"
        },
        "font": {
          "description": "The typeface to set the text in (e.g., `\"Helvetica Neue\"`).",
          "type": "string"
        },
        "fontSize": {
          "description": "The font size, in pixels.",
          "minimum": 0,
          "type": "number"
        },
        "fontStyle": {
          "$ref": "#/definitions/FontStyle",
          "description": "The font style (e.g., `\"italic\"`)."
        },
        "fontWeight": {
          "anyOf": [
            {
              "$ref": "#/definitions/FontWeight"
            },
            {
              "$ref": "#/definitions/FontWeightNumber"
            }
          ],
          "description": "The font weight (e.g., `\"bold\"`)."
        },
        "href": {
          "description": "A URL to load upon mouse click. If defined, the mark acts as a hyperlink.",
          "format": "uri",
          "type": "string"
        },
        "interpolate": {
          "$ref": "#/definitions/Interpolate",
          "description": "The line interpolation method to use for line and area marks. One of the following:\n- `\"linear\"`: piecewise linear segments, as in a polyline.\n- `\"linear-closed\"`: close the linear segments to form a polygon.\n- `\"step\"`: alternate between horizontal and vertical segments, as in a step function.\n- `\"step-before\"`: alternate between vertical and horizontal segments, as in a step function.\n- `\"step-after\"`: alternate between horizontal and vertical segments, as in a step function.\n- `\"basis\"`: a B-spline, with control point duplication on the ends.\n- `\"basis-open\"`: an open B-spline; may not intersect the start or end.\n- `\"basis-closed\"`: a closed B-spline, as in a loop.\n- `\"cardinal\"`: a Cardinal spline, with control point duplication on the ends.\n- `\"cardinal-open\"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.\n- `\"cardinal-closed\"`: a closed Cardinal spline, as in a loop.\n- `\"bundle\"`: equivalent to basis, except the tension parameter is used to straighten the spline.\n- `\"monotone\"`: cubic interpolation that preserves monotonicity in y."
        },
        "limit": {
          "description": "The maximum length of the text mark in pixels (default 0, indicating no limit). The text value will be automatically truncated if the rendered size exceeds the limit.",
          "type": "number"
        },
        "opacity": {
          "description": "The overall opacity (value between [0,1]).\n\n__Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "orient": {
          "$ref": "#/definitions/Orient",
          "description": "The orientation of a non-stacked bar, tick, area, and line charts.\nThe value is either horizontal (default) or vertical.\n- For bar, rule and tick, this determines whether the size of the bar and tick\nshould be applied to x or y dimension.\n- For area, this property determines the orient property of the Vega output.\n- For line, this property determines the sort order of the points in the line\nif `config.sortLineBy` is not specified.\nFor stacked charts, this is always determined by the orientation of the stack;\ntherefore explicitly specified value will be ignored."
        },
        "radius": {
          "description": "Polar coordinate radial offset, in pixels, of the text label from the origin determined by the `x` and `y` properties.",
          "minimum": 0,
          "type": "number"
        },
        "shape": {
          "description": "The default symbol shape to use. One of: `\"circle\"` (default), `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`, or `\"triangle-down\"`, or a custom SVG path.\n\n__Default value:__ `\"circle\"`",
          "type": "string"
        },
        "shortTimeLabels": {
          "description": "Whether month names and weekday names should be abbreviated.",
          "type": "boolean"
        },
        "size": {
          "description": "The pixel area each the point/circle/square.\nFor example: in the case of circles, the radius is determined in part by the square root of the size value.\n\n__Default value:__ `30`",
          "minimum": 0,
          "type": "number"
        },
        "stroke": {
          "description": "Default Stroke Color.  This has higher precedence than config.color\n\n__Default value:__ (None)",
          "type": "string"
        },
        "strokeDash": {
          "description": "An array of alternating stroke, space lengths for creating dashed or dotted lines.",
          "items": {
            "type": "number"
          },
          "type": "array"
        },
        "strokeDashOffset": {
          "description": "The offset (in pixels) into which to begin drawing with the stroke dash array.",
          "type": "number"
        },
        "strokeOpacity": {
          "description": "The stroke opacity (value between [0,1]).\n\n__Default value:__ `1`",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "strokeWidth": {
          "description": "The stroke width, in pixels.",
          "minimum": 0,
          "type": "number"
        },
        "tension": {
          "description": "Depending on the interpolation type, sets the tension parameter (for line and area marks).",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "text": {
          "description": "Placeholder text if the `text` channel is not specified",
          "type": "string"
        },
        "theta": {
          "description": "Polar coordinate angle, in radians, of the text label from the origin determined by the `x` and `y` properties. Values for `theta` follow the same convention of `arc` mark `startAngle` and `endAngle` properties: angles are measured in radians, with `0` indicating \"north\".",
          "type": "number"
        }
      },
      "type": "object"
    },
    "TickConfig": {
      "additionalProperties": false,
      "properties": {
        "align": {
          "$ref": "#/definitions/HorizontalAlign",
          "description": "The horizontal alignment of the text. One of `\"left\"`, `\"right\"`, `\"center\"`."
        },
        "angle": {
          "description": "The rotation angle of the text, in degrees.",
          "maximum": 360,
          "minimum": 0,
          "type": "number"
        },
        "bandSize": {
          "description": "The width of the ticks.\n\n__Default value:__  2/3 of rangeStep.",
          "minimum": 0,
          "type": "number"
        },
        "baseline": {
          "$ref": "#/definitions/VerticalAlign",
          "description": "The vertical alignment of the text. One of `\"top\"`, `\"middle\"`, `\"bottom\"`.\n\n__Default value:__ `\"middle\"`"
        },
        "color": {
          "description": "Default color.  Note that `fill` and `stroke` have higher precedence than `color` and will override `color`.\n\n__Default value:__ <span style=\"color: #4682b4;\">&#9632;</span> `\"#4682b4\"`\n\n__Note:__ This property cannot be used in a [style config](mark.html#style-config).",
          "type": "string"
        },
        "cursor": {
          "description": "The mouse cursor used over the mark. Any valid [CSS cursor type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.",
          "enum": [
            "auto",
            "default",
            "none",
            "context-menu",
            "help",
            "pointer",
            "progress",
            "wait",
            "cell",
            "crosshair",
            "text",
            "vertical-text",
            "alias",
            "copy",
            "move",
            "no-drop",
            "not-allowed",
            "e-resize",
            "n-resize",
            "ne-resize",
            "nw-resize",
            "s-resize",
            "se-resize",
            "sw-resize",
            "w-resize",
            "ew-resize",
            "ns-resize",
            "nesw-resize",
            "nwse-resize",
            "col-resize",
            "row-resize",
            "all-scroll",
            "zoom-in",
            "zoom-out",
            "grab",
            "grabbing"
          ],
          "type": "string"
        },
        "dx": {
          "description": "The horizontal offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.",
          "type": "number"
        },
        "dy": {
          "description": "The vertical offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.",
          "type": "number"
        },
        "fill": {
          "description": "Default Fill Color.  This has higher precedence than config.color\n\n__Default value:__ (None)",
          "type": "string"
        },
        "fillOpacity": {
          "description": "The fill opacity (value between [0,1]).\n\n__Default value:__ `1`",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "filled": {
          "description": "Whether the mark's color should be used as fill color instead of stroke color.\n\n__Default value:__ `true` for all marks except `point` and `false` for `point`.\n\n__Applicable for:__ `bar`, `point`, `circle`, `square`, and `area` marks.\n\n__Note:__ This property cannot be used in a [style config](mark.html#style-config).",
          "type": "boolean"
        },
        "font": {
          "description": "The typeface to set the text in (e.g., `\"Helvetica Neue\"`).",
          "type": "string"
        },
        "fontSize": {
          "description": "The font size, in pixels.",
          "minimum": 0,
          "type": "number"
        },
        "fontStyle": {
          "$ref": "#/definitions/FontStyle",
          "description": "The font style (e.g., `\"italic\"`)."
        },
        "fontWeight": {
          "anyOf": [
            {
              "$ref": "#/definitions/FontWeight"
            },
            {
              "$ref": "#/definitions/FontWeightNumber"
            }
          ],
          "description": "The font weight (e.g., `\"bold\"`)."
        },
        "href": {
          "description": "A URL to load upon mouse click. If defined, the mark acts as a hyperlink.",
          "format": "uri",
          "type": "string"
        },
        "interpolate": {
          "$ref": "#/definitions/Interpolate",
          "description": "The line interpolation method to use for line and area marks. One of the following:\n- `\"linear\"`: piecewise linear segments, as in a polyline.\n- `\"linear-closed\"`: close the linear segments to form a polygon.\n- `\"step\"`: alternate between horizontal and vertical segments, as in a step function.\n- `\"step-before\"`: alternate between vertical and horizontal segments, as in a step function.\n- `\"step-after\"`: alternate between horizontal and vertical segments, as in a step function.\n- `\"basis\"`: a B-spline, with control point duplication on the ends.\n- `\"basis-open\"`: an open B-spline; may not intersect the start or end.\n- `\"basis-closed\"`: a closed B-spline, as in a loop.\n- `\"cardinal\"`: a Cardinal spline, with control point duplication on the ends.\n- `\"cardinal-open\"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.\n- `\"cardinal-closed\"`: a closed Cardinal spline, as in a loop.\n- `\"bundle\"`: equivalent to basis, except the tension parameter is used to straighten the spline.\n- `\"monotone\"`: cubic interpolation that preserves monotonicity in y."
        },
        "limit": {
          "description": "The maximum length of the text mark in pixels (default 0, indicating no limit). The text value will be automatically truncated if the rendered size exceeds the limit.",
          "type": "number"
        },
        "opacity": {
          "description": "The overall opacity (value between [0,1]).\n\n__Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "orient": {
          "$ref": "#/definitions/Orient",
          "description": "The orientation of a non-stacked bar, tick, area, and line charts.\nThe value is either horizontal (default) or vertical.\n- For bar, rule and tick, this determines whether the size of the bar and tick\nshould be applied to x or y dimension.\n- For area, this property determines the orient property of the Vega output.\n- For line, this property determines the sort order of the points in the line\nif `config.sortLineBy` is not specified.\nFor stacked charts, this is always determined by the orientation of the stack;\ntherefore explicitly specified value will be ignored."
        },
        "radius": {
          "description": "Polar coordinate radial offset, in pixels, of the text label from the origin determined by the `x` and `y` properties.",
          "minimum": 0,
          "type": "number"
        },
        "shape": {
          "description": "The default symbol shape to use. One of: `\"circle\"` (default), `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`, or `\"triangle-down\"`, or a custom SVG path.\n\n__Default value:__ `\"circle\"`",
          "type": "string"
        },
        "size": {
          "description": "The pixel area each the point/circle/square.\nFor example: in the case of circles, the radius is determined in part by the square root of the size value.\n\n__Default value:__ `30`",
          "minimum": 0,
          "type": "number"
        },
        "stroke": {
          "description": "Default Stroke Color.  This has higher precedence than config.color\n\n__Default value:__ (None)",
          "type": "string"
        },
        "strokeDash": {
          "description": "An array of alternating stroke, space lengths for creating dashed or dotted lines.",
          "items": {
            "type": "number"
          },
          "type": "array"
        },
        "strokeDashOffset": {
          "description": "The offset (in pixels) into which to begin drawing with the stroke dash array.",
          "type": "number"
        },
        "strokeOpacity": {
          "description": "The stroke opacity (value between [0,1]).\n\n__Default value:__ `1`",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "strokeWidth": {
          "description": "The stroke width, in pixels.",
          "minimum": 0,
          "type": "number"
        },
        "tension": {
          "description": "Depending on the interpolation type, sets the tension parameter (for line and area marks).",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "text": {
          "description": "Placeholder text if the `text` channel is not specified",
          "type": "string"
        },
        "theta": {
          "description": "Polar coordinate angle, in radians, of the text label from the origin determined by the `x` and `y` properties. Values for `theta` follow the same convention of `arc` mark `startAngle` and `endAngle` properties: angles are measured in radians, with `0` indicating \"north\".",
          "type": "number"
        },
        "thickness": {
          "description": "Thickness of the tick mark.\n\n__Default value:__  `1`",
          "minimum": 0,
          "type": "number"
        }
      },
      "type": "object"
    },
    "TimeUnit": {
      "anyOf": [
        {
          "$ref": "#/definitions/SingleTimeUnit"
        },
        {
          "$ref": "#/definitions/MultiTimeUnit"
        }
      ]
    },
    "TimeUnitTransform": {
      "additionalProperties": false,
      "properties": {
        "as": {
          "description": "The output field to write the timeUnit value.",
          "type": "string"
        },
        "field": {
          "description": "The data field to apply time unit.",
          "type": "string"
        },
        "timeUnit": {
          "$ref": "#/definitions/TimeUnit",
          "description": "The timeUnit."
        }
      },
      "required": [
        "timeUnit",
        "field",
        "as"
      ],
      "type": "object"
    },
    "TitleOrient": {
      "enum": [
        "top",
        "bottom",
        "left",
        "right"
      ],
      "type": "string"
    },
    "TitleParams": {
      "additionalProperties": false,
      "properties": {
        "anchor": {
          "$ref": "#/definitions/Anchor",
          "description": "The anchor position for placing the title. One of `\"start\"`, `\"middle\"`, or `\"end\"`. For example, with an orientation of top these anchor positions map to a left-, center-, or right-aligned title.\n\n__Default value:__ `\"middle\"` for [single](spec.html) and [layered](layer.html) views.\n`\"start\"` for other composite views.\n\n__Note:__ [For now](https://github.com/vega/vega-lite/issues/2875), `anchor` is only customizable only for [single](spec.html) and [layered](layer.html) views.  For other composite views, `anchor` is always `\"start\"`."
        },
        "offset": {
          "description": "The orthogonal offset in pixels by which to displace the title from its position along the edge of the chart.",
          "type": "number"
        },
        "orient": {
          "$ref": "#/definitions/TitleOrient",
          "description": "The orientation of the title relative to the chart. One of `\"top\"` (the default), `\"bottom\"`, `\"left\"`, or `\"right\"`."
        },
        "style": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            }
          ],
          "description": "A [mark style property](config.html#style) to apply to the title text mark.\n\n__Default value:__ `\"group-title\"`."
        },
        "text": {
          "description": "The title text.",
          "type": "string"
        }
      },
      "required": [
        "text"
      ],
      "type": "object"
    },
    "TopLevel<FacetedUnitSpec>": {
      "additionalProperties": false,
      "properties": {
        "$schema": {
          "description": "URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v2.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema.",
          "format": "uri",
          "type": "string"
        },
        "autosize": {
          "anyOf": [
            {
              "$ref": "#/definitions/AutosizeType"
            },
            {
              "$ref": "#/definitions/AutoSizeParams"
            }
          ],
          "description": "Sets how the visualization size should be determined. If a string, should be one of `\"pad\"`, `\"fit\"` or `\"none\"`.\nObject values can additionally specify parameters for content sizing and automatic resizing.\n`\"fit\"` is only supported for single and layered views that don't use `rangeStep`.\n\n__Default value__: `pad`"
        },
        "background": {
          "description": "CSS color property to use as the background of visualization.\n\n__Default value:__ none (transparent)",
          "type": "string"
        },
        "config": {
          "$ref": "#/definitions/Config",
          "description": "Vega-Lite configuration object.  This property can only be defined at the top-level of a specification."
        },
        "data": {
          "$ref": "#/definitions/Data",
          "description": "An object describing the data source"
        },
        "description": {
          "description": "Description of this mark for commenting purpose.",
          "type": "string"
        },
        "encoding": {
          "$ref": "#/definitions/EncodingWithFacet",
          "description": "A key-value mapping between encoding channels and definition of fields."
        },
        "height": {
          "description": "The height of a visualization.\n\n__Default value:__\n- If a view's [`autosize`](size.html#autosize) type is `\"fit\"` or its y-channel has a [continuous scale](scale.html#continuous), the height will be the value of [`config.view.height`](spec.html#config).\n- For y-axis with a band or point scale: if [`rangeStep`](scale.html#band) is a numeric value or unspecified, the height is [determined by the range step, paddings, and the cardinality of the field mapped to y-channel](scale.html#band). Otherwise, if the `rangeStep` is `null`, the height will be the value of [`config.view.height`](spec.html#config).\n- If no field is mapped to `y` channel, the `height` will be the value of `rangeStep`.\n\n__Note__: For plots with [`row` and `column` channels](encoding.html#facet), this represents the height of a single view.\n\n__See also:__ The documentation for [width and height](size.html) contains more examples.",
          "type": "number"
        },
        "mark": {
          "$ref": "#/definitions/AnyMark",
          "description": "A string describing the mark type (one of `\"bar\"`, `\"circle\"`, `\"square\"`, `\"tick\"`, `\"line\"`,\n* `\"area\"`, `\"point\"`, `\"rule\"`, `\"geoshape\"`, and `\"text\"`) or a [mark definition object](mark.html#mark-def)."
        },
        "name": {
          "description": "Name of the visualization for later reference.",
          "type": "string"
        },
        "padding": {
          "$ref": "#/definitions/Padding",
          "description": "The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle.  If a number, specifies padding for all sides.\nIf an object, the value should have the format `{\"left\": 5, \"top\": 5, \"right\": 5, \"bottom\": 5}` to specify padding for each side of the visualization.\n\n__Default value__: `5`"
        },
        "projection": {
          "$ref": "#/definitions/Projection",
          "description": "An object defining properties of geographic projection.\n\nWorks with `\"geoshape\"` marks and `\"point\"` or `\"line\"` marks that have a channel (one or more of `\"X\"`, `\"X2\"`, `\"Y\"`, `\"Y2\"`) with type `\"latitude\"`, or `\"longitude\"`."
        },
        "selection": {
          "additionalProperties": {
            "$ref": "#/definitions/SelectionDef"
          },
          "description": "A key-value mapping between selection names and definitions.",
          "type": "object"
        },
        "title": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/TitleParams"
            }
          ],
          "description": "Title for the plot."
        },
        "transform": {
          "description": "An array of data transformations such as filter and new field calculation.",
          "items": {
            "$ref": "#/definitions/Transform"
          },
          "type": "array"
        },
        "width": {
          "description": "The width of a visualization.\n\n__Default value:__ This will be determined by the following rules:\n\n- If a view's [`autosize`](size.html#autosize) type is `\"fit\"` or its x-channel has a [continuous scale](scale.html#continuous), the width will be the value of [`config.view.width`](spec.html#config).\n- For x-axis with a band or point scale: if [`rangeStep`](scale.html#band) is a numeric value or unspecified, the width is [determined by the range step, paddings, and the cardinality of the field mapped to x-channel](scale.html#band).   Otherwise, if the `rangeStep` is `null`, the width will be the value of [`config.view.width`](spec.html#config).\n- If no field is mapped to `x` channel, the `width` will be the value of [`config.scale.textXRangeStep`](size.html#default-width-and-height) for `text` mark and the value of `rangeStep` for other marks.\n\n__Note:__ For plots with [`row` and `column` channels](encoding.html#facet), this represents the width of a single view.\n\n__See also:__ The documentation for [width and height](size.html) contains more examples.",
          "type": "number"
        }
      },
      "required": [
        "encoding",
        "mark"
      ],
      "type": "object"
    },
    "TopLevel<FacetSpec>": {
      "additionalProperties": false,
      "properties": {
        "$schema": {
          "description": "URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v2.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema.",
          "format": "uri",
          "type": "string"
        },
        "autosize": {
          "anyOf": [
            {
              "$ref": "#/definitions/AutosizeType"
            },
            {
              "$ref": "#/definitions/AutoSizeParams"
            }
          ],
          "description": "Sets how the visualization size should be determined. If a string, should be one of `\"pad\"`, `\"fit\"` or `\"none\"`.\nObject values can additionally specify parameters for content sizing and automatic resizing.\n`\"fit\"` is only supported for single and layered views that don't use `rangeStep`.\n\n__Default value__: `pad`"
        },
        "background": {
          "description": "CSS color property to use as the background of visualization.\n\n__Default value:__ none (transparent)",
          "type": "string"
        },
        "config": {
          "$ref": "#/definitions/Config",
          "description": "Vega-Lite configuration object.  This property can only be defined at the top-level of a specification."
        },
        "data": {
          "$ref": "#/definitions/Data",
          "description": "An object describing the data source"
        },
        "description": {
          "description": "Description of this mark for commenting purpose.",
          "type": "string"
        },
        "facet": {
          "$ref": "#/definitions/FacetMapping",
          "description": "An object that describes mappings between `row` and `column` channels and their field definitions."
        },
        "name": {
          "description": "Name of the visualization for later reference.",
          "type": "string"
        },
        "padding": {
          "$ref": "#/definitions/Padding",
          "description": "The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle.  If a number, specifies padding for all sides.\nIf an object, the value should have the format `{\"left\": 5, \"top\": 5, \"right\": 5, \"bottom\": 5}` to specify padding for each side of the visualization.\n\n__Default value__: `5`"
        },
        "resolve": {
          "$ref": "#/definitions/Resolve",
          "description": "Scale, axis, and legend resolutions for facets."
        },
        "spec": {
          "anyOf": [
            {
              "$ref": "#/definitions/LayerSpec"
            },
            {
              "$ref": "#/definitions/CompositeUnitSpec"
            }
          ],
          "description": "A specification of the view that gets faceted."
        },
        "title": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/TitleParams"
            }
          ],
          "description": "Title for the plot."
        },
        "transform": {
          "description": "An array of data transformations such as filter and new field calculation.",
          "items": {
            "$ref": "#/definitions/Transform"
          },
          "type": "array"
        }
      },
      "required": [
        "facet",
        "spec"
      ],
      "type": "object"
    },
    "TopLevel<HConcatSpec>": {
      "additionalProperties": false,
      "properties": {
        "$schema": {
          "description": "URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v2.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema.",
          "format": "uri",
          "type": "string"
        },
        "autosize": {
          "anyOf": [
            {
              "$ref": "#/definitions/AutosizeType"
            },
            {
              "$ref": "#/definitions/AutoSizeParams"
            }
          ],
          "description": "Sets how the visualization size should be determined. If a string, should be one of `\"pad\"`, `\"fit\"` or `\"none\"`.\nObject values can additionally specify parameters for content sizing and automatic resizing.\n`\"fit\"` is only supported for single and layered views that don't use `rangeStep`.\n\n__Default value__: `pad`"
        },
        "background": {
          "description": "CSS color property to use as the background of visualization.\n\n__Default value:__ none (transparent)",
          "type": "string"
        },
        "config": {
          "$ref": "#/definitions/Config",
          "description": "Vega-Lite configuration object.  This property can only be defined at the top-level of a specification."
        },
        "data": {
          "$ref": "#/definitions/Data",
          "description": "An object describing the data source"
        },
        "description": {
          "description": "Description of this mark for commenting purpose.",
          "type": "string"
        },
        "hconcat": {
          "description": "A list of views that should be concatenated and put into a row.",
          "items": {
            "$ref": "#/definitions/Spec"
          },
          "type": "array"
        },
        "name": {
          "description": "Name of the visualization for later reference.",
          "type": "string"
        },
        "padding": {
          "$ref": "#/definitions/Padding",
          "description": "The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle.  If a number, specifies padding for all sides.\nIf an object, the value should have the format `{\"left\": 5, \"top\": 5, \"right\": 5, \"bottom\": 5}` to specify padding for each side of the visualization.\n\n__Default value__: `5`"
        },
        "resolve": {
          "$ref": "#/definitions/Resolve",
          "description": "Scale, axis, and legend resolutions for horizontally concatenated charts."
        },
        "title": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/TitleParams"
            }
          ],
          "description": "Title for the plot."
        },
        "transform": {
          "description": "An array of data transformations such as filter and new field calculation.",
          "items": {
            "$ref": "#/definitions/Transform"
          },
          "type": "array"
        }
      },
      "required": [
        "hconcat"
      ],
      "type": "object"
    },
    "TopLevel<LayerSpec>": {
      "additionalProperties": false,
      "properties": {
        "$schema": {
          "description": "URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v2.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema.",
          "format": "uri",
          "type": "string"
        },
        "autosize": {
          "anyOf": [
            {
              "$ref": "#/definitions/AutosizeType"
            },
            {
              "$ref": "#/definitions/AutoSizeParams"
            }
          ],
          "description": "Sets how the visualization size should be determined. If a string, should be one of `\"pad\"`, `\"fit\"` or `\"none\"`.\nObject values can additionally specify parameters for content sizing and automatic resizing.\n`\"fit\"` is only supported for single and layered views that don't use `rangeStep`.\n\n__Default value__: `pad`"
        },
        "background": {
          "description": "CSS color property to use as the background of visualization.\n\n__Default value:__ none (transparent)",
          "type": "string"
        },
        "config": {
          "$ref": "#/definitions/Config",
          "description": "Vega-Lite configuration object.  This property can only be defined at the top-level of a specification."
        },
        "data": {
          "$ref": "#/definitions/Data",
          "description": "An object describing the data source"
        },
        "description": {
          "description": "Description of this mark for commenting purpose.",
          "type": "string"
        },
        "height": {
          "description": "The height of a visualization.\n\n__Default value:__\n- If a view's [`autosize`](size.html#autosize) type is `\"fit\"` or its y-channel has a [continuous scale](scale.html#continuous), the height will be the value of [`config.view.height`](spec.html#config).\n- For y-axis with a band or point scale: if [`rangeStep`](scale.html#band) is a numeric value or unspecified, the height is [determined by the range step, paddings, and the cardinality of the field mapped to y-channel](scale.html#band). Otherwise, if the `rangeStep` is `null`, the height will be the value of [`config.view.height`](spec.html#config).\n- If no field is mapped to `y` channel, the `height` will be the value of `rangeStep`.\n\n__Note__: For plots with [`row` and `column` channels](encoding.html#facet), this represents the height of a single view.\n\n__See also:__ The documentation for [width and height](size.html) contains more examples.",
          "type": "number"
        },
        "layer": {
          "description": "Layer or single view specifications to be layered.\n\n__Note__: Specifications inside `layer` cannot use `row` and `column` channels as layering facet specifications is not allowed.",
          "items": {
            "anyOf": [
              {
                "$ref": "#/definitions/LayerSpec"
              },
              {
                "$ref": "#/definitions/CompositeUnitSpec"
              }
            ]
          },
          "type": "array"
        },
        "name": {
          "description": "Name of the visualization for later reference.",
          "type": "string"
        },
        "padding": {
          "$ref": "#/definitions/Padding",
          "description": "The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle.  If a number, specifies padding for all sides.\nIf an object, the value should have the format `{\"left\": 5, \"top\": 5, \"right\": 5, \"bottom\": 5}` to specify padding for each side of the visualization.\n\n__Default value__: `5`"
        },
        "resolve": {
          "$ref": "#/definitions/Resolve",
          "description": "Scale, axis, and legend resolutions for layers."
        },
        "title": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/TitleParams"
            }
          ],
          "description": "Title for the plot."
        },
        "transform": {
          "description": "An array of data transformations such as filter and new field calculation.",
          "items": {
            "$ref": "#/definitions/Transform"
          },
          "type": "array"
        },
        "width": {
          "description": "The width of a visualization.\n\n__Default value:__ This will be determined by the following rules:\n\n- If a view's [`autosize`](size.html#autosize) type is `\"fit\"` or its x-channel has a [continuous scale](scale.html#continuous), the width will be the value of [`config.view.width`](spec.html#config).\n- For x-axis with a band or point scale: if [`rangeStep`](scale.html#band) is a numeric value or unspecified, the width is [determined by the range step, paddings, and the cardinality of the field mapped to x-channel](scale.html#band).   Otherwise, if the `rangeStep` is `null`, the width will be the value of [`config.view.width`](spec.html#config).\n- If no field is mapped to `x` channel, the `width` will be the value of [`config.scale.textXRangeStep`](size.html#default-width-and-height) for `text` mark and the value of `rangeStep` for other marks.\n\n__Note:__ For plots with [`row` and `column` channels](encoding.html#facet), this represents the width of a single view.\n\n__See also:__ The documentation for [width and height](size.html) contains more examples.",
          "type": "number"
        }
      },
      "required": [
        "layer"
      ],
      "type": "object"
    },
    "TopLevel<RepeatSpec>": {
      "additionalProperties": false,
      "properties": {
        "$schema": {
          "description": "URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v2.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema.",
          "format": "uri",
          "type": "string"
        },
        "autosize": {
          "anyOf": [
            {
              "$ref": "#/definitions/AutosizeType"
            },
            {
              "$ref": "#/definitions/AutoSizeParams"
            }
          ],
          "description": "Sets how the visualization size should be determined. If a string, should be one of `\"pad\"`, `\"fit\"` or `\"none\"`.\nObject values can additionally specify parameters for content sizing and automatic resizing.\n`\"fit\"` is only supported for single and layered views that don't use `rangeStep`.\n\n__Default value__: `pad`"
        },
        "background": {
          "description": "CSS color property to use as the background of visualization.\n\n__Default value:__ none (transparent)",
          "type": "string"
        },
        "config": {
          "$ref": "#/definitions/Config",
          "description": "Vega-Lite configuration object.  This property can only be defined at the top-level of a specification."
        },
        "data": {
          "$ref": "#/definitions/Data",
          "description": "An object describing the data source"
        },
        "description": {
          "description": "Description of this mark for commenting purpose.",
          "type": "string"
        },
        "name": {
          "description": "Name of the visualization for later reference.",
          "type": "string"
        },
        "padding": {
          "$ref": "#/definitions/Padding",
          "description": "The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle.  If a number, specifies padding for all sides.\nIf an object, the value should have the format `{\"left\": 5, \"top\": 5, \"right\": 5, \"bottom\": 5}` to specify padding for each side of the visualization.\n\n__Default value__: `5`"
        },
        "repeat": {
          "$ref": "#/definitions/Repeat",
          "description": "An object that describes what fields should be repeated into views that are laid out as a `row` or `column`."
        },
        "resolve": {
          "$ref": "#/definitions/Resolve",
          "description": "Scale and legend resolutions for repeated charts."
        },
        "spec": {
          "$ref": "#/definitions/Spec"
        },
        "title": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/TitleParams"
            }
          ],
          "description": "Title for the plot."
        },
        "transform": {
          "description": "An array of data transformations such as filter and new field calculation.",
          "items": {
            "$ref": "#/definitions/Transform"
          },
          "type": "array"
        }
      },
      "required": [
        "repeat",
        "spec"
      ],
      "type": "object"
    },
    "TopLevel<VConcatSpec>": {
      "additionalProperties": false,
      "properties": {
        "$schema": {
          "description": "URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v2.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema.",
          "format": "uri",
          "type": "string"
        },
        "autosize": {
          "anyOf": [
            {
              "$ref": "#/definitions/AutosizeType"
            },
            {
              "$ref": "#/definitions/AutoSizeParams"
            }
          ],
          "description": "Sets how the visualization size should be determined. If a string, should be one of `\"pad\"`, `\"fit\"` or `\"none\"`.\nObject values can additionally specify parameters for content sizing and automatic resizing.\n`\"fit\"` is only supported for single and layered views that don't use `rangeStep`.\n\n__Default value__: `pad`"
        },
        "background": {
          "description": "CSS color property to use as the background of visualization.\n\n__Default value:__ none (transparent)",
          "type": "string"
        },
        "config": {
          "$ref": "#/definitions/Config",
          "description": "Vega-Lite configuration object.  This property can only be defined at the top-level of a specification."
        },
        "data": {
          "$ref": "#/definitions/Data",
          "description": "An object describing the data source"
        },
        "description": {
          "description": "Description of this mark for commenting purpose.",
          "type": "string"
        },
        "name": {
          "description": "Name of the visualization for later reference.",
          "type": "string"
        },
        "padding": {
          "$ref": "#/definitions/Padding",
          "description": "The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle.  If a number, specifies padding for all sides.\nIf an object, the value should have the format `{\"left\": 5, \"top\": 5, \"right\": 5, \"bottom\": 5}` to specify padding for each side of the visualization.\n\n__Default value__: `5`"
        },
        "resolve": {
          "$ref": "#/definitions/Resolve",
          "description": "Scale, axis, and legend resolutions for vertically concatenated charts."
        },
        "title": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/TitleParams"
            }
          ],
          "description": "Title for the plot."
        },
        "transform": {
          "description": "An array of data transformations such as filter and new field calculation.",
          "items": {
            "$ref": "#/definitions/Transform"
          },
          "type": "array"
        },
        "vconcat": {
          "description": "A list of views that should be concatenated and put into a column.",
          "items": {
            "$ref": "#/definitions/Spec"
          },
          "type": "array"
        }
      },
      "required": [
        "vconcat"
      ],
      "type": "object"
    },
    "TopLevelExtendedSpec": {
      "anyOf": [
        {
          "$ref": "#/definitions/TopLevel<FacetedUnitSpec>"
        },
        {
          "$ref": "#/definitions/TopLevel<LayerSpec>"
        },
        {
          "$ref": "#/definitions/TopLevel<FacetSpec>"
        },
        {
          "$ref": "#/definitions/TopLevel<RepeatSpec>"
        },
        {
          "$ref": "#/definitions/TopLevel<VConcatSpec>"
        },
        {
          "$ref": "#/definitions/TopLevel<HConcatSpec>"
        }
      ]
    },
    "TopoDataFormat": {
      "additionalProperties": false,
      "properties": {
        "feature": {
          "description": "The name of the TopoJSON object set to convert to a GeoJSON feature collection.\nFor example, in a map of the world, there may be an object set named `\"countries\"`.\nUsing the feature property, we can extract this set and generate a GeoJSON feature object for each country.",
          "type": "string"
        },
        "mesh": {
          "description": "The name of the TopoJSON object set to convert to mesh.\nSimilar to the `feature` option, `mesh` extracts a named TopoJSON object set.\n  Unlike the `feature` option, the corresponding geo data is returned as a single, unified mesh instance, not as individual GeoJSON features.\nExtracting a mesh is useful for more efficiently drawing borders or other geographic elements that you do not need to associate with specific regions such as individual countries, states or counties.",
          "type": "string"
        },
        "parse": {
          "anyOf": [
            {
              "enum": [
                "auto"
              ],
              "type": "string"
            },
            {
              "type": "object"
            }
          ],
          "description": "If set to auto (the default), perform automatic type inference to determine the desired data types.\nAlternatively, a parsing directive object can be provided for explicit data types. Each property of the object corresponds to a field name, and the value to the desired data type (one of `\"number\"`, `\"boolean\"` or `\"date\"`).\nFor example, `\"parse\": {\"modified_on\": \"date\"}` parses the `modified_on` field in each input record a Date value.\n\nFor `\"date\"`, we parse data based using Javascript's [`Date.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse).\nFor Specific date formats can be provided (e.g., `{foo: 'date:\"%m%d%Y\"'}`), using the [d3-time-format syntax](https://github.com/d3/d3-time-format#locale_format). UTC date format parsing is supported similarly (e.g., `{foo: 'utc:\"%m%d%Y\"'}`). See more about [UTC time](timeunit.html#utc)"
        },
        "type": {
          "description": "Type of input data: `\"json\"`, `\"csv\"`, `\"tsv\"`.\nThe default format type is determined by the extension of the file URL.\nIf no extension is detected, `\"json\"` will be used by default.",
          "enum": [
            "topojson"
          ],
          "type": "string"
        }
      },
      "type": "object"
    },
    "Transform": {
      "anyOf": [
        {
          "$ref": "#/definitions/FilterTransform"
        },
        {
          "$ref": "#/definitions/CalculateTransform"
        },
        {
          "$ref": "#/definitions/LookupTransform"
        },
        {
          "$ref": "#/definitions/BinTransform"
        },
        {
          "$ref": "#/definitions/TimeUnitTransform"
        },
        {
          "$ref": "#/definitions/AggregateTransform"
        }
      ]
    },
    "Type": {
      "anyOf": [
        {
          "$ref": "#/definitions/BasicType"
        },
        {
          "$ref": "#/definitions/GeoType"
        }
      ],
      "description": "Constants and utilities for data type  \n Data type based on level of measurement "
    },
    "UrlData": {
      "additionalProperties": false,
      "properties": {
        "format": {
          "$ref": "#/definitions/DataFormat",
          "description": "An object that specifies the format for parsing the data file."
        },
        "url": {
          "description": "An URL from which to load the data set. Use the `format.type` property\nto ensure the loaded data is correctly parsed.",
          "type": "string"
        }
      },
      "required": [
        "url"
      ],
      "type": "object"
    },
    "UtcMultiTimeUnit": {
      "enum": [
        "utcyearquarter",
        "utcyearquartermonth",
        "utcyearmonth",
        "utcyearmonthdate",
        "utcyearmonthdatehours",
        "utcyearmonthdatehoursminutes",
        "utcyearmonthdatehoursminutesseconds",
        "utcquartermonth",
        "utcmonthdate",
        "utchoursminutes",
        "utchoursminutesseconds",
        "utcminutesseconds",
        "utcsecondsmilliseconds"
      ],
      "type": "string"
    },
    "UtcSingleTimeUnit": {
      "enum": [
        "utcyear",
        "utcquarter",
        "utcmonth",
        "utcday",
        "utcdate",
        "utchours",
        "utcminutes",
        "utcseconds",
        "utcmilliseconds"
      ],
      "type": "string"
    },
    "ValueDef": {
      "additionalProperties": false,
      "description": "Definition object for a constant value of an encoding channel.",
      "properties": {
        "value": {
          "description": "A constant value in visual domain (e.g., `\"red\"` / \"#0099ff\" for color, values between `0` to `1` for opacity).",
          "type": [
            "number",
            "string",
            "boolean"
          ]
        }
      },
      "required": [
        "value"
      ],
      "type": "object"
    },
    "ValueDefWithCondition": {
      "additionalProperties": false,
      "description": "A ValueDef with Condition<ValueDef | FieldDef>\n{\n   condition: {field: ...} | {value: ...},\n   value: ...,\n}",
      "properties": {
        "condition": {
          "anyOf": [
            {
              "$ref": "#/definitions/Conditional<FieldDef>"
            },
            {
              "$ref": "#/definitions/Conditional<ValueDef>"
            },
            {
              "items": {
                "$ref": "#/definitions/Conditional<ValueDef>"
              },
              "type": "array"
            }
          ],
          "description": "A field definition or one or more value definition(s) with a selection predicate."
        },
        "value": {
          "description": "A constant value in visual domain.",
          "type": [
            "number",
            "string",
            "boolean"
          ]
        }
      },
      "type": "object"
    },
    "MarkPropValueDefWithCondition": {
      "additionalProperties": false,
      "description": "A ValueDef with Condition<ValueDef | FieldDef>\n{\n   condition: {field: ...} | {value: ...},\n   value: ...,\n}",
      "properties": {
        "condition": {
          "anyOf": [
            {
              "$ref": "#/definitions/Conditional<MarkPropFieldDef>"
            },
            {
              "$ref": "#/definitions/Conditional<ValueDef>"
            },
            {
              "items": {
                "$ref": "#/definitions/Conditional<ValueDef>"
              },
              "type": "array"
            }
          ],
          "description": "A field definition or one or more value definition(s) with a selection predicate."
        },
        "value": {
          "description": "A constant value in visual domain.",
          "type": [
            "number",
            "string",
            "boolean"
          ]
        }
      },
      "type": "object"
    },
    "TextValueDefWithCondition": {
      "additionalProperties": false,
      "description": "A ValueDef with Condition<ValueDef | FieldDef>\n{\n   condition: {field: ...} | {value: ...},\n   value: ...,\n}",
      "properties": {
        "condition": {
          "anyOf": [
            {
              "$ref": "#/definitions/Conditional<TextFieldDef>"
            },
            {
              "$ref": "#/definitions/Conditional<ValueDef>"
            },
            {
              "items": {
                "$ref": "#/definitions/Conditional<ValueDef>"
              },
              "type": "array"
            }
          ],
          "description": "A field definition or one or more value definition(s) with a selection predicate."
        },
        "value": {
          "description": "A constant value in visual domain.",
          "type": [
            "number",
            "string",
            "boolean"
          ]
        }
      },
      "type": "object"
    },
    "VerticalAlign": {
      "enum": [
        "top",
        "middle",
        "bottom"
      ],
      "type": "string"
    },
    "VgAxisConfig": {
      "additionalProperties": false,
      "properties": {
        "bandPosition": {
          "description": "An interpolation fraction indicating where, for `band` scales, axis ticks should be positioned. A value of `0` places ticks at the left edge of their bands. A value of `0.5` places ticks in the middle of their bands.",
          "type": "number"
        },
        "domain": {
          "description": "A boolean flag indicating if the domain (the axis baseline) should be included as part of the axis.\n\n__Default value:__ `true`",
          "type": "boolean"
        },
        "domainColor": {
          "description": "Color of axis domain line.\n\n__Default value:__  (none, using Vega default).",
          "type": "string"
        },
        "domainWidth": {
          "description": "Stroke width of axis domain line\n\n__Default value:__  (none, using Vega default).",
          "type": "number"
        },
        "grid": {
          "description": "A boolean flag indicating if grid lines should be included as part of the axis\n\n__Default value:__ `true` for [continuous scales](scale.html#continuous) that are not binned; otherwise, `false`.",
          "type": "boolean"
        },
        "gridColor": {
          "description": "Color of gridlines.",
          "type": "string"
        },
        "gridDash": {
          "description": "The offset (in pixels) into which to begin drawing with the grid dash array.",
          "items": {
            "type": "number"
          },
          "type": "array"
        },
        "gridOpacity": {
          "description": "The stroke opacity of grid (value between [0,1])\n\n__Default value:__ (`1` by default)",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "gridWidth": {
          "description": "The grid width, in pixels.",
          "minimum": 0,
          "type": "number"
        },
        "labelAngle": {
          "description": "The rotation angle of the axis labels.\n\n__Default value:__ `-90` for nominal and ordinal fields; `0` otherwise.",
          "maximum": 360,
          "minimum": -360,
          "type": "number"
        },
        "labelBound": {
          "description": "Indicates if labels should be hidden if they exceed the axis range. If `false `(the default) no bounds overlap analysis is performed. If `true`, labels will be hidden if they exceed the axis range by more than 1 pixel. If this property is a number, it specifies the pixel tolerance: the maximum amount by which a label bounding box may exceed the axis range.\n\n__Default value:__ `false`.",
          "type": [
            "boolean",
            "number"
          ]
        },
        "labelColor": {
          "description": "The color of the tick label, can be in hex color code or regular color name.",
          "type": "string"
        },
        "labelFlush": {
          "description": "Indicates if the first and last axis labels should be aligned flush with the scale range. Flush alignment for a horizontal axis will left-align the first label and right-align the last label. For vertical axes, bottom and top text baselines are applied instead. If this property is a number, it also indicates the number of pixels by which to offset the first and last labels; for example, a value of 2 will flush-align the first and last labels and also push them 2 pixels outward from the center of the axis. The additional adjustment can sometimes help the labels better visually group with corresponding axis ticks.\n\n__Default value:__ `true` for axis of a continuous x-scale. Otherwise, `false`.",
          "type": [
            "boolean",
            "number"
          ]
        },
        "labelFont": {
          "description": "The font of the tick label.",
          "type": "string"
        },
        "labelFontSize": {
          "description": "The font size of the label, in pixels.",
          "minimum": 0,
          "type": "number"
        },
        "labelLimit": {
          "description": "Maximum allowed pixel width of axis tick labels.",
          "type": "number"
        },
        "labelOverlap": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "enum": [
                "parity"
              ],
              "type": "string"
            },
            {
              "enum": [
                "greedy"
              ],
              "type": "string"
            }
          ],
          "description": "The strategy to use for resolving overlap of axis labels. If `false` (the default), no overlap reduction is attempted. If set to `true` or `\"parity\"`, a strategy of removing every other label is used (this works well for standard linear axes). If set to `\"greedy\"`, a linear scan of the labels is performed, removing any labels that overlaps with the last visible label (this often works better for log-scaled axes).\n\n__Default value:__ `true` for non-nominal fields with non-log scales; `\"greedy\"` for log scales; otherwise `false`."
        },
        "labelPadding": {
          "description": "The padding, in pixels, between axis and text labels.",
          "type": "number"
        },
        "labels": {
          "description": "A boolean flag indicating if labels should be included as part of the axis.\n\n__Default value:__  `true`.",
          "type": "boolean"
        },
        "maxExtent": {
          "description": "The maximum extent in pixels that axis ticks and labels should use. This determines a maximum offset value for axis titles.\n\n__Default value:__ `undefined`.",
          "type": "number"
        },
        "minExtent": {
          "description": "The minimum extent in pixels that axis ticks and labels should use. This determines a minimum offset value for axis titles.\n\n__Default value:__ `30` for y-axis; `undefined` for x-axis.",
          "type": "number"
        },
        "tickColor": {
          "description": "The color of the axis's tick.",
          "type": "string"
        },
        "tickRound": {
          "description": "Boolean flag indicating if pixel position values should be rounded to the nearest integer.",
          "type": "boolean"
        },
        "tickSize": {
          "description": "The size in pixels of axis ticks.",
          "minimum": 0,
          "type": "number"
        },
        "tickWidth": {
          "description": "The width, in pixels, of ticks.",
          "minimum": 0,
          "type": "number"
        },
        "ticks": {
          "description": "Boolean value that determines whether the axis should include ticks.",
          "type": "boolean"
        },
        "titleAlign": {
          "description": "Horizontal text alignment of axis titles.",
          "type": "string"
        },
        "titleAngle": {
          "description": "Angle in degrees of axis titles.",
          "type": "number"
        },
        "titleBaseline": {
          "description": "Vertical text baseline for axis titles.",
          "type": "string"
        },
        "titleColor": {
          "description": "Color of the title, can be in hex color code or regular color name.",
          "type": "string"
        },
        "titleFont": {
          "description": "Font of the title. (e.g., `\"Helvetica Neue\"`).",
          "type": "string"
        },
        "titleFontSize": {
          "description": "Font size of the title.",
          "minimum": 0,
          "type": "number"
        },
        "titleFontWeight": {
          "description": "Font weight of the title. (e.g., `\"bold\"`).",
          "type": [
            "string",
            "number"
          ]
        },
        "titleLimit": {
          "description": "Maximum allowed pixel width of axis titles.",
          "type": "number"
        },
        "titleMaxLength": {
          "description": "Max length for axis title if the title is automatically generated from the field's description.",
          "type": "number"
        },
        "titlePadding": {
          "description": "The padding, in pixels, between title and axis.",
          "type": "number"
        },
        "titleX": {
          "description": "X-coordinate of the axis title relative to the axis group.",
          "type": "number"
        },
        "titleY": {
          "description": "Y-coordinate of the axis title relative to the axis group.",
          "type": "number"
        }
      },
      "type": "object"
    },
    "VgBinding": {
      "anyOf": [
        {
          "$ref": "#/definitions/VgCheckboxBinding"
        },
        {
          "$ref": "#/definitions/VgRadioBinding"
        },
        {
          "$ref": "#/definitions/VgSelectBinding"
        },
        {
          "$ref": "#/definitions/VgRangeBinding"
        },
        {
          "$ref": "#/definitions/VgGenericBinding"
        }
      ]
    },
    "VgCheckboxBinding": {
      "additionalProperties": false,
      "properties": {
        "element": {
          "type": "string"
        },
        "input": {
          "enum": [
            "checkbox"
          ],
          "type": "string"
        }
      },
      "required": [
        "input"
      ],
      "type": "object"
    },
    "VgEventStream": {
    },
    "VgGenericBinding": {
      "additionalProperties": false,
      "properties": {
        "element": {
          "type": "string"
        },
        "input": {
          "type": "string"
        }
      },
      "required": [
        "input"
      ],
      "type": "object"
    },
    "VgMarkConfig": {
      "additionalProperties": false,
      "properties": {
        "align": {
          "$ref": "#/definitions/HorizontalAlign",
          "description": "The horizontal alignment of the text. One of `\"left\"`, `\"right\"`, `\"center\"`."
        },
        "angle": {
          "description": "The rotation angle of the text, in degrees.",
          "maximum": 360,
          "minimum": 0,
          "type": "number"
        },
        "baseline": {
          "$ref": "#/definitions/VerticalAlign",
          "description": "The vertical alignment of the text. One of `\"top\"`, `\"middle\"`, `\"bottom\"`.\n\n__Default value:__ `\"middle\"`"
        },
        "cursor": {
          "description": "The mouse cursor used over the mark. Any valid [CSS cursor type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.",
          "enum": [
            "auto",
            "default",
            "none",
            "context-menu",
            "help",
            "pointer",
            "progress",
            "wait",
            "cell",
            "crosshair",
            "text",
            "vertical-text",
            "alias",
            "copy",
            "move",
            "no-drop",
            "not-allowed",
            "e-resize",
            "n-resize",
            "ne-resize",
            "nw-resize",
            "s-resize",
            "se-resize",
            "sw-resize",
            "w-resize",
            "ew-resize",
            "ns-resize",
            "nesw-resize",
            "nwse-resize",
            "col-resize",
            "row-resize",
            "all-scroll",
            "zoom-in",
            "zoom-out",
            "grab",
            "grabbing"
          ],
          "type": "string"
        },
        "dx": {
          "description": "The horizontal offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.",
          "type": "number"
        },
        "dy": {
          "description": "The vertical offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.",
          "type": "number"
        },
        "fill": {
          "description": "Default Fill Color.  This has higher precedence than config.color\n\n__Default value:__ (None)",
          "type": "string"
        },
        "fillOpacity": {
          "description": "The fill opacity (value between [0,1]).\n\n__Default value:__ `1`",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "font": {
          "description": "The typeface to set the text in (e.g., `\"Helvetica Neue\"`).",
          "type": "string"
        },
        "fontSize": {
          "description": "The font size, in pixels.",
          "minimum": 0,
          "type": "number"
        },
        "fontStyle": {
          "$ref": "#/definitions/FontStyle",
          "description": "The font style (e.g., `\"italic\"`)."
        },
        "fontWeight": {
          "anyOf": [
            {
              "$ref": "#/definitions/FontWeight"
            },
            {
              "$ref": "#/definitions/FontWeightNumber"
            }
          ],
          "description": "The font weight (e.g., `\"bold\"`)."
        },
        "href": {
          "description": "A URL to load upon mouse click. If defined, the mark acts as a hyperlink.",
          "format": "uri",
          "type": "string"
        },
        "interpolate": {
          "$ref": "#/definitions/Interpolate",
          "description": "The line interpolation method to use for line and area marks. One of the following:\n- `\"linear\"`: piecewise linear segments, as in a polyline.\n- `\"linear-closed\"`: close the linear segments to form a polygon.\n- `\"step\"`: alternate between horizontal and vertical segments, as in a step function.\n- `\"step-before\"`: alternate between vertical and horizontal segments, as in a step function.\n- `\"step-after\"`: alternate between horizontal and vertical segments, as in a step function.\n- `\"basis\"`: a B-spline, with control point duplication on the ends.\n- `\"basis-open\"`: an open B-spline; may not intersect the start or end.\n- `\"basis-closed\"`: a closed B-spline, as in a loop.\n- `\"cardinal\"`: a Cardinal spline, with control point duplication on the ends.\n- `\"cardinal-open\"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.\n- `\"cardinal-closed\"`: a closed Cardinal spline, as in a loop.\n- `\"bundle\"`: equivalent to basis, except the tension parameter is used to straighten the spline.\n- `\"monotone\"`: cubic interpolation that preserves monotonicity in y."
        },
        "limit": {
          "description": "The maximum length of the text mark in pixels (default 0, indicating no limit). The text value will be automatically truncated if the rendered size exceeds the limit.",
          "type": "number"
        },
        "opacity": {
          "description": "The overall opacity (value between [0,1]).\n\n__Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "orient": {
          "$ref": "#/definitions/Orient",
          "description": "The orientation of a non-stacked bar, tick, area, and line charts.\nThe value is either horizontal (default) or vertical.\n- For bar, rule and tick, this determines whether the size of the bar and tick\nshould be applied to x or y dimension.\n- For area, this property determines the orient property of the Vega output.\n- For line, this property determines the sort order of the points in the line\nif `config.sortLineBy` is not specified.\nFor stacked charts, this is always determined by the orientation of the stack;\ntherefore explicitly specified value will be ignored."
        },
        "radius": {
          "description": "Polar coordinate radial offset, in pixels, of the text label from the origin determined by the `x` and `y` properties.",
          "minimum": 0,
          "type": "number"
        },
        "shape": {
          "description": "The default symbol shape to use. One of: `\"circle\"` (default), `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`, or `\"triangle-down\"`, or a custom SVG path.\n\n__Default value:__ `\"circle\"`",
          "type": "string"
        },
        "size": {
          "description": "The pixel area each the point/circle/square.\nFor example: in the case of circles, the radius is determined in part by the square root of the size value.\n\n__Default value:__ `30`",
          "minimum": 0,
          "type": "number"
        },
        "stroke": {
          "description": "Default Stroke Color.  This has higher precedence than config.color\n\n__Default value:__ (None)",
          "type": "string"
        },
        "strokeDash": {
          "description": "An array of alternating stroke, space lengths for creating dashed or dotted lines.",
          "items": {
            "type": "number"
          },
          "type": "array"
        },
        "strokeDashOffset": {
          "description": "The offset (in pixels) into which to begin drawing with the stroke dash array.",
          "type": "number"
        },
        "strokeOpacity": {
          "description": "The stroke opacity (value between [0,1]).\n\n__Default value:__ `1`",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "strokeWidth": {
          "description": "The stroke width, in pixels.",
          "minimum": 0,
          "type": "number"
        },
        "tension": {
          "description": "Depending on the interpolation type, sets the tension parameter (for line and area marks).",
          "maximum": 1,
          "minimum": 0,
          "type": "number"
        },
        "text": {
          "description": "Placeholder text if the `text` channel is not specified",
          "type": "string"
        },
        "theta": {
          "description": "Polar coordinate angle, in radians, of the text label from the origin determined by the `x` and `y` properties. Values for `theta` follow the same convention of `arc` mark `startAngle` and `endAngle` properties: angles are measured in radians, with `0` indicating \"north\".",
          "type": "number"
        }
      },
      "type": "object"
    },
    "VgProjectionType": {
      "enum": [
        "albers",
        "albersUsa",
        "azimuthalEqualArea",
        "azimuthalEquidistant",
        "conicConformal",
        "conicEqualArea",
        "conicEquidistant",
        "equirectangular",
        "gnomonic",
        "mercator",
        "orthographic",
        "stereographic",
        "transverseMercator"
      ],
      "type": "string"
    },
    "VgRadioBinding": {
      "additionalProperties": false,
      "properties": {
        "element": {
          "type": "string"
        },
        "input": {
          "enum": [
            "radio"
          ],
          "type": "string"
        },
        "options": {
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "input",
        "options"
      ],
      "type": "object"
    },
    "VgRangeBinding": {
      "additionalProperties": false,
      "properties": {
        "element": {
          "type": "string"
        },
        "input": {
          "enum": [
            "range"
          ],
          "type": "string"
        },
        "max": {
          "type": "number"
        },
        "min": {
          "type": "number"
        },
        "step": {
          "type": "number"
        }
      },
      "required": [
        "input"
      ],
      "type": "object"
    },
    "VgScheme": {
      "additionalProperties": false,
      "properties": {
        "count": {
          "type": "number"
        },
        "extent": {
          "items": {
            "type": "number"
          },
          "type": "array"
        },
        "scheme": {
          "type": "string"
        }
      },
      "required": [
        "scheme"
      ],
      "type": "object"
    },
    "VgSelectBinding": {
      "additionalProperties": false,
      "properties": {
        "element": {
          "type": "string"
        },
        "input": {
          "enum": [
            "select"
          ],
          "type": "string"
        },
        "options": {
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "input",
        "options"
      ],
      "type": "object"
    },
    "VgTitleConfig": {
      "additionalProperties": false,
      "properties": {
        "anchor": {
          "$ref": "#/definitions/Anchor",
          "description": "The anchor position for placing the title. One of `\"start\"`, `\"middle\"`, or `\"end\"`. For example, with an orientation of top these anchor positions map to a left-, center-, or right-aligned title.\n\n__Default value:__ `\"middle\"` for [single](spec.html) and [layered](layer.html) views.\n`\"start\"` for other composite views.\n\n__Note:__ [For now](https://github.com/vega/vega-lite/issues/2875), `anchor` is only customizable only for [single](spec.html) and [layered](layer.html) views.  For other composite views, `anchor` is always `\"start\"`."
        },
        "angle": {
          "description": "Angle in degrees of title text.",
          "type": "number"
        },
        "baseline": {
          "$ref": "#/definitions/VerticalAlign",
          "description": "Vertical text baseline for title text."
        },
        "color": {
          "description": "Text color for title text.",
          "type": "string"
        },
        "font": {
          "description": "Font name for title text.",
          "type": "string"
        },
        "fontSize": {
          "description": "Font size in pixels for title text.\n\n__Default value:__ `10`.",
          "minimum": 0,
          "type": "number"
        },
        "fontWeight": {
          "anyOf": [
            {
              "$ref": "#/definitions/FontWeight"
            },
            {
              "$ref": "#/definitions/FontWeightNumber"
            }
          ],
          "description": "Font weight for title text."
        },
        "limit": {
          "description": "The maximum allowed length in pixels of legend labels.",
          "minimum": 0,
          "type": "number"
        },
        "offset": {
          "description": "Offset in pixels of the title from the chart body and axes.",
          "type": "number"
        },
        "orient": {
          "$ref": "#/definitions/TitleOrient",
          "description": "Default title orientation (\"top\", \"bottom\", \"left\", or \"right\")"
        }
      },
      "type": "object"
    },
    "ViewConfig": {
      "additionalProperties": false,
      "properties": {
        "clip": {
          "description": "Whether the view should be clipped.",
          "type": "boolean"
        },
        "fill": {
          "description": "The fill color.\n\n__Default value:__ (none)",
          "type": "string"
        },
        "fillOpacity": {
          "description": "The fill opacity (value between [0,1]).\n\n__Default value:__ (none)",
          "type": "number"
        },
        "height": {
          "description": "The default height of the single plot or each plot in a trellis plot when the visualization has a continuous (non-ordinal) y-scale with `rangeStep` = `null`.\n\n__Default value:__ `200`",
          "type": "number"
        },
        "stroke": {
          "description": "The stroke color.\n\n__Default value:__ (none)",
          "type": "string"
        },
        "strokeDash": {
          "description": "An array of alternating stroke, space lengths for creating dashed or dotted lines.\n\n__Default value:__ (none)",
          "items": {
            "type": "number"
          },
          "type": "array"
        },
        "strokeDashOffset": {
          "description": "The offset (in pixels) into which to begin drawing with the stroke dash array.\n\n__Default value:__ (none)",
          "type": "number"
        },
        "strokeOpacity": {
          "description": "The stroke opacity (value between [0,1]).\n\n__Default value:__ (none)",
          "type": "number"
        },
        "strokeWidth": {
          "description": "The stroke width, in pixels.\n\n__Default value:__ (none)",
          "type": "number"
        },
        "width": {
          "description": "The default width of the single plot or each plot in a trellis plot when the visualization has a continuous (non-ordinal) x-scale or ordinal x-scale with `rangeStep` = `null`.\n\n__Default value:__ `200`",
          "type": "number"
        }
      },
      "type": "object"
    }
  }
}

'''
'''--- version.sh ---
#!/bin/sh
# Modified from https://github.com/nikomatsakis/lalrpop/blob/master/version.sh
#
# A script to bump the version number on all Cargo.toml files etc in
# an atomic fashion.

set -ex

if [ "$1" == "" ]; then
    echo "Usage: version.sh <new-version-number>"
    exit 1
fi

VERSION=$(
    ls **/Cargo.toml | \
        xargs grep "# VERSION_TAG$" | \
        perl -p -e 's/.*version = "([0-9.]+)"[^#]+# VERSION_TAG$/$1/' |
        sort |
        uniq)

if [ $(echo $VERSION | wc -w) != 1 ]; then
    echo "Error: inconsistent versions detected across Cargo.toml files!"
    echo "$VERSION"
    exit 1
fi

echo "Found consistent version $VERSION"

perl -p -i -e 's/version *= *"[0-9.]+"([^#]+)# VERSION_TAG/version = "'$1'"$1# VERSION_TAG/' \
     $(ls **/Cargo.toml Cargo.toml)

perl -p -i -e 's/^gluon *= *"[0-9.]+"/gluon = "'$1'"/' \
     README.md

perl -p -i -e 's/[0-9][0-9.]+([^#]+)# VERSION_TAG/'$1'$1# VERSION_TAG/' \
     $(ls **/src/lib.rs src/lib.rs)

# Update Cargo.lock
cargo fetch

git add .
CHANGES=$(git diff  HEAD --unified=0 -- CHANGELOG.md | tail +6 | sed -e 's/^\+//')
git commit -m "Version ${1}\n\n${CHANGES}"
git tag "v${1}"

'''