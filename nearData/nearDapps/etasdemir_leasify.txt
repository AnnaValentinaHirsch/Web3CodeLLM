*GitHub Repository "etasdemir/leasify"*

'''--- README.md ---
# Welcome to Leasify!

**Leasify** is a trustless asset leasing smart contract deployed on NEAR testnet. It is written in AssemblyScript. With Leasify, you can buy asset and lease them. With that, you can get periodic income from your asset. Alternatively, you might want to lease an asset instead of buying. You only need to pay lease price periodically.

# Installation

1. Clone this repository: <br/>
`git clone https://github.com/etasdemir/leasify.git`
2. Install dependencies: <br/>
`yarn install`
4. Build and deploy the contract:  <br/>
`yarn dev-deploy`
> It will make a release build and deploy the smart contract.
5. Contract successfully deployed. Now, firstly you need to generate some mock assets: <br/>
`near call $CONTRACT_ID generateMockAssets --accountId $ACCOUNT_ID --gas=300000000000000   `
> **Note:** You need to increase gas amount for some commands by adding --gas=300000000000000 to the CLI command
7. At this step, you can freely interact with the contract.

# Methods and Usage

## Usage
Every functions can be called with: <br/>
`near call $CONTRACT_ID methodName '{"argName1": "argValue1"}' --accountId $ACCOUNT_ID --gas=300000000000000`

## Contract Methods
1. Generate mock assets. It will be used only in development environment. Before interacting with the contract, this method should be called. <br/>
`generateMockAssets(): string`
2. Get buyable assets. Buyable means not owned by anybody.  <br/>
`getBuyableAssets(): Array<Asset>`
3. Get leasable assets. Leasable means not leased by anybody.  <br/>
`getLeasebleAssets(): Array<Asset>`
4. Get asset info with id.  <br/>
`getAssetById(assetId: string): Asset`

## Lessor Methods
1. Get lessor by public account id. Returns Lessor.  <br/>
`getLessor(sender: AccountId): Lessor` <br/>
Usage:   <br/>
`near call dev-1650223408078-59961683836754 getLessor '{"sender": "erentasdemir.testnet"}' --accountId erentasdemir.testnet --gas=300000000000000`
2.  Buy assets. Return  true if success  <br/>
`buyAsset(assetId: string): bool`
3. Get accumulated income.  <br/>
`getAccumulatedIncome(): Balance`
4. Get assets owned by contract caller account.   <br/>
`getOwnedAssets(): Array<Asset>`
5. Transfer accumulated income from  contract to asset owner account.  <br/>
`transferAccumulatedIncome(amount: Money): bool`
6. Sell the asset.  <br/>
`sellAsset(assetId: string): bool`

## Lessee Methods
1. Get lessee by public account id.  <br/>
`getLessee(sender: AccountId): Lessee`
> **Note:** When an asset leased, lessee pay the asset deposit amount. It will be used for future implementations. After releasing the asset, deposit will be transfered back to lessee account. Future implementations 2nd and 3rd item.
3. Lease the asset given with id.  <br/>
`leaseAsset(assetId: string): bool`
4. Pay periodic lease amount.  <br/>
`payLease(assetId: string): bool`
5. Get assets leased by contract caller account.  <br/>
`getLeasedAssets(): Array<Asset>`
6. Release the asset.  <br/>
`releaseAsset(assetId: string): bool`	

# Future Implementations

1. Periodic income can be dynamic like percentage in case of asset price changes.
2. If a lessee do not pay its periodic lease amount, an interest rate should be added to the next lease amount.
3. If a lessee still not paying, when lease amount with the interest reaches deposit amount, automatically release asset and transfer deposit to the asset owner.
4. Partial lessor system. Instead of only one lessor for an asset, more than one people can buy a part of the asset. N Lessor - 1 Asset.
5. Adding new assets to the contract by users.
6. Gas price usage should be reduced.
7. Mobile app and web implementation to interact with the contract more easily.

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- asconfig.json ---
{
  "workspaces": [
    "src/leasify"
  ]
}

'''
'''--- package.json ---
{
  "name": "leasify",
  "version": "0.1.0",
  "description": "Trustless asset leasing platform.",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test'",
    "test": "yarn asp -f unit.spec",
    "clean": "rm -rf ./build && rm -rf ./neardev",
    "build": "asb --target debug",
    "build:release": "asb",
    "asp": "asp --verbose --nologo",
    "lint": "eslint . --ext .ts",
    "dev-deploy": "yarn build:release && near dev-deploy ./build/release/leasify.wasm"
  },
  "keywords": [],
  "author": "https://github.com/etasdemir",
  "license": "Apache-2",
  "devDependencies": {
    "@typescript-eslint/eslint-plugin": "^5.19.0",
    "@typescript-eslint/parser": "^5.19.0",
    "eslint": "^8.13.0"
  },
  "dependencies": {
    "near-sdk-as": "^3.2.3",
    "typescript": "^4.6.3"
  }
}

'''
'''--- scripts/1.dev-deploy.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 1: Build the contract (may take a few seconds)"
echo ---------------------------------------------------------
echo

yarn build

echo
echo
echo ---------------------------------------------------------
echo "Step 2: Deploy the contract"
echo
echo "(edit scripts/1.dev-deploy.sh to deploy other contract)"
echo ---------------------------------------------------------
echo

near dev-deploy ./build/release/leasify.wasm

echo
echo
echo ---------------------------------------------------------
echo "Step 3: Prepare your environment for next steps"
echo
echo "(a) find the contract (account) name in the message above"
echo "    it will look like this: [ Account id: dev-###-### ]"
echo
echo "(b) set an environment variable using this account name"
echo "    see example below (this may not work on Windows)"
echo
echo ---------------------------------------------------------
echo 'export CONTRACT=<dev-123-456>'
# uncomment this line for a useful hint when using the singleton style
# echo "near call \$CONTRACT init --accountId \$CONTRACT"
echo ---------------------------------------------------------
echo

exit 0

'''
'''--- scripts/2.use-contract.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for environment variable with contract name"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"

echo
echo
echo ---------------------------------------------------------
echo "Step 1: Call 'view' functions on the contract"
echo
echo "(run this script again to see changes made by this file)"
echo ---------------------------------------------------------
echo

near view $CONTRACT getBuyableAssets

echo
echo

near view $CONTRACT getLeasebleAssets

echo
echo
echo ---------------------------------------------------------
echo "Step 2: Call 'change' functions on the contract"
echo ---------------------------------------------------------
echo

near call $CONTRACT buyAsset '{"assetId": "asset id from getBuyableAssets method"}' --accountId $CONTRACT

echo
echo "now run this script again to see changes made by this file"
exit 0

'''
'''--- scripts/3.cleanup.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for required environment variables"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$BENEFICIARY" ] && echo "Missing \$BENEFICIARY environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"
[ -z "$BENEFICIARY" ] || echo "Found it! \$BENEFICIARY is set to [ $BENEFICIARY ]"

echo
echo
echo ---------------------------------------------------------
echo "Step 1: Delete $CONTRACT, setting $BENEFICIARY as beneficiary"
echo ---------------------------------------------------------
echo
near delete $CONTRACT $BENEFICIARY

echo
echo ---------------------------------------------------------
echo "Step 2: Clean up project folders"
echo ---------------------------------------------------------
echo
yarn clean

exit 0

'''
'''--- scripts/README.md ---
## Setting up your terminal

The scripts in this folder are designed to help you demonstrate the behavior of the contract(s) in this project.

It uses the following setup:

```sh
# set your terminal up to have 2 windows, A and B like this:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                 ‚îÇ                                 ‚îÇ
‚îÇ                                 ‚îÇ                                 ‚îÇ
‚îÇ                A                ‚îÇ                B                ‚îÇ
‚îÇ                                 ‚îÇ                                 ‚îÇ
‚îÇ                                 ‚îÇ                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Terminal **A**

*This window is used to compile, deploy and control the contract*
- Environment
  ```sh
  export CONTRACT=        # depends on deployment
  export OWNER=           # any account you control

  # for example
  # export CONTRACT=dev-1615190770786-2702449
  # export OWNER=sherif.testnet
  ```

- Commands

  _helper scripts_
  ```sh
  1.dev-deploy.sh                # helper: build and deploy contracts
  2.use-contract.sh              # helper: call methods on ContractPromise
  3.cleanup.sh                   # helper: delete build and deploy artifacts
  ```

### Terminal **B**

*This window is used to render the contract account storage*
- Environment
  ```sh
  export CONTRACT=               # depends on deployment

  # for example
  # export CONTRACT=dev-1615190770786-2702449
  ```

- Commands
  ```sh
  # monitor contract storage using near-account-utils
  # https://github.com/near-examples/near-account-utils
  watch -d -n 1 yarn storage $CONTRACT
  ```
---

## OS Support

### Linux

- The `watch` command is supported natively on Linux
- To learn more about any of these shell commands take a look at [explainshell.com](https://explainshell.com)

### MacOS

- Consider `brew info visionmedia-watch` (or `brew install watch`)

### Windows

- Consider this article: [What is the Windows analog of the Linux watch command?](https://superuser.com/questions/191063/what-is-the-windows-analog-of-the-linuo-watch-command#191068)

'''
'''--- src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/leasify/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/leasify/__tests__/index.unit.spec.ts ---
import { Contract } from "../assembly";

let contract: Contract

beforeEach(() => {
  contract = new Contract()
})

describe("Contract", () => {
  // VIEW method tests

  it("says hello", () => {
    expect(contract.helloWorld()).toStrictEqual("hello world")
  })

  it("reads data", () => {
    expect(contract.read("some key")).toStrictEqual("üö´ Key [ some key ] not found in storage. ( storage [ 0 bytes ] )")
  })

  // CHANGE method tests

  it("saves data to contract storage", () => {
    expect(contract.write("some-key", "some value")).toStrictEqual("‚úÖ Data saved. ( storage [ 18 bytes ] )")
  })
})

'''
'''--- src/leasify/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/leasify/assembly/Constants.ts ---
export const BUILD_TYPE = 'DEV';

export const LESSOR_MAP_PREFIX = "a";

export const LESSEE_MAP_PREFIX = "b";

export const ASSET_MAP_PREFIX = "c";

export const ASSET_IDS_PREFIX = "d";

'''
'''--- src/leasify/assembly/index.ts ---
import { Context, math, PersistentMap, PersistentSet } from "near-sdk-core"
import { ContractPromiseBatch, u128, logging, RNG } from 'near-sdk-as';
import {AccountId, assert_self, Balance, Money, toYocto} from './utils';
import { BUILD_TYPE, LESSOR_MAP_PREFIX, LESSEE_MAP_PREFIX, ASSET_MAP_PREFIX, ASSET_IDS_PREFIX } from "./Constants";
import {Lessor} from "./models/Lessor";
import {Lessee} from "./models/Lessee";
import {Asset} from "./models/Asset";

@nearBindgen
export class Contract {
  private lessorMap: PersistentMap<AccountId, Lessor> = new PersistentMap(LESSOR_MAP_PREFIX);
  private lesseeMap: PersistentMap<AccountId, Lessee> = new PersistentMap(LESSEE_MAP_PREFIX);
  private assetMap: PersistentMap<string, Asset> = new PersistentMap(ASSET_MAP_PREFIX);
  private assetIds: PersistentSet<string> = new PersistentSet(ASSET_IDS_PREFIX);

  // near call $contract generateMockAssets --accountId $account --gas=300000000000000 
  @mutateState()
  generateMockAssets(): string {
    assert(BUILD_TYPE === "DEV", "generateAssets method can be called only in development environment");
    // assert_self();
    const MOCK_ASSET_COUNT = 20;
    assert(this.assetIds.size < MOCK_ASSET_COUNT, "Mock assests already created");
    const rng = new RNG<u32>(MOCK_ASSET_COUNT * 4, 1000);
    for (let i = 0; i < MOCK_ASSET_COUNT; i++) {
      const id = math.hash32<u32>(rng.next()).toString();
      const price = u128.div(toYocto(rng.next()), u128.from(1000));
      const leasePrice = u128.div(price, u128.from(30));
      const periodicIncome = leasePrice;
      const deposit = u128.mul(leasePrice, u128.from(6));
      const asset = new Asset(id, price, leasePrice, periodicIncome, deposit);
      this.assetIds.add(id);
      this.assetMap.set(id, asset);
    }
    return 'Mock assets are generated.';
  }

  getBuyableAssets(): Array<Asset> {
    const assets: Array<Asset> = new Array<Asset>();
    const assetIds: string[] = this.assetIds.values();
    for (let i = 0; i < assetIds.length; i++) {
      const asset: Asset = this.getAssetById(assetIds[i]);
      if (!asset.ownedBy) {
        assets.push(asset);
      }
    }
    return assets;
  }

  getLeasebleAssets(): Array<Asset> {
    const assets: Array<Asset> = new Array<Asset>();
    const assetIds: string[] = this.assetIds.values();
    for (let i = 0; i < assetIds.length; i++) {
      const asset: Asset = this.getAssetById(assetIds[i]);
      if (!asset.leasedBy) {
        assets.push(asset);
      }
    }
    return assets;
  }

  getAssetById(assetId: string): Asset {
    const asset = this.assetMap.get(assetId, null);
    assert(asset != null, `Asset not found with id: ${assetId}`);
    return asset!;
  }

  /**
   * Lessor methods
   */

  @mutateState()
  buyAsset(assetId: string): bool {
    const asset: Asset = this.getAssetById(assetId);
    assert(!asset.isOwned(), 'Asset already owned.');
    const sender = Context.sender;
    const contract = Context.contractName;
    const buy_asset = ContractPromiseBatch.create(contract);
    buy_asset.transfer(asset.price);
    asset.buyAsset(sender);
    this.assetMap.set(assetId, asset);
    const lessor = this.getLessorOrCreate(sender);
    lessor.addAsset(asset.id);
    this.lessorMap.set(sender, lessor);
    logging.log(`Success. Asset with id: ${assetId} bought by ${sender}`);
    return true;
  }

  getAccumulatedIncome(): Balance {
    const sender = Context.sender;
    const lessor = this.getLessor(sender);
    return lessor.accumulatedIncome;
  }

  getOwnedAssets(): Array<Asset> {
    const sender = Context.sender;
    const lessor = this.getLessor(sender);
    const ownedAssets = new Array<Asset>();
    const assetIds = lessor.ownedAssetIds.values();
    for (let index = 0; index < assetIds.length; index++) {
      const assetId = assetIds[index];
      const asset = this.getAssetById(assetId);
      if (asset.ownedBy == lessor.id) {
        ownedAssets.push(asset);
      }
    }
    return ownedAssets;
  }

  @mutateState()
	transferAccumulatedIncome(amount: Money): bool {
    const sender = Context.sender;
    const lessor = this.getLessor(sender);
    assert(lessor.accumulatedIncome > u128.Zero, "Accumulated amount can not be less than or equal to 0");
    assert(amount > u128.Zero && amount <= lessor.accumulatedIncome, 
      "Requested amount should be bigger than 0, less than or equal to accumulated amount");
    const transferIncome = ContractPromiseBatch.create(lessor.id);
    transferIncome.transfer(amount);
    lessor.transferAccumulatedIncome(amount);
    this.lessorMap.set(sender, lessor);
    logging.log(`Success. ${amount} amount transfered to ${sender}`);
    return true;
  }

  @mutateState()
	sellAsset(assetId: string): bool {
    const sender = Context.sender;
    const lessor = this.getLessor(sender);
    const asset = this.getAssetById(assetId);
    const sell_asset = ContractPromiseBatch.create(lessor.id);
    sell_asset.transfer(asset.price);
    asset.sellAsset();
    this.assetMap.set(assetId, asset);
    lessor.removeAsset(assetId);
    this.lessorMap.set(lessor.id, lessor);
    logging.log(`Success. Asset with id: ${assetId} sold by ${sender}`);
    return true;
  }

  getLessor(sender: AccountId): Lessor {
    const lessor = this.lessorMap.get(sender, null);
    assert(lessor != null, "Lessor not found.");
    assert(lessor!.id == sender, "Incorrect caller or it is not a lessor")
    return lessor!;
  }

  private getLessorOrCreate(sender: AccountId): Lessor {
    return this.lessorMap.get(sender, new Lessor(sender))!;
  }

  /**
   * Lessee methods
   */
   @mutateState()
  leaseAsset(assetId: string): bool {
    const asset = this.getAssetById(assetId);
    assert(!asset.isLeased(), "Asset already leased");
    const sender = Context.sender;
    const lessee = this.getLesseeOrCreate(sender)
    const lease_asset = ContractPromiseBatch.create(Context.contractName);
    lease_asset.transfer(asset.depositAmount);
    asset.leaseAsset(lessee.id);
    this.assetMap.set(assetId, asset);
    lessee.depositBalance = u128.add(lessee.depositBalance, asset.depositAmount);
    lessee.addAsset(assetId);
    this.lesseeMap.set(lessee.id, lessee);
    logging.log(`Success. Asset with id: ${assetId} leased by ${sender}`);
    return true;
  }

  @mutateState()
  payLease(assetId: string): bool {
    const sender = Context.sender;
    const lessee = this.getLessee(sender);
    const asset = this.getAssetById(assetId);
    const contract = Context.contractName;
    const pay_lease = ContractPromiseBatch.create(contract);
    pay_lease.transfer(asset.leasePrice);
    if (asset.isOwned()) {
      const lessor = this.getLessor(asset.ownedBy);
      lessor.accumulatedIncome = u128.add(lessor.accumulatedIncome, asset.leasePrice);
      this.lessorMap.set(lessor.id, lessor);
    }
    logging.log(`${sender} paid ${asset.leasePrice} for asset ${assetId}`);
    return true;
  }

  getLeasedAssets(): Array<Asset> {
    const sender = Context.sender;
    const lessee = this.getLessee(sender);
    const leasedAssets = new Array<Asset>();
    const leasedAssetIds = lessee.leasedAssetIds.values();
    for (let index = 0; index < leasedAssetIds.length; index++) {
      const assetId = leasedAssetIds[index];
      const asset = this.getAssetById(assetId);
      if (asset.leasedBy == lessee.id) {
        leasedAssets.push(asset);
      }
    }
    return leasedAssets;
  }

  @mutateState()
  releaseAsset(assetId: string): bool {
    const sender = Context.sender;
    const lessee = this.getLessee(sender);
    const asset = this.getAssetById(assetId);
    assert(lessee.depositBalance >= asset.depositAmount, "Insufficient deposit balance.");
    const transferDeposit = ContractPromiseBatch.create(lessee.id);
    transferDeposit.transfer(asset.depositAmount);
    lessee.removeAsset(assetId, asset.depositAmount);
    this.lesseeMap.set(lessee.id, lessee);
    asset.releaseAsset();
    this.assetMap.set(asset.id, asset);
    logging.log(`Success. Asset with id: ${assetId} released by ${sender}`);
    return true;
  }

  getLessee(sender: AccountId): Lessee {
    const lessee = this.lesseeMap.get(sender, null);
    assert(lessee != null, "Lessee not found.");
    assert(lessee!.id == sender, "Incorrect caller or it is not a lessee")
    return lessee!;
  }

  private getLesseeOrCreate(sender: AccountId): Lessee {
    return this.lesseeMap.get(sender, new Lessee(sender))!;
  }
}

'''
'''--- src/leasify/assembly/models/Asset.ts ---
import { Money, AccountId } from "../utils"

@nearBindgen
export class Asset {
    id: string
    price: Money
    leasePrice: Money
    periodicIncome: Money
    depositAmount: Money
    ownedBy: AccountId
    leasedBy: AccountId

    constructor(id: string, price: Money, leasePrice: Money, periodicIncome: Money, depositAmount: Money) {
        this.id = id;
        this.price = price;
        this.leasePrice = leasePrice;
        this.periodicIncome = periodicIncome;
        this.depositAmount = depositAmount;
        this.ownedBy = '';
        this.leasedBy = '';
    }

    isLeased(): bool {
        return this.leasedBy != '';
    }

    isOwned(): bool {
        return this.ownedBy != '';
    }

    buyAsset(owner: string): void {
        this.ownedBy = owner;
    }

    sellAsset(): void {
        this.ownedBy = '';
    }

    leaseAsset(lesse: string): void {
        this.leasedBy = lesse;
    }

    releaseAsset(): void {
        this.leasedBy = '';
    }
}
'''
'''--- src/leasify/assembly/models/Lessee.ts ---
import { u128 } from 'near-sdk-as';
import {Balance, Amount} from '../utils';

@nearBindgen
export class Lessee {
    id: string
	depositBalance: Balance
	leasedAssetIds: Set<string>

    constructor(id: string) {
        this.id = id;
        this.depositBalance = u128.Zero;
        this.leasedAssetIds = new Set<string>();
    }

    addAsset(assetId: string): void {
        this.leasedAssetIds.add(assetId);
    }

    removeAsset(assetId: string, depositAmount: Amount): void {
        this.leasedAssetIds.delete(assetId);
        this.depositBalance = u128.sub(this.depositBalance, depositAmount);
    }
}

'''
'''--- src/leasify/assembly/models/Lessor.ts ---
import { u128 } from 'near-sdk-as';
import {Balance, Money} from '../utils';

@nearBindgen
export class Lessor {
    id: string
	accumulatedIncome: Balance
	ownedAssetIds: Set<string>

    constructor(id: string) {
        this.id = id;
        this.accumulatedIncome = u128.Zero;
        this.ownedAssetIds = new Set<string>();
    }

    transferAccumulatedIncome(amount: Money): void {
        this.accumulatedIncome = u128.sub(this.accumulatedIncome, amount);
    }

    addAsset(assetId: string): void {
        this.ownedAssetIds.add(assetId);
    }

    removeAsset(assetId: string): void {
        this.ownedAssetIds.delete(assetId);
    }
}

'''
'''--- src/leasify/assembly/utils.ts ---
import { u128, Context, ContractPromise } from "near-sdk-as";

/**
 * == TYPES ====================================================================
 */

/**
 * Account IDs in NEAR are just strings.
 */
export type AccountId = string;

/**
 * Gas is u64
 */
export type Gas = u64;

/**
 * Amounts, Balances, and Money in NEAR is are u128.
 */

export type Amount = u128;

export type Balance = Amount;

export type Money = Amount;

/**
 * Timestamp in NEAR is a number.
 */
export type Timestamp = u64;

/**
 * == CONSTANTS ================================================================
 *
 * ONE_NEAR = unit of NEAR token in yocto ‚ìÉ (1e24)
 * XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"
 * MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking
 *
 * TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this
 *  could end up being much higher
 */

export const ONE_NEAR = u128.from("1000000000000000000000000");
export const XCC_GAS: Gas = 50_000_000_000_000;
export const MIN_ACCOUNT_BALANCE: u128 = u128.mul(ONE_NEAR, u128.from(3));

/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto ‚ìÉ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
export function asNEAR(amount: u128): string {
  return u128.div(amount, ONE_NEAR).toString();
}

/**
 * @function toYocto
 * @param amount {number} - Integer to convert
 * @returns {u128}        - Amount in yocto ‚ìÉ as an unsigned 128-bit integer
 *
 * @example
 *
 *    toYocto(7)
 *    // => 7000000000000000000000000
 */
export function toYocto(amount: number): u128 {
  return u128.mul(ONE_NEAR, u128.from(amount))
}

/**
 * Function to assert that the contract has called itself
 */
export function assert_self(): void {
  const caller = Context.predecessor
  const sender = Context.sender
  const self = Context.contractName
  assert(caller === self && sender === self, "Only this contract may call itself");
}

export function assert_single_promise_success(): void {
  const x = ContractPromise.getResults()
  assert(x.length == 1, "Expected exactly one promise result")
  assert(x[0].succeeded, "Expected PromiseStatus to be successful")
}
'''
'''--- src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

'''