*GitHub Repository "evgenykuzyakov/wonderland"*

'''--- README.md ---
# Wonderland

A fork of berryclub designed to create a zero-sum ecosystem for custom fungible tokens.

## Definitions:
- `FT` - an instance of a fungible token used for this version of the Wonderland. E.g. wUSDC, wDAI or Banana.
- `L` - an inner fungible token used to track liquidity of this version of the Wonderland.
- `ft_pool` - the total amount of `FT` tokens that are used to determine current drawing pricing and reward distribution
- `l_pool` - the total amount of `L` tokens.

## Actions:
- Draw a pixel
- Add L
- Remove L
- Farm (passive)

### Draw a pixel

The cost of drawing a pixel is determined by current `ft_pool` and a fixed coefficient `pixel_coef` (e.g. `1 / 10000`)

`pixel_price = ft_pool * pixel_coef`

When drawing multiple pixels in one transaction it's should be possible to correctly compute the total price.

`draw_fee_coef` is used to determine which part of the pixel price goes to liquidity providers as a reward (e.g. `1 / 10`)

- `your_ft -= pixel_price` - withdrawing `FT` amount from your account.
- `lp_reward = draw_fee_coef * pixel_price` will be split proportionally to `L` owners at `your_l / l_pool`
- `ft_pool += pixel_price - lp_reward` increasing `FT` pool

### Add L

Anyone can buy `L` tokens at current `l_price`, but some amount of the newly minted `L` will be held by the app to
disincentive the liquidity providers from frequently add and remove liquidity.

`l_price = ft_pool / l_pool`

The amount you get depends on `farm_hold_coefficient` (e.g. `1 / 10`)
The amount of `FT` you want to spend.

- `your_ft -= ft_amount`
- `l_amount = ft_amount / l_price` - total amount of `L` being minted
- `app_l_amount = l_amount * farm_hold_coefficient` - the amount of `L` that will be forever held by the app to incentivize farmers.
- `your_l_amount = l_amount - app_l_amount` - the amount of `L` you get.
- `ft_pool += ft_amount` - increasing `FT` pool
- `l_pool += l_amount` - increasing `L` pool
- `your_l += your_l_amount` - increasing your `L` total amount
- `app_l += app_l_amount` - increasing app's `L` total amount

### Remove L

Any liquidity provider (except for the App) can remove the liquidity by burning `L` tokens and getting corresponding amount
of `FT` tokens based on the current `l_price`. There is no fee to remove `L`

- `l_amount` - the amount of `L` tokens to remove/burn
- `your_l -= l_amount` - remove `L` tokens from your balance
- `ft_amount = l_amount * l_price` - the amount `FT` you get for removing liquidity
- `your_ft += ft_amount` - increase your `FT` balance
- `ft_pool -= ft_amount` - decrease amount of `FT` in the pool
- `l_pool -= l_amount` - decrease amount of `L` in the pool

### Farm

Every second a pixel on board is earning `FT` tokens to the pixel owner based on current `ft_pool`.

- `ft_amount_per_pixel = (magic formula based on time) * ft_pool`
- `ft_pool -= ft_amount_per_pixel * num_active_pixels`
- `ft_farmed_per_pixel += ft_amount_per_pixel` - increased based on time passed from last update

Every account tracks:

- `last_ft_farmed_per_pixel` - the previous `ft_farmed_per_pixel` value
- `num_pixels` - the number of pixels the account owns on the board

Touching account

- `diff_ft_farmed_per_pixel = ft_farmed_per_pixel - last_ft_farmed_per_pixel` - the difference from the last time account was touched
- `farmed_ft_amount = diff_ft_farmed_per_pixel * num_pixels` - the accumulated farmed amount from last time
- `last_ft_farmed_per_pixel = ft_farmed_per_pixel` - remembering the current value
- `acc_ft += farmed_ft_amount` - adding farmed balance to the account balance

## App fee

The app owner will not be able to withdraw app liquidity, so the farmers can be certain that the `FT` pool can't be fully drained.
But the app owner will be able to claim draw fees earned by the app liquidity.

'''
'''--- contract-rs/wonderland/Cargo.toml ---
[package]
name = "wonderland"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "=3.0.0-pre.2"
uint = "0.9.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

[workspace]
members = []

'''
'''--- contract-rs/wonderland/README.md ---
# NEAR Place

Smart contract to keep track of the board.

## Building

```bash
./build.sh
```

## Testing

To test run:

```bash
cargo test --package near-place -- --nocapture
```

'''
'''--- contract-rs/wonderland/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/wonderland.wasm ./res/

'''
'''--- contract-rs/wonderland/src/account.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize)]
pub enum UpgradableAccount {
    Last(Account),
}

impl From<UpgradableAccount> for Account {
    fn from(account: UpgradableAccount) -> Self {
        match account {
            UpgradableAccount::Last(account) => account,
        }
    }
}

impl From<Account> for UpgradableAccount {
    fn from(account: Account) -> Self {
        UpgradableAccount::Last(account)
    }
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Account {
    pub account_id: AccountId,
    pub account_index: AccountIndex,
    pub last_ft_farmed_per_pixel: FarmRatio,

    pub ft_balance: TokenBalance,
    pub l_balance: TokenBalance,

    pub num_pixels: u32,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct HumanAccount {
    pub account_id: AccountId,
    pub account_index: AccountIndex,
    pub ft_balance: U128,
    pub l_balance: U128,
    pub num_pixels: u32,
}

impl From<Account> for HumanAccount {
    fn from(account: Account) -> Self {
        Self {
            account_id: account.account_id,
            account_index: account.account_index,
            ft_balance: account.ft_balance.into(),
            l_balance: account.l_balance.into(),
            num_pixels: account.num_pixels,
        }
    }
}

impl Account {
    pub fn new(
        account_id: AccountId,
        account_index: AccountIndex,
        ft_farmed_per_pixel: FarmRatio,
    ) -> Self {
        Self {
            account_id,
            account_index,
            last_ft_farmed_per_pixel: ft_farmed_per_pixel,
            ft_balance: 0,
            l_balance: 0,
            num_pixels: 0,
        }
    }

    pub fn touch(&mut self, ft_farmed_per_pixel: FarmRatio) -> TokenBalance {
        let ft_farmed_diff = ft_farmed_per_pixel - self.last_ft_farmed_per_pixel;
        let ft_farmed_amount = ft_farmed_diff * FarmRatio::from(self.num_pixels);
        self.ft_balance += ft_farmed_amount;
        self.last_ft_farmed_per_pixel = ft_farmed_per_pixel;
        ft_farmed_amount
    }

    pub fn charge(&mut self, ft_amount: TokenBalance) {
        assert!(
            self.ft_balance >= ft_amount,
            "Not enough FT balance to draw pixels"
        );
        self.ft_balance -= ft_amount;
    }
}

#[near_bindgen]
impl Contract {
    pub fn get_num_accounts(&self) -> u32 {
        self.num_accounts
    }

    pub fn register_account(&mut self) {
        let account = self.get_mut_account(env::predecessor_account_id());
        self.save_account(account);
    }

    #[payable]
    pub fn withdraw_ft(&mut self, amount: Option<U128>) -> Promise {
        assert_one_yocto();
        let mut account = self.get_mut_account(env::predecessor_account_id());
        let amount = amount.map(|a| a.into()).unwrap_or(account.ft_balance);
        if account.ft_balance < amount {
            env::panic(b"Account doesn't have enough FT balance");
        }
        account.ft_balance -= amount;
        let account_id = account.account_id.clone();
        self.save_account(account);
        self.internal_withdraw_to(account_id, amount)
    }

    pub fn account_exists(&self, account_id: ValidAccountId) -> bool {
        self.account_indices.contains_key(account_id.as_ref())
    }

    pub fn get_account_by_index(&self, account_index: AccountIndex) -> Option<HumanAccount> {
        self.get_internal_account_by_index(account_index)
            .map(|mut account| {
                account.touch(self.ft_farmed_per_pixel);
                account.into()
            })
    }

    pub fn get_account(&self, account_id: ValidAccountId) -> Option<HumanAccount> {
        self.get_internal_account_by_id(account_id.as_ref())
            .map(|mut account| {
                account.touch(self.ft_farmed_per_pixel);
                account.into()
            })
    }
}

impl Contract {
    pub fn get_internal_account_by_id(&self, account_id: &AccountId) -> Option<Account> {
        self.account_indices
            .get(&account_id)
            .and_then(|account_index| self.get_internal_account_by_index(account_index))
    }

    pub fn get_app_account(&mut self) -> Account {
        let mut account = self.get_internal_account_by_index(0).unwrap();
        self.touch_account(&mut account);
        account
    }

    pub fn get_mut_account(&mut self, account_id: AccountId) -> Account {
        let mut account = self
            .get_internal_account_by_id(&account_id)
            .unwrap_or_else(|| {
                Account::new(account_id, self.num_accounts, self.ft_farmed_per_pixel)
            });
        self.touch_account(&mut account);
        account
    }

    pub fn get_internal_account_by_index(&self, account_index: AccountIndex) -> Option<Account> {
        self.accounts
            .get(&account_index)
            .map(|account| account.into())
    }

    pub fn touch_account(&mut self, account: &mut Account) {
        let ft_farmed = account.touch(self.ft_farmed_per_pixel);
        if ft_farmed > 0 {
            self.stats.ft_farmed.0 += ft_farmed;
        }
    }

    pub fn save_account(&mut self, account: Account) {
        let account_index = account.account_index;
        if account_index >= self.num_accounts {
            self.account_indices
                .insert(&account.account_id, &account_index);
            self.num_accounts += 1;
        }
        self.accounts.insert(&account_index, &account.into());
    }
}

'''
'''--- contract-rs/wonderland/src/board.rs ---
use crate::*;

use near_sdk::collections::Vector;
use near_sdk::json_types::Base64VecU8;
use std::collections::HashMap;

pub const BOARD_WIDTH: u32 = 50;
pub const BOARD_HEIGHT: u32 = 50;
pub const TOTAL_NUM_PIXELS: u32 = BOARD_WIDTH * BOARD_HEIGHT;

#[derive(BorshDeserialize, BorshSerialize, Copy, Clone)]
pub struct Pixel {
    pub color: u32,
    pub owner_id: AccountIndex,
}

impl Default for Pixel {
    fn default() -> Self {
        Self {
            color: 0xffffff,
            owner_id: 0,
        }
    }
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct PixelLine(pub Vec<Pixel>);

impl Default for PixelLine {
    fn default() -> Self {
        Self(vec![Pixel::default(); BOARD_WIDTH as usize])
    }
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct PixelBoard {
    pub lines: Vector<PixelLine>,
    pub line_versions: Vec<u32>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SetPixelRequest {
    pub x: u32,
    pub y: u32,
    pub color: u32,
}

impl SetPixelRequest {
    pub fn assert_valid(&self) {
        assert!(self.x < BOARD_WIDTH, "X is out of bounds");
        assert!(self.y < BOARD_HEIGHT, "Y is out of bounds");
        assert!(self.color <= 0xffffff, "Color is out of bounds");
    }
}

impl PixelBoard {
    pub fn new() -> Self {
        let mut board = Self {
            lines: Vector::new(b"p".to_vec()),
            line_versions: vec![0; BOARD_HEIGHT as usize],
        };
        let default_line = PixelLine::default();
        for _ in 0..BOARD_HEIGHT {
            board.lines.push(&default_line);
        }
        board
    }

    pub fn get_line(&self, index: u32) -> PixelLine {
        self.lines.get(u64::from(index)).unwrap()
    }

    /// Returns the list of the old owner IDs for the replaced pixels
    pub fn set_pixels(
        &mut self,
        new_owner_id: u32,
        pixels: &[SetPixelRequest],
    ) -> HashMap<AccountIndex, u32> {
        let mut lines = HashMap::new();
        let mut old_owners = HashMap::new();
        for request in pixels {
            request.assert_valid();
            let line = lines
                .entry(request.y)
                .or_insert_with(|| self.lines.get(u64::from(request.y)).unwrap());
            let old_owner = line.0[request.x as usize].owner_id;
            line.0[request.x as usize] = Pixel {
                owner_id: new_owner_id,
                color: request.color,
            };
            *old_owners.entry(old_owner).or_default() += 1;
        }
        for (i, line) in lines {
            self.save_line(i, &line);
        }
        old_owners
    }

    fn save_line(&mut self, index: u32, line: &PixelLine) {
        self.lines.replace(u64::from(index), line);
        self.line_versions[index as usize] += 1;
    }
}

#[near_bindgen]
impl Contract {
    pub fn get_lines(&self, lines: Vec<u32>) -> Vec<Base64VecU8> {
        lines
            .into_iter()
            .map(|i| {
                let line = self.board.get_line(i);
                line.try_to_vec().unwrap().into()
            })
            .collect()
    }

    pub fn get_line_versions(&self) -> Vec<u32> {
        self.board.line_versions.clone()
    }
}

'''
'''--- contract-rs/wonderland/src/fungible_token.rs ---
use crate::*;
use near_sdk::{ext_contract, Gas, PromiseOrValue};

const FT_TRANSFER_GAS: Gas = 5_000_000_000_000;

pub trait FungibleTokenReceiver {
    /// Called by fungible token contract after `ft_transfer_call` was initiated by
    /// `sender_id` of the given `amount` with the transfer message given in `msg` field.
    /// The `amount` of tokens were already transferred to this contract account and ready to be used.
    ///
    /// The method must return the amount of tokens that are *not* used/accepted by this contract from the transferred
    /// amount. Examples:
    /// - The transferred amount was `500`, the contract completely takes it and must return `0`.
    /// - The transferred amount was `500`, but this transfer call only needs `450` for the action passed in the `msg`
    ///   field, then the method must return `50`.
    /// - The transferred amount was `500`, but the action in `msg` field has expired and the transfer must be
    ///   cancelled. The method must return `500` or panic.
    ///
    /// Arguments:
    /// - `sender_id` - the account ID that initiated the transfer.
    /// - `amount` - the amount of tokens that were transferred to this account in a decimal string representation.
    /// - `msg` - a string message that was passed with this transfer call.
    ///
    /// Returns the amount of unused tokens that should be returned to sender, in a decimal string representation.
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;
}

#[derive(Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum FtMessage {
    Deposit,
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        assert_eq!(
            &env::predecessor_account_id(),
            self.config.ft_account_id.as_ref()
        );

        let msg: FtMessage =
            near_sdk::serde_json::from_str(&msg).expect("Can't deserialize the msg");

        match msg {
            FtMessage::Deposit => {
                let mut account: Account = self.get_mut_account(sender_id.into());
                account.ft_balance += amount.0;
                log!("Deposited {} FT to @{}", amount.0, account.account_id);
                PromiseOrValue::Value(0.into())
            }
        }
    }
}

#[ext_contract(ext_ft_core)]
pub trait FungibleTokenCore {
    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id`.
    /// Both accounts must be registered with the contract for transfer to succeed. (See [NEP-145](https://github.com/near/NEPs/discussions/145))
    /// This method must to be able to accept attached deposits, and must not panic on attached deposit.
    /// Exactly 1 yoctoNEAR must be attached.
    /// See [the Security section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver.
    /// - `amount` - the amount of tokens to transfer. Must be a positive number in decimal string representation.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);
}

impl Contract {
    pub fn internal_withdraw_to(&mut self, account_id: AccountId, amount: TokenBalance) -> Promise {
        ext_ft_core::ft_transfer(
            account_id,
            amount.into(),
            Some("Wonderland withdrawal".to_string()),
            self.config.ft_account_id.as_ref(),
            ONE_YOCTO,
            FT_TRANSFER_GAS,
        )
    }
}

'''
'''--- contract-rs/wonderland/src/internal.rs ---
use crate::*;

pub(crate) const ONE_YOCTO: Balance = 1;

pub(crate) fn assert_one_yocto() {
    assert_eq!(
        env::attached_deposit(),
        ONE_YOCTO,
        "Requires attached deposit of exactly 1 yoctoNEAR"
    )
}

'''
'''--- contract-rs/wonderland/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, log, near_bindgen, AccountId, Balance, PanicOnDefault, Promise, Timestamp};

pub mod account;
pub use crate::account::*;

pub mod board;
pub use crate::board::*;

mod internal;
use crate::internal::*;

mod liquidity;
pub use crate::liquidity::*;

mod types;
use types::*;

mod fungible_token;
pub use crate::fungible_token::*;

near_sdk::setup_alloc!();

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ContractConfig {
    pub ft_account_id: ValidAccountId,
    pub app_owner_id: ValidAccountId,

    pub app_liquidity_denominator: U128,
    pub pixel_coef_denominator: U128,
    pub draw_fee_denominator: U128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Stats {
    pub ft_draw_fee: U128,
    pub ft_draw_spent: U128,
    pub ft_farmed: U128,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
#[borsh_init(touch)]
pub struct Contract {
    pub account_indices: LookupMap<AccountId, u32>,
    pub accounts: LookupMap<u32, UpgradableAccount>,
    pub num_accounts: u32,

    pub board: board::PixelBoard,

    pub config: ContractConfig,
    pub stats: Stats,

    pub ft_farmed_per_pixel: FarmRatio,
    pub last_timestamp_touched: Timestamp,

    pub ft_pool: TokenBalance,
    pub l_pool: TokenBalance,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(config: ContractConfig) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        let mut this = Self {
            account_indices: LookupMap::new(b"i".to_vec()),
            accounts: LookupMap::new(b"u".to_vec()),
            num_accounts: 0,

            board: PixelBoard::new(),

            config,

            stats: Stats {
                ft_draw_fee: U128(0),
                ft_draw_spent: U128(0),
                ft_farmed: U128(0),
            },

            ft_farmed_per_pixel: 0,
            last_timestamp_touched: env::block_timestamp(),

            ft_pool: 0,
            l_pool: 0,
        };

        let mut account = this.get_mut_account(this.config.app_owner_id.clone().into());
        account.num_pixels = TOTAL_NUM_PIXELS;
        this.save_account(account);

        this
    }

    pub fn draw(&mut self, pixels: Vec<SetPixelRequest>) {
        if pixels.is_empty() {
            return;
        }
        let mut account = self.get_mut_account(env::predecessor_account_id());
        let new_pixels = pixels.len() as u32;

        // Computing pixel price
        let mut ft_amount = 0;
        let mut ft_draw_fee = 0;
        for _i in 0..new_pixels {
            let pixel_ft = self.ft_pool / self.config.pixel_coef_denominator.0;
            ft_amount += pixel_ft;
            let pixel_ft_draw_fee = pixel_ft / self.config.draw_fee_denominator.0;
            ft_draw_fee += pixel_ft_draw_fee;
            self.ft_pool += pixel_ft - pixel_ft_draw_fee;
        }

        account.charge(ft_amount);
        self.stats.ft_draw_fee.0 += ft_draw_fee;
        self.stats.ft_draw_spent.0 += ft_amount;

        let mut old_owners = self.board.set_pixels(account.account_index, &pixels);
        let replaced_pixels = old_owners.remove(&account.account_index).unwrap_or(0);
        account.num_pixels += new_pixels - replaced_pixels;
        self.save_account(account);

        for (account_index, num_pixels) in old_owners {
            let mut account = self.get_internal_account_by_index(account_index).unwrap();
            self.touch_account(&mut account);
            account.num_pixels -= num_pixels;
            self.save_account(account);
        }
    }

    pub fn get_config(self) -> ContractConfig {
        self.config
    }

    pub fn get_stats(self) -> Stats {
        self.stats
    }
}

impl Contract {
    pub fn touch(&mut self) {
        let timestamp = env::block_timestamp();
        let time_diff = timestamp - self.last_timestamp_touched;
        self.last_timestamp_touched = timestamp;
        if self.ft_pool <= MIN_FT_POOL {
            return;
        }
        // TODO: Magic formula
        let added_ft_farmed_per_pixel = 0;
        let ft_amount = added_ft_farmed_per_pixel * FarmRatio::from(BOARD_HEIGHT * BOARD_WIDTH);
        self.ft_farmed_per_pixel += added_ft_farmed_per_pixel;
        self.ft_pool -= ft_amount;
    }
}

'''
'''--- contract-rs/wonderland/src/liquidity.rs ---
use crate::*;

pub const MIN_FT_POOL: TokenBalance = 1_000_000_000_000_000_000;

#[near_bindgen]
impl Contract {
    #[payable]
    pub fn add_liquidity(&mut self, ft_amount: TokenBalance, min_l_amount: TokenBalance) {
        assert_one_yocto();
        self.touch();
        let mut account = self.get_mut_account(env::predecessor_account_id());
        assert_ne!(
            account.account_index, 0,
            "The app owner can't add or remove liquidity"
        );
        if account.ft_balance < ft_amount {
            env::panic(b"Not enough FT balance on the account");
        }
        account.ft_balance -= ft_amount;

        let new_ft_pool = self.ft_pool + ft_amount;
        if new_ft_pool < MIN_FT_POOL {
            env::panic(
                format!(
                    "The new FT pool {} has to be above MIN_FT_POOL {}",
                    new_ft_pool, MIN_FT_POOL
                )
                .as_bytes(),
            );
        }

        let l_amount = self.internal_l_from_ft(ft_amount);
        if l_amount < min_l_amount {
            env::panic(
                format!(
                    "The resulting L {} is lower than {}",
                    l_amount, min_l_amount
                )
                .as_bytes(),
            );
        }

        let app_l_amount = l_amount / self.config.app_liquidity_denominator.0;
        account.l_balance += l_amount - app_l_amount;
        log!("Minted {} L for {} FT", l_amount, ft_amount);

        self.l_pool += l_amount;
        self.ft_pool += ft_amount;

        self.save_account(account);

        let mut app_account = self.get_app_account();
        app_account.l_balance += app_l_amount;
        self.save_account(app_account);
    }

    #[payable]
    pub fn remove_liquidity(&mut self, l_amount: TokenBalance, min_ft_amount: TokenBalance) {
        assert_one_yocto();
        self.touch();
        let mut account = self.get_mut_account(env::predecessor_account_id());
        assert_ne!(
            account.account_index, 0,
            "The app owner can't add or remove liquidity"
        );
        if account.l_balance < l_amount {
            env::panic(b"Not enough L balance on the account");
        }
        account.l_balance -= l_amount;

        let ft_amount = self.internal_ft_from_l(l_amount);

        if ft_amount < min_ft_amount {
            env::panic(
                format!(
                    "The resulting FT {} is lower than {}",
                    ft_amount, min_ft_amount
                )
                .as_bytes(),
            );
        }

        self.ft_pool -= ft_amount;
        if self.ft_pool < MIN_FT_POOL {
            env::panic(
                format!(
                    "The new FT pool {} has to be above MIN_FT_POOL {}",
                    self.ft_pool, MIN_FT_POOL
                )
                .as_bytes(),
            );
        }

        account.ft_balance -= ft_amount;
        log!("Burned {} L for {} FT", l_amount, ft_amount);

        self.l_pool -= l_amount;

        self.save_account(account);
    }
}

impl Contract {
    pub fn internal_ft_from_l(&self, l_amount: TokenBalance) -> TokenBalance {
        if self.ft_pool < MIN_FT_POOL {
            env::panic(
                format!(
                    "The FT pool {} has to be above MIN_FT_POOL {}",
                    self.ft_pool, MIN_FT_POOL
                )
                .as_bytes(),
            );
        }
        (U256::from(l_amount) * U256::from(self.ft_pool) / U256::from(self.l_pool)).as_u128()
    }

    pub fn internal_l_from_ft(&self, ft_amount: TokenBalance) -> TokenBalance {
        if self.ft_pool < MIN_FT_POOL {
            return ft_amount;
        }
        (U256::from(ft_amount) * U256::from(self.l_pool) / U256::from(self.ft_pool)).as_u128()
    }
}

'''
'''--- contract-rs/wonderland/src/types.rs ---
use uint::construct_uint;

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

pub type FarmRatio = u128;

pub type TokenBalance = u128;

pub type AccountIndex = u32;

'''
'''--- frontend/README.md ---
This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `yarn start`

Runs the app in the development mode.<br />
Open [http://localhost:3000](http://localhost:3000) to view it in the browser.

The page will reload if you make edits.<br />
You will also see any lint errors in the console.

### `yarn test`

Launches the test runner in the interactive watch mode.<br />
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `yarn build`

Builds the app for production to the `build` folder.<br />
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.<br />
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `yarn eject`

**Note: this is a one-way operation. Once you `eject`, you can‚Äôt go back!**

If you aren‚Äôt satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you‚Äôre on your own.

You don‚Äôt have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn‚Äôt feel obligated to use this feature. However we understand that this tool wouldn‚Äôt be useful if you couldn‚Äôt customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: https://facebook.github.io/create-react-app/docs/code-splitting

### Analyzing the Bundle Size

This section has moved here: https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size

### Making a Progressive Web App

This section has moved here: https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app

### Advanced Configuration

This section has moved here: https://facebook.github.io/create-react-app/docs/advanced-configuration

### Deployment

This section has moved here: https://facebook.github.io/create-react-app/docs/deployment

### `yarn build` fails to minify

This section has moved here: https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify

'''
'''--- frontend/package.json ---
{
  "name": "frontend",
  "version": "0.2.0",
  "homepage": "https://berryclub.io",
  "private": true,
  "dependencies": {
    "@testing-library/jest-dom": "^4.2.4",
    "@testing-library/react": "^9.3.2",
    "@testing-library/user-event": "^7.1.2",
    "bn.js": "^5.1.1",
    "near-api-js": "^0.32.0",
    "node-sass": "^4.0.0",
    "react": "^16.13.1",
    "react-bootstrap": "^1.0.0",
    "react-color": "^2.18.1",
    "react-dom": "^16.13.1",
    "react-files": "^2.4.8",
    "react-scripts": "3.4.0",
    "react-switch": "^5.0.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "deploy": "yarn build && gh-pages -d build"
  },
  "eslintConfig": {
    "extends": "react-app"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "gh-pages": "^2.2.0"
  }
}

'''
'''--- frontend/public/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Berry Club - eat ü•ë - draw pixels - farm üçå - talk through ü•ù"
    />
    <meta name="twitter:card" content="summary_large_image" />
    <meta property="og:image" content="https://wayback.berryclub.io/img/"/>
    <meta property="og:url" content="https://berryclub.io/" />
    <meta property="og:title" content="Berry Club" />
    <meta property="og:description" content="Eat ü•ë - draw pixels - farm üçå - talk through ü•ù" />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/favicon.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>Berry Club üçå</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

'''
'''--- frontend/public/manifest.json ---
{
  "short_name": "Berry Club",
  "name": "Berry Club - eat berry - draw pixel",
  "icons": [
    {
      "src": "favicon.png",
      "sizes": "256x256",
      "type": "image/png"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

'''
'''--- frontend/public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

'''
'''--- frontend/src/App.js ---
import "./App.scss";
import "./gh-fork-ribbon.css";
import React from 'react';
import BN from 'bn.js';
import * as nearAPI from 'near-api-js'
import { AlphaPicker, HuePicker, GithubPicker } from 'react-color'
import Switch from "react-switch"

const PixelPrice = new BN("10000000000000000000000");
const IsMainnet = false; // window.location.hostname === "berryclub.io";
const TestNearConfig = {
  networkId: 'testnet',
  nodeUrl: 'https://rpc.testnet.near.org',
  contractName: 'dev-1615590559953-5504799',
  walletUrl: 'https://wallet.testnet.near.org',
};
const MainNearConfig = {
  networkId: 'mainnet',
  nodeUrl: 'https://rpc.mainnet.near.org',
  contractName: 'berryclub.ek.near',
  walletUrl: 'https://wallet.near.org',
};
const NearConfig = IsMainnet ? MainNearConfig : TestNearConfig;

const BoardHeight = 50;
const BoardWidth = 50;
const NumLinesPerFetch = 10;
const ExpectedLineLength = 4 + 8 * BoardWidth;
const CellWidth = 12;
const CellHeight = 12;
const MaxNumColors = 31;
const BatchOfPixels = 100;
// 500 ms
const BatchTimeout = 500;
const RefreshBoardTimeout = 1000;
const MaxWorkTime = 10 * 60 * 1000;

const intToColor = (c) => `#${c.toString(16).padStart(6, '0')}`;
const intToColorWithAlpha = (c, a) => `#${c.toString(16).padStart(6, '0')}${Math.round(255 * a).toString(16).padStart(2, '0')}`;

const rgbaToInt = (cr, cg, cb, ca, bgColor) => {
  const bb = (bgColor & 255);
  const bg = ((bgColor >> 8) & 255);
  const br = ((bgColor >> 16) & 255);

  const r = Math.round(cr * ca + br * (1 - ca));
  const g = Math.round(cg * ca + bg * (1 - ca));
  const b = Math.round(cb * ca + bb * (1 - ca));
  return (r << 16) + (g << 8) + b;
}

const imgColorToInt = (c, bgColor) => {
  const cr = (c & 255);
  const cg = ((c >> 8) & 255);
  const cb = ((c >> 16) & 255);
  const ca = ((c >> 24) & 255) / 255;
  return rgbaToInt(cr, cg, cb, ca, bgColor);
}

  const int2hsv = (cInt) => {
  cInt = intToColor(cInt).substr(1)
  const r = parseInt(cInt.substr(0, 2), 16) / 255
  const g = parseInt(cInt.substr(2, 2), 16) / 255
  const b = parseInt(cInt.substr(4, 2), 16) / 255
  let v=Math.max(r,g,b), c=v-Math.min(r,g,b);
  let h= c && ((v===r) ? (g-b)/c : ((v===g) ? 2+(b-r)/c : 4+(r-g)/c));
  return [60*(h<0?h+6:h), v&&c/v, v];
}
const transparentColor = (c, a) => `rgba(${(c >> 16) / 1}, ${((c >> 8) & 0xff) / 1}, ${(c & 0xff) / 1}, ${a})`
const generateGamma = (hue) => {
  const gammaColors = [];
  for (let i = 0; i < MaxNumColors; ++i) {
    gammaColors.push(`hsl(${hue}, 100%, ${100 * i / (MaxNumColors - 1)}%)`);
  }
  return gammaColors;
};
const decodeLine = (line) => {
  let buf = Buffer.from(line, 'base64');
  if (buf.length !== ExpectedLineLength) {
    throw new Error("Unexpected encoded line length");
  }
  let pixels = []
  for (let i = 4; i < buf.length; i += 8) {
    let color = buf.readUInt32LE(i);
    let ownerIndex = buf.readUInt32LE(i + 4);
    pixels.push({
      color,
      ownerIndex,
    })
  }
  return pixels;
};

class App extends React.Component {
  constructor(props) {
    super(props);

    const colors = ["#000000", "#666666", "#aaaaaa", "#FFFFFF", "#F44E3B", "#D33115", "#9F0500", "#FE9200", "#E27300", "#C45100", "#FCDC00", "#FCC400", "#FB9E00", "#DBDF00", "#B0BC00", "#808900", "#A4DD00", "#68BC00", "#194D33", "#68CCCA", "#16A5A5", "#0C797D", "#73D8FF", "#009CE0", "#0062B1", "#AEA1FF", "#7B64FF", "#653294", "#FDA1FF", "#FA28FF", "#AB149E"].map((c) => c.toLowerCase());
    const currentColor = parseInt(colors[Math.floor(Math.random() * colors.length)].substring(1), 16);
    // const currentColor = parseInt(colors[0].substring(1), 16);
    const defaultAlpha = 1;

    this.state = {
      connected: false,
      signedIn: false,
      accountId: null,
      pendingPixels: 0,
      boardLoaded: false,
      selectedCell: null,
      alpha: defaultAlpha,
      currentColor,
      pickerColor: intToColorWithAlpha(currentColor, defaultAlpha),
      colors,
      gammaColors: generateGamma(0),
      pickingColor: false,
      owners: [],
      accounts: {},
      highlightedAccountIndex: -1,
      selectedOwnerIndex: false,
      showDepositDialog: false,
      showWithdrawDialog: false,
    };

    this._buttonDown = false;
    this._oldCounts = {};
    this._numFailedTxs = 0;
    this._balanceRefreshTimer = null;
    this.canvasRef = React.createRef();
    this._context = false;
    this._lines = false;
    this._queue = [];
    this._pendingPixels = [];
    this._refreshBoardTimer = null;
    this._sendQueueTimer = null;
    this._stopRefreshTime = new Date().getTime() + MaxWorkTime;
    this._accounts = {};

    this._initNear().then(() => {
      this.setState({
        connected: true,
        signedIn: !!this._accountId,
        accountId: this._accountId,
        ircAccountId: this._accountId.replace('.', '_')
      });
    });
  }

  componentDidMount() {
    const canvas = this.canvasRef.current;
    this._context = canvas.getContext('2d');

    const click = async () => {
      if (this.state.rendering) {
        await this.drawImg(this.state.selectedCell);
      } else if (this.state.pickingColor) {
        this.pickColor(this.state.selectedCell);
      } else {
        this.saveColor();
        await this.drawPixel(this.state.selectedCell);
      }
    };

    const mouseMove = (e) => {
      let x, y;
      if ('touches' in e) {
        if (e.touches.length > 1) {
          return true;
        } else {
          const rect = e.target.getBoundingClientRect();
          x = e.targetTouches[0].clientX - rect.left;
          y = e.targetTouches[0].clientY - rect.top;
        }
      } else {
        x = e.offsetX;
        y = e.offsetY;
      }
      x = Math.trunc(x / e.target.clientWidth * BoardWidth);
      y = Math.trunc(y / e.target.clientHeight * BoardWidth);
      let cell = null;
      if (x >= 0 && x < BoardWidth && y >= 0 && y < BoardHeight) {
        cell = {x, y};
      }
      if (JSON.stringify(cell) !== JSON.stringify(this.state.selectedCell)) {
        this.setState({
          selectedCell: cell,
          selectedOwnerIndex: this._lines && cell && this._lines[cell.y] && this._lines[cell.y][cell.x].ownerIndex
        }, async () => {
          this.renderCanvas()
          if (this.state.selectedCell !== null && this._buttonDown) {
            await click();
          }
        })
      }
      e.preventDefault();
      return false;
    };

    canvas.addEventListener('mousemove', mouseMove);
    canvas.addEventListener('touchmove', mouseMove);

    const mouseDown = async (e) => {
      this._buttonDown = true;
      if (this.state.selectedCell !== null) {
        await click();
      }
    };

    canvas.addEventListener('mousedown', mouseDown);
    canvas.addEventListener('touchstart', mouseDown);

    const unselectCell = () => {
      this.setState({
        selectedCell: null,
      }, () => this.renderCanvas());
    }

    const mouseUp = async (e) => {
      this._buttonDown = false;
      if ('touches' in e) {
        unselectCell();
      }
    }

    canvas.addEventListener('mouseup', mouseUp);
    canvas.addEventListener('touchend', mouseUp);

    canvas.addEventListener('mouseleave', unselectCell);

    canvas.addEventListener('mouseenter', (e) => {
      if (this._buttonDown) {
        if (!('touches' in e) && !(e.buttons & 1)) {
          this._buttonDown = false;
        }
      }
    });

    document.addEventListener('keydown', (e) => {
      e.altKey && this.enablePickColor()
    })

    document.addEventListener('keyup', (e) => {
      !e.altKey && this.disablePickColor();
    })
  }

  enablePickColor() {
    this.setState({
      pickingColor: true,
    }, () => {
      this.renderCanvas()
    });
  }

  disablePickColor() {
    this.setState({
      pickingColor: false,
    }, () => {
      this.renderCanvas()
    });
  }

  pickColor(cell) {
    if (!this.state.signedIn || !this._lines || !this._lines[cell.y]) {
      return;
    }
    const color = this._lines[cell.y][cell.x].color;

    this.setState({
      currentColor: color,
      alpha: 1,
      pickerColor: intToColorWithAlpha(color, 1),
      gammaColors: generateGamma(int2hsv(color)[0]),
      pickingColor: false,
    }, () => {
      this.renderCanvas()
    });
  }

  async _sendQueue() {
    const pixels = this._queue.slice(0, BatchOfPixels);
    this._queue = this._queue.slice(BatchOfPixels);
    this._pendingPixels = pixels;

    try {
      await this._contract.draw({
        pixels
      }, new BN("75000000000000"));
      this._numFailedTxs = 0;
    } catch (error) {
      console.log("Failed to send a transaction", error);
      this._numFailedTxs += 1;
      if (this._numFailedTxs < 3) {
        this._queue = this._queue.concat(this._pendingPixels);
        this._pendingPixels = [];
      } else {
        this._pendingPixels = [];
        this._queue = [];
      }
    }
    try {
      await Promise.all([this.refreshBoard(true), this.refreshAccountStats()]);
    } catch (e) {
      // ignore
    }
    this._pendingPixels.forEach((p) => {
      if (this._pending[p.y][p.x] === p.color) {
        this._pending[p.y][p.x] = -1;
      }
    });
    this._pendingPixels = [];
  }

  async _pingQueue(ready) {
    if (this._sendQueueTimer) {
      clearTimeout(this._sendQueueTimer);
      this._sendQueueTimer = null;
    }

    if (this._pendingPixels.length === 0 && (this._queue.length >= BatchOfPixels || ready)) {
      await this._sendQueue();
    }
    if (this._queue.length > 0) {
      this._sendQueueTimer = setTimeout(async () => {
        await this._pingQueue(true);
      }, BatchTimeout);
    }

  }

  async drawImg(cell) {
    if (!this.state.signedIn || !this._lines || !this._lines[cell.y]) {
      return;
    }
    const balance = this.state.account ? this.state.account.avocadoBalance : 0;

    if (balance - this.state.pendingPixels < this.state.avocadoNeeded) {
      return;
    }

    const img = this.imageData;
    const w = img.width;
    const h = img.height;
    const x = cell.x - Math.trunc(w / 2);
    const y = cell.y - Math.trunc(h / 2);
    const d = new Uint32Array(this.imageData.data.buffer);
    for (let i = 0; i < h; ++i) {
      for (let j = 0; j < w; ++j) {
        const imgColor = d[i * w + j];
        if (imgColor && y + i >= 0 && y + i < BoardHeight && x + j >= 0 && x + j < BoardWidth) {
          const bgColor = this._lines[y + i] ? this._lines[y + i][x + j].color : 0;
          const color = imgColorToInt(imgColor, bgColor);
          if (color !== bgColor) {
            this._queue.push({
              x: x + j,
              y: y + i,
              color,
            });
          }
        }
      }
    }
    this.setState({
      rendering: false,
    })

    this._stopRefreshTime = new Date().getTime() + MaxWorkTime;
    await this._pingQueue(false);
  }

  async drawPixel(cell) {
    if (!this.state.signedIn || !this._lines || !this._lines[cell.y]) {
      return;
    }
    const balance = this.state.account ? this.state.account.avocadoBalance : 0;
    if (balance - this.state.pendingPixels < 1) {
      return;
    }

    const bgColor = this._lines[cell.y] ? this._lines[cell.y][cell.x].color : 0;
    const cb = (this.state.currentColor & 255);
    const cg = ((this.state.currentColor >> 8) & 255);
    const cr = ((this.state.currentColor >> 16) & 255);
    const color = rgbaToInt(cr, cg, cb, this.state.alpha, bgColor);

    if (this._pending[cell.y][cell.x] !== color && this._lines[cell.y][cell.x].color !== color) {
      this._pending[cell.y][cell.x] = color;
    } else {
      return;
    }

    this._queue.push({
      x: cell.x,
      y: cell.y,
      color,
    });

    this._stopRefreshTime = new Date().getTime() + MaxWorkTime;
    await this._pingQueue(false);
  }

  parseAccount(account, accountId) {
    if (!account) {
      account = {
        accountId,
        accountIndex: -1,
        ftBalance: 0.0,
        lBalance: 0.0,
        numPixels: 0,
      }
    } else {
      account = {
        accountId: account.account_id,
        accountIndex: account.account_index,
        ftBalance: parseFloat(account.ft_balance) / this._pixelCost,
        lBalance: parseFloat(account.l_balance) / this._pixelCost,
        numPixels: account.num_pixels,
      }
    }
    account.startTime = new Date().getTime();
    return account;
  }

  async getAccount(accountId) {
    return this.parseAccount(
      await this._contract.get_account({account_id: accountId}),
      accountId
    );
  }

  async getAccountByIndex(accountIndex) {
    return this.parseAccount(
      await this._contract.get_account_by_index({account_index: accountIndex}),
      "unknown",
    );
  }

  async refreshAccountStats() {
    let account = await this.getAccount(this._accountId);
    if (this._balanceRefreshTimer) {
      clearInterval(this._balanceRefreshTimer);
      this._balanceRefreshTimer = null;
    }

    this.setState({
      pendingPixels: this._pendingPixels.length + this._queue.length,
      account,
    });

    /*
    this._balanceRefreshTimer = setInterval(() => {
      const t = new Date().getTime() - account.startTime;
      this.setState({
        account: Object.assign({}, account, {
          avocadoBalance: account.avocadoBalance + t * account.avocadoRewardPerMs,
          bananaBalance: account.bananaBalance + t * account.bananaRewardPerMs,
        }),
        pendingPixels: this._pendingPixels.length + this._queue.length,
      });
    }, 100);
     */
  }

  async _initNear() {
    const keyStore = new nearAPI.keyStores.BrowserLocalStorageKeyStore();
    const near = await nearAPI.connect(Object.assign({deps: {keyStore}}, NearConfig));
    this._keyStore = keyStore;
    this._near = near;

    this._walletConnection = new nearAPI.WalletConnection(near, NearConfig.contractName);
    this._accountId = this._walletConnection.getAccountId();

    this._account = this._walletConnection.account();
    this._contract = new nearAPI.Contract(this._account, NearConfig.contractName, {
      viewMethods: ['get_account', 'get_account_by_index', 'get_lines', 'get_line_versions', 'get_config', 'get_stats'],
      changeMethods: ['draw', 'buy_tokens', 'select_farming_preference'],
    });
    const config = await this._contract.get_config();
    this.config = {
      appAccountId: config.app_account_id,
      ftAccountId: config.ft_account_id,
      appLiquidity: 1 / parseFloat(config.app_liquidity_denominator),
      pixelCoef: 1 / parseFloat(config.pixel_coef_denominator),
      drawFee: 1 / parseFloat(config.draw_fee_denominator),
    }

    this._ftContract = new nearAPI.Contract(this._account, NearConfig.contractName, {
      viewMethods: ['ft_balance_of'],
      changeMethods: ['ft_transfer_call'],
    });

    this._pixelCost = 1e18;
    if (this._accountId) {
      await this.refreshAccountStats();
    }
    this._lineVersions = Array(BoardHeight).fill(-1);
    this._lines = Array(BoardHeight).fill(false);
    this._pending = Array(BoardHeight).fill(false);
    this._pending.forEach((v, i, a) => a[i] = Array(BoardWidth).fill(-1));
    await this.refreshBoard(true);
  }

  async refreshBoard(forced) {
    if (this._refreshBoardTimer) {
      clearTimeout(this._refreshBoardTimer);
      this._refreshBoardTimer = null;
    }
    const t = new Date().getTime();
    if (t < this._stopRefreshTime) {
      this._refreshBoardTimer = setTimeout(async () => {
        await this.refreshBoard(false);
      }, RefreshBoardTimeout);
    }

    if (!forced && document.hidden) {
      return;
    }

    let lineVersions = await this._contract.get_line_versions();
    let needLines = [];
    for (let i = 0; i < BoardHeight; ++i) {
      if (lineVersions[i] !== this._lineVersions[i]) {
        needLines.push(i);
      }
    }
    let requestLines = []
    for (let i = 0; i < needLines.length; i += NumLinesPerFetch) {
      requestLines.push(needLines.slice(i, i + NumLinesPerFetch));
    }

    let results = await Promise.all(requestLines.map(lines => this._contract.get_lines({lines})));
    results = results.flat();
    requestLines = requestLines.flat();
    for (let i = 0; i < requestLines.length; ++i) {
      let lineIndex = requestLines[i];
      let line = decodeLine(results[i]);
      this._lines[lineIndex] = line;
    }

    this._lineVersions = lineVersions;
    this._refreshOwners();
    this.renderCanvas();
  }

  _refreshOwners() {
    const counts = {};
    this._lines.flat().forEach((cell) => {
      counts[cell.ownerIndex] = (counts[cell.ownerIndex] || 0) + 1;
    })
    delete counts[0];
    const sortedKeys = Object.keys(counts).sort((a, b) => counts[b] - counts[a]);
    this.setState({
      owners: sortedKeys.map((accountIndex) => {
        accountIndex = parseInt(accountIndex);
        return {
          accountIndex,
          numPixels: counts[accountIndex],
        }
      })
    })
    sortedKeys.forEach(async (accountIndex) => {
      accountIndex = parseInt(accountIndex);
      if (!(accountIndex in this._accounts) || counts[accountIndex] !== (this._oldCounts[accountIndex] || 0)) {
        try {
          this._accounts[accountIndex] = await this.getAccountByIndex(accountIndex);
        } catch (err) {
          console.log("Failed to fetch account index #", accountIndex, err)
        }
        this.setState({
          accounts: Object.assign({}, this._accounts),
        })
      }
    })
    this.setState({
      accounts: Object.assign({}, this._accounts),
    })
    this._oldCounts = counts;
  }

  renderCanvas() {
    if (!this._context || !this._lines) {
      return;
    }

    const ctx = this._context;

    for (let i = 0; i < BoardHeight; ++i) {
      const line = this._lines[i];
      if (!line) {
        continue;
      }
      for (let j = 0; j < BoardWidth; ++j) {
        const p = line[j];
        ctx.fillStyle = intToColor(p.color);
        ctx.fillRect(j * CellWidth, i * CellHeight, CellWidth, CellHeight);
        if (this.state.highlightedAccountIndex >= 0) {
          if (p.ownerIndex !== this.state.highlightedAccountIndex) {
            ctx.fillStyle = 'rgba(32, 32, 32, 0.8)';
            ctx.fillRect(j * CellWidth, i * CellHeight, CellWidth / 2, CellHeight / 2);
            ctx.fillRect((j + 0.5) * CellWidth, (i + 0.5) * CellHeight, CellWidth / 2, CellHeight / 2);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(j * CellWidth, (i + 0.5) * CellHeight, CellWidth / 2, CellHeight / 2);
            ctx.fillRect((j + 0.5) * CellWidth, i * CellHeight, CellWidth / 2, CellHeight / 2);
          } else {
            ctx.beginPath();
            ctx.strokeStyle = ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 0.5;
            ctx.rect(j * CellWidth + 0.5, i * CellHeight + 0.5, CellWidth - 1, CellHeight - 1);
            ctx.stroke();
            ctx.closePath();
          }
        }
      }
    }

    this._pendingPixels.concat(this._queue).forEach((p) => {
      ctx.fillStyle = intToColor(p.color);
      ctx.fillRect(p.x * CellWidth, p.y * CellHeight, CellWidth, CellHeight);
    })

    if (this.state.selectedCell) {
      const c = this.state.selectedCell;
      if (this.state.rendering) {
        const img = this.imageData;
        const w = img.width;
        const h = img.height;
        const x = c.x - Math.trunc(w / 2);
        const y = c.y - Math.trunc(h / 2);
        const d = new Uint32Array(this.imageData.data.buffer);
        for (let i = 0; i < h; ++i) {
          for (let j = 0; j < w; ++j) {
            const color = d[i * w + j];
            if (color && y + i >= 0 && y + i < BoardHeight && x + j >= 0 && x + j < BoardWidth) {
              const bgColor = this._lines[y + i] ? this._lines[y + i][x + j].color : 0;
              ctx.fillStyle = intToColor(imgColorToInt(color, bgColor));
              ctx.fillRect((x + j) * CellWidth, (y + i) * CellHeight, CellWidth, CellHeight);
            }
          }
        }
      } else if (this.state.pickingColor) {
        const color = this._lines[c.y] ? this._lines[c.y][c.x].color : 0;
        ctx.beginPath();
        ctx.strokeStyle = ctx.fillStyle = transparentColor(color, 0.5);
        ctx.lineWidth = CellWidth * 4;
        ctx.arc((c.x + 0.5) * CellWidth, (c.y + 0.5) * CellHeight, CellWidth * 4, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.closePath();

        ctx.beginPath();
        ctx.strokeStyle = ctx.fillStyle = transparentColor(color, 1);
        ctx.lineWidth = CellWidth * 2;
        ctx.arc((c.x + 0.5) * CellWidth, (c.y + 0.5) * CellHeight, CellWidth * 4, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.closePath();
      } else {
        ctx.fillStyle = transparentColor(this.state.currentColor, 0.2);
        ctx.fillRect(c.x * CellWidth, 0, CellWidth, c.y * CellHeight);
        ctx.fillRect(c.x * CellWidth, (c.y + 1) * CellHeight, CellWidth, (BoardHeight - c.y - 1) * CellHeight);
        ctx.fillRect(0, c.y * CellHeight, c.x * CellWidth, CellHeight);
        ctx.fillRect((c.x + 1) * CellWidth, c.y * CellHeight, (BoardWidth - c.x - 1) * CellWidth, CellHeight);

        ctx.beginPath();
        ctx.lineWidth = 3;
        ctx.fillStyle = intToColor(this.state.currentColor);
        ctx.strokeStyle = intToColor(this.state.currentColor);
        ctx.rect(c.x * CellWidth, c.y * CellHeight, CellWidth, CellHeight);
        ctx.stroke();
        ctx.closePath();
      }

    }

    if (!this.state.boardLoaded) {
      this.setState({
        boardLoaded: true
      })
    }
  }

  async requestSignIn() {
    const appTitle = 'Berry Club';
    await this._walletConnection.requestSignIn(
      NearConfig.contractName,
      appTitle
    )
  }

  async logOut() {
    this._walletConnection.signOut();
    this._accountId = null;
    this.setState({
      signedIn: !!this._accountId,
      accountId: this._accountId,
    })
  }

  async alphaColorChange(c) {
    this.setState({
      alpha: c.rgb.a,
    }, () => {
      this.changeColor(c, c.rgb.a)
    });
  }

  hueColorChange(c) {
    this.setState({
      gammaColors: generateGamma(c.hsl.h)
    })
    this.changeColor(c)
  }

  saveColor() {
    const newColor = intToColor(this.state.currentColor);
    const index = this.state.colors.indexOf(newColor);
    if (index >= 0) {
      this.state.colors.splice(index, 1);
    }
    this.setState({
      colors: [newColor].concat(this.state.colors).slice(0, MaxNumColors)
    });
  }

  changeColor(c, alpha) {
    alpha = alpha || 1.0;
    const currentColor = c.rgb.r * 0x010000 + c.rgb.g * 0x000100 + c.rgb.b;
    c.hex = intToColorWithAlpha(currentColor, alpha);
    c.rgb.a = alpha;
    c.hsl.a = alpha;
    c.hsv.a = alpha;
    this.setState({
      pickerColor: c,
      alpha,
      currentColor,
    }, () => {
      this.renderCanvas();
    })
  }

  async buyTokens(amount) {
    const requiredBalance = PixelPrice.muln(amount);
    await this._contract.buy_tokens({}, new BN("30000000000000"), requiredBalance);
  }

  depositFt() {
    this.setState({
      showDepositDialog: true
    })
  }

  withdrawFt() {
    this.setState({
      showWithdrawDialog: true
    })
  }

  setHover(accountIndex, v) {
    if (v) {
      this.setState({
        highlightedAccountIndex: accountIndex,
      }, () => {
        this.renderCanvas();
      })
    } else if (this.state.highlightedAccountIndex === accountIndex) {
      this.setState({
        highlightedAccountIndex: -1,
      }, () => {
        this.renderCanvas();
      })
    }
  }

  render() {
    const content = !this.state.connected ? (
        <div>Connecting... <span className="spinner-grow spinner-grow-sm" role="status" aria-hidden="true" /></div>
    ) : (this.state.signedIn ? (
        <div>
          <div className="float-right">
            <button
              className="btn btn-outline-secondary"
              onClick={() => this.logOut()}>Log out ({this.state.accountId})</button>
          </div>
          <div className="your-balance">
            Balance: <Balance
              account={this.state.account}
              pendingPixels={this.state.pendingPixels}
              detailed={true}
          />
          </div>
          <div className="buttons">
            <button
              className="btn btn-primary"
              onClick={() => this.depositFt()}>Deposit FT
            </button>{' '}
            <button
              className="btn btn-primary"
              onClick={() => this.withdrawFt()}>Withdraw FT
            </button>{' '}
            <button
              className="btn btn-primary"
              onClick={() => this.addLiquidity()}>Add Liquidity
            </button>{' '}
            <button
              className="btn btn-primary"
              onClick={() => this.removeLiquidity()}>Remove Liquidity
            </button>{' '}
          </div>
          <div className="color-picker">
            <HuePicker color={ this.state.pickerColor } width="100%" onChange={(c) => this.hueColorChange(c)}/>
            <GithubPicker className="circle-picker" colors={this.state.gammaColors} color={ this.state.pickerColor } triangle='hide' width="100%" onChangeComplete={(c) => this.changeColor(c)}/>
            <GithubPicker className="circle-picker" colors={this.state.colors} color={ this.state.pickerColor } triangle='hide' width="100%" onChangeComplete={(c) => this.hueColorChange(c)}/>
          </div>
        </div>
    ) : (
        <div style={{marginBottom: "10px"}}>
          <button
              className="btn btn-primary"
              onClick={() => this.requestSignIn()}>Log in with NEAR Wallet</button>
        </div>
    ));
    return (
      <div>
        <div class="header">
          <h2>Wonderland</h2>{' '}
          {content}
        </div>
        <div className="container">
          <div className="row">
            <div>
              <div>
                <canvas ref={this.canvasRef}
                        width={600}
                        height={600}
                        className={this.state.boardLoaded ? "pixel-board" : "pixel-board c-animated-background"}>

                </canvas>
              </div>
            </div>
            <div className="leaderboard">
              <div>
                <Leaderboard
                  owners={this.state.owners}
                  accounts={this.state.accounts}
                  setHover={(accountIndex, v) => this.setHover(accountIndex, v)}
                  selectedOwnerIndex={this.state.selectedOwnerIndex}
                  highlightedAccountIndex={this.state.highlightedAccountIndex}
                />
              </div>
            </div>
          </div>
        </div>
        <a className="github-fork-ribbon right-bottom fixed" href="https://github.com/evgenykuzyakov/wonderland" data-ribbon="Fork me on GitHub"
           title="Fork me on GitHub">Fork me on GitHub</a>
      </div>
    );
  }
}

const Balance = (props) => {
  const account = props.account;
  if (!account) {
    return "";
  }
  const fraction = props.detailed ? 3: 1;
  return (
    <span className="balances font-small">
      <span className="font-weight-bold">{account.ftBalance.toFixed(fraction)}</span>{' '}FT{' '}
      <span className="font-weight-bold">{account.lBalance.toFixed(fraction)}</span>{' '}Liq{' '}
      {
        props.pendingPixels ? <span> ({props.pendingPixels} pending)</span> : ""
      }
    </span>
  );
};

const Leaderboard = (props) => {
  const owners = props.owners.map((owner) => {
    if (owner.accountIndex in props.accounts) {
      owner.account = props.accounts[owner.accountIndex];
    }
    return <Owner
      key={owner.accountIndex}
      {...owner}
      isSelected={owner.accountIndex === props.selectedOwnerIndex}
      setHover={(v) => props.setHover(owner.accountIndex, v)}
      isHighlighted={owner.accountIndex === props.highlightedAccountIndex}
    />
  })
  return (
    <table className="table table-hover table-sm"><tbody>{owners}</tbody></table>
  );
};

const Owner = (props) => {
  const account = props.account;
  return (
    <tr onMouseEnter={() => props.setHover(true)}
        onMouseLeave={() => props.setHover(false)}
        className={props.isSelected ? "selected" : ""}>
      <td>
        {account ? <Account accountId={account.accountId} /> : "..."}
      </td>
      <td className="text-nowrap">
        <small>
          <Balance account={account} />
        </small>
      </td>
    </tr>
  )
}

const Account = (props) => {
  const accountId = props.accountId;
  const shortAccountId = (accountId.length > 6 + 6 + 3) ?
    (accountId.slice(0, 6) + '...' + accountId.slice(-6)) :
    accountId;
  return <a className="account"
            href={`https://explorer.near.org/accounts/${accountId}`}>{shortAccountId}</a>
}

export default App;

'''
'''--- frontend/src/gh-fork-ribbon.css ---
/*!
 * "Fork me on GitHub" CSS ribbon v0.2.3 | MIT License
 * https://github.com/simonwhitaker/github-fork-ribbon-css
*/

.github-fork-ribbon {
  width: 12.1em;
  height: 12.1em;
  position: absolute;
  overflow: hidden;
  top: 0;
  right: 0;
  z-index: 9999;
  pointer-events: none;
  font-size: 13px;
  text-decoration: none;
  text-indent: -999999px;
}

.github-fork-ribbon.fixed {
  position: fixed;
}

.github-fork-ribbon:hover, .github-fork-ribbon:active {
  background-color: rgba(0, 0, 0, 0.0);
}

.github-fork-ribbon:before, .github-fork-ribbon:after {
  /* The right and left classes determine the side we attach our banner to */
  position: absolute;
  display: block;
  width: 15.38em;
  height: 1.54em;

  top: 3.23em;
  right: -3.23em;

  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  box-sizing: content-box;

  -webkit-transform: rotate(45deg);
  -moz-transform: rotate(45deg);
  -ms-transform: rotate(45deg);
  -o-transform: rotate(45deg);
  transform: rotate(45deg);
}

.github-fork-ribbon:before {
  content: "";

  /* Add a bit of padding to give some substance outside the "stitching" */
  padding: .38em 0;

  /* Set the base colour */
  background-color: #a00;

  /* Set a gradient: transparent black at the top to almost-transparent black at the bottom */
  background-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0, 0, 0, 0)), to(rgba(0, 0, 0, 0.15)));
  background-image: -webkit-linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
  background-image: -moz-linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
  background-image: -ms-linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
  background-image: -o-linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
  background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));

  /* Add a drop shadow */
  -webkit-box-shadow: 0 .15em .23em 0 rgba(0, 0, 0, 0.5);
  -moz-box-shadow: 0 .15em .23em 0 rgba(0, 0, 0, 0.5);
  box-shadow: 0 .15em .23em 0 rgba(0, 0, 0, 0.5);

  pointer-events: auto;
}

.github-fork-ribbon:after {
  /* Set the text from the data-ribbon attribute */
  content: attr(data-ribbon);

  /* Set the text properties */
  color: #fff;
  font: 700 1em "Helvetica Neue", Helvetica, Arial, sans-serif;
  line-height: 1.54em;
  text-decoration: none;
  text-shadow: 0 -.08em rgba(0, 0, 0, 0.5);
  text-align: center;
  text-indent: 0;

  /* Set the layout properties */
  padding: .15em 0;
  margin: .15em 0;

  /* Add "stitching" effect */
  border-width: .08em 0;
  border-style: dotted;
  border-color: #fff;
  border-color: rgba(255, 255, 255, 0.7);
}

.github-fork-ribbon.left-top, .github-fork-ribbon.left-bottom {
  right: auto;
  left: 0;
}

.github-fork-ribbon.left-bottom, .github-fork-ribbon.right-bottom {
  top: auto;
  bottom: 0;
}

.github-fork-ribbon.left-top:before, .github-fork-ribbon.left-top:after, .github-fork-ribbon.left-bottom:before, .github-fork-ribbon.left-bottom:after {
  right: auto;
  left: -3.23em;
}

.github-fork-ribbon.left-bottom:before, .github-fork-ribbon.left-bottom:after, .github-fork-ribbon.right-bottom:before, .github-fork-ribbon.right-bottom:after {
  top: auto;
  bottom: 3.23em;
}

.github-fork-ribbon.left-top:before, .github-fork-ribbon.left-top:after, .github-fork-ribbon.right-bottom:before, .github-fork-ribbon.right-bottom:after {
  -webkit-transform: rotate(-45deg);
  -moz-transform: rotate(-45deg);
  -ms-transform: rotate(-45deg);
  -o-transform: rotate(-45deg);
  transform: rotate(-45deg);
}

'''
'''--- frontend/src/index.css ---
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

'''
'''--- frontend/src/index.js ---
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';

ReactDOM.render(<App />, document.getElementById('root'));

'''