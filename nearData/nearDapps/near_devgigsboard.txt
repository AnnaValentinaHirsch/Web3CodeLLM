*GitHub Repository "near/devgigsboard"*

'''--- .devcontainer/devcontainer.json ---
{
    "image": "ghcr.io/near/near-devcontainer:latest",
    "customizations": {
        "vscode": {
            "extensions": [
                "dtsvet.vscode-wasm",
                "rust-lang.rust-analyzer",
                "github.vscode-github-actions"
            ]
        }
    },
    "postCreateCommand": "./.devcontainer/post-create.sh"
}

'''
'''--- .devcontainer/post-create.sh ---
#!/bin/bash

(cd discussions && cargo near build)
(cd community && cargo near build)
(cd community-factory && cargo near build)
cargo near build

'''
'''--- .github/workflows/main.yml ---
name: CI
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
jobs:
  rununittest:
    name: Unit tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - uses: Swatinem/rust-cache@v1
      - name: Install cargo-near
        run: curl --proto '=https' --tlsv1.2 -LsSf https://github.com/near/cargo-near/releases/latest/download/cargo-near-installer.sh | sh
      - name: Build discussions contract
        run: cd discussions && cargo near build
      - name: Build community contract
        run: cd community && cargo near build
      - name: Build community factory contract
        run: cd community-factory && cargo near build
      - name: Build devhub contract
        run: cargo near build
      - name: Unit tests
        run: cargo test

'''
'''--- .github/workflows/release.yml ---
name: Release
on:
  push:
    branches: [ main ]

jobs:
  deploy-devhub-contract:
    runs-on: ubuntu-latest
    name: Deploy contract to mainnet
    env:
      NEAR_NETWORK_CONNECTION: mainnet
      NEAR_DEVHUB_ACCOUNT_ID: ${{ vars.NEAR_GIGSBOARD_ACCOUNT_ID }}
      NEAR_DEVHUB_ACCOUNT_PUBLIC_KEY: ${{ vars.NEAR_GIGSBOARD_ACCOUNT_PUBLIC_KEY }}
      NEAR_DEVHUB_ACCOUNT_PRIVATE_KEY: ${{ secrets.NEAR_GIGSBOARD_ACCOUNT_PRIVATE_KEY }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    - uses: Swatinem/rust-cache@v1
    - name: Install cargo-near
      run: curl --proto '=https' --tlsv1.2 -LsSf https://github.com/near/cargo-near/releases/latest/download/cargo-near-installer.sh | sh
    - name: Build discussions contract
      run: cd discussions && cargo near build
    - name: Build community contract
      run: cd community && cargo near build
    - name: Build community factory contract
      run: cd community-factory && cargo near build
    - name: Build devhub contract
      run: cargo near build
    - name: Install near CLI
      run: |
        curl --proto '=https' --tlsv1.2 -LsSf https://github.com/near/near-cli-rs/releases/download/v0.3.1/near-cli-rs-v0.3.1-installer.sh | sh
    - name: Deploy contract
      run: |
        output=$(near contract call-function as-transaction "$NEAR_DEVHUB_ACCOUNT_ID" unsafe_self_upgrade file-args ./target/near/devhub.wasm prepaid-gas '200 TeraGas' attached-deposit '0 NEAR' sign-as "$NEAR_DEVHUB_ACCOUNT_ID" network-config "$NEAR_NETWORK_CONNECTION" sign-with-plaintext-private-key --signer-public-key "$NEAR_DEVHUB_ACCOUNT_PUBLIC_KEY" --signer-private-key "$NEAR_DEVHUB_ACCOUNT_PRIVATE_KEY" send)
        while [[ ! "$output" == *"Migration done."* ]]; do
          echo "$output"
          sleep 5
          output=$(near contract call-function as-transaction "$NEAR_DEVHUB_ACCOUNT_ID" unsafe_migrate json-args '{}' prepaid-gas '100 TeraGas' attached-deposit '0 NEAR' sign-as "$NEAR_DEVHUB_ACCOUNT_ID" network-config "$NEAR_NETWORK_CONNECTION" sign-with-plaintext-private-key --signer-public-key "$NEAR_DEVHUB_ACCOUNT_PUBLIC_KEY" --signer-private-key "$NEAR_DEVHUB_ACCOUNT_PRIVATE_KEY" send)
        done
        echo "$output"

'''
'''--- Cargo.toml ---
[package]
name = "devhub"
version = "0.2.0"
authors = ["NEAR DevHub <neardevhub.org>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "5.1.0"
near-contract-standards = "5.1.0"
serde_json = { version = "1.0", features = ["preserve_order"] }
devhub_common = { path = "./devhub_common" }

[dev-dependencies]
near-sdk = { version = "5.1.0", features = ["unit-testing"] }
insta = { version = "1.31.0", features = ["json", "redactions"] }
regex = "1"
near-workspaces = { version = "0.10.0", features = ["unstable"], default-features = false  }
tokio = { version = "1.10.0", features = ["full"] }
anyhow = "1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- README.md ---
# NEAR DevHub Contract

## Overview

The smart contract responsible for managing the communities, posts, and permissions made available via the [NEAR DevHub frontend](https://neardevhub.org). The repository for the frontend widgets can be found [here](https://github.com/NEAR-DevHub/neardevhub-bos).

## Getting Started

### Prerequisites

Before starting, make sure you have the following installed:

1. [cargo-near](https://github.com/near/cargo-near), to easily create testnet accounts, build and deploy contracts.
2. [NEAR CLI RS](https://github.com/near/near-cli-rs), to interact with the contract.

## Building

From the root directory, run:

```sh
cd discussions
cargo near build
cd ../community
cargo near build
cd ../community-factory
cargo near build
cd ..
cargo near build
```

## Running Tests

From the root directory, run:

```sh
cargo test
```

## Deploying

Using [cargo-near](https://github.com/near/cargo-near), run the following command. Be sure to set your own account id and corresponding network.

```sh
cargo near deploy {{account.near}}
cd community-factory
cargo near deploy {{community.account.near}}
```

'''
'''--- community-factory/Cargo.toml ---
[package]
name = "devhub-community-factory"
version = "0.1.0"
authors = ["NEAR DevHub <neardevhub.org>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "5.1.0"
devhub_common = { path = "../devhub_common" }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- community-factory/src/lib.rs ---
use near_sdk::{env, near, require, AccountId, Gas, NearToken, Promise};
use near_sdk::serde_json::json;

use devhub_common::social_db_contract;

const CODE: &[u8] = include_bytes!("../../community/target/near/devhub_community.wasm");
const INITIAL_BALANCE: NearToken = NearToken::from_near(4);
const PUBKEY_STR: &str = "ed25519:4deBAvg1S4MF7qe9GBDJwDCGLyyXtJa73JnMXwyG9vsB";

#[near(contract_state)]
#[derive(Default)]
pub struct Contract {}

#[near]
impl Contract {
    #[payable]
    pub fn create_community_account(&mut self, community: String) -> Promise {
        let parent_account: AccountId = env::current_account_id()
            .get_parent_account_id()
            .expect("Community factory should be deployed on a child account")
            .into();
        require!(
            env::predecessor_account_id() == parent_account,
            "Can only be called from parent contract"
        );
        require!(
            env::attached_deposit() >= INITIAL_BALANCE,
            "Require 4 NEAR to create community account"
        );

        let community_account_id: AccountId =
            format!("{}.{}", community, env::current_account_id()).parse().unwrap();

        let pubkey = PUBKEY_STR.parse().unwrap();
        Promise::new(community_account_id.clone())
            .create_account()
            .add_full_access_key(pubkey)
            .transfer(INITIAL_BALANCE)
            .deploy_contract(CODE.to_vec())
            .function_call(
                "new".to_string(),
                b"{}".to_vec(),
                NearToken::from_near(0),
                Gas::from_tgas(50),
            )
            .then(
                self.subscribe_to_community_accounts(community_account_id)
            )
    }

    pub fn subscribe_to_community_accounts(&mut self, community_account_id: AccountId) -> Promise {
        let community_factory_account = env::current_account_id();
        let discussions_account_id: AccountId =
            format!("discussions.{}", community_account_id.clone()).parse().unwrap();

        social_db_contract()
            .with_static_gas(env::prepaid_gas().saturating_div(3))
            .with_attached_deposit(env::attached_deposit())
            .set(json!({
                community_factory_account: {
                    "graph": {
                        "follow": {
                            community_account_id.clone(): "",
                            discussions_account_id.clone(): "",
                        }
                    },
                    "index": {
                        "graph": json!([
                            {
                                "key": "follow",
                                "value": {
                                    "type": "follow",
                                    "accountId": community_account_id
                                }
                            },
                            {
                                "key": "follow",
                                "value": {
                                    "type": "follow",
                                    "accountId": discussions_account_id
                                }
                            }
                        ]).to_string()
                    }                  
                },
            }))
    }
}

'''
'''--- community/Cargo.toml ---
[package]
name = "devhub-community"
version = "0.1.0"
authors = ["NEAR DevHub <neardevhub.org>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "5.1.0"
devhub_common = { path = "../devhub_common" }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- community/src/lib.rs ---
use devhub_common::social_db_contract;
use near_sdk;
use near_sdk::Gas;
use near_sdk::{env, near, require, AccountId, NearToken, Promise};

const CODE: &[u8] = include_bytes!("../../discussions/target/near/devhub_discussions.wasm");
const PUBKEY_STR: &str = "ed25519:4deBAvg1S4MF7qe9GBDJwDCGLyyXtJa73JnMXwyG9vsB";

#[near(contract_state)]
#[derive(Default)]
pub struct Contract {}

#[near]
impl Contract {
    #[payable]
    pub fn new(&mut self) -> Promise {
        social_db_contract()
            .with_unused_gas_weight(1)
            .with_attached_deposit(NearToken::from_near(1))
            .grant_write_permission(
                Some(Contract::get_devhub_account()),
                None,
                vec![env::current_account_id().to_string()],
            )
            .then(self.create_discussions_account())
    }

    pub fn destroy(&mut self) -> Promise {
        let devhub_account = Contract::get_devhub_account();
        require!(
            env::predecessor_account_id() == devhub_account,
            "Can only destroy community account from DevHub contract"
        );
        Promise::new(env::current_account_id()).delete_account(devhub_account)
    }

    fn get_devhub_account() -> AccountId {
        env::current_account_id()
            .get_parent_account_id()
            .expect("Community contract should be deployed on a child account")
            .get_parent_account_id()
            .expect("Community factory should be deployed on a child account")
            .into()
    }

    pub fn create_discussions_account(&mut self) -> Promise {
        let account_id: AccountId =
            format!("discussions.{}", env::current_account_id()).parse().unwrap();

        let pubkey = PUBKEY_STR.parse().unwrap();
        Promise::new(account_id)
            .create_account()
            .add_full_access_key(pubkey)
            .transfer(NearToken::from_near(2))
            .deploy_contract(CODE.to_vec())
            .function_call(
                "new".to_string(),
                b"{}".to_vec(),
                NearToken::from_near(0),
                Gas::from_tgas(20),
            )
    }
}

'''
'''--- devhub_common/Cargo.toml ---
[package]
name = "devhub_common"
version = "0.1.0"
edition = "2021"

[dependencies]
near-sdk = "5.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- devhub_common/src/lib.rs ---
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json::Value;
use near_sdk::{env, ext_contract, AccountId, PublicKey, NearSchema};

#[derive(Copy, Clone, Serialize, Deserialize, NearSchema)]
#[serde(crate = "near_sdk::serde")]
pub struct SetReturnType {
    pub block_height: near_sdk::json_types::U64,
}

#[ext_contract(ext_social_db)]
pub trait SocialDB {
    fn set(&mut self, data: Value) -> SetReturnType;
    fn grant_write_permission(
        &mut self,
        predecessor_id: Option<AccountId>,
        public_key: Option<PublicKey>,
        keys: Vec<String>,
    );
}

pub fn social_db_contract() -> ext_social_db::SocialDBExt {
    let social_db: AccountId = if env::current_account_id().to_string().ends_with("testnet") {
        "v1.social08.testnet"
    } else {
        "social.near"
    }
    .parse()
    .unwrap();
    ext_social_db::ext(social_db)
}

'''
'''--- discussions/Cargo.toml ---
[package]
name = "devhub-discussions"
version = "0.1.0"
authors = ["NEAR DevHub <neardevhub.org>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "5.1.0"
devhub_common = { path = "../devhub_common" }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- discussions/src/lib.rs ---
use devhub_common::social_db_contract;
use near_sdk::{env, require, near, AccountId, NearToken, Promise};

#[near(contract_state)]
#[derive(Default)]
pub struct Contract {}

#[near]
impl Contract {
    #[init]
    pub fn new() -> Self {
        social_db_contract()
            .with_unused_gas_weight(1)
            .with_attached_deposit(NearToken::from_near(1))
            .grant_write_permission(
                Some(Contract::get_devhub_account()),
                None,
                vec![env::current_account_id().to_string()],
            )
            .as_return();
        Contract {}
    }

    pub fn destroy(&mut self) -> Promise {
        let devhub_account = Contract::get_devhub_account();
        require!(
            env::predecessor_account_id() == devhub_account,
            "Can only destroy community account from DevHub contract"
        );
        Promise::new(env::current_account_id()).delete_account(devhub_account)
    }

    /**
     * current_account_id = discussions.{{community}}.community.devhub.near
     * returns devhub.near
     */
    fn get_devhub_account() -> AccountId {
        env::current_account_id()
            .get_parent_account_id()
            .expect("Discussions contract should be deployed on a child account")
            .get_parent_account_id()
            .expect("Community contract should be deployed on a child account")
            .get_parent_account_id()
            .expect("Community factory should be deployed on a child account")
            .into()
    }
}

'''
'''--- rust-toolchain.toml ---
[toolchain]
channel = "1.75.0"
components = ["rustfmt"]
targets = ["wasm32-unknown-unknown"]

'''
'''--- rustfmt.toml ---
use_small_heuristics = "Max"
reorder_imports = true
edition = "2021"

'''
'''--- src/access_control/members.rs ---
use crate::access_control::rules::Rule;
use near_sdk::{near, AccountId};
use std::collections::hash_map::Entry;
use std::collections::{HashMap, HashSet};

#[near(serializers=[borsh, json])]
#[derive(Clone, Debug, PartialOrd, PartialEq, Ord, Eq, Hash)]
#[serde(from = "String")]
#[serde(into = "String")]
pub enum Member {
    /// NEAR account names do not allow `:` character so this structure cannot be abused.
    Account(AccountId),
    Team(String),
}

/// JSON string representation prefix of `Member::Team` variant.
const TEAM: &str = "team:";

impl From<String> for Member {
    fn from(full_str: String) -> Self {
        if let Some(s) = full_str.strip_prefix(TEAM) {
            Member::Team(s.to_string())
        } else {
            Member::Account(full_str.parse().unwrap())
        }
    }
}

impl Into<String> for Member {
    fn into(self) -> String {
        match self {
            Member::Account(s) => s.to_string(),
            Member::Team(s) => format!("{}{}", TEAM, s).to_string(),
        }
    }
}

#[near(serializers=[borsh, json])]
#[derive(Clone, Default, Debug, Eq, PartialEq)]
pub struct MemberMetadata {
    pub description: String,
    pub permissions: HashMap<Rule, HashSet<ActionType>>,
    pub children: HashSet<Member>,
    pub parents: HashSet<Member>,
}

#[near(serializers=[borsh, json])]
#[derive(Clone, PartialOrd, PartialEq, Ord, Eq, Hash, Debug)]
#[serde(rename_all = "kebab-case")]
pub enum ActionType {
    /// Can edit posts that have these labels.
    EditPost,
    /// Can add/remove labels that fall under these rules.
    UseLabels,
}

#[near(serializers=[borsh, json])]
#[derive(Clone, Debug, Eq, PartialEq)]
#[serde(tag = "member_metadata_version")]
pub enum VersionedMemberMetadata {
    V0(MemberMetadata),
}

impl VersionedMemberMetadata {
    pub fn last_version(&self) -> MemberMetadata {
        match self {
            VersionedMemberMetadata::V0(v0) => v0.clone(),
        }
    }
}

impl From<MemberMetadata> for VersionedMemberMetadata {
    fn from(m: MemberMetadata) -> Self {
        VersionedMemberMetadata::V0(m)
    }
}

#[near(serializers=[borsh, json])]
#[derive(Clone, Debug, Eq, PartialEq, Default)]
pub struct MembersList {
    #[serde(flatten)]
    pub members: HashMap<Member, VersionedMemberMetadata>,
}

impl MembersList {
    /// Get members that do not belong to any team.
    pub fn get_root_members(&self) -> HashMap<Member, VersionedMemberMetadata> {
        self.members
            .iter()
            .filter(|(_, v)| v.last_version().parents.is_empty())
            .map(|(k, v)| (k.clone(), v.clone()))
            .collect()
    }

    /// Whether given account has special permissions for a post with the given labels.
    /// Labels are restricted labels.
    pub fn check_permissions(
        &self,
        account: AccountId,
        labels: Vec<String>,
    ) -> HashSet<ActionType> {
        let member_account = Member::Account(account);
        if !self.members.contains_key(&member_account) {
            return HashSet::new();
        }

        let mut stack = HashSet::new();
        stack.insert(member_account);

        let mut permissions = HashSet::new();
        while let Some(member) = stack.iter().next().cloned() {
            stack.remove(&member);

            let metadata = self
                .members
                .get(&member)
                .unwrap_or_else(|| panic!("Metadata not found for {:#?}", member))
                .last_version();

            for (member_rule, member_permissions) in metadata.permissions {
                if member_rule.applies_to_any(&labels) {
                    permissions.extend(member_permissions);
                }
            }

            stack.extend(metadata.parents);
        }
        permissions
    }

    pub fn add_member(&mut self, member: Member, metadata: VersionedMemberMetadata) {
        assert!(
            self.members.insert(member.clone(), metadata.clone()).is_none(),
            "Member already exists"
        );

        // Update child members that this member is a parent of.
        for child in &metadata.last_version().children {
            match self.members.entry(child.clone()) {
                Entry::Occupied(mut occ) => {
                    let MemberMetadata { description, children, mut parents, permissions } =
                        occ.get().last_version();
                    assert!(parents.insert(member.clone()), "Child already had this parent");
                    let new_child = MemberMetadata { description, children, parents, permissions };
                    occ.insert(new_child.into());
                }
                Entry::Vacant(_) => {
                    panic!("Member declares a child {:#?} that does not exist", child)
                }
            }
        }

        // Update parent members that this member is now a child of.
        for parent in &metadata.last_version().parents {
            match self.members.entry(parent.clone()) {
                Entry::Occupied(mut occ) => {
                    let MemberMetadata { description, mut children, parents, permissions } =
                        occ.get().last_version();
                    assert!(children.insert(member.clone()), "Parent already had this child");
                    let new_parent = MemberMetadata { description, children, parents, permissions };
                    occ.insert(new_parent.into());
                }
                Entry::Vacant(_) => {
                    panic!("Member declares a parent {:#?} that does not exist", parent)
                }
            }
        }
    }

    pub fn remove_member(&mut self, member: &Member) {
        let metadata = self.members.remove(member).expect("Member does not exist");

        // Update child members that this member is not a parent of anymore.
        for child in &metadata.last_version().children {
            match self.members.entry(child.clone()) {
                Entry::Occupied(mut occ) => {
                    let MemberMetadata { description, children, mut parents, permissions } =
                        occ.get().last_version();
                    assert!(parents.remove(member), "Child did not have this parent.");
                    let new_child = MemberMetadata { description, children, parents, permissions };
                    occ.insert(new_child.into());
                }
                Entry::Vacant(_) => {
                    panic!("Member declares a child {:#?} that does not exist", child)
                }
            }
        }

        // Update parent members that this member is not a child of anymore.
        for parent in &metadata.last_version().parents {
            match self.members.entry(parent.clone()) {
                Entry::Occupied(mut occ) => {
                    let MemberMetadata { description, mut children, parents, permissions } =
                        occ.get().last_version();
                    assert!(children.remove(member), "Parent did not have this child.");
                    let new_parent = MemberMetadata { description, children, parents, permissions };
                    occ.insert(new_parent.into());
                }
                Entry::Vacant(_) => {
                    panic!("Member declares a parent {:#?} that does not exist", parent)
                }
            }
        }
    }

    pub fn edit_member(&mut self, member: Member, metadata: VersionedMemberMetadata) {
        self.remove_member(&member);
        self.add_member(member, metadata);
    }

    pub fn get_moderators(&self) -> HashSet<Member> {
        self.members
            .get(&Member::Team("moderators".to_string()))
            .map(|team| team.last_version().children)
            .unwrap_or(HashSet::new())
    }
}

#[cfg(test)]
mod tests {
    use crate::access_control::members::{
        ActionType, Member, MemberMetadata, MembersList, VersionedMemberMetadata,
    };
    use crate::access_control::rules::Rule;
    use near_sdk::serde_json;
    use std::collections::{HashMap, HashSet};

    #[test]
    fn member_serialization() {
        let member = Member::Account("alice.near".parse().unwrap());
        assert_eq!(serde_json::to_value(&member).unwrap(), serde_json::json!("alice.near"));

        let member = Member::Team("funding".to_string());
        assert_eq!(serde_json::to_value(&member).unwrap(), serde_json::json!("team:funding"));
    }

    #[test]
    fn member_deserialization() {
        let member: Member = serde_json::from_str(r#""alice.near""#).unwrap();
        assert_eq!(member, Member::Account("alice.near".parse().unwrap()));

        let member: Member = serde_json::from_str(r#""team:funding""#).unwrap();
        assert_eq!(member, Member::Team("funding".to_string()));
    }

    fn root_member() -> (Member, VersionedMemberMetadata) {
        (
            Member::Account("devgovgigs.near".parse().unwrap()),
            MemberMetadata {
                description: "Main account can do anything".to_string(),
                permissions: HashMap::from([
                    (
                        Rule::StartsWith("wg-".to_string()),
                        HashSet::from([ActionType::EditPost, ActionType::UseLabels]),
                    ),
                    (
                        Rule::StartsWith("funding".to_string()),
                        HashSet::from([ActionType::EditPost, ActionType::UseLabels]),
                    ),
                    (
                        Rule::StartsWith("mnw".to_string()),
                        HashSet::from([ActionType::EditPost, ActionType::UseLabels]),
                    ),
                ]),
                ..Default::default()
            }
            .into(),
        )
    }

    fn moderator_member(name: &str) -> (Member, VersionedMemberMetadata) {
        (
            Member::Account(name.parse().unwrap()),
            MemberMetadata {
                description: format!("{} inherits everything from moderator group.", name)
                    .to_string(),
                parents: HashSet::from([Member::Team("moderators".to_string())]),
                ..Default::default()
            }
            .into(),
        )
    }

    fn moderators() -> (Member, VersionedMemberMetadata) {
        (
            Member::Team("moderators".to_string()),
            MemberMetadata {
                description: "Moderators can do anything except funding posts.".to_string(),
                permissions: HashMap::from([
                    (
                        Rule::StartsWith("wg-".to_string()),
                        HashSet::from([ActionType::EditPost, ActionType::UseLabels]),
                    ),
                    (
                        Rule::StartsWith("mnw".to_string()),
                        HashSet::from([ActionType::EditPost, ActionType::UseLabels]),
                    ),
                ]),
                children: HashSet::from([
                    Member::Account("ori.near".parse().unwrap()),
                    Member::Account("max.near".parse().unwrap()),
                    Member::Account("vlad.near".parse().unwrap()),
                ]),
                ..Default::default()
            }
            .into(),
        )
    }

    fn create_list() -> MembersList {
        MembersList {
            members: HashMap::from([
                moderators(),
                root_member(),
                moderator_member("ori.near"),
                moderator_member("max.near"),
                moderator_member("vlad.near"),
            ]),
        }
    }

    #[test]
    fn get_root_members() {
        let list = create_list();
        let root_members: HashSet<_> = list.get_root_members().keys().cloned().collect();
        assert_eq!(
            root_members,
            HashSet::from([
                Member::Team("moderators".to_string()),
                Member::Account("devgovgigs.near".parse().unwrap())
            ])
        );
    }

    #[test]
    fn check_permissions() {
        let list = create_list();
        let actual = list.check_permissions(
            "max.near".parse().unwrap(),
            vec!["wg-protocol".to_string(), "funding-requested".to_string()],
        );
        assert_eq!(
            actual,
            serde_json::from_value::<HashSet<ActionType>>(serde_json::json!([
                "edit-post",
                "use-labels"
            ]))
            .unwrap()
        );

        let actual = list
            .check_permissions("max.near".parse().unwrap(), vec!["funding-requested".to_string()]);
        assert!(actual.is_empty());
    }

    #[test]
    fn check_permissions_rules_any() {
        let mut list = create_list();
        let given_permissions = HashSet::from([ActionType::EditPost, ActionType::UseLabels]);
        list.add_member(
            Member::Account("thomasguntenaar.near".parse().unwrap()),
            MemberMetadata {
                description: "Account has `Any` rules without labels".to_string(),
                permissions: HashMap::from([(Rule::Any(), given_permissions.clone())]),
                ..Default::default()
            }
            .into(),
        );
        // Without labels
        assert_eq!(
            list.check_permissions("thomasguntenaar.near".parse().unwrap(), vec![]),
            given_permissions,
        );

        // With labels
        assert_eq!(
            list.check_permissions(
                "thomasguntenaar.near".parse().unwrap(),
                vec!["funding-requested".to_string()]
            ),
            given_permissions,
        )
    }

    #[test]
    fn check_permissions_of_not_member() {
        let list = create_list();
        let actual: HashSet<ActionType> = list.check_permissions(
            "random.near".parse().unwrap(),
            vec!["wg-protocol".to_string(), "funding-requested".to_string()],
        );
        assert!(actual.is_empty());
    }

    #[test]
    fn add_remove_member() {
        let mut list = create_list();
        list.add_member(
            Member::Account("bob.near".parse().unwrap()),
            MemberMetadata {
                parents: HashSet::from([Member::Team("moderators".to_string())]),
                ..Default::default()
            }
            .into(),
        );
        list.remove_member(&Member::Account("bob.near".parse().unwrap()));
        assert_eq!(list, create_list());
    }
}

'''
'''--- src/access_control/mod.rs ---
use crate::access_control::members::{Member, MembersList, VersionedMemberMetadata};
use crate::access_control::rules::{Rule, RulesList};
use crate::*;
use near_sdk::near;
use std::collections::{HashMap, HashSet};

pub mod members;
pub mod rules;

#[near(serializers=[borsh, json])]
#[derive(Clone, Default)]
pub struct AccessControl {
    pub rules_list: RulesList,
    pub members_list: MembersList,
}

#[near]
impl Contract {
    pub fn get_access_control_info(&self) -> &AccessControl {
        &self.access_control
    }

    pub fn is_restricted_label(&self, label: String) -> bool {
        self.access_control.rules_list.is_restricted(&label)
    }

    pub fn find_restricted_labels(&self, labels: Vec<String>) -> HashSet<String> {
        self.access_control.rules_list.find_restricted(&labels)
    }

    pub fn set_restricted_rules(&mut self, rules: RulesList) {
        require!(
            self.has_moderator(env::predecessor_account_id())
                || env::predecessor_account_id() == env::current_account_id(),
            "Only the admin and moderators can set restricted rules"
        );
        self.access_control.rules_list.set_restricted(rules)
    }

    pub fn unset_restricted_rules(&mut self, rules: Vec<Rule>) {
        require!(
            self.has_moderator(env::predecessor_account_id())
                || env::predecessor_account_id() == env::current_account_id(),
            "Only the admin and moderators can unset restricted rules"
        );
        self.access_control.rules_list.unset_restricted(rules)
    }

    pub fn get_root_members(&self) -> HashMap<Member, VersionedMemberMetadata> {
        self.access_control.members_list.get_root_members()
    }

    pub fn add_member(&mut self, member: Member, metadata: VersionedMemberMetadata) {
        require!(
            self.has_moderator(env::predecessor_account_id())
                || env::predecessor_account_id() == env::current_account_id(),
            "Only the admin and moderators can add members"
        );
        self.access_control.members_list.add_member(member, metadata)
    }

    pub fn remove_member(&mut self, member: &Member) {
        require!(
            self.has_moderator(env::predecessor_account_id())
                || env::predecessor_account_id() == env::current_account_id(),
            "Only the admin and moderators can remove members"
        );
        self.access_control.members_list.remove_member(member)
    }

    pub fn edit_member(&mut self, member: Member, metadata: VersionedMemberMetadata) {
        require!(
            self.has_moderator(env::predecessor_account_id())
                || env::predecessor_account_id() == env::current_account_id(),
            "Only the admin and moderators can edit members"
        );
        self.access_control.members_list.edit_member(member, metadata)
    }
}

'''
'''--- src/access_control/rules.rs ---
use near_sdk::near;
use std::collections::{HashMap, HashSet};

#[near(serializers=[borsh, json])]
#[derive(Clone, Debug, Eq, PartialEq, Default)]
pub struct RulesList {
    #[serde(flatten)]
    pub rules: HashMap<Rule, VersionedRuleMetadata>,
}

#[near(serializers=[borsh, json])]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct RuleMetadata {
    pub description: String,
}

#[near(serializers=[borsh, json])]
#[derive(Clone, Debug, Eq, PartialEq)]
#[serde(tag = "rule_metadata_version")]
pub enum VersionedRuleMetadata {
    V0(RuleMetadata),
}

impl From<RuleMetadata> for VersionedRuleMetadata {
    fn from(rm: RuleMetadata) -> Self {
        VersionedRuleMetadata::V0(rm)
    }
}

#[near(serializers=[borsh, json])]
#[derive(Clone, PartialOrd, PartialEq, Ord, Eq, Hash, Debug)]
#[serde(from = "String", into = "String")]
pub enum Rule {
    /// Labels can be any string, but rules are created by the NEAR account owner of this contract,
    /// or small circle of moderators. So this code cannot be abused. Likely creating a label that
    /// mimics a rule makes this label only more restrictive, so there might be nothing to exploit.
    /// TODO: Add extra logic to prevent malicious rules creation by creating labels that mimic rules.
    ExactMatch(String),
    StartsWith(String),
    Any(),
}

/// JSON string representation prefix of Rule::StartsWith variant.
const STARTS_WITH: &str = "starts-with:";
const ANY: &str = "*";

impl From<String> for Rule {
    fn from(full_str: String) -> Self {
        if full_str == ANY {
            Rule::Any()
        } else if let Some(s) = full_str.strip_prefix(STARTS_WITH) {
            Rule::StartsWith(s.to_string())
        } else {
            Rule::ExactMatch(full_str)
        }
    }
}

impl Into<String> for Rule {
    fn into(self) -> String {
        match self {
            Rule::ExactMatch(s) => s.to_string(),
            Rule::StartsWith(s) => format!("{}{}", STARTS_WITH, s).to_string(),
            Rule::Any() => ANY.to_string(),
        }
    }
}

impl Rule {
    /// Check if this rule applies to a label.
    pub fn applies(&self, label: &str) -> bool {
        match self {
            Rule::ExactMatch(rule) => label == rule,
            Rule::StartsWith(rule) => label.starts_with(rule),
            Rule::Any() => true,
        }
    }

    /// Check if this rule applies to any of the labels.
    pub fn applies_to_any(&self, labels: &[String]) -> bool {
        match self {
            Rule::ExactMatch(rule) => labels.iter().any(|label| label == rule),
            Rule::StartsWith(rule) => labels.iter().any(|label| label.starts_with(rule.as_str())),
            Rule::Any() => true,
        }
    }
}

impl RulesList {
    /// Is this a restricted label.
    pub fn is_restricted(&self, label: &str) -> bool {
        self.rules.keys().any(|rule| rule.applies(label))
    }

    /// Get restricted labels out of this list.
    pub fn find_restricted(&self, labels: &[String]) -> HashSet<String> {
        self.rules
            .keys()
            .map(|key| match key {
                Rule::ExactMatch(rule) => {
                    labels.iter().filter(|label| label == &rule).collect::<Vec<_>>()
                }
                Rule::StartsWith(rule) => {
                    labels.iter().filter(|label| label.starts_with(rule)).collect::<Vec<_>>()
                }
                Rule::Any() => {
                    vec![]
                }
            })
            .flatten()
            .cloned()
            .collect()
    }

    /// Set rules as restricted. Can be also used to override metadata on existing rules.
    pub fn set_restricted(&mut self, rules: Self) {
        for (rule, metadata) in rules.rules {
            self.rules.insert(rule, metadata);
        }
    }

    /// Unset rules as restricted.
    pub fn unset_restricted(&mut self, rules: Vec<Rule>) {
        for rule in rules {
            self.rules.remove(&rule);
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::access_control::rules::{Rule, RuleMetadata, RulesList};
    use near_sdk::serde_json;
    use std::collections::{HashMap, HashSet};

    #[test]
    fn rule_serialization() {
        let rule = Rule::ExactMatch("wg-protocol".to_string());
        assert_eq!(serde_json::to_value(&rule).unwrap(), serde_json::json!("wg-protocol"));

        let rule = Rule::StartsWith("funding".to_string());
        assert_eq!(serde_json::to_value(&rule).unwrap(), serde_json::json!("starts-with:funding"));
    }

    #[test]
    fn rule_deserialization() {
        let rule: Rule = serde_json::from_str(r#""wg-protocol""#).unwrap();
        assert_eq!(rule, Rule::ExactMatch("wg-protocol".to_string()));

        let rule: Rule = serde_json::from_str(r#""starts-with:funding""#).unwrap();
        assert_eq!(rule, Rule::StartsWith("funding".to_string()));
    }

    fn create_list() -> RulesList {
        RulesList {
            rules: HashMap::from([
                (
                    Rule::ExactMatch("wg-protocol".to_string()),
                    RuleMetadata { description: "For Protocol WG only".to_string() }.into(),
                ),
                (
                    Rule::ExactMatch("wg-tools".to_string()),
                    RuleMetadata { description: "For Tools WG only".to_string() }.into(),
                ),
                (
                    Rule::StartsWith("funding".to_string()),
                    RuleMetadata { description: "For funding team only".to_string() }.into(),
                ),
                (
                    Rule::StartsWith("mnw".to_string()),
                    RuleMetadata { description: "For Wallet WG only".to_string() }.into(),
                ),
            ]),
        }
    }

    #[test]
    fn rule_list_serialization_deserialization() {
        let list = create_list();

        let list_json = serde_json::json!(
            {
                "wg-protocol": { "description": "For Protocol WG only", "rule_metadata_version": "V0"},
                "wg-tools": {"description": "For Tools WG only", "rule_metadata_version": "V0" },
                "starts-with:funding": {"description": "For funding team only", "rule_metadata_version": "V0" },
                "starts-with:mnw": {"description": "For Wallet WG only", "rule_metadata_version": "V0" }
            }
        );
        assert_eq!(serde_json::to_value(list.clone()).unwrap(), list_json);
        assert_eq!(serde_json::from_value::<RulesList>(list_json).unwrap(), list);
    }

    #[test]
    fn is_restricted() {
        let list = create_list();
        assert!(list.is_restricted(&"wg-protocol".to_string()));
        assert!(list.is_restricted(&"wg-tools".to_string()));
        assert!(!list.is_restricted(&"wg-wallet".to_string()));
        assert!(list.is_restricted(&"funding".to_string()));
        assert!(list.is_restricted(&"fundingfoobar".to_string()));
        assert!(list.is_restricted(&"funding-requested".to_string()));
        assert!(!list.is_restricted(&"nofunding".to_string()));
        assert!(list.is_restricted(&"mnw".to_string()));
        assert!(list.is_restricted(&"mnw-approved".to_string()));
        assert!(!list.is_restricted(&"nomnw".to_string()));
    }

    #[test]
    fn find_restricted() {
        let list = create_list();
        let actual = list.find_restricted(&[
            "wg-protocol".to_string(),
            "wg-tools".to_string(),
            "wg-wallet".to_string(),
            "funding".to_string(),
            "funding".to_string(),
            "fundingfoobar".to_string(),
            "fundingfoobar".to_string(),
            "funding-requested".to_string(),
            "nofunding".to_string(),
            "nofunding".to_string(),
            "mnw".to_string(),
            "mnw-approved".to_string(),
            "nomnw".to_string(),
        ]);
        let expected = HashSet::from([
            "wg-protocol".to_string(),
            "wg-tools".to_string(),
            "funding".to_string(),
            "fundingfoobar".to_string(),
            "funding-requested".to_string(),
            "mnw".to_string(),
            "mnw-approved".to_string(),
        ]);
        assert_eq!(actual, expected);
    }
}

'''
'''--- src/community/mod.rs ---
use near_sdk::{env, ext_contract, near, require, AccountId, Gas, NearToken};

pub type CommunityHandle = String;

pub type AddOnId = String;

#[near(serializers=[borsh, json])]
#[derive(Clone)]
pub struct CommunityInputs {
    pub handle: CommunityHandle,
    pub name: String,
    pub tag: String,
    pub description: String,
    pub logo_url: String,
    pub banner_url: String,
    pub bio_markdown: Option<String>,
}

#[near(serializers=[borsh, json])]
#[derive(Clone)]
pub struct CommunityMetadata {
    pub admins: Vec<AccountId>,
    pub handle: CommunityHandle,
    pub name: String,
    pub tag: String,
    pub description: String,
    pub logo_url: String,
    pub banner_url: String,
    pub bio_markdown: Option<String>,
}

#[near(serializers=[borsh, json])]
#[derive(Clone)]
pub struct CommunityFeatureFlags {
    pub telegram: bool,
    pub github: bool,
    pub board: bool,
    pub wiki: bool,
}

#[near(serializers=[borsh, json])]
#[derive(Clone)]
pub struct WikiPage {
    name: String,
    content_markdown: String,
}

#[near(serializers=[borsh, json])]
#[derive(Clone, PartialEq, Debug)]
pub struct CommunityAddOn {
    pub id: String,
    pub addon_id: AddOnId,
    pub display_name: String,
    pub enabled: bool,
    pub parameters: String,
}

#[near(serializers=[borsh, json])]
#[derive(Clone, PartialEq, Debug)]
pub struct AddOn {
    pub id: AddOnId,
    pub title: String,
    pub description: String,
    pub icon: String,
    // The path to the view on the community page
    pub view_widget: String,
    // The path to the view on the community configuration page
    pub configurator_widget: String,
}

impl AddOn {
    pub fn validate(&self) {
        if !matches!(self.id.chars().count(), 3..=120) {
            panic!("Add-on id must contain 3 to 120 characters");
        }

        if !matches!(self.title.chars().count(), 3..=120) {
            panic!("Add-on title must contain 3 to 120 characters");
        }

        if !matches!(self.description.chars().count(), 3..=120) {
            panic!("Add-on description must contain 3 to 120 characters");
        }
        if !matches!(self.view_widget.chars().count(), 6..=240) {
            panic!("Add-on viewer must contain 6 to 240 characters");
        }
        if !matches!(self.configurator_widget.chars().count(), 0..=240) {
            panic!("Add-on configurator must contain 0 to 240 characters");
        }
        if !matches!(self.icon.chars().count(), 6..=60) {
            panic!("Add-on icon must contain 6 to 60 characters");
        }
    }
}

#[near(serializers=[borsh, json])]
pub struct Community {
    pub admins: Vec<AccountId>,
    pub handle: CommunityHandle,
    pub name: String,
    pub tag: String,
    pub description: String,
    pub logo_url: String,
    pub banner_url: String,
    pub bio_markdown: Option<String>,
    pub github_handle: Option<String>,
    pub telegram_handle: Option<String>,
    pub twitter_handle: Option<String>,
    pub website_url: Option<String>,
    pub addons: Vec<CommunityAddOn>,
}

#[near(serializers=[borsh, json])]
#[derive(Clone)]
pub struct FeaturedCommunity {
    pub handle: CommunityHandle,
}

#[near(serializers=[borsh, json])]
#[derive(Clone)]
pub struct CommunityPermissions {
    pub can_configure: bool,
    pub can_delete: bool,
}

impl Community {
    pub fn validate(&self) {
        require!(
            matches!(self.handle.chars().count(), 3..=40),
            "Community handle must contain 3 to 40 characters"
        );
        require!(
            self.handle.parse::<AccountId>().is_ok() && !self.handle.contains('.'),
            "Community handle should be lowercase alphanumeric symbols separated either by `_` or `-`, separators are not permitted to immediately follow each other, start or end with separators"
        );
        require!(
            matches!(self.name.chars().count(), 3..=30),
            "Community name must contain 3 to 30 characters"
        );
        require!(
            matches!(self.tag.chars().count(), 3..=30),
            "Community tag must contain 3 to 30 characters"
        );
        require!(
            matches!(self.description.chars().count(), 6..=60),
            "Community description must contain 6 to 60 characters"
        );
        require!(
            self.bio_markdown.is_none()
                || matches!(
                    self.bio_markdown.to_owned().map_or(0, |text| text.chars().count()),
                    3..=200
                ),
            "Community bio must contain 3 to 200 characters"
        );
    }

    pub fn add_addon(&mut self, addon_config: CommunityAddOn) {
        self.addons.push(addon_config);
    }

    pub fn remove_addon(&mut self, addon_to_remove: CommunityAddOn) {
        self.addons.retain(|addon| addon != &addon_to_remove);
    }

    pub fn set_addons(&mut self, addons: Vec<CommunityAddOn>) {
        self.addons = addons;
    }

    pub fn set_default_admin(&mut self) {
        if self.admins.is_empty() {
            self.admins = vec![env::predecessor_account_id()];
        }
    }
}

pub fn get_devhub_community_factory() -> AccountId {
    format!("community.{}", env::current_account_id()).parse().unwrap()
}

pub fn get_devhub_discussions_factory(handle: &CommunityHandle) -> AccountId {
    get_devhub_community_account(handle).parse().unwrap()
}

pub fn get_devhub_community_account(handle: &CommunityHandle) -> String {
    format!("{}.{}", handle, get_devhub_community_factory())
}

pub fn get_devhub_discussions_account(handle: &CommunityHandle) -> String {
    format!("discussions.{}", get_devhub_community_account(handle))
}

#[ext_contract(ext_devhub_community_factory)]
pub trait DevhubCommunityFactory {
    fn create_community_account(&mut self, community: String);
}

#[ext_contract(ext_devhub_community)]
pub trait DevhubCommunity {
    fn destroy(&mut self);

    fn create_discussions_account(&mut self);
}

pub const CREATE_COMMUNITY_BALANCE: NearToken = NearToken::from_near(4);
pub const CREATE_DISCUSSION_BALANCE: NearToken = NearToken::from_near(2);
pub const CREATE_COMMUNITY_GAS: Gas = Gas::from_tgas(200);
pub const UPDATE_COMMUNITY_GAS: Gas = Gas::from_tgas(30);
pub const DELETE_COMMUNITY_GAS: Gas = Gas::from_tgas(30);
pub const SET_COMMUNITY_SOCIALDB_GAS: Gas = Gas::from_tgas(30);
pub const CREATE_DISCUSSION_GAS: Gas = Gas::from_tgas(30);

'''
'''--- src/debug.rs ---
use crate::*;
use near_sdk::near;
use near_sdk::serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Stats {
    pub num_posts: u64,
}

#[near]
impl Contract {
    pub fn get_post_to_parent(&self) -> Vec<(PostId, PostId)> {
        let mut res = vec![];
        for child_id in 0..self.posts.len() {
            if let Some(parent_id) = self.post_to_parent.get(&child_id) {
                res.push((child_id, parent_id));
            }
        }
        res
    }

    pub fn get_parent_to_children(&self) -> Vec<(PostId, Vec<PostId>)> {
        let mut res = vec![];
        for parent_id in 0..self.posts.len() {
            if let Some(children_ids) = self.post_to_children.get(&parent_id) {
                res.push((parent_id, children_ids));
            }
        }
        res
    }
}

'''
'''--- src/lib.rs ---
pub mod access_control;
pub mod community;
pub mod debug;
pub mod migrations;
mod notify;
pub mod post;
pub mod proposal;
mod repost;
pub mod stats;
pub mod str_serializers;

use crate::access_control::members::ActionType;
use crate::access_control::members::Member;
use crate::access_control::AccessControl;
use community::*;
use post::*;
use proposal::timeline::TimelineStatus;
use proposal::*;

use devhub_common::{social_db_contract, SetReturnType};

use near_sdk::borsh::BorshDeserialize;
use near_sdk::collections::{LookupMap, UnorderedMap, Vector};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json::{json, Number, Value};
use near_sdk::{env, near, require, AccountId, NearSchema, PanicOnDefault, Promise};

use std::collections::HashSet;
use std::convert::TryInto;

type PostId = u64;
type IdeaId = u64;
type AttestationId = u64;
type SolutionId = u64;
type SponsorshipId = u64;
type CommentId = u64;

/// An imaginary top post representing the landing page.
const ROOT_POST_ID: u64 = u64::MAX;

#[near(contract_state)]
#[derive(PanicOnDefault)]
pub struct Contract {
    pub posts: Vector<VersionedPost>,
    pub post_to_parent: LookupMap<PostId, PostId>,
    pub post_to_children: LookupMap<PostId, Vec<PostId>>,
    pub label_to_posts: UnorderedMap<String, HashSet<PostId>>,
    pub access_control: AccessControl,
    pub authors: UnorderedMap<AccountId, HashSet<PostId>>,
    pub proposals: Vector<VersionedProposal>,
    pub label_to_proposals: UnorderedMap<String, HashSet<ProposalId>>,
    pub author_proposals: UnorderedMap<AccountId, HashSet<ProposalId>>,
    pub proposal_categories: Vec<String>,
    pub communities: UnorderedMap<CommunityHandle, Community>,
    pub featured_communities: Vec<FeaturedCommunity>,
    pub available_addons: UnorderedMap<AddOnId, AddOn>,
}

#[near]
impl Contract {
    #[init]
    pub fn new() -> Self {
        migrations::state_version_write(&migrations::StateVersion::V10);

        let mut contract = Self {
            posts: Vector::new(StorageKey::Posts),
            post_to_parent: LookupMap::new(StorageKey::PostToParent),
            post_to_children: LookupMap::new(StorageKey::PostToChildren),
            label_to_posts: UnorderedMap::new(StorageKey::LabelToPostsV2),
            access_control: AccessControl::default(),
            authors: UnorderedMap::new(StorageKey::AuthorToAuthorPosts),
            proposals: Vector::new(StorageKey::Proposals),
            label_to_proposals: UnorderedMap::new(StorageKey::LabelToProposals),
            author_proposals: UnorderedMap::new(StorageKey::AuthorProposals),
            proposal_categories: default_categories(),
            communities: UnorderedMap::new(StorageKey::Communities),
            featured_communities: Vec::new(),
            available_addons: UnorderedMap::new(StorageKey::AddOns),
        };

        contract.post_to_children.insert(&ROOT_POST_ID, &Vec::new());
        contract
    }

    /// If `parent_id` is not provided get all landing page posts. Otherwise, get all posts under
    /// `parent_id` post.
    pub fn get_posts(&self, parent_id: Option<PostId>) -> Vec<VersionedPost> {
        near_sdk::log!("get_posts");
        let parent_id = parent_id.unwrap_or(ROOT_POST_ID);
        let children_ids = self
            .post_to_children
            .get(&parent_id)
            .unwrap_or_else(|| panic!("Parent id {} not found", parent_id));
        children_ids
            .into_iter()
            .map(|id| {
                self.posts
                    .get(id)
                    .unwrap_or_else(|| panic!("Post id {} not found. Broken state invariant", id))
            })
            .collect()
    }

    pub fn get_post(&self, post_id: PostId) -> VersionedPost {
        near_sdk::log!("get_post");
        self.posts.get(post_id).unwrap_or_else(|| panic!("Post id {} not found", post_id))
    }

    pub fn get_all_post_ids(&self) -> Vec<PostId> {
        near_sdk::log!("get_all_post_ids");
        (0..self.posts.len()).collect()
    }

    pub fn get_children_ids(&self, post_id: Option<PostId>) -> Vec<PostId> {
        near_sdk::log!("get_children_ids");
        let post_id = post_id.unwrap_or(ROOT_POST_ID);
        self.post_to_children
            .get(&post_id)
            .unwrap_or_else(|| panic!("Parent id {} not found", post_id))
    }

    pub fn get_parent_id(&self, post_id: PostId) -> Option<PostId> {
        near_sdk::log!("get_parent_id");
        let res = self
            .post_to_parent
            .get(&post_id)
            .unwrap_or_else(|| panic!("Parent id {} not found", post_id));
        if res == ROOT_POST_ID {
            Option::None
        } else {
            Option::Some(res)
        }
    }

    pub fn get_proposals(&self) -> Vec<VersionedProposal> {
        near_sdk::log!("get_proposals");
        self.proposals.to_vec()
    }

    pub fn get_proposal(&self, proposal_id: ProposalId) -> VersionedProposal {
        near_sdk::log!("get_proposal");
        self.proposals
            .get(proposal_id.into())
            .unwrap_or_else(|| panic!("Proposal id {} not found", proposal_id))
    }

    pub fn get_all_proposal_ids(&self) -> Vec<ProposalId> {
        near_sdk::log!("get_all_proposal_ids");
        (0..self.proposals.len().try_into().unwrap()).collect()
    }

    #[payable]
    pub fn add_like(&mut self, post_id: PostId) -> Promise {
        near_sdk::log!("add_like");
        let mut post: Post = self
            .posts
            .get(post_id)
            .unwrap_or_else(|| panic!("Post id {} not found", post_id))
            .into();
        let post_author = post.author_id.clone();
        let like =
            Like { author_id: env::predecessor_account_id(), timestamp: env::block_timestamp() };
        post.likes.insert(like);
        self.posts.replace(post_id, &post.into());
        notify::notify_like(post_id, post_author)
    }

    #[payable]
    pub fn add_post(
        &mut self,
        parent_id: Option<PostId>,
        body: PostBody,
        labels: HashSet<String>,
    ) -> Promise {
        near_sdk::log!("add_post");
        let parent_id = parent_id.unwrap_or(ROOT_POST_ID);
        let id = self.posts.len();
        let author_id = env::predecessor_account_id();
        let editor_id = author_id.clone();
        require!(
            self.is_allowed_to_use_labels(
                Some(editor_id.clone()),
                labels.iter().cloned().collect()
            ),
            "Cannot use these labels"
        );

        for label in &labels {
            let mut other_posts = self.label_to_posts.get(label).unwrap_or_default();
            other_posts.insert(id);
            self.label_to_posts.insert(label, &other_posts);
        }
        let post = Post {
            id,
            author_id: author_id.clone(),
            likes: Default::default(),
            snapshot: PostSnapshot { editor_id, timestamp: env::block_timestamp(), labels, body },
            snapshot_history: vec![],
        };
        self.posts.push(&post.clone().into());
        self.post_to_parent.insert(&id, &parent_id);

        let mut siblings = self
            .post_to_children
            .get(&parent_id)
            .unwrap_or_else(|| panic!("Parent id {} not found", parent_id));
        siblings.push(id);
        self.post_to_children.insert(&parent_id, &siblings);

        // Don't forget to add an empty list of your own children.
        self.post_to_children.insert(&id, &vec![]);

        let mut author_posts = self.authors.get(&author_id).unwrap_or_default();
        author_posts.insert(post.id);
        self.authors.insert(&post.author_id, &author_posts);

        let desc = get_post_description(post.clone());

        if parent_id != ROOT_POST_ID {
            let parent_post: Post = self
                .posts
                .get(parent_id)
                .unwrap_or_else(|| panic!("Parent post with id {} not found", parent_id))
                .into();
            let parent_author = parent_post.author_id;
            notify::notify_reply(parent_id, parent_author);
        } else {
            repost::repost(post);
        }
        notify::notify_mentions(desc.as_str(), id)
    }

    #[payable]
    pub fn add_proposal(
        &mut self,
        body: VersionedProposalBody,
        labels: HashSet<String>,
    ) -> Promise {
        near_sdk::log!("add_proposal");
        let id: ProposalId = self.proposals.len().try_into().unwrap();
        let author_id = env::predecessor_account_id();
        let editor_id = author_id.clone();

        let proposal_body = body.clone().latest_version();

        require!(
            self.is_allowed_to_use_labels(
                Some(editor_id.clone()),
                labels.iter().cloned().collect()
            ),
            "Cannot use these labels"
        );

        require!(self.proposal_categories.contains(&proposal_body.category), "Unknown category");

        require!(
            proposal_body.timeline.is_draft() || proposal_body.timeline.is_empty_review(),
            "Cannot create proposal which is not in a draft or a review state"
        );

        for label in &labels {
            let mut other_proposals = self.label_to_proposals.get(label).unwrap_or_default();
            other_proposals.insert(id);
            self.label_to_proposals.insert(label, &other_proposals);
        }

        let mut author_proposals = self.author_proposals.get(&author_id).unwrap_or_default();
        author_proposals.insert(id);
        self.author_proposals.insert(&author_id, &author_proposals);

        let proposal = Proposal {
            id: id,
            author_id: author_id.clone(),
            social_db_post_block_height: 0u64,
            snapshot: ProposalSnapshot {
                editor_id,
                timestamp: env::block_timestamp(),
                labels,
                body: body.clone(),
            },
            snapshot_history: vec![],
        };

        proposal::repost::publish_to_socialdb_feed(
            Self::ext(env::current_account_id())
                .with_static_gas(env::prepaid_gas().saturating_div(4))
                .set_block_height_callback(proposal.clone()),
            proposal.clone(),
        )
        .then(notify::notify_proposal_subscribers(&proposal))
    }

    #[private]
    pub fn set_block_height_callback(
        &mut self,
        #[allow(unused_mut)] mut proposal: Proposal,
        #[callback_unwrap] set_result: SetReturnType,
    ) -> BlockHeightCallbackRetValue {
        proposal.social_db_post_block_height = set_result.block_height.into();
        self.proposals.push(&proposal.clone().into());
        BlockHeightCallbackRetValue { proposal_id: proposal.id }
    }

    pub fn get_posts_by_author(&self, author: AccountId) -> Vec<PostId> {
        near_sdk::log!("get_posts_by_author");
        self.authors.get(&author).map(|posts| posts.into_iter().collect()).unwrap_or_default()
    }

    pub fn get_posts_by_label(&self, label: String) -> Vec<PostId> {
        near_sdk::log!("get_posts_by_label");
        let mut res: Vec<_> =
            self.label_to_posts.get(&label).unwrap_or_default().into_iter().collect();
        res.sort();
        res
    }

    pub fn get_proposals_by_author(&self, author: AccountId) -> Vec<ProposalId> {
        near_sdk::log!("get_proposals_by_author");
        self.author_proposals
            .get(&author)
            .map(|proposals| proposals.into_iter().collect())
            .unwrap_or_default()
    }

    pub fn get_proposals_by_label(&self, label: String) -> Vec<ProposalId> {
        near_sdk::log!("get_proposals_by_label");
        let mut res: Vec<_> =
            self.label_to_proposals.get(&label).unwrap_or_default().into_iter().collect();
        res.sort();
        res
    }

    pub fn get_all_labels(&self) -> Vec<String> {
        near_sdk::log!("get_all_labels");
        let mut res: Vec<_> = self.label_to_posts.keys().collect();
        res.sort();
        res
    }

    pub fn get_all_proposal_labels(&self) -> Vec<String> {
        near_sdk::log!("get_all_proposal_labels");
        let mut res: Vec<_> = self.label_to_proposals.keys().collect();
        res.sort();
        res
    }

    pub fn get_all_authors(&self) -> Vec<AccountId> {
        near_sdk::log!("get_all_authors");
        let mut res: Vec<_> = self.authors.keys().collect();
        res.sort();
        res
    }

    pub fn get_all_proposal_authors(&self) -> Vec<AccountId> {
        near_sdk::log!("get_all_proposal_authors");
        let mut res: Vec<_> = self.author_proposals.keys().collect();
        res.sort();
        res
    }

    pub fn is_allowed_to_edit_proposal(
        &self,
        proposal_id: ProposalId,
        editor: Option<AccountId>,
    ) -> bool {
        near_sdk::log!("is_allowed_to_edit_proposal");
        let proposal: Proposal = self
            .proposals
            .get(proposal_id.try_into().unwrap())
            .unwrap_or_else(|| panic!("Proposal id {} not found", proposal_id))
            .into();
        let editor = editor.unwrap_or_else(env::predecessor_account_id);
        // First check for simple cases.
        if editor == env::current_account_id() || editor == proposal.author_id {
            return true;
        }

        // Then check for complex case.
        self.access_control
            .members_list
            .check_permissions(editor, proposal.snapshot.labels.into_iter().collect::<Vec<_>>())
            .contains(&ActionType::EditPost)
    }

    pub fn is_allowed_to_edit(&self, post_id: PostId, editor: Option<AccountId>) -> bool {
        near_sdk::log!("is_allowed_to_edit");
        let post: Post = self
            .posts
            .get(post_id)
            .unwrap_or_else(|| panic!("Post id {} not found", post_id))
            .into();
        let editor = editor.unwrap_or_else(env::predecessor_account_id);
        // First check for simple cases.
        if editor == env::current_account_id() || editor == post.author_id {
            return true;
        }

        // Then check for complex case.
        self.access_control
            .members_list
            .check_permissions(editor, post.snapshot.labels.into_iter().collect::<Vec<_>>())
            .contains(&ActionType::EditPost)
    }

    pub fn is_allowed_to_use_labels(&self, editor: Option<AccountId>, labels: Vec<String>) -> bool {
        let editor = editor.unwrap_or_else(env::predecessor_account_id);
        // First check for simple cases.
        if editor == env::current_account_id() {
            return true;
        }
        let restricted_labels = self.access_control.rules_list.find_restricted(&labels);
        if restricted_labels.is_empty() {
            return true;
        }
        self.access_control
            .members_list
            .check_permissions(editor, labels)
            .contains(&ActionType::UseLabels)
    }

    fn filtered_labels<T>(
        &self,
        labels_to_t: &UnorderedMap<String, T>,
        editor: &AccountId,
    ) -> Vec<String>
    where
        T: near_sdk::borsh::BorshSerialize + near_sdk::borsh::BorshDeserialize,
    {
        let filtered: HashSet<String> = labels_to_t
            .keys()
            .filter(|label| {
                self.is_allowed_to_use_labels(Some(editor.clone()), vec![label.clone()])
            })
            .collect();
        let mut res: Vec<_> = filtered.into_iter().collect();
        res.sort();
        res
    }

    pub fn get_all_allowed_labels(&self, editor: AccountId) -> Vec<String> {
        near_sdk::log!("get_all_allowed_labels");
        self.filtered_labels(&self.label_to_posts, &editor)
    }

    pub fn get_all_allowed_proposal_labels(&self, editor: AccountId) -> Vec<String> {
        near_sdk::log!("get_all_allowed_proposal_labels");
        self.filtered_labels(&self.label_to_proposals, &editor)
    }

    #[payable]
    pub fn edit_post(&mut self, id: PostId, body: PostBody, labels: HashSet<String>) -> Promise {
        near_sdk::log!("edit_post");
        require!(
            self.is_allowed_to_edit(id, Option::None),
            "The account is not allowed to edit this post"
        );
        let editor_id = env::predecessor_account_id();
        let mut post: Post =
            self.posts.get(id).unwrap_or_else(|| panic!("Post id {} not found", id)).into();

        let old_snapshot = post.snapshot.clone();
        let old_labels_set = old_snapshot.labels.clone();
        let new_labels = labels;
        let new_snapshot = PostSnapshot {
            editor_id: editor_id.clone(),
            timestamp: env::block_timestamp(),
            labels: new_labels.clone(),
            body,
        };
        post.snapshot = new_snapshot;
        post.snapshot_history.push(old_snapshot);
        let post_author = post.author_id.clone();
        self.posts.replace(id, &post.into());

        // Update labels index.
        let new_labels_set = new_labels;
        let labels_to_remove = &old_labels_set - &new_labels_set;
        let labels_to_add = &new_labels_set - &old_labels_set;
        require!(
            self.is_allowed_to_use_labels(
                Some(editor_id.clone()),
                labels_to_remove.iter().cloned().collect()
            ),
            "Not allowed to remove these labels"
        );
        require!(
            self.is_allowed_to_use_labels(
                Some(editor_id.clone()),
                labels_to_add.iter().cloned().collect()
            ),
            "Not allowed to add these labels"
        );

        for label_to_remove in labels_to_remove {
            let mut posts = self.label_to_posts.get(&label_to_remove).unwrap();
            posts.remove(&id);
            self.label_to_posts.insert(&label_to_remove, &posts);
        }

        for label_to_add in labels_to_add {
            let mut posts = self.label_to_posts.get(&label_to_add).unwrap_or_default();
            posts.insert(id);
            self.label_to_posts.insert(&label_to_add, &posts);
        }

        notify::notify_edit(id, post_author)
    }

    #[payable]
    pub fn create_community(
        &mut self,
        #[allow(unused_mut)] mut inputs: CommunityInputs,
    ) -> Promise {
        require!(
            self.get_community(inputs.handle.to_owned()).is_none(),
            "Community already exists"
        );

        require!(
            env::attached_deposit() >= CREATE_COMMUNITY_BALANCE,
            "Require 4 NEAR to create community"
        );

        require!(env::prepaid_gas() >= CREATE_COMMUNITY_GAS, "Require at least 200 Tgas");

        let mut new_community = Community {
            admins: vec![],
            handle: inputs.handle.clone(),
            name: inputs.name,
            tag: inputs.tag,
            description: inputs.description,
            logo_url: inputs.logo_url,
            banner_url: inputs.banner_url,
            bio_markdown: inputs.bio_markdown,
            github_handle: None,
            telegram_handle: None,
            twitter_handle: None,
            website_url: None,
            addons: vec![
                CommunityAddOn {
                    id: "announcements".to_string(),
                    addon_id: "announcements".to_string(),
                    display_name: "Announcements".to_string(),
                    enabled: true,
                    parameters: "".to_string(),
                },
                CommunityAddOn {
                    id: "discussions".to_string(),
                    addon_id: "discussions".to_string(),
                    display_name: "Discussions".to_string(),
                    enabled: true,
                    parameters: "".to_string(),
                },
            ],
        };

        new_community.validate();
        new_community.set_default_admin();
        self.communities.insert(&new_community.handle, &new_community);

        ext_devhub_community_factory::ext(get_devhub_community_factory())
            .with_unused_gas_weight(1)
            .with_attached_deposit(CREATE_COMMUNITY_BALANCE)
            .create_community_account(new_community.handle.clone())
    }

    #[payable]
    pub fn edit_proposal(
        &mut self,
        id: ProposalId,
        body: VersionedProposalBody,
        labels: HashSet<String>,
    ) -> Promise {
        near_sdk::log!("edit_proposal");
        self.edit_proposal_internal(id, body.clone(), labels)
    }

    #[payable]
    pub fn edit_proposal_timeline(&mut self, id: ProposalId, timeline: TimelineStatus) -> Promise {
        near_sdk::log!("edit_proposal_timeline");
        let proposal: Proposal = self
            .proposals
            .get(id.into())
            .unwrap_or_else(|| panic!("Proposal id {} not found", id))
            .into();
        let mut body = proposal.snapshot.body.latest_version();
        body.timeline = timeline;

        self.edit_proposal_internal(id, body.into(), proposal.snapshot.labels)
    }

    fn edit_proposal_internal(
        &mut self,
        id: ProposalId,
        body: VersionedProposalBody,
        labels: HashSet<String>,
    ) -> Promise {
        require!(
            self.is_allowed_to_edit_proposal(id, Option::None),
            "The account is not allowed to edit this proposal"
        );
        let editor_id = env::predecessor_account_id();
        let mut proposal: Proposal = self
            .proposals
            .get(id.into())
            .unwrap_or_else(|| panic!("Proposal id {} not found", id))
            .into();

        let proposal_body = body.clone().latest_version();

        let current_timeline = proposal.snapshot.body.clone().latest_version().timeline;

        require!(
            self.has_moderator(editor_id.clone())
                || editor_id.clone() == env::current_account_id()
                || current_timeline.is_draft()
                    && (proposal_body.timeline.is_empty_review()
                        || proposal_body.timeline.is_draft())
                || current_timeline.can_be_cancelled() && proposal_body.timeline.is_cancelled(),
            "This account is only allowed to change proposal status from DRAFT to REVIEW"
        );

        require!(
            proposal_body.timeline.is_draft() ||  proposal_body.timeline.is_review() || proposal_body.timeline.is_cancelled() || proposal_body.supervisor.is_some(),
            "You can't change the timeline of the proposal to this status without adding a supervisor"
        );

        require!(self.proposal_categories.contains(&proposal_body.category), "Unknown category");

        let old_snapshot = proposal.snapshot.clone();
        let old_labels_set = old_snapshot.labels.clone();
        let new_labels = labels;
        let new_snapshot = ProposalSnapshot {
            editor_id: editor_id.clone(),
            timestamp: env::block_timestamp(),
            labels: new_labels.clone(),
            body: body,
        };
        proposal.snapshot = new_snapshot;
        proposal.snapshot_history.push(old_snapshot);
        let proposal_author = proposal.author_id.clone();
        self.proposals.replace(id.try_into().unwrap(), &proposal.into());

        // Update labels index.
        let new_labels_set = new_labels;
        let labels_to_remove = &old_labels_set - &new_labels_set;
        let labels_to_add = &new_labels_set - &old_labels_set;
        require!(
            self.is_allowed_to_use_labels(
                Some(editor_id.clone()),
                labels_to_remove.iter().cloned().collect()
            ),
            "Not allowed to remove these labels"
        );
        require!(
            self.is_allowed_to_use_labels(
                Some(editor_id.clone()),
                labels_to_add.iter().cloned().collect()
            ),
            "Not allowed to add these labels"
        );

        for label_to_remove in labels_to_remove {
            let mut proposals = self.label_to_proposals.get(&label_to_remove).unwrap();
            proposals.remove(&id);
            self.label_to_proposals.insert(&label_to_remove, &proposals);
        }

        for label_to_add in labels_to_add {
            let mut proposals = self.label_to_proposals.get(&label_to_add).unwrap_or_default();
            proposals.insert(id);
            self.label_to_proposals.insert(&label_to_add, &proposals);
        }

        notify::notify_edit_proposal(id, proposal_author)
    }

    pub fn get_allowed_categories(&self) -> Vec<String> {
        near_sdk::log!("get_allowed_categories");
        self.proposal_categories.clone()
    }

    #[payable]
    pub fn set_allowed_categories(&mut self, new_categories: Vec<String>) {
        let editor_id = env::predecessor_account_id();
        require!(
            self.has_moderator(editor_id.clone()) || editor_id.clone() == env::current_account_id(),
            "Only the admin and moderators can set categories"
        );
        self.proposal_categories = new_categories;
    }

    pub fn get_community(&self, handle: CommunityHandle) -> Option<Community> {
        self.communities.get(&handle)
    }

    pub fn get_community_metadata(&self, handle: CommunityHandle) -> Option<CommunityMetadata> {
        self.communities.get(&handle).map(|community| CommunityMetadata {
            admins: community.admins,
            handle: community.handle,
            name: community.name,
            tag: community.tag,
            description: community.description,
            logo_url: community.logo_url,
            banner_url: community.banner_url,
            bio_markdown: community.bio_markdown,
        })
    }

    pub fn get_account_community_permissions(
        &self,
        account_id: AccountId,
        community_handle: CommunityHandle,
    ) -> CommunityPermissions {
        let community = self.get_community(community_handle.to_owned()).expect(
            format!("Community with handle `{}` does not exist", community_handle).as_str(),
        );

        CommunityPermissions {
            can_configure: community.admins.contains(&account_id)
                || self.has_moderator(account_id.to_owned()),

            can_delete: self.has_moderator(account_id),
        }
    }

    pub fn get_all_communities_metadata(&self) -> Vec<CommunityMetadata> {
        near_sdk::log!("get_all_communities");
        self.communities
            .iter()
            .map(|(handle, community)| CommunityMetadata {
                admins: community.admins,
                handle,
                name: community.name,
                tag: community.tag,
                description: community.description,
                logo_url: community.logo_url,
                banner_url: community.banner_url,
                bio_markdown: community.bio_markdown,
            })
            .collect()
    }

    pub fn get_addon(&self, id: AddOnId) -> Option<AddOn> {
        self.available_addons.get(&id)
    }

    pub fn get_all_addons(&self) -> Vec<AddOn> {
        self.available_addons.iter().map(|(_id, add_on)| add_on).collect()
    }

    // Only the contract admin and DevHub moderators
    pub fn create_addon(&mut self, addon: AddOn) {
        if !self.has_moderator(env::predecessor_account_id())
            && env::predecessor_account_id() != env::current_account_id()
        {
            panic!("Only the admin and moderators can create new add-ons");
        }
        if self.get_addon(addon.id.to_owned()).is_some() {
            panic!("Add-on with this id already exists");
        }
        addon.validate();
        self.available_addons.insert(&addon.id.clone(), &addon);
    }

    // ONLY FOR TESTING
    pub fn delete_addon(&mut self, id: AddOnId) {
        // Also delete from communities
        if !self.has_moderator(env::predecessor_account_id())
            && env::predecessor_account_id() != env::current_account_id()
        {
            panic!("Only the admin and moderators can delete add-ons");
        }
        let addon = self
            .get_addon(id.clone())
            .expect(&format!("Add-on with id `{}` does not exist", id))
            .clone();

        self.available_addons.remove(&addon.id);
    }

    pub fn update_addon(&mut self, addon: AddOn) {
        if !self.has_moderator(env::predecessor_account_id())
            && env::predecessor_account_id() != env::current_account_id()
        {
            panic!("Only the admin and moderators can edit add-ons");
        }
        self.available_addons.insert(&addon.id.clone(), &addon);
    }

    pub fn get_community_addons(&self, handle: CommunityHandle) -> Vec<CommunityAddOn> {
        let community = self
            .get_community(handle.clone())
            .expect(format!("Community not found with handle `{}`", handle).as_str());
        return community.addons;
    }

    pub fn set_community_addons(
        &mut self,
        handle: CommunityHandle,
        addons: Vec<CommunityAddOn>,
    ) -> Promise {
        let mut community = self
            .get_community(handle.clone())
            .expect(format!("Community not found with handle `{}`", handle).as_str());
        community.addons = addons;
        self.update_community(handle, community)
    }

    // To add or update parameters set by the configurator widget
    pub fn set_community_addon(
        &mut self,
        handle: CommunityHandle,
        community_addon: CommunityAddOn,
    ) -> Promise {
        let mut community = self
            .get_community(handle.clone())
            .expect(format!("Community not found with handle `{}`", handle).as_str());
        if let Some(existing_addon) =
            community.addons.iter_mut().find(|current| current.id == community_addon.id)
        {
            *existing_addon = community_addon;
        } else {
            community.addons.push(community_addon);
        }
        self.update_community(handle, community)
    }

    fn get_editable_community(&self, handle: &CommunityHandle) -> Option<Community> {
        if self
            .get_account_community_permissions(env::predecessor_account_id(), handle.to_owned())
            .can_configure
        {
            return self.get_community(handle.to_owned());
        } else {
            return None;
        };
    }

    pub fn update_community(
        &mut self,
        handle: CommunityHandle,
        #[allow(unused_mut)] mut community: Community,
    ) -> Promise {
        let _ = self
            .get_editable_community(&handle)
            .expect("Only community admins and hub moderators can configure communities");

        community.validate();
        community.set_default_admin();

        require!(community.handle == handle, "Community handle cannot be changed");
        require!(env::prepaid_gas() >= UPDATE_COMMUNITY_GAS, "Require at least 30 Tgas");
        self.communities.insert(&handle, &community);
        let community_page_link =
            format!("/devhub.near/widget/app?page=community&handle={}", community.handle);
        social_db_contract().with_unused_gas_weight(1).set(json!({
            get_devhub_community_account(&community.handle): {
                "profile": {
                    "name": community.name,
                    "image": {
                        "url": community.logo_url,
                    },
                    "linktree": {
                        "twitter": community.twitter_handle,
                        "github": community.github_handle,
                        "telegram": community.telegram_handle,
                        "website": format!("near.social{community_page_link}"),
                    },
                    "description": format!(
                        "{}\n\nLearn more about our community [on DevHub]({}).",
                        community.bio_markdown.as_ref().unwrap_or(&community.description),
                        community_page_link
                    ),
                    "backgroundImage": {
                        "url": community.banner_url,
                    },
                    "tags": {
                        "community": "",
                        "announcements": "",
                        &community.handle: "",
                    }
                }
            },
            get_devhub_discussions_account(&community.handle):  {
                "profile": {
                    "name": format!("{} (Community Discussions)", community.name),
                    "image": {
                        "url": community.logo_url,
                    },
                    "linktree": {
                        "twitter": community.twitter_handle,
                        "github": community.github_handle,
                        "telegram": community.telegram_handle,
                        "website": format!("near.social{community_page_link}"),
                    },
                    "description": format!("{}\n\nLearn more about our community [on DevHub]({}).", community.description, community_page_link),
                    "backgroundImage": {
                        "url": community.banner_url,
                    },
                    "tags": {
                        "community": "",
                        "discussions": "",
                        &community.handle: "",
                    }
                }
            }
        }))
    }

    pub fn set_community_socialdb(&mut self, handle: CommunityHandle, data: Value) -> Promise {
        let _ = self
            .get_editable_community(&handle)
            .expect("Only community admins and hub moderators can set community Social DB");

        require!(env::prepaid_gas() >= SET_COMMUNITY_SOCIALDB_GAS, "Require at least 30 Tgas");
        social_db_contract()
            .with_unused_gas_weight(1)
            .set(json!({ get_devhub_community_account(&handle): data }))
    }

    pub fn create_discussion(&mut self, handle: CommunityHandle, block_height: Number) -> Promise {
        require!(env::prepaid_gas() >= CREATE_DISCUSSION_GAS, "Require at least 30 Tgas");

        let post_initiator = env::predecessor_account_id();
        let repost = format!("[{{\"key\":\"main\",\"value\":{{\"type\":\"repost\",\"item\":{{\"type\":\"social\",\"path\":\"{}/post/main\",\"blockHeight\":{}}}}}}},{{\"key\":{{\"type\":\"social\",\"path\":\"{}/post/main\",\"blockHeight\":{}}},\"value\":{{\"type\":\"repost\"}}}}]", post_initiator, block_height, post_initiator, block_height);
        let notify = format!("{{\"key\":\"{}\",\"value\":{{\"type\":\"repost\",\"item\":{{\"type\":\"social\",\"path\":\"{}/post/main\",\"blockHeight\":{}}}}}}}", post_initiator, post_initiator, block_height);
        social_db_contract().with_unused_gas_weight(1).set(
            json!({ get_devhub_discussions_account(&handle): {
              "index": {
                "repost": repost,
                "notify": notify
              }
            } }),
        )
    }

    pub fn delete_community(&mut self, handle: CommunityHandle) -> Promise {
        require!(
            self.has_moderator(env::predecessor_account_id()),
            "Only moderators can delete community"
        );

        let community = self
            .get_community(handle.clone())
            .expect(&format!("Community with handle `{}` does not exist", handle));

        self.communities.remove(&community.handle);

        require!(env::prepaid_gas() >= DELETE_COMMUNITY_GAS, "Require at least 30 Tgas");
        ext_devhub_community::ext(get_devhub_community_account(&community.handle).parse().unwrap())
            .with_unused_gas_weight(1)
            .destroy()
    }

    pub fn set_featured_communities(&mut self, handles: Vec<CommunityHandle>) {
        require!(
            self.has_moderator(env::predecessor_account_id()),
            "Only moderators can add featured communities"
        );

        // Check if every handle corresponds to an existing community
        for handle in &handles {
            require!(self.communities.get(&handle).is_some(), "Community does not exist.");
        }

        // Replace the existing featured communities with the new ones
        self.featured_communities =
            handles.into_iter().map(|handle| FeaturedCommunity { handle }).collect();
    }

    pub fn get_featured_communities(&self) -> Vec<Community> {
        self.featured_communities
            .iter()
            .filter_map(|fc| self.get_community(fc.handle.clone()))
            .collect()
    }

    pub fn has_moderator(&self, account_id: AccountId) -> bool {
        let moderators = self.access_control.members_list.get_moderators();
        moderators.contains(&Member::Account(account_id))
    }
}

#[derive(Copy, Clone, Serialize, Deserialize, NearSchema)]
#[serde(crate = "near_sdk::serde")]
pub struct BlockHeightCallbackRetValue {
    proposal_id: ProposalId,
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use crate::community::AddOn;
    use crate::{PostBody, ProposalBodyV0, VersionedProposalBody};
    use near_sdk::test_utils::{get_created_receipts, VMContextBuilder};
    use near_sdk::{testing_env, VMContext};
    use serde_json::json;
    use std::collections::HashSet;
    use std::convert::TryInto;

    use super::Contract;

    fn get_context(is_view: bool) -> VMContext {
        get_context_with_signer(is_view, "bob.near".to_string())
    }

    fn get_context_with_signer(is_view: bool, signer: String) -> VMContext {
        VMContextBuilder::new()
            .signer_account_id(signer.clone().try_into().unwrap())
            .current_account_id(signer.try_into().unwrap())
            .is_view(is_view)
            .build()
    }

    fn get_context_with_current(is_view: bool, signer: String) -> VMContext {
        VMContextBuilder::new()
            .current_account_id(signer.try_into().unwrap())
            .is_view(is_view)
            .build()
    }

    #[allow(dead_code)]
    fn get_context_with_predecessor(is_view: bool, signer: String) -> VMContext {
        VMContextBuilder::new()
            .predecessor_account_id(signer.try_into().unwrap())
            .is_view(is_view)
            .build()
    }

    #[test]
    pub fn test_add_proposal() {
        let context = get_context(false);
        testing_env!(context);
        let mut contract = Contract::new();

        let body: ProposalBodyV0 = near_sdk::serde_json::from_value(json!({
            "proposal_body_version": "V0",
            "name": "another post",
            "description": "Hello to @petersalomonsen.near and @psalomo.near. This is an idea with mentions.",            "category": "Marketing",
            "summary": "sum",
            "linked_proposals": [1, 3],
            "requested_sponsorship_usd_amount": "1000000000",
            "requested_sponsorship_paid_in_currency": "USDT",
            "receiver_account": "polyprogrammist.near",
            "supervisor": "frol.near",
            "requested_sponsor": "neardevdao.near",
            "payouts": [],
            "timeline": {"status": "DRAFT"}
        })).unwrap();
        contract.add_proposal(VersionedProposalBody::V0(body), HashSet::new());
        let receipts = get_created_receipts();
        assert_eq!(3, receipts.len());

        if let near_sdk::mock::MockAction::FunctionCallWeight { method_name, args, .. } =
            &receipts[2].actions[0]
        {
            assert_eq!(method_name, b"set");
            assert_eq!(args, b"{\"data\":{\"bob.near\":{\"index\":{\"notify\":\"[{\\\"key\\\":\\\"petersalomonsen.near\\\",\\\"value\\\":{\\\"type\\\":\\\"devhub/mention\\\",\\\"proposal\\\":0,\\\"notifier\\\":\\\"bob.near\\\"}},{\\\"key\\\":\\\"psalomo.near.\\\",\\\"value\\\":{\\\"type\\\":\\\"devhub/mention\\\",\\\"proposal\\\":0,\\\"notifier\\\":\\\"bob.near\\\"}},{\\\"key\\\":\\\"frol.near\\\",\\\"value\\\":{\\\"type\\\":\\\"devhub/mention\\\",\\\"proposal\\\":0,\\\"notifier\\\":\\\"bob.near\\\"}},{\\\"key\\\":\\\"neardevdao.near\\\",\\\"value\\\":{\\\"type\\\":\\\"devhub/mention\\\",\\\"proposal\\\":0,\\\"notifier\\\":\\\"bob.near\\\"}}]\"}}}}");
        } else {
            assert!(false, "Expected a function call ...")
        }
    }

    #[test]
    pub fn test_add_post_with_mention() {
        let context = get_context(false);
        testing_env!(context);
        let mut contract = Contract::new();

        let body: PostBody = near_sdk::serde_json::from_str(r#"
        {
            "name": "another post",
            "description": "Hello to @petersalomonsen.near and @psalomo.near. This is an idea with mentions.",
            "post_type": "Idea",
            "idea_version": "V1"
        }"#).unwrap();
        contract.add_post(None, body, HashSet::new());
        let receipts = get_created_receipts();
        assert_eq!(2, receipts.len());

        // Extract the method_name and args values
        if let near_sdk::mock::MockAction::FunctionCallWeight { method_name, args, .. } =
            &receipts[1].actions[0]
        {
            assert_eq!(method_name, b"set");
            assert_eq!(args, b"{\"data\":{\"bob.near\":{\"index\":{\"notify\":\"[{\\\"key\\\":\\\"petersalomonsen.near\\\",\\\"value\\\":{\\\"type\\\":\\\"devgovgigs/mention\\\",\\\"post\\\":0}},{\\\"key\\\":\\\"psalomo.near.\\\",\\\"value\\\":{\\\"type\\\":\\\"devgovgigs/mention\\\",\\\"post\\\":0}}]\"}}}}");
        } else {
            assert!(false, "Expected a function call ...")
        }
    }

    #[test]
    pub fn test_create_addon() {
        let context = get_context_with_current(false, "bob.near".to_string());
        testing_env!(context);

        let mut contract = Contract::new();
        let input = fake_addon("CommunityAddOnId".to_string());
        contract.create_addon(input.to_owned());

        let addon = contract.get_addon("CommunityAddOnId".to_owned());

        assert_eq!(addon, Some(input))
    }

    pub fn fake_addon(id: String) -> AddOn {
        let input = AddOn {
            id: id.to_owned(),
            title: "GitHub AddOn".to_owned(),
            description: "Current status of NEARCORE repo".to_owned(),
            view_widget: "custom-viewer-widget".to_owned(),
            configurator_widget: "github-configurator".to_owned(),
            icon: "bi bi-github".to_owned(),
        };
        return input;
    }

    #[test]
    pub fn test_get_all_addons() {
        let context = get_context_with_current(false, "bob.near".to_string());
        testing_env!(context);
        let mut contract = Contract::new();
        let input = fake_addon("CommunityAddOnId".to_string());
        contract.create_addon(input.to_owned());

        let addons = contract.get_all_addons();

        assert_eq!(addons[0], input)
    }

    #[test]
    pub fn test_get_addon() {
        let context = get_context_with_current(false, "bob.near".to_string());
        testing_env!(context);
        let mut contract = Contract::new();
        let input = fake_addon("CommunityAddOnId".to_string());
        contract.create_addon(input.to_owned());

        let addon = contract.get_addon("CommunityAddOnId".to_owned());

        assert_eq!(addon, Some(input))
    }

    #[test]
    pub fn test_update_addon() {
        let context = get_context(false);
        testing_env!(context);
        let mut contract = Contract::new();
        let input = fake_addon("test".to_owned());
        contract.create_addon(input.to_owned());

        contract.update_addon(AddOn { title: "Telegram AddOn".to_owned(), ..input });

        let addons = contract.get_all_addons();

        assert_eq!(addons[0].title, "Telegram AddOn".to_owned());
    }
}

'''
'''--- src/migrations.rs ---
//! Public methods of data model/state migrations between the versions.
//! Should be invocable only by the owner and in most cases should be called only once though the
//! latter is not asserted.

use crate::*;
use near_sdk::{borsh::to_vec, env, near, NearToken, Promise};
use std::cmp::min;
use std::collections::HashSet;

#[near]
#[derive(PanicOnDefault)]
pub struct ContractV1 {
    pub posts: Vector<VersionedPost>,
    pub post_to_parent: LookupMap<PostId, PostId>,
    pub post_to_children: LookupMap<PostId, Vec<PostId>>,
    pub label_to_posts: UnorderedMap<String, HashSet<PostId>>,
}

// From ContractV1 to ContractV2
#[near]
impl Contract {
    fn unsafe_add_acl() {
        let ContractV1 { posts, post_to_parent, post_to_children, label_to_posts } =
            env::state_read().unwrap();
        env::state_write(&ContractV2 {
            posts,
            post_to_parent,
            post_to_children,
            label_to_posts,
            access_control: Default::default(),
        });
    }
}

// // Fake vector purely for the sake of overriding initialization.
// #[derive(BorshSerialize, BorshDeserialize)]
// pub struct FakeVector {
//     len: u64,
//     prefix: Vec<u8>,
// }
//
// impl FakeVector {
//     pub fn new<S>(len: u64, prefix: S) -> Self
//     where
//         S: IntoStorageKey,
//     {
//         Self { len, prefix: prefix.into_storage_key() }
//     }
// }

#[near]
#[derive(PanicOnDefault)]
pub struct ContractV2 {
    pub posts: Vector<VersionedPost>,
    pub post_to_parent: LookupMap<PostId, PostId>,
    pub post_to_children: LookupMap<PostId, Vec<PostId>>,
    pub label_to_posts: UnorderedMap<String, HashSet<PostId>>,
    pub access_control: AccessControl,
}

// From ContractV2 to ContractV3
#[near]
impl Contract {
    fn unsafe_add_post_authors() {
        let ContractV2 { posts, post_to_parent, post_to_children, label_to_posts, access_control } =
            env::state_read().unwrap();
        let authors = UnorderedMap::new(StorageKey::AuthorToAuthorPosts);

        env::state_write(&ContractV3 {
            posts,
            post_to_parent,
            post_to_children,
            label_to_posts,
            access_control,
            authors,
        });
    }

    fn unsafe_insert_old_post_authors(start: u64, end: u64) -> StateVersion {
        let mut contract: ContractV3 = env::state_read().unwrap();
        let total = contract.posts.len();
        let end = min(total, end);
        for i in start..end {
            let versioned_post = contract.posts.get(i);
            if let Some(versioned_post) = versioned_post {
                let post: Post = versioned_post.into();
                let mut author_posts =
                    contract.authors.get(&post.author_id).unwrap_or_else(|| HashSet::new());
                author_posts.insert(post.id);
                contract.authors.insert(&post.author_id, &author_posts);
            }
        }
        env::state_write(&contract);
        StateVersion::V3 { done: end == total, migrated_count: end }
    }
}

#[near]
#[derive(PanicOnDefault)]
pub struct ContractV3 {
    pub posts: Vector<VersionedPost>,
    pub post_to_parent: LookupMap<PostId, PostId>,
    pub post_to_children: LookupMap<PostId, Vec<PostId>>,
    pub label_to_posts: UnorderedMap<String, HashSet<PostId>>,
    pub access_control: AccessControl,
    pub authors: UnorderedMap<AccountId, HashSet<PostId>>,
}

// From ContractV3 to ContractV4
#[near]
impl Contract {
    fn unsafe_add_communities() {
        let ContractV3 {
            posts,
            post_to_parent,
            post_to_children,
            label_to_posts,
            access_control,
            authors,
        } = env::state_read().unwrap();
        env::state_write(&ContractV4 {
            posts,
            post_to_parent,
            post_to_children,
            label_to_posts,
            access_control,
            authors,
            communities: UnorderedMap::new(StorageKey::Communities),
        });
    }
}

#[near]
#[derive(PanicOnDefault)]
pub struct ContractV4 {
    pub posts: Vector<VersionedPost>,
    pub post_to_parent: LookupMap<PostId, PostId>,
    pub post_to_children: LookupMap<PostId, Vec<PostId>>,
    pub label_to_posts: UnorderedMap<String, HashSet<PostId>>,
    pub access_control: AccessControl,
    pub authors: UnorderedMap<AccountId, HashSet<PostId>>,
    pub communities: UnorderedMap<String, CommunityV1>,
}

// From ContractV4 to ContractV5
#[near]
impl Contract {
    fn unsafe_add_featured_communities() {
        let ContractV4 {
            posts,
            post_to_parent,
            post_to_children,
            label_to_posts,
            access_control,
            authors,
            communities,
        } = env::state_read().unwrap();
        env::state_write(&ContractV5 {
            posts,
            post_to_parent,
            post_to_children,
            label_to_posts,
            access_control,
            authors,
            communities,
            featured_communities: Vec::new(),
        });
    }
}

#[near]
#[derive(Clone)]
pub struct CommunityV1 {
    pub handle: CommunityHandle,
    pub admins: Vec<AccountId>,
    pub name: String,
    pub description: String,
    pub bio_markdown: Option<String>,
    pub logo_url: String,
    pub banner_url: String,
    pub tag: String,
    pub github_handle: Option<String>,
    pub telegram_handle: Option<String>,
    pub twitter_handle: Option<String>,
    pub website_url: Option<String>,
    /// JSON string of github board configuration
    pub github: Option<String>,
    pub sponsorship: Option<bool>,
    pub wiki1: Option<WikiPage>,
    pub wiki2: Option<WikiPage>,
}

#[near]
#[derive(PanicOnDefault)]
pub struct ContractV5 {
    pub posts: Vector<VersionedPost>,
    pub post_to_parent: LookupMap<PostId, PostId>,
    pub post_to_children: LookupMap<PostId, Vec<PostId>>,
    pub label_to_posts: UnorderedMap<String, HashSet<PostId>>,
    pub access_control: AccessControl,
    pub authors: UnorderedMap<AccountId, HashSet<PostId>>,
    pub communities: UnorderedMap<String, CommunityV1>,
    pub featured_communities: Vec<FeaturedCommunity>,
}

// From ContractV5 to ContractV6
#[near]
impl Contract {
    fn unsafe_multiple_telegrams() {
        let ContractV5 {
            posts,
            post_to_parent,
            post_to_children,
            label_to_posts,
            access_control,
            authors,
            mut communities,
            featured_communities,
        } = env::state_read().unwrap();

        let migrated_communities: Vec<(String, CommunityV2)> = communities
            .iter()
            .map(|(community_handle, community)| {
                (
                    community_handle,
                    CommunityV2 {
                        handle: community.handle,
                        admins: community.admins,
                        name: community.name,
                        description: community.description,
                        bio_markdown: community.bio_markdown,
                        logo_url: community.logo_url,
                        banner_url: community.banner_url,
                        tag: community.tag,
                        github_handle: community.github_handle,
                        telegram_handle: community.telegram_handle.iter().cloned().collect(),
                        twitter_handle: community.twitter_handle,
                        website_url: community.website_url,
                        github: community.github,
                        sponsorship: community.sponsorship,
                        wiki1: community.wiki1,
                        wiki2: community.wiki2,
                    },
                )
            })
            .collect();

        communities.clear();

        let mut communities_new = UnorderedMap::new(StorageKey::Communities);

        for (k, v) in migrated_communities {
            communities_new.insert(&k, &v);
        }

        env::state_write(&ContractV6 {
            posts,
            post_to_parent,
            post_to_children,
            label_to_posts,
            access_control,
            authors,
            communities: communities_new,
            featured_communities,
        });
    }
}

#[near]
#[derive(Clone)]
pub struct CommunityV2 {
    pub handle: CommunityHandle,
    pub admins: Vec<AccountId>,
    pub name: String,
    pub description: String,
    pub bio_markdown: Option<String>,
    pub logo_url: String,
    pub banner_url: String,
    pub tag: String,
    pub github_handle: Option<String>,
    pub telegram_handle: Vec<String>,
    pub twitter_handle: Option<String>,
    pub website_url: Option<String>,
    /// JSON string of github board configuration
    pub github: Option<String>,
    pub sponsorship: Option<bool>,
    pub wiki1: Option<WikiPage>,
    pub wiki2: Option<WikiPage>,
}

#[near]
#[derive(PanicOnDefault)]
pub struct ContractV6 {
    pub posts: Vector<VersionedPost>,
    pub post_to_parent: LookupMap<PostId, PostId>,
    pub post_to_children: LookupMap<PostId, Vec<PostId>>,
    pub label_to_posts: UnorderedMap<String, HashSet<PostId>>,
    pub access_control: AccessControl,
    pub authors: UnorderedMap<AccountId, HashSet<PostId>>,
    pub communities: UnorderedMap<String, CommunityV2>,
    pub featured_communities: Vec<FeaturedCommunity>,
}

// From ContractV6 to ContractV7
#[near]
impl Contract {
    fn unsafe_add_board_and_feature_flags() {
        let ContractV6 {
            posts,
            post_to_parent,
            post_to_children,
            label_to_posts,
            access_control,
            authors,
            mut communities,
            featured_communities,
        } = env::state_read().unwrap();

        let migrated_communities: Vec<(String, CommunityV3)> = communities
            .iter()
            .map(|(community_handle, community)| {
                (
                    community_handle,
                    CommunityV3 {
                        admins: community.admins,
                        handle: community.handle,
                        name: community.name,
                        tag: community.tag,
                        description: community.description,
                        logo_url: community.logo_url,
                        banner_url: community.banner_url,
                        bio_markdown: community.bio_markdown,
                        github_handle: community.github_handle,
                        telegram_handle: community.telegram_handle,
                        twitter_handle: community.twitter_handle,
                        website_url: community.website_url,
                        github: community.github,
                        board: None,
                        wiki1: community.wiki1,
                        wiki2: community.wiki2,

                        features: CommunityFeatureFlags {
                            telegram: true,
                            github: true,
                            board: true,
                            wiki: true,
                        },
                    },
                )
            })
            .collect();

        communities.clear();

        let mut communities_new = UnorderedMap::new(StorageKey::Communities);

        for (k, v) in migrated_communities {
            communities_new.insert(&k, &v);
        }

        env::state_write(&ContractV7 {
            posts,
            post_to_parent,
            post_to_children,
            label_to_posts,
            access_control,
            authors,
            communities: communities_new,
            featured_communities,
        });
    }
}

#[near]
#[derive(Clone)]
pub struct CommunityV3 {
    pub admins: Vec<AccountId>,
    pub handle: CommunityHandle,
    pub name: String,
    pub tag: String,
    pub description: String,
    pub logo_url: String,
    pub banner_url: String,
    pub bio_markdown: Option<String>,
    pub github_handle: Option<String>,
    pub telegram_handle: Vec<String>,
    pub twitter_handle: Option<String>,
    pub website_url: Option<String>,
    /// JSON string of github board configuration
    pub github: Option<String>,
    /// JSON string of kanban board configuration
    pub board: Option<String>,
    pub wiki1: Option<WikiPage>,
    pub wiki2: Option<WikiPage>,
    pub features: CommunityFeatureFlags,
}

#[near]
#[derive(PanicOnDefault)]
pub struct ContractV7 {
    pub posts: Vector<VersionedPost>,
    pub post_to_parent: LookupMap<PostId, PostId>,
    pub post_to_children: LookupMap<PostId, Vec<PostId>>,
    pub label_to_posts: UnorderedMap<String, HashSet<PostId>>,
    pub access_control: AccessControl,
    pub authors: UnorderedMap<AccountId, HashSet<PostId>>,
    pub communities: UnorderedMap<String, CommunityV3>,
    pub featured_communities: Vec<FeaturedCommunity>,
}

// From ContractV7 to ContractV8
#[near]
impl Contract {
    fn unsafe_add_community_addons() {
        let ContractV7 {
            posts,
            post_to_parent,
            post_to_children,
            label_to_posts,
            access_control,
            authors,
            mut communities,
            featured_communities,
        } = env::state_read().unwrap();

        let migrated_communities: Vec<(String, CommunityV4)> = communities
            .iter()
            .map(|(community_handle, community)| {
                (
                    community_handle,
                    CommunityV4 {
                        admins: community.admins,
                        handle: community.handle,
                        name: community.name,
                        tag: community.tag,
                        description: community.description,
                        logo_url: community.logo_url,
                        banner_url: community.banner_url,
                        bio_markdown: community.bio_markdown,
                        github_handle: community.github_handle,
                        telegram_handle: community.telegram_handle,
                        twitter_handle: community.twitter_handle,
                        website_url: community.website_url,
                        github: community.github,
                        board: None,
                        wiki1: community.wiki1,
                        wiki2: community.wiki2,
                        features: community.features,
                        addons: Vec::new(),
                    },
                )
            })
            .collect();

        communities.clear();

        let mut communities_new = UnorderedMap::new(StorageKey::Communities);

        for (k, v) in migrated_communities {
            communities_new.insert(&k, &v);
        }

        env::state_write(&ContractV8 {
            posts,
            post_to_parent,
            post_to_children,
            label_to_posts,
            access_control,
            authors,
            communities: communities_new,
            featured_communities,
            available_addons: UnorderedMap::new(StorageKey::AddOns),
        });
    }
}

#[near]
pub struct CommunityV4 {
    pub admins: Vec<AccountId>,
    pub handle: CommunityHandle,
    pub name: String,
    pub tag: String,
    pub description: String,
    pub logo_url: String,
    pub banner_url: String,
    pub bio_markdown: Option<String>,
    pub github_handle: Option<String>,
    pub telegram_handle: Vec<String>,
    pub twitter_handle: Option<String>,
    pub website_url: Option<String>,
    /// JSON string of github board configuration
    pub github: Option<String>,
    /// JSON string of kanban board configuration
    pub board: Option<String>,
    pub wiki1: Option<WikiPage>,
    pub wiki2: Option<WikiPage>,
    pub features: CommunityFeatureFlags,
    pub addons: Vec<CommunityAddOn>,
}

#[near]
#[derive(PanicOnDefault)]
pub struct ContractV8 {
    pub posts: Vector<VersionedPost>,
    pub post_to_parent: LookupMap<PostId, PostId>,
    pub post_to_children: LookupMap<PostId, Vec<PostId>>,
    pub label_to_posts: UnorderedMap<String, HashSet<PostId>>,
    pub access_control: AccessControl,
    pub authors: UnorderedMap<AccountId, HashSet<PostId>>,
    pub communities: UnorderedMap<String, CommunityV4>,
    pub featured_communities: Vec<FeaturedCommunity>,
    pub available_addons: UnorderedMap<AddOnId, AddOn>,
}

// From ContractV8 to ContractV9
#[near]
impl Contract {
    fn unsafe_clean_up_community() {
        let ContractV8 {
            posts,
            post_to_parent,
            post_to_children,
            label_to_posts,
            access_control,
            authors,
            mut communities,
            featured_communities,
            available_addons,
        } = env::state_read().unwrap();
        let migrated_communities: Vec<(String, CommunityV5)> = communities
            .iter()
            .map(|(community_handle, community)| {
                (
                    community_handle,
                    CommunityV5 {
                        admins: community.admins,
                        handle: community.handle,
                        name: community.name,
                        tag: community.tag,
                        description: community.description,
                        logo_url: community.logo_url,
                        banner_url: community.banner_url,
                        bio_markdown: community.bio_markdown,
                        github_handle: community.github_handle,
                        telegram_handle: community.telegram_handle.first().cloned(),
                        twitter_handle: community.twitter_handle,
                        website_url: community.website_url,
                        addons: community.addons,
                    },
                )
            })
            .collect();

        communities.clear();

        let mut communities_new = UnorderedMap::new(StorageKey::Communities);

        for (k, v) in migrated_communities {
            communities_new.insert(&k, &v);
        }

        env::state_write(&ContractV9 {
            posts,
            post_to_parent,
            post_to_children,
            label_to_posts,
            access_control,
            authors,
            communities: communities_new,
            featured_communities,
            available_addons,
        });
    }
}

#[near]
pub struct CommunityV5 {
    pub admins: Vec<AccountId>,
    pub handle: CommunityHandle,
    pub name: String,
    pub tag: String,
    pub description: String,
    pub logo_url: String,
    pub banner_url: String,
    pub bio_markdown: Option<String>,
    pub github_handle: Option<String>,
    pub telegram_handle: Option<String>,
    pub twitter_handle: Option<String>,
    pub website_url: Option<String>,
    pub addons: Vec<CommunityAddOn>,
}

#[near]
#[derive(PanicOnDefault)]
pub struct ContractV9 {
    pub posts: Vector<VersionedPost>,
    pub post_to_parent: LookupMap<PostId, PostId>,
    pub post_to_children: LookupMap<PostId, Vec<PostId>>,
    pub label_to_posts: UnorderedMap<String, HashSet<PostId>>,
    pub access_control: AccessControl,
    pub authors: UnorderedMap<AccountId, HashSet<PostId>>,
    pub communities: UnorderedMap<String, CommunityV5>,
    pub featured_communities: Vec<FeaturedCommunity>,
    pub available_addons: UnorderedMap<AddOnId, AddOn>,
}

// From ContractV9 to ContractV10
#[near]
impl Contract {
    fn unsafe_add_proposals() {
        let ContractV9 {
            posts,
            post_to_parent,
            post_to_children,
            label_to_posts,
            access_control,
            authors,
            communities,
            featured_communities,
            available_addons,
        } = env::state_read().unwrap();

        env::state_write(&ContractV10 {
            posts,
            post_to_parent,
            post_to_children,
            label_to_posts,
            access_control,
            authors,
            proposals: Vector::new(StorageKey::Proposals),
            label_to_proposals: UnorderedMap::new(StorageKey::LabelToProposals),
            author_proposals: UnorderedMap::new(StorageKey::AuthorProposals),
            proposal_categories: default_categories(),
            communities,
            featured_communities,
            available_addons,
        });
    }
}

#[near]
#[derive(PanicOnDefault)]
pub struct ContractV10 {
    pub posts: Vector<VersionedPost>,
    pub post_to_parent: LookupMap<PostId, PostId>,
    pub post_to_children: LookupMap<PostId, Vec<PostId>>,
    pub label_to_posts: UnorderedMap<String, HashSet<PostId>>,
    pub access_control: AccessControl,
    pub authors: UnorderedMap<AccountId, HashSet<PostId>>,
    pub proposals: Vector<VersionedProposal>,
    pub label_to_proposals: UnorderedMap<String, HashSet<ProposalId>>,
    pub author_proposals: UnorderedMap<AccountId, HashSet<ProposalId>>,
    pub proposal_categories: Vec<String>,
    pub communities: UnorderedMap<CommunityHandle, CommunityV5>,
    pub featured_communities: Vec<FeaturedCommunity>,
    pub available_addons: UnorderedMap<AddOnId, AddOn>,
}

#[near]
#[derive(Debug)]
pub(crate) enum StateVersion {
    V1,
    V2,
    V3 { done: bool, migrated_count: u64 },
    V4,
    V5,
    V6,
    V7,
    V8,
    V9,
    V10,
}

const VERSION_KEY: &[u8] = b"VERSION";

fn state_version_read() -> StateVersion {
    env::storage_read(VERSION_KEY)
        .map(|data| {
            StateVersion::try_from_slice(&data).expect("Cannot deserialize the contract state.")
        })
        .unwrap_or(StateVersion::V2) // StateVersion is introduced in production contract with V2 State.
}

pub(crate) fn state_version_write(version: &StateVersion) {
    let data = to_vec(&version).expect("Cannot serialize the contract state.");
    env::storage_write(VERSION_KEY, &data);
    near_sdk::log!("Migrated to version: {:?}", version);
}

#[near]
impl Contract {
    pub fn unsafe_self_upgrade() {
        near_sdk::assert_self();

        let contract = env::input().expect("No contract code is attached in input");
        Promise::new(env::current_account_id())
            .deploy_contract(contract)
            .then(Promise::new(env::current_account_id()).function_call(
                "unsafe_migrate".to_string(),
                Vec::new(),
                NearToken::from_near(0),
                env::prepaid_gas().saturating_sub(near_sdk::Gas::from_tgas(100)),
            ))
            .as_return();
    }

    fn migration_done() {
        near_sdk::log!("Migration done.");
        env::value_return(b"\"done\"");
    }

    fn needs_migration() {
        env::value_return(b"\"needs-migration\"");
    }

    pub fn unsafe_migrate() {
        near_sdk::assert_self();
        let current_version = state_version_read();
        near_sdk::log!("Migrating from version: {:?}", current_version);
        match current_version {
            StateVersion::V1 => {
                Contract::unsafe_add_acl();
                state_version_write(&StateVersion::V2);
            }
            StateVersion::V2 => {
                Contract::unsafe_add_post_authors();
                state_version_write(&StateVersion::V3 { done: false, migrated_count: 0 })
            }
            StateVersion::V3 { done: false, migrated_count } => {
                let new_version =
                    Contract::unsafe_insert_old_post_authors(migrated_count, migrated_count + 100);
                state_version_write(&new_version);
            }
            StateVersion::V3 { done: true, migrated_count: _ } => {
                Contract::unsafe_add_communities();
                state_version_write(&StateVersion::V4);
            }
            StateVersion::V4 => {
                Contract::unsafe_add_featured_communities();
                state_version_write(&StateVersion::V5);
            }
            StateVersion::V5 => {
                Contract::unsafe_multiple_telegrams();
                state_version_write(&StateVersion::V6);
            }
            StateVersion::V6 => {
                Contract::unsafe_add_board_and_feature_flags();
                state_version_write(&StateVersion::V7);
            }
            StateVersion::V7 => {
                Contract::unsafe_add_community_addons();
                state_version_write(&StateVersion::V8);
            }
            StateVersion::V8 => {
                Contract::unsafe_clean_up_community();
                state_version_write(&StateVersion::V9);
            }
            StateVersion::V9 => {
                Contract::unsafe_add_proposals();
                state_version_write(&StateVersion::V10);
            }
            _ => {
                return Contract::migration_done();
            }
        }
        Contract::needs_migration();
    }
}

'''
'''--- src/notify.rs ---
use crate::{get_subscribers, PostId, Proposal, ProposalId};
use devhub_common::social_db_contract;
use near_sdk::serde_json::json;
use near_sdk::{env, AccountId, Promise};

pub fn get_text_mentions(text: &str) -> Vec<String> {
    let mut mentions = Vec::new();
    let mut mention = String::new();
    let mut recording = false;

    for ch in text.chars() {
        if recording {
            if ch.is_alphanumeric() || ch == '.' {
                mention.push(ch);
            } else {
                if !mention.is_empty() {
                    mentions.push(mention.clone());
                    mention.clear();
                }
                recording = false;
            }
        }

        if ch == '@' {
            recording = true;
        }
    }

    // Push the last mention if it wasn't pushed yet
    if recording && !mention.is_empty() {
        mentions.push(mention);
    }

    mentions
}

pub fn notify_accounts(
    notifier: AccountId,
    accounts: Vec<String>,
    notify_value: serde_json::Value,
) -> Promise {
    if !accounts.is_empty() {
        let mut notify_values = Vec::new();

        for account in accounts {
            notify_values.push(json!({
                "key": account,
                "value": notify_value,
            }));
        }

        social_db_contract()
            .with_static_gas(env::prepaid_gas().saturating_div(4))
            .with_attached_deposit(env::attached_deposit())
            .set(json!({
                notifier : {
                    "index": {
                        "notify": json!(notify_values).to_string()
                    }
                }
            }))
    } else {
        Promise::new(env::current_account_id())
    }
}

pub fn notify_proposal_subscribers(proposal: &Proposal) -> Promise {
    let accounts = get_subscribers(&proposal.snapshot.body.clone().latest_version());

    notify_accounts(
        env::current_account_id(),
        accounts,
        json!({
            "type": "devhub/mention",
            "proposal": proposal.id,
            "notifier": env::predecessor_account_id(),
        }),
    )
}

pub fn notify_mentions(text: &str, post_id: PostId) -> Promise {
    let mentions = get_text_mentions(text);

    notify_accounts(
        env::predecessor_account_id(),
        mentions,
        json!({
            "type": "devgovgigs/mention",
            "post": post_id,
        }),
    )
}

pub fn notify_like(post_id: PostId, post_author: AccountId) -> Promise {
    notify(env::predecessor_account_id(), post_author, notify_value(post_id, "like"))
}

pub fn notify_reply(post_id: PostId, post_author: AccountId) -> Promise {
    notify(env::predecessor_account_id(), post_author, notify_value(post_id, "reply"))
}

pub fn notify_edit(post_id: PostId, post_author: AccountId) -> Promise {
    notify(env::predecessor_account_id(), post_author, notify_value(post_id, "edit"))
}

pub fn notify_edit_proposal(proposal_id: ProposalId, post_author: AccountId) -> Promise {
    notify(
        env::current_account_id(),
        post_author,
        json!({
            "type": "devhub/edit",
            "proposal": proposal_id,
            "notifier": env::predecessor_account_id(),
        }),
    )
}

fn notify_value(post_id: PostId, action: &str) -> serde_json::Value {
    json!({
        "type": format!("devgovgigs/{}", action),
        "post": post_id,
    })
}

fn notify(notifier: AccountId, post_author: AccountId, notify_value: serde_json::Value) -> Promise {
    social_db_contract()
        .with_static_gas(env::prepaid_gas().saturating_div(4))
        .with_attached_deposit(env::attached_deposit())
        .set(json!({
            notifier : {
                "index": {
                    "notify": json!({
                        "key": post_author,
                        "value": notify_value,
                    }).to_string()
                }
            }
        }))
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use super::notify_mentions;

    use near_sdk::test_utils::{get_created_receipts, VMContextBuilder};
    use near_sdk::{testing_env, VMContext};

    fn get_context(is_view: bool) -> VMContext {
        VMContextBuilder::new()
            .signer_account_id("bob.near".parse().unwrap())
            .is_view(is_view)
            .build()
    }

    #[test]
    pub fn test_notify_mentions() {
        let context = get_context(false);
        testing_env!(context);
        let text = "Mentioning @a.near and @bcdefg.near";
        notify_mentions(text, 2);
        let receipts = get_created_receipts();
        assert_eq!(1, receipts.len());

        if let near_sdk::mock::MockAction::FunctionCallWeight { method_name, args, .. } =
            &receipts[0].actions[0]
        {
            assert_eq!(method_name, b"set");
            assert_eq!(args, b"{\"data\":{\"bob.near\":{\"index\":{\"notify\":\"[{\\\"key\\\":\\\"a.near\\\",\\\"value\\\":{\\\"type\\\":\\\"devgovgigs/mention\\\",\\\"post\\\":2}},{\\\"key\\\":\\\"bcdefg.near\\\",\\\"value\\\":{\\\"type\\\":\\\"devgovgigs/mention\\\",\\\"post\\\":2}}]\"}}}}");
        } else {
            assert!(false, "Expected a function call ...")
        }
    }

    #[test]
    pub fn test_no_mentions() {
        let context = get_context(false);
        testing_env!(context);
        let text = "Not mentioning anyone";
        notify_mentions(text, 2);
        assert_eq!(1, get_created_receipts().len());
        assert_eq!(0, get_created_receipts()[0].actions.len());
    }
}

'''
'''--- src/post/attestation.rs ---
use super::{Like, PostStatus};
use crate::str_serializers::*;
use crate::{AttestationId, CommentId, SolutionId};
use near_sdk::borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, NearSchema, Timestamp};
use std::collections::HashSet;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, NearSchema)]
#[serde(crate = "near_sdk::serde")]
#[borsh(crate = "near_sdk::borsh")]
pub struct Attestation {
    // Common fields
    pub id: AttestationId,
    pub name: String,
    pub description: String,
    pub author_id: AccountId,
    #[serde(
        serialize_with = "u64_dec_format::serialize",
        deserialize_with = "u64_dec_format::deserialize"
    )]
    pub timestamp: Timestamp,
    pub status: PostStatus,
    pub likes: HashSet<Like>,
    pub comments: Vec<CommentId>,

    //Specific fields
    #[serde(
        serialize_with = "u64_dec_format::serialize",
        deserialize_with = "u64_dec_format::deserialize"
    )]
    pub submission_id: SolutionId,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, NearSchema)]
#[serde(crate = "near_sdk::serde")]
#[borsh(crate = "near_sdk::borsh")]
pub struct AttestationV1 {
    pub name: String,
    pub description: String,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, NearSchema)]
#[serde(crate = "near_sdk::serde")]
#[serde(tag = "attestation_version")]
#[borsh(crate = "near_sdk::borsh")]
pub enum VersionedAttestation {
    V0(Attestation),
    V1(AttestationV1),
}

impl VersionedAttestation {
    pub fn latest_version(self) -> AttestationV1 {
        self.into()
    }
}

impl From<VersionedAttestation> for Attestation {
    fn from(va: VersionedAttestation) -> Self {
        match va {
            VersionedAttestation::V0(v0) => v0,
            VersionedAttestation::V1(_) => unimplemented!(),
        }
    }
}

impl From<VersionedAttestation> for AttestationV1 {
    fn from(va: VersionedAttestation) -> Self {
        match va {
            VersionedAttestation::V0(_) => unimplemented!(),
            VersionedAttestation::V1(v1) => v1,
        }
    }
}

impl From<Attestation> for VersionedAttestation {
    fn from(a: Attestation) -> Self {
        VersionedAttestation::V0(a)
    }
}

'''
'''--- src/post/comment.rs ---
use super::Like;
use crate::str_serializers::*;
use crate::CommentId;
use near_sdk::borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, NearSchema, Timestamp};
use std::collections::HashSet;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, NearSchema)]
#[serde(crate = "near_sdk::serde")]
#[borsh(crate = "near_sdk::borsh")]
pub struct CommentV0 {
    pub author_id: AccountId,
    #[serde(
        serialize_with = "u64_dec_format::serialize",
        deserialize_with = "u64_dec_format::deserialize"
    )]
    pub timestamp: Timestamp,
    pub description: String,
    pub likes: HashSet<Like>,
    pub comments: Vec<CommentId>,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, NearSchema)]
#[serde(crate = "near_sdk::serde")]
#[borsh(crate = "near_sdk::borsh")]
pub struct Comment {
    pub id: CommentId,
    pub author_id: AccountId,
    #[serde(
        serialize_with = "u64_dec_format::serialize",
        deserialize_with = "u64_dec_format::deserialize"
    )]
    pub timestamp: Timestamp,
    pub description: String,
    pub likes: HashSet<Like>,
    pub comments: Vec<CommentId>,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, NearSchema)]
#[serde(crate = "near_sdk::serde")]
#[borsh(crate = "near_sdk::borsh")]
pub struct CommentV2 {
    pub description: String,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, NearSchema)]
#[serde(crate = "near_sdk::serde")]
#[serde(tag = "comment_version")]
#[borsh(crate = "near_sdk::borsh")]
pub enum VersionedComment {
    V0(CommentV0),
    V1(Comment),
    V2(CommentV2),
}

impl VersionedComment {
    pub fn latest_version(self) -> CommentV2 {
        self.into()
    }
}

impl From<VersionedComment> for Comment {
    fn from(vc: VersionedComment) -> Self {
        match vc {
            VersionedComment::V0(v0) => Comment {
                id: 0,
                author_id: v0.author_id,
                timestamp: v0.timestamp,
                description: v0.description,
                likes: v0.likes,
                comments: v0.comments,
            },
            VersionedComment::V1(v1) => v1,
            VersionedComment::V2(_) => unimplemented!(),
        }
    }
}

impl From<VersionedComment> for CommentV2 {
    fn from(vc: VersionedComment) -> Self {
        match vc {
            VersionedComment::V2(v2) => v2,
            _ => unimplemented!(),
        }
    }
}

impl From<Comment> for VersionedComment {
    fn from(c: Comment) -> Self {
        VersionedComment::V1(c)
    }
}

'''
'''--- src/post/github.rs ---
use near_sdk::borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
#[borsh(crate = "near_sdk::borsh")]
pub struct GithubV0 {
    pub github_link: String,
    pub name: String,
    pub description: String,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
#[serde(tag = "github_version")]
#[borsh(crate = "near_sdk::borsh")]
pub enum VersionedGithub {
    V0(GithubV0),
}

impl From<GithubV0> for VersionedGithub {
    fn from(v0: GithubV0) -> Self {
        VersionedGithub::V0(v0)
    }
}

impl From<VersionedGithub> for GithubV0 {
    fn from(vg: VersionedGithub) -> Self {
        match vg {
            VersionedGithub::V0(v0) => v0,
        }
    }
}

'''
'''--- src/post/idea.rs ---
use super::{Like, PostStatus};
use crate::{CommentId, IdeaId, SolutionId};
use near_sdk::borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, NearSchema, Timestamp};
use std::collections::HashSet;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, NearSchema)]
#[serde(crate = "near_sdk::serde")]
#[borsh(crate = "near_sdk::borsh")]
pub struct Idea {
    // Common Fields
    pub id: IdeaId,
    pub name: String,
    pub description: String,
    pub author_id: AccountId,
    pub timestamp: Timestamp,
    pub status: PostStatus,
    pub likes: HashSet<Like>,
    pub comments: Vec<CommentId>,

    // Specific fields
    pub solutions: Vec<SolutionId>,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, NearSchema)]
#[serde(crate = "near_sdk::serde")]
#[borsh(crate = "near_sdk::borsh")]
pub struct IdeaV1 {
    pub name: String,
    pub description: String,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, NearSchema)]
#[serde(crate = "near_sdk::serde")]
#[serde(tag = "idea_version")]
#[borsh(crate = "near_sdk::borsh")]
pub enum VersionedIdea {
    V0(Idea),
    V1(IdeaV1),
}

impl VersionedIdea {
    pub fn latest_version(self) -> IdeaV1 {
        self.into()
    }
}

impl From<VersionedIdea> for Idea {
    fn from(vi: VersionedIdea) -> Self {
        match vi {
            VersionedIdea::V0(v0) => v0,
            VersionedIdea::V1(_) => unimplemented!(),
        }
    }
}

impl From<VersionedIdea> for IdeaV1 {
    fn from(vi: VersionedIdea) -> Self {
        match vi {
            VersionedIdea::V1(v1) => v1,
            _ => unimplemented!(),
        }
    }
}

impl From<Idea> for VersionedIdea {
    fn from(idea: Idea) -> Self {
        VersionedIdea::V0(idea)
    }
}

'''
'''--- src/post/like.rs ---
use crate::str_serializers::*;
use near_sdk::borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, NearSchema, Timestamp};
use std::cmp::Ordering;
use std::hash::{Hash, Hasher};

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Ord, NearSchema)]
#[serde(crate = "near_sdk::serde")]
#[borsh(crate = "near_sdk::borsh")]
pub struct Like {
    pub author_id: AccountId,
    #[serde(
        serialize_with = "u64_dec_format::serialize",
        deserialize_with = "u64_dec_format::deserialize"
    )]
    pub timestamp: Timestamp,
}

impl Hash for Like {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.author_id.hash(state)
    }
}

impl PartialEq for Like {
    fn eq(&self, other: &Self) -> bool {
        self.author_id.eq(&other.author_id)
    }
}

impl PartialOrd for Like {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.author_id.partial_cmp(&other.author_id)
    }
}

impl Eq for Like {}

'''
'''--- src/post/mod.rs ---
mod attestation;
mod comment;
mod github;
mod idea;
mod like;
mod solution;
mod sponsorship;

use crate::str_serializers::*;
pub use attestation::*;
pub use comment::*;
pub use idea::*;
pub use like::*;
use near_sdk::borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, BorshStorageKey, CryptoHash, NearSchema, Timestamp};
pub use solution::*;
pub use sponsorship::*;
use std::collections::HashSet;

pub type Balance = u128;
pub type PostId = u64;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
#[borsh(crate = "near_sdk::borsh")]
pub enum PostType {
    Comment,
    Idea,
    Solution,
    Attestation,
    Sponsorship,
    Github,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, NearSchema)]
#[serde(crate = "near_sdk::serde")]
#[borsh(crate = "near_sdk::borsh")]
pub enum PostStatus {
    Open,
    Closed { reason: String },
}

#[derive(BorshSerialize, BorshStorageKey)]
#[borsh(crate = "near_sdk::borsh")]
pub enum StorageKey {
    Ideas,
    Solutions,
    Attestations,
    Sponsorships,
    Comments,
    Posts,
    PostToParent,
    PostToChildren,
    /// Deprecated due to damaged storage state.
    LabelToPosts,
    LabelToPostsV2,
    AuthorToAuthorPosts,
    AuthorPosts(CryptoHash),
    Communities,
    AddOns,
    Proposals,
    LabelToProposals,
    AuthorProposals,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, NearSchema)]
#[serde(crate = "near_sdk::serde")]
#[serde(tag = "post_version")]
#[borsh(crate = "near_sdk::borsh")]
pub enum VersionedPost {
    V0(Post),
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, NearSchema)]
#[serde(crate = "near_sdk::serde")]
#[borsh(crate = "near_sdk::borsh")]
pub struct Post {
    pub id: PostId,
    pub author_id: AccountId,
    pub likes: HashSet<Like>,
    pub snapshot: PostSnapshot,
    // Excludes the current snapshot itself.
    pub snapshot_history: Vec<PostSnapshot>,
}

type PostTag = String;

impl From<VersionedPost> for Post {
    fn from(vp: VersionedPost) -> Self {
        match vp {
            VersionedPost::V0(v0) => v0,
        }
    }
}

impl From<Post> for VersionedPost {
    fn from(p: Post) -> Self {
        VersionedPost::V0(p)
    }
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, NearSchema)]
#[serde(crate = "near_sdk::serde")]
#[borsh(crate = "near_sdk::borsh")]
pub struct PostSnapshot {
    pub editor_id: AccountId,
    #[serde(
        serialize_with = "u64_dec_format::serialize",
        deserialize_with = "u64_dec_format::deserialize"
    )]
    pub timestamp: Timestamp,
    pub labels: HashSet<PostTag>,
    #[serde(flatten)]
    pub body: PostBody,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, NearSchema)]
#[serde(crate = "near_sdk::serde")]
#[serde(tag = "post_type")]
#[borsh(crate = "near_sdk::borsh")]
pub enum PostBody {
    Comment(VersionedComment),
    Idea(VersionedIdea),
    Solution(VersionedSolution),
    Attestation(VersionedAttestation),
    Sponsorship(VersionedSponsorship),
}

pub fn get_post_description(post: Post) -> String {
    return match post.snapshot.body.clone() {
        PostBody::Comment(comment) => comment.latest_version().description,
        PostBody::Idea(idea) => idea.latest_version().description,
        PostBody::Solution(solution) => solution.latest_version().description,
        PostBody::Attestation(attestation) => attestation.latest_version().description,
        PostBody::Sponsorship(sponsorship) => sponsorship.latest_version().description,
    };
}

'''
'''--- src/post/solution.rs ---
use super::{Like, PostStatus, SponsorshipToken};
use crate::str_serializers::*;
use crate::{AttestationId, Balance, CommentId, SolutionId, SponsorshipId};
use near_sdk::borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, NearSchema, Timestamp};
use std::collections::HashSet;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, NearSchema)]
#[serde(crate = "near_sdk::serde")]
#[borsh(crate = "near_sdk::borsh")]
pub struct SolutionV0 {
    // Common fields
    pub id: SolutionId,
    pub name: String,
    pub description: String,
    pub author_id: AccountId,
    #[serde(
        serialize_with = "u64_dec_format::serialize",
        deserialize_with = "u64_dec_format::deserialize"
    )]
    pub timestamp: Timestamp,
    pub status: PostStatus,
    pub likes: HashSet<Like>,
    pub comments: Vec<CommentId>,

    // Specific fields
    #[serde(
        serialize_with = "u64_dec_format::serialize",
        deserialize_with = "u64_dec_format::deserialize"
    )]
    pub idea_id: u64,
    pub attestations: Vec<AttestationId>,
    pub sponsorships: Vec<SponsorshipId>,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, NearSchema)]
#[serde(crate = "near_sdk::serde")]
#[borsh(crate = "near_sdk::borsh")]
pub struct SolutionV1 {
    pub name: String,
    pub description: String,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, NearSchema)]
#[serde(crate = "near_sdk::serde")]
#[borsh(crate = "near_sdk::borsh")]
pub struct SolutionV2 {
    pub name: String,
    pub description: String,
    pub requested_sponsor: Option<AccountId>,
    #[serde(
        serialize_with = "u128_dec_format::serialize",
        deserialize_with = "u128_dec_format::deserialize"
    )]
    pub requested_sponsorship_amount: Balance,
    pub requested_sponsorship_token: Option<SponsorshipToken>,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, NearSchema)]
#[serde(crate = "near_sdk::serde")]
#[serde(tag = "solution_version")]
#[borsh(crate = "near_sdk::borsh")]
pub enum VersionedSolution {
    V0(SolutionV0),
    V1(SolutionV1),
    V2(SolutionV2),
}

impl VersionedSolution {
    pub fn latest_version(self) -> SolutionV2 {
        self.into()
    }

    pub fn validate(&self) {
        match self {
            VersionedSolution::V2(solution) => {
                if solution.requested_sponsorship_amount > 0
                    && (solution.requested_sponsorship_token.is_none()
                        || solution.requested_sponsor.is_none())
                {
                    panic!(
                        "Solution that requires funding must specify sponsorship token and sponsor"
                    )
                }
            }

            _ => unimplemented!(),
        }
    }
}

impl From<VersionedSolution> for SolutionV0 {
    fn from(solution: VersionedSolution) -> Self {
        match solution {
            VersionedSolution::V0(v0) => v0,
            _ => unimplemented!(),
        }
    }
}

impl From<VersionedSolution> for SolutionV1 {
    fn from(solution: VersionedSolution) -> Self {
        match solution {
            VersionedSolution::V1(v1) => v1,
            _ => unimplemented!(),
        }
    }
}

impl From<SolutionV0> for VersionedSolution {
    fn from(solution: SolutionV0) -> Self {
        VersionedSolution::V0(solution)
    }
}

impl From<VersionedSolution> for SolutionV2 {
    fn from(solution: VersionedSolution) -> Self {
        match solution {
            VersionedSolution::V2(v2) => v2,

            VersionedSolution::V1(v1) => SolutionV2 {
                name: v1.name,
                description: v1.description,
                requested_sponsor: None,
                requested_sponsorship_amount: 0,
                requested_sponsorship_token: None,
            },

            _ => unimplemented!(),
        }
    }
}

'''
'''--- src/post/sponsorship.rs ---
use super::{Like, PostStatus};
use crate::{str_serializers::*, Balance, CommentId, SolutionId, SponsorshipId};
use near_sdk::borsh::{BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, NearSchema, Timestamp};
use std::collections::HashSet;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, NearSchema)]
#[serde(crate = "near_sdk::serde")]
#[borsh(crate = "near_sdk::borsh")]
pub enum SponsorshipToken {
    NEAR,
    NEP141 { address: AccountId },
    USD,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, NearSchema)]
#[serde(crate = "near_sdk::serde")]
#[borsh(crate = "near_sdk::borsh")]
pub struct Sponsorship {
    // Common fields
    pub id: SponsorshipId,
    pub name: String,
    pub description: String,
    pub author_id: AccountId,
    #[serde(
        serialize_with = "u64_dec_format::serialize",
        deserialize_with = "u64_dec_format::deserialize"
    )]
    pub timestamp: Timestamp,
    pub status: PostStatus,
    pub likes: HashSet<Like>,
    pub comments: Vec<CommentId>,

    // Specific fields
    #[serde(
        serialize_with = "u64_dec_format::serialize",
        deserialize_with = "u64_dec_format::deserialize"
    )]
    pub submission_id: SolutionId,
    pub sponsorship_token: SponsorshipToken,
    #[serde(
        serialize_with = "u128_dec_format::serialize",
        deserialize_with = "u128_dec_format::deserialize"
    )]
    pub amount: Balance,
    pub supervisor: AccountId,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, NearSchema)]
#[serde(crate = "near_sdk::serde")]
#[borsh(crate = "near_sdk::borsh")]
pub struct SponsorshipV1 {
    pub name: String,
    pub description: String,
    pub sponsorship_token: SponsorshipToken,
    #[serde(
        serialize_with = "u128_dec_format::serialize",
        deserialize_with = "u128_dec_format::deserialize"
    )]
    pub amount: Balance,
    pub supervisor: AccountId,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, NearSchema)]
#[serde(crate = "near_sdk::serde")]
#[serde(tag = "sponsorship_version")]
#[borsh(crate = "near_sdk::borsh")]
pub enum VersionedSponsorship {
    V0(Sponsorship),
    V1(SponsorshipV1),
}

impl VersionedSponsorship {
    pub fn latest_version(self) -> SponsorshipV1 {
        self.into()
    }
}

impl From<VersionedSponsorship> for Sponsorship {
    fn from(vs: VersionedSponsorship) -> Self {
        match vs {
            VersionedSponsorship::V0(v0) => v0,
            VersionedSponsorship::V1(_) => unimplemented!(),
        }
    }
}

impl From<VersionedSponsorship> for SponsorshipV1 {
    fn from(vs: VersionedSponsorship) -> Self {
        match vs {
            VersionedSponsorship::V1(v1) => v1,
            _ => unimplemented!(),
        }
    }
}

impl From<Sponsorship> for VersionedSponsorship {
    fn from(s: Sponsorship) -> Self {
        VersionedSponsorship::V0(s)
    }
}

'''
'''--- src/proposal/mod.rs ---
pub mod repost;
pub mod timeline;

use std::collections::HashSet;

use self::timeline::TimelineStatus;

use crate::notify::get_text_mentions;
use crate::str_serializers::*;

use near_sdk::{near, AccountId, BlockHeight, Timestamp};

pub type ProposalId = u32;

type PostTag = String;

#[near(serializers=[borsh, json])]
#[derive(Clone)]
#[serde(tag = "proposal_version")]
pub enum VersionedProposal {
    V0(Proposal),
}

#[near(serializers=[borsh, json])]
#[derive(Clone)]
pub struct Proposal {
    pub id: ProposalId,
    pub author_id: AccountId,
    #[serde(
        serialize_with = "u64_dec_format::serialize",
        deserialize_with = "u64_dec_format::deserialize"
    )]
    pub social_db_post_block_height: BlockHeight,
    pub snapshot: ProposalSnapshot,
    // // Excludes the current snapshot itself.
    pub snapshot_history: Vec<ProposalSnapshot>,
}

impl From<VersionedProposal> for Proposal {
    fn from(vp: VersionedProposal) -> Self {
        match vp {
            VersionedProposal::V0(v0) => v0,
        }
    }
}

impl From<Proposal> for VersionedProposal {
    fn from(p: Proposal) -> Self {
        VersionedProposal::V0(p)
    }
}

#[near(serializers=[borsh, json])]
#[derive(Clone)]
pub struct ProposalSnapshot {
    pub editor_id: AccountId,
    #[serde(
        serialize_with = "u64_dec_format::serialize",
        deserialize_with = "u64_dec_format::deserialize"
    )]
    pub timestamp: Timestamp,
    pub labels: HashSet<PostTag>,
    #[serde(flatten)]
    pub body: VersionedProposalBody,
}

#[near(serializers=[borsh, json])]
#[derive(Clone)]
pub struct ProposalBodyV0 {
    pub name: String,
    pub category: String,
    pub summary: String,
    pub description: String,
    pub linked_proposals: Vec<ProposalId>,
    #[serde(
        serialize_with = "u32_dec_format::serialize",
        deserialize_with = "u32_dec_format::deserialize"
    )]
    pub requested_sponsorship_usd_amount: u32,
    pub requested_sponsorship_paid_in_currency: ProposalFundingCurrency,
    pub receiver_account: AccountId,
    pub requested_sponsor: AccountId,
    pub supervisor: Option<AccountId>,
    pub timeline: TimelineStatus,
}

#[near(serializers=[borsh, json])]
#[derive(Clone)]
#[serde(tag = "proposal_body_version")]
pub enum VersionedProposalBody {
    V0(ProposalBodyV0),
}

impl From<VersionedProposalBody> for ProposalBodyV0 {
    fn from(solution: VersionedProposalBody) -> Self {
        match solution {
            VersionedProposalBody::V0(v0) => v0,
        }
    }
}

impl From<ProposalBodyV0> for VersionedProposalBody {
    fn from(p: ProposalBodyV0) -> Self {
        VersionedProposalBody::V0(p)
    }
}

impl VersionedProposalBody {
    pub fn latest_version(self) -> ProposalBodyV0 {
        self.into()
    }
}

pub fn get_subscribers(proposal_body: &ProposalBodyV0) -> Vec<String> {
    let mut result = [
        get_text_mentions(proposal_body.description.as_str()),
        get_text_mentions(proposal_body.summary.as_str()),
    ]
    .concat();
    if let Some(supervisor) = proposal_body.supervisor.clone() {
        result.push(supervisor.to_string());
    }
    result.push(proposal_body.requested_sponsor.to_string());
    result
}

pub fn default_categories() -> Vec<String> {
    vec![
        String::from("DevDAO Operations"),
        String::from("Decentralized DevRel"),
        String::from("NEAR Campus"),
        String::from("Marketing"),
        String::from("Events"),
        String::from("Tooling & Infrastructures"),
        String::from("Other"),
    ]
}

#[near(serializers=[borsh, json])]
#[derive(Clone)]
pub enum ProposalFundingCurrency {
    NEAR,
    USDT,
    USDC,
    OTHER,
}

'''
'''--- src/proposal/repost.rs ---
use near_sdk::serde_json::json;
use near_sdk::{env, AccountId, Promise};

use devhub_common::social_db_contract;

use crate::Proposal;

fn repost_internal(proposal: Proposal, contract_address: AccountId) -> near_sdk::serde_json::Value {
    let proposal_link = format!("/devhub.near/widget/app?page=proposal&id={}", proposal.id);

    let title = proposal.snapshot.body.clone().latest_version().name;
    let summary = proposal.snapshot.body.clone().latest_version().summary;
    let category = proposal.snapshot.body.clone().latest_version().category;

    let text = format!(
        "We have just received a new *{category}* proposal.\n\n\n\n**By**: @{author}\n\n**Title**: {title}\n\n**Summary**:\n\n{summary}\n\n\n\nRead the full proposal and share your feedback on [DevHub]({proposal_link})",
        author = proposal.author_id,
        proposal_link = proposal_link,
        title = title,
        summary = summary,
        category = category
    );

    let main_value = json!({
        "type": "md",
        "text": text
    });

    json!({
        contract_address: {
            "post": {
                "main": main_value.to_string(),
            },
            "index": {
                "post": "{\"key\":\"main\",\"value\":{\"type\":\"md\"}}",
            }
        }
    })
}

pub fn publish_to_socialdb_feed(callback: Promise, proposal: Proposal) -> Promise {
    social_db_contract()
        .with_static_gas(env::prepaid_gas().saturating_div(3))
        .with_attached_deposit(env::attached_deposit())
        .set(repost_internal(proposal, env::current_account_id()))
        .then(callback)
}

'''
'''--- src/proposal/timeline.rs ---
use near_sdk::near;

#[near(serializers=[borsh, json])]
#[derive(Clone)]
#[serde(tag = "status", rename_all = "SCREAMING_SNAKE_CASE")]
pub enum TimelineStatus {
    Draft,
    Review(ReviewStatus),
    Approved(ReviewStatus),
    Rejected(ReviewStatus),
    ApprovedConditionally(ReviewStatus),
    PaymentProcessing(PaymentProcessingStatus),
    Funded(FundedStatus),
    Cancelled(ReviewStatus),
}

impl TimelineStatus {
    pub fn is_draft(&self) -> bool {
        matches!(self, TimelineStatus::Draft)
    }

    pub fn is_empty_review(&self) -> bool {
        match self {
            TimelineStatus::Review(review_status) => {
                !review_status.sponsor_requested_review
                    && !review_status.reviewer_completed_attestation
            }
            _ => false,
        }
    }

    pub fn is_review(&self) -> bool {
        matches!(self, TimelineStatus::Review(..))
    }

    pub fn is_cancelled(&self) -> bool {
        matches!(self, TimelineStatus::Cancelled(..))
    }

    pub fn can_be_cancelled(&self) -> bool {
        match self {
            TimelineStatus::Draft => true,
            TimelineStatus::Review(..) => true,
            _ => false,
        }
    }
}

#[near(serializers=[borsh, json])]
#[derive(Clone)]
pub struct ReviewStatus {
    sponsor_requested_review: bool,
    reviewer_completed_attestation: bool,
}

#[near(serializers=[borsh, json])]
#[derive(Clone)]
pub struct PaymentProcessingStatus {
    #[serde(flatten)]
    review_status: ReviewStatus,
    kyc_verified: bool,
    test_transaction_sent: bool,
    request_for_trustees_created: bool,
}

#[near(serializers=[borsh, json])]
#[derive(Clone)]
pub struct FundedStatus {
    #[serde(flatten)]
    payment_processing_status: PaymentProcessingStatus,
    trustees_released_payment: bool,
    payouts: Vec<String>,
}

'''
'''--- src/repost.rs ---
use crate::post::{get_post_description, Post, PostBody};
use devhub_common::social_db_contract;
use near_sdk::serde_json::json;
use near_sdk::{env, AccountId, Promise};

fn repost_internal(post: Post, contract_address: AccountId) -> near_sdk::serde_json::Value {
    let post_link = format!("/devhub.near/widget/app?page=post&id={}", post.id);
    let title = match post.snapshot.body.clone() {
        PostBody::Idea(idea) => format!("## Idea: {}\n", idea.latest_version().name),
        PostBody::Solution(solution) => {
            format!("## Solution: {}\n", solution.latest_version().name)
        }
        PostBody::Attestation(attestation) => {
            format!("## Attestation: {}\n", attestation.latest_version().name)
        }
        PostBody::Sponsorship(sponsorship) => {
            format!("## Sponsorship: {}\n", sponsorship.latest_version().name)
        }
        _ => Default::default(),
    };

    let desc = get_post_description(post.clone());

    let text = format!(
        "@{author} [Posted on DevHub]({post_link})\n{title}{desc}",
        author = post.author_id,
        post_link = post_link,
        title = title,
        desc = desc
    );

    let main_value = json!({
        "type": "md",
        "text": text
    });

    json!({
        contract_address: {
            "post": {
                "main": main_value.to_string(),
            },
            "index": {
                "post": "{\"key\":\"main\",\"value\":{\"type\":\"md\"}}",
            }
        }
    })
}

pub fn repost(post: Post) -> Promise {
    social_db_contract()
        .with_static_gas(env::prepaid_gas().saturating_div(3))
        .with_attached_deposit(env::attached_deposit())
        .set(repost_internal(post, env::current_account_id()))
}

#[cfg(test)]
mod tests {
    use crate::post::{IdeaV1, Post, PostBody, PostSnapshot, VersionedIdea};
    use crate::repost::repost_internal;
    use near_sdk::serde_json::json;

    #[test]
    pub fn check_formatting() {
        let post = Post {
            id: 0,
            author_id: "neardevgov.near".parse().unwrap(),
            likes: Default::default(),
            snapshot: PostSnapshot {
                editor_id: "neardevgov.near".parse().unwrap(),
                timestamp: 0,
                labels: Default::default(),
                body: PostBody::Idea(VersionedIdea::V1(IdeaV1 { name: "A call for Zero Knowledge Work Group members!".to_string(), description: "We are excited to create a more formal Zero Knowledge Work Group (WG) to oversee official decisions on Zero Knowledge proposals. Were looking for 3-7 experts to participate. Reply to the post if youre interested in becoming a work group member.".to_string() })),
            },
            snapshot_history: vec![],
        };

        let call_args = repost_internal(post, "devhub.near".parse().unwrap());
        let expected = json!({
            "devhub.near": {
                "post": {
                  "main": "{\"type\":\"md\",\"text\":\"@neardevgov.near [Posted on DevHub](/devhub.near/widget/app?page=post&id=0)\\n## Idea: A call for Zero Knowledge Work Group members!\\nWe are excited to create a more formal Zero Knowledge Work Group (WG) to oversee official decisions on Zero Knowledge proposals. Were looking for 3-7 experts to participate. Reply to the post if youre interested in becoming a work group member.\"}"
                },
                "index": {
                  "post": "{\"key\":\"main\",\"value\":{\"type\":\"md\"}}"
                }
              }
        });
        assert_eq!(call_args, expected);
    }
}

'''
'''--- src/stats.rs ---
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{near, NearSchema};

use crate::*;

#[derive(Serialize, Deserialize, NearSchema)]
#[serde(crate = "near_sdk::serde")]
pub struct Stats {
    pub num_posts: u64,
}

#[near]
impl Contract {
    pub fn get_stats(&self) -> Stats {
        Stats { num_posts: self.posts.len() }
    }
}

'''
'''--- src/str_serializers.rs ---
pub mod u128_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u128, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u128, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?.parse().map_err(de::Error::custom)
    }
}

pub mod u64_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u64, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u64, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?.parse().map_err(de::Error::custom)
    }
}

pub mod u32_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u32, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u32, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?.parse().map_err(de::Error::custom)
    }
}

'''
'''--- test.sh ---
#!/bin/bash

contract=i.zxcvn.testnet

# near create-account $contract --masterAccount zxcvn.testnet --initialBalance 10
# near deploy $contract res/devgovgigs.wasm --initFunction new --initArgs '{}'

# for i in $(seq 1 2)
# do
# near call $contract add_post --accountId zxcvn.testnet --deposit 0.01 --args '{"parent_id":null,"body":{"post_type": "Idea","idea_version":"V1","name":"a'$i'","description":"aaa"},"labels":[]}'
# near call $contract add_post --accountId zxcvn.testnet --deposit 0.01 --args '{"parent_id":null,"body":{"post_type": "Idea","idea_version":"V1","name":"b'$i'","description":"bbb"},"labels":[]}'
# near call $contract add_post --accountId a.zxcvn.testnet --deposit 0.01 --args '{"parent_id":null,"body":{"post_type": "Idea","idea_version":"V1","name":"c'$i'","description":"ccc"},"labels":[]}'
# near call $contract add_post --accountId zxcvn.testnet --deposit 0.01 --args '{"parent_id":null,"body":{"post_type": "Idea","idea_version":"V1","name":"d'$i'","description":"ddd"},"labels":[]}'
# done

# near deploy $contract res/devgovgigs.wasm

# near call $contract unsafe_self_upgrade --accountId $contract --args $(base64 < res/devgovgigs.wasm ) --base64 --gas 300000000000000

#near call contract.devhubopen.testnet unsafe_self_upgrade --accountId contract.devhubopen.testnet --args $(base64 < res/devgovgigs.wasm ) --base64 --gas 300000000000000

# near call $contract unsafe_migrate --accountId $contract --gas 300000000000000
'''
'''--- tests/README.md ---
# Integration Test using near-workspaces-rs

This codebase is designed to deploy and test the Devhub contract on a Sandbox node.

## Dependencies

- Rust: For writing the test suite.
- `near-workspaces`: A custom library for handling contract calls.
- `near_units`: For handling NEAR unit conversions.
- `serde_json`: For JSON serialization and deserialization.

### How to Run

To run the test, use the following command:

```bash
cargo test
```

'''
'''--- tests/communities.rs ---
mod test_env;

use near_sdk::NearToken;
use {crate::test_env::*, serde_json::json};

#[tokio::test]
async fn test_community_addon() -> anyhow::Result<()> {
    // Initialize the devhub and near social contract on chain,
    // contract is devhub contract instance.
    let (contract, _, _) = init_contracts_from_res().await?;

    let deposit_amount = NearToken::from_near(4);

    // Add a community
    let _create_community = contract
        .call("create_community")
        .args_json(json!({
            "inputs": {
                "handle": "gotham",
                "name": "Gotham",
                "tag": "some",
                "description": "This is a test community.",
                "bio_markdown": "This is a sample text about your community.\nYou can change it on the community configuration page.",
                "logo_url": "https://ipfs.near.social/ipfs/bafkreibysr2mkwhb4j36h2t7mqwhynqdy4vzjfygfkfg65kuspd2bawauu",
                "banner_url": "https://ipfs.near.social/ipfs/bafkreic4xgorjt6ha5z4s5e3hscjqrowe5ahd7hlfc5p4hb6kdfp6prgy4"
            }
        }))
        .max_gas()
        .deposit(deposit_amount)
        .transact()
        .await?;

    // Create add-on
    let _ = contract
        .call("create_addon")
        .args_json(json!({"addon": {
            "id": "CommunityAddOnId",
            "title": "GitHub AddOn",
            "description": "Current status of NEARCORE repo",
            "view_widget": "custom-viewer-widget",
            "configurator_widget": "github-configurator",
            "icon": "bi bi-github",
        }}))
        .max_gas()
        .transact()
        .await?;

    let _ = contract
        .call("set_community_addons")
        .args_json(json!({
            "handle": "gotham",
            "addons": [{
                "id": "unique",
                "addon_id": "CommunityAddOnId",
                "display_name": "GitHub",
                "enabled": true,
                "parameters": ""
            }]
        }))
        .max_gas()
        .transact()
        .await?;

    let get_community: serde_json::Value = contract
        .call("get_community")
        .args_json(json!({
            "handle" : "gotham"
        }))
        .view()
        .await?
        .json()?;

    assert_eq!(get_community["addons"][0]["display_name"].as_str(), Some("GitHub"));

    Ok(())
}

#[tokio::test]
async fn test_update_community() -> anyhow::Result<()> {
    // Initialize the devhub and near social contract on chain,
    // contract is devhub contract instance.
    let (contract, _, _) = init_contracts_from_res().await?;

    let deposit_amount = NearToken::from_near(4);

    // Add a community
    let _create_community = contract
        .call("create_community")
        .args_json(json!({
            "inputs": {
                "handle": "gotham",
                "name": "Gotham",
                "tag": "some",
                "description": "This is a test community.",
                "bio_markdown": "This is a sample text about your community.\nYou can change it on the community configuration page.",
                "logo_url": "https://ipfs.near.social/ipfs/bafkreibysr2mkwhb4j36h2t7mqwhynqdy4vzjfygfkfg65kuspd2bawauu",
                "banner_url": "https://ipfs.near.social/ipfs/bafkreic4xgorjt6ha5z4s5e3hscjqrowe5ahd7hlfc5p4hb6kdfp6prgy4"
            }
        }))
        .max_gas()
        .deposit(deposit_amount)
        .transact()
        .await?;

    let _update_community = contract
        .call("update_community")
        .args_json(json!({
            "handle": "gotham",
            "community": {
                "admins": [],
                "handle": "gotham",
                "name": "Gotham2",
                "tag": "other",
                "description": "This is a test community.",
                "bio_markdown": "This is a sample text about your community.\nYou can change it on the community configuration page.",
                "logo_url": "https://ipfs.near.social/ipfs/bafkreibysr2mkwhb4j36h2t7mqwhynqdy4vzjfygfkfg65kuspd2bawauu",
                "banner_url": "https://ipfs.near.social/ipfs/bafkreic4xgorjt6ha5z4s5e3hscjqrowe5ahd7hlfc5p4hb6kdfp6prgy4",
                "addons": []
            }
        }))
        .max_gas()
        .transact()
        .await?;

    let get_community: serde_json::Value = contract
        .call("get_community")
        .args_json(json!({
            "handle" : "gotham"
        }))
        .view()
        .await?
        .json()?;

    assert_eq!(get_community["tag"].as_str(), Some("other"));
    assert_eq!(get_community["name"].as_str(), Some("Gotham2"));

    Ok(())
}

#[tokio::test]
async fn test_announcement() -> anyhow::Result<()> {
    // Initialize the devhub and near social contract on chain,
    // contract is devhub contract instance.
    let (contract, worker, _) = init_contracts_from_res().await?;

    let deposit_amount = NearToken::from_near(4);

    // Add a community
    let _create_community = contract
        .call("create_community")
        .args_json(json!({
            "inputs": {
                "handle": "gotham",
                "name": "Gotham",
                "tag": "some",
                "description": "This is a test community.",
                "bio_markdown": "This is a sample text about your community.\nYou can change it on the community configuration page.",
                "logo_url": "https://ipfs.near.social/ipfs/bafkreibysr2mkwhb4j36h2t7mqwhynqdy4vzjfygfkfg65kuspd2bawauu",
                "banner_url": "https://ipfs.near.social/ipfs/bafkreic4xgorjt6ha5z4s5e3hscjqrowe5ahd7hlfc5p4hb6kdfp6prgy4"
            }
        }))
        .max_gas()
        .deposit(deposit_amount)
        .transact()
        .await?;

    println!("{:?}", _create_community);

    let community_account = "gotham.community.devhub.near".parse()?;

    // assert community account exists
    let _ = worker.view_account(&community_account).await?;

    // create announcement
    let create_announcement = contract
        .call("set_community_socialdb")
        .args_json(json!({
            "handle": "gotham",
            "data": {
                "post": {
                    "main": "{\"type\":\"md\",\"text\":\"what's up\"}"
                },
                "index": {
                    "post": "{\"key\":\"main\",\"value\":{\"type\":\"md\"}}"
                }
            }
        }))
        .max_gas()
        .transact()
        .await?;

    assert!(create_announcement.is_success());

    let near_social_account = "social.near".parse()?;
    let data: serde_json::Value = worker
        .view(&near_social_account, "get")
        .args_json(json!({"keys": ["gotham.community.devhub.near/**"]}))
        .await?
        .json()?;

    assert_eq!(
        data["gotham.community.devhub.near"]["post"]["main"].as_str(),
        Some("{\"type\":\"md\",\"text\":\"what's up\"}")
    );

    // update community, intend to change name and logo
    let _update_community = contract
    .call("update_community")
    .args_json(json!({
        "handle": "gotham",
        "community": {
            "admins": [],
            "handle": "gotham",
            "name": "Gotham2",
            "tag": "some",
            "description": "This is a test community.",
            "bio_markdown": "This is a sample text about your community.\nYou can change it on the community configuration page.",
            "logo_url": "https://example.com/image.png",
            "banner_url": "https://ipfs.near.social/ipfs/bafkreic4xgorjt6ha5z4s5e3hscjqrowe5ahd7hlfc5p4hb6kdfp6prgy4",
            "addons": []
        }
    }))
    .max_gas()
    .transact()
    .await?;

    let near_social_account = "social.near".parse()?;
    let data: serde_json::Value = worker
        .view(&near_social_account, "get")
        .args_json(json!({"keys": ["gotham.community.devhub.near/**"]}))
        .await?
        .json()?;

    assert_eq!(data["gotham.community.devhub.near"]["profile"]["name"].as_str(), Some("Gotham2"));
    assert_eq!(
        data["gotham.community.devhub.near"]["profile"]["image"]["url"].as_str(),
        Some("https://example.com/image.png")
    );

    Ok(())
}

#[tokio::test]
async fn test_discussions() -> anyhow::Result<()> {
    // Initialize the devhub and near social contract on chain,
    // contract is devhub contract instance.
    let (contract, worker, near_social) = init_contracts_from_res().await?;

    let deposit_amount = NearToken::from_near(6);

    // Add a community
    let _ = contract
        .call("create_community")
        .args_json(json!({
            "inputs": {
                "handle": "gotham",
                "name": "Gotham",
                "tag": "some",
                "description": "This is a test community.",
                "bio_markdown": "This is a sample text about your community.\nYou can change it on the community configuration page.",
                "logo_url": "https://ipfs.near.social/ipfs/bafkreibysr2mkwhb4j36h2t7mqwhynqdy4vzjfygfkfg65kuspd2bawauu",
                "banner_url": "https://ipfs.near.social/ipfs/bafkreic4xgorjt6ha5z4s5e3hscjqrowe5ahd7hlfc5p4hb6kdfp6prgy4"
            }
        }))
        .max_gas()
        .deposit(deposit_amount)
        .transact()
        .await?;

    let community_account = "gotham.community.devhub.near".parse()?;
    let discussions_account = "discussions.gotham.community.devhub.near".parse()?;

    // assert community account exists
    let _ = worker.view_account(&community_account).await?;
    // assert discussions account exists
    let _ = worker.view_account(&discussions_account).await?;

    // grant write permission to discussions account from a user
    let user = worker.dev_create_account().await?;

    let deposit_amount = NearToken::from_near(1);

    // user make a post on social.near
    let create_post = user
        .call(near_social.id(), "set")
        .args_json(json!({
            "data": {
              user.id().to_string(): {
                "post": {
                    "main": "{\"type\":\"md\",\"text\":\"what's up\"}"
                },
                "index": {
                    "post": "{\"key\":\"main\",\"value\":{\"type\":\"md\"}}"
                }
            }
          }
        }))
        .deposit(deposit_amount)
        .max_gas()
        .transact()
        .await?;

    assert!(create_post.is_success());

    let get_block_height: serde_json::Value = worker
        .view(&near_social.id(), "get")
        .args_json(json!({"keys": [format!("{}/**", user.id())], "options": {
          "with_block_height": true,
        }}))
        .await?
        .json()?;

    let block_height = get_block_height[user.id().as_str()]["post"][":block"].clone();
    assert!(block_height.is_number());

    // create discussion as user
    let repost_discussion = user
        .call(contract.id(), "create_discussion")
        .args_json(json!({
            "handle": "gotham",
            "block_height": block_height,
        }))
        .max_gas()
        .transact()
        .await?;

    assert!(repost_discussion.is_success());

    let discussion_data: serde_json::Value = worker
        .view(&near_social.id(), "get")
        .args_json(json!({"keys": ["discussions.gotham.community.devhub.near/index/**"]}))
        .await?
        .json()?;

    let post_initiator = user.id().to_string();
    let repost = format!("[{{\"key\":\"main\",\"value\":{{\"type\":\"repost\",\"item\":{{\"type\":\"social\",\"path\":\"{}/post/main\",\"blockHeight\":{}}}}}}},{{\"key\":{{\"type\":\"social\",\"path\":\"{}/post/main\",\"blockHeight\":{}}},\"value\":{{\"type\":\"repost\"}}}}]", post_initiator, block_height, post_initiator, block_height);

    assert_eq!(
        discussion_data["discussions.gotham.community.devhub.near"]["index"]["repost"].as_str(),
        Some(repost.as_str())
    );

    Ok(())
}

'''
'''--- tests/migration.rs ---
mod test_env;

use near_sdk::NearToken;
use {crate::test_env::*, serde_json::json};

#[tokio::test]
async fn test_deploy_contract_self_upgrade() -> anyhow::Result<()> {
    // Test Flow:
    // 1. Deploy devhub and near social contract on sandbox
    // 2. Add all kinds of posts and add a community.
    // 3. Upgrade the contract.
    // 4. Get all the posts and community and check if migration was successful.

    // Initialize the devhub and near social contract on chain,
    // contract is devhub contract instance.
    let contract = init_contracts_from_mainnet().await?;

    let deposit_amount = NearToken::from_millinear(100);

    // Add Posts
    let add_idea_post = contract
        .call("add_post")
        .args_json(json!({
            "parent_id": null,
            "labels": [],
            "body": {
                "name": "This is a test idea.",
                "description": "This is a test description.",
                "post_type": "Idea",
                "idea_version": "V1"
            }
        }))
        .deposit(deposit_amount)
        .transact()
        .await?;

    assert!(add_idea_post.is_success());

    let add_solution_v2_post = contract
        .call("add_post")
        .args_json(json!({
            "parent_id": null,
            "labels": [],
            "body": {
                "name": "Solution Test",
                "description": "This is a test solution post.",
                "post_type": "Solution",
                "requested_sponsor": "neardevgov.near",
                "requested_sponsorship_amount": "1000",
                "requested_sponsorship_token": "NEAR",
                "solution_version": "V2"
            }
        }))
        .deposit(deposit_amount)
        .max_gas()
        .transact()
        .await?;

    assert!(add_solution_v2_post.is_success());

    let add_comment_post = contract
        .call("add_post")
        .args_json(json!({
            "parent_id": 0,
            "labels": [],
            "body": {
                "description": "This is test Comment.",
                "comment_version": "V2",
                "post_type": "Comment"
            }
        }))
        .deposit(deposit_amount)
        .max_gas()
        .transact()
        .await?;

    assert!(add_comment_post.is_success());

    let add_attestation_post = contract
        .call("add_post")
        .args_json(json!({
            "parent_id": 1,
            "labels": [],
            "body": {
                "name": "Attestation",
                "description": "Description",
                "attestation_version": "V1",
                "post_type": "Attestation"
            }
        }))
        .deposit(deposit_amount)
        .max_gas()
        .transact()
        .await?;

    assert!(add_attestation_post.is_success());

    let add_sponsorship_post_with_near = contract
        .call("add_post")
        .args_json(json!({
            "parent_id": 1,
            "labels": [],
            "body": {
                "name": "Contributor fellowship",
                "description": "Funding approved",
                "amount": "1000",
                "sponsorship_token": "NEAR",
                "supervisor": "john.near",
                "sponsorship_version": "V1",
                "post_type": "Sponsorship"
            }
        }))
        .deposit(deposit_amount)
        .max_gas()
        .transact()
        .await?;

    assert!(add_sponsorship_post_with_near.is_success());

    let add_sponsorship_post_with_usd = contract
        .call("add_post")
        .args_json(json!({
            "parent_id": 1,
            "labels": [],
            "body": {
                "name": "Contributor fellowship",
                "description": "Funding approved",
                "amount": "1000",
                "sponsorship_token": "USD",
                "supervisor": "john.near",
                "sponsorship_version": "V1",
                "post_type": "Sponsorship"
            }
        }))
        .deposit(deposit_amount)
        .max_gas()
        .transact()
        .await?;

    assert!(add_sponsorship_post_with_usd.is_success());

    let add_sponsorship_post_with_nep141 = contract
        .call("add_post")
        .args_json(json!({
            "parent_id": 1,
            "labels": [],
            "body": {
                "name": "Contributor fellowship",
                "description": "Funding approved",
                "amount": "1000",
                "sponsorship_token": {
                    "NEP141": {
                        "address": "usdt.tether-token.near"
                    }
                },
                "supervisor": "john.near",
                "sponsorship_version": "V1",
                "post_type": "Sponsorship"
            }
        }))
        .deposit(deposit_amount)
        .max_gas()
        .transact()
        .await?;

    assert!(add_sponsorship_post_with_nep141.is_success());

    // Add a community
    let create_community = contract
        .call("create_community")
        .args_json(json!({
            "inputs": {
                "handle": "gotham",
                "name": "Gotham",
                "tag": "some",
                "description": "This is a test community.",
                "bio_markdown": "This is a sample text about your community.\nYou can change it on the community configuration page.",
                "logo_url": "https://ipfs.near.social/ipfs/bafkreibysr2mkwhb4j36h2t7mqwhynqdy4vzjfygfkfg65kuspd2bawauu",
                "banner_url": "https://ipfs.near.social/ipfs/bafkreic4xgorjt6ha5z4s5e3hscjqrowe5ahd7hlfc5p4hb6kdfp6prgy4"
            }
        }))
        .deposit(NearToken::from_near(4))
        .max_gas()
        .transact()
        .await?;

    assert!(dbg!(create_community).is_success());

    // Call self upgrade with current branch code
    // compile the current code
    let wasm = near_workspaces::compile_project("./").await?;

    let mut contract_upgrade_result =
        contract.call("unsafe_self_upgrade").args(wasm).max_gas().transact().await?;

    while contract_upgrade_result.json::<String>()? == "needs-migration" {
        contract_upgrade_result =
            contract.call("unsafe_migrate").args_json(json!({})).max_gas().transact().await?;
    }

    let get_idea_post: serde_json::Value = contract
        .call("get_post")
        .args_json(json!({
            "post_id" : 0
        }))
        .view()
        .await?
        .json()?;

    insta::assert_json_snapshot!(get_idea_post, {".snapshot.timestamp" => "[timestamp]"});

    let get_solution_v2_post: serde_json::Value = contract
        .call("get_post")
        .args_json(json!({
            "post_id" : 1
        }))
        .view()
        .await?
        .json()?;

    insta::assert_json_snapshot!(get_solution_v2_post, {".snapshot.timestamp" => "[timestamp]"});

    let get_comment_posts: serde_json::Value = contract
        .call("get_posts")
        .args_json(json!({
            "parent_id" : 0
        }))
        .view()
        .await?
        .json()?;

    insta::assert_json_snapshot!(get_comment_posts, {"[].snapshot.timestamp" => "[timestamp]"});

    let get_attestation_sponsorship_posts: serde_json::Value = contract
        .call("get_posts")
        .args_json(json!({
            "parent_id" : 1
        }))
        .view()
        .await?
        .json()?;

    insta::assert_json_snapshot!(get_attestation_sponsorship_posts, {"[].snapshot.timestamp" => "[timestamp]"});

    let get_sponsorship_post_with_near: serde_json::Value = contract
        .call("get_post")
        .args_json(json!({
            "post_id" : 4
        }))
        .view()
        .await?
        .json()?;

    insta::assert_json_snapshot!(get_sponsorship_post_with_near, {".snapshot.timestamp" => "[timestamp]"});

    let get_sponsorship_post_with_usd: serde_json::Value = contract
        .call("get_post")
        .args_json(json!({
            "post_id" : 5
        }))
        .view()
        .await?
        .json()?;

    insta::assert_json_snapshot!(get_sponsorship_post_with_usd, {".snapshot.timestamp" => "[timestamp]"});

    let get_sponsorship_post_with_nep141: serde_json::Value = contract
        .call("get_post")
        .args_json(json!({
            "post_id" : 6
        }))
        .view()
        .await?
        .json()?;

    insta::assert_json_snapshot!(get_sponsorship_post_with_nep141, {".snapshot.timestamp" => "[timestamp]"});

    let get_community: serde_json::Value = contract
        .call("get_community")
        .args_json(json!({
            "handle" : "gotham"
        }))
        .view()
        .await?
        .json()?;

    insta::assert_json_snapshot!(get_community);

    Ok(())
}

'''
'''--- tests/proposals.rs ---
mod test_env;

use near_sdk::NearToken;
use serde_json::Value;
use {crate::test_env::*, serde_json::json};

#[tokio::test]
async fn test_proposal() -> anyhow::Result<()> {
    // Initialize the devhub and near social contract on chain,
    // contract is devhub contract instance.
    let (contract, worker, near_social) = init_contracts_from_res().await?;

    let deposit_amount = NearToken::from_near(2);

    let _add_proposal = contract
        .call("add_proposal")
        .args_json(json!({
            "body": {
                "proposal_body_version": "V0",
                "name": "another post",
                "description": "some description",
                "category": "Marketing",
                "summary": "sum",
                "linked_proposals": [1, 3],
                "requested_sponsorship_usd_amount": "1000000000",
                "requested_sponsorship_paid_in_currency": "USDT",
                "receiver_account": "polyprogrammist.near",
                "supervisor": "frol.near",
                "requested_sponsor": "neardevdao.near",
                "timeline": {"status": "DRAFT"}
            },
            "labels": ["test1", "test2"],
        }))
        .max_gas()
        .deposit(deposit_amount)
        .transact()
        .await?;

    let get_proposal: serde_json::Value = contract
        .call("get_proposal")
        .args_json(json!({
            "proposal_id" : 0
        }))
        .view()
        .await?
        .json()?;

    assert_eq!(get_proposal["snapshot"]["category"], "Marketing");

    let social_db_post_block_height: u64 =
        get_proposal["social_db_post_block_height"].as_str().unwrap().parse::<u64>()?;
    assert!(social_db_post_block_height > 0);

    let first_proposal_social_post = String::from_utf8(
        near_social
            .call("get")
            .args_json(json!({"keys": [format!("{}/post/main", contract.id())]}))
            .view()
            .await?
            .result,
    )
    .unwrap();

    assert_eq!(first_proposal_social_post, "{\"devhub.near\":{\"post\":{\"main\":\"{\\\"type\\\":\\\"md\\\",\\\"text\\\":\\\"We have just received a new *Marketing* proposal.\\\\n\\\\n\\\\n\\\\n**By**: @devhub.near\\\\n\\\\n**Title**: another post\\\\n\\\\n**Summary**:\\\\n\\\\nsum\\\\n\\\\n\\\\n\\\\nRead the full proposal and share your feedback on [DevHub](/devhub.near/widget/app?page=proposal&id=0)\\\"}\"}}}");
    let _edit_proposal_category = contract
        .call("edit_proposal")
        .args_json(json!({
            "id": 0,
            "body": {
                "proposal_body_version": "V0",
                "name": "another post",
                "description": "some description",
                "category": "Events",
                "summary": "sum",
                "linked_proposals": [1, 3],
                "requested_sponsorship_usd_amount": "1000000000",
                "requested_sponsorship_paid_in_currency": "USDT",
                "receiver_account": "polyprogrammist.near",
                "supervisor": "frol.near",
                "requested_sponsor": "neardevdao.near",
                "timeline": {"status": "REVIEW", "sponsor_requested_review": true, "reviewer_completed_attestation": false }
            },
            "labels": ["test1", "test2"],
        }))
        .max_gas()
        .deposit(deposit_amount)
        .transact()
        .await?;

    let get_proposal_with_new_category: serde_json::Value = contract
        .call("get_proposal")
        .args_json(json!({
            "proposal_id" : 0
        }))
        .view()
        .await?
        .json()?;

    assert_eq!(get_proposal_with_new_category["snapshot"]["category"], "Events");

    let _add_second_proposal = contract
        .call("add_proposal")
        .args_json(json!({
            "body": {
                "proposal_body_version": "V0",
                "name": "One more",
                "description": "some description",
                "category": "Events",
                "summary": "sum",
                "linked_proposals": [],
                "requested_sponsorship_usd_amount": "200",
                "requested_sponsorship_paid_in_currency": "NEAR",
                "receiver_account": "polyprogrammist.near",
                "supervisor": "frol.near",
                "requested_sponsor": "neardevdao.near",
                "timeline": {"status": "DRAFT"}
            },
            "labels": ["test3"],
        }))
        .max_gas()
        .deposit(deposit_amount)
        .transact()
        .await?;

    let get_proposals =
        contract.call("get_proposals").args_json(json!({})).view().await?.json::<Value>()?;

    let proposals_array = get_proposals.as_array().unwrap();

    assert_eq!(proposals_array.len(), 2);
    assert_eq!(proposals_array.get(1).unwrap()["snapshot"]["name"], "One more");

    let get_proposal_ids =
        contract.call("get_all_proposal_ids").args_json(json!({})).view().await?.json::<Value>()?;

    let proposal_ids = get_proposal_ids
        .as_array()
        .unwrap()
        .iter()
        .map(|x| x.clone().as_u64().unwrap())
        .collect::<Vec<_>>();

    let expected_ids: Vec<u64> = [0u64, 1u64].to_vec();

    assert_eq!(proposal_ids, expected_ids);

    let second_account = worker
        .root_account()?
        .create_subaccount("second")
        .initial_balance(NearToken::from_near(20))
        .transact()
        .await?
        .into_result()?;

    let _second_author_add_proposal = second_account
        .call(contract.id(), "add_proposal")
        .args_json(json!({
            "body": {
                "proposal_body_version": "V0",
                "name": "another author",
                "description": "some description",
                "category": "Events",
                "summary": "sum",
                "linked_proposals": [1, 3],
                "requested_sponsorship_usd_amount": "1000000000",
                "requested_sponsorship_paid_in_currency": "USDT",
                "receiver_account": "polyprogrammist.near",
                "supervisor": "frol.near",
                "requested_sponsor": "neardevdao.near",
                "timeline": {"status": "DRAFT"}
            },
            "labels": ["test2", "test3"],
        }))
        .max_gas()
        .deposit(NearToken::from_near(1))
        .transact()
        .await?;

    let second_proposal_social_post = String::from_utf8(
        near_social
            .call("get")
            .args_json(json!({"keys": [format!("{}/post/main", contract.id())]}))
            .view()
            .await?
            .result,
    )
    .unwrap();

    assert_eq!(second_proposal_social_post, "{\"devhub.near\":{\"post\":{\"main\":\"{\\\"type\\\":\\\"md\\\",\\\"text\\\":\\\"We have just received a new *Events* proposal.\\\\n\\\\n\\\\n\\\\n**By**: @second.test.near\\\\n\\\\n**Title**: another author\\\\n\\\\n**Summary**:\\\\n\\\\nsum\\\\n\\\\n\\\\n\\\\nRead the full proposal and share your feedback on [DevHub](/devhub.near/widget/app?page=proposal&id=2)\\\"}\"}}}");

    let get_second_author_proposal: serde_json::Value = contract
        .call("get_proposal")
        .args_json(json!({
            "proposal_id" : 2
        }))
        .view()
        .await?
        .json()?;

    assert_eq!(get_second_author_proposal["author_id"], "second.test.near");

    let get_proposals_by_author = contract
        .call("get_proposals_by_author")
        .args_json(json!({
            "author": "devhub.near"
        }))
        .view()
        .await?
        .json::<Value>()?;

    let proposals_array = get_proposals_by_author.as_array().unwrap();

    assert_eq!(proposals_array.len(), 2);

    let get_proposals_by_label = contract
        .call("get_proposals_by_label")
        .args_json(json!({
            "label": "test2"
        }))
        .view()
        .await?
        .json::<Value>()?;

    let proposal_ids_by_label = get_proposals_by_label
        .as_array()
        .unwrap()
        .iter()
        .map(|x| x.as_u64().unwrap())
        .collect::<Vec<_>>();

    let expected_ids: Vec<u64> = [0u64, 2u64].to_vec();
    assert_eq!(proposal_ids_by_label, expected_ids);

    let get_all_proposal_labels = contract
        .call("get_all_proposal_labels")
        .args_json(json!({}))
        .view()
        .await?
        .json::<Value>()?;

    let proposal_labels = get_all_proposal_labels
        .as_array()
        .unwrap()
        .iter()
        .map(|x| x.as_str().unwrap())
        .collect::<Vec<_>>();

    let expected_labels: Vec<&str> = ["test1", "test2", "test3"].to_vec();
    assert_eq!(proposal_labels, expected_labels);

    let get_all_proposal_authors = contract
        .call("get_all_proposal_authors")
        .args_json(json!({}))
        .view()
        .await?
        .json::<Value>()?;

    let proposal_authors = get_all_proposal_authors
        .as_array()
        .unwrap()
        .iter()
        .map(|x| x.as_str().unwrap())
        .collect::<Vec<_>>();

    let expected_authors: Vec<&str> = ["devhub.near", "second.test.near"].to_vec();
    assert_eq!(proposal_authors, expected_authors);

    let is_allowed_to_edit_proposal_false = contract
        .call("is_allowed_to_edit_proposal")
        .args_json(json!({
            "proposal_id": 0,
            "editor": "second.test.near"
        }))
        .view()
        .await?
        .json::<Value>()?;

    assert!(!is_allowed_to_edit_proposal_false.as_bool().unwrap());

    let is_allowed_to_edit_proposal_true = contract
        .call("is_allowed_to_edit_proposal")
        .args_json(json!({
            "proposal_id": 0,
            "editor": "devhub.near"
        }))
        .view()
        .await?
        .json::<Value>()?;

    assert!(is_allowed_to_edit_proposal_true.as_bool().unwrap());

    let get_all_allowed_proposal_labels = contract
        .call("get_all_allowed_proposal_labels")
        .args_json(json!({
            "editor": "devhub.near"
        }))
        .view()
        .await?
        .json::<Value>()?;

    let allowed_proposal_labels = get_all_allowed_proposal_labels
        .as_array()
        .unwrap()
        .iter()
        .map(|x| x.as_str().unwrap())
        .collect::<Vec<_>>();

    let expected_labels: Vec<&str> = ["test1", "test2", "test3"].to_vec();
    assert_eq!(allowed_proposal_labels, expected_labels);

    let add_proposal_incorrect_timeline_status = contract
        .call("add_proposal")
        .args_json(json!({
            "body": {
                "proposal_body_version": "V0",
                "name": "another post",
                "description": "some description",
                "category": "Events",
                "summary": "sum",
                "linked_proposals": [],
                "requested_sponsorship_usd_amount": "1000000000",
                "requested_sponsorship_paid_in_currency": "USDT",
                "receiver_account": "polyprogrammist.near",
                "requested_sponsor": "neardevdao.near",
                "timeline": {"status": "REVIEW", "sponsor_requested_review": true, "reviewer_completed_attestation": false }
            },
            "labels": ["test1", "test2"],
        }))
        .max_gas()
        .deposit(deposit_amount)
        .transact()
        .await?;
    assert!(add_proposal_incorrect_timeline_status.is_failure());

    let edit_proposal_incorrect_timeline_status = second_account.call(contract.id(), "edit_proposal")
        .args_json(json!({
            "id": 2,
            "body": {
                "proposal_body_version": "V0",
                "name": "another post",
                "description": "some description",
                "category": "Events",
                "summary": "sum",
                "linked_proposals": [1, 3],
                "requested_sponsorship_usd_amount": "1000000000",
                "requested_sponsorship_paid_in_currency": "USDT",
                "receiver_account": "polyprogrammist.near",
                "supervisor": "frol.near",
                "requested_sponsor": "neardevdao.near",
                "timeline": {"status": "REVIEW", "sponsor_requested_review": true, "reviewer_completed_attestation": false }
            },
            "labels": ["test1", "test2"],
        }))
        .max_gas()
        .deposit(deposit_amount)
        .transact()
        .await?;

    assert!(edit_proposal_incorrect_timeline_status.is_failure());

    let edit_proposal_to_review = second_account.call(contract.id(), "edit_proposal")
        .args_json(json!({
            "id": 2,
            "body": {
                "proposal_body_version": "V0",
                "name": "another post",
                "description": "some description",
                "category": "Events",
                "summary": "sum",
                "linked_proposals": [1, 3],
                "requested_sponsorship_usd_amount": "1000000000",
                "requested_sponsorship_paid_in_currency": "USDT",
                "receiver_account": "polyprogrammist.near",
                "supervisor": "frol.near",
                "requested_sponsor": "neardevdao.near",
                "timeline": {"status": "REVIEW", "sponsor_requested_review": false, "reviewer_completed_attestation": false }
            },
            "labels": ["test1", "test2"],
        }))
        .max_gas()
        .deposit(deposit_amount)
        .transact()
        .await?;

    assert!(edit_proposal_to_review.is_success());

    let edit_proposal_to_cancelled: near_workspaces::result::ExecutionFinalResult = second_account.call(contract.id(), "edit_proposal")
        .args_json(json!({
            "id": 2,
            "body": {
                "proposal_body_version": "V0",
                "name": "another post",
                "description": "some description",
                "category": "Events",
                "summary": "sum",
                "linked_proposals": [1, 3],
                "requested_sponsorship_usd_amount": "1000000000",
                "requested_sponsorship_paid_in_currency": "USDT",
                "receiver_account": "polyprogrammist.near",
                "supervisor": "frol.near",
                "requested_sponsor": "neardevdao.near",
                "timeline": {"status": "CANCELLED", "sponsor_requested_review": false, "reviewer_completed_attestation": false }
            },
            "labels": ["test1", "test2"],
        }))
        .max_gas()
        .deposit(deposit_amount)
        .transact()
        .await?;

    assert!(edit_proposal_to_cancelled.is_success());

    let set_categories_not_allowed = second_account
        .call(contract.id(), "set_allowed_categories")
        .args_json(json!({"new_categories": ["One", "Two"]}))
        .max_gas()
        .deposit(NearToken::from_near(1))
        .transact()
        .await?;

    assert!(set_categories_not_allowed.is_failure());

    let _set_categories = contract
        .call("set_allowed_categories")
        .args_json(json!({"new_categories": ["Two", "Three"]}))
        .max_gas()
        .deposit(NearToken::from_near(1))
        .transact()
        .await?;

    let get_categories: serde_json::Value =
        contract.call("get_allowed_categories").args_json(json!({})).view().await?.json()?;

    let categories: Vec<String> = get_categories
        .as_array()
        .unwrap()
        .iter()
        .map(|x| String::from(x.clone().as_str().unwrap()))
        .collect::<Vec<_>>();

    assert_eq!(categories, vec!["Two", "Three"]);

    let edit_proposal_incorrect_category = contract
        .call("edit_proposal")
        .args_json(json!({
            "id": 0,
            "body": {
                "proposal_body_version": "V0",
                "name": "another post",
                "description": "some description",
                "category": "bad cat",
                "summary": "sum",
                "linked_proposals": [1, 3],
                "requested_sponsorship_usd_amount": "1000000000",
                "requested_sponsorship_paid_in_currency": "USDT",
                "receiver_account": "polyprogrammist.near",
                "supervisor": "frol.near",
                "requested_sponsor": "neardevdao.near",
                "timeline": {"status": "REVIEW", "sponsor_requested_review": true, "reviewer_completed_attestation": false }
            },
            "labels": ["test1", "test2"],
        }))
        .max_gas()
        .deposit(deposit_amount)
        .transact()
        .await?;

    assert!(edit_proposal_incorrect_category.is_failure());

    let _edit_proposal_timeline_approved = contract
        .call("edit_proposal")
        .args_json(json!({
            "id": 0,
            "body": {
                "proposal_body_version": "V0",
                "name": "another post",
                "description": "some description",
                "category": "Three",
                "summary": "sum",
                "linked_proposals": [1, 3],
                "requested_sponsorship_usd_amount": "1000000000",
                "requested_sponsorship_paid_in_currency": "USDT",
                "receiver_account": "polyprogrammist.near",
                "supervisor": "frol.near",
                "requested_sponsor": "neardevdao.near",
                "timeline": {"status": "APPROVED", "sponsor_requested_review": true, "reviewer_completed_attestation": false }
            },
            "labels": ["test1", "test2"],
        }))
        .max_gas()
        .deposit(deposit_amount)
        .transact()
        .await?;

    assert!(_edit_proposal_timeline_approved.is_success());

    let edit_proposal_to_cancelled_incorrect: near_workspaces::result::ExecutionFinalResult = second_account.call(contract.id(), "edit_proposal")
        .args_json(json!({
            "id": 2,
            "body": {
                "proposal_body_version": "V0",
                "name": "another post",
                "description": "some description",
                "category": "Events",
                "summary": "sum",
                "linked_proposals": [1, 3],
                "requested_sponsorship_usd_amount": "1000000000",
                "requested_sponsorship_paid_in_currency": "USDT",
                "receiver_account": "polyprogrammist.near",
                "supervisor": "frol.near",
                "requested_sponsor": "neardevdao.near",
                "timeline": {"status": "CANCELLED", "sponsor_requested_review": false, "reviewer_completed_attestation": false }
            },
            "labels": ["test1", "test2"],
        }))
        .max_gas()
        .deposit(deposit_amount)
        .transact()
        .await?;

    assert!(edit_proposal_to_cancelled_incorrect.is_failure());

    let _edit_proposal_timeline_rejected = contract
        .call("edit_proposal_timeline")
        .args_json(json!({
            "id": 0,
            "timeline": {"status": "REJECTED", "sponsor_requested_review": true, "reviewer_completed_attestation": false }
        }))
        .max_gas()
        .deposit(deposit_amount)
        .transact()
        .await?;

    assert!(_edit_proposal_timeline_rejected.is_success());

    let _edit_proposal_timeline_conditionally = contract
        .call("edit_proposal_timeline")
        .args_json(json!({
            "id": 0,
            "timeline": {"status": "APPROVED_CONDITIONALLY", "sponsor_requested_review": true, "reviewer_completed_attestation": false }
        }))
        .max_gas()
        .deposit(deposit_amount)
        .transact()
        .await?;

    assert!(_edit_proposal_timeline_conditionally.is_success());

    let _edit_proposal_timeline_payment = contract
        .call("edit_proposal_timeline")
        .args_json(json!({
            "id": 0,
            "timeline": {"status": "PAYMENT_PROCESSING", "kyc_verified": false, "test_transaction_sent": false, "request_for_trustees_created": false, "sponsor_requested_review": true, "reviewer_completed_attestation": false }
        }))
        .max_gas()
        .deposit(deposit_amount)
        .transact()
        .await?;

    assert!(_edit_proposal_timeline_payment.is_success());

    let _edit_proposal_timeline_funded = contract
        .call("edit_proposal_timeline")
        .args_json(json!({
            "id": 0,
            "timeline": {"status": "FUNDED", "trustees_released_payment": false, "kyc_verified": false, "test_transaction_sent": false, "request_for_trustees_created": false, "sponsor_requested_review": true, "reviewer_completed_attestation": false, "payouts": [ "https://nearblocks.io/txns/6UwrzrYqBhA3ft2mDHXtvpzEFwkWhvCauJS1FGKjG37p" ] }
        }))
        .max_gas()
        .deposit(deposit_amount)
        .transact()
        .await?;

    assert!(_edit_proposal_timeline_funded.is_success());

    let get_proposal: serde_json::Value = contract
        .call("get_proposal")
        .args_json(json!({
            "proposal_id" : 0
        }))
        .view()
        .await?
        .json()?;

    assert_eq!(get_proposal["snapshot"]["timeline"]["status"], "FUNDED");

    let _add_team = contract
        .call("add_member")
        .args_json(json!({
            "member": "team:moderators",
            "metadata": {
                "member_metadata_version": "V0",
                "children": [],
                "description": "moderators",
                "parents": [],
                "permissions": {
                    "*": ["use-labels", "edit-post"]
                }
            }
        }))
        .max_gas()
        .deposit(NearToken::from_near(0))
        .transact()
        .await?;

    let _add_member = contract
        .call("add_member")
        .args_json(json!({
            "member": "second.test.near",
            "metadata": {
                "member_metadata_version": "V0",
                "children": [],
                "description": "One of the moderators",
                "parents": ["team:moderators"],
                "permissions": {}
            }
        }))
        .max_gas()
        .deposit(NearToken::from_near(0))
        .transact()
        .await?;

    let is_allowed_to_edit_proposal_again = contract
        .call("is_allowed_to_edit_proposal")
        .args_json(json!({
            "proposal_id": 0,
            "editor": "second.test.near"
        }))
        .view()
        .await?
        .json::<Value>()?;

    assert!(is_allowed_to_edit_proposal_again.as_bool().unwrap());

    Ok(())
}

'''
'''--- tests/test_env.rs ---
use near_sdk::{AccountIdRef, NearToken};
use near_workspaces::network::Sandbox;
use near_workspaces::types::{AccessKey, KeyType, SecretKey};
use near_workspaces::{Account, Worker};

use serde_json::json;

const DEVHUB_CONTRACT_PREFIX: &str = "devhub";
const DEVHUB_CONTRACT: &AccountIdRef = AccountIdRef::new_or_panic("devhub.near");
const DEVHUB_COMMUNITY_CONTRACT: &AccountIdRef =
    AccountIdRef::new_or_panic("community.devhub.near");
const COMMUNITY_FACTORY_PREFIX: &str = "community";
const NEAR_SOCIAL: &AccountIdRef = AccountIdRef::new_or_panic("social.near");
const _TEST_NEAR_SOCIAL: &AccountIdRef = AccountIdRef::new_or_panic("v1.social08.testnet");
const TEST_SEED: &str = "testificate";
const DEVHUB_CONTRACT_PATH: &str = "./target/near/devhub.wasm";
const COMMUNITY_FACTORY_CONTRACT_PATH: &str =
    "./community-factory/target/near/devhub_community_factory.wasm";

#[allow(dead_code)]
pub async fn init_contracts_from_mainnet() -> anyhow::Result<near_workspaces::Contract> {
    let worker = near_workspaces::sandbox().await?;
    let mainnet = near_workspaces::mainnet_archival().await?;

    // NEAR social deployment
    let near_social = worker
        .import_contract(&NEAR_SOCIAL.to_owned(), &mainnet)
        .initial_balance(NearToken::from_near(10000))
        .transact()
        .await?;
    near_social.call("new").transact().await?.into_result()?;
    near_social
        .call("set_status")
        .args_json(json!({
            "status": "Live"
        }))
        .transact()
        .await?
        .into_result()?;

    // Devhub contract deployment
    let devhub_contract = worker
        .import_contract(&DEVHUB_CONTRACT.to_owned(), &mainnet)
        .initial_balance(NearToken::from_near(1000))
        .transact()
        .await?;
    let outcome = devhub_contract.call("new").args_json(json!({})).transact().await?;
    assert!(outcome.is_success());
    assert!(format!("{:?}", outcome).contains("Migrated to version:"));

    // Devhub Community contract deployment
    worker
        .import_contract(&DEVHUB_COMMUNITY_CONTRACT.to_owned(), &mainnet)
        .initial_balance(NearToken::from_near(10))
        .transact()
        .await?;

    Ok(devhub_contract)
}

#[allow(dead_code)]
pub async fn init_contracts_from_res(
) -> anyhow::Result<(near_workspaces::Contract, Worker<Sandbox>, near_workspaces::Contract)> {
    let worker: Worker<Sandbox> = near_workspaces::sandbox().await?;
    let mainnet = near_workspaces::mainnet_archival().await?;

    // NEAR social deployment
    let near_social = worker
        .import_contract(&NEAR_SOCIAL.to_owned(), &mainnet)
        .initial_balance(NearToken::from_near(10000))
        .transact()
        .await?;
    near_social.call("new").transact().await?.into_result()?;
    near_social
        .call("set_status")
        .args_json(json!({
            "status": "Live"
        }))
        .transact()
        .await?
        .into_result()?;

    let contract_wasm = std::fs::read(DEVHUB_CONTRACT_PATH)?;
    let sk = SecretKey::from_seed(KeyType::ED25519, TEST_SEED);

    let _test_near = worker.root_account()?;
    let tla_near = Account::from_secret_key("near".parse()?, sk.clone(), &worker);
    worker
        .patch(tla_near.id())
        .access_key(sk.public_key(), AccessKey::full_access())
        .transact()
        .await?;
    let contract_account = tla_near
        .create_subaccount(DEVHUB_CONTRACT_PREFIX)
        .initial_balance(NearToken::from_near(100))
        .transact()
        .await?
        .into_result()?;
    let contract = contract_account.deploy(&contract_wasm).await?.into_result()?;
    let _outcome = contract.call("new").args_json(json!({})).transact().await?;

    let community_factory_account = contract_account
        .create_subaccount(COMMUNITY_FACTORY_PREFIX)
        .initial_balance(NearToken::from_near(10))
        .transact()
        .await?
        .into_result()?;
    let community_factory_wasm = std::fs::read(COMMUNITY_FACTORY_CONTRACT_PATH)?;
    let _community_factory =
        community_factory_account.deploy(&community_factory_wasm).await?.into_result()?;
    Ok((contract, worker, near_social))
}

'''